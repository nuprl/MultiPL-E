language: d
name: HumanEval_70_strange_sort_list
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto odd = true;\n    long[] result = [];\n    bool[] choosen\
    \ = new bool[lst.length];\n    long min_i = 0L;\n    long max_i = 0L;\n    long\
    \ i = 0L;\n    long min = lst[0];\n    long max = lst[0];\n    while (i < lst.length)\
    \ \n    {\n        if (choosen[i]) \n        {\n            i++;\n           \
    \ continue;\n        }\n        if (odd) \n        {\n            if (lst[i] <\
    \ min) \n            {\n                min = lst[i];\n                min_i =\
    \ i;\n            }\n        }\n        else \n        {\n            if (lst[i]\
    \ > max) \n            {\n                max = lst[i];\n                max_i\
    \ = i;\n            }\n        }\n        i++;\n    }\n    odd = !odd;\n    result\
    \ ~= min;\n    choosen[min_i] = true;\n    result ~= max;\n    choosen[max_i]\
    \ = true;\n    foreach (e; lst) \n    {\n        if (e == min || e == max) \n\
    \        {\n            continue;\n        }\n        if (odd) \n        {\n \
    \           if (e < min) \n            {\n                min = e;\n         \
    \       min_i = i;\n            }\n        }\n        else \n        {\n     \
    \       if (e > max) \n            {\n                max = e;\n             \
    \   max_i = i;\n            }\n        }\n        i++;\n    }\n    if (min !=\
    \ max) \n    {\n        odd = !odd;\n        result ~= min;\n        choosen[min_i]\
    \ = true;\n        result ~= max;\n        choosen[max_i] = true;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmphadecdnu.d(88): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428e7e]

    ??:? long[] tmphadecdnu.strange_sort_list(long[]) [0x428408]

    ??:? void tmphadecdnu.__unittest_L92_C1() [0x428483]

    ??:? void tmphadecdnu.__modtest() [0x428b4c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42c76a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4312b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431764]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x431241]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c741]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int fun'
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length % 2 == 0)\n    {\n        int i = 0;\n        bool\
    \ shift_down = true;\n        while (i < lst.length)\n        {\n            if\
    \ (shift_down)\n            {\n                long min = min(lst[i], lst[i +\
    \ 1]);\n                long max = max(lst[i], lst[i + 1]);\n                lst[i]\
    \ = min;\n                lst[i + 1] = max;\n            }\n            else\n\
    \            {\n                long max = max(lst[i], lst[i + 1]);\n        \
    \        long min = min(lst[i], lst[i + 1]);\n                lst[i] = min;\n\
    \                lst[i + 1] = max;\n            }\n            shift_down = !shift_down;\n\
    \            i += 2;\n        }\n    }\n    else\n    {\n        int i = 0;\n\
    \        bool shift_down = true;\n        while (i < lst.length - 1)\n       \
    \ {\n            if (shift_down)\n            {\n                long min = min(lst[i],\
    \ lst[i + 1]);\n                long max = max(lst[i], lst[i + 1]);\n        \
    \        lst[i] = min;\n                lst[i + 1] = max;\n            }\n   \
    \         else\n            {\n                long max = max(lst[i], lst[i +\
    \ 1]);\n                long min = min(lst[i], lst[i + 1]);\n                lst[i]\
    \ = min;\n                lst[i + 1] = max;\n            }\n            shift_down\
    \ = !shift_down;\n            i += 2;\n        }\n    }\n    return lst;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvtm_zdls.d(28): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpvtm_zdls.d(29): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpvtm_zdls.d(35): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpvtm_zdls.d(36): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpvtm_zdls.d(52): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpvtm_zdls.d(53): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpvtm_zdls.d(59): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpvtm_zdls.d(60): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvtm_zdls.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto sorted = sort(lst);\n    if (lst.length() % 2 == 0)\n   \
    \ {\n        long[] result = new long[lst.length()];\n        for (int i = 0;\
    \ i < lst.length(); i++)\n        {\n            if (i % 2 == 0)\n           \
    \ {\n                result[i] = sorted[i / 2];\n            }\n            else\n\
    \            {\n                result[i] = sorted[lst.length() - i / 2 - 1];\n\
    \            }\n        }\n        return result;\n    }\n    else\n    {\n  \
    \      long[] result = new long[lst.length()];\n        for (int i = 0; i < lst.length();\
    \ i++)\n        {\n            if (i % 2 == 0)\n            {\n              \
    \  result[i] = sorted[i / 2];\n            }\n            else\n            {\n\
    \                result[i] = sorted[lst.length() - i / 2 - 1];\n            }\n\
    \        }\n        return result;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ba2952i.d(20): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp1ba2952i.d(21): Error: no property `length` for type `long[]`

    /tmp/tmp1ba2952i.d(23): Error: no property `length` for type `long[]`

    /tmp/tmp1ba2952i.d(24): Error: no property `length` for type `long[]`

    /tmp/tmp1ba2952i.d(39): Error: no property `length` for type `long[]`

    /tmp/tmp1ba2952i.d(40): Error: no property `length` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ba2952i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    lst = lst.dup;\n    lst.sort;\n    long[] lst1;\n    long[] lst2;\n\
    \    if (lst.length == 0)\n    {\n        return [];\n    }\n    else if (lst.length\
    \ % 2 == 0)\n    {\n        lst1 = lst[0..$/2];\n        lst2 = lst[$/2..$];\n\
    \    }\n    else\n    {\n        lst1 = lst[0..$/2];\n        lst2 = lst[$/2+1..$];\n\
    \    }\n    long[] result = new long[0];\n    while (lst1.length != 0 && lst2.length\
    \ != 0)\n    {\n        result ~= lst1.front;\n        result ~= lst2.back;\n\
    \        lst1 = lst1[1..$];\n        lst2 = lst2[0..$-1];\n    }\n    if (lst1.length\
    \ != 0)\n    {\n        result ~= lst1.front;\n    }\n    else if (lst2.length\
    \ != 0)\n    {\n        result ~= lst2.front;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8o8_kkyf.d(21): Error: no property `sort` for type `long[]`

    /tmp/tmp8o8_kkyf.d(41): Error: no property `front` for type `long[]`

    /tmp/tmp8o8_kkyf.d(42): Error: no property `back` for type `long[]`

    /tmp/tmp8o8_kkyf.d(48): Error: no property `front` for type `long[]`

    /tmp/tmp8o8_kkyf.d(52): Error: no property `front` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8o8_kkyf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    alias MinMax = Tuple!(long, long);\n    immutable MinMax minmax\
    \ = lst[0 .. $ - 1].map!((el) {\n        return tuple(el, el);\n    }).reduce!(MinMax.minMax);\n\
    \    immutable MinMax maxmin = lst[0 .. $ - 1].map!((el) {\n        return tuple(el,\
    \ el);\n    }).reduce!(MinMax.maxMin);\n    long min = minmax[0];\n    long max\
    \ = maxmin[1];\n    long[] strange_sorted = new long[]($);\n    int i = 0;\n \
    \   while (i < $) {\n        strange_sorted[i] = min;\n        i++;\n        if\
    \ (i < $) {\n            strange_sorted[i] = max;\n            i++;\n        }\n\
    \    }\n    return strange_sorted;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpld9vsddc.d(29): Error: `$` is valid only inside [] of index or
    slice

    /tmp/tmpld9vsddc.d(31): Error: `$` is valid only inside [] of index or slice

    /tmp/tmpld9vsddc.d(34): Error: `$` is valid only inside [] of index or slice

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpld9vsddc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long max = max(lst);\n    long min = min(lst);\n    long[] res\
    \ = typeof(res).init;\n    immutable bool increase = true;\n    foreach(i; lst)\
    \ \n    {\n        if(increase) \n        {\n            auto x = min;\n     \
    \       foreach(k; lst)\n            {\n                if(k > x) \n         \
    \       {\n                    if(k < max) \n                    {\n         \
    \               x = k;\n                    }\n                }\n           \
    \ }\n            max = x;\n            res ~= x;\n            increase = false;\n\
    \        }\n        else \n        {\n            auto x = max;\n            foreach(k;\
    \ lst)\n            {\n                if(k < x) \n                {\n       \
    \             if(k > min) \n                    {\n                        x =\
    \ k;\n                    }\n                }\n            }\n            min\
    \ = x;\n            res ~= x;\n            increase = true;\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ymyz9vp.d(20): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmp_ymyz9vp.d(21): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp_ymyz9vp.d(22): Error: undefined identifier `res`, did you mean struct
    `Yes`?

    /tmp/tmp_ymyz9vp.d(41): Error: cannot modify `immutable` expression `increase`

    /tmp/tmp_ymyz9vp.d(58): Error: cannot modify `immutable` expression `increase`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ymyz9vp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    struct MinMax\n\
    \    {\n        long min;\n        long max;\n    }\n    \n    MinMax findMinMax(long[]\
    \ lst)\n    {\n        MinMax mm;\n        mm.min = lst[0];\n        mm.max =\
    \ lst[0];\n        foreach (i; 1..lst.length)\n        {\n            if (lst[i]\
    \ < mm.min)\n                mm.min = lst[i];\n            if (lst[i] > mm.max)\n\
    \                mm.max = lst[i];\n        }\n        return mm;\n    }\n    \n\
    \    auto mm = findMinMax(lst);\n    long[] res = new long[lst.length];\n    bool\
    \ descending = false;\n    foreach (i; 0..lst.length)\n    {\n        if (descending)\n\
    \        {\n            res[i] = mm.max;\n            mm.max = mm.max == lst[0]\
    \ ? lst[1] : lst[0];\n        }\n        else\n        {\n            res[i] =\
    \ mm.min;\n            mm.min = mm.min == lst[0] ? lst[1] : lst[0];\n        }\n\
    \        descending = !descending;\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj9zu8i2d.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f35]

    ??:? void tmpj9zu8i2d.__unittest_L63_C1() [0x428346]

    ??:? void tmpj9zu8i2d.__modtest() [0x42899c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d0df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bfee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4311fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4316ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x431189]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bfc5]

    ??:? runModuleUnitTests [0x42ceb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4293f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    import std.algorithm;\n    import std.range;\n    import std.algorithm.sorting;\n\
    \    import std.array;\n    import std.range;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.exception;\n    import std.string;\n    import\
    \ std.math;\n    int min_pos = 0;\n    int max_pos = 0;\n    immutable count =\
    \ lst.length;\n    long[] ret = new long[count];\n    foreach (index; 0..2*count-1)\n\
    \    {\n        if (index % 2 == 0)\n        {\n            ret[index] = lst[min_pos];\n\
    \            if (index + 1 == count)\n            {\n                sort(lst[0..$]);\n\
    \                min_pos = min_pos + 1;\n            }\n            else\n   \
    \         {\n                sort(lst[min_pos+1..$]);\n                min_pos\
    \ = min_pos + 1;\n            }\n        }\n        else\n        {\n        \
    \    ret[index] = lst[max_pos];\n            if (index + 1 == count)\n       \
    \     {\n                sort(lst[0..$]);\n                max_pos = max_pos +\
    \ 1;\n            }\n            else\n            {\n                sort(lst[max_pos+1..$]);\n\
    \                max_pos = max_pos + 1;\n            }\n        }\n    }\n   \
    \ return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpe5asekdd.d(38): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x443e66]

    ??:? long[] tmpe5asekdd.strange_sort_list(long[]) [0x43c601]

    ??:? void tmpe5asekdd.__unittest_L67_C1() [0x43c7df]

    ??:? void tmpe5asekdd.__modtest() [0x441efc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x44d01b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4434e6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x44642d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4465c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4463b9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4434bd]

    ??:? runModuleUnitTests [0x44cdf1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int fun'
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    \n    int length_of_list = lst.length;\n    int length_of_list_divided_by_two\
    \ = length_of_list/2;\n    enum sort_direction { MIN, MAX }\n    sort_direction\
    \ sort_direction = sort_direction.MIN;\n    sort_direction next_sort_direction\
    \ = sort_direction.MAX;\n    long[] result_list = new long[length_of_list];\n\
    \    int source_list_index = 0;\n    for (int i = 0; i < length_of_list_divided_by_two;\
    \ i++)\n    {\n        \n        long max_value = lst[i];\n        int max_value_index\
    \ = i;\n        for (int j = source_list_index + 1; j < length_of_list; j++)\n\
    \        {\n            if(lst[j] > max_value)\n            {\n              \
    \  max_value = lst[j];\n                max_value_index = j;\n            }\n\
    \        }\n        if(sort_direction == sort_direction.MIN)\n        {\n    \
    \        result_list[i] = lst[i];\n            result_list[length_of_list_divided_by_two\
    \ + i] = max_value;\n        }\n        else\n        {\n            result_list[i]\
    \ = max_value;\n            result_list[length_of_list_divided_by_two + i] = lst[i];\n\
    \        }\n        sort_direction = next_sort_direction;\n        next_sort_direction\
    \ = (sort_direction == sort_direction.MIN) ? sort_direction.MAX : sort_direction.MIN;\n\
    \        source_list_index = max_value_index;\n    }\n    if(length_of_list %\
    \ 2 != 0)\n    {\n        result_list[length_of_list - 1] = lst[source_list_index];\n\
    \    }\n    return result_list;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwao3v7n6.d(21): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmpwao3v7n6.d(24): Error: declaration `tmpwao3v7n6.strange_sort_list.sort_direction`
    is already defined

    /tmp/tmpwao3v7n6.d(41): Error: incompatible types for `(sort_direction) == (MIN)`:
    cannot use `==` with types

    /tmp/tmpwao3v7n6.d(51): Error: `sort_direction` is not an lvalue and cannot be
    modified

    /tmp/tmpwao3v7n6.d(52): Error: incompatible types for `(sort_direction) == (MIN)`:
    cannot use `==` with types

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwao3v7n6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // We need an array of tuples,\n    // where first value is `value`\n\
    \    // and second value is `index`.\n    Tuple!(long, long)[] tuples = lst.map!(x\
    \ => tuple(x, lst.indexOf(x)));\n    // We will sort our array of tuples.\n  \
    \  tuples.sort!((x, y) => x[0] < y[0]);\n    // We need to get all values\n  \
    \  // from our array of tuples.\n    long[] values = tuples.map!(x => x[0]).array;\n\
    \    // Finally, we will return array of `long`\n    // where at index of tuple's\
    \ `index` we\n    // will put tuple's `value`.\n    return values.map!(x => tuple(x,\
    \ values.indexOf(x))).array;\n}\n/*\n    Put together two arrays.\n    If odd\
    \ number of elements, let\n    last element from first array\n    be at last position.\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80jcf9qx.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80jcf9qx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int len = lst.length;\n    if (len <= 1)\n        return lst;\n\
    \    long[] res = new long[len];\n    int c = 0;\n    res[c++] = lst[0];\n   \
    \ long[] new_lst = lst[1..$];\n    long min = new_lst[0];\n    long max = new_lst[0];\n\
    \    foreach (el; new_lst)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    res[c++] = max;\n  \
    \  if (len > 2)\n    {\n        for (int i = 0; i < len - 2; i++)\n        {\n\
    \            if (i % 2 == 0)\n            {\n                foreach (el; new_lst)\n\
    \                {\n                    if (el == min)\n                    {\n\
    \                        res[c++] = el;\n                        new_lst -= el;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n            else\n            {\n                foreach (el; new_lst)\n\
    \                {\n                    if (el == max)\n                    {\n\
    \                        res[c++] = el;\n                        new_lst -= el;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n        if (len % 2 == 0)\n            res[c++] = new_lst[0];\n\
    \        else\n            res[c++] = min;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7hafwaet.d(20): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmp7hafwaet.d(48): Error: invalid array operation `new_lst -= el` (possible
    missing [])

    /tmp/tmp7hafwaet.d(60): Error: invalid array operation `new_lst -= el` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7hafwaet.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    immutable(long)[] res = sort(lst);\n    immutable(long)[] tmp\
    \ = res.dup;\n    auto len = lst.length;\n    res = res[0 .. len / 2];\n    if(len\
    \ % 2 != 0)\n    {\n        res ~= tmp[len / 2];\n    }\n    long[] next = tmp[len\
    \ / 2 .. $];\n    foreach(k; 0 .. len / 2)\n    {\n        res ~= next[k];\n \
    \       if(len % 2 == 0 || k < (len / 2) - 1)\n        {\n            res ~= next[len\
    \ / 2 - k - 1];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptr6h68oa.d(20): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmptr6h68oa.d(28): Error: cannot implicitly convert expression `tmp[len /
    2LU..__dollar]` of type `immutable(long)[]` to `long[]`

    /tmp/tmptr6h68oa.d(37): Error: cannot implicitly convert expression `res` of type
    `immutable(long)[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptr6h68oa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    struct list_wrapper\n    {\n        long[] list;\n        size_t\
    \ i;\n        long getElement()\n        {\n            return list[i];\n    \
    \    }\n        void increment()\n        {\n            i++;\n        }\n   \
    \     bool isEmpty()\n        {\n            return i == list.length;\n      \
    \  }\n    }\n    auto min_max(list_wrapper lw)\n    {\n        static if (is(typeof(lw.list[0])\
    \ == long))\n        {\n            long max = lw.getElement();\n            long\
    \ min = lw.getElement();\n            lw.increment();\n            while (!lw.isEmpty())\n\
    \            {\n                max = max(max, lw.getElement());\n           \
    \     min = min(min, lw.getElement());\n                lw.increment();\n    \
    \        }\n            return tuple(min, max);\n        }\n        else\n   \
    \     {\n            // static assert(0, \"Sorry, this sorting is only available\
    \ for integers\");\n            return tuple(0L, 0L);\n        }\n    }\n    auto\
    \ wrapper = list_wrapper(lst, 0);\n    long[] result;\n    auto t = min_max(wrapper);\n\
    \    while (!wrapper.isEmpty())\n    {\n        result ~= t[0];\n        result\
    \ ~= t[1];\n        wrapper.increment();\n        t = min_max(wrapper);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8yvw9qfo.d(46): Error: function expected before `()`, not `max`
    of type `long`

    /tmp/tmp8yvw9qfo.d(47): Error: function expected before `()`, not `min` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8yvw9qfo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] original_list = lst;\n    auto len = lst.length;\n    long[]\
    \ first_half_list = lst[0..len/2];\n    long[] second_half_list = lst[len/2..$];\n\
    \    long[] mixed_list = [];\n    long[] mixed_list_index = [];\n    long[] mixed_list_index_to_not_add\
    \ = [];\n    // long longest_list_length = max(first_half_list.length, second_half_list.length);\n\
    \    if (len > 0)\n    {\n        for (int x = 0; x < len; x++)\n        {\n \
    \           if (x%2 == 0)\n            {\n                mixed_list ~= first_half_list[x/2];\n\
    \                mixed_list_index ~= (x/2);\n            }\n            else\n\
    \            {\n                mixed_list ~= second_half_list[x/2];\n       \
    \         mixed_list_index ~= (len/2 + x/2);\n            }\n        }\n     \
    \   // writefln(\"mixed_list_index_to_not_add.length = %s\", mixed_list_index_to_not_add.length);\n\
    \        // writefln(\"mixed_list_index_to_not_add = %s\", mixed_list_index_to_not_add);\n\
    \        // writefln(\"mixed_list = %s\", mixed_list);\n        // writefln(\"\
    mixed_list_index = %s\", mixed_list_index);\n        // writefln(\"original_list\
    \ = %s\", original_list);\n        long[] array_of_same_value = [];\n        for\
    \ (int x = 0; x < len; x++)\n        {\n            if (!(mixed_list_index_to_not_add.find(x)))\n\
    \            {\n                long max_value = max(mixed_list);\n          \
    \      long min_value = min(mixed_list);\n                long index_of_max_value\
    \ = mixed_list.find(max_value);\n                long index_of_min_value = mixed_list.find(min_value);\n\
    \                if\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpktku5udh.d(58): Error: found `unittest` when expecting `(`

    /tmp/tmpktku5udh.d(72): Error: found `void` when expecting `)`

    /tmp/tmpktku5udh.d(72): Error: found `{` when expecting `;` following statement

    /tmp/tmpktku5udh.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpktku5udh.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpktku5udh.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpktku5udh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ sort(lst);\n    size_t n = lst.length;\n    size_t i = 0;\n    size_t j = n\
    \ - 1;\n    size_t k = 0;\n    long[] res = new long[n];\n    while (k < n) \n\
    \    {\n        res[k++] = lst[i++];\n        if (k < n) \n        {\n       \
    \     res[k++] = lst[j--];\n        }\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn_adun09.d(24): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn_adun09.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] output;\n    if (lst.length == 0)\n    {\n        return\
    \ output;\n    }\n    else if (lst.length == 1)\n    {\n        output ~= lst[0];\n\
    \        return output;\n    }\n    long[] tmp = lst.dup;\n    long[] sorted =\
    \ tmp.sort;\n    long[] a = sorted[0..$/2];\n    long[] b = sorted[$/2..$];\n\
    \    a.reverse;\n    b.reverse;\n    foreach(a; b) \n    {\n        output ~=\
    \ a.front;\n        output ~= b.front;\n        a.popFront;\n        b.popFront;\n\
    \    }\n    if (a.length > 0)\n    {\n        output ~= a.front;\n    }\n    return\
    \ output;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2td0wgie.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmp2td0wgie.d(34): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmp2td0wgie.d(35): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmp2td0wgie.d(36): Error: variable `a` is shadowing variable `tmp2td0wgie.strange_sort_list.a`

    /tmp/tmp2td0wgie.d(38): Error: no property `front` for type `long`

    /tmp/tmp2td0wgie.d(39): Error: no property `front` for type `long[]`

    /tmp/tmp2td0wg'
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto tpl = minMax(lst);\n    if (tpl[0] == tpl[1])\n        return\
    \ lst;\n    long min = tpl[0];\n    long max = tpl[1];\n    long[] lstSort = lst.retro;\n\
    \    lstSort -= lstSort.idup.array;\n    long[] newList = [];\n    while (lstSort.length\
    \ > 0)\n    {\n        auto tpl = minMax(lstSort);\n        min = tpl[0];\n  \
    \      max = tpl[1];\n        newList ~= min;\n        newList ~= max;\n     \
    \   lstSort -= [min, max];\n    }\n    return newList;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpda_x0104.d(20): Error: undefined identifier `minMax`

    /tmp/tmpda_x0104.d(25): Error: no property `retro` for type `long[]`

    /tmp/tmpda_x0104.d(26): Error: no property `array` for type `immutable(long)[]`

    /tmp/tmpda_x0104.d(30): Error: undefined identifier `minMax`

    /tmp/tmpda_x0104.d(30): Error: variable `tpl` is shadowing variable `tmpda_x0104.strange_sort_list.tpl`

    /tmp/tmpda_x0104.d(35): Error: invalid array operation `lstSort -= [min, max]`
    (possible missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpda_x0104.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // TODO: Implement strange_sort_list here.\n    return lst;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3zmjmewf.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x4287d5]

    ??:? void tmp3zmjmewf.__unittest_L23_C1() [0x427f02]

    ??:? void tmp3zmjmewf.__modtest() [0x428558]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b676]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430809]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430795]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b64d]

    ??:? runModuleUnitTests [0x42c5b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c24]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto sort_range = retuple(lst[0L..$ / 2L], lst[($ / 2L)..$]);\n\
    \    auto sort_min = sort_range[0L].sort();\n    auto sort_max = sort_range[1L].sort(std.algorithm.sorting.greater);\n\
    \    return zip!((x, y) => tuple(x, y))(sort_min, sort_max).flatMap!(a => [a[0],\
    \ a[1]]);\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphb1stzhi.d(20): Error: undefined identifier `retuple`, did you
    mean template `tuple(Names...)`?

    /tmp/tmphb1stzhi.d(23): Error: template instance `zip!((x, y) => tuple(x, y))`
    template `zip` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphb1stzhi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    \n    // checking if list is empty or not\n    if(lst.length ==\
    \ 0)\n    {\n        return lst;\n    }\n    \n    // if not empty looping through\
    \ list\n    // and creating a tuple of min and max value for the remaining items\n\
    \    // and removing those values from the list\n    // and then appending those\
    \ items in the tuple to final list\n    auto final_list = [];\n    auto remain_list\
    \ = lst;\n    while(true)\n    {\n        auto element = tuple(remain_list[0],\
    \ remain_list[0]);\n        foreach(remain_item; remain_list)\n        {\n   \
    \         element[0] = min(element[0], remain_item);\n            element[1] =\
    \ max(element[1], remain_item);\n        }\n        final_list ~= element[0];\n\
    \        final_list ~= element[1];\n        remain_list = remain_list.remove(element[0]);\n\
    \        remain_list = remain_list.remove(element[1]);\n        if(remain_list.length\
    \ == 0)\n        {\n            break;\n        }\n    }\n    return final_list;\n\
    }\n// #endregion\nunittest\n{\n    alias candidate = strange_sort_list;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpasxvbb68.d(38): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpasxvbb68.d(39): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpasxvbb68.d(41): Error: cannot append type `long` to type `void[]`

    /tmp/tmpasxvbb68.d(42): Error: cannot append type `long` to type `void[]`

    /tmp/tmpasxvbb68.d(43): Error: no property `remove` for type `long[]`

    /tmp/tmpasxvbb68.d(44): Error: no property `remove` for type `long[]`

    /tmp/tmpasxvbb68.d(50): Error: cannot implicitly convert expression `final_list`
    of type `void[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasxvbb68.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n    auto res = new long[];\n    //if the list is empty, return an\
    \ empty list\n    if(lst.length == 0)\n        return res;\n    //keep track of\
    \ the minimum and maximum value\n    long min = 0, max = 0;\n    //find the minimum\
    \ and maximum value, and the indexes\n    //of each value\n    auto min_list =\
    \ new Tuple!(long, long)[];\n    auto max_list = new Tuple!(long, long)[];\n \
    \   for(size_t i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == min)\n\
    \            min_list ~= tuple(lst[i], i);\n        else if(lst[i] < min)\n  \
    \      {\n            min = lst[i];\n            min_list = [tuple(lst[i], i)];\n\
    \        }\n        if(lst[i] == max)\n            max_list ~= tuple(lst[i], i);\n\
    \        else if(lst[i] > max)\n        {\n            max = lst[i];\n       \
    \     max_list = [tuple(lst[i], i)];\n        }\n    }\n    //for each value in\
    \ the list from the beginning, add\n    //the value to the result list. \n   \
    \ for(size_t i = 0; i < lst.length; i++)\n    {\n        //go through the minimum\
    \ and maximum list and add\n        //the value corresponding to the index of\
    \ i to the result\n        //list.\n        for(auto min_tuple : min_list)\n \
    \       {\n            if(min_tuple[1] == i)\n            {\n                res\
    \ ~= min_tuple[0];\n                break;\n            }\n        }\n       \
    \ for(auto max_tuple : max_list)\n        {\n            if(max_tuple[1] == i)\n\
    \            {\n                res ~= max_tuple[0];\n                break;\n\
    \            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprm5npru_.d(54): Error: no identifier for declarator `min_tuple`

    /tmp/tmprm5npru_.d(54): Error: expression expected, not `:`

    /tmp/tmprm5npru_.d(54): Error: found `min_list` when expecting `;` following `for`
    condition

    /tmp/tmprm5npru_.d(62): Error: no identifier for declarator `max_tuple`

    /tmp/tmprm5npru_.d(62): Error: expression expected, not `:`

    /tmp/tmprm5npru_.d(62): Error: found `max_list` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprm5npru_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto myList = lst.dup;\n    myList.sort();\n    long[] _ret =\
    \ new long[0];\n    foreach(immutable i; 0..(lst.length() / 2))\n    {\n     \
    \   _ret ~= myList[i];\n        _ret ~= myList[(lst.length() - 1) - i];\n    }\n\
    \    if(lst.length() % 2 != 0)\n    {\n        _ret ~= myList[lst.length() / 2];\n\
    \    }\n    return _ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk25umlml.d(21): Error: no property `sort` for type `long[]`

    /tmp/tmpk25umlml.d(23): Error: no property `length` for type `long[]`

    /tmp/tmpk25umlml.d(28): Error: no property `length` for type `long[]`

    /tmp/tmpk25umlml.d(30): Error: no property `length` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk25umlml.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tif (lst.length <= 1)\n\t\treturn lst;\n\tlst = lst.dup;\n\tlst.sort;\n\
    \tlong[] dst = new long[lst.length];\n\tbool inverse = false;\n\tint n = 0;\n\t\
    while (true) {\n\t\tif (inverse)\n\t\t\tn = lst.length - 1;\n\t\tfor (int i =\
    \ 0; i < lst.length; i++) {\n\t\t\tif (lst[n] == long.min)\n\t\t\t\tcontinue;\n\
    \t\t\tdst[i] = lst[n];\n\t\t\tlst[n] = long.min;\n\t\t\tif (inverse)\n\t\t\t\t\
    n--;\n\t\t\telse\n\t\t\t\tn++;\n\t\t}\n\t\tinverse = !inverse;\n\t\tif (n == lst.length)\n\
    \t\t\tbreak;\n\t}\n\treturn dst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6hiczr_.d(23): Error: no property `sort` for type `long[]`

    /tmp/tmpv6hiczr_.d(29): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6hiczr_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ long min_val = min(lst);\n    long max_val = max(lst);\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool min_next = true;\n\
    \    int cnt = 0;\n    while (cnt < lst.length) \n    {\n        if (min_next)\
    \ \n        {\n            result[cnt] = min_val;\n            remove(lst_copy,\
    \ min_val);\n            min_val = min(lst_copy);\n        } \n        else \n\
    \        {\n            result[cnt] = max_val;\n            remove(lst_copy, max_val);\n\
    \            max_val = max(lst_copy);\n        }\n        min_next = !min_next;\n\
    \        cnt += 1;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj_5tzx95.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpj_5tzx95.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpj_5tzx95.d(35): Error: undefined identifier `remove`

    /tmp/tmpj_5tzx95.d(36): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpj_5tzx95.d(41): Error: undefined identifier `remove`

    /tmp/tmpj_5tzx95.d(42): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj_5tzx95.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    return lst.zip(lst.length.enumerate).sort!((a, b) => (a[1] * 2\
    \ / lst.length + a[1] % 2 * (lst.length - 1)) < (b[1] * 2 / lst.length + b[1]\
    \ % 2 * (lst.length - 1))).array();\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr_qrz1ij.d(20): Error: no property `zip` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr_qrz1ij.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    return lst.sort.dg.joiner.joiner.joiner.joiner(lst.reverse);\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpthrmnn4c.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpthrmnn4c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    int mn =\
    \ lst[0];\n    for (in\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt4tu__qh.d(24): Error: found `in` instead of statement

    /tmp/tmpt4tu__qh.d(30): Error: found `;` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt4tu__qh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164252
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return new long[0];\n    \n    lst.sort;\n\
    \    long min = lst[0];\n    lst = lst[1..$];\n    lst.reverse;\n    lst.unshift(min);\n\
    \    long result_length = lst.length * 2;\n    long[] result = new long[result_length];\n\
    \    long i = 0;\n    long j = 1;\n    foreach (ele; lst)\n    {\n        result[i]\
    \ = ele;\n        result[j] = lst[$ - i - 1];\n        i += 2;\n        j += 2;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph4gq0o2y.d(23): Error: no property `sort` for type `long[]`

    /tmp/tmph4gq0o2y.d(26): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmph4gq0o2y.d(27): Error: no property `unshift` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph4gq0o2y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // You code here\n    long[] newLst = new long[lst.length];\n\
    \    long min, max;\n    bool isMin = true;\n    bool isMax = false;\n    long\
    \ counter = 0;\n    if(lst.length == 0) return newLst;\n    do{\n        if(isMin)\n\
    \        {\n            min = lst[0];\n            foreach(long index, long val;\
    \ lst)\n            {\n                if(val < min) min = val;\n            }\n\
    \            newLst[counter] = min;\n            isMin = false;\n            isMax\
    \ = true;\n            counter++;\n        }\n        if(isMax)\n        {\n \
    \           max = lst[0];\n            foreach(long index, long val; lst)\n  \
    \          {\n                if(val > max) max = val;\n            }\n      \
    \      newLst[counter] = max;\n            isMax = false;\n            isMin =\
    \ true;\n            counter++;\n        }\n    }while(counter < lst.length);\n\
    \    return newLst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpywpyu9q0.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x42899d]

    ??:? void tmpywpyu9q0.__unittest_L55_C1() [0x4280ca]

    ??:? void tmpywpyu9q0.__modtest() [0x428720]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b90e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431048]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430b25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8e5]

    ??:? runModuleUnitTests [0x42c851]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e60]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ return strange_sort_list(lst[1 .. $])\n        .map!((x) => (x < lst[0]))\n\
    \        .array\n        .replace(false, tuple(lst[0], lst[0]))\n        .expand!((t)\
    \ => [t[0], t[1]]);\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4alab9ta.d(25): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4alab9ta.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ long[] result = new long[lst.length];\n    long[][] t = lst.sort().chunks(2);\n\
    \    enum i = 0;\n    foreach (chunk; t) \n    {\n        foreach (d; chunk) \n\
    \        {\n            result[i] = d;\n            i += 1;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6o5tjm0x.d(25): Error: no property `sort` for type `long[]`

    /tmp/tmp6o5tjm0x.d(32): Error: cannot modify constant `0`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6o5tjm0x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    int cnt = lst.length;\n\
    \    auto reverse = ((cnt % 2) == 0) ? false : true;\n    auto lst_rev = lst.sort.reverse;\n\
    \    long[] res = new long[cnt];\n    int i = 0;\n    while (cnt > 0)\n    {\n\
    \        if (!reverse)\n        {\n            res[i] = lst[0];\n            lst\
    \ = lst[1..$];\n        }\n        else\n        {\n            res[i] = lst_rev[0];\n\
    \            lst_rev = lst_rev[1..$];\n        }\n        i++;\n        cnt--;\n\
    \        reverse = !reverse;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3697wgq.d(22): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmpk3697wgq.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3697wgq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // write here\n    return lst;\n}\n \n \nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3cm7aklm.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x4287d5]

    ??:? void tmp3cm7aklm.__unittest_L25_C1() [0x427f02]

    ??:? void tmp3cm7aklm.__modtest() [0x428558]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b676]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430809]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430795]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b64d]

    ??:? runModuleUnitTests [0x42c5b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c24]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ else if (lst.length == 1) \n    {\n        return lst;\n    }\n    else if (lst.length\
    \ == 2) \n    {\n        return lst;\n    }\n    else \n    {\n        long[]\
    \ sorted_list = sort(lst);\n        bool direction = true;\n        long[] new_list\
    \ = new long[sorted_list.length];\n        int i = 0;\n        int j = sorted_list.length\
    \ - 1;\n        int k = 0;\n        while (i < j) \n        {\n            if\
    \ (direction) \n            {\n                new_list[k] = sorted_list[i];\n\
    \                i++;\n            }\n            else \n            {\n     \
    \           new_list[k] = sorted_list[j];\n                j--;\n            }\n\
    \            direction = !direction;\n            k++;\n        }\n        if\
    \ (i == j) \n        {\n            new_list[k] = sorted_list[i];\n        }\n\
    \        return new_list;\n    }\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzw_vw1gp.d(34): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpzw_vw1gp.d(38): Error: cannot implicitly convert expression `sorted_list.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzw_vw1gp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tlst = sort(lst);\n\tlong[] res = new long[lst.length];\n\tint i,\
    \ j;\n\tint r;\n\ti = 0;\n\tj = lst.length - 1;\n\tr = 0;\n\twhile(true)\n\t{\n\
    \t\tif(i < lst.length)\n\t\t{\n\t\t\tres[r] = lst[i];\n\t\t\ti++;\n\t\t\tr++;\n\
    \t\t}\n\t\tif(j < lst.length)\n\t\t{\n\t\t\tres[r] = lst[j];\n\t\t\tj--;\n\t\t\
    \tr++;\n\t\t}\n\t\tif(r == lst.length)\n\t\t\tbreak;\n\t}\n\treturn res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnrjw1lr8.d(20): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpnrjw1lr8.d(25): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnrjw1lr8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    enum even = true;\n    enum odd = false;\n    // empty case.\n\
    \    if (empty(lst)) \n    {\n        return lst;\n    }\n    // creating tuple\
    \ with \n    // first element being list of all even numbers\n    // second element\
    \ being list of all odd numbers\n    Tuple!(long[], long[]) list_of_even_odds\
    \ = tuple(filter!(isEven)(lst), filter!(isOdd)(lst));\n    // sorting list of\
    \ evens in ascending order\n    sort!(a => a < b)(list_of_even_odds[even]);\n\
    \    // sorting list of odds in descending order\n    sort!(a => a > b)(list_of_even_odds[odd]);\n\
    \    // result list\n    long[] result_list = new long[];\n    // list with even\
    \ elements\n    long[] list_even = list_of_even_odds[even];\n    // list with\
    \ odd elements\n    long[] list_odd = list_of_even_odds[odd];\n    // while even\
    \ and odd list are not empty\n    while (!empty(list_even) && !empty(list_odd))\
    \ \n    {\n        // append first element of even list to result list\n     \
    \   result_list ~= list_even[0];\n        // append first element of odd list\
    \ to result list\n        result_list ~= list_odd[0];\n        // remove first\
    \ element of even list\n        list_even = list_even[1 .. $];\n        // remove\
    \ first element of odd list\n        list_odd = list_odd[1 .. $];\n    }\n   \
    \ // append all the remaining numbers to result list\n    result_list ~= list_even;\n\
    \    result_list ~= list_odd;\n    return result_list;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpknqbukdj.d(23): Error: undefined identifier `empty`

    /tmp/tmpknqbukdj.d(30): Error: template instance `filter!isEven` template `filter`
    is not defined

    /tmp/tmpknqbukdj.d(30): Error: template instance `filter!isOdd` template `filter`
    is not defined

    /tmp/tmpknqbukdj.d(32): Error: template instance `sort!((a) => a < b)` template
    `sort` is not defined, did you mean sqrt?

    /tmp/tmpknqbukdj.d(34): Error: template instance `sort!((a) => a > b)` template
    `sort` is not defined, did you mean sqrt?

    /tmp/tmpknqbukdj.d(36): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmpknqbukdj.d(42): Error: undefined identifier `empty`

    /tmp/tmpknqbukdj.d(42): Error: undefined identifier `empty`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpknqbukdj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto sorted = lst.array.sort;\n\
    \    long[] result = new long[sorted.length];\n    for (auto i = 0; i < sorted.length;\
    \ i += 2)\n    {\n        result[i] = sorted[i / 2];\n        if (i + 1 < sorted.length)\n\
    \            result[i + 1] = sorted[sorted.length - (i / 2) - 1];\n    }\n   \
    \ return result;\n}\n/*\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyu10xi_8.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyu10xi_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int low = 0;\n    int high = lst.length - 1;\n    long[] result\
    \ = new long[lst.length];\n    int index = 0;\n    foreach(i; 0..lst.length) \n\
    \    {\n        if(i % 2 == 0) \n        {\n            result[index] = lst[low];\n\
    \            low++;\n        }\n        else \n        {\n            result[index]\
    \ = lst[high];\n            high--;\n        }\n        index++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpejjpowty.d(21): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpejjpowty.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] even = [], odd = [];\n    foreach(val; lst) {\n       \
    \ if(val % 2 == 0)\n            even ~= val;\n        else\n            odd ~=\
    \ val;\n    }\n    even.sort;\n    odd.sort;\n    long[] ret = [];\n    while(even.length\
    \ != 0 && odd.length != 0) {\n        ret ~= even.front;\n        even.popFront;\n\
    \        ret ~= odd.back;\n        odd.popBack;\n    }\n    return ret;\n}\n \n\
    /*\n    Check if list is sorted, ascending or descending.\n    \n    Examples:\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L])\n    true\n    >>> is_sorted([4L, 3L, 2L,\
    \ 1L])\n    true\n    >>> is_sorted([2L, 3L, 1L, 4L])\n    false\n    >>> is_sorted([1L,\
    \ 2L, 4L, 3L])\n    false\n    >>> is_sorted([])\n    true\n*/\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpey85n_jg.d(27): Error: no property `sort` for type `long[]`

    /tmp/tmpey85n_jg.d(28): Error: no property `sort` for type `long[]`

    /tmp/tmpey85n_jg.d(31): Error: no property `front` for type `long[]`

    /tmp/tmpey85n_jg.d(32): Error: no property `popFront` for type `long[]`

    /tmp/tmpey85n_jg.d(33): Error: no property `back` for type `long[]`

    /tmp/tmpey85n_jg.d(34): Error: no property `popBack` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpey85n_jg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n    if (lst.length == 0) \n        return lst; \n    long min_pos\
    \ = 0; \n    long min_val = lst[0]; \n    long max_pos = 0; \n    long max_val\
    \ = lst[0]; \n    long i = 0; \n    long[] res = new long[lst.length]; \n    for\
    \ (long l : lst) \n    { \n        if (l < min_val) \n        { \n           \
    \ min_val = l; \n            min_pos = i; \n        } \n        if (l > max_val)\
    \ \n        { \n            max_val = l; \n            max_pos = i; \n       \
    \ } \n        i++; \n    } \n    i = 0; \n    long dir = 1; \n    long pos = min_pos;\
    \ \n    if (min_pos < max_pos) \n    { \n        pos = max_pos; \n        dir\
    \ = -1; \n    } \n    for (long j = 0; j < lst.length; j++) \n    { \n       \
    \ res[i] = lst[pos]; \n        i++; \n        pos += dir; \n        if (dir ==\
    \ 1 && pos == max_pos) \n        { \n            dir = -1; \n            pos =\
    \ min_pos; \n        } \n        if (dir == -1 && pos == min_pos) \n        {\
    \ \n            dir = 1; \n            pos = max_pos; \n        } \n    } \n \
    \   return res; \n} \n/*\n    Once upon a time, on a way through the old wild\
    \ mountainous west,\u2026\n    \u2026 a man was given directions to go from one\
    \ point to another. \n    The directions were \"NORTH\", \"SOUTH\", \"WEST\",\
    \ \"EAST\". Clearly \"NORTH\" \n    and \"SOUTH\" are opposite, \"WEST\" and \"\
    EAST\" too. Going to one direction \n    and coming back the opposite direction\
    \ is a needless effort. Since this \n    is the wild west, with dreadfull weather\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk9rszqxl.d(28): Error: semicolon expected, not `:`

    /tmp/tmpk9rszqxl.d(28): Error: expression expected, not `:`

    /tmp/tmpk9rszqxl.d(28): Error: found `lst` when expecting `;` following `for`
    condition

    /tmp/tmpk9rszqxl.d(68): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk9rszqxl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    sort(lst);\n  \
    \  long[] result = new long[lst.length];\n    int offset = lst.length / 2;\n \
    \   if (lst.length % 2 == 0) \n        offset--;\n    int next_neg = 0;\n    int\
    \ next_pos = offset;\n    foreach (i; 0 .. lst.length) \n    {\n        if (i\
    \ % 2 == 0) \n        {\n            result[i] = lst[next_neg];\n            next_neg++;\n\
    \        } \n        else \n        {\n            result[i] = lst[next_pos];\n\
    \            next_pos++;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpewef4kdd.d(22): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpewef4kdd.d(24): Error: cannot implicitly convert expression `lst.length
    / 2LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpewef4kdd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // Getting a tuple of arrays with the values sorted in ascending\
    \ order and the original indexes\n    Tuple!(long[], int[]) tuple = sort_and_index(lst);\n\
    \    auto [new_lst, indexes] = tuple;\n    long[] result = new long[new_lst.length];\n\
    \    bool even = true;\n    int index = 0;\n    while (true) {\n        if (new_lst.length\
    \ <= 0) break;\n        if (even) {\n            result[index] = new_lst[0];\n\
    \            new_lst = new_lst[1 .. $];\n        } else {\n            result[index]\
    \ = new_lst[$ - 1];\n            new_lst = new_lst[0 .. $ - 1];\n        }\n \
    \       index++;\n        even = !even;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpui2aznk5.d(22): Error: basic type expected, not `[`

    /tmp/tmpui2aznk5.d(22): Error: found `,` when expecting `]`

    /tmp/tmpui2aznk5.d(22): Error: semicolon expected, not `]`

    /tmp/tmpui2aznk5.d(22): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpui2aznk5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // C++: int n = lst.size();\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjno2_943.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjno2_943.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] idx = new long[lst.length];\n    foreach(i; 0..lst.length)\
    \ idx[i] = i;\n    idx.sort!((i, j) => lst[i] < lst[j]);\n    return idx.map!(i\
    \ => lst[i]);\n}\n \n \n \nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7bca3v7v.d(22): Error: no property `sort` for type `long[]`

    /tmp/tmp7bca3v7v.d(23): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7bca3v7v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (empty(lst)) return lst;\n    auto s = sort(lst);\n    auto\
    \ n = s.length;\n    // Fisrt Item of list is first Item of sorted list\n    auto\
    \ result = new long[n];\n    result[0] = s[0];\n    // Choose min/max item from\
    \ list and add to result\n    int j = 1;\n    bool min = true;\n    for (int i\
    \ = 1; i < n; i++) {\n        if (min) {\n            result[j] = s[i];\n    \
    \        j += 2;\n        } else {\n            result[j] = s[n - i];\n      \
    \      j += 2;\n        }\n        min = !min;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5k3zf6n2.d(20): Error: undefined identifier `empty`

    /tmp/tmp5k3zf6n2.d(21): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5k3zf6n2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto result = new long[lst.length];\n    size_t[int] indexes =\
    \ [0 : iota(lst.length)];\n    foreach(int i; 0 .. 2 * lst.length)\n    {\n  \
    \      auto min_or_max = i % 2 == 0 ? std.algorithm.maxElement(lst[indexes]) :\
    \ std.algorithm.minElement(lst[indexes]);\n        result[i / 2] = min_or_max.front;\n\
    \        indexes.remove(min_or_max.back);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9kt9gors.d(21): Error: undefined identifier `iota`

    /tmp/tmp9kt9gors.d(22): Error: cannot implicitly convert expression `2LU * lst.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9kt9gors.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length & 1) \n    {\n        lst = lst.dup;\n        auto\
    \ min = min(lst);\n        lst = lst.filter!(i => i != min);\n    }\n    auto\
    \ it = new Tuple!(long, long)(1, lst.length - 1);\n    long[] out = new long[lst.length];\n\
    \    foreach (i; 0 .. out.length) \n    {\n        if (i & 1) \n        {\n  \
    \          out[i] = lst[it[0]];\n            it[0] += 2;\n        }\n        else\
    \ \n        {\n            out[i] = lst[it[1]];\n            it[1] -= 2;\n   \
    \     }\n    }\n    return out;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbs9_xrfx.d(27): Error: no identifier for declarator `long[]`

    /tmp/tmpbs9_xrfx.d(27): Error: found `out` instead of statement

    /tmp/tmpbs9_xrfx.d(28): Error: expression expected, not `out`

    /tmp/tmpbs9_xrfx.d(32): Error: found `out` instead of statement

    /tmp/tmpbs9_xrfx.d(37): Error: found `out` instead of statement

    /tmp/tmpbs9_xrfx.d(41): Error: expression expected, not `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbs9_xrfx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[];\n    while(lst.length) \n    {\n \
    \       immutable min = lst[0];\n        immutable max = lst[0];\n        foreach(immutable\
    \ el; lst) \n        {\n            min = min(min, el);\n            max = max(max,\
    \ el);\n        }\n        result ~= min;\n        lst = lst.dup.remove(min);\n\
    \        if(lst.length) \n        {\n            result ~= max;\n            lst\
    \ = lst.dup.remove(max);\n        }\n    }\n    return result;\n}\n/*\n    Given\
    \ arrays of integers, return array in strange order.\n    Strange sorting, is\
    \ when you start with the minimum value,\n    then maximum of the remaining integers,\
    \ then minimum and so on.\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9mrwfr72.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9mrwfr72.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto l = lst.array();\n    auto sort = l.sort();\n    long[] result\
    \ = new long[lst.length];\n    result[0] = sort[0];\n    if (lst.length <= 1)\
    \ return result;\n    result[lst.length - 1] = sort[lst.length - 1];\n    size_t\
    \ j = 1;\n    size_t k = lst.length - 2;\n    for (size_t i = 1; i < lst.length\
    \ - 1; i++)\n    {\n        if (i % 2 == 1)\n        {\n            result[j]\
    \ = sort[i];\n            j++;\n        }\n        else\n        {\n         \
    \   result[k] = sort[i];\n            k--;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq6jgogbo.d(20): Error: no property `array` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq6jgogbo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto isOdd = (lst.length % 2) == 1;\n    auto isEven = !isOdd;\n\
    \    auto lst2 = lst.sort;\n    auto lst3 = lst2.dup;\n    long[] result;\n  \
    \  if (isOdd)\n    {\n        result = lst3.init;\n    }\n    else\n    {\n  \
    \      result = lst3;\n    }\n    int i = 0;\n    int j = lst2.length - 1;\n \
    \   while (j >= 0)\n    {\n        if (i % 2 == 0)\n        {\n            result[i]\
    \ = lst2[i / 2];\n        }\n        else\n        {\n            result[i] =\
    \ lst2[j];\n            j--;\n        }\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1y1hu0cd.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1y1hu0cd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long[] res\
    \ = new long[lst.length];\n    int k = 0;\n    int k_steps = (int)divCeil(lst.length,\
    \ 2L);\n    int cmp = -1;\n    int len = lst.length;\n    bool is_first = true;\n\
    \    long max_num = long.min;\n    bool[] used = new bool[lst.length];\n    for\
    \ (int i = 0; i < lst.length; i++) \n    {\n        int min_idx = -1;\n      \
    \  for (int j = 0; j < lst.length; j++) \n        {\n            if (!used[j])\
    \ \n            {\n                if (is_first)\n                    max_num\
    \ = max(max_num, lst[j]);\n                if (min_idx == -1 || lst[j] * cmp <\
    \ lst[min_idx] * cmp)\n                    min_idx = j;\n            }\n     \
    \   }\n        used[min_idx] = true;\n        res[k] = lst[min_idx];\n       \
    \ k += k_steps;\n        if (k >= len) \n        {\n            k = 1;\n     \
    \       k_steps = (int)divCeil(len - 1, 2L);\n            is_first = false;\n\
    \            cmp *= -1;\n        }\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjeyet2lz.d(25): Error: C style cast illegal, use `cast(int)divCeil(lst.length,
    2L)`

    /tmp/tmpjeyet2lz.d(50): Error: C style cast illegal, use `cast(int)divCeil(len
    - 1, 2L)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjeyet2lz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int n = lst.length;\n    bool[] visited = new bool[n];\n    visited[]\
    \ = false;\n    long[] res = new long[n];\n    if (n == 0) return res;\n    res[0]\
    \ = min(lst);\n    long cur = max(lst);\n    int idx = 1;\n    int cur_idx = 0;\n\
    \    while (idx < n) {\n        int cur_idx = lst.countUntil((x) => x == cur);\n\
    \        if (visited[cur_idx]) break;\n        visited[cur_idx] = true;\n    \
    \    res[idx] = cur;\n        cur = max(lst);\n        idx += 1;\n    }\n    return\
    \ res;\n}\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwqzz7jwq.d(20): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmpwqzz7jwq.d(25): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpwqzz7jwq.d(26): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpwqzz7jwq.d(30): Error: no property `countUntil` for type `long[]`

    /tmp/tmpwqzz7jwq.d(30): Error: variable `cur_idx` is shadowing variable `tmpwqzz7jwq.strange_sort_list.cur_idx`

    /tmp/tmpwqzz7jwq.d(34): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwqzz7jwq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto comparer = (Tuple!(long, int, bool) a, Tuple!(long, int,\
    \ bool) b)\n    {\n        return a[0] < b[0];\n    };\n    SortedRange!(comparer)\
    \ sorted_lst;\n    long[] res = new long[lst.length];\n    foreach(i, v; lst)\n\
    \    {\n        sorted_lst.insert(tuple(v, i, true));\n    }\n    for(int i =\
    \ 0; i < sorted_lst.length; i += 2)\n    {\n        res[sorted_lst[i][1]] = sorted_lst[i][0];\n\
    \    }\n    for(int i = sorted_lst.length - 1; i >= 0; i -= 2)\n    {\n      \
    \  res[sorted_lst[i][1]] = sorted_lst[i][0];\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkr9p6jqp.d(24): Error: template instance `SortedRange!comparer`
    template `SortedRange` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkr9p6jqp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    else\n    {\n \
    \       long min = min(lst);\n        long max = max(lst);\n        long[] lst2\
    \ = lst[0..$-1];\n        long[] lst3 = lst[1..$];\n        long[] lst4 = merge(lst2,\
    \ lst3);\n        lst = [min];\n        bool odd = true;\n        foreach (i;\
    \ lst4)\n        {\n            if (odd)\n                lst ~= max(lst4);\n\
    \            else\n                lst ~= min(lst4);\n            odd = !odd;\n\
    \        }\n        return lst;\n    }\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9198c395.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp9198c395.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp9198c395.d(28): Error: undefined identifier `merge`

    /tmp/tmp9198c395.d(34): Error: function expected before `()`, not `max` of type
    `long`

    /tmp/tmp9198c395.d(36): Error: function expected before `()`, not `min` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9198c395.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    size_t curr = 0;\n   \
    \ while (lst.length > 0) {\n        long min = min_element(lst);\n        lst\
    \ = remove_if!(a => a == min)(lst);\n        res[curr] = min;\n        ++curr;\n\
    \        if (lst.length > 0) {\n            long max = max_element(lst);\n   \
    \         lst = remove_if!(a => a == max)(lst);\n            res[curr] = max;\n\
    \            ++curr;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpidnzlcpe.d(23): Error: undefined identifier `min_element`

    /tmp/tmpidnzlcpe.d(24): Error: template instance `remove_if!((a) => a == min)`
    template `remove_if` is not defined

    /tmp/tmpidnzlcpe.d(28): Error: undefined identifier `max_element`

    /tmp/tmpidnzlcpe.d(29): Error: template instance `remove_if!((a) => a == max)`
    template `remove_if` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpidnzlcpe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    struct Pair(T) {\n        T min;\n        T max;\n    }\n    long[]\
    \ res;\n    size_t i = 0;\n    while (i<lst.length)\n    {\n        Pair!(long)\
    \ pair = Pair!(long)();\n        pair.min = min(lst[i]);\n        pair.max = max(lst[i]);\n\
    \        res ~= pair.min;\n        res ~= pair.max;\n        ++i;\n    }\n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpstbr24ir.d(29): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpstbr24ir.d(30): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpstbr24ir.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    bool is_even = true;\n    long[] result = new long[lst.length];\n\
    \    // .dup duplicates an array\n    long[] lst2 = lst.dup;\n    for (size_t\
    \ i = 0; i < lst.length; i++)\n    {\n        size_t min_index = minIndex(lst2);\n\
    \        size_t max_index = maxIndex(lst2);\n        if (is_even)\n        {\n\
    \            result[i] = lst2[min_index];\n            lst2 = lst2[min_index..$].dup;\n\
    \        }\n        else\n        {\n            result[i] = lst2[max_index];\n\
    \            lst2 = lst2[max_index..$].dup;\n        }\n        is_even = !is_even;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpab3g3yys.d(26): Error: undefined identifier `minIndex`

    /tmp/tmpab3g3yys.d(27): Error: undefined identifier `maxIndex`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpab3g3yys.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    else \n    {\n\
    \        long[] res = new long[lst.length];\n        auto t = tuple(lst[$-1],\
    \ lst[0]);\n        auto min_max = minmax(t);\n        res[0] = min_max[0];\n\
    \        res[$-1] = min_max[1];\n        auto lst2 = lst[1..$-1];\n        int\
    \ i = 1;\n        foreach (el; lst2) \n        {\n            if (i % 2 == 0)\n\
    \                res[i] = lst2[0];\n            else\n                res[i] =\
    \ lst2[$-1];\n            i += 1;\n        }\n        return res;\n    }\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvrhmfoke.d(26): Error: undefined identifier `minmax`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvrhmfoke.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] ret = new\
    \ long[lst.length];\n    size_t i = 0;\n    int inc = 1;\n    while(true)\n  \
    \  {\n        int min = min(lst).indices.front;\n        int max = max(lst).indices.front;\n\
    \        if(i == lst.length)\n            break;\n        ret[i] = lst[min];\n\
    \        ret[i+1] = lst[max];\n        lst[min] = long.max;\n        lst[max]\
    \ = long.min;\n        i += 2;\n    }\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnne33bjw.d(27): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpnne33bjw.d(28): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnne33bjw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // TODO: add implementation here\n    return lst;\n}\n// Start\
    \ tests\npublic static void main(string[] args) \n{\n    var testCases = new long[][]\
    \ \n    {\n        new long[] {1L, 2L, 3L, 4L},\n        new long[] {5L, 5L, 5L,\
    \ 5L},\n        new long[] {},\n    };\n    var expectedResults = new long[][]\
    \ \n    {\n        new long[] {1L, 4L, 2L, 3L},\n        new long[] {5L, 5L, 5L,\
    \ 5L},\n        new long[] {},\n    };\n    var idx = 0;\n    foreach (var tc\
    \ in testCases) \n    {\n        var res = strange_sort_list(tc);\n        if\
    \ (res != expectedResults[idx]) \n        {\n            throw new Exception(\"\
    Error: \" + res);\n        }\n        idx++;\n    }\n}\n// End tests\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyo813yl2.d(27): Error: semicolon expected, not `{`

    /tmp/tmpyo813yl2.d(28): Error: found `{` when expecting `;` following statement

    /tmp/tmpyo813yl2.d(28): Error: found `}` when expecting `;` following statement

    /tmp/tmpyo813yl2.d(28): Error: found `,` instead of statement

    /tmp/tmpyo813yl2.d(29): Error: found `,` instead of statement

    /tmp/tmpyo813yl2.d(30): Error: declaration expected, not `,`

    /tmp/tmpyo813yl2.d(33): Error: semicolon expected, not `{`

    /tmp/tmpyo813yl2.d(33): Error: declaration expected, not `{`

    /tmp/tmpyo813yl2.d(39): Error: declaration expected, not `foreach`

    /tmp/tmpyo813yl2.d(42): Error: declaration expected, not `if`

    /tmp/tmpyo813yl2.d(45): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyo813yl2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    enum flag = true;\n    long[] result = new long[lst.length];\n\
    \    int index = 0;\n    size_t min_index;\n    while (flag) \n    {\n       \
    \ min_index = min_element(lst);\n        if (min_index == -1) flag = false;\n\
    \        else \n        {\n            result[index] = lst[min_index];\n     \
    \       lst[min_index] = -1;\n            index++;\n        }\n    }\n    flag\
    \ = true;\n    while (flag) \n    {\n        min_index = max_element(lst);\n \
    \       if (min_index == -1) flag = false;\n        else \n        {\n       \
    \     result[index] = lst[min_index];\n            lst[min_index] = -1;\n    \
    \        index++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpytk1cxdb.d(26): Error: undefined identifier `min_element`

    /tmp/tmpytk1cxdb.d(27): Error: cannot modify constant `flag`

    /tmp/tmpytk1cxdb.d(35): Error: cannot modify constant `flag`

    /tmp/tmpytk1cxdb.d(38): Error: undefined identifier `max_element`

    /tmp/tmpytk1cxdb.d(39): Error: cannot modify constant `flag`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpytk1cxdb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    struct elem\n    {\n        long value;\n        bool visited;\n\
    \        elem(long x) {\n            value = x;\n            visited = false;\n\
    \        }\n    }\n    static auto get_visited(elem[] elems)\n    {\n        long[]\
    \ res;\n        foreach(e; elems)\n        {\n            if(e.visited)\n    \
    \            res ~= e.value;\n        }\n        return res;\n    }\n    static\
    \ auto get_unvisited(elem[] elems)\n    {\n        long[] res;\n        foreach(e;\
    \ elems)\n        {\n            if(!e.visited)\n                res ~= e.value;\n\
    \        }\n        return res;\n    }\n    static auto strange_sort(elem[] elems)\n\
    \    {\n        if(elems.length == 0)\n            return [];\n        long min\
    \ = min(get_unvisited(elems));\n        long max = max(get_unvisited(elems));\n\
    \        long[] res;\n        res ~= min;\n        res ~= max;\n        res ~=\
    \ strange_sort(get_unvisited(elems)).array;\n        return res;\n    }\n    long[]\
    \ res;\n    foreach(x; lst)\n    {\n        res ~= elem(x);\n    }\n    return\
    \ strange_sort(res).array;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbw47zk_5.d(24): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpbw47zk_5.d(24): Error: no identifier for declarator `elem(long x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbw47zk_5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    alias LList = Tuple!(long,\
    \ LList);\n    LList tl = tuple(lst[0], LList.init);\n    for (size_t i = 1; i\
    \ < lst.length; i++)\n    {\n        if (tl[0] > lst[i])\n            tl = tuple(lst[i],\
    \ tl);\n        else\n            tl[1] ~= tuple(lst[i], LList.init);\n    }\n\
    \    LList res = LList.init;\n    while (tl.length != 0)\n    {\n        if (tl[0]\
    \ < tl[1][0])\n        {\n            res ~= tuple(tl[0], LList.init);\n     \
    \       tl = tl[1];\n        }\n        else\n        {\n            res ~= tuple(tl[1][0],\
    \ LList.init);\n            tl[1] = tl[1][1];\n        }\n    }\n    long[] res_\
    \ = new long[res.length];\n    for (size_t i = 0; i < res.length; i++)\n     \
    \   res_[i] = res[i][0];\n    return res_;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqcqnmwg1.d(22): Error: alias `LList` recursive alias declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqcqnmwg1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    lst.sort();\n  \
    \  auto max = lst.length - 1;\n    auto min = 0;\n    long[] result = new long[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++) \n    {\n        if (i % 2 == 0) \n\
    \        {\n            result[i] = lst[min];\n            min++;\n        }\n\
    \        else \n        {\n            result[i] = lst[max];\n            max--;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5xc6pig4.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xc6pig4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tif (lst.length==0)\n\t\treturn lst;\n\t\n\tlong[] result = new long[lst.length];\n\
    \tTuple!(long, long, ubyte)[] tuples = new Tuple!(long, long, ubyte)[lst.length];\n\
    \tfor (size_t i=0; i<lst.length; i++)\n\t{\n\t\ttuples[i] = tuple(lst[i], lst[i],\
    \ 0u);\n\t}\n\t\n\t// sort by first value (original array)\n\tstd.algorithm.sort!(\"\
    a[0] < b[0]\")(tuples);\n\t\n\t// fill array with minimum values\n\tfor (size_t\
    \ i=0; i<lst.length; i+=2)\n\t{\n\t\ttuples[i].tupleof[2] = 1u;\n\t\tresult[i]\
    \ = tuples[i].tupleof[0];\n\t}\n\t\n\t// fill array with maximum values\n\tfor\
    \ (size_t i=1; i<lst.length; i+=2)\n\t{\n\t\ttuples[i].tupleof[2] = 1u;\n\t\t\
    result[i] = tuples[i].tupleof[1];\n\t}\n\t\n\t//sort by second value (remaining\
    \ array)\n\tstd.algorithm.sort!(\"a[1] < b[1]\")(tuples);\n\t\n\tint k=0;\n\t\
    for (size_t i=0; i<lst.length; i++)\n\t{\n\t\tif (tuples[i].tupleof[2]==0u)\n\t\
    \t{\n\t\t\tresult[k] = tuples[i].tupleof[0];\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\treturn\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi0rk7rhh.d(27): Error: template `std.typecons.Tuple!(long, long,
    ubyte).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long,
    long, uint))`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long, ubyte).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmpi0rk7rhh.d(31): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmpi0rk7rhh.d(48): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi0rk7rhh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto length = lst.length;\n    bool toggle = true;\n    auto res\
    \ = length.iota\n                .map!((i) => lst[i])\n                .array;\n\
    \    while(res.length > 1)\n    {\n        if(toggle)\n        {\n           \
    \ res.remove(res.min);\n        }\n        else\n        {\n            res.remove(res.max);\n\
    \        }\n        toggle = !toggle;\n    }\n    return lst;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphvjchrqp.d(22): Error: no property `iota` for type `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvjchrqp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    if (lst.length == 0) \n    {\n        return\
    \ result;\n    }\n    auto _lst = lst.dup;\n    auto min_element = _lst[0];\n\
    \    auto min_index = 0;\n    foreach (index, value; _lst) \n    {\n        if\
    \ (value < min_element) \n        {\n            min_element = value;\n      \
    \      min_index = index;\n        }\n    }\n    auto first_element = min_element;\n\
    \    result ~= first_element;\n    _lst.remove(min_index);\n    auto sort_lst\
    \ = result.dup;\n    foreach (i; 0 .. _lst.length) \n    {\n        auto sub_lst\
    \ = _lst.dup;\n        auto max_element = sub_lst[0];\n        auto max_index\
    \ = 0;\n        foreach (index, value; sub_lst) \n        {\n            if (value\
    \ > max_element) \n            {\n                max_element = value;\n     \
    \           max_index = index;\n            }\n        }\n        sort_lst ~=\
    \ max_element;\n        sub_lst.remove(max_index);\n        auto min_element =\
    \ sub_lst[0];\n        auto min_index = 0;\n        foreach (index, value; sub_lst)\
    \ \n        {\n            if (value < min_element) \n            {\n        \
    \        min_element = value;\n                min_index = index;\n          \
    \  }\n        }\n        sort_lst ~= min_element;\n        sub_lst.remove(min_index);\n\
    \        _lst = sub_lst.dup;\n    }\n    return sort_lst;\n}\nunittest\n{\n  \
    \  alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L])\
    \ == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L,\
    \ 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L,\
    \ 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd9qge7ur.d(33): Error: cannot implicitly convert expression `index`
    of type `ulong` to `int`

    /tmp/tmpd9qge7ur.d(38): Error: no property `remove` for type `long[]`

    /tmp/tmpd9qge7ur.d(50): Error: cannot implicitly convert expression `index` of
    type `ulong` to `int`

    /tmp/tmpd9qge7ur.d(54): Error: no property `remove` for type `long[]`

    /tmp/tmpd9qge7ur.d(55): Error: variable `min_element` is shadowing variable `tmpd9qge7ur.strange_sort_list.min_element`

    /tmp/tmpd9qge7ur.d(56): Error: variable `min_index` is shadowing variable `tmpd9qge7ur.strange_sort_list.min_index`

    /tmp/tmpd9qge7ur.d(62): Error: cannot implicitly convert expression `index` of
    type `ulong` to `int`

    /tmp/tmpd9qge7ur.d(66): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd9qge7ur.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // your code here\n    if(lst.length == 0)\n        return lst;\n\
    \    lst.sort();\n    lst = lst.dup;\n    long[] result = new long[lst.length];\n\
    \    if(lst.length == 1)\n        return lst;\n    else if(lst.length == 2)\n\
    \    {\n        result[0] = lst[0];\n        result[1] = lst[1];\n        return\
    \ result;\n    }\n    else\n    {\n        ulong j = 0;\n        ulong i = 0;\n\
    \        while(i < lst.length)\n        {\n            if(j < lst.length)\n  \
    \          {\n                result[i] = lst[j];\n                j += 2;\n \
    \               i++;\n            }\n            else\n            {\n       \
    \         j = 1;\n            }\n        }\n        return result;\n    }\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj9wnoh1p.d(23): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj9wnoh1p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (empty(lst)) return lst;\n    lst.sort();\n    auto minv =\
    \ lst[0];\n    auto maxv = lst[$ - 1];\n    auto newlst = [minv];\n    auto l\
    \ = lst[1 .. $ - 1];\n    //long[] l = [i for i in lst[1 .. $ - 1]];\n    while\
    \ (!empty(l)) \n    {\n        newlst ~= l[$ - 1];\n        l = l[0 .. $ - 2];\n\
    \        if (empty(l)) break;\n        newlst ~= l[0];\n        l = l[1 .. $];\n\
    \    }\n    if (minv != maxv) \n    {\n        newlst ~= maxv;\n    }\n    return\
    \ newlst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpamkmj6d2.d(20): Error: undefined identifier `empty`

    /tmp/tmpamkmj6d2.d(21): Error: no property `sort` for type `long[]`

    /tmp/tmpamkmj6d2.d(27): Error: undefined identifier `empty`

    /tmp/tmpamkmj6d2.d(31): Error: undefined identifier `empty`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpamkmj6d2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length <= 1)\n        return lst;\n    \n    long[] res\
    \ = new long[lst.length];\n    auto n = lst.length;\n    long min = 0, max = n\
    \ - 1;\n    bool min_first = true;\n    foreach (i; 0 .. n)\n    {\n        auto\
    \ index = min_first ? min : max;\n        res[i] = lst[index];\n        if (min_first)\n\
    \            min++;\n        else\n            max--;\n        min_first = !min_first;\n\
    \    }\n    return res;\n}\n/*\n    This function takes an array of integers and\
    \ modifies it so that\n    all values are distinct by increasing the values with\
    \ the same amount.\n    \n    Example:\n    >>> make_distinct([0L, 1L, 2L, 2L,\
    \ 3L, 4L, 4L, 5L, 6L])\n    [0L, 1L, 2L, 4L, 3L, 4L, 6L, 5L, 6L]\n    >>> make_distinct([1L,\
    \ 1L, 1L, 1L, 1L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> make_distinct([1L, 2L, 3L,\
    \ 4L, 5L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> make_distinct([])\n    []\n*/\n\
    long[] make_distinct(long[] array) \n{\n    if (array.length <= 1)\n        return\
    \ array;\n    \n    long[] res = new long[array.length];\n    res[0] = array[0];\n\
    \    long index = 1, count = 0;\n    foreach (i; 1 .. array.length)\n    {\n \
    \       if (array[i] == array[i - 1])\n            count++;\n        else\n  \
    \          count = 0;\n        res[index] = array[i] + count;\n        index++;\n\
    \    }\n    return res;\n}\n/*\n    This function takes 2 arrays and returns true\
    \ if the second array\n    can be obtained from the first one by deleting\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3q0ih8h8.d(72): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3q0ih8h8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ long min = min(lst);\n    long max = max(lst);\n    long[] small = lst.filter!(a\
    \ => a < max)();\n    long[] big = lst.filter!(a => a > min)();\n    lst = new\
    \ long[$];\n    bool flag = true;\n    foreach (i; 0 .. lst.length / 2) \n   \
    \ {\n        if (flag) \n        {\n            lst ~= min;\n            lst ~=\
    \ max;\n        } \n        else \n        {\n            lst ~= max;\n      \
    \      lst ~= min;\n        }\n        flag = !flag;\n    }\n    if (small.length\
    \ == 0) \n    {\n        return lst;\n    }\n    if (big.length == 0) \n    {\n\
    \        return lst;\n    }\n    return lst.zip(strange_sort_list(small) ~ strange_sort_list(big)).map!((k,v)\
    \ => v).array();\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8mjj6_cz.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp8mjj6_cz.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp8mjj6_cz.d(26): Error: no property `filter` for type `long[]`

    /tmp/tmp8mjj6_cz.d(27): Error: no property `filter` for type `long[]`

    /tmp/tmp8mjj6_cz.d(28): Error: undefined identifier `__dollar`

    /tmp/tmp8mjj6_cz.d(52): Error: no property `zip` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8mjj6_cz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tauto res = new long[](0);\n\tif(lst.length == 0) \n\t\treturn res;\n\
    \telse \n\t{\n\t\tauto first_half = new long[](lst.length / 2);\n\t\tauto second_half\
    \ = new long[](lst.length / 2);\n\t\tif(lst.length % 2 == 0) \n\t\t{\n\t\t\tforeach(i,\
    \ x; lst) \n\t\t\t{\n\t\t\t\tif(i % 2 == 0)\n\t\t\t\t\tfirst_half ~= x;\n\t\t\t\
    \telse\n\t\t\t\t\tsecond_half ~= x;\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\t\
    foreach(i, x; lst) \n\t\t\t{\n\t\t\t\tif(i % 2 == 0)\n\t\t\t\t\tfirst_half ~=\
    \ x;\n\t\t\t\telse\n\t\t\t\t\tsecond_half ~= x;\n\t\t\t}\n\t\t\tfirst_half ~=\
    \ lst[lst.length - 1];\n\t\t}\n\t\t\n\t\tsecond_half = second_half.sort!((a, b)\
    \ => b - a)();\n\t\tfirst_half = first_half.sort!((a, b) => a - b)();\n\t\t\n\t\
    \tif(lst.length % 2 == 0) \n\t\t{\n\t\t\tfor(int i = 0; i < first_half.length;\
    \ i++) \n\t\t\t{\n\t\t\t\tres ~= first_half[i];\n\t\t\t\tres ~= second_half[i];\n\
    \t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tfor(int i = 0; i < first_half.length -\
    \ 1; i++) \n\t\t\t{\n\t\t\t\tres ~= first_half[i];\n\t\t\t\tres ~= second_half[i];\n\
    \t\t\t}\n\t\t\tres ~= first_half[first_half.length - 1];\n\t\t}\n\t\treturn res;\n\
    \t}\n\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0gd4hpwl.d(72): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0gd4hpwl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto zipped = zip(lst, iota(lst.length));\n    auto sorted = sort(zipped,\
    \ (a, b) => std.cmp(a[0], b[0]));\n    auto result = map!(x => x[0])(sorted);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbrpnfjhj.d(20): Error: undefined identifier `zip`

    /tmp/tmpbrpnfjhj.d(21): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpbrpnfjhj.d(22): Error: template instance `map!((x) => x[0])` template
    `map` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbrpnfjhj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_1 = new long[lst.length];\n    foreach (ix,\
    \ e; lst)\n        lst_1[ix] = e;\n    auto lst_max = max(lst_1);\n    auto lst_min\
    \ = min(lst_1);\n    foreach (ix, e; lst)\n    {\n        if (ix % 2 == 0)\n \
    \       {\n            res[ix] = lst_min;\n            lst_1 = remove(lst_1, lst_min);\n\
    \            lst_min = min(lst_1);\n        }\n        else\n        {\n     \
    \       res[ix] = lst_max;\n            lst_1 = remove(lst_1, lst_max);\n    \
    \        lst_max = max(lst_1);\n        }\n    }\n    return res;\n}\n \nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuknc1_j5.d(26): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpuknc1_j5.d(27): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpuknc1_j5.d(33): Error: undefined identifier `remove`

    /tmp/tmpuknc1_j5.d(39): Error: undefined identifier `remove`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuknc1_j5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] sorted = lst.dup;\n    sorted.sort;\n    long[] output\
    \ = new long[];\n    for (int i = 0; i < cast(int)sorted.length; i++) \n    {\n\
    \        int bottom = i*2;\n        int top = sorted.length - (i+1)*2;\n     \
    \   if (bottom < sorted.length) \n        {\n            output ~= sorted[bottom];\n\
    \        }\n        if (top >= 0) \n        {\n            output ~= sorted[top];\n\
    \        }\n    }\n    return output;\n}\n \nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpza1yuq6i.d(21): Error: no property `sort` for type `long[]`

    /tmp/tmpza1yuq6i.d(22): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmpza1yuq6i.d(26): Error: cannot implicitly convert expression `sorted.length
    - cast(ulong)((i + 1) * 2)` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpza1yuq6i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // Initialize accumulator list\n    long[] acc = [];\n    // Iterate\
    \ over length/2 (rounded down)\n    foreach (i; 0 .. (lst.length/2).floor) \n\
    \    {\n        // Append minimum to accumulator list\n        acc ~= lst.min;\n\
    \        // Remove minimum from list\n        lst = lst.removeAll(lst.min);\n\
    \        // Append maximum to accumulator list\n        acc ~= lst.max;\n    \
    \    // Remove maximum from list\n        lst = lst.removeAll(lst.max);\n    }\n\
    \    // Append remaining item in lst to accumulator\n    acc ~= lst;\n    // Return\
    \ accumulator\n    return acc;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptc2elglo.d(23): Error: `std.math.floor` called with argument types
    `(ulong)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(4394):     `std.math.floor(real
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(4487):     `std.math.floor(float
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptc2elglo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // for quick and dirty tests\n    assert(1L == 1L);\n    assert(2L\
    \ == 2L);\n    assert(3L == 3L);\n    assert(4L == 4L);\n    assert(5L == 5L);\n\
    \    assert(6L == 6L);\n    assert(7L == 7L);\n    assert(8L == 8L);\n    assert(9L\
    \ == 9L);\n    assert(10L == 10L);\n    assert(11L == 11L);\n    assert(12L ==\
    \ 12L);\n    assert(13L == 13L);\n    assert(14L == 14L);\n    assert(15L == 15L);\n\
    \    assert(16L == 16L);\n    assert(17L == 17L);\n    assert(18L == 18L);\n \
    \   assert(19L == 19L);\n    assert(20L == 20L);\n    assert(21L == 21L);\n  \
    \  assert(22L == 22L);\n    assert(23L == 23L);\n    assert(24L == 24L);\n   \
    \ assert(25L == 25L);\n    assert(26L == 26L);\n    assert(27L == 27L);\n    assert(28L\
    \ == 28L);\n    assert(29L == 29L);\n    assert(30L == 30L);\n    assert(31L ==\
    \ 31L);\n    assert(32L == 32L);\n    assert(33L == 33L);\n    assert(34L == 34L);\n\
    \    assert(35L == 35L);\n    assert(36L == 36L);\n    assert(37L == 37L);\n \
    \   assert(38L == 38L);\n    assert(39L == 39L);\n    assert(40L == 40L);\n  \
    \  assert(41L == 41L);\n    assert(42L == 42L);\n    assert(43L == 43L);\n   \
    \ assert(44L == 44L);\n    assert(45L == 45L);\n    assert(46L == 46L);\n    assert(47L\
    \ == 47L);\n    assert(48L == 48L);\n    assert(49L == 49L);\n    assert(50L ==\
    \ 50L);\n   \nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpld5_ixd5.d(72): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpld5_ixd5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // Write your code here\n    auto res = new long[](lst.length);\n\
    \    if (lst.length == 0) \n        return res;\n    int i = 0;\n    int j = lst.length-1;\n\
    \    int k = 0;\n    while (k < lst.length) \n    {\n        res[k++] = lst[i++];\n\
    \        if (k < lst.length)\n            res[k++] = lst[j--];\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp28sr6xj9.d(25): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp28sr6xj9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto list_of_tuples = zip(lst, iota(0L, lst.length));\n    //\
    \ sort by descending for max and ascending for min\n    list_of_tuples.sort!((a,\
    \ b) => a[0] > b[0] ? -1 : a[0] < b[0] ? 1 : 0);\n    list_of_tuples.sort!((a,\
    \ b) => a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0);\n    return list_of_tuples.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfe061cer.d(20): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfe061cer.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n  if (lst.length == 0)\n  {\n    return lst;\n  }\n  if (lst.length\
    \ == 1)\n  {\n    return lst;\n  }\n  int n = lst.length;\n  long[] r = new long[n];\n\
    \  long[] s = new long[n];\n  int i = 0;\n  long min_val = min(lst);\n  long max_val\
    \ = max(lst);\n  long cur_val = min_val;\n  while (i < n)\n  {\n    r[i] = cur_val;\n\
    \    i++;\n    cur_val = (i % 2 == 0) ? min_val : max_val;\n  }\n  i = 0;\n  foreach\
    \ (long l; lst)\n  {\n    if (l == min_val)\n    {\n      s[i] = l;\n      i++;\n\
    \    }\n  }\n  foreach (long l; lst)\n  {\n    if (l == max_val)\n    {\n    \
    \  s[i] = l;\n      i++;\n    }\n  }\n  return r;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppx458pm2.d(28): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmppx458pm2.d(32): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmppx458pm2.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppx458pm2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ else \n    {\n        long min = min_element(lst);\n        long max = max_element(lst);\n\
    \        long[] result = new long[lst.length];\n        bool min_or_max = true;\n\
    \        int odd_even = 0;\n        int result_index = 0;\n        while (odd_even\
    \ != lst.length) \n        {\n            if (min_or_max) \n            {\n  \
    \              result[result_index] = min;\n                min_or_max = false;\n\
    \            }\n            else \n            {\n                result[result_index]\
    \ = max;\n                min_or_max = true;\n            }\n            result_index\
    \ += 1;\n            odd_even += 1;\n        }\n        return result;\n    }\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgzjb51_v.d(26): Error: undefined identifier `min_element`

    /tmp/tmpgzjb51_v.d(27): Error: undefined identifier `max_element`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgzjb51_v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int i, len;\n    long[] lst_end, res;\n    bool f;\n    // test\n\
    \    len = lst.length;\n    if (len == 0) return lst;\n    //\n    f = true;\n\
    \    lst_end = new long[len];\n    res = new long[len];\n    for (i = 0; i < len;\
    \ i++) {\n        lst_end[i] = lst[i];\n    }\n    for (i = 0; i < len; i++) {\n\
    \        if (f) {\n            res[i] = lst_end[0];\n            lst_end = removeAt(lst_end,\
    \ 0);\n        } else {\n            res[i] = lst_end[lst_end.length - 1];\n \
    \           lst_end = removeAt(lst_end, lst_end.length - 1);\n        }\n    \
    \    f = !f;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpelzv2tnz.d(24): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmpelzv2tnz.d(36): Error: undefined identifier `removeAt`

    /tmp/tmpelzv2tnz.d(39): Error: undefined identifier `removeAt`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpelzv2tnz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int ln = lst.length;\n    if (ln < 2) \n        return lst;\n\
    \    long tmp;\n    long[] lst1 = lst[$-1 .. $];\n    int ln1 = lst1.length;\n\
    \    if (ln1 == 0) \n        return lst;\n    for (int i = 0; i < ln1; i++) \n\
    \    {\n        if (i % 2 == 0) \n        {\n            tmp = lst1[0];\n    \
    \        lst1 = lst1[1 .. $];\n            lst1 ~= tmp;\n        } \n        else\
    \ \n        {\n            tmp = lst1[$-1];\n            lst1 = lst1[0 .. $-1];\n\
    \            lst1 = [tmp] ~ lst1;\n        }\n    }\n    return lst1;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf_0upfeq.d(20): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmpf_0upfeq.d(25): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_0upfeq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = [];\n    bool reverse = false;\n    result ~=\
    \ lst[0];\n    lst = lst[1..$];\n    while(lst.length != 0)\n    {\n        if(reverse)\n\
    \        {\n            result ~= lst[0];\n            lst = lst[1..$];\n    \
    \    }\n        else\n        {\n            result ~= lst[$-1];\n           \
    \ lst = lst[0..$-2];\n        }\n        reverse = !reverse;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxzagm86w.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x4289e5]

    ??:? void tmpxzagm86w.__unittest_L40_C1() [0x42810e]

    ??:? void tmpxzagm86w.__modtest() [0x428764]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d453]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42c2e6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430d39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4311e8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430cc5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c2bd]

    ??:? runModuleUnitTests [0x42d229]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ea8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tint n = lst.length;\n\t\n\t// Removes duplicate elements\n\tlst\
    \ = lst.dup.sort().dedup;\n\t\n\t// We need the minimum and maximum values\n\t\
    long min = lst[0];\n\tlong max = lst[$-1];\n\t\n\tint k = 0;\n\tauto res = new\
    \ long[n];\n\t\n\tif(n == 0) return res;\n\t\n\tint dir = 1; // 1 for ascending,\
    \ -1 for descending\n\tbool duplicate = n == 1;\n\t\n\twhile(true)\n\t{\n\t\t\
    if(k == n) break;\n\t\t\n\t\tif(duplicate) \n\t\t{\n\t\t\tres[k] = lst[0];\n\t\
    \t\tk++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Check if we have reached the minimum\
    \ or maximum\n\t\tif(lst[0] == min || lst[$-1] == max) \n\t\t{\n\t\t\t// The 'duplicate'\
    \ flag is set if there is only one element left\n\t\t\tif(lst.length == 1) duplicate\
    \ = true;\n\t\t\t\n\t\t\t// Changes direction\n\t\t\tdir *= -1;\n\t\t}\n\t\t\n\
    \t\t// Removes the minimum or maximum\n\t\tlst = lst[1..$-1];\n\t\t\n\t\t// Removes\
    \ the first or last element\n\t\tres[k] = dir == 1 ? lst[0] : lst[$-1];\n\t\t\
    k++;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk4zbvqaf.d(20): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmpk4zbvqaf.d(23): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk4zbvqaf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto len = lst.length;\n    long[] ret = new long[len];\n    if\
    \ (len > 0) \n    {\n        int i = 0;\n        auto it = lst.tupleof;\n    \
    \    int2 dir = int2(1, -1);\n        bool asc = true;\n        while (i < len)\
    \ \n        {\n            if (it.empty) \n            {\n                asc\
    \ = !asc;\n                it = lst.tupleof;\n            }\n            else\
    \ \n            {\n                ret[i] = it[asc ? 0 : $ - 1];\n           \
    \     it = it[1 .. $ - 1];\n                i += dir[asc ? 0 : 1];\n         \
    \   }\n        }\n    }\n    return ret;\n}\n/*\n    int[] strange_sort_list(int[]\
    \ arr)\n    {\n        arr.sort();\n        bool asc = true;\n        int mid_idx\
    \ = (arr.length - 1) / 2;\n        int i = 0;\n        while (i < arr.length)\n\
    \        {\n            if (asc)\n            {\n                arr[i] = arr[mid_idx];\n\
    \                mid_idx++;\n            }\n            else\n            {\n\
    \                arr[i] = arr[mid_idx];\n                mid_idx--;\n        \
    \    }\n            i++;\n            asc = !asc;\n        }\n        return arr;\n\
    \    }\n*/\nauto strange_sort_list2(T)(T[] lst) if (isArray!T) \n{\n    return\
    \ lst.sort(true).array;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb_2h021y.d(25): Error: no property `tupleof` for type `long[]`

    /tmp/tmpb_2h021y.d(26): Error: undefined identifier `int2`

    /tmp/tmpb_2h021y.d(26): Error: undefined identifier `int2`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_2h021y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n    if (lst.length==0)\n        return [];\n    else if (lst.length==1)\n\
    \        return lst;\n    long[] up = [];\n    long[] down = [];\n    long[] res\
    \ = [];\n    long min_val = lst[0];\n    long min_idx = 0;\n    long max_val =\
    \ lst[0];\n    long max_idx = 0;\n    foreach(int i, long x; lst) {\n        if\
    \ (x > max_val) {\n            max_val = x;\n            max_idx = i;\n      \
    \  }\n        if (x < min_val) {\n            min_val = x;\n            min_idx\
    \ = i;\n        }\n    }\n    //writefln(\"max_val=%s max_idx=%s min_val=%s min_idx=%s\"\
    ,max_val,max_idx,min_val,min_idx);\n    if (min_idx > max_idx) {\n        res\
    \ ~= min_val;\n        up = lst[0..min_idx];\n        down = lst[min_idx+1..$];\n\
    \    } else {\n        res ~= max_val;\n        up = lst[0..max_idx];\n      \
    \  down = lst[max_idx+1..$];\n    }\n    return res ~ strange_sort_list(up) ~\
    \ strange_sort_list(down);\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppnxl_r73.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x428b4d]

    ??:? void tmppnxl_r73.__unittest_L53_C1() [0x428276]

    ??:? void tmppnxl_r73.__modtest() [0x4288cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d5bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42c44e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430ea1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431350]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430e2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c425]

    ??:? runModuleUnitTests [0x42d391]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429010]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n  if (lst.length == 0)\n    return lst;\n  long[] rlst = lst.dup;\n\
    \  auto rIter = rlst.randomAccess.front;\n  auto lIter = lst.front;\n  auto lIterEnd\
    \ = lst.back;\n  rIter.put((lIter++).front);\n  lIterEnd.popFront;\n  rIter.put((lIterEnd--).front);\n\
    \  while (lIter <= lIterEnd)\n  {\n    rIter.put((lIter++).front);\n    rIter.put((lIterEnd--).front);\n\
    \  }\n  return rlst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzq6mb6bo.d(23): Error: no property `randomAccess` for type `long[]`

    /tmp/tmpzq6mb6bo.d(24): Error: no property `front` for type `long[]`

    /tmp/tmpzq6mb6bo.d(25): Error: no property `back` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzq6mb6bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = [];\n    long[] tmplst = lst.dup;\n    size_t n =\
    \ tmplst.length;\n    while (n != 0){\n        long min = minElement(tmplst);\n\
    \        long max = maxElement(tmplst);\n        n -= 2;\n        res ~= min;\n\
    \        tmplst = tmplst.filter!(i => i != min);\n        if (n < 0) break;\n\
    \        res ~= max;\n        tmplst = tmplst.filter!(i => i != max);\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuu7fi0lc.d(24): Error: undefined identifier `minElement`

    /tmp/tmpuu7fi0lc.d(25): Error: undefined identifier `maxElement`

    /tmp/tmpuu7fi0lc.d(28): Error: no property `filter` for type `long[]`

    /tmp/tmpuu7fi0lc.d(31): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuu7fi0lc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    bool[] used = new\
    \ bool[lst.length];\n    long[] result = new long[lst.length];\n    result[0]\
    \ = min(lst);\n    used[lst.indexOf(result[0])] = true;\n    long[] remaining\
    \ = lst[0..$ - 1];\n    foreach (idx; 1..lst.length) \n    {\n        if (idx\
    \ % 2 == 0)\n            result[idx] = min(remaining);\n        else\n       \
    \     result[idx] = max(remaining);\n        used[lst.indexOf(result[idx])] =\
    \ true;\n        remaining = remaining[0..$ - 1];\n    }\n    return result;\n\
    }\n/*\n    Given strings s1 and s2, return the lexicographically smallest\n  \
    \  string obtained by placing the characters of s2 between the\n    characters\
    \ of s1.\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfy1qee9j.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfy1qee9j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    lst.sort;\n\
    \    auto sz = cast(int) lst.length;\n    long[] rlst = lst[0 .. sz / 2];\n  \
    \  foreach (i; (sz / 2 .. sz).step(2))\n        rlst ~= lst[i];\n    foreach (i;\
    \ (sz / 2 - 1 .. 0).step(-2))\n        rlst ~= lst[i];\n    return rlst;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdefsipz8.d(26): Error: found `..` when expecting `)`

    /tmp/tmpdefsipz8.d(26): Error: found `sz` when expecting `)`

    /tmp/tmpdefsipz8.d(26): Error: found `)` instead of statement

    /tmp/tmpdefsipz8.d(28): Error: found `..` when expecting `)`

    /tmp/tmpdefsipz8.d(28): Error: found `0` when expecting `)`

    /tmp/tmpdefsipz8.d(28): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdefsipz8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    bool addMin = true;\n  \
    \  long[] res = new long[lst.length];\n    auto lst2 = lst.dup;\n    lst2.sort;\n\
    \    lst2.reverse;\n    lst.sort;\n    foreach (index,item; lst) \n    {\n   \
    \     if (addMin) \n        {\n            res[index] = item;\n            addMin\
    \ = false;\n        }\n        else \n        {\n            res[index] = lst2[0];\n\
    \            lst2 = lst2[1..$];\n            addMin = true;\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5_0ue4v1.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmp5_0ue4v1.d(25): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmp5_0ue4v1.d(26): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_0ue4v1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length <= 1) \n    {\n        return lst;\n    }\n   \
    \ else \n    {\n        long[] sorted_array = sort(lst);\n        int array_length\
    \ = sorted_array.length;\n        long[] min_array = new long[array_length / 2];\n\
    \        long[] max_array = new long[(array_length + 1) / 2];\n        min_array\
    \ = sorted_array[0 .. (array_length / 2)];\n        max_array = sorted_array[(array_length\
    \ / 2) .. $];\n        Tuple!(long[], long[]) t = tuple(max_array, min_array);\n\
    \        return flatten(reverse(t));\n    }\n}\n \nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpejk50ooo.d(26): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpejk50ooo.d(27): Error: cannot implicitly convert expression `sorted_array.length`
    of type `ulong` to `int`

    /tmp/tmpejk50ooo.d(33): Error: undefined identifier `flatten`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpejk50ooo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    const int min = 0;\n    const int max = 1;\n    const int size\
    \ = lst.length;\n    long[] strange_lst = new long[size];\n    auto index = 0;\n\
    \    auto index_list = new int[size];\n    auto to_sort = lst.dup;\n    auto index_type\
    \ = min;\n    while (to_sort.length != 0)\n    {\n        auto maximum = max(to_sort);\n\
    \        auto maximum_index = 0;\n        foreach (index, el; to_sort)\n     \
    \   {\n            if (el == maximum)\n            {\n                maximum_index\
    \ = index;\n                break;\n            }\n        }\n        auto minimum\
    \ = min(to_sort);\n        auto minimum_index = 0;\n        foreach (index, el;\
    \ to_sort)\n        {\n            if (el == minimum)\n            {\n       \
    \         minimum_index = index;\n                break;\n            }\n    \
    \    }\n        strange_lst[index] = (index_type == min) ? minimum : maximum;\n\
    \        index_list[index] = (index_type == min) ? minimum_index : maximum_index;\n\
    \        index_type = (index_type == min) ? max : min;\n        index++;\n   \
    \     to_sort = delete(to_sort, (index_type == min) ? minimum_index : maximum_index);\n\
    \    }\n    return strange_lst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqrbsvr2p.d(22): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `const(int)`

    /tmp/tmpqrbsvr2p.d(30): Error: function expected before `()`, not `max` of type
    `const(int)`

    /tmp/tmpqrbsvr2p.d(32): Error: variable `index` is shadowing variable `tmpqrbsvr2p.strange_sort_list.index`

    /tmp/tmpqrbsvr2p.d(36): Error: cannot implicitly convert expression `index` of
    type `ulong` to `int`

    /tmp/tmpqrbsvr2p.d(40): Error: function expected before `()`, not `min` of type
    `const(int)`

    /tmp/tmpqrbsvr2p.d(42): Error: variable `index` is shadowing variable `tmpqrbsvr2p.strange_sort_list.index`

    /tmp/tmpqrbsvr2p.d(46): Error: cannot implicitly convert expression `index` of
    type `ulong` to `int`

    /tmp/tmpqrbsvr2p.d(52): Error: cannot modify `const` expression `index_type`

    /tmp/tmpqrbsvr2p.d(54): Deprecation: The `delete` keyword has been deprecated.  Use
    `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.

    /tmp/tmpqrbsvr2p.d(54): Error: Using the result of a comma expression is n'
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\t\n\tlong[] r = new long[lst.length];\n\tint count = 0;\n\tauto t\
    \ = tuple(lst);\n\twhile(t[0].length > 0)\n\t{\n\t\tr[count] = t[0][0];\n\t\t\
    count++;\n\t\tt[0] = t[0][1..$];\n\t\tt = t.rotateLeft;\n\t}\n\treturn r;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmponfm5otw.d(29): Error: no property `rotateLeft` for type `Tuple!(long[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmponfm5otw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto isEven = (int n) { return n % 2 == 0; };\n    auto sorter\
    \ = lst\n    .enumerate\n    .group\n    .sort\n    .enumerate\n    .sort((a,\
    \ b) => isEven(a.index) ? (a.value[0] > b.value[0]) : (a.value[0] < b.value[0]))\n\
    \    .map!(x => x.value[0])\n    .array;\n    return sorter;\n}\n/*\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps9t96rs5.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps9t96rs5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto minmax = minmaxElement(lst);\n    bool isEven = true;\n \
    \   bool isMax = false;\n    bool isMin = false;\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    foreach(el; lst)\n    {\n        if(el != *minmax.first &&\
    \ el != *minmax.second)\n        {\n            result[i] = el;\n            i++;\n\
    \        }\n    }\n    foreach(el; lst)\n    {\n        if(isEven)\n        {\n\
    \            if(el == *minmax.first)\n            {\n                result[i]\
    \ = el;\n                i++;\n                isMin = true;\n            }\n\
    \            else if(el == *minmax.second)\n            {\n                isMax\
    \ = true;\n            }\n        }\n        else\n        {\n            if(el\
    \ == *minmax.second && isMax)\n            {\n                result[i] = el;\n\
    \                i++;\n                isMax = false;\n            }\n       \
    \     else if(el == *minmax.first && isMin)\n            {\n                result[i]\
    \ = el;\n                i++;\n                isMin = false;\n            }\n\
    \        }\n        isEven = !isEven;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2r__0lqd.d(20): Error: undefined identifier `minmaxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2r__0lqd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] tmp;\n    auto i = 0;\n    auto j = lst.length - 1;\n \
    \   auto k = 0;\n    long[] res;\n    res.length = lst.length;\n    while (i <=\
    \ j) \n    {\n        tmp = lst[j..$];\n        res[k] = tmp[$-1];\n        k++;\n\
    \        if (i != j) \n        {\n            res[k] = tmp[0];\n            k++;\n\
    \        }\n        i++;\n        j--;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpa5jrfq86.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x42891d]

    ??:? void tmpa5jrfq86.__unittest_L41_C1() [0x428046]

    ??:? void tmpa5jrfq86.__modtest() [0x42869c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da6f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42c902]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x431d41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4321f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x431ccd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c8d9]

    ??:? runModuleUnitTests [0x42d845]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428de0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    bool isAsc = true;\n   \
    \ long[] tmp = lst.dup;\n    sort(tmp);\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    foreach(immutable elem; tmp)\n    {\n        if (isAsc)\n\
    \        {\n            result[i] = elem;\n            i += 2;\n        }\n  \
    \      else\n        {\n            result[i] = elem;\n            i -= 2;\n \
    \       }\n        if (i < 0)\n        {\n            i = 1;\n            isAsc\
    \ = true;\n        }\n        else if (i >= result.length)\n        {\n      \
    \      i = result.length - 2;\n            isAsc = false;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt41xvwgy.d(23): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpt41xvwgy.d(45): Error: cannot implicitly convert expression `result.length
    - 2LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt41xvwgy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    struct WeirdSorter {\n        size_t i;\n        size_t last;\n\
    \        long[] lst;\n        size_t getIndex() {\n            if (i > last)\n\
    \                return size_t.max;\n            if (i == last)\n            \
    \    return i;\n            auto j = 2 * (i + 1) - 1;\n            return j <=\
    \ last ? j : last;\n        }\n        int opCmp(const WeirdSorter rhs) const\
    \ {\n            if (i == rhs.i)\n                return 0;\n            if (i\
    \ > rhs.i)\n                return 1;\n            return -1;\n        }\n   \
    \ }\n    if (lst.length == 0)\n        return lst;\n    auto s = WeirdSorter(0,\
    \ lst.length - 1, lst);\n    auto ws = new WeirdSorter[](lst.length);\n    auto\
    \ iter = ws.begin();\n    foreach (i; 0 .. ws.length) {\n        *iter = s;\n\
    \        s.i += 2;\n        iter++;\n    }\n    auto res = new long[](lst.length);\n\
    \    auto maxw = max(ws);\n    auto minw = min(ws);\n    foreach (i; 0 .. res.length)\
    \ {\n        auto w = i % 2 == 0 ? minw : maxw;\n        res[i] = lst[w.getIndex()];\n\
    \        if (w.getIndex() == w.last)\n            w.last--;\n        else\n  \
    \          w.i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2oael2x3.d(44): Error: no property `begin` for type `WeirdSorter[]`

    /tmp/tmp2oael2x3.d(51): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp2oael2x3.d(52): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2oael2x3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ else \n    {\n        auto min = minElement(lst);\n        auto index_of_min\
    \ = std.algorithm.find(lst, min);\n        auto lst_rest = remove(lst, index_of_min);\n\
    \        auto new_lst = [min];\n        for (i in 0..lst_rest.length/2) \n   \
    \     {\n            auto max = maxElement(lst_rest);\n            auto index_of_max\
    \ = std.algorithm.find(lst_rest, max);\n            new_lst ~= max;\n        \
    \    lst_rest = remove(lst_rest, index_of_max);\n            auto min = minElement(lst_rest);\n\
    \            auto index_of_min = std.algorithm.find(lst_rest, min);\n        \
    \    new_lst ~= min;\n            lst_rest = remove(lst_rest, index_of_min);\n\
    \        }\n        if (lst_rest.length == 1) \n        {\n            new_lst\
    \ ~= lst_rest[0];\n        }\n        return new_lst;\n    }\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk47eegr1.d(30): Error: found `..` when expecting `;` following
    statement

    /tmp/tmpk47eegr1.d(30): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmpk47eegr1.d(41): Error: found `if` when expecting `)`

    /tmp/tmpk47eegr1.d(41): Error: found `==` when expecting `)`

    /tmp/tmpk47eegr1.d(41): Error: missing `{ ... }` for function literal

    /tmp/tmpk47eegr1.d(41): Error: found `1` when expecting `;` following statement

    /tmp/tmpk47eegr1.d(41): Error: found `)` instead of statement

    /tmp/tmpk47eegr1.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk47eegr1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // if no elements in lst, return lst\n    if (lst.length == 0)\
    \ return lst;\n    // create empty list out of size lst.length and capacity lst.length\n\
    \    auto sort_list = Tuple!(long[])([]);\n    // create an array of bools for\
    \ each element in lst\n    bool[] used = new bool[lst.length];\n    // true if\
    \ element in lst is already in sort_list\n    // false if it is not\n    // at\
    \ first, all values in used are false\n    foreach (index, _; used) \n    {\n\
    \        used[index] = false;\n    }\n    // fill sort_list with min value from\
    \ lst\n    // we know that there is at least one element in lst,\n    // so there\
    \ will be also at least one element in sort_list\n    auto index_min = lst.minIndex;\n\
    \    sort_list.front = lst[index_min];\n    used[index_min] = true;\n    // starting\
    \ from second element in sort_list\n    for (auto i = 1; i < lst.length; i++)\
    \ \n    {\n        auto min_value = lst.max;\n        auto max_value = lst.min;\n\
    \        // position of min/max values in lst\n        auto min_index = -1;\n\
    \        auto max_index = -1;\n        // for each element in lst\n        foreach\
    \ (i, element; lst) \n        {\n            // if element already in sort_list,\
    \ skip\n            if (used[i]) continue;\n            // if element smaller\
    \ then min, make it min\n            if (element < min_value) \n            {\n\
    \                min_value = element;\n                min_index = i;\n      \
    \      }\n            // if element greater then max, make it max\n          \
    \  if (element > max_value) \n            {\n                max_value = element;\n\
    \                max_index = i;\n            }\n        }\n        // if i is\
    \ even, we need to add min value\n        if (i % 2 == 0) \n        {\n      \
    \      // if there is no more elements in lst, add nothing\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3df9em4c.d(69): Error: found `unittest` instead of statement

    /tmp/tmp3df9em4c.d(83): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp3df9em4c.d(83): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3df9em4c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n    if (lst.length <= 2) \n        return lst; \n    long mx = max(lst);\
    \ \n    long mn = min(lst); \n    long[] res = new long[lst.length]; \n    int\
    \ j = 0; \n    int k = lst.length-1; \n    for (int i = 0; i < lst.length; i++)\
    \ \n    { \n        if (i % 2 == 0) \n            res[i] = mn; \n        else\n\
    \            res[i] = mx; \n        if (res[i] == lst[j]) \n            j++; \n\
    \        else if (res[i] == lst[k]) \n            k--; \n    } \n    return res;\
    \ \n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp56qt5bb8.d(22): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmp56qt5bb8.d(23): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp56qt5bb8.d(26): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp56qt5bb8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int len = lst.length;\n    if (len == 0)\n        return [];\n\
    \    auto res = new long[](len);\n    int a = 0;\n    int b = len - 1;\n    int\
    \ pos = 0;\n    bool is_a = true;\n    while (pos < len) \n    {\n        if (is_a)\
    \ \n        {\n            res[pos] = lst[a];\n            a++;\n        }\n \
    \       else \n        {\n            res[pos] = lst[b];\n            b--;\n \
    \       }\n        is_a = !is_a;\n        pos++;\n    }\n    return res;\n}\n\
    /*\n    Given a list of lists, return the sum of the lists that\n    have the\
    \ same elements, but the elements are sorted in \n    different order.\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpojrpb9c_.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpojrpb9c_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    lst.sort();\n\
    \    auto res = new long[](lst.length);\n    size_t i = 0;\n    size_t j = lst.length\
    \ - 1;\n    while (i < lst.length/2) \n    {\n        res[i * 2] = lst[i];\n \
    \       res[i * 2 + 1] = lst[j];\n        i++;\n        j--;\n    }\n    if (lst.length\
    \ % 2 == 1)\n        res[lst.length - 1] = lst[lst.length / 2];\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfi4304sl.d(23): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfi4304sl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n  if (lst.length == 0)\n    return lst;\n  auto tup = sort(lst);\n\
    \  int middle = tup[0].length / 2;\n  long[] rez = new long[tup[0].length];\n\
    \  int index = 0;\n  for (int i = 0; i < middle; i++)\n  {\n    rez[index] = tup[0][i];\n\
    \    index++;\n    rez[index] = tup[0][tup[0].length - i - 1];\n    index++;\n\
    \  }\n  if (tup[0].length % 2 != 0)\n    rez[index] = tup[0][middle];\n  return\
    \ rez;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprd2k9ku2.d(22): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprd2k9ku2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    // two pointers for array\n\
    \    int l = 0;\n    int r = lst.length - 1;\n    // iterate up to half of the\
    \ array\n    for (int i = 0; i < (lst.length/2 + lst.length%2); i++)\n    {\n\
    \        // add maximum and minimum\n        res[2*i] = lst[l];\n        res[2*i\
    \ + 1] = lst[r];\n        // update points\n        l++;\n        r--;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphseq9jcn.d(23): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphseq9jcn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n    if (lst.length <= 1) return lst;\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbqrsx2is.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbqrsx2is.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] odd = new long[lst.length];\n    long[] even = new long[lst.length];\n\
    \    long[] result = new long[lst.length];\n    lst.sort();\n    int odd_counter\
    \ = 0;\n    int even_counter = 0;\n    foreach(num; lst)\n    {\n        if(num\
    \ % 2 == 0)\n        {\n            even[even_counter] = num;\n            even_counter++;\n\
    \        }\n        else\n        {\n            odd[odd_counter] = num;\n   \
    \         odd_counter++;\n        }\n    }\n    int odd_length = odd.length-1;\n\
    \    int even_length = even.length-1;\n    bool is_odd = true;\n    foreach(i;\
    \ 0..odd.length)\n    {\n        if(is_odd)\n        {\n            if(odd_length\
    \ == -1)\n            {\n                result[i] = even[even_length];\n    \
    \            even_length--;\n            }\n            else\n            {\n\
    \                result[i] = odd[odd_length];\n                odd_length--;\n\
    \            }\n        }\n        else\n        {\n            if(even_length\
    \ == -1)\n            {\n                result[i] = odd[odd_length];\n      \
    \          odd_length--;\n            }\n            else\n            {\n   \
    \             result[i] = even[even_length];\n                even_length--;\n\
    \            }\n        }\n        is_odd = !is_odd;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1fvi21l_.d(23): Error: no property `sort` for type `long[]`

    /tmp/tmp1fvi21l_.d(39): Error: cannot implicitly convert expression `odd.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp1fvi21l_.d(40): Error: cannot implicitly convert expression `even.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1fvi21l_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return [];\n    else \n    {\n        auto\
    \ min = min(lst);\n        long[] new_list = lst[min..$];\n        return [min,\
    \ max(new_list)] ~ strange_sort_list(new_list[0..max(new_list)]) ~ new_list[max(new_list)+1..$];\n\
    \    }\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzjnvjwu0.d(23): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpzjnvjwu0.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpzjnvjwu0.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpzjnvjwu0.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzjnvjwu0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto n = lst.length;\n    long[] res;\n    res.length = n;\n \
    \   auto indx = 0;\n    auto rep = sort(lst).length;\n    if (n == 0) \n    {\n\
    \        return res;\n    }\n    else \n    {\n        while (rep > 0) \n    \
    \    {\n            if (indx % 2 == 0) \n            {\n                res[indx]\
    \ = min(lst);\n                lst.remove(res[indx]);\n            }\n       \
    \     else \n            {\n                res[indx] = max(lst);\n          \
    \      lst.remove(res[indx]);\n            }\n            rep--;\n           \
    \ indx++;\n        }\n        return res;\n    }\n}\n/*\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5fa9f88j.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5fa9f88j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length <= 1)\n        return lst;\n    auto t = zip(lst,\
    \ iota(lst.length));\n    t.sort!(\"a[0] < b[0]\");\n    auto smallest = t[0];\n\
    \    t.removeFront();\n    auto result = [smallest[0]];\n    while (t.length >\
    \ 0)\n    {\n        if (t.length == 1)\n        {\n            result ~= t[0][0];\n\
    \            t.removeFront();\n        }\n        else\n        {\n          \
    \  result ~= t[0][0];\n            result ~= t[$-1][0];\n            t.removeFront();\n\
    \            t.removeBack();\n        }\n    }\n    return result;\n}\n \n/*\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqtp_9jnh.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtp_9jnh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int index = 0;\n    long[] new_list = new long[lst.length];\n\
    \    long min_val = min(lst);\n    long max_val = max(lst);\n    if (lst.length\
    \ == 0)\n        return lst;\n    while (index < lst.length) {\n        new_list[index]\
    \ = min_val;\n        index++;\n        if (index < lst.length) {\n          \
    \  new_list[index] = max_val;\n            index++;\n        }\n    }\n    return\
    \ new_list;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5w1kcli_.d(22): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp5w1kcli_.d(23): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5w1kcli_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] sorted_list;\n    long min_elem;\n    min_elem = min(lst);\n\
    \    sorted_list ~= min_elem;\n    auto b = lst.filter!(e => e != min_elem);\n\
    \    long[] lst2 = lst.filter!(e => e != min_elem);\n    lst = lst2;\n    int\
    \ i = 0;\n    while(lst.length != 0)\n    {\n        min_elem = min(lst);\n  \
    \      sorted_list ~= min_elem;\n        lst = lst.filter!(e => e != min_elem);\n\
    \        long max_elem = max(lst);\n        sorted_list ~= max_elem;\n       \
    \ lst = lst.filter!(e => e != max_elem);\n    }\n    return sorted_list;\n}\n\
    \ \nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7w6je08q.d(22): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp7w6je08q.d(24): Error: no property `filter` for type `long[]`

    /tmp/tmp7w6je08q.d(25): Error: no property `filter` for type `long[]`

    /tmp/tmp7w6je08q.d(30): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp7w6je08q.d(32): Error: no property `filter` for type `long[]`

    /tmp/tmp7w6je08q.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp7w6je08q.d(35): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7w6je08q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n  if (lst.length < 2) \n  {\n    return lst;\n  }\n  bool[] marked\
    \ = new bool[lst.length];\n  foreach (i; 0 .. lst.length) \n  {\n    marked[i]\
    \ = false;\n  }\n  auto max_it = maxElement(lst);\n  long max_index = max_it[1];\n\
    \  long result_len = lst.length;\n  long[] result = new long[result_len];\n  result[0]\
    \ = lst[max_index];\n  marked[max_index] = true;\n  while (result_len > 1) \n\
    \  {\n    long min_index = lst.length - 1;\n    long max_index = 0;\n    foreach\
    \ (i; 0 .. lst.length) \n    {\n      if (!marked[i]) \n      {\n        if (lst[i]\
    \ > lst[max_index]) \n        {\n          max_index = i;\n        }\n       \
    \ if (lst[i] < lst[min_index]) \n        {\n          min_index = i;\n       \
    \ }\n      }\n    }\n    result[result_len - 1] = lst[min_index];\n    marked[min_index]\
    \ = true;\n    result[result_len - 2] = lst[max_index];\n    marked[max_index]\
    \ = true;\n    result_len -= 2;\n  }\n  return result;\n}\n/*\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81q99_yw.d(61): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81q99_yw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto s = lst.dup;\n    if (s.length <= 1) \n    {\n        return\
    \ s;\n    }\n    auto res = new long[](s.length);\n    immutable bool asc = false;\n\
    \    immutable bool inc = true;\n    immutable bool dec = false;\n    immutable\
    \ bool equal = true;\n    immutable bool not_equal = false;\n    immutable long\
    \ temp = 1;\n    immutable long k = 0;\n    immutable long min = s[0];\n    immutable\
    \ long max = s[0];\n    foreach (i; 1..s.length) \n    {\n        if (s[i] < min)\
    \ \n        {\n            min = s[i];\n        }\n        if (s[i] > max) \n\
    \        {\n            max = s[i];\n        }\n    }\n    if (s.length == 2)\
    \ \n    {\n        res[0] = min;\n        res[1] = max;\n        return res;\n\
    \    }\n    if (s.length == 3) \n    {\n        res[0] = min;\n        res[1]\
    \ = max;\n        res[2] = s[0] + s[1] + s[2] - res[0] - res[1];\n        return\
    \ res;\n    }\n    if (s.length % 2 == 0) \n    {\n        s.length -= 1;\n  \
    \  }\n    while (s.length > 1) \n    {\n        if (k % 2 == 0) \n        {\n\
    \            temp = s[0];\n            inc = true;\n            dec = false;\n\
    \            equal = true;\n            not_equal = false;\n            asc =\
    \ false;\n        }\n        else \n        {\n            temp = s[0];\n    \
    \        inc = false;\n            dec = true;\n            equal = true;\n  \
    \          not_equal = false;\n            asc = true;\n        }\n        for\
    \ (immutable long i = 1; i < s.length; i++) \n        {\n            if (dec)\
    \ \n            {\n                if (s[i] > temp) \n                {\n    \
    \                temp = s[i\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjv2h6z4a.d(90): Error: found `unittest` when expecting `,`

    /tmp/tmpjv2h6z4a.d(104): Error: found `void` when expecting `,`

    /tmp/tmpjv2h6z4a.d(104): Error: found `{` when expecting `,`

    /tmp/tmpjv2h6z4a.d(104): Error: expression expected, not `}`

    /tmp/tmpjv2h6z4a.d(104): Error: found `End of File` when expecting `,`

    /tmp/tmpjv2h6z4a.d(104): Error: found `End of File` when expecting `]`

    /tmp/tmpjv2h6z4a.d(104): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpjv2h6z4a.d(104): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpjv2h6z4a.d(104): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpjv2h6z4a.d(104): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpjv2h6z4a.d(104): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpjv2h6z4a.d(104): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o'
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length < 1)\n        return lst;\n    long[] ret = new\
    \ long[lst.length];\n    lst.sort();\n    uint idx = 0;\n    while (idx < lst.length)\n\
    \    {\n        if (idx % 2 == 0)\n            ret[idx] = lst[idx / 2];\n    \
    \    else\n            ret[idx] = lst[lst.length - (idx + 1) / 2];\n        idx\
    \ += 1;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr1xrvjjs.d(23): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr1xrvjjs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n    immutable size = lst.length;\n    immutable half = size / 2;\n\
    \    if (size < 3) return lst;\n    auto result = [lst[0], lst[size - 1]];\n \
    \   auto l = strange_sort_list(lst[1 .. half]);\n    auto r = strange_sort_list(lst[half\
    \ .. $ - 1]);\n    foreach(i; 0 .. half)\n    {\n        result ~= l[i];\n   \
    \     result ~= r[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpl465q2fy.d(28): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428abe]

    ??:? long[] tmpl465q2fy.strange_sort_list(long[]) [0x427fb8]

    ??:? void tmpl465q2fy.__unittest_L33_C1() [0x4280c3]

    ??:? void tmpl465q2fy.__modtest() [0x42878c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d47b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42c30e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430d61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431210]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ced]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c2e5]

    ??:? runModuleUnitTests [0x42d251]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int fun'
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // \n    auto res = new long[lst.length];\n    auto min_max =\
    \ minMax(lst);\n    auto min_val = min_max[0];\n    auto max_val = min_max[1];\n\
    \    auto min_num = lst.count(min_val);\n    auto max_num = lst.count(max_val);\n\
    \    // \n    auto lhs = new long[lst.length-max_num];\n    auto rhs = new long[lst.length-min_num];\n\
    \    // \n    auto lhs_idx = 0L;\n    auto rhs_idx = 0L;\n    // \n    foreach(item;\
    \ lst)\n    {\n        if(item > min_val)\n        {\n            lhs[lhs_idx]\
    \ = item;\n            lhs_idx++;\n        }\n        else if(item < max_val)\n\
    \        {\n            rhs[rhs_idx] = item;\n            rhs_idx++;\n       \
    \ }\n    }\n    // \n    auto res_idx = 0L;\n    auto lhs_len = lhs.length;\n\
    \    auto rhs_len = rhs.length;\n    // \n    while(res_idx < lst.length)\n  \
    \  {\n        if(res_idx % 2 == 0)\n        {\n            res[res_idx] = min_val;\n\
    \            min_num--;\n        }\n        else\n        {\n            if(lhs_len\
    \ > 0 && rhs_len > 0)\n            {\n                res[res_idx] = max(lhs[lhs_len-1],\
    \ rhs[rhs_len-1]);\n                if(lhs[lhs_len-1] >= rhs[rhs_len-1])\n   \
    \             {\n                    lhs_len--;\n                }\n         \
    \       else\n                {\n                    rhs_len--;\n            \
    \    }\n            }\n            else if(lhs_len > 0)\n            {\n     \
    \           res[res_idx] = lhs[lhs_len-1];\n               \nunittest\n{\n   \
    \ alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L])\
    \ == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L,\
    \ 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L,\
    \ 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsao_0fje.d(77): Error: found `unittest` instead of statement

    /tmp/tmpsao_0fje.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpsao_0fje.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpsao_0fje.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsao_0fje.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    import std.typecons;\n    import std.range;\n    import std.algorithm;\n\
    \    immutable length = lst.length;\n    long[] arr = new long[length];\n    auto\
    \ tmp = lst.map!(a => tuple(a, true)).array;\n    for (size_t i = 0; i < length;\
    \ i++)\n    {\n        arr[i] = tmp.min!.front;\n        tmp.remove(tmp.min!);\n\
    \        if (!tmp.empty)\n        {\n            arr[i + 1] = tmp.max!.front;\n\
    \            tmp.remove(tmp.max!);\n        }\n    }\n    return arr;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwfgmr3_.d(28): Error: template argument expected following `!`

    /tmp/tmppwfgmr3_.d(29): Error: template argument expected following `!`

    /tmp/tmppwfgmr3_.d(32): Error: template argument expected following `!`

    /tmp/tmppwfgmr3_.d(33): Error: template argument expected following `!`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwfgmr3_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    else if (lst.length\
    \ == 1)\n        return lst;\n    else\n    {\n        long min = min(lst);\n\
    \        long max = max(lst);\n        long res[] = new long[lst.length];\n  \
    \      int i = 0;\n        while (min != max)\n        {\n            res[i] =\
    \ min;\n            res[i + 1] = max;\n            i += 2;\n            lst -=\
    \ [min, max];\n            min = min(lst);\n            max = max(lst);\n    \
    \    }\n        res[i] = min;\n        return res;\n    }\n}\nunittest\n{\n  \
    \  alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L])\
    \ == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L,\
    \ 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L,\
    \ 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkdf335so.d(28): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] res`

    /tmp/tmpkdf335so.d(26): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpkdf335so.d(27): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpkdf335so.d(35): Error: invalid array operation `lst -= [min, max]` (possible
    missing [])

    /tmp/tmpkdf335so.d(36): Error: function expected before `()`, not `min` of type
    `long`

    /tmp/tmpkdf335so.d(37): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkdf335so.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    alias minMax =\
    \ tuple!(long, long);\n    auto sortHelper = (lst) {\n        if (lst.length <=\
    \ 1)\n            return lst;\n        long max = lst[0];\n        long min =\
    \ lst[0];\n        long maxIdx = 0;\n        long minIdx = 0;\n        foreach\
    \ (i, elem; lst)\n        {\n            if (elem > max)\n            {\n    \
    \            max = elem;\n                maxIdx = i;\n            }\n       \
    \     if (elem < min)\n            {\n                min = elem;\n          \
    \      minIdx = i;\n            }\n        }\n        long[] newLst = lst[0..minIdx]\
    \ ~ lst[minIdx + 1..$];\n        return (newLst[0..maxIdx] ~ newLst[maxIdx + 1..$])\n\
    \            .array;\n    };\n    long[] result = [lst[0]];\n    lst = lst[1..$];\n\
    \    bool isMax = true;\n    while (lst.length > 0)\n    {\n        if (isMax)\n\
    \        {\n            auto max = sortHelper(lst);\n            result ~= max[0];\n\
    \            lst = max[1..$];\n        }\n        else\n        {\n          \
    \  auto min = sortHelper(lst);\n            result ~= min[$ - 1];\n          \
    \  lst = min[0..$ - 1];\n        }\n        isMax = !isMax;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc_313kc2.d(23): Error: variable `tmpc_313kc2.strange_sort_list.sortHelper`
    type `void` is inferred from initializer `(lst)

    {

    if (lst.length <= 1)

    return lst;

    long max = lst[0];

    long min = lst[0];

    long maxIdx = 0;

    long minIdx = 0;

    foreach (i, elem; lst)

    {

    if (elem > max)

    {

    max = elem;

    maxIdx = i;

    }

    if (elem < min)

    {

    min = elem;

    minIdx = i;

    }

    }

    long[] newLst = lst[0..minIdx] ~ lst[minIdx + 1..__dollar];

    return (newLst[0..maxIdx] ~ newLst[maxIdx + 1..__dollar]).array;

    }

    `, and variables cannot be of type `void`

    /tmp/tmpc_313kc2.d(23): Error: template lambda has no value

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc_313kc2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    if (lst.length\
    \ == 1)\n        return lst;\n    return strange_sort_list(lst[0..$/2]) + strange_sort_list(lst[$/2..$]);\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt_lnp5l3.d(24): Error: invalid array operation `strange_sort_list(lst[0..__dollar
    / 2LU]) + strange_sort_list(lst[__dollar / 2LU..__dollar])` (possible missing
    [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt_lnp5l3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] ret = new\
    \ long[lst.length];\n    // TODO: Write code to implement strange_sort_list()\n\
    \    lst.sort();\n    size_t idx = 0;\n    while (lst.length > 1)\n    {\n   \
    \     ret[idx] = lst[0];\n        ret[idx + 1] = lst[$ - 1];\n        idx += 2;\n\
    \        lst = lst[1 .. $ - 1];\n    }\n    ret[idx] = lst[0];\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfzww8_4i.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfzww8_4i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length==0) return new long[0];\n    long[] result = new\
    \ long[lst.length];\n    int pos = 0;\n    int[] neg = new int[1];\n    neg[0]\
    \ = 0;\n    long[] temp = new long[lst.length];\n    long min = min(lst);\n  \
    \  for (long i = 0; i < lst.length; i++) \n    {\n        if (lst[(int)i] > min)\
    \ \n        {\n            temp[neg[0]] = lst[(int)i];\n            neg[0]++;\n\
    \        }\n    }\n    result[pos] = min;\n    pos++;\n    temp = temp[0..neg[0]];\n\
    \    while (neg[0] > 0) \n    {\n        min = min(temp);\n        result[pos]\
    \ = min;\n        pos++;\n        long max = max(temp);\n        result[pos] =\
    \ max;\n        pos++;\n        neg[0] -= 2;\n        temp = temp[0..neg[0]];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9um626z.d(29): Error: C style cast illegal, use `cast(int)i`

    /tmp/tmpl9um626z.d(31): Error: C style cast illegal, use `cast(int)i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9um626z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length <= 1)\n        return lst;\n    else\n    {\n \
    \       auto tmp = lst.dup;\n        tmp.sort;\n        long[] sorted = [tmp[0],\
    \ tmp[$-1]];\n        tmp.remove(tmp[0]);\n        tmp.remove(tmp[$-1]);\n   \
    \     while(tmp.length != 0)\n        {\n            sorted ~= tmp[0];\n     \
    \       sorted ~= tmp[$-1];\n            tmp.remove(tmp[0]);\n            tmp.remove(tmp[$-1]);\n\
    \        }\n        return sorted;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpht6a7sqx.d(25): Error: no property `sort` for type `long[]`

    /tmp/tmpht6a7sqx.d(27): Error: no property `remove` for type `long[]`

    /tmp/tmpht6a7sqx.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmpht6a7sqx.d(33): Error: no property `remove` for type `long[]`

    /tmp/tmpht6a7sqx.d(34): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpht6a7sqx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ bool ascending = true;\n    return lst.sort()\n        .filter!(a => a != lst[0])\n\
    \        .sort!((a, b) => a > b).map!(a => \n        {\n            auto aa =\
    \ a;\n            a = aa;\n            if (ascending) \n            {\n      \
    \          return a;\n            }\n            else \n            {\n      \
    \          return a.popFront();\n            }\n        })\n        .array()\n\
    \        .insert(0, lst[0]);\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyobx21rr.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyobx21rr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length < 2) return lst;\n    if (lst.length == 2) return\
    \ [min(lst[0], lst[1]), max(lst[0], lst[1])];\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpokh65xnv.d(21): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpokh65xnv.d(21): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpokh65xnv.d(22): Error: undefined identifier `res`, did you mean struct
    `Yes`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpokh65xnv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    sort(lst);\n    long[] res = new long[$];\n    int i = 0;\n  \
    \  int j = (lst.length - 1);\n    while (true)\n    {\n        res[i] = lst[i];\n\
    \        i += 1;\n        if (i >= lst.length) break;\n        res[i] = lst[j];\n\
    \        j -= 1;\n        i += 1;\n        if (i >= lst.length) break;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpni9m4q27.d(20): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpni9m4q27.d(21): Error: undefined identifier `__dollar`

    /tmp/tmpni9m4q27.d(23): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni9m4q27.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    enum bp = 0, ep = lst.length;\n    long[] res = new long[lst.length];\n\
    \    int res_i = 0;\n    while (bp < ep)\n    {\n        long min = min_of_unseen(lst,\
    \ bp, ep);\n        long max = max_of_unseen(lst, bp, ep);\n        if (min <\
    \ max)\n        {\n            res[res_i++] = min;\n            res[res_i++] =\
    \ max;\n        }\n        else if (min == max)\n        {\n            res[res_i++]\
    \ = min;\n        }\n        bp = min + 1;\n        ep = max;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpll5eb671.d(20): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpll5eb671.d(25): Error: undefined identifier `min_of_unseen`

    /tmp/tmpll5eb671.d(26): Error: undefined identifier `max_of_unseen`

    /tmp/tmpll5eb671.d(36): Error: cannot modify constant `bp`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpll5eb671.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    long min = 1000000000000000;\n\
    \    long max = -1000000000000000;\n    for (long l : lst)\n    {\n        if\
    \ (l < min)\n            min = l;\n        if (l > max)\n            max = l;\n\
    \    }\n    uint[long] elements = [min:min];\n    long[] remaining = [min];\n\
    \    for (long l : lst)\n    {\n        if (l != min)\n            remaining ~=\
    \ l;\n    }\n    uint[] result = [];\n    while (true)\n    {\n        if (result.length\
    \ % 2 == 0)\n        {\n            long elem = remaining[0];\n            result\
    \ ~= elem;\n            remaining = remaining[1..$];\n            elements[elem]\
    \ = elem;\n        }\n        else\n        {\n            long elem = remaining[$-1];\n\
    \            result ~= elem;\n            remaining = remaining[0..$-1];\n   \
    \         elements[elem] = elem;\n        }\n        if (result.length == lst.length)\n\
    \            break;\n        if (result.length % 2 == 0)\n        {\n        \
    \    long last = remaining[$-1];\n            if (last > elements[$-1])\n    \
    \        {\n                result ~= last;\n                remaining = remaining[0..$-1];\n\
    \                elements[last] = last;\n            }\n            else\n   \
    \         {\n                long first = remaining[0];\n                result\
    \ ~= first;\n                remaining = remaining[1..$];\n                elements[first]\
    \ = first;\n            }\n        }\n        else\n        {\n            long\
    \ last = remaining[$-1];\n            if (last < elements[$-1])\n            {\n\
    \                result ~= last;\n                remaining = remaining[0..$-1];\n\
    \                elements[last] = last;\n            }\n            else\n   \
    \         {\n                long first = remaining[0];\n                result\
    \ ~= first;\n                remaining = remaining[1..$];\n                elements[first]\
    \ = first;\n            }\n        }\n    }\n    return result;\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpneth4wfc.d(24): Error: semicolon expected, not `:`

    /tmp/tmpneth4wfc.d(24): Error: expression expected, not `:`

    /tmp/tmpneth4wfc.d(24): Error: found `lst` when expecting `;` following `for`
    condition

    /tmp/tmpneth4wfc.d(33): Error: semicolon expected, not `:`

    /tmp/tmpneth4wfc.d(33): Error: expression expected, not `:`

    /tmp/tmpneth4wfc.d(33): Error: found `lst` when expecting `;` following `for`
    condition

    /tmp/tmpneth4wfc.d(93): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpneth4wfc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    auto tmpLst = lst.dup;\n\
    \    auto r = appender!(typeof(return));\n    bool[int] isVisited = bool[int](false);\n\
    \    bool isEven = true;\n    bool found = false;\n    while (tmpLst.length !=\
    \ 0) {\n        long min = tmpLst[0];\n        long max = tmpLst[0];\n       \
    \ int idxMin = 0;\n        int idxMax = 0;\n        foreach (i, e; tmpLst) {\n\
    \            if (e < min) {\n                min = e;\n                idxMin\
    \ = i;\n            }\n            if (e > max) {\n                max = e;\n\
    \                idxMax = i;\n            }\n        }\n        if (isEven) {\n\
    \            r.put(min);\n            isVisited[idxMin] = true;\n        } else\
    \ {\n            r.put(max);\n            isVisited[idxMax] = true;\n        }\n\
    \        isEven = !isEven;\n        foreach (i, e; tmpLst) {\n            if (!isVisited[i])\
    \ {\n                found = true;\n                break;\n            }\n  \
    \      }\n        if (!found) {\n            tmpLst = [];\n        }\n    }\n\
    \    return r.data;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3dvuidb5.d(23): Error: found `[` when expecting `.` following bool

    /tmp/tmp3dvuidb5.d(23): Error: found `int` when expecting identifier following
    `bool`.

    /tmp/tmp3dvuidb5.d(23): Error: semicolon expected, not `]`

    /tmp/tmp3dvuidb5.d(23): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3dvuidb5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return new long[0];\n    if (lst.length\
    \ == 1)\n        return lst;\n    long minimum = lst[0];\n    long maximum = lst[0];\n\
    \    foreach (l; lst)\n    {\n        if (l < minimum)\n            minimum =\
    \ l;\n        if (l > maximum)\n            maximum = l;\n    }\n    long[] minList\
    \ = new long[lst.length];\n    long[] maxList = new long[lst.length];\n    int\
    \ minCount = 0;\n    int maxCount = 0;\n    foreach (i; lst)\n    {\n        if\
    \ (i == minimum)\n            continue;\n        if (i == maximum)\n         \
    \   continue;\n        if (i < minimum + maximum)\n            minList[minCount++]\
    \ = i;\n        else\n            maxList[maxCount++] = i;\n    }\n    minList\
    \ = minList[0..minCount];\n    maxList = maxList[0..maxCount];\n    minList =\
    \ minList.sort(min);\n    maxList = maxList.sort(max);\n    long[] result = new\
    \ long[lst.length];\n    result[0] = minimum;\n    result[lst.length - 1] = maximum;\n\
    \    int current = 1;\n    for (;;)\n    {\n        if (minList.length == 0 &&\
    \ maxList.length == 0)\n            break;\n        if (minList.length != 0)\n\
    \        {\n            result[current] = minList[0];\n            minList = minList[1..$];\n\
    \            current++;\n        }\n        if (maxList.length != 0)\n       \
    \ {\n            result[current] = maxList[0];\n            maxList = maxList[1..$];\n\
    \            current++;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdtg4jncl.d(50): Error: no property `sort` for type `long[]`

    /tmp/tmpdtg4jncl.d(51): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdtg4jncl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return new long[0];\n    if (lst.length ==\
    \ 1) return lst;\n    // Sort the array\n    auto s = lst.sort();\n    int l =\
    \ s.length - 1;\n    // Generate result array\n    long[] res = new long[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        // If it's the end of\
    \ the array\n        if (l == 0)\n        {\n            res[i] = s[l];\n    \
    \        break;\n        }\n        // Get the minimum and maximum values, depending\
    \ on i\n        if (i % 2 == 0)\n        {\n            res[i] = s[0];\n     \
    \       s = s[1..$];\n        }\n        else\n        {\n            res[i] =\
    \ s[l];\n            s = s[0..$-1];\n        }\n        l--;\n    }\n    return\
    \ res;\n}\n \nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp20k4fhic.d(23): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp20k4fhic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    sort(lst);\n    immutable len = lst.length;\n    immutable n =\
    \ len / 2;\n    long[] l;\n    l.length = len;\n    foreach(immutable i, immutable\
    \ v; lst[0 .. n])\n    {\n        l[i] = v;\n        l[len - i - 1] = lst[n +\
    \ i];\n    }\n    if (len % 2 == 1)\n        l[n] = lst[n];\n    return l;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyrw7if0t.d(20): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyrw7if0t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length < 2)\n        return lst;\n    \n    long[] out\
    \ = new long[lst.length];\n    auto range = zip(iota(0), lst).sort!((a, b) =>\
    \ a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0);\n    int index = 0;\n    while (range.length\
    \ > 0)\n    {\n        if (index % 2 == 0)\n            out[index] = range.front[1];\n\
    \        else\n            out[index] = range.back[1];\n        index++;\n   \
    \     range = range[1..$-1];\n    }\n    return out;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfgd3u2ou.d(23): Error: no identifier for declarator `long[]`

    /tmp/tmpfgd3u2ou.d(23): Error: found `out` instead of statement

    /tmp/tmpfgd3u2ou.d(29): Error: found `out` instead of statement

    /tmp/tmpfgd3u2ou.d(31): Error: found `out` instead of statement

    /tmp/tmpfgd3u2ou.d(35): Error: expression expected, not `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfgd3u2ou.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return [];\n    if (lst.length == 1) return\
    \ lst;\n    import std.algorithm;\n    import std.array;\n    int step = 2;\n\
    \    bool is_inc = true;\n    long[] new_lst = new long[lst.length];\n    foreach\
    \ (idx, item; lst.enumerate)\n    {\n        new_lst[idx] = item;\n    }\n   \
    \ foreach (idx, item; new_lst.enumerate)\n    {\n        if (idx < lst.length/2)\n\
    \        {\n            new_lst[idx] = lst[idx];\n        }\n        else if (idx\
    \ < lst.length-1)\n        {\n            new_lst[idx] = lst[lst.length-1-idx];\n\
    \        }\n        else\n        {\n            new_lst[idx] = lst[idx];\n  \
    \      }\n    }\n    return new_lst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_xb70tnm.d(27): Error: no property `enumerate` for type `long[]`

    /tmp/tmp_xb70tnm.d(31): Error: no property `enumerate` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_xb70tnm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tstatic assert(!lst.empty);\n\tauto min_index = minIndex(lst);\n\t\
    long[] result = [lst[min_index]];\n\tlong[] remaining = lst.dup;\n\tremaining.remove(min_index);\n\
    \twhile(!remaining.empty)\n\t{\n\t\tif(remaining.length%2 == 0)\n\t\t{\n\t\t\t\
    auto min_index = minIndex(remaining);\n\t\t\tresult ~= remaining[min_index];\n\
    \t\t\tremaining.remove(min_index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto max_index\
    \ = maxIndex(remaining);\n\t\t\tresult ~= remaining[max_index];\n\t\t\tremaining.remove(max_index);\n\
    \t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnwfqxi1z.d(20): Error: no property `empty` for type `long[]`

    /tmp/tmpnwfqxi1z.d(20):        while evaluating: `static assert(!lst.empty)`

    /tmp/tmpnwfqxi1z.d(21): Error: undefined identifier `minIndex`

    /tmp/tmpnwfqxi1z.d(24): Error: no property `remove` for type `long[]`

    /tmp/tmpnwfqxi1z.d(25): Error: no property `empty` for type `long[]`

    /tmp/tmpnwfqxi1z.d(29): Error: undefined identifier `minIndex`, did you mean variable
    `min_index`?

    /tmp/tmpnwfqxi1z.d(29): Error: variable `min_index` is shadowing variable `tmpnwfqxi1z.strange_sort_list.min_index`

    /tmp/tmpnwfqxi1z.d(31): Error: no property `remove` for type `long[]`

    /tmp/tmpnwfqxi1z.d(35): Error: undefined identifier `maxIndex`

    /tmp/tmpnwfqxi1z.d(37): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnwfqxi1z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] orderedList = lst.dup.sort.array;\n    if (orderedList.length\
    \ % 2 == 0)\n    {\n        for (int i = 0; i < orderedList.length; i += 2)\n\
    \        {\n            long l1 = orderedList[i];\n            long l2 = orderedList[i\
    \ + 1];\n            orderedList[i] = l2;\n            orderedList[i + 1] = l1;\n\
    \        }\n    }\n    else\n    {\n        int maxPos = orderedList.length -\
    \ 1;\n        for (int i = 0; i < orderedList.length; i += 2)\n        {\n   \
    \         long l1 = orderedList[i];\n            long l2 = orderedList[maxPos];\n\
    \            orderedList[i] = l2;\n            orderedList[maxPos] = l1;\n   \
    \         maxPos--;\n        }\n    }\n    return orderedList;\n}\n/*\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdt4nzsh0.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdt4nzsh0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164253
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ long min = min(lst);\n    long max = max(lst);\n    long[] sorted = new long[lst.length];\n\
    \    bool isMin = true;\n    long[] remaining = lst;\n    int count = 0;\n   \
    \ while (count < lst.length) \n    {\n        if (isMin) \n        {\n       \
    \     isMin = false;\n            remaining = remove(remaining, min);\n      \
    \      sorted[count] = min;\n        } \n        else \n        {\n          \
    \  isMin = true;\n            remaining = remove(remaining, max);\n          \
    \  sorted[count] = max;\n        }\n        min = min(remaining);\n        max\
    \ = max(remaining);\n        count++;\n    }\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmo7jaa4w.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpmo7jaa4w.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpmo7jaa4w.d(35): Error: undefined identifier `remove`

    /tmp/tmpmo7jaa4w.d(41): Error: undefined identifier `remove`

    /tmp/tmpmo7jaa4w.d(44): Error: function expected before `()`, not `min` of type
    `long`

    /tmp/tmpmo7jaa4w.d(45): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmo7jaa4w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    auto direction =\
    \ 1;\n    auto result = new long[lst.length];\n    auto source = lst.dup;\n  \
    \  int i;\n    foreach (resultIndex; 0 .. result.length) \n    {\n        auto\
    \ best = source[0];\n        int bestIndex = 0;\n        for (i = 1; i < source.length;\
    \ i++) \n        {\n            if (direction == 1) \n            {\n        \
    \        if (source[i] > best) \n                {\n                    best =\
    \ source[i];\n                    bestIndex = i;\n                }\n        \
    \    }\n            else \n            {\n                if (source[i] < best)\
    \ \n                {\n                    best = source[i];\n               \
    \     bestIndex = i;\n                }\n            }\n        }\n        result[resultIndex]\
    \ = best;\n        source = source[0 .. bestIndex] ~ source[bestIndex + 1 .. $];\n\
    \        direction *= -1;\n    }\n    return result;\n}\nstatic assert(strange_sort_list([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\nstatic assert(strange_sort_list([5L, 5L,\
    \ 5L, 5L]) == [5L, 5L, 5L, 5L]);\nstatic assert(strange_sort_list([]) == []);\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj5x7vsjv.d(55): Error: static assert:  `strange_sort_list([1L,
    2L, 3L, 4L]) == [1L, 4L, 2L, 3L]` is false

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj5x7vsjv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] sortedArray = [];\n    sort(lst);\n    auto plus = lst.length;\n\
    \    while(plus != 0) {\n        sortedArray ~= lst[0];\n        sortedArray ~=\
    \ lst[plus - 1];\n        lst = lst[1..$-1];\n        plus -= 2;\n    }\n    return\
    \ sortedArray;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n \
    \   assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvip54wzh.d(21): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvip54wzh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ else \n    {\n        auto order = new long[lst.length];\n        auto max_min\
    \ = minmax(lst);\n        auto max = max_min[1];\n        auto min = max_min[0];\n\
    \        auto x = 0;\n        auto y = lst.length - 1;\n        foreach (idx,\
    \ value; lst) \n        {\n            if (idx % 2 == 0) \n            {\n   \
    \             order[idx] = min;\n                min = std.algorithm.partition(lst,\
    \ v => v > min).front;\n            }\n            else \n            {\n    \
    \            order[idx] = max;\n                max = std.algorithm.partition(lst,\
    \ v => v < max).back;\n            }\n        }\n        return order;\n    }\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppzf1477n.d(27): Error: undefined identifier `minmax`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppzf1477n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ long[] result = new long[lst.length];\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std\nunittest\n{\n    alias candidate = strange_sort_list;\n\n \
    \   assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx5ybima_.d(55): Error: found `unittest` when expecting `,`

    /tmp/tmpx5ybima_.d(69): Error: found `void` when expecting `,`

    /tmp/tmpx5ybima_.d(69): Error: found `{` when expecting `,`

    /tmp/tmpx5ybima_.d(69): Error: expression expected, not `}`

    /tmp/tmpx5ybima_.d(69): Error: found `End of File` when expecting `,`

    /tmp/tmpx5ybima_.d(69): Error: found `End of File` when expecting `)`

    /tmp/tmpx5ybima_.d(69): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpx5ybima_.d(69): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx5ybima_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n    const auto N = lst.length;\n    if (N == 0)\n        return lst;\n\
    \    auto indices = iota(0L, N).array;\n    auto tmp = lst.array;\n    std.algorithm.sort(tmp,\
    \ indices, std.less());\n    auto res = appender!(long[])();\n    foreach (i;\
    \ 0 .. N / 2)\n    {\n        res.put(lst[indices[i]]);\n        res.put(lst[indices[N\
    \ - i - 1]]);\n    }\n    if (N % 2)\n        res.put(lst[indices[N / 2]]);\n\
    \    return res.data;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq9evf2r1.d(23): Error: undefined identifier `iota`

    /tmp/tmpq9evf2r1.d(24): Error: no property `array` for type `long[]`

    /tmp/tmpq9evf2r1.d(25): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmpq9evf2r1.d(26): Error: template instance `appender!(long[])` template
    `appender` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq9evf2r1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto z = lst.dup;\n\
    \    z = z.sort();\n    lst.length = 0;\n    for (int i = 0; i < z.length; i++)\n\
    \    {\n        if (i % 2 == 0)\n            lst ~= z[i];\n        else\n    \
    \        lst.insert(0, z[i]);\n    }\n    return lst;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_hpqq6f1.d(23): Error: no property `sort` for type `long[]`

    /tmp/tmp_hpqq6f1.d(30): Error: no property `insert` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hpqq6f1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int min = min(lst).i;\n\
    \    int max = max(lst).i;\n    int index = 0;\n    long[] remaining = new long[lst.length];\n\
    \    int remaining_index = 0;\n    int remaining_length = lst.length;\n    foreach(int\
    \ i; lst)\n    {\n        if(i == min || i == max)\n        {\n            res[index]\
    \ = i;\n            index++;\n        }\n        else\n        {\n           \
    \ remaining[remaining_index] = i;\n            remaining_index++;\n        }\n\
    \    }\n    remaining_length -= 2;\n    while(remaining_length > 0)\n    {\n \
    \       min = min(remaining).i;\n        max = max(remaining).i;\n        foreach(int\
    \ i; remaining)\n        {\n            if(i == min || i == max)\n           \
    \ {\n                res[index] = i;\n                index++;\n            }\n\
    \            else\n            {\n                remaining[remaining_index] =\
    \ i;\n                remaining_index++;\n            }\n        }\n        remaining_length\
    \ -= 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptbieoizr.d(21): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmptbieoizr.d(22): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmptbieoizr.d(26): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmptbieoizr.d(27): Error: cannot implicitly convert expression `__r73[__key74]`
    of type `long` to `int`

    /tmp/tmptbieoizr.d(43): Error: function expected before `()`, not `min` of type
    `int`

    /tmp/tmptbieoizr.d(44): Error: function expected before `()`, not `max` of type
    `int`

    /tmp/tmptbieoizr.d(45): Error: cannot implicitly convert expression `__r75[__key76]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptbieoizr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // your code here\n    return null;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zylqk92.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x4287c5]

    ??:? void tmp6zylqk92.__unittest_L23_C1() [0x427ef2]

    ??:? void tmp6zylqk92.__modtest() [0x428548]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b666]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307f9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430ca8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430785]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b63d]

    ??:? runModuleUnitTests [0x42c5a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c14]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    struct elem_pair(T, U)\n    {\n        T first;\n        U second;\n\
    \    }\n    auto make_pair(T, U)(T f, U s)\n    {\n        elem_pair!(T, U) p;\n\
    \        p.first = f;\n        p.second = s;\n        return p;\n    }\n    size_t\
    \ count = lst.length;\n    if (count == 0) return lst;\n    auto arr = lst.map!(a\
    \ => make_pair(a, false));\n    size_t i = 0;\n    while (i < count)\n    {\n\
    \        if (i & 1)\n        {\n            auto max = arr.max!((a, b) => a.first\
    \ > b.first && !a.second);\n            max.second = true;\n            lst[i]\
    \ = max.first;\n        }\n        else\n        {\n            auto min = arr.min!((a,\
    \ b) => a.first < b.first && !a.second);\n            min.second = true;\n   \
    \         lst[i] = min.first;\n        }\n        i++;\n    }\n    return lst;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpch0h6bmh.d(34): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpch0h6bmh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto sorted_list = lst.sort()[];\n    auto even_indexes = [](int\
    \ i){return (i & 1) == 0;};\n    auto odd_indexes = [](int i){return (i & 1) ==\
    \ 1;};\n    auto even_elements = sorted_list.filter!even_indexes;\n    auto odd_elements\
    \ = sorted_list.filter!odd_indexes;\n    return even_elements.array.reverse().array\
    \ ~ odd_elements.array;\n}\n/*\n    Given a list of integers and a value,\n  \
    \  return the sum of all integers that\n    are in the list and strictly higher\
    \ than the given value.\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu3mvz9wi.d(21): Error: found `i` when expecting `.` following int

    /tmp/tmpu3mvz9wi.d(21): Error: found `)` when expecting identifier following `int`.

    /tmp/tmpu3mvz9wi.d(21): Error: found `{` when expecting `,`

    /tmp/tmpu3mvz9wi.d(21): Error: expression expected, not `return`

    /tmp/tmpu3mvz9wi.d(21): Error: found `;` when expecting `,`

    /tmp/tmpu3mvz9wi.d(21): Error: expression expected, not `}`

    /tmp/tmpu3mvz9wi.d(21): Error: found `;` when expecting `,`

    /tmp/tmpu3mvz9wi.d(22): Error: expression expected, not `auto`

    /tmp/tmpu3mvz9wi.d(22): Error: found `odd_indexes` when expecting `,`

    /tmp/tmpu3mvz9wi.d(22): Error: expression expected, not `=`

    /tmp/tmpu3mvz9wi.d(22): Error: found `i` when expecting `.` following int

    /tmp/tmpu3mvz9wi.d(22): Error: found `)` when expecting identifier following `int`.

    /tmp/tmpu3mvz9wi.d(22): Error: found `{` when expecting `,`

    /tmp/tmpu3mvz9wi.d(22): Error: expression expected, not `return`

    /tmp/tmpu3mvz9wi.d(22): Error: found `;` when expecting `,`

    /tmp/tmpu3mvz9wi.d(22): E'
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n    if (lst.length == 0) \n        return lst; \n    else\n    {\
    \ \n        auto odd = new long[lst.length]; \n        auto even = new long[lst.length];\
    \ \n        int odd_ind = 0; \n        int even_ind = 0; \n        auto min_ind\
    \ = 0; \n        auto max_ind = lst.length - 1; \n        for (int i = 0; i <\
    \ lst.length; i++)\n        { \n            if (i % 2 == 0)\n            { \n\
    \                odd[odd_ind] = lst[min_ind]; \n                odd_ind++; \n\
    \                min_ind++; \n            } \n            else\n            {\
    \ \n                even[even_ind] = lst[max_ind]; \n                even_ind++;\
    \ \n                max_ind--; \n            } \n        } \n        return odd~even;\
    \ \n    } \n} \nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3x6m7bcf.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428935]

    ??:? void tmp3x6m7bcf.__unittest_L48_C1() [0x42805e]

    ??:? void tmp3x6m7bcf.__modtest() [0x4286b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cb5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b9ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430abd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9c5]

    ??:? runModuleUnitTests [0x42c931]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428df8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    bool asc = true;\n\
    \    long[] result = new long[lst.length];\n    long next = lst[0];\n    foreach\
    \ (i; 0 .. lst.length)\n    {\n        if (asc)\n        {\n            long max\
    \ = next;\n            foreach (j; 0 .. lst.length)\n            {\n         \
    \       if (lst[j] > max && !result.contains(lst[j]))\n                    max\
    \ = lst[j];\n            }\n            next = max;\n            asc = false;\n\
    \        }\n        else\n        {\n            long min = next;\n          \
    \  foreach (j; 0 .. lst.length)\n            {\n                if (lst[j] < min\
    \ && !result.contains(lst[j]))\n                    min = lst[j];\n          \
    \  }\n            next = min;\n            asc = true;\n        }\n        result[i]\
    \ = next;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl8pdctj1.d(32): Error: no property `contains` for type `long[]`

    /tmp/tmpl8pdctj1.d(43): Error: no property `contains` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl8pdctj1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tif (lst.length < 2)\n\t\treturn lst;\n\tif (lst.length < 3)\n\t\t\
    return lst[0] > lst[1] ? lst.reverse() : lst;\n\tlst.sort();\n\treturn std.range(0,\
    \ lst.length / 2)\n\t.map!((i) => tuple(lst[i], lst[lst.length - i - 1]))\n\t\
    .flatMap!((e) => e)\n\t.toArray();\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkyq2stpq.d(23): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmpkyq2stpq.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmpkyq2stpq.d(25): Deprecation: package `std.range` is not accessible here

    /tmp/tmpkyq2stpq.d(25): Error: function expected before `()`, not `package range`
    of type `void`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkyq2stpq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int[] positions = generate!(int)(lst.length).array;\n    enum\
    \ n = lst.length / 2 + lst.length % 2;\n    lst = lst.dup;\n    lst.sort();\n\
    \    auto result = new long[](n);\n    foreach (int i, int j; iota(0, n))\n  \
    \  {\n        if (i % 2 == 0) \n        {\n            result[i] = lst[positions[j]];\n\
    \            positions[j] = -1;\n        }\n        else \n        {\n       \
    \     result[i] = lst[positions[lst.length - j - 1]];\n            positions[lst.length\
    \ - j - 1] = -1;\n        }\n    }\n    return result;\n}\n/*\n    Given array\
    \ of integers, return true if array contains some duplicate values.\n    Otherwise,\
    \ return false.\nunittest\n{\n    alias candidate = strange_sort_list;\n\n   \
    \ assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7nlxr3h9.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nlxr3h9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int n = lst.length;\n    if (n == 0)\n        return typeof(return).array();\n\
    \    else \n    {\n        auto lst2 = lst.dup;\n        lst2.sort;\n        long[]\
    \ res = new long[n];\n        bool flg = true;\n        int i = 0;\n        int\
    \ j = 0;\n        int k = 1;\n        while (j < n) \n        {\n            if\
    \ (flg) \n            {\n                res[j] = lst2[i];\n                i\
    \ += 1;\n            }\n            else \n            {\n                res[j]\
    \ = lst2[n - k];\n                k += 1;\n            }\n            j += 1;\n\
    \            flg = !flg;\n        }\n        return res;\n    }\n}\n/*\n    Given\
    \ list of strings, return tuple\n    of the number of elements that start\n  \
    \  with 'f' and the number of elements that\n    start with 'b'. If no elements\
    \ start with\n    'f' or 'b', return (0, 0).\n    \n    Example:\n    >>> foo_bar([\"\
    foo\", \"bar\", \"foobar\"])\n    (1, 1)\n    >>> foo_bar([\"foo\", \"bar\", \"\
    baz\"])\n    (0, 1)\n    >>> foo_bar([\"foobar\", \"foo\", \"bar\"])\n    (1,\
    \ 1)\n    >>> foo_bar([\"foobar\", \"bar\"])\n    (1, 1)\n    >>> foo_bar([\"\
    foobar\", \"foo\"])\n    (1, 0)\n    >>> foo_bar([\"foo\", \"foobar\"])\n    (1,\
    \ 0)\n    >>> foo_bar([\"bar\", \"baz\"])\n    (0, 2)\n    >>> foo_bar([\"foobar\"\
    ])\n    (1, 0)\n    >>> foo_bar([\"foobar\", \"foobar\"])\n    (2, 0)\n    >>>\
    \ foo_bar([\"foobar\", \"foobar\", \"foobar\"])\n    (3, 0)\n    >>> foo_bar([\"\
    foo\", \"foo\",\nunittest\n{\n    alias candidate = strange_sort_list;\n\n   \
    \ assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp34frkfb9.d(50): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp34frkfb9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tif (lst.length == 0)\n\t\treturn lst;\n\telse\n\t{\n\t\tlong min\
    \ = min(lst);\n\t\tlong max = max(lst);\n\t\tlong[] zipped = zip(\n\t\t\t\t\t\t\
    \tenumerate(lst),\n\t\t\t\t\t\t\t(j) => j[1] != min && j[1] != max ? j[0] : -1L\n\
    \t\t\t\t\t\t\t).retro;\n\t\tlong[] sorted = zip(lst, sort(lst)).retro;\n\t\tlong[]\
    \ res = new long[lst.length];\n\t\tforeach (j; 0 .. lst.length)\n\t\t{\n\t\t\t\
    if (zipped[j] != -1L)\n\t\t\t\tres[j] = sorted[zipped[j]];\n\t\t\telse\n\t\t\t\
    \tres[j] = sorted[j];\n\t\t}\n\t\treturn res;\n\t}\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo3h8pdsf.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpo3h8pdsf.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpo3h8pdsf.d(26): Error: undefined identifier `zip`

    /tmp/tmpo3h8pdsf.d(30): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo3h8pdsf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length < 2)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    long min = min(lst);\n    long max =\
    \ max(lst);\n    long del = min(min, max);\n    for (i = 0; i < lst.length; i++)\n\
    \    {\n        if (i % 2 == 0)\n            res[i] = lst[i / 2];\n        else\n\
    \            res[i] = lst[lst.length - i / 2 - 1];\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8t_ki1d5.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp8t_ki1d5.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp8t_ki1d5.d(26): Error: function expected before `()`, not `min` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8t_ki1d5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tif (lst.length <= 1) return lst;\n\tlong min = min(lst);\n\tlong\
    \ max = max(lst);\n\tint min_index = indexOf(lst, min);\n\tint max_index = indexOf(lst,\
    \ max);\n\tint mid = lst.length / 2;\n\t\n\tauto t = (min, max);\n\t\n\tif (min_index\
    \ == max_index) {\n\t\treturn lst;\n\t}\n\t\n\tif (min_index > max_index) {\n\t\
    \tstd.algorithm.swap(lst[min_index], lst[max_index]);\n\t\tt = (max, min);\n\t\
    }\n\t\n\tif (min_index == mid) return lst;\n\t\n\treturn strange_sort_list(lst);\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxedupat.d(21): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpaxedupat.d(22): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpaxedupat.d(23): Error: undefined identifier `indexOf`

    /tmp/tmpaxedupat.d(24): Error: undefined identifier `indexOf`

    /tmp/tmpaxedupat.d(25): Error: cannot implicitly convert expression `lst.length
    / 2LU` of type `ulong` to `int`

    /tmp/tmpaxedupat.d(27): Error: Using the result of a comma expression is not allowed

    /tmp/tmpaxedupat.d(27): Error: Using the result of a comma expression is not allowed

    /tmp/tmpaxedupat.d(34): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmpaxedupat.d(35): Error: Using the result of a comma expression is not allowed

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxedupat.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto copy = lst.dup;\n    if (copy.length == 0)\n        return\
    \ copy;\n    bool odd = true;\n    long[] lst1;\n    long[] lst2;\n    long[]\
    \ lst3;\n    long[] lst4;\n    long[] lst5;\n    long[] lst6;\n    long[] lst7;\n\
    \    long[] lst8;\n    long[] lst9;\n    long[] lst10;\n    long[] lst11;\n  \
    \  long[] lst12;\n    long[] lst13;\n    long[] lst14;\n    long[] lst15;\n  \
    \  long[] lst16;\n    long[] lst17;\n    long[] lst18;\n    long[] lst19;\n  \
    \  long[] lst20;\n    long[] lst21;\n    long[] lst22;\n    long[] lst23;\n  \
    \  long[] lst24;\n    long[] lst25;\n    long[] lst26;\n    long[] lst27;\n  \
    \  long[] lst28;\n    long[] lst29;\n    long[] lst30;\n    long[] lst31;\n  \
    \  long[] lst32;\n    long[] lst33;\n    long[] lst34;\n    long[] lst35;\n  \
    \  long[] lst36;\n    long[] lst37;\n    long[] lst38;\n    long[] lst39;\n  \
    \  long[] lst40;\n    long[] lst41;\n    long[] lst42;\n    long[] lst43;\n  \
    \  long[] lst44;\n    long[] lst45;\n    long[] lst46;\n    long[] lst47;\n  \
    \  long[] lst48;\n    long[] lst49;\n    long[] lst50;\n    long[] lst51;\n  \
    \  long[] lst52;\n    long[] lst53;\n    long[] lst54;\n    long[] lst55;\n  \
    \  long[] lst56;\n    long[] lst57;\n    long[] lst58;\n    long[] lst59;\n  \
    \  long[] l\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprigaryg9.d(84): Error: semicolon expected, not `unittest`

    /tmp/tmprigaryg9.d(84): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprigaryg9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    if (lst.length\
    \ == 1)\n        return lst;\n    auto m = lst.max();\n    auto l = lst.length;\n\
    \    long[] res = new long[l];\n    bool incr = true;\n    int j = 0;\n    for\
    \ (int i = 0; i < l; i++)\n    {\n        res[i] = lst[j];\n        if (incr ==\
    \ true)\n        {\n            j++;\n            if (j == l)\n            {\n\
    \                incr = false;\n                j = l - 2;\n            }\n  \
    \      }\n        else\n        {\n            j--;\n            if (j == -1)\n\
    \            {\n                incr = true;\n                j = 1;\n       \
    \     }\n        }\n    }\n    return res;\n}\nauto strange_sort_list = memoize!(strange_sort_list);\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbma4njai.d(53): Error: variable `tmpbma4njai.strange_sort_list`
    conflicts with function `tmpbma4njai.strange_sort_list` at /tmp/tmpbma4njai.d(18)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbma4njai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    bool asc = true;\n\
    \    int i = 0;\n    auto pairs = zip(iota(lst.length), lst);\n    sort!((a, b)\
    \ => (asc ? a.item2 > b.item2 : a.item2 < b.item2))(pairs);\n    return pairs.map!(x\
    \ => x.item2).array;\n}\n \nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1w3180mw.d(24): Error: undefined identifier `zip`

    /tmp/tmp1w3180mw.d(25): Error: template instance `sort!((a, b) => asc ? a.item2
    > b.item2 : a.item2 < b.item2)` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1w3180mw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long len = lst.length;\n    if (len == 0) \n    {\n        return\
    \ lst;\n    }\n    auto a = [lst[0L]];\n    long minimum = a[0L];\n    long maximum\
    \ = a[0L];\n    long min_index = 0L;\n    long max_index = 0L;\n    foreach (index,\
    \ item; lst[1L .. $]) \n    {\n        if (item < minimum) \n        {\n     \
    \       minimum = item;\n            min_index = index + 1L;\n        }\n    \
    \    else if (item > maximum) \n        {\n            maximum = item;\n     \
    \       max_index = index + 1L;\n        }\n    }\n    auto min_max = tuple(minimum,\
    \ maximum);\n    if (max_index < min_index) \n    {\n        min_max.swap();\n\
    \    }\n    a ~= min_max;\n    lst = lst[0L .. min_index] ~ lst[min_index + 1L\
    \ .. max_index] ~ lst[max_index + 1L .. $];\n    if (lst.length > 1L) \n    {\n\
    \        a ~= strange_sort_list(lst);\n    }\n    return a;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8tyy09ta.d(46): Error: no property `swap` for type `Tuple!(long,
    long)`

    /tmp/tmp8tyy09ta.d(48): Error: cannot append type `Tuple!(long, long)` to type
    `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8tyy09ta.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return [];\n    bool asc = true;\n    long[]\
    \ result = [lst[0]];\n    auto lst_ = lst[1..$];\n    while (lst_.length > 0)\n\
    \    {\n        if (asc)\n        {\n            lst_ = lst_.sort!((a, b) => a\
    \ < b);\n            result ~= lst_[$-1];\n            lst_ = lst_[0..$-1];\n\
    \        }\n        else\n        {\n            lst_ = lst_.sort!((a, b) => a\
    \ > b);\n            result ~= lst_[$-1];\n            lst_ = lst_[0..$-1];\n\
    \        }\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8xeegmz8.d(28): Error: no property `sort` for type `long[]`

    /tmp/tmp8xeegmz8.d(34): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8xeegmz8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length < 2)\n        return lst;\n    \n    auto tpl =\
    \ tuple(minElement(lst), maxElement(lst));\n    long res[] = new long[lst.length];\n\
    \    res[0] = tpl[0];\n    res[lst.length - 1] = tpl[1];\n    \n    bool asc =\
    \ false;\n    for (int i = 1; i < lst.length - 1; i++) \n    {\n        if (asc)\n\
    \            res[i] = minElement(lst);\n        else\n            res[i] = maxElement(lst);\n\
    \        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iwjbqxp.d(24): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] res`

    /tmp/tmp1iwjbqxp.d(23): Error: undefined identifier `minElement`

    /tmp/tmp1iwjbqxp.d(23): Error: undefined identifier `maxElement`

    /tmp/tmp1iwjbqxp.d(32): Error: undefined identifier `minElement`

    /tmp/tmp1iwjbqxp.d(34): Error: undefined identifier `maxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iwjbqxp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ int start = 0;\n    int end = lst.length - 1;\n    bool is_max = false;\n  \
    \  long[] res = new long[lst.length];\n    long[] new_lst = new long[lst.length];\n\
    \    foreach (item; lst) \n    {\n        new_lst[start] = item;\n        start++;\n\
    \    }\n    quickSort(new_lst);\n    start = 0;\n    end = lst.length - 1;\n \
    \   while (start <= end) \n    {\n        if (is_max) \n        {\n          \
    \  res[start] = new_lst[end];\n            end--;\n        } \n        else \n\
    \        {\n            res[start] = new_lst[start];\n            start++;\n \
    \       }\n        is_max = !is_max;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8uc_c49l.d(25): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8uc_c49l.d(34): Error: undefined identifier `quickSort`

    /tmp/tmp8uc_c49l.d(36): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8uc_c49l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return [];\n    }\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9duf202h.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9duf202h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    //long[] lst2 = deepCopy(lst);\n    long[] lst2 = deepCopy(lst);\n\
    \    long[] lst3 = new long[0];\n    if (lst2.length != 0)\n    {\n        long\
    \ min = min(lst2);\n        while (lst2.length != 0)\n        {\n            lst3\
    \ ~= min;\n            lst2 = lst2.filter!(a => a != min);\n            if (lst2.length\
    \ != 0)\n            {\n                long max = max(lst2);\n              \
    \  lst3 ~= max;\n                lst2 = lst2.filter!(a => a != max);\n       \
    \     }\n        }\n    }\n    return lst3;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkck22ip5.d(21): Error: undefined identifier `deepCopy`

    /tmp/tmpkck22ip5.d(25): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpkck22ip5.d(29): Error: no property `filter` for type `long[]`

    /tmp/tmpkck22ip5.d(32): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpkck22ip5.d(34): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkck22ip5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ //all items are equal\n    if (lst.length > 1 && min(lst) == max(lst)) \n  \
    \  {\n        return lst;\n    }\n    long[] ret_list = [];\n    auto sort_list\
    \ = sort(lst);\n    //main magic here\n    foreach (elem; sort_list) \n    {\n\
    \        if (sort_list.length > 1) \n        {\n            ret_list ~= elem;\n\
    \            sort_list = sort_list[1 .. $ - 1];\n            sort_list = sort_list[$\
    \ - 1 .. 0];\n        }\n        else \n        {\n            ret_list ~= elem;\n\
    \        }\n    }\n    return ret_list;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpipetexj7.d(25): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpipetexj7.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpipetexj7.d(30): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpipetexj7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ long min = minElement(lst);\n    long max = maxElement(lst);\n    long[] res\
    \ = new long[lst.length];\n    int c = 0;\n    int i = 0;\n    while (c < lst.length)\
    \ \n    {\n        if (i % 2 == 0) \n        {\n            res[c] = min;\n  \
    \          ++c;\n            if (c == lst.length)\n            {\n           \
    \     break;\n            }\n            min = minElement(filter!(a => a != min)(lst));\n\
    \        } \n        else \n        {\n            res[c] = max;\n           \
    \ ++c;\n            if (c == lst.length)\n            {\n                break;\n\
    \            }\n            max = maxElement(filter!(a => a != max)(lst));\n \
    \       }\n        ++i;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnuux7_x6.d(24): Error: undefined identifier `minElement`

    /tmp/tmpnuux7_x6.d(25): Error: undefined identifier `maxElement`

    /tmp/tmpnuux7_x6.d(39): Error: undefined identifier `minElement`

    /tmp/tmpnuux7_x6.d(49): Error: undefined identifier `maxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnuux7_x6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto r = lst.sort().zip(enum(lst.sort().reversed()));\n    auto\
    \ flatten = staticMap!((x) => x[0], r);\n    flatten ~= staticMap!((x) => x[1],\
    \ r);\n    return flatten[0 .. lst.length];\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi50gc_v1.d(20): Error: expression expected, not `enum`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi50gc_v1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n  immutable min_value = min(lst);\n  immutable max_value = max(lst);\n\
    \  long[] result;\n  foreach(immutable n; lst)\n  {\n      if(n != min_value &&\
    \ n != max_value)\n      {\n        result ~= n;\n      }\n  }\n  immutable forward\
    \ = true;\n  while(result.length != 0)\n  {\n    if(forward)\n    {\n      foreach(immutable\
    \ n; lst)\n      {\n        if(n == min_value)\n        {\n          result =\
    \ [n] ~ result;\n        }\n        else if(n == max_value)\n        {\n     \
    \     result ~= [n];\n        }\n      }\n      forward = false;\n    }\n    else\n\
    \    {\n      foreach(immutable n; lst)\n      {\n        if(n == max_value)\n\
    \        {\n          result = [n] ~ result;\n        }\n        else if(n ==\
    \ min_value)\n        {\n          result ~= [n];\n        }\n      }\n      forward\
    \ = true;\n    }\n  }\n  return result;\n}\n \nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppl2nrne5.d(20): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmppl2nrne5.d(21): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmppl2nrne5.d(46): Error: cannot modify `immutable` expression `forward`

    /tmp/tmppl2nrne5.d(61): Error: cannot modify `immutable` expression `forward`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppl2nrne5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp07o7mqli.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp07o7mqli.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] r = [], r2 = [], r3 = [];\n    foreach(long m; lst) \n\
    \    {\n        r ~= m;\n    }\n    int len = r.length;\n    for(int i = 0; i\
    \ < len; i++) \n    {\n        if (i % 2 == 0) \n        {\n            r2 ~=\
    \ r[0];\n            r = r[1..$];\n        }\n        else \n        {\n     \
    \       r2 ~= r[$-1];\n            r = r[0..$-1];\n        }\n    }\n    foreach(m;\
    \ r2) \n    {\n        r3 ~= m;\n    }\n    return r3;\n}\n/*\n    This function\
    \ checks if the given string is a palindrome.\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbdlbitcg.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbdlbitcg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    bool asc = true;\n    long[] result = new long[lst.length];\n\
    \    foreach(i, ref x; lst)\n    {\n        result[i] = x;\n    }\n    for(size_t\
    \ i = 0; i < lst.length; i++)\n    {\n        if(i % 2 == 0)\n        {\n    \
    \        std.algorithm.sort(result[i]);\n        }\n        else\n        {\n\
    \            std.algorithm.sort(result[i], asc);\n        }\n    }\n    return\
    \ result;\n}\n/*\n    From a given array of integers return array with non-duplicated\
    \ integers.\n    Example:\n    >>> remove_duplicates([1L, 2L, 3L, 4L, 4L, 5L,\
    \ 5L, 5L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> remove_duplicates([])\n    []\n\
    */\nlong[] remove_duplicates(long[] lst) \n{\n    long[] result = new long[lst.length];\n\
    \    foreach(i, ref x; lst)\n    {\n        result[i] = x;\n    }\n    std.algorithm.uniq(result);\n\
    \    return result;\n}\n/*\n    Given array of integers, generate a new array\
    \ containing the product\n    of all the integers in the array except itself.\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3o1l9h3.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3o1l9h3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[$];\n    bool[] used = new bool[$];\n\
    \    long min, max;\n    foreach (i; 0 .. lst.length)\n    {\n        min = max\
    \ = lst[0];\n        foreach (j; 1 .. lst.length)\n        {\n            if (used[j])\n\
    \                continue;\n            min = min(min, lst[j]);\n            max\
    \ = max(max, lst[j]);\n        }\n        if (i % 2 == 0)\n        {\n       \
    \     result[i] = min;\n            used[index(lst, min)] = true;\n        }\n\
    \        else\n        {\n            result[i] = max;\n            used[index(lst,\
    \ max)] = true;\n        }\n    }\n    return result;\n}\n/*\n    Tests\n*/\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdyob2bl.d(20): Error: undefined identifier `__dollar`

    /tmp/tmpzdyob2bl.d(21): Error: undefined identifier `__dollar`

    /tmp/tmpzdyob2bl.d(30): Error: function expected before `()`, not `min` of type
    `long`

    /tmp/tmpzdyob2bl.d(31): Error: function expected before `()`, not `max` of type
    `long`

    /tmp/tmpzdyob2bl.d(36): Error: undefined identifier `index`

    /tmp/tmpzdyob2bl.d(41): Error: undefined identifier `index`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdyob2bl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    struct KeyValue {\n        long key;\n        long value;\n  \
    \      this(long key, long value) {\n            this.key = key;\n           \
    \ this.value = value;\n        }\n    }\n    auto cmp = (ref const KeyValue a,\
    \ ref const KeyValue b) {\n        return a.key < b.key;\n    };\n    auto pairs\
    \ = zip(lst, iota(lst.length));\n    sort(pairs, cmp);\n    long[] ret;\n    foreach\
    \ (i, pair; pairs) {\n        ret ~= pair[1];\n    }\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiagvxj03.d(31): Error: undefined identifier `zip`

    /tmp/tmpiagvxj03.d(32): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiagvxj03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return [];\n    }\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9duf202h.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9duf202h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // \n    // \n    //\n    // \n    // \n    // \n    // \n   \
    \ // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n\
    \    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    //\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvdt0pav7.d(148): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvdt0pav7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto result = lst[];\n    lst.sort;\n    auto max_value = lst[$-1];\n\
    \    auto min_value = lst[0];\n    bool is_min = true;\n    foreach(i;0..lst.length)\n\
    \    {\n        if(is_min)\n        {\n            result ~= min_value;\n    \
    \        is_min = false;\n        }\n        else\n        {\n            result\
    \ ~= max_value;\n            is_min = true;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyoce5uj7.d(21): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyoce5uj7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto len = lst.length;\n    if (len == 0) return [];\n    else\
    \ if (len == 1) return lst;\n    else if (len == 2) \n    {\n        if (lst[0]\
    \ > lst[1]) return [lst[1], lst[0]];\n        else return lst;\n    }\n    else\
    \ \n    {\n        enum MIN = 0;\n        enum MAX = 1;\n        long min = minElement(lst);\n\
    \        long max = maxElement(lst);\n        enum OP = MIN;\n        long[] res\
    \ = [min];\n        foreach (num; lst)\n        {\n            if (num == min\
    \ || num == max) continue;\n            if (OP == MIN) \n            {\n     \
    \           res ~= num;\n                OP = MAX;\n            }\n          \
    \  else if (OP == MAX) \n            {\n                res = [num] ~ res;\n \
    \               OP = MIN;\n            }\n        }\n        if (max > min) res\
    \ ~= max;\n        else res = [max] ~ res;\n        return res;\n    }\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_oifeeo0.d(32): Error: undefined identifier `minElement`

    /tmp/tmp_oifeeo0.d(33): Error: undefined identifier `maxElement`

    /tmp/tmp_oifeeo0.d(42): Error: cannot modify constant `OP`

    /tmp/tmp_oifeeo0.d(47): Error: cannot modify constant `OP`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_oifeeo0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // TODO: sort lst as required, return it\n    return lst;\n}\n\
    \ \nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm3ohr_fs.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x4287d5]

    ??:? void tmpm3ohr_fs.__unittest_L24_C1() [0x427f02]

    ??:? void tmpm3ohr_fs.__modtest() [0x428558]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b676]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430809]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430795]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b64d]

    ??:? runModuleUnitTests [0x42c5b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c24]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] new_lst;\n    long[] temp_lst;\n    // sort the list and\
    \ return\n    auto sorted_lst = std.algorithm.sort(lst);\n    // if list is even\
    \ return the list\n    if (sorted_lst.length % 2 == 0) \n    {\n        // return\
    \ the list\n        return sorted_lst;\n    } \n    else \n    {\n        new_lst\
    \ = new long[sorted_lst.length];\n        // set of the beginning to the mid point\
    \ of the list\n        new_lst[0] = sorted_lst[0];\n        long max_index = sorted_lst.length\
    \ / 2;\n        long min_index = max_index;\n        // if the number of items\
    \ in the list is odd swap the min and max\n        if (sorted_lst.length % 2 !=\
    \ 0) \n        {\n            max_index = max_index + 1;\n        }\n        //\
    \ assign the min and max values to the new list\n        for (int i = 1; i < sorted_lst.length\
    \ - 1; i = i + 2) \n        {\n            new_lst[i] = sorted_lst[max_index];\n\
    \            new_lst[i + 1] = sorted_lst[min_index];\n            // decrement\
    \ the max and min index\n            max_index = max_index - 1;\n            min_index\
    \ = min_index - 1;\n        }\n        // assign the last element in the list\n\
    \        new_lst[sorted_lst.length - 1] = sorted_lst[sorted_lst.length - 1];\n\
    \        // return the new list\n        return new_lst;\n    }\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqz7j6cz2.d(23): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqz7j6cz2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tlong[] sorted;\n\tint direction = 1;\n\timmutable(long)[] sorted;\n\
    \twhile(lst.length) \n\t{\n\t\tif(direction == 1)\n\t\t{\n\t\t\tsorted ~= lst[0];\n\
    \t\t\tlst = lst[1..$];\n\t\t}\n\t\telse \n\t\t{\n\t\t\tsorted ~= lst[$-1];\n\t\
    \t\tlst = lst[0..$-1];\n\t\t}\n\t\tdirection *= -1;\n\t}\n\treturn sorted;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk4vrafna.d(22): Error: declaration `tmpk4vrafna.strange_sort_list.sorted`
    is already defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk4vrafna.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return [];\n    }\n    //TypeTuple!(int,\
    \ int) t = tuple(lst[0], lst[0]);\n    int[] index = new int[2];\n    index[0]\
    \ = 0;\n    index[1] = 0;\n    for (int i = 0; i < lst.length; i++) \n    {\n\
    \        if (lst[i] < lst[index[0]]) \n        {\n            index[0] = i;\n\
    \        }\n        if (lst[i] > lst[index[1]]) \n        {\n            index[1]\
    \ = i;\n        }\n    }\n    long[] new_lst = new long[lst.length];\n    for\
    \ (int i = 0; i < lst.length; i += 2) \n    {\n        new_lst[i] = lst[index[0]];\n\
    \        new_lst[i + 1] = lst[index[1]];\n    }\n    return new_lst;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt5l06pzn.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x428d7d]

    ??:? void tmpt5l06pzn.__unittest_L47_C1() [0x4284a6]

    ??:? void tmpt5l06pzn.__modtest() [0x428afc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d03f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bed2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43115d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43160c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4310e9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bea9]

    ??:? runModuleUnitTests [0x42ce15]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429240]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length < 1) \n    {\n        return lst;\n    }\n    auto\
    \ tuples = lst.map!(a => tuple(a, abs(a)));\n    tuples.sort!(a => (a[1]));\n\
    \    auto temp = tuples.map!(a => a[0]);\n    int front = 0;\n    int back = temp.length\
    \ - 1;\n    long[] answer = new long[temp.length];\n    for (int i = 0; i < temp.length;\
    \ i++) \n    {\n        if (i % 2 == 0) \n        {\n            answer[i] = temp[front];\n\
    \            front++;\n        } \n        else \n        {\n            answer[i]\
    \ = temp[back];\n            back--;\n        }\n    }\n    return answer;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu6kpufa2.d(24): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu6kpufa2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    \n    const long sort_up = 1L;\n    const long sort_down = 2L;\n\
    \    auto result = new long[](lst.length);\n    const long start_at = min(lst);\n\
    \    bool has_start_at = false;\n    long counter = 0L;\n    long num_iterations\
    \ = (lst.length % 2 == 0 ? lst.length : lst.length - 1);\n    long sort_direction\
    \ = sort_up;\n    long sort_num = start_at;\n    static if (is(typeof(lst) ==\
    \ DynamicArray!long))\n    {\n        auto lst_rnd = lst.dup;\n        foreach\
    \ (i; 0 .. num_iterations)\n        {\n            if (!has_start_at)\n      \
    \      {\n                lst_rnd[start_at] = -1L;\n                has_start_at\
    \ = true;\n            }\n            result[counter] = sort_num;\n          \
    \  counter += 1L;\n            if (sort_direction == sort_up)\n            {\n\
    \                sort_num = max(lst_rnd);\n                sort_direction = sort_down;\n\
    \            }\n            else if (sort_direction == sort_down)\n          \
    \  {\n                sort_num = min(lst_rnd);\n                sort_direction\
    \ = sort_up;\n            }\n            lst_rnd[sort_num] = -1L;\n        }\n\
    \    }\n    else\n    {\n        foreach (i; 0 .. num_iterations)\n        {\n\
    \            if (!has_start_at)\n            {\n                lst[start_at]\
    \ = -1L;\n                has_start_at = true;\n            }\n            result[counter]\
    \ = sort_num;\n            counter += 1L;\n            if (sort_direction == sort_up)\n\
    \            {\n                sort_num = max(lst);\n                sort_direction\
    \ = sort_down;\n            }\n            else if (sort_direction == sort_down)\n\
    \            {\n                sort_num = min(lst);\n                sort_direction\
    \ = sort_up;\n            }\n            lst[\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8rwvgnot.d(77): Error: expression expected, not `unittest`

    /tmp/tmp8rwvgnot.d(78): Error: found `{` when expecting `,`

    /tmp/tmp8rwvgnot.d(79): Error: expression expected, not `alias`

    /tmp/tmp8rwvgnot.d(79): Error: found `candidate` when expecting `,`

    /tmp/tmp8rwvgnot.d(79): Error: expression expected, not `=`

    /tmp/tmp8rwvgnot.d(79): Error: found `strange_sort_list` when expecting `,`

    /tmp/tmp8rwvgnot.d(79): Error: expression expected, not `;`

    /tmp/tmp8rwvgnot.d(81): Error: found `assert` when expecting `,`

    /tmp/tmp8rwvgnot.d(81): Error: found `;` when expecting `,`

    /tmp/tmp8rwvgnot.d(82): Error: found `;` when expecting `,`

    /tmp/tmp8rwvgnot.d(83): Error: found `;` when expecting `,`

    /tmp/tmp8rwvgnot.d(84): Error: found `;` when expecting `,`

    /tmp/tmp8rwvgnot.d(85): Error: found `;` when expecting `,`

    /tmp/tmp8rwvgnot.d(86): Error: found `;` when expecting `,`

    /tmp/tmp8rwvgnot.d(87): Error: found `;` when expecting `,`

    /tmp/tmp8rwvgnot.d(88): Error: found `;` when expecting `,`

    /tmp/tmp8rwvgnot.d(89): '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n\tauto sorted = lst.sort();\n\tint i=0;\n\tint j=sorted.length-1;\n\
    \tauto result = new long[lst.length];\n\twhile(i<j)\n\t{\n\t\tresult[i]=sorted[i];\n\
    \t\tresult[j]=sorted[j];\n\t\ti++;\n\t\tj--;\n\t}\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr_6vd6j8.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr_6vd6j8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    Tuple!(long[],\
    \ long[]) tuple = lst.chunks(lst.length/2);\n    long[] left = tuple[0];\n   \
    \ long[] right = tuple[1];\n    long[] joined = new long[lst.length];\n    bool\
    \ is_even = false;\n    long left_index = 0;\n    long right_index = 0;\n    for\
    \ (long i = 0; i < lst.length; i++)\n    {\n        if (is_even)\n        {\n\
    \            joined[i] = left[left_index];\n            left_index++;\n      \
    \  }\n        else\n        {\n            joined[i] = right[right_index];\n \
    \           right_index++;\n        }\n        is_even = !is_even;\n    }\n  \
    \  return joined;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp68stxu1d.d(22): Error: no property `chunks` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp68stxu1d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n    long min, max;\n    int i;\n    long[] lst1;\n    bool add =\
    \ true;\n    lst1 = new long[0];\n    if(lst.length == 0)\n        return lst1;\n\
    \    while(lst.length > 0)\n    {\n        min = lst[0];\n        max = lst[0];\n\
    \        for(i = 0; i < lst.length; i++)\n        {\n            if(lst[i] > max)\n\
    \                max = lst[i];\n            if(lst[i] < min)\n               \
    \ min = lst[i];\n        }\n        lst1 ~= add ? min : max;\n        lst = lst.filter!(x\
    \ => x != min && x != max);\n        add = !add;\n    }\n    return lst1;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9xqxmaln.d(39): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9xqxmaln.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length < 2) \n    {\n        return lst;\n    }\n    alias\
    \ Longs = long[];\n    auto min = minElement(lst);\n    auto idx = std.algorithm.find(lst,\
    \ min);\n    return to!Longs(\n        chain(\n            [min],\n          \
    \  strange_sort_list(lst[0..idx] + lst[idx + 1..$])\n        )\n    );\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp0posa2z.d(25): Error: undefined identifier `minElement`

    /tmp/tmpp0posa2z.d(26): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmpp0posa2z.d(27): Error: template instance `to!Longs` template `to` is not
    defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp0posa2z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length==0) return lst;\n    long[] odd=lst.filter!(x=>x%2!=0).sort!(a,b=>a>b);\n\
    \    long[] even=lst.filter!(x=>x%2==0).sort!(a,b=>a<b);\n    long[] res= new\
    \ long[lst.length];\n    int index=0;\n    for (int i=0;i<=res.length/2;i++)\n\
    \    {\n        res[index]=even[i];\n        index++;\n        if (odd.length>(res.length/2))\n\
    \        {\n            res[index]=odd[i];\n            index++;\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpatqtqv6g.d(21): Error: no property `filter` for type `long[]`

    /tmp/tmpatqtqv6g.d(22): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatqtqv6g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    immutable len = lst.length;\n    if (len == 0) \n    {\n     \
    \   return lst;\n    }\n    else if (len == 1) \n    {\n        return lst;\n\
    \    }\n    else \n    {\n        auto tmp = sort(lst);\n        auto index =\
    \ sequence(0, 2 * len, 2);\n        index = repeat(index) ~ repeat(reverse(index));\n\
    \        index = index[0..len];\n        auto result = new long[len];\n      \
    \  foreach (i, j; index) \n        {\n            result[i] = tmp[j];\n      \
    \  }\n        return result;\n    }\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpswq1xwp7.d(31): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpswq1xwp7.d(32): Error: undefined identifier `sequence`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpswq1xwp7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    if (lst.length == 0)\
    \ \n    {\n        return result;\n    }\n    if (lst.length == 1) \n    {\n \
    \       result[0] = lst[0];\n        return result;\n    }\n    bool asc = true;\n\
    \    int index = 0;\n    while (true) \n    {\n        long[] sorted = copy(lst);\n\
    \        sorted.sort(asc ? (a, b) => a - b : (a, b) => b - a);\n        result[index]\
    \ = sorted[0];\n        lst = sorted[1 .. $];\n        if (lst.length == 0) \n\
    \        {\n            break;\n        }\n        index += 1;\n        asc =\
    \ !asc;\n    }\n    return result;\n}\n/*\n    \n    See tests for examples.\n\
    \    You can run tests with command:\n    $ dmd -run tests.d\nunittest\n{\n  \
    \  alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L])\
    \ == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L,\
    \ 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L,\
    \ 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9xrmqy48.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9xrmqy48.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // create tuple of (value, index) pairs\n    long[][] idx_pair\
    \ = zip(lst, iota(lst.length)).array;\n    // sort by value\n    idx_pair.sort!(\"\
    a[0] < b[0]\");\n    // extract just the indices\n    long[] idx = idx_pair.map!(\"\
    a[1]\").array;\n    // we need to invert odd indices\n    idx = invert(idx[1..$-1].byChunk(2));\n\
    \    // append last index\n    idx ~= idx_pair[$-1][1];\n    // get the sorted\
    \ array\n    lst[idx]\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwf8c966p.d(32): Error: found `}` when expecting `;` following statement

    /tmp/tmpwf8c966p.d(33): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwf8c966p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    Tuple!(long[],\
    \ long[]) both = tuple(lst.dup, lst.dup);\n    both[1].sort;\n    auto p = both[1].partition;\n\
    \    alias min = p[0];\n    alias max = p[1].reverse;\n    auto result = new long[][max.length\
    \ + min.length];\n    foreach (i, ref elem; result)\n    {\n        if (i % 2\
    \ == 0)\n            elem = min[i ~/ 2];\n        else\n            elem = max[i\
    \ ~/ 2];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj28qnh1i.d(31): Error: expression expected, not `/`

    /tmp/tmpj28qnh1i.d(31): Error: found `2` when expecting `,`

    /tmp/tmpj28qnh1i.d(33): Error: expression expected, not `/`

    /tmp/tmpj28qnh1i.d(33): Error: found `2` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj28qnh1i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    /*\n    long[] sorted =\
    \ new long[lst.length];\n    while(sorted.length)\n    {\n        long min = min(lst);\n\
    \        long max = max(lst);\n        if (sorted.length%2)\n        {\n     \
    \       sorted ~= min;\n            lst = lst.filter!(e=>e!=min);\n        }\n\
    \        else\n        {\n            sorted ~= max;\n            lst = lst.filter!(e=>e!=max);\n\
    \        }\n    }\n    return sorted;\n    */\n    return lst;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9upsbbxj.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x4287e5]

    ??:? void tmp9upsbbxj.__unittest_L42_C1() [0x427f12]

    ??:? void tmp9upsbbxj.__modtest() [0x428568]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7f3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b686]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430819]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4307a5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b65d]

    ??:? runModuleUnitTests [0x42c5c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c34]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto lstNew = lst.dup;\n    lstNew.sort;\n    lstNew.reverse;\n\
    \    return lstNew;\n}\n//by dalke\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4l9d6gcr.d(21): Error: no property `sort` for type `long[]`

    /tmp/tmp4l9d6gcr.d(22): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4l9d6gcr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length < 2) \n    {\n        return lst;\n    }\n    lst.sort;\n\
    \    auto lst_len = lst.length;\n    auto int_range = iota(0, lst_len, 2);\n \
    \   auto even_range = iota(1, lst_len - 1, 2);\n    auto res = new long[lst_len];\n\
    \    foreach (i, lst_elem; zip(int_range, lst)) \n    {\n        res[i] = lst_elem;\n\
    \    }\n    foreach (i, lst_elem; zip(even_range, lst)) \n    {\n        res[i]\
    \ = lst_elem;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2dg51xg1.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmp2dg51xg1.d(26): Error: undefined identifier `iota`

    /tmp/tmp2dg51xg1.d(27): Error: undefined identifier `iota`

    /tmp/tmp2dg51xg1.d(29): Error: undefined identifier `zip`

    /tmp/tmp2dg51xg1.d(33): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2dg51xg1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{ \n  if (lst.length == 0) return new long[0];\n  if (lst.length == 1)\
    \ return lst;\n  if (lst.length == 2)\n  {\n      if (lst[0] < lst[1]) return\
    \ lst;\n      return [lst[1], lst[0]];\n  }\n  long[] arr = new long[lst.length];\n\
    \  int idx = 0;\n  if (lst[0] < lst[1]) \n  {\n      arr[idx++] = lst[0];\n  \
    \    arr[idx++] = lst[1];\n  }\n  else\n  {\n      arr[idx++] = lst[1];\n    \
    \  arr[idx++] = lst[0];\n  }\n  long[] _lst = lst[2..$];\n  while(_lst.length\
    \ > 0)\n  {\n      long vmax = max(_lst);\n      long vmin = min(_lst);\n    \
    \  _lst = _lst.filter!( (x) => x != vmax && x != vmin );\n      arr[idx++] = vmax;\n\
    \      arr[idx++] = vmin;\n  }\n  return arr;\n}\n \nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph8o5aw3t.d(42): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmph8o5aw3t.d(43): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmph8o5aw3t.d(44): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph8o5aw3t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int len = lst.length;\n    if (len == 0) return lst;\n    int\
    \ k = len / 2;\n    long[] odd = new long[k], even = new long[len - k];\n    auto\
    \ cmp = (a, b) => b < a;\n    auto sorter = (a, b) => {\n        return a.sort!(cmp);\n\
    \    };\n    auto zipped = zip(lst.sort!(cmp).take(k), lst.sort().skip(k));\n\
    \    foreach(it; zipped) \n    {\n        odd ~= it[0];\n        even ~= it[1];\n\
    \    }\n    return (odd.sort!(cmp) ~ even.sort()).array;\n}\nunittest\n{\n   \
    \ alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L])\
    \ == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L,\
    \ 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L,\
    \ 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5da0l7zw.d(20): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmp5da0l7zw.d(24): Error: variable `tmp5da0l7zw.strange_sort_list.cmp` type
    `void` is inferred from initializer `(a, b) => b < a`, and variables cannot be
    of type `void`

    /tmp/tmp5da0l7zw.d(24): Error: template lambda has no value

    /tmp/tmp5da0l7zw.d(25): Error: variable `tmp5da0l7zw.strange_sort_list.sorter`
    type `void` is inferred from initializer `(a, b) => ()

    {

    return a.sort!cmp;

    }

    `, and variables cannot be of type `void`

    /tmp/tmp5da0l7zw.d(25): Error: template lambda has no value

    /tmp/tmp5da0l7zw.d(28): Error: undefined identifier `zip`

    /tmp/tmp5da0l7zw.d(34): Error: no property `sort` for type `long[]`

    /tmp/tmp5da0l7zw.d(34): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5da0l7zw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164254
