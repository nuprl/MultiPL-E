name: HumanEval_100_make_a_pile
language: d
prompt: "import std.math;\n/*\n\n    Given a positive integer n, you have to make\
  \ a pile of n levels of stones.\n    The first level has n stones.\n    The number\
  \ of stones in the next level is:\n        - the next odd number if n is odd.\n\
  \        - the next even number if n is even.\n    Return the number of stones in\
  \ each level in an array, where element at index\n    i represents the number of\
  \ stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3L)\n    [3L,\
  \ 5L, 7L]\n    \n*/\nlong[] make_a_pile(long n) \n"
tests: "unittest\n{\n    alias candidate = make_a_pile;\n\n    assert(candidate(3L)\
  \ == [3L, 5L, 7L]);\n    assert(candidate(4L) == [4L, 6L, 8L, 10L]);\n    assert(candidate(5L)\
  \ == [5L, 7L, 9L, 11L, 13L]);\n    assert(candidate(6L) == [6L, 8L, 10L, 12L, 14L,\
  \ 16L]);\n    assert(candidate(8L) == [8L, 10L, 12L, 14L, 16L, 18L, 20L, 22L]);\n\
  }\nvoid main(){}"
completions: ["{\n    long[] res = new long[n];\n    res[0] = n;\n    for (long i\
    \ = 1; i < n; i++)\n    {\n        if (res[i-1] % 2 == 0)\n            res[i]\
    \ = res[i-1] + 2;\n        else\n            res[i] = res[i-1] + 1;\n    }\n \
    \   return res;\n}", "{\n    long[] ans = new long[n];\n    long count = n;\n\
    \    for (long i = 0; i < n; i++)\n    {\n        ans[i] = count;\n        if\
    \ (count % 2 == 0)\n            count++;\n        else\n            count += 2;\n\
    \    }\n    return ans;\n}", "{\n    return iota(n).map!(i => n + i + i + 1L)().array();\n\
    }", "{\n    long[] arr;\n    arr ~= n;\n    long level = n;\n    while(n--) {\n\
    \        if(level % 2 == 0) {\n            arr ~= arr[$-1] + 2;\n        } else\
    \ {\n            arr ~= arr[$-1] + 1;\n        }\n        level--;\n    }\n  \
    \  return arr;\n}\n/*\n    This function is intended to help to solve the following\
    \ problem:\n    Given a positive integer n, you have to make a pile of n levels\
    \ of stones.\n    The first level has n stones.\n    The number of stones in the\
    \ next level is:\n        - the next odd number if n is odd.\n        - the next\
    \ even number if n is even.\n    Return the number of stones in each level in\
    \ an array, where element at index\n    i represents the number of stones in the\
    \ level (i+1).", "{\n    long[] res = new long[n];\n    res[0] = n;\n    for (int\
    \ i = 1; i < n; i++)\n    {\n        res[i] = res[i-1] + (res[i-1] % 2 == 0 ?\
    \ 2 : 1);\n    }\n    return res;\n}", "{\n    immutable m = n;\n    long[] result\
    \ = new long[m];\n    result[0] = n;\n    for (int i = 1; i < m; i++)\n    {\n\
    \        if (modulo(n, 2) == 0)\n        {\n            result[i] = result[i-1]\
    \ + 2;\n        }\n        else\n        {\n            result[i] = result[i-1]\
    \ + 1;\n        }\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[n];\n    result[0] = n;\n    for (long i = 1; i < n; i++) {\n        if\
    \ (n % 2 == 0) {\n            result[i] = n + 2;\n        } else {\n         \
    \   result[i] = n + 1;\n        }\n        n = result[i];\n    }\n    return result;\n\
    }", "{\n    /*\n        The result array is initialized to be n elements long.\n\
    \        The first element is n.\n        There are n elements, so n levels.\n\
    \    */\n    long[] result = new long[n];\n    /*\n        The result array is\
    \ populated in a loop.\n        The loop counter \"i\" starts from zero.\n   \
    \     The number of iterations is n.\n        The type of \"i\" is long.\n   \
    \ */\n    for (long i = 0L; i < n; i = i + 1L)\n    {\n        /*\n          \
    \  If the value of i is odd, then the previous value\n            of i is even.\n\
    \            1L is added to the previous value of i\n            and stored in\
    \ the result array at the index i.\n        */\n        if (i % 2L == 1L)\n  \
    \      {\n            result[i] = i + 1L;\n        }\n        /*\n           \
    \ If the value of i is even, then the previous value\n            of i is odd.\n\
    \            2L is added to the previous value of i\n            and stored in\
    \ the result array at the index i.\n        */\n        else\n        {\n    \
    \        result[i] = i + 2L;\n        }\n    }\n    /*\n        The array is returned.\n\
    \    */\n    return result;\n}", "{\n    auto size = (int)log2(n) + 1;\n    auto\
    \ result = new long[size];\n    result[0] = n;\n    auto current = n;\n    foreach\
    \ (i; 1 .. size)\n    {\n        current = ((current % 2) ? (current + 2) : (current\
    \ + 1));\n        result[i] = current;\n    }\n    return result;\n}", "{\n  \
    \  int size = int(n);\n    long[] result = new long[n];\n    result[0] = n;\n\
    \    for (int i = 1; i < size; i++) {\n        if (n % 2 == 0) {\n           \
    \ result[i] = n + 2;\n        } else {\n            result[i] = n + 1;\n     \
    \   }\n        n = result[i];\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[n];\n    result[0] = n;\n    long level = 1;\n    while (level <\
    \ n)\n    {\n        result[level] = result[level-1] + (level % 2 == 0 ? 2 : 1);\n\
    \        level++;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[n];\n    result[0] = n;\n    long i = 1;\n    while (i < n)\n    {\n  \
    \      if (result[i-1]%2 == 0)\n            result[i] = result[i-1] + 2;\n   \
    \     else\n            result[i] = result[i-1] + 1;\n        i++;\n    }\n  \
    \  return result;\n}", "{\n    long[] pile = new long[n];\n    pile[0] = n;\n\
    \    for (size_t i = 1; i < n; i++)\n    {\n        pile[i] = pile[i-1] + 2*(i%2==0?1:-1);\n\
    \    }\n    return pile;\n}", "{\n    auto result = new long[](n);\n    for (int\
    \ i = 0; i < n; i++)\n    {\n        result[i] = n;\n        if (n % 2 == 0)\n\
    \            n += 1;\n        else\n            n += 2;\n    }\n    return result;\n\
    }", "{\n    long a = n;\n    long b = a % 2 == 0 ? a + 2 : a + 1;\n    long c\
    \ = b % 2 == 0 ? b + 2 : b + 1;\n    return [a, b, c];\n}\n/*", "{\n    long[]\
    \ result = new long[n];\n    long count = n;\n    foreach(i; 0..n)\n    {\n  \
    \      result[i] = count;\n        if(count % 2 == 0)\n            count++;\n\
    \        else\n            count+=2;\n    }\n    return result;\n}", "{\n    auto\
    \ pile = [n](inout long[] result)\n    {\n        long k = 0;\n        while (n\
    \ > 0)\n        {\n            result ~= n;\n            if (n & 1)\n        \
    \        n = n + 2;\n            else\n                n = n + 1;\n        }\n\
    \    };\n    auto arr = appender!(long[])();\n    pile(arr);\n    return arr.data;\n\
    }", "{\n    long[] result = new long[(int)n];\n    long levelNum = n;\n    result[0]\
    \ = n;\n    for (long i = 1; i < n; i++) {\n        levelNum = (levelNum % 2 ==\
    \ 0) ? levelNum + 1 : levelNum + 2;\n        result[(int)i] = levelNum;\n    }\n\
    \    return result;\n}", "{\n    import std.range;\n    return iota(n).map!(a\
    \ => n += n%2 ? 2 : 1).array;\n}", "{\n  // (2x + 1)**2 + x*(x+1)\n  auto s =\
    \ n * (n + 1) / 2;\n  return [s + n * n, s + n * (n + 1)];\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
