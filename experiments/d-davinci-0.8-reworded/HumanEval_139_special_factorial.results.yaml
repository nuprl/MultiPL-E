language: d
name: HumanEval_139_special_factorial
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long x = 1;\n    long nn = n;\n    while(nn > 0)\n    {\n        x *= std.math.factorial(nn);\n\
    \        nn--;\n    }\n    return x;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu2foahtl.d(22): Error: undefined identifier `factorial` in module
    `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu2foahtl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \ttypeof(factorial!int)()(x) = 0;\n\tif(n<=1)return n*1;\n\treturn n*special_factorial(n-1);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqurg6py9.d(18): Error: template instance `factorial!int` template
    `factorial` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqurg6py9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif (n < 0) {\n\t\treturn -1;\n\t}\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\treturn\
    \ n * special_factorial(n - 1);\n}\n/*\n    Count the number of times that the\
    \ element elem appears in the given list.\n    >>> count_elem(1, [1, 2, 1, 1,\
    \ 1, 2, 3, 1, 1, 4, 1, 5, 6, 1])\n    8\n    >>> count_elem(2, [1, 2, 1, 1, 1,\
    \ 2, 3, 1, 1, 4, 1, 5, 6, 1])\n    2\n    >>> count_elem(9, [1, 2, 1, 1, 1, 2,\
    \ 3, 1, 1, 4, 1, 5, 6, 1])\n    0\n*/\nlong count_elem(long elem, long[] list)\n\
    {\n\tlong n = 0;\n\tforeach (long i; list) {\n\t\tif (i == elem) {\n\t\t\tn++;\n\
    \t\t}\n\t}\n\treturn n;\n}\n/*\n    A \"Fibonacci word\" is a word over the alphabet\
    \ {0, 1} defined as follows:\n    - The empty word is a Fibonacci word.\n    -\
    \ If a word has last letter 0, then the word obtained by removing the last\n \
    \   letter is a Fibonacci word.\n    - If a word has last letter 1, then the word\
    \ obtained by removing the last\n    letter and then the last letter of the obtained\
    \ word is a Fibonacci word.\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpggh_jq0x.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpggh_jq0x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \treturn n <= 0 ? 1 : n * special_factorial(n - 1);\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsxnw_2df.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpsxnw_2df.__unittest_L20_C1() [0x427a5a]

    ??:? void tmpsxnw_2df.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n) * factorial(n - 1) * factorial(n - 2);\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2wfph48f.d(18): Error: undefined identifier `factorial`

    /tmp/tmp2wfph48f.d(18): Error: undefined identifier `factorial`

    /tmp/tmp2wfph48f.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2wfph48f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    int res = n;\n    n--;\n    while(n>0)\n    {\n        res *= n;\n      \
    \  n--;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpltzc_hjh.d(18): Error: cannot implicitly convert expression `n`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpltzc_hjh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.stdio : writeln;\n    return reduce!((a, b) => a * b)(iota(n));\n\
    }\n \nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9jfm5vc4.d(19): Error: template instance `reduce!((a, b) => a *
    b)` template `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9jfm5vc4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long brazilian_factorial = 1L;\n    long factorial = 1L;\n    if (n == 0)\n\
    \        return 1L;\n    else\n    {\n        for (int i = 1; i <= n; i++)\n \
    \       {\n            factorial *= i;\n            brazilian_factorial *= factorial;\n\
    \        }\n        return brazilian_factorial;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = 1;\n    foreach(i; 1..n) {\n        res *= factorial(i);\n   \
    \ }\n    return res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2k70z2cq.d(20): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2k70z2cq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for (int i = 0; i < n; i++)\n    {\n        result\
    \ *= factorial(n - i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpksv02p03.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpksv02p03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return n == 0 ? 1 : n * special_factorial(n - 1);\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqrp1dwp5.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpqrp1dwp5.__unittest_L20_C1() [0x427a62]

    ??:? void tmpqrp1dwp5.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  if (n <= 1) return 1;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpus9yraqb.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpus9yraqb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    int i = 0;\n    long result = 1;\n    while (i < n) {\n        result *=\
    \ i+1;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsgj0r53f.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpsgj0r53f.__unittest_L26_C1() [0x427a66]

    ??:? void tmpsgj0r53f.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \treturn n==0 ? 1 : n * special_factorial(n-1);\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptwl_p_dd.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmptwl_p_dd.__unittest_L20_C1() [0x427a62]

    ??:? void tmptwl_p_dd.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42813b]

    ??:? _d_run_main [0x4280a6]

    ??:? main [0x427afb]

    ??:? __libc_start_main [0xd4265554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong result = 1;\n\tforeach(i; 1 .. n)\n\t{\n\t\tresult *= math.factorial(i);\n\
    \t}\n\treturn result;\n}\n \n/*\nGiven a string and an integer, find the nth index\
    \ of the end where a given substring is located.\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2pdoi1pm.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2pdoi1pm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.math : lgamma;\n    assert(n > 0);\n    auto result = 1.0;\n \
    \   for (long i = 1; i <= n; i++)\n    {\n        result *= lgamma(i+1);\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe0mafqck.d(18): Error: module `std.math` import `lgamma` not found

    /tmp/tmpe0mafqck.d(25): Error: cannot implicitly convert expression `result` of
    type `double` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0mafqck.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static assert(n > 0);\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeggjuuj8.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeggjuuj8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    foreach(i;2..n)\n    {\n        result *= i;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphxy7wzha.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmphxy7wzha.__unittest_L25_C1() [0x427a66]

    ??:? void tmphxy7wzha.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static if (is(typeof(mixin(\"factorial\"))))\n    {\n        return factorial(n)\
    \ * factorial(n - 1) * factorial(n - 2);\n    }\n    else\n    {\n        return\
    \ n.factorial * (n - 1).factorial * (n - 2).factorial;\n    }\n}\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjzm5f9oy.d(24): Error: no property `factorial` for type `long`

    /tmp/tmpjzm5f9oy.d(24): Error: no property `factorial` for type `long`

    /tmp/tmpjzm5f9oy.d(24): Error: no property `factorial` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjzm5f9oy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong ret = 1;\n\tforeach(i; 2..n+1)\n\t{\n\t\tret *= i;\n\t}\n\treturn ret;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaq59wch8.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpaq59wch8.__unittest_L25_C1() [0x427a6a]

    ??:? void tmpaq59wch8.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n <= 0) {\n        throw new Exception(\"Error\");\n    }\n    return\
    \ std.algorithm.reduce!((a, b) => a * b)(n);\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdpo15pq2.d(21): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdpo15pq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    foreach(i;1..n+1) \n    {\n        result *= factorial(i);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmwh1rakr.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmwh1rakr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long brazilian_factorial = 1L;\n    long factorial = 1L;\n    static immutable\
    \ int MAX_FACTORIAL = 20;\n    static immutable factorial_t[] factorials = new\
    \ factorial_t[](MAX_FACTORIAL);\n    static bool is_factorials_init = false;\n\
    \    if (!is_factorials_init) {\n        for (int i = 0; i < MAX_FACTORIAL; i++)\
    \ {\n            factorials[i] = factorial_t(i, factorial);\n            factorial\
    \ *= i + 1;\n        }\n        is_factorials_init = true;\n    }\n    foreach\
    \ (factorial_t fact; factorials) {\n        if (fact.index >= n) break;\n    \
    \    brazilian_factorial *= fact.factorial;\n    }\n    return brazilian_factorial;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwh5dlj9g.d(21): Error: undefined identifier `factorial_t`, did
    you mean variable `factorial`?

    /tmp/tmpwh5dlj9g.d(21): Error: undefined identifier `factorial_t`, did you mean
    variable `factorial`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwh5dlj9g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    long factorial = 1;\n    long nb = 1;\n    long nb2\
    \ = 0;\n    long tmp = 0;\n    long[] tab;\n    int index = 0;\n    int index2\
    \ = 0;\n    int i = 0;\n    int j = 0;\n    if (n == 0)\n        return (1);\n\
    \    if (n == 1)\n        return (1);\n    while (n > 1)\n    {\n        if (n\
    \ > 1)\n        {\n            factorial = factorial * n;\n            n--;\n\
    \        }\n        nb2 = nb2 + 1;\n        nb = nb * nb2;\n        if (n == 1)\n\
    \        {\n            result = result * factorial * nb;\n            return\
    \ (result);\n        }\n        if (n == 2)\n        {\n            result = result\
    \ * factorial * nb;\n            return (result);\n        }\n        if (n ==\
    \ 3)\n        {\n            result = result * factorial * nb;\n            return\
    \ (result);\n        }\n        if (n < 8)\n        {\n            result = result\
    \ * factorial * nb;\n            n = 0;\n        }\n        else\n        {\n\
    \            if (n > 8)\n            {\n                tab = new long[n / 8 +\
    \ 1];\n                tab[index] = factorial * nb;\n                index++;\n\
    \                n = n - 8;\n            }\n        }\n    }\n    if (index !=\
    \ 0)\n    {\n        i = 0;\n        while (i < index)\n        {\n          \
    \  j = 0;\n            while (j < index)\n            {\n                if (i\
    \ != j)\n                {\n                    result = result * tab[i] * tab[j];\n\
    \                }\n                j++;\n            }\n            i++;\n  \
    \      }\n    }\n    return (result);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmz2k9vtz.d(95): unittest failure

    ----------------

    ??:? _d_unittestp [0x42820d]

    ??:? void tmpmz2k9vtz.__unittest_L91_C1() [0x427f0a]

    ??:? void tmpmz2k9vtz.__modtest() [0x427f90]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c20b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b09e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430329]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4307d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4302b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b075]

    ??:? runModuleUnitTests [0x42bfe1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4286d0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n <= 0) \n    {\n        return 1;\n    }\n    return n * special_factorial(n\
    \ - 1);\n}\n/*\nThe following block of code is a sample answer.\nI have run the\
    \ code through the debugger and it matches the\nc++ and python implementations\n\
    */\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0ut3q76e.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp0ut3q76e.__unittest_L29_C1() [0x427a5a]

    ??:? void tmp0ut3q76e.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    foreach(i; 1..n)\n    {\n        foreach(k; i..n)\n\
    \        {\n            result *= k;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8vs1ucka.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmp8vs1ucka.__unittest_L28_C1() [0x427a8e]

    ??:? void tmp8vs1ucka.__modtest() [0x427b14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return n < 2 ? 1 : n * special_factorial(n - 1);\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzc915ba2.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpzc915ba2.__unittest_L20_C1() [0x427a5a]

    ??:? void tmpzc915ba2.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    for (size_t i = 0; i < n; i++)\n    {\n        factorial\
    \ *= factorial(n - i);\n    }\n    return factorial;\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_irygxb5.d(21): Error: function expected before `()`, not `factorial`
    of type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_irygxb5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // This function takes an integer n and returns the Brazilian factorial of\n\
    \    // the integer\n    long result = 1L;\n    for (n; n > 0; n--)\n    {\n \
    \       result *= factorial(n);\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp642j0x_e.d(21): Error: `n` has no effect

    /tmp/tmp642j0x_e.d(23): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp642j0x_e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    foreach(i; 0 .. n)\n    {\n        result *= factorial(i);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpckvwu_cy.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpckvwu_cy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = 1;\n    for (int i = n; i > 0; i--)\n    {\n        res *= factorial(i);\n\
    \    }\n    return res;\n}\n// Test cases:\nunittest \n{\n    assert(special_factorial(1L)\
    \ == 1L);\n    assert(special_factorial(2L) == 2L);\n    assert(special_factorial(3L)\
    \ == 36L);\n    assert(special_factorial(4L) == 288L);\n    assert(special_factorial(5L)\
    \ == 34560L);\n    assert(special_factorial(6L) == 24883200L);\n    assert(special_factorial(7L)\
    \ == 125411328000L);\n    assert(special_factorial(8L) == 396829705856000L);\n\
    \    assert(special_factorial(9L) == 806393792168064000L);\n    assert(special_factorial(10L)\
    \ == 10384327894991360000L);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ydfzoac.d(37): Error: signed integer overflow

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ydfzoac.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // The product of all the factorials from 1 to the value of the argument,\
    \ inclusive.\n    return iota(1L, n + 1).map!(factorial).reduce!`a * b`(1L);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcjf3_782.d(19): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcjf3_782.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0L);\n    return product(iota(n));\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2wouokd3.d(19): Error: undefined identifier `product`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2wouokd3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static assert(n > 0);\n    long result = 1;\n    for (long i = 2; i <= n;\
    \ i++)\n    {\n        for (long j = i; j > 0; j--)\n        {\n            result\
    \ *= j;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0thloo8o.d(18): Error: variable `n` cannot be read at compile time

    /tmp/tmp0thloo8o.d(18):        while evaluating: `static assert(n > 0L)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0thloo8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return (n<=1) ? 1L : n * special_factorial(n-1L);\n}\n/*\n    Write a function\
    \ that receives a matrix and returns the sum of all its\n    elements.\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7v71m3uy.d(20): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7v71m3uy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.math;\n    long res = 1;\n    foreach(i; 2..n+1)\n    {\n    \
    \    res *= factorial(i);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxxp8v125.d(22): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxxp8v125.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0);\n    long result = 1;\n    static typeof(1) arr = [1, 1, 2,\
    \ 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800,\
    \ 87178291200, 1307674368000, 20922789888000, 355687428096000, 6402373705728000,\
    \ 121645100408832000, 2432902008176640000];\n    if (n < 20)\n        return arr[n];\n\
    \    foreach (int i; 0 .. n+1)\n        result *= i;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2uv2kgdt.d(20): Error: cannot use array to initialize `int`

    /tmp/tmp2uv2kgdt.d(22): Error: only one index allowed to index `int`

    /tmp/tmp2uv2kgdt.d(23): Error: cannot implicitly convert expression `n + 1L` of
    type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2uv2kgdt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return foldl!(lmul)(1L, iota(1L, n + 1L));\n}\n \n/*\n    This is the best\
    \ solution that I have found, which uses only one function\n    to generate the\
    \ sequence and then fold it.\n*/\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1a5i8odw.d(18): Error: template instance `foldl!lmul` template
    `foldl` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1a5i8odw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static import Factorial;\n    long res = 1;\n    foreach(idx; 0..n)\n   \
    \ {\n        res *= factorial(idx);\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpplf1qkae.d(18): Error: module `Factorial` is in file ''Factorial.d''
    which cannot be read

    import path[0] = /tmp

    import path[1] = /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos

    import path[2] = /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpplf1qkae.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // your code here\n    auto list = new int[n];\n    foreach(idx, val; list)\n\
    \    {\n        list[idx] = idx + 1;\n    }\n    long a = reduce!(\"a * b\")(list);\n\
    \    auto list2 = new int[n-1];\n    foreach(idx, val; list2)\n    {\n       \
    \ list2[idx] = idx + 1;\n    }\n    long b = reduce!(\"a * b\")(list2);\n    auto\
    \ list3 = new int[n-2];\n    foreach(idx, val; list3)\n    {\n        list3[idx]\
    \ = idx + 1;\n    }\n    long c = reduce!(\"a * b\")(list3);\n    return a * b\
    \ * c;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8cw804uk.d(22): Error: cannot implicitly convert expression `idx
    + 1LU` of type `ulong` to `int`

    /tmp/tmp8cw804uk.d(24): Error: template instance `reduce!"a * b"` template `reduce`
    is not defined

    /tmp/tmp8cw804uk.d(28): Error: cannot implicitly convert expression `idx + 1LU`
    of type `ulong` to `int`

    /tmp/tmp8cw804uk.d(30): Error: template instance `reduce!"a * b"` template `reduce`
    is not defined

    /tmp/tmp8cw804uk.d(34): Error: cannot implicitly convert expression `idx + 1LU`
    of type `ulong` to `int`

    /tmp/tmp8cw804uk.d(36): Error: template instance `reduce!"a * b"` template `reduce`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8cw804uk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ret = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        ret *= factorial(i);\n\
    \    }\n    return ret;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp17ntbkn_.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp17ntbkn_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    for (size_t i = 1; i <= n; i++)\n    {\n      factorial\
    \ *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpx2j1k03x.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpx2j1k03x.__unittest_L25_C1() [0x427a66]

    ??:? void tmpx2j1k03x.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return product(map!(x => factorial(x))(iota(n)));\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa64abrld.d(18): Error: undefined identifier `product`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa64abrld.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long i = 0;\n    long s = 1;\n    for (; i < n; i++)\n    {\n        s *=\
    \ factorial(i);\n    }\n    return s;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph2l5u70n.d(22): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2l5u70n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long a = 1;\n    auto itr = iota(1L, n + 1);\n    foreach(long aa; itr) {\n\
    \        a *= factorial(aa);\n    }\n    return a;\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplga116sl.d(19): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplga116sl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n >= 0);\n    bool is_odd = false;\n    if (n % 2 != 0)\n    {\n \
    \       is_odd = true;\n        n--;\n    }\n    long p = 1;\n    while (n > 0)\n\
    \    {\n        p *= n;\n        n -= 2;\n    }\n    if (is_odd)\n        p *=\
    \ 2;\n    return p;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk2toyila.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e79]

    ??:? void tmpk2toyila.__unittest_L35_C1() [0x427abe]

    ??:? void tmpk2toyila.__modtest() [0x427b44]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb9f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa32]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbc5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430074]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb51]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa09]

    ??:? runModuleUnitTests [0x42b975]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  return n == 0 ? 1 : n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqsr0x7_8.d(19): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpqsr0x7_8.d(28): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsr0x7_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  auto f = long.factorial;\n  return iota(1L, n).map!(x => f(x)).product;\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppgeyxwlv.d(18): Error: no property `factorial` for type `long`

    /tmp/tmppgeyxwlv.d(19): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppgeyxwlv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 0)\n        return 0;\n    auto factorials = new UnsignedLong[n +\
    \ 1];\n    factorials[0] = 1;\n    for (int i = 1; i <= n; i++)\n        factorials[i]\
    \ = factorials[i - 1] * cast(UnsignedLong)i;\n    long result = 1;\n    for (int\
    \ i = 0; i <= n; i++)\n        result *= factorials[i];\n    return result;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi_87e_aq.d(20): Error: undefined identifier `UnsignedLong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi_87e_aq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n == 0L)\n        return 1L;\n    else\n        return n * special_factorial(n\
    \ - 1L);\n}\n/*\n    For example:\n    >>> fibonacci(1)\n    1\n    >>> fibonacci(2)\n\
    \    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(4)\n    3\n    >>> fibonacci(5)\n\
    \    5\n    >>> fibonacci(6)\n    8\n    >>> fibonacci(7)\n    13\n    >>> fibonacci(8)\n\
    \    21\n    >>> fibonacci(9)\n    34\n    >>> fibonacci(10)\n    55\n*/\nsize_t\
    \ fibonacci(size_t n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n\
    \        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n/*\n    For example:\n\
    \    >>> combinations(5, 2)\n    10\n    >>> combinations(5, 3)\n    10\n    >>>\
    \ combinations(5, 4)\n    5\n    >>> combinations(5, 5)\n    1\n    >>> combinations(5,\
    \ 6)\n    0\n*/\nsize_t combinations(size_t n, size_t r)\n{\n    if (r == 0 ||\
    \ r == n)\n        return 1;\n    else\n        return combinations(n - 1, r -\
    \ 1) + combinations(n - 1, r);\n}\n/*\n    For example:\n    >>> permutations(5,\
    \ 2)\n    20\n    >>> permutations(5, 3)\n    60\n    >>> permutations(5, 4)\n\
    \    120\n    >>> permutations(5, 5)\n    120\n    >>> permutations(5, 6)\n  \
    \  0\n*/\nsize_t permutations(size_t n, size_t r)\n{\n    if (r == 0 || r == n)\n\
    \        return 1;\n    else\n        return n * permutations(n - 1, r - 1);\n\
    }\n/*\n    For example:\n    >>> factorial(1)\n    1\n    >>> factorial(2)\n\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn7lqkfzh.d(93): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn7lqkfzh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    immutable factorial = [1L, 1L, 2L, 6L, 24L, 120L, 720L, 5040L, 40320L, 362880L,\
    \ 3628800L, 39916800L, 479001600L, 6227020800L, 87178291200L, 1307674368000L,\
    \ 20922789888000L, 355687428096000L, 6402373705728000L, 121645100408832000L, 2432902008176640000L,\
    \ 51090942171709440000L, 1124000727777607680000L, 25852016738884976640000L, 620448401733239439360000L,\
    \ 15511210043330985984000000L, 403291461126605635584000000L, 10888869450418352160768000000L,\
    \ 304888344611713860501504000000L, 8841761993739701954543616000000L, 265252859812191058636308480000000L,\
    \ 8222838654177922817725562880000000L, 263130836933693530167218012160000000L,\
    \ 8683317618811886495518194401280000000L, 295232799039604140847618609643520000000L,\
    \ 10333147966386144929666651337523200000000L, 371993326789901217467999448150835200000000L,\
    \ 13763753091226345046315979581580902400000000L, 523022617466601111760007224100074291200000000L,\
    \ 20397882081197443358640281739902897356800000000L, 815915283247897734345611269596115894272000000000L,\
    \ 33452526613163807108170062053440751665152000000000L, 1405006117752879898543142606244511569936384000000000L,\
    \ 60415263063373835637355132068513997507264512000000000L, 2658271574788448768043625811014615890319638528000000000L\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    /tmp/tmp5dzpd7vr.d(18): Error: integer overflow

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5dzpd7vr.d", '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong i = n, result = 1L;\n\twhile (i >= 2L) \n\t{\n\t\tresult *= i--;\n\t\t\
    result *= i--;\n\t}\n\treturn result;\n}\n/*\n    Before explaining the function,\
    \ I should explain the sequence.\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nx3q6a7.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nx3q6a7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // Assuming that n is greater than 0\n    long sum = 1;\n    long i = 1;\n\
    \    for (; i <= n; i += 1) {\n        long j = 1;\n        long factorial = 1;\n\
    \        for (; j <= i; j += 1) {\n            factorial *= j;\n        }\n  \
    \      sum *= factorial;\n    }\n    return sum;\n}\n/*\n    Implement the function\
    \ next_smaller(n) that takes an integer n and returns\n    the next smaller positive\
    \ integer with the same number of ones in its binary\n    representation.\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1_o_pc2q.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_o_pc2q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    alias T = long;\n    static if(is(typeof(2 * 3) == T))\n    {\n        return\
    \ n <= 1 ? 1 : n * special_factorial(n - 1);\n    }\n    else static if(is(typeof(log(2))\
    \ == T))\n    {\n        return n <= 1 ? 1 : n * special_factorial(n - 1);\n \
    \   }\n    else static if(is(typeof(1.0f / 2) == T))\n    {\n        return n\
    \ <= 1 ? 1 : n * special_factorial(n - 1);\n    }\n    else static if(is(typeof(2.0\
    \ / 3) == T))\n    {\n        return n <= 1 ? 1 : n * special_factorial(n - 1);\n\
    \    }\n    else static if(is(typeof(Complex(2, 0) * Complex(3, 0)) == T))\n \
    \   {\n        return n <= 1 ? 1 : n * special_factorial(n - 1);\n    }\n    else\n\
    \    {\n        return n <= 1 ? 1 : n * special_factorial(n - 1);\n    }\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyhmuox9e.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpyhmuox9e.__unittest_L44_C1() [0x427a5a]

    ??:? void tmpyhmuox9e.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n) * factorial(n - 1) * factorial(n - 2);\n}\n \n/*\nThe\
    \ function will take a tuple of numbers as input, and should return\ntheir sum.\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphqi7dnbz.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphqi7dnbz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res;\n    res = 1;\n    foreach(val; 1..n)\n    {\n        auto lol\
    \ = special_factorial(val);\n        res *= lol;\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpipwyopz4.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpipwyopz4.__unittest_L27_C1() [0x427a72]

    ??:? void tmpipwyopz4.__modtest() [0x427af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    foreach(n; 1 .. n + 1)\n    {\n        result *= n;\n\
    \    }\n    return result;\n}\n \nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbbvdgcy0.d(19): Error: variable `n` is shadowing variable `tmpbbvdgcy0.special_factorial.n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbbvdgcy0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long bf = 1;\n    bool[] is_factored = new bool[n];\n    is_factored[0..n]\
    \ = false;\n    long fac = 2;\n    while (fac < n) {\n        long multiple =\
    \ fac;\n        while (multiple < n) {\n            if (!is_factored[multiple])\
    \ {\n                bf *= fac;\n                is_factored[multiple] = true;\n\
    \            }\n            multiple += fac;\n        }\n        fac++;\n    }\n\
    \    return bf;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzkg_1leo.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f7d]

    ??:? void tmpzkg_1leo.__unittest_L35_C1() [0x427c7a]

    ??:? void tmpzkg_1leo.__modtest() [0x427d00]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bdb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ac46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fed1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430380]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fe5d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac1d]

    ??:? runModuleUnitTests [0x42bb89]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428440]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    foreach(i;0..n)\n    {\n        result *= factorial(i);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjlg_vnvn.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjlg_vnvn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for (int i = n; i >= 1; i--)\n    {\n        result\
    \ *= i;\n    }\n    for (int i = n-1; i >= 1; i--)\n    {\n        result *= i;\n\
    \    }\n    for (int i = n-2; i >= 1; i--)\n    {\n        result *= i;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp965zjzrb.d(19): Error: cannot implicitly convert expression `n`
    of type `long` to `int`

    /tmp/tmp965zjzrb.d(23): Error: cannot implicitly convert expression `n - 1L` of
    type `long` to `int`

    /tmp/tmp965zjzrb.d(27): Error: cannot implicitly convert expression `n - 2L` of
    type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp965zjzrb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return product(iota(1L, n+1L));\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfj9yv4b7.d(18): Error: undefined identifier `product`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfj9yv4b7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif (n < 1) \n\t{\n\t\treturn 1;\n\t}\n\t\n\tlong prod = n;\n\t\n\twhile (n >\
    \ 1) \n\t{\n\t\tprod *= (n - 1);\n\t\tn--;\n\t}\n\t\n\treturn prod;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfe9l_pk1.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpfe9l_pk1.__unittest_L33_C1() [0x427a66]

    ??:? void tmpfe9l_pk1.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static assert(n > 0);\n    return factorial(n) * factorial(n - 1);\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51em92xe.d(18): Error: variable `n` cannot be read at compile time

    /tmp/tmp51em92xe.d(18):        while evaluating: `static assert(n > 0L)`

    /tmp/tmp51em92xe.d(19): Error: undefined identifier `factorial`

    /tmp/tmp51em92xe.d(19): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51em92xe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n == 0) \n    {\n        return 1;\n    }\n    return n * special_factorial(n\
    \ - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyfbql7l7.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpyfbql7l7.__unittest_L24_C1() [0x427a62]

    ??:? void tmpyfbql7l7.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    auto l = new TypeTuple!(long);\n    while(n > 0)\n    {\n        auto r =\
    \ 1L;\n        auto i = n;\n        while(i > 0)\n        {\n            r *=\
    \ i;\n            i--;\n        }\n        l.add(r);\n        n--;\n    }\n  \
    \  return reduce!((a, b) => a * b)(l);\n}\nunittest\n{\n    alias candidate =\
    \ special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpohkdsobr.d(18): Error: template instance `TypeTuple!long` template
    `TypeTuple` is not defined

    /tmp/tmpohkdsobr.d(31): Error: template instance `reduce!((a, b) => a * b)` template
    `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpohkdsobr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // if (n == 0) return 1;\n    // long r = 1;\n    // foreach (i; 1 .. n +\
    \ 1)\n    // {\n    //     r *= factorial(i);\n    // }\n    // return r;\n  \
    \  return iota(1, n + 1).map!(factorial).reduce!((a, b) => a * b)(1);\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplz1p3qc_.d(25): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplz1p3qc_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 1)\n        return 0;\n    else\n    {\n        long count = n;\n\
    \        long accum = 1;\n        while (count > 0)\n        {\n            accum\
    \ *= count;\n            count--;\n        }\n        return accum * factorial(n\
    \ - 1);\n    }\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n \
    \   assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n   \
    \ assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_qica4it.d(29): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_qica4it.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return n * special_factorial(n\
    \ - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxsx8kbu3.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpxsx8kbu3.__unittest_L23_C1() [0x427a62]

    ??:? void tmpxsx8kbu3.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 1)\n        return 1;\n    long res = 1;\n    while (n > 1)\n   \
    \ {\n        res *= factorial(n);\n        n--;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4rf5kpjx.d(23): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4rf5kpjx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = n;\n    while(n > 1)\n    {\n        factorial *= --n;\n\
    \    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvsabmqc7.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpvsabmqc7.__unittest_L25_C1() [0x427a56]

    ??:? void tmpvsabmqc7.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long brazilian_factorial(long n)\n    {\n        long r = 1;\n        while\
    \ (n != 0) \n        {\n            r *= n--;\n        }\n        return r;\n\
    \    }\n    long result = 1;\n    while (n != 0) \n    {\n        result *= brazilian_factorial(n--);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n >= 0L);\n    long accumulator = 1L;\n    for (int i = 1; i <= n;\
    \ i++) {\n        accumulator *= factorial(i);\n    }\n    return accumulator;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg03ucoda.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg03ucoda.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \treturn n == 0 ? 1 : n * special_factorial(n - 1);\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz3e6peeb.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpz3e6peeb.__unittest_L20_C1() [0x427a62]

    ??:? void tmpz3e6peeb.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    nassert(n > 0L, \"n should be > 0\");\n    return n * special_factorial(n\
    \ - 1L);\n}\n/*\n    The function should get an integer array and return a bool\
    \ array.\n    Each value in the returned array will be true iff the corresponding\
    \ number in the input\n    array is bigger than the average of all the values\
    \ in the input array.\n    \n    For example:\n    >>> is_bigger_than_average([1,\
    \ 2, 3])\n    [false, false, true]\n    \n    >>> is_bigger_than_average([])\n\
    \    []\n    \n    Note that if the input array is empty then the function should\
    \ return an empty array.\n    \n*/\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa7hjvnoc.d(18): Error: undefined identifier `nassert`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa7hjvnoc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n<1) return -1;\n    return n*special_factorial(n-1);\n}\n \n \nlong\
    \ special_factorial(long n) \n{\n    if (n<1) return -1;\n    if (n==1) return\
    \ 1;\n    return n*special_factorial(n-1);\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu3lrwu1g.d(19): Error: `tmpu3lrwu1g.special_factorial` called with
    argument types `(long)` matches both:

    /tmp/tmpu3lrwu1g.d(16):     `tmpu3lrwu1g.special_factorial(long n)`

    and:

    /tmp/tmpu3lrwu1g.d(23):     `tmpu3lrwu1g.special_factorial(long n)`

    /tmp/tmpu3lrwu1g.d(27): Error: `tmpu3lrwu1g.special_factorial` called with argument
    types `(long)` matches both:

    /tmp/tmpu3lrwu1g.d(16):     `tmpu3lrwu1g.special_factorial(long n)`

    and:

    /tmp/tmpu3lrwu1g.d(23):     `tmpu3lrwu1g.special_factorial(long n)`

    /tmp/tmpu3lrwu1g.d(33): Error: `tmpu3lrwu1g.special_factorial` called with argument
    types `(long)` matches both:

    /tmp/tmpu3lrwu1g.d(16):     `tmpu3lrwu1g.special_factorial(long n)`

    and:

    /tmp/tmpu3lrwu1g.d(23):     `tmpu3lrwu1g.special_factorial(long n)`

    /tmp/tmpu3lrwu1g.d(34): Error: `tmpu3lrwu1g.special_factorial` called with argument
    types `(long)` matches both:

    /tmp/tmpu3lrwu1g.d(16):     `tmpu3lrwu1g.special_factorial(long n)`

    and:

    /tmp/tmpu3lrwu1g.d(23):     `tmpu3lrwu1g.special_factorial(long n)`

    /tmp/tmp'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return product(iota(1L, n));\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo1xgyr_8.d(18): Error: undefined identifier `product`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo1xgyr_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = 1;\n    foreach(i; 1..n+1)\n    {\n        res *= factorial(i);\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppnjg9lvr.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppnjg9lvr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    mixin(map!(a => a*1, iota(1, n)).reduce!`a + b`);\n}\n \n/*\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qytwpp4.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qytwpp4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long i = 0L;\n  long result = 1L;\n  while (i < n) \n  {\n    i = i + 1L;\n\
    \    result = result * i * special_factorial(i - 1L);\n  }\n  return result;\n\
    }\n/*\nThis problem asks you to write a function which returns the first n fibonacci\n\
    numbers.\n    For example:\n    >>> fibonacci(4)\n    [0, 1, 1, 2]\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8r01aii9.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8r01aii9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0L);\n    long res = 1L;\n    foreach(i; 0 .. n) \n    {\n   \
    \     res *= factorial(i);\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_v1s_j4s.d(22): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_v1s_j4s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0);\n    long n_factorial = 1;\n    long n_m_factorial = 1;\n\
    \    long counter = 0;\n    while (counter < n) {\n        n_factorial *= (n -\
    \ counter);\n        n_m_factorial *= (n - counter - 1);\n        ++counter;\n\
    \    }\n    return n_factorial * n_m_factorial;\n}\n/*\nImplement an algorithm\
    \ to determine if a string has all unique characters.\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp678hv3aj.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp678hv3aj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long nFactorial = 1;\n    long temp = n;\n    foreach(curr; 0 .. n)\n   \
    \ {\n        nFactorial *= temp;\n        temp--;\n    }\n    return nFactorial;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvs1teumu.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpvs1teumu.__unittest_L27_C1() [0x427a72]

    ??:? void tmpvs1teumu.__modtest() [0x427af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0);\n    auto ret = 1;\n    for (int i = 1; i <= n; i++)\n   \
    \ {\n        ret *= factorial(i);\n    }\n    return ret;\n}\nunittest\n{\n  \
    \  alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9i1vm9o.d(22): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9i1vm9o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.math : factorial;\n    n = n < 0 ? n : n + 1;\n    return factorial(n);\n\
    }\nlong special_factorial(long n)\n{\n    import std.range : iota;\n    import\
    \ std.math : factorial;\n    n = n < 0 ? n : n + 1;\n    return iota(n, 0, -1).map!(x\
    \ => factorial(x)).product;\n}\nlong special_factorial(long n) \n{\n    import\
    \ std.math : factorial;\n    n = n < 0 ? n : n + 1;\n    long ret;\n    ret =\
    \ factorial(n);\n    foreach(i; 0 .. n) \n    {\n        ret *= factorial(i);\n\
    \    }\n    return ret;\n}\nlong special_factorial(long n) \n{\n    n = n < 0\
    \ ? n : n + 1;\n    return n < 2 ? 1 : n * special_factorial(n - 1);\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeh03m05i.d(18): Error: module `std.math` import `factorial` not
    found

    /tmp/tmpeh03m05i.d(25): Error: module `std.math` import `factorial` not found

    /tmp/tmpeh03m05i.d(27): Error: no property `map` for type `Result`

    /tmp/tmpeh03m05i.d(31): Error: module `std.math` import `factorial` not found

    /tmp/tmpeh03m05i.d(44): Error: `tmpeh03m05i.special_factorial` called with argument
    types `(long)` matches both:

    /tmp/tmpeh03m05i.d(16):     `tmpeh03m05i.special_factorial(long n)`

    and:

    /tmp/tmpeh03m05i.d(41):     `tmpeh03m05i.special_factorial(long n)`

    /tmp/tmpeh03m05i.d(50): Error: `tmpeh03m05i.special_factorial` called with argument
    types `(long)` matches both:

    /tmp/tmpeh03m05i.d(16):     `tmpeh03m05i.special_factorial(long n)`

    and:

    /tmp/tmpeh03m05i.d(41):     `tmpeh03m05i.special_factorial(long n)`

    /tmp/tmpeh03m05i.d(51): Error: `tmpeh03m05i.special_factorial` called with argument
    types `(long)` matches both:

    /tmp/tmpeh03m05i.d(16):     `tmpeh03m05i.special_factorial(long n)`

    and:

    /tmp/tmpeh03m05i.d(41):     `'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for (long i = n; i >= 1; i--)\n    {\n        result\
    \ *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgbcc4icj.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgbcc4icj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.range;\n    return product(1..n);\n}\n/*\nGiven a string, `find_unique_letters`\
    \ function should return all unique letters\nthat have a count of 1. The string\
    \ should be treated case-insensitively, and the\noutput string should be lowercase.\n\
    */\nstring find_unique_letters(string s) \n{\n    import std.algorithm.comparison\
    \ : equal;\n    import std.algorithm.searching : count;\n    import std.array\
    \ : array;\n    import std.range;\n    import std.conv;\n    return to!string(array(s.toLower().filter!(ch\
    \ => count(s.toLower(), ch) == 1)));\n}\n/*\nThe Halloween sale has begun, and\
    \ you've decided to buy some potions for your\nwizarding friends. You'll need\
    \ to find out how much you'll spend. You will be\ngiven the cost of each potion\
    \ and the number of potions you wish to buy. You\nmust buy at least 1 potion.\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq_0r34vj.d(19): Error: found `..` when expecting `,`

    /tmp/tmpq_0r34vj.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_0r34vj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long nl = n;\n    while(nl > 1)\n    {\n        n *= nl--;\n    }\n    return\
    \ n;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaui8_dpk.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpaui8_dpk.__unittest_L25_C1() [0x427a56]

    ??:? void tmpaui8_dpk.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n <= 0)\n        return 1;\n    return n * special_factorial(n - 1);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp36cm508h.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp36cm508h.__unittest_L22_C1() [0x427a5a]

    ??:? void tmp36cm508h.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n) * product(iota(1L, n));\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpifwyczjn.d(18): Error: undefined identifier `factorial`

    /tmp/tmpifwyczjn.d(18): Error: undefined identifier `product`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpifwyczjn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for (; n > 0; --n)\n    {\n        result *= n;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpa5skkjyp.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpa5skkjyp.__unittest_L25_C1() [0x427a5a]

    ??:? void tmpa5skkjyp.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return (n > 0L ? n * special_factorial(n - 1L) : 1L);\n}\nunittest\n{\n \
    \   alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpns2apgtg.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpns2apgtg.__unittest_L20_C1() [0x427a5a]

    ??:? void tmpns2apgtg.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return n < 1 ? 0 : factorial(n) * factorial(n - 1) * factorial(n - 2);\n\
    }\n```\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9c_l6tso.d(20): Error: declaration expected, not `""`

    /tmp/tmp9c_l6tso.d(20): Error: unterminated string constant starting at /tmp/tmp9c_l6tso.d(20)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9c_l6tso.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return fac(n);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgkzd90ye.d(18): Error: undefined identifier `fac`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgkzd90ye.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong factorial = 1;\n\twhile(n>0) {\n\t\tfactorial *= n;\n\t\tn--;\n\t}\n\t\
    return factorial;\n}\n/*\nHey, Happy New Year!\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpopn4d_cd.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopn4d_cd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    n = n.factorial.factorial.factorial;\n    return n;\n}\nunittest\n{\n   \
    \ alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsp3ek6be.d(18): Error: no property `factorial` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsp3ek6be.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = 1;\n    foreach(i; 1 .. n + 1)\n    {\n        res *= i;\n   \
    \ }\n    return res;\n}\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpibphjp5z.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpibphjp5z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // your code here\n    long result = 1;\n    foreach(i; 1 .. n + 1)\n   \
    \ {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppktusdr4.d(22): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppktusdr4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long brazilian_factorial(long n)\n    {\n        long r1 = 1L;\n        for\
    \ (long i = 1L; i <= n; i++)\n        {\n            r1 *= i;\n        }\n   \
    \     return r1;\n    }\n    long r2 = 1L;\n    for (long i = 1L; i <= n; i++)\n\
    \    {\n        r2 *= brazilian_factorial(i);\n    }\n    return r2;\n}\n/*\n\
    Your task will be to write a function called getMiddlePermutation which will take\
    \ a string that contains the characters a, b, c, d, e, f and g in some order.\
    \ Those characters will always be given in that specific order, but your function\
    \ should return the middle permutation of whatever string is passed in.\nThe middle\
    \ permutation is the one that comes exactly in the middle of the sorted list of\
    \ all permutations of the given characters, with respect to the given order. If\
    \ there are an even number of permutations of the given characters, you should\
    \ return the one that comes first in the list.\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsxjg1dqv.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsxjg1dqv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n == 0L)\n        return 1L;\n    return n * special_factorial(n - 1L);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_egeov3_.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmp_egeov3_.__unittest_L22_C1() [0x427a62]

    ??:? void tmp_egeov3_.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    foreach(i; 1 .. n)\n    {\n        result *= factorial(i);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyefg_j9f.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyefg_j9f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = n;\n    n--;\n    while(n > 0)\n    {\n        result *= n;\n\
    \        n--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo_9x_0ta.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpo_9x_0ta.__unittest_L27_C1() [0x427a5a]

    ??:? void tmpo_9x_0ta.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return n > 0 ? n*special_factorial(n-1) : 1;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnb88a3yw.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpnb88a3yw.__unittest_L20_C1() [0x427a5a]

    ??:? void tmpnb88a3yw.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n <= 0) return 1;\n    return n * special_factorial(n - 1);\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp32lcmd6i.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp32lcmd6i.__unittest_L21_C1() [0x427a5a]

    ??:? void tmp32lcmd6i.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = n;\n    for (long i = n-1; i > 0; i--) {\n        result *=\
    \ i;\n    }\n    return result;\n}\n \n/*\nThe Brazilian factorial is defined\
    \ as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where\
    \ n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpchna3gxp.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchna3gxp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return brazilian_factorial(n);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8aadtdzk.d(18): Error: undefined identifier `brazilian_factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8aadtdzk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long[] a = new long[n];\n    long[] b = new long[n];\n    a[0] = 1;\n   \
    \ b[0] = n;\n    for (int i = 1; i < n; i++)\n    {\n        a[i] = a[i - 1] *\
    \ i;\n        b[i] = b[i - 1] * (n - i);\n    }\n    return reduce!\"a * b\"(array(a),\
    \ array(b));\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n   \
    \ assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnr407hm5.d(27): Error: template instance `reduce!"a * b"` template
    `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnr407hm5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \t// mult is used to hold a running product of all the intermediate special_factorials\n\
    \tlong mult = 1L;\n\tforeach(i; typeof(i) <= n)\n\t{\n\t\tmult *= factorial(i);\n\
    \t}\n\treturn mult;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8s3twcs_.d(20): Error: undefined identifier `i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8s3twcs_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    auto r = 1L;\n    foreach(i; 1 .. n + 1)\n    {\n        r *= i;\n    }\n\
    \    return r;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n \
    \   assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n   \
    \ assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg_iurgh1.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpg_iurgh1.__unittest_L25_C1() [0x427a66]

    ??:? void tmpg_iurgh1.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    long current_result = 1;\n    while (n > 0) {\n   \
    \     result *= current_result;\n        current_result *= n;\n        n--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplq30i0nv.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmplq30i0nv.__unittest_L27_C1() [0x427a6e]

    ??:? void tmplq30i0nv.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long p = product(1 .. n);\n    long q = product(1 .. n - 1);\n    long r\
    \ = product(1 .. n - 2);\n    long s = product(1 .. n - 3);\n    long t = product(1\
    \ .. n - 4);\n    long u = product(1 .. n - 5);\n    long v = product(1 .. n -\
    \ 6);\n    long w = product(1 .. n - 7);\n    long x = product(1 .. n - 8);\n\
    \    long y = product(1 .. n - 9);\n    long z = product(1 .. n - 10);\n    long\
    \ a = product(1 .. n - 11);\n    long b = product(1 .. n - 12);\n    long c =\
    \ product(1 .. n - 13);\n    long d = product(1 .. n - 14);\n    long e = product(1\
    \ .. n - 15);\n    long f = product(1 .. n - 16);\n    long g = product(1 .. n\
    \ - 17);\n    long h = product(1 .. n - 18);\n    long i = product(1 .. n - 19);\n\
    \    long j = product(1 .. n - 20);\n    long k = product(1 .. n - 21);\n    long\
    \ l = product(1 .. n - 22);\n    long m = product(1 .. n - 23);\n    long o =\
    \ product(1 .. n - 24);\n    long qq = product(1 .. n - 25);\n    long rr = product(1\
    \ .. n - 26);\n    long ss = product(1 .. n - 27);\n    long tt = product(1 ..\
    \ n - 28);\n    long uu = product(1 .. n - 29);\n    long vv = product(1 .. n\
    \ - 30);\n    long ww = product(1 .. n - 31);\n    long xx = product(1 .. n -\
    \ 32);\n    long yy = product(1 .. n - 33);\n    long zz = product(1 .. n - 34);\n\
    \    long aa = product(1 .. n - 35);\n    long bb = product(1 .. n - 36);\n  \
    \  long cc = product(1 .. n - 37);\n    long dd = product(1\nunittest\n{\n   \
    \ alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmfk1x0x9.d(18): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(19): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(20): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(21): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(22): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(23): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(24): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(25): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(26): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(27): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(28): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(29): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(30): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(31): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(32): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(33): Error: found `..` when expecting `,`

    /tmp/tmpmfk1x0x9.d(34): Error: found `..` when e'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static int[] factorials = new int[];\n    int num = factorials.length;\n\
    \    factorials ~= n;\n    for (int i = num; i < n; i++)\n    {\n        factorials\
    \ ~= factorials[$-1] * (i + 1);\n    }\n    return factorials[$-1];\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz16c98_x.d(18): Error: new can only create structs, dynamic arrays
    or class objects, not `int[]`''s

    /tmp/tmpz16c98_x.d(19): Error: cannot implicitly convert expression `factorials.length`
    of type `ulong` to `int`

    /tmp/tmpz16c98_x.d(20): Error: cannot append type `long` to type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz16c98_x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    while (n > 0)\n    {\n        result *= factorial(n);\n\
    \        n--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbke4ino3.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbke4ino3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long f = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        f *= factorial(i);\n\
    \    }\n    return f;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwkqjf3m_.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwkqjf3m_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factor = 1;\n    long counter = 1;\n    while (counter <= n)\n    {\n\
    \        factor *= counter;\n        counter++;\n    }\n    return factor;\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptfq3usgi.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmptfq3usgi.__unittest_L27_C1() [0x427a62]

    ??:? void tmptfq3usgi.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = n;\n    for (int i = 2; i < n; i++)\n    {\n        result\
    \ *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxk9yjo34.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpxk9yjo34.__unittest_L25_C1() [0x427a62]

    ??:? void tmpxk9yjo34.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \treturn typeof(n)(factorial(n) * factorial(n - 1) * factorial(n - 2));\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptfg5tix_.d(18): Error: undefined identifier `factorial`

    /tmp/tmptfg5tix_.d(18): Error: undefined identifier `factorial`

    /tmp/tmptfg5tix_.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptfg5tix_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fac = 1;\n    for (long i = 1; i <= n; i++)\n    {\n        fac *= i;\n\
    \    }\n    return fac;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr1lo6i1n.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpr1lo6i1n.__unittest_L25_C1() [0x427a62]

    ??:? void tmpr1lo6i1n.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    mixin Factorial;\n    long f = 1;\n    foreach(immutable i; 0 .. n)\n   \
    \ {\n        f *= factorial(i);\n    }\n    return f;\n}\n/*\nThis is a variant\
    \ on the famous FizzBuzz problem. The purpose of this problem is\nto implement\
    \ a function that will return a string with numbers from 1 to n,\nwhere:\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp27pftzdx.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27pftzdx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.algorithm.iteration : accumulate;\n    import std.range.primitives\
    \ : iota;\n    import std.conv : to;\n    import std.math : factorial;\n    return\
    \ n <= 0 ? 0L : accumulate(iota(1L, n+1L).map!factorial);\n}\n```\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpna172mvq.d(24): Error: declaration expected, not `""`

    /tmp/tmpna172mvq.d(24): Error: unterminated string constant starting at /tmp/tmpna172mvq.d(24)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpna172mvq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.typecons;\n    import std.math;\n    //long x = 1;\n    Tuple!(long,long)\
    \ result;\n    //long result;\n    //result = n;\n    for (int i = 1; i < n; i++)\n\
    \    {\n        result = result.tupleof;\n        //result = n;\n        n = n\
    \ * n;\n    }\n    return n;\n}\n/*\nThe term \"regular\" polygon refers to any\
    \ polygon that is equiangular (all angles are equal in measure) and equilateral\
    \ (all sides have the same length).\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx86639u3.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx86639u3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    mixin(special_factorial_c!(long, \"n\", n));\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpskzx6u81.d(18): Error: template instance `special_factorial_c!(long,
    "n", n)` template `special_factorial_c` is not defined, did you mean special_factorial?

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return iota(1L, n + 1).foldLeft!((acc, x) => acc * std.math.factorial(x))();\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9nvw0guq.d(18): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9nvw0guq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.stdio;\n    writefln(\"The value of n is: %s\", n);\n    long\
    \ val = 1;\n    for (int i = 1; i <= n; i++) {\n        val *= i;\n    }\n   \
    \ return val;\n}\nlong brazilian_factorial(long n)\n{\n    import std.stdio;\n\
    \    writefln(\"The value of n is: %s\", n);\n    return special_factorial(n)\
    \ * special_factorial(n-1) * special_factorial(n-2);\n}\n/*\nThe following is\
    \ a very famous mathematical problem called the Josephus Problem.\nThe problem\
    \ is as follows:\n    - There are N people standing in a circle waiting to be\
    \ executed.\n    - The counting out begins at some point in the circle and proceeds\
    \ around the\n      circle in a fixed direction.\n    - In each step, a certain\
    \ number of people are skipped and the next person is\n      executed.\n    -\
    \ The elimination proceeds around the circle (which is becoming smaller and\n\
    \      smaller as the executed people are removed), until only the last person\n\
    \      remains, who is given freedom.\n    - Given the total number of persons\
    \ N and a number K which indicates that K-1\n      persons are skipped and kth\
    \ person is killed in circle.\n    - The task is to choose the place in the initial\
    \ circle so that you are the\n      last one remaining and so survive.\n    -\
    \ Assume that there are 4 persons to be executed and you are the first one to\n\
    \      be executed, you are numbered 1.\n    - The initial arrangement will be\
    \ 1 2 3 4, lets say you choose position 2,\n      i.e., to be executed at position\
    \ 2, then you will be executed first and the\n      initial arrangement will be\
    \ changed to 1 3 4.\n    - They will kill at position 2, now initial arrangement\
    \ will be 1 4 3, then\n      they will kill at position 3, then initial arrangement\
    \ will be 1 4 and\n      finally they will kill at position 1, hence you will\
    \ be the last one\n      remaining.\n    - You have to find the initial position\
    \ of the person to be executed to save\n      him/her.\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprupji9wm.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprupji9wm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    \n    return product(iota(n+1, 1L));\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpffx1w8ew.d(19): Error: undefined identifier `product`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpffx1w8ew.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    enforce(n > 0L, \"n > 0\");\n    //++n;\n    long a = 1L;\n    for (int i\
    \ = 1; i <= n; i++)\n    {\n        a *= factorial(i);\n    }\n    return a;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprxc31nz7.d(18): Error: undefined identifier `enforce`

    /tmp/tmprxc31nz7.d(23): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprxc31nz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static FactorialArray facts = new FactorialArray();\n    return facts[n];\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp97v12p1r.d(18): Error: undefined identifier `FactorialArray`

    /tmp/tmp97v12p1r.d(18): Error: undefined identifier `FactorialArray`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp97v12p1r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long f = 1;\n    while (n > 0) {\n        f *= n;\n        n -= 1;\n    }\n\
    \    return f;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n \
    \   assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n   \
    \ assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxch_07us.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpxch_07us.__unittest_L25_C1() [0x427a5a]

    ??:? void tmpxch_07us.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long brazilian_factorial = 1L;\n    foreach(number; iota(n, 0, -1)) \n  \
    \  {\n        brazilian_factorial *= factorial(number);\n    }\n    return brazilian_factorial;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwxj484e.d(19): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwxj484e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long nAux=n;\n    if(n==0) return 1;\n    long nFatorial=1;\n    while(nAux>0)\n\
    \    {\n        nFatorial*=nAux;\n        nAux--;\n    }\n    return nFatorial*special_factorial(n-1);\n\
    }\n/*\nThe special product is defined as:\n    special_product(p) = p[0] * p[1]\
    \ * p[2] * ... * p[n]\n    where p is a list of integers and n is the length of\
    \ p\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6l4eazhr.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6l4eazhr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.math;\n    import std.typecons;\n    \n    long[] arr;\n    while(n\
    \ > 0)\n    {\n        arr ~= (n--);\n    }\n    //writeln(arr);\n    return reduce!\"\
    a * b\"(arr);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n  \
    \  assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr__q6ylk.d(27): Error: template instance `reduce!"a * b"` template
    `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr__q6ylk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    foreach(i; 1 .. n)\n    {\n      fact *= factorial(i);\n\
    \    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj5jlsh5o.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj5jlsh5o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 0)\n        return 0;\n    if (n == 0)\n        return 1;\n    auto\
    \ result = n;\n    foreach (index; 1 .. n)\n        result *= index;\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyhd7u_qe.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmpyhd7u_qe.__unittest_L27_C1() [0x427a92]

    ??:? void tmpyhd7u_qe.__modtest() [0x427b18]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ret = 1;\n    foreach(i; 2 .. n + 1)\n    {\n        long accum = 1;\n\
    \        foreach(j; 1 .. i + 1)\n        {\n            accum *= j;\n        }\n\
    \        ret *= accum;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  if (n <= 1) \n    return 1;\n  return n * special_factorial(n - 1);\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuq3gqhw1.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpuq3gqhw1.__unittest_L22_C1() [0x427a5a]

    ??:? void tmpuq3gqhw1.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    auto factorial = iota(1L, n + 1);\n    auto factorial_accumulate = reduce!q{a\
    \ * b}(factorial);\n    return factorial_accumulate;\n}\n \n// void main() {\n\
    //     foreach(i; 0..10)\n//         writeln(special_factorial(i));\n// }\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy6om8asp.d(18): Error: undefined identifier `iota`

    /tmp/tmpy6om8asp.d(19): Error: template instance `reduce!"a * b"` template `reduce`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy6om8asp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    int fac = 1;\n    foreach(i; 1..n)\n    {\n        fac = fac * i;\n    }\n\
    \    return fac;\n}\n/*\nThe purpose of this kata is to write a higher-order function\
    \ which is capable of creating a function that iterates on a specified function\
    \ a given number of times. This new functions takes in an argument as a seed to\
    \ start the computation from.\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo05gxyxt.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo05gxyxt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 0)\n        return -1;\n    if (n == 0)\n        return 1;\n    return\
    \ n * special_factorial(n - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppwk135ja.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmppwk135ja.__unittest_L24_C1() [0x427a6e]

    ??:? void tmppwk135ja.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    int _n = to!int(n);\n    if (_n < 0) return -1;\n    if (_n == 0) return\
    \ 1;\n    if (_n == 1) return 1;\n    auto result = _n * special_factorial(_n\
    \ - 1);\n    return result;\n}\n \nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk_4_khl3.d(18): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_4_khl3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 0) \n    {\n        return -1;\n    }\n    else \n    {\n       \
    \ long result = 1;\n        for (; n > 0; n--) \n        {\n            result\
    \ *= n;\n        }\n        return result;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi_j_29an.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpi_j_29an.__unittest_L32_C1() [0x427a6a]

    ??:? void tmpi_j_29an.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  return factorial(n) * factorial(n - 1) * factorial(n - 2);\n}\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu_zth2b_.d(18): Error: undefined identifier `factorial`

    /tmp/tmpu_zth2b_.d(18): Error: undefined identifier `factorial`

    /tmp/tmpu_zth2b_.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu_zth2b_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0L);\n    long result = 1L;\n    long f;\n    while (n > 0L) {\n\
    \        f = 1L;\n        foreach (k; 1L .. n+1L)\n            f *= k;\n     \
    \   result *= f;\n        n--;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif (n == 0) return 1;\n\tauto fac = n;\n\tforeach (i; 1 .. n) {\n\t\tfac *=\
    \ n - i;\n\t}\n\treturn fac;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptcsz4_5m.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d8d]

    ??:? void tmptcsz4_5m.__unittest_L25_C1() [0x427a8a]

    ??:? void tmptcsz4_5m.__modtest() [0x427b10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a946]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff88]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a91d]

    ??:? runModuleUnitTests [0x42b889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static immutable fact = tuple(1L, 1L, 2L, 6L, 24L, 120L, 720L, 5040L, 40320L,\
    \ 362880L, 3628800L, 39916800L, 479001600L, 6227020800L, 87178291200L, 1307674368000L,\
    \ 20922789888000L, 355687428096000L, 6402373705728000L, 121645100408832000L, 2432902008176640000L);\n\
    \    return fact[n];\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgl5oxk2e.d(19): Error: variable `n` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgl5oxk2e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    auto primes = tuple(primeFactors(n));\n    long result = 1;\n    foreach(p;\
    \ primes) \n    {\n        result *= p;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbza_xkmt.d(18): Error: undefined identifier `primeFactors`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbza_xkmt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163940
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    foreach(i; 1..n)\n    {\n        factorial *= i;\n\
    \    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbgacr74h.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpbgacr74h.__unittest_L25_C1() [0x427a62]

    ??:? void tmpbgacr74h.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 0)\n        return 0;\n    else\n    {\n        long total = 1;\n\
    \        for (long i = n; i > 0; i--)\n        {\n            total *= i;\n  \
    \      }\n        for (long i = n - 1; i > 0; i--)\n        {\n            total\
    \ *= i;\n        }\n        for (long i = n - 2; i > 0; i--)\n        {\n    \
    \        total *= i;\n        }\n        return total;\n    }\n}\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmposa0xlyv.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dc5]

    ??:? void tmposa0xlyv.__unittest_L38_C1() [0x427ae1]

    ??:? void tmposa0xlyv.__modtest() [0x427b44]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baeb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a97e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a955]

    ??:? runModuleUnitTests [0x42b8c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428214]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return n > 0 ? n * special_factorial(n - 1) : 1;\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1hz9dklo.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp1hz9dklo.__unittest_L20_C1() [0x427a5a]

    ??:? void tmp1hz9dklo.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    switch(n)\n    {\n        case 0: return 1;\n        case 1: return 1;\n\
    \        case 2: return 2;\n        case 3: return 6;\n        case 4: return\
    \ 24;\n        case 5: return 120;\n        case 6: return 720;\n        case\
    \ 7: return 5040;\n        case 8: return 40320;\n        case 9: return 362880;\n\
    \        case 10: return 3628800;\n        case 11: return 39916800;\n       \
    \ case 12: return 479001600;\n        case 13: return 6227020800;\n        case\
    \ 14: return 87178291200;\n        case 15: return 1307674368000;\n        case\
    \ 16: return 20922789888000;\n        case 17: return 355687428096000;\n     \
    \   case 18: return 6402373705728000;\n        case 19: return 121645100408832000;\n\
    \        case 20: return 2432902008176640000;\n        case 21: return 51090942171709440000;\n\
    \        case 22: return 1124000727777607680000;\n        case 23: return 25852016738884976640000;\n\
    \        case 24: return 620448401733239439360000;\n        case 25: return 15511210043330985984000000;\n\
    \        case 26: return 403291461126605635584000000;\n        case 27: return\
    \ 10888869450418352160768000000;\n        case 28: return 304888344611713860501504000000;\n\
    \        case 29: return 8841761993739701954543616000000;\n        case 30: return\
    \ 265252859812191058636308480000000;\n        case 31: return 8222838654177922817725562880000000;\n\
    \        case 32: return 263130836933693530167218012160000000;\n        case 33:\
    \ return 8683317618811886495518194401280000000;\n        case 34: return 295232799039604140847618609643520000000;\n\
    \        case 35: return 10333147966386144929666651337523200000000;\n        case\
    \ 36: return\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf_dhlbgs.d(41): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(42): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(43): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(44): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(45): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(46): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(47): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(48): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(49): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(50): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(51): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(52): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(53): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(54): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(55): Error: integer overflow

    /tmp/tmpf_dhlbgs.d(57): Error: expression expected, not `unittest`

    /tmp/tmpf_dhlbgs.d(58): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmpf_dhlbgs.d(66): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/t'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long a = 1L;\n    long b = 1L;\n    for (size_t i = n; i > 1; i--)\n    {\n\
    \        a *= i;\n        b *= a;\n    }\n    return b;\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8ojre87g.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmp8ojre87g.__unittest_L27_C1() [0x427a6e]

    ??:? void tmp8ojre87g.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.algorithm;\n    import std.math;\n    import std.typecons;\n \
    \   import std.range;\n    import std.stdio;\n    ////auto sumRange = iota(1,\
    \ n + 1).map!(x => factorial(x));\n    //auto sumRange = iota(1, n + 1).map!(x\
    \ => factorial(x)).reduce!((acc, x) => acc * x)();\n    ////auto s = sumRange.reduce!((acc,\
    \ x) => acc * x)();\n    //return sumRange;\n    // write your code here\n   \
    \ return iota(1, n + 1).map!(x => factorial(x)).reduce!((acc, x) => acc * x)();\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf3ntl684.d(28): Error: undefined identifier `factorial`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):        instantiated
    from here: `MapResult!(__lambda2, Result)`

    /tmp/tmpf3ntl684.d(28):        instantiated from here: `map!(Result)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf3ntl684.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0L);\n    long ret = 0L;\n    long fac = 1L;\n    long i = 1L;\n\
    \    while (i <= n) {\n        fac *= i;\n        ret += fac;\n        i++;\n\
    \    }\n    return ret;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzo7viofn.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e59]

    ??:? void tmpzo7viofn.__unittest_L29_C1() [0x427aa2]

    ??:? void tmpzo7viofn.__modtest() [0x427b28]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa12]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430054]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb31]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9e9]

    ??:? runModuleUnitTests [0x42b955]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // your code goes here\n    auto x = n;\n    while(x != 1)\n    {\n     \
    \   n *= x;\n        x--;\n    }\n    return n;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwmnqk87l.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpwmnqk87l.__unittest_L27_C1() [0x427a56]

    ??:? void tmpwmnqk87l.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong sf = 1;\n\tfor (n; n > 0; n--)\n\t{\n\t\tsf *= n;\n\t}\n\treturn sf;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpogjbw5e2.d(19): Error: `n` has no effect

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogjbw5e2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    //TODO\n    if (n > 0)\n    {\n        foreach (n;\
    \ 0L .. n)\n        {\n            factorial *= n;\n        }\n    }\n    return\
    \ factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n   \
    \ assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprcuq_q00.d(22): Error: variable `n` is shadowing variable `tmprcuq_q00.special_factorial.n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprcuq_q00.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static long[long] memo;\n    return _special_factorial(n, memo);\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpesh4rkjl.d(19): Error: undefined identifier `_special_factorial`,
    did you mean function `special_factorial`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpesh4rkjl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long r = 1;\n    foreach(i;1..n+1)\n    {\n        r *= i;\n    }\n    return\
    \ r;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpljvjiln1.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpljvjiln1.__unittest_L25_C1() [0x427a66]

    ??:? void tmpljvjiln1.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static if (isIntegral!long)\n    {\n        if (n < 0)\n            return\
    \ 0;\n        else if (n == 0)\n            return 1;\n        else\n        \
    \    return n * special_factorial(n - 1);\n    }\n    else\n    {\n        return\
    \ 0;\n    }\n}\n// end::solution[]\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg3efq3qk.d(18): Error: template instance `isIntegral!long` template
    `isIntegral` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg3efq3qk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0);\n    //Your code goes here\n    //Your code goes here\n  \
    \  n = n + (n-1) + (n-2);\n    return n;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwvjh0nhn.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e39]

    ??:? void tmpwvjh0nhn.__unittest_L24_C1() [0x427a82]

    ??:? void tmpwvjh0nhn.__modtest() [0x427b08]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb5f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb85]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430034]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb11]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9c9]

    ??:? runModuleUnitTests [0x42b935]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428288]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0);\n    long factoral = 1;\n    while(n > 0)\n    {\n       \
    \ factoral *= std.math.factorial(n);\n        n--;\n    }\n    return factoral;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo82aavkq.d(22): Error: undefined identifier `factorial` in module
    `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo82aavkq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // size_t x = cast(size_t)n;\n    // auto d = tuple(iota(x));\n    // return\
    \ reduce!\"a * b\"(1, d);\n    return range(1,n+1).reduce!\"a * b\"(1L);\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz3asqhki.d(21): Error: undefined identifier `range`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz3asqhki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.algorithm, std.functional;\n    import std.range;\n    return\
    \ n.iota().product;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpihoy7wi9.d(20): Error: no property `product` for type `Result`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpihoy7wi9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n) * product(map!(x => factorial(x))(iota(n-1L)));\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl99kocjm.d(18): Error: undefined identifier `factorial`

    /tmp/tmpl99kocjm.d(18): Error: undefined identifier `product`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl99kocjm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long r = 1;\n    while (n >= 1) \n    {\n      r *= n;\n      n--;\n    }\n\
    \    return r;\n}\nimport std.range;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu0m9dvj5.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpu0m9dvj5.__unittest_L27_C1() [0x427a5a]

    ??:? void tmpu0m9dvj5.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long sf = 1;\n    foreach(i; 1 .. n)\n    {\n        sf *= i;\n    }\n  \
    \  return sf;\n}\n// class Address is\n//     private(\n//         string   street,\n\
    //         string   city,\n//         string   state,\n//         string   country,\n\
    //         string   postcode\n//     );\n//     char* street,\n//     char* city,\n\
    //     char* state,\n//     char* country,\n//     char* postcode\n// };\nstring[]\
    \ address_details(string street, string city, string state, string country, string\
    \ postcode) \n{\n    return [street, city, state, country, postcode];\n}\n/*\n\
    Your task is to implement a \n*/\nstring format_address(string street, string\
    \ city, string state, string country, string postcode) \n{\n    string[] pieces\
    \ = address_details(street, city, state, country, postcode);\n    return format(\"\
    %s\\n%s, %s %s\\n%s\", pieces[0], pieces[1], pieces[2], pieces[3], pieces[4]);\n\
    }\n// class Address is\n//     private(\n//         string   street,\n//     \
    \    string   city,\n//         string   state,\n//         string   country,\n\
    //         string   postcode\n//     );\n// };\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdr420ufz.d(49): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdr420ufz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    /*\n    auto result = reduce!\"a * b\"(iota(n, 1));\n    return result *\
    \ reduce!\"a * b\"(iota(n-1, 1));\n    */\n    /*\n    auto result = 1;\n    for\
    \ (int i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;\n\
    \    */\n    import std.algorithm.comparison : max;\n    import std.algorithm.iteration\
    \ : filter;\n    import std.conv : to;\n    import std.range : iota;\n    import\
    \ std.math : pow;\n    // auto prime = iota(1, n).filter!(a => a.isPrime).array;\n\
    \    auto prime = iota(1, n).filter!(a => isPrime(a.to!uint)).array;\n    auto\
    \ num = n.to!uint;\n    auto remain = prime.map!(a => pow(a, n) / pow(a, num %\
    \ a)).max;\n    return reduce!\"a * b\"(iota(n, 1)) * remain;\n}\n/*\nThis kata\
    \ uses the concept of a \"Brazilian factorial\" - https://en.wikipedia.org/wiki/Factorial#Double_factorial\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuu5ewq2z.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuu5ewq2z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong result = 1;\n\tif (n > 0)\n\t{\n\t\tint l = to!int(n);\n\t\tforeach (i;\
    \ 0 .. l)\n\t\t{\n\t\t\tresult *= n--;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjmo5d2qc.d(21): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjmo5d2qc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long[] tab = new long[n];\n    long[] r = new long[n];\n    foreach(i; 0..n)\n\
    \    {\n        tab[i] = n-i;\n        r[i] = 1;\n    }\n    foreach(i; 0..n)\n\
    \    {\n        foreach(j; 0..n)\n        {\n            if(tab[j] % tab[i] ==\
    \ 0)\n            {\n                r[j] = r[j] * tab[i];\n                tab[j]\
    \ = tab[j] / tab[i];\n            }\n        }\n    }\n    return product(r);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn8jezqxx.d(36): Error: undefined identifier `product`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn8jezqxx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long brazilian_factorial(int n)\n    {\n        return n > 0 ? n * brazilian_factorial(n\
    \ - 1) : 1;\n    }\n    return brazilian_factorial(n) / brazilian_factorial(n\
    \ - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr3sxz9s_.d(22): Error: function `tmpr3sxz9s_.special_factorial.brazilian_factorial(int
    n)` is not callable using argument types `(long)`

    /tmp/tmpr3sxz9s_.d(22):        cannot pass argument `n` of type `long` to parameter
    `int n`

    /tmp/tmpr3sxz9s_.d(22): Error: function `tmpr3sxz9s_.special_factorial.brazilian_factorial(int
    n)` is not callable using argument types `(long)`

    /tmp/tmpr3sxz9s_.d(22):        cannot pass argument `n - 1L` of type `long` to
    parameter `int n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr3sxz9s_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = 1;\n    foreach(immutable i; 0..n) \n    {\n        res *= factorial(i);\n\
    \    }\n    return res;\n}\n/*\nFind the upper triangular matrix of order n given\
    \ a square matrix.\n    For example:\n    >>> upper_triangular([[2, 3, 5], [6,\
    \ 7, 8], [9, 10, 11]])\n    [[2, 3, 5], [0, 7, 8], [0, 0, 11]]\n    \n    The\
    \ function will receive a single argument as input. This argument will be\n  \
    \  a 2-dimensional array representing a square matrix. The function should\n \
    \   return an upper triangular matrix.\n*/\nlong[][] upper_triangular(long[][]\
    \ matrix) \n{\n    long[][] upper_matrix = new long[matrix.length][matrix.length];\n\
    \    foreach(immutable i; 0..matrix.length) \n    {\n        foreach(immutable\
    \ j; 0..matrix.length) \n        {\n            if(i <= j) \n            {\n \
    \               upper_matrix[i][j] = matrix[i][j];\n            }\n        }\n\
    \    }\n    return upper_matrix;\n}\n/*\nGiven a matrix, whose elements are either\
    \ 0 or 1, find the largest square\nsub-matrix consisting of only 1s.\n    For\
    \ example:\n    >>> largest_square([[1, 0, 1, 1, 1], [1, 0, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 0, 1, 1, 1]])\n    [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 0, 1, 1, 1]]\n    \n    The function will receive a single argument\
    \ as input. This argument will be\n    a 2-dimensional array representing a matrix.\
    \ The function should return the\n    largest square sub-matrix.\n*/\nlong[][]\
    \ largest_square(long[][] matrix) \n{\n    long[][] largest_square = new long[matrix.length][matrix.\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg4bo_plz.d(64): Error: identifier expected following `.`, not `unittest`

    /tmp/tmpg4bo_plz.d(65): Error: found `{` when expecting `]`

    /tmp/tmpg4bo_plz.d(66): Error: semicolon expected, not `alias`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg4bo_plz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong res = 1;\n\tfor (long i = n; i > 0; i--)\n\t{\n\t\tres *= i;\n\t}\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm_eddsyg.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpm_eddsyg.__unittest_L25_C1() [0x427a5a]

    ??:? void tmpm_eddsyg.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    static if (is(typeof(n) : unsigned))\n    {\n        return n > 1u ? n *\
    \ special_factorial(n - 1u) : 1u;\n    }\n    else\n    {\n        return n >\
    \ 1 ? n * special_factorial(n - 1) : 1;\n    }\n}\n/*\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvouz5x0s.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvouz5x0s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    auto factorials = lazy_factorials(n);\n    return foldl!\"a * b\"(1L, factorials);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3vm9uc3.d(18): Error: undefined identifier `lazy_factorials`

    /tmp/tmpk3vm9uc3.d(19): Error: template instance `foldl!"a * b"` template `foldl`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3vm9uc3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return 1;\n}\n \nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_yi72vm4.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d35]

    ??:? void tmp_yi72vm4.__unittest_L21_C1() [0x427a32]

    ??:? void tmp_yi72vm4.__modtest() [0x427ab8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa81]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa0d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8c5]

    ??:? runModuleUnitTests [0x42b831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428184]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    alias map = std.algorithm.map;\n    alias reduce = std.algorithm.reduce;\n\
    \    alias zip = std.algorithm.zip;\n    immutable int[] listOfNums = iota(n)\
    \ + 1;\n    immutable int[] backwardsListOfNums = reverse(listOfNums);\n    immutable\
    \ int[] listOfFactorials = map!(\n            (x) => reduce!((acc, j) => acc *\
    \ j)(1, iota(x) + 1)\n        )(listOfNums);\n    auto zippedList = zip(listOfFactorials,\
    \ backwardsListOfNums);\n    return reduce!((acc, i) => acc * i[0])(1, zippedList);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp77a_ecrz.d(18): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmp77a_ecrz.d(19): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp77a_ecrz.d(20): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp77a_ecrz.d(21): Error: undefined identifier `iota`

    /tmp/tmp77a_ecrz.d(22): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(immutable(int[]))`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmp77a_ecrz.d(23): Error: template instance `map!((x) => reduce!((acc, j)
    => acc * j)(1, iota(x) + 1))` `map` is not a template declaration, it is a alias

    /tmp/tmp77a_ecrz.d(27): Error: template instance `reduce!((acc, i) => acc * i[0])`
    `reduce` is not a template declaration, it is a alias

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp77a_ecrz.d"'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    int result = 1;\n    foreach(i;2..n)\n        result *= factorial(i);\n \
    \   return factorial(n) * result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8y60w677.d(20): Error: undefined identifier `factorial`

    /tmp/tmp8y60w677.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8y60w677.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long x = 1;\n    while(n>1)\n    {\n        x*=factorial(n);\n        n--;\n\
    \    }\n    return x;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj2gbrwdn.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj2gbrwdn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n) * factorial(n - 1) * factorial(n - 2);\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2wfph48f.d(18): Error: undefined identifier `factorial`

    /tmp/tmp2wfph48f.d(18): Error: undefined identifier `factorial`

    /tmp/tmp2wfph48f.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2wfph48f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163939
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.algorithm : reduce;\n    import std.range : iota;\n    return\
    \ n < 1 ? 1 : reduce!\"a * b\"(iota(1L, n + 1L));\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpapw8xrbb.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ce5]

    ??:? void tmpapw8xrbb.__unittest_L22_C1() [0x42860e]

    ??:? void tmpapw8xrbb.__modtest() [0x428c84]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4299a2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b3b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b444]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b341]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429979]

    ??:? runModuleUnitTests [0x42dfc5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a188]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163942
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return n * special_factorial(n - 1);\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163958
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tstatic foreach( i; 0 .. n + 1 )\n\t{\n\t\tif( i == 0 )\n\t\t\tstatic immutable\
    \ f = 1;\n\t\telse\n\t\t\tstatic immutable f = f * i;\n\t}\n\t\n\treturn f;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmakf2ca7.d(18): Error: variable `n` cannot be read at compile time

    /tmp/tmpmakf2ca7.d(18): Error: CTFE failed because of previous errors in `__lambda2`

    /tmp/tmpmakf2ca7.d(26): Error: undefined identifier `f`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmakf2ca7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return special_factorial_r(n, 1);\n}\nunittest\n{\n    alias candidate =\
    \ special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw02p744_.d(18): Error: undefined identifier `special_factorial_r`,
    did you mean function `special_factorial`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw02p744_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    /*\n    Use the BigInt class to hold the results of the multiplication of\
    \ factorials.\n    */\n    BigInt big_fact = 1;\n    foreach(i; 1..n)\n    {\n\
    \        big_fact *= factorial(i);\n    }\n    /*\n    The cast will not overflow\
    \ the long because:\n    The factorial function accepts a long as input, so the\
    \ result is lower than\n    it.\n    */\n    return big_fact.to!long;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv0ubtu2v.d(21): Error: undefined identifier `BigInt`

    /tmp/tmpv0ubtu2v.d(24): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv0ubtu2v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return n == 0L ? 1L : n * (n - 1L).special_factorial;\n}\nunittest\n{\n \
    \   alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphj6p6h00.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmphj6p6h00.__unittest_L20_C1() [0x427a62]

    ??:? void tmphj6p6h00.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return foldr!((a, b) => a * b)(1L, iota(1L, n+1));\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpggwnzdig.d(18): Error: template instance `foldr!((a, b) => a *
    b)` template `foldr` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpggwnzdig.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    auto r = 1L;\n    for (auto i = 1L; i <= n; i++)\n    {\n        r *= factorial(i);\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe0mm1w7c.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0mm1w7c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // Write your code here\n    if (n < 0) {\n        return -1;\n    }\n  \
    \  else if (n == 0) {\n        return 1;\n    }\n    else {\n        long result\
    \ = 1;\n        for (long i = n; i > 0; i--) {\n            result *= i;\n   \
    \     }\n        for (long i = n - 1; i > 0; i--) {\n            result *= i;\n\
    \        }\n        for (long i = n - 2; i > 0; i--) {\n            result *=\
    \ i;\n        }\n        return result;\n    }\n}\n/*\nThe following function\
    \ will receive an integer n and should return a tuple\ncontaining the two results\
    \ of the following calculation on this integer:\n    result1 = n * (n-1) * (n-2)\
    \ * ... * 2 * 1\n    result2 = n * (n-1) * (n-2) * ... * 2 * 1 +\n           \
    \   (n-1) * (n-2) * ... * 2 * 1 +\n              (n-2) * (n-3) * ... * 2 * 1 +\n\
    \              ...\n              1\n    \n*/\nTuple!(long, long) chinese_factorial(long\
    \ n) \n{\n    // Write your code here\n    long result1 = 1;\n    long result2\
    \ = 0;\n    for (long i = n; i > 0; i--) {\n        result1 *= i;\n        result2\
    \ += result1;\n    }\n    return tuple(result1, result2);\n}\nunittest\n{\n  \
    \  alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpximcoisv.d(66): unittest failure

    ----------------

    ??:? _d_unittestp [0x4289a5]

    ??:? void tmpximcoisv.__unittest_L61_C1() [0x428059]

    ??:? void tmpximcoisv.__modtest() [0x42840c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d2d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42c1e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b09]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430a95]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c1b9]

    ??:? runModuleUnitTests [0x42d0a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428df4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163942
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = n;\n    n--;\n    while(n > 0)\n    {\n        res *= n;\n   \
    \     n--;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyky7kdqe.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpyky7kdqe.__unittest_L27_C1() [0x427a5a]

    ??:? void tmpyky7kdqe.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163942
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for (long i = 1; i <= n; i++)\n    {\n        result\
    \ *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp55za4ej1.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmp55za4ej1.__unittest_L25_C1() [0x427a62]

    ??:? void tmp55za4ej1.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163942
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fac = 1;\n    foreach(i; 1 .. n + 1)\n    {\n        fac *= factorial(i);\n\
    \    }\n    return fac;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmposq0kg_n.d(21): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmposq0kg_n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return n;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n \
    \   assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n   \
    \ assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpldteewoi.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d35]

    ??:? void tmpldteewoi.__unittest_L20_C1() [0x427a32]

    ??:? void tmpldteewoi.__modtest() [0x427ab8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa81]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa0d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8c5]

    ??:? runModuleUnitTests [0x42b831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428184]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163942
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong fac = 1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfac *= i;\n\t}\n\t\n\
    \treturn fac;\n}\n/*\n    Now, let's write a function that receives a list of\
    \ integer and returns\n    a list of the special factorial for each integer in\
    \ the list.\n    \n    For example:\n    >>> special_factorial_list([1L, 2L, 3L])\n\
    \    [1L, 2L, 6L]\n    \n    The function will receive a list of integers as input\
    \ and should return a\n    list of the special factorial for each integer in the\
    \ list.\n    \n*/\nList!long special_factorial_list(List!long integers) \n{\n\t\
    List!long result;\n\tfor (int i = 0; i < integers.length; i++)\n\t{\n\t\tresult\
    \ ~= special_factorial(integers[i]);\n\t}\n\t\n\treturn result;\n}\n/*\n    Finally,\
    \ let's write a function that receives an integer and returns\n    a list of the\
    \ special factorial for each integer in range [1, n].\n    \n    For example:\n\
    \    >>> special_factorial_n(3L)\n    [1L, 2L, 6L]\n    \n    The function will\
    \ receive an integer as input and should return a list of\n    the special factorial\
    \ for each integer in range [1, n].\n*/\nList!long special_factorial_n(long n)\
    \ \n{\n\tList!long result;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tresult ~=\
    \ special_factorial(i);\n\t}\n\t\n\treturn result;\n}\n/*\n    Now, let's write\
    \ a function that receives a list of integer and returns\n    a list of the special\
    \ factorial for each integer in the list.\n    \n    For example:\n    >>> special_factorial_list([1L,\
    \ 2L, 3L])\n    [1L, 2L, 6L]\n    \n    The function will receive a list of integers\
    \ as input and should return a\n    list of the special factorial for each integer\
    \ in the list.\n    \n*/\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzq6k_x_4.d(38): Error: template instance `List!long` template `List`
    is not defined

    /tmp/tmpzq6k_x_4.d(38): Error: template instance `List!long` template `List` is
    not defined

    /tmp/tmpzq6k_x_4.d(59): Error: template instance `List!long` template `List` is
    not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzq6k_x_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tstatic if(is(typeof(factorial(1))) == is(long))\n\t{\n\t\tint primes = 0;\n\t\
    \tforeach(p; 0 .. int.max)\n\t\t{\n\t\t\tif(isPrime(p))\n\t\t\t\tprimes++;\n\t\
    \t\tif(primes == n)\n\t\t\t\treturn p;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(n < 1)\n\
    \t\t\treturn 1;\n\t\treturn n * special_factorial(n - 1);\n\t}\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpba8mu9jp.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpba8mu9jp.__unittest_L36_C1() [0x427a5a]

    ??:? void tmpba8mu9jp.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163942
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    struct Acc\n    {\n        long count;\n        long result;\n    }\n   \
    \ Acc accumulator;\n    accumulator.count = n;\n    accumulator.result = 1;\n\
    \    foreach(i; n-1L..0L)\n    {\n        accumulator.result *= accumulator.count;\n\
    \        accumulator.count -= 1;\n    }\n    return accumulator.result;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpx9y3sdxl.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428155]

    ??:? void tmpx9y3sdxl.__unittest_L33_C1() [0x427b3a]

    ??:? void tmpx9y3sdxl.__modtest() [0x427bc0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bfe7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aef6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43000d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4304bc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ff99]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aecd]

    ??:? runModuleUnitTests [0x42bdbd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4285a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163942
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    /*\n    Write your function here.\n    */\n    import std.math;\n    import\
    \ std.algorithm;\n    import std.typecons;\n    /*\n    The Brazilian factorial\
    \ is defined as:\n        brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ...\
    \ * 1!\n        where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk1vytqln.d(24): Error: unterminated /* */ comment

    /tmp/tmpk1vytqln.d(37): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk1vytqln.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // GCD doesn't work with negative numbers\n    if (n < 0)\n        n = -n;\n\
    \    \n    return n == 0 ? 1 : n * factorial(n - 1);\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgij3qrg2.d(22): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgij3qrg2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    import std.algorithm;\n    import std.range;\n    import std.stdio;\n   \
    \ import std.range;\n    static if (n <= 0)\n    {\n        return 1;\n    }\n\
    \    else\n    {\n        return n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiaidncgf.d(29): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpiaidncgf.d(38): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpiaidncgf.d(38): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiaidncgf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif (n <= 1)\n\t\treturn 1;\n\t\t\n\treturn n * special_factorial(n - 1);\n}\n\
    /*\nImplement a function that receives an integer as input and returns the\nsum\
    \ of all the \"special prime\" factors of this integer.\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv35qklo6.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv35qklo6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    assert(n > 0);\n    return n * (n - 1) * (n - 2);\n}\n/*\nYou have received\
    \ a string as input, but you don't know if it is a palindrome.\nA palindrome is\
    \ a word that is spelt the same both forwards and backwards.\nIn other words,\
    \ a palindrome is a string that is read the same way in either\ndirection. You\
    \ are to write a function that returns true if the string is a\npalindrome, and\
    \ false otherwise.\nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk_nat4bd.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_nat4bd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 1) {\n        return 0;\n    }\n    long ret = 1;\n    foreach (i;\
    \ 0 .. n) {\n        ret *= factorial(i);\n    }\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf8n1emk0.d(23): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf8n1emk0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  if (n == 0) \n  {\n    return 1;\n  }\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp63htjhaj.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp63htjhaj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163941
