name: HumanEval_78_hex_key
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYou have been tasked to write\
  \ a function that receives \n    a hexadecimal number as a string and counts the\
  \ number of hexadecimal \n    digits that are primes (prime number, or a prime,\
  \ is a natural number \n    greater than 1 that is not a product of two smaller\
  \ natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
  \ B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have\
  \ to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11),\
  \ D (=decimal 13).\n    Note: you may assume the input is always correct or empty\
  \ string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n \
  \   >>> hex_key(\"AB\")\n    1L\n    >>> hex_key(\"1077E\")\n    2L\n    >>> hex_key(\"\
  ABED1A33\")\n    4L\n    >>> hex_key(\"123456789ABCDEF0\")\n    6L\n    >>> hex_key(\"\
  2020\")\n    2L\n    \n*/\nlong hex_key(string num) \n"
tests: "unittest\n{\n    alias candidate = hex_key;\n\n    assert(candidate(\"AB\"\
  ) == 1L);\n    assert(candidate(\"1077E\") == 2L);\n    assert(candidate(\"ABED1A33\"\
  ) == 4L);\n    assert(candidate(\"2020\") == 2L);\n    assert(candidate(\"123456789ABCDEF0\"\
  ) == 6L);\n    assert(candidate(\"112233445566778899AABBCCDDEEFF00\") == 12L);\n\
  }\nvoid main(){}"
completions: ["{\n\t/*My solution 1*/\n\tint count=0;\n\tint n;\n\tbool isPrime;\n\
    \tif(num.length!=0)\n\t{\n\t\tfor(int i=0;i<num.length;i++)\n\t\t{\n\t\t\tif(num[i]=='A'||num[i]=='B'||num[i]=='D'||num[i]=='F')\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tn=num[i].to!int;\n\
    \t\t\t\tisPrime=true;\n\t\t\t\tfor(int j=2;j<=int(sqrt(n));j++)\n\t\t\t\t{\n\t\
    \t\t\t\tif(n%j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tisPrime=false;\n\t\t\t\t\t\tbreak;\n\
    \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(isPrime)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\
    \t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\t/*My solution 2\n\tint count=0;\n\
    \tint n;\n\tif(num.length!=0)\n\t{\n\t\tfor(int i=0;i<num.length;i++)\n\t\t{\n\
    \t\t\tn=num[i].to!int;\n\t\t\tif(n==2||n==3||n==5||n==7||n==11||n==13)\n\t\t\t\
    {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\t*/\n}", "{\n    long\
    \ cnt = 0;\n    foreach(char c; num)\n    {\n        cnt += uppercase(c) in ['2',\
    \ '3', '5', '7', 'B', 'D'];\n    }\n    return cnt;\n}", "{\n    import std.bitmanip;\n\
    \    import std.conv;\n    import std.range;\n    import std.math;\n    import\
    \ std.typecons;\n    import std.algorithm;\n    import std.array;\n    if (num.length\
    \ == 0) \n    {\n        return 0;\n    }\n    auto int_array = num.array;\n \
    \   auto int_tuple = tuple(int_array);\n    auto int_list = int_tuple.map!(a =>\
    \ (a >= 'A' && a <= 'F') ? a - 'A' + 10 : a - '0').array;\n    auto int_sum =\
    \ int_list.sum;\n    auto is_prime = true;\n    for (int i = 2; i < int_sum; i++)\
    \ \n    {\n        if (int_sum % i == 0) \n        {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    return is_prime ? 1 : 0;\n}", "{\n\
    \    long res = 0;\n    foreach(inout ch; num) {\n        ch = toUpper(ch);\n\
    \        int val = (ch <= '9') ? ch - '0' : ch - 'A' + 10;\n        if(val ==\
    \ 2 || val == 3 || val == 5 || val == 7 || val == 11 || val == 13) {\n       \
    \     res++;\n        }\n    }\n    return res;\n}", "{\n    enum hex_digits =\
    \ \"0123456789ABCDEF\";\n    long r = 0;\n    int sz = num.length;\n    for (int\
    \ i = 0; i < sz; i++)\n    {\n        if (binaryFinder!(hex_digits, num[i]).isNaN)\n\
    \        {\n            int curr = to!int(num[i]);\n            if (curr % 2 ==\
    \ 0 || curr % 3 == 0 || curr % 5 == 0 || curr % 7 == 0 ||\n                curr\
    \ % 11 == 0 || curr % 13 == 0)\n            {\n                r++;\n        \
    \    }\n        }\n    }\n    return r;\n}", "{\n    long count = 0;\n    string\
    \ hex = num;\n    bool isHexPrime = false;\n    string[] primes = [\"2\", \"3\"\
    , \"5\", \"7\", \"B\", \"D\"];\n    for (int i = 0; i < num.length; i++)\n   \
    \ {\n        for (int j = 0; j < primes.length; j++)\n        {\n            if\
    \ (num[i] == primes[j][0])\n            {\n                count++;\n        \
    \    }\n        }\n    }\n    return count;\n}", "{\n    long count = 0;\n   \
    \ string prim = \"2357BDC\";\n    foreach( elem; num)\n    {\n        foreach(\
    \ prime; prim)\n        {\n            if(elem == prime)\n            {\n    \
    \            count++;\n            }\n        }\n    }\n    return count;\n}\n\
    \ ", "{\n    long count=0;\n    if(num==\"\")\n        return 0;\n    foreach(immutable\
    \ element;num)\n    {\n        auto temp=element;\n        if(temp in \"0123456789\"\
    )\n            temp-=48;\n        else\n            temp-=55;\n        if(temp==2||temp==3||temp==5||temp==7||temp==11||temp==13)\n\
    \            count++;\n    }\n    return count;\n}", "{\n  int ret = 0;\n  foreach(immutable\
    \ char ch; num) {\n    switch(ch) {\n    case 'A': case 'B': case 'D': case '2':\
    \ case '3': case '5': case '7':\n      ret++;\n      break;\n    }\n  }\n  return\
    \ ret;\n}", "{\n    long res = 0;\n    long [] primes = {\n        2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,\
    \ 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,\
    \ 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353,\
    \ 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449,\
    \ 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\
    \ 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653,\
    \ 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\
    \ 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,\
    \ 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991,\
    \ 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069,\
    \ 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171,\
    \ 1181,", "{\n    long const HEX_PRIMES = 0xAFu;\n    bool hex_is_prime(long hex)\
    \ { return (HEX_PRIMES >> hex) & 1; }\n    return count!(hex_is_prime)(num.retro);\n\
    }", "{\n    long result = 0;\n    for (i, c; num) \n    {\n        if (isPrimes(i))\
    \ \n        {\n            result++;\n        }\n    }\n    return result;\n}",
  "{\n    //check if empty\n    if(num.empty) return 0;\n    string hex_digits = \"\
    0123456789ABCDEF\";\n    long count = 0;\n    ulong[] primes = [2,3,5,7,11,13];\n\
    \    for(ulong x : num)\n    {\n        if(primes.find(hex_digits.indexOf(x)))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long cnt = 0;\n    string c_hex = \"023456789ABCDEF\";\n    string c_prime\
    \ = \"2357BD\";\n    foreach(x; num) \n    {\n        if(c_prime.canFind(x)) cnt++;\n\
    \    }\n    return cnt;\n}", "{\n    string[] primes = [\"2\", \"3\", \"5\", \"\
    7\", \"B\", \"D\"];\n    return num.count!(i => i in primes);\n}", "{\n    long\
    \ count = 0;\n    bool flag = false;\n    foreach(i; num){\n        if( i == '2'\
    \ ){\n            flag = true;\n        }\n        else if( i == '3' ){\n    \
    \        flag = true;\n        }\n        else if( i == '5' ){\n            flag\
    \ = true;\n        }\n        else if( i == '7' ){\n            flag = true;\n\
    \        }\n        else if( i == 'B' ){\n            flag = true;\n        }\n\
    \        else if( i == 'D' ){\n            flag = true;\n        }\n        else\
    \ if( i == 'F' ){\n            flag = true;\n        }\n        else {\n     \
    \       flag = false;\n        }\n        if(flag){\n            count++;\n  \
    \      }\n    }\n    return count;\n}", "{\n    long result = 0;\n    // What\
    \ if string is empty\n    if (num == \"\") return result;\n    // Put each char\
    \ into an array\n    // Split array into two digits\n    // Put two digits into\
    \ a tuple\n    // Put tuple in an array\n    // For each tuple in array find the\
    \ sum of the two digits\n    // If the sum is in prime and the sum is less than\
    \ 16 then add one to result\n    string[] big_split = num.split(\"\");\n    string[]\
    \ small_split = big_split.splitter(2);\n    int[] temp = new int[small_split.length];\n\
    \    foreach(i,j; small_split)\n    {\n        foreach(letter; j)\n        {\n\
    \            temp[i] += atoi(letter);\n        }\n    }\n    // Remove all duplicates\
    \ from array\n    string[] two_digits = temp.sort.uniq;\n    foreach(j; two_digits)\n\
    \    {\n        if(j <= 16 && isPrime(j)) result++;\n    }\n    return result;\n\
    }\n// Prime number check", "{ \n    // your code here\n    long _answer=0;\n \
    \   string _num = num;\n    int _num_size = num.length;\n    long[] _prime_numbers\
    \ = {2,3,5,7,11,13};\n    string[] _hex_numbers = {\"0\",\"1\",\"2\",\"3\",\"\
    4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"};\n    int\
    \ _i=0;\n    int _j=0;\n    int _prime_number_length = _prime_numbers.length;\n\
    \    while(_i<_num_size)\n    {\n        _j=0;\n        while(_j<_prime_number_length)\n\
    \        {\n            if(_hex_numbers[_i]==_prime_numbers[_j])\n           \
    \ {\n                _answer++;\n            }\n            _j++;\n        }\n\
    \        _i++;\n    }\n    return _answer;\n}\nlong hex_key2(string num) \n{ \n\
    \    // your code here\n    long _answer=0;\n    string _num = num;\n    int _num_size\
    \ = num.length;\n    long[] _prime_numbers = {2,3,5,7,11,13};\n    string[] _hex_numbers\
    \ = {\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"\
    C\",\"D\",\"E\",\"F\"};\n    int _i=0;\n    int _j=0;\n    int _prime_number_length\
    \ = _prime_numbers.length;\n    int _prime_number=0;\n    while(_i<_num_size)\n\
    \    {\n        _j=0;\n        while(_j<_prime_number_length)\n        {\n   \
    \         if(_hex_numbers[_i]==_prime_numbers[_j])\n            {\n          \
    \      _answer++;\n            }\n            _j++;\n        }\n        _i++;\n\
    \    }\n    return _answer;\n}\nlong hex_key3(string num) \n{ \n    // your code\
    \ here\n    long _answer=0;\n    string", "{\n    static bool[char] primes = ['2':true,\
    \ '3':true, '5':true, '7':true, 'B':true, 'D':true];\n    size_t res = 0;\n  \
    \  foreach(i; num)\n        if(primes[i])\n            res++;\n    return res;\n\
    }", "{\n    string hex = \"0123456789ABCDEF\";\n    long count = 0;\n    for (size_t\
    \ i = 0; i < num.length; i++)\n    {\n        if(hex[num[i]] <= '7' && num[i]\
    \ != '0')\n        {\n            count++;\n        }\n        else if (num[i]\
    \ == 'A' || num[i] == 'B' || num[i] == 'D')\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\nYou have been tasked to write a function\
    \ that receives \n    a string that can be a roman or arabic numeral (or both\
    \ mixed) \n    and returns a string with the arabic numbers replaced by their\
    \ \n    roman equivalent and the roman numbers replaced by their arabic \n   \
    \ equivalent. Return the new string with the converted numbers.\n    Note: The\
    \ roman numerals in your output should be in uppercase.\n    Examples:\n    >>>\
    \ numeral_mix(\"XXI\")\n    \"21\"\n    >>> numeral_mix(\"IVXLCDM\")\n    \"4,9,40,50,100,500,1000\"\
    \n    >>> numeral_mix(\"MDCLXVI\")\n    \"1666\"\n    >>> numeral_mix(\"MMVIII\"\
    )\n    \"2008\"\n    >>> numeral_mix(\"C\")\n    \"100\"\n*/\nstring numeral_mix(string\
    \ num)\n{\n    return num;\n}\n/*\nYou have been tasked to write a function that\
    \ validates \n    an username with the following rules:\n    - The username is\
    \ between 4 and 25 characters, inclusive.\n    - The username can only contain\
    \ alphanumeric characters and underscores.\n    - The first character of the username\
    \ must be an alphabetic character, \n    i.e., either lowercase character, uppercase\
    \ character, or digits \n    are not allowed as the first character of an username.\n\
    \    - The username must not contain three same consecutive characters \n    (e.g.,\
    \ \"...aaa...\" is invalid, \"...eee...\" is invalid, but \n    \"...eeeo...\"\
    \ is permissible).\n    - The username must not contain two consecutive underscores\
    \ (", "{\n    return num.filter!(x => \"2357BD\".canFind(x)).length;\n}", "{\n\
    \    long cnt = 0;\n    static int[] primes = [2, 3, 5, 7, 11, 13];\n    static\
    \ Map!string map = [\"2\":2, \"3\":3, \"5\":5, \"7\":7, \"B\":11, \"D\":13];\n\
    \    foreach(ch; num) \n    {\n        if(map.count(ch)) cnt++;\n    }\n    return\
    \ cnt;\n}", "{ \n    int primes[] = { 2, 3, 5, 7, 11, 13 };\n    string[] hex_digits\
    \ = split(\"0123456789ABCDEF\");\n    string[] hex_primes = split(\"2357BD\");\n\
    \    int count = 0;\n    foreach(char c; num)\n    {\n        foreach(string s;\
    \ hex_primes)\n        {\n            if(c == s[0])\n            {\n         \
    \       count++;\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    const char primes[] = \"2357BD\";\n    auto primeset = bitset!(char).fromString(primes);\n\
    \    long result = 0;\n    foreach(c;num){\n        if(primeset[c]){\n       \
    \     result++;\n        }\n    }\n    return result;\n}\n/*\nYou are given a\
    \ sequence of non-negative integers, sorted in ascending order. \n    You should\
    \ find the smallest positive integer, that is not included in the given sequence.\n\
    \    Examples:\n    >>> find_missing_number([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\
    \    11L\n    >>> find_missing_number([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12])\n\
    \    11L\n    >>> find_missing_number([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11])\n  \
    \  10L\n    >>> find_missing_number([])\n    0L\n    >>> find_missing_number([1])\n\
    \    0L\n    >>> find_missing_number([0])\n    1L\n    >>> find_missing_number([0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,\
    \ 115", "{\n    import std.string;\n    long n = 0;\n    foreach(e; num) \n  \
    \  {\n        if(e == '2' || e == '3' || e == '5' || e == '7' || e == 'B' || e\
    \ == 'D')\n            n++;\n    }\n    return n;\n}", "{\n    long result = 0;\n\
    \    long len = num.length;\n    long[] hexArr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11, 12, 13, 14, 15];\n    long[] hexStr = [\"0\", \"1\", \"2\", \"3\", \"\
    4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"\
    F\"];\n    for (int i = 0; i < len; i++)\n    {\n        if (std.array.find(hexStr,\
    \ num[i]) == -1)\n        {\n            return result;\n        }\n    }\n  \
    \  foreach (i; hexArr)\n    {\n        if (num.find(hexStr[i]) != -1)\n      \
    \  {\n            bool isPrime = true;\n            long factor = 2;\n       \
    \     while (factor < i / 2 + 1)\n            {\n                if (i % factor\
    \ == 0)\n                {\n                    isPrime = false;\n           \
    \         break;\n                }\n                factor++;\n            }\n\
    \            if (isPrime)\n            {\n                result++;\n        \
    \    }\n        }\n    }\n    return result;\n}", "{\n    long result = 0;\n \
    \   if(num.length > 0)\n    {\n        const(char)[] hexa = [\n            '0',\
    \ '1', '2', '3', '4', '5', '6', '7', '8', '9',\n            'A', 'B', 'C', 'D',\
    \ 'E', 'F'\n        ];\n        const(long)[] primes = [2, 3, 5, 7, 11, 13];\n\
    \        for(char c : num)\n        {\n            foreach(idx, hex; hexa)\n \
    \           {\n                if(c == hex)\n                {\n             \
    \       foreach(idxP, prime; primes)\n                    {\n                \
    \        if(idx == prime)\n                        {\n                       \
    \     result++;\n                        }\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\n/*\n    You\
    \ have to write a function that receives a list and returns \n    a list of lists\
    \ such that each list contains the elements of the \n    original list that appear\
    \ in the same position.\n    Example:\n    >>> same_position([1, 2, 3, 4, 5],\
    \ ['a', 'b', 'c', 'd', 'e'])\n    [[1, 'a'], [2, 'b'], [3, 'c'], [4, 'd'], [5,\
    \ 'e']]\n*/\nauto same_position(T)(T list) \n{\n    auto result = list[0].array();\n\
    \    foreach(idx, e; list)\n    {\n        result ~= tuple(e, list[idx]);\n  \
    \  }\n    return result;\n}", "{\n    long res = 0;\n    return num.count!(b =>\
    \ (b >= '2' && b <= '7') || b == 'B' || b == 'D' || b == 'F');\n}\nstatic assert(hex_key(\"\
    AB\") == 1);\nstatic assert(hex_key(\"1077E\") == 2);\nstatic assert(hex_key(\"\
    ABED1A33\") == 4);\nstatic assert(hex_key(\"123456789ABCDEF0\") == 6);\nstatic\
    \ assert(hex_key(\"2020\") == 2);", "{\n    auto digits = num.map!(x => \"0123456789ABCDEF\"\
    .indexOf(x));\n    long count = 0;\n    foreach(i; digits) \n    {\n        if\
    \ (i < 10)\n        {\n            count += i % 2 && i % 3 && i % 5 && i % 7 ?\
    \ 1 : 0;\n        }\n        else \n        {\n            count += (i == 11 ||\
    \ i == 13) ? 1 : 0;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    auto prime_list = [2, 3, 5, 7, 11, 13];\n    auto hex_list = [\"2\"\
    , \"3\", \"5\", \"7\", \"B\", \"D\"];\n    foreach(i; hex_list)\n    {\n     \
    \   count += num.count(i);\n    }\n    return count;\n}", "{\n\tlong cnt = 0;\n\
    \tforeach(d; num) \n\t{\n\t\tcnt += [2, 3, 5, 7, 11, 13].canFind(hexToInt(d));\n\
    \t}\n\treturn cnt;\n}\n/*\nWrite a function that takes a list of strings and returns\
    \ the \n    longest string from it. In case of tie, the function should \n   \
    \ return the one which appears first in the list.\n    Examples:\n    >>> find_longest([\"\
    A\", \"BB\", \"CCC\"])\n    \"CCC\"\n    >>> find_longest([\"A\", \"BB\", \"C\"\
    ])\n    \"BB\"\n    >>> find_longest([\"A\", \"BB\", \"C\", \"DDDD\"])\n    \"\
    DDDD\"\n    >>> find_longest([\"AAAA\", \"C\"])\n    \"AAAA\"\n*/\nstring find_longest(string[]\
    \ arr)\n{\n\tstring best = \"\";\n\tforeach(s; arr) \n\t{\n\t\tif(s.length > best.length)\
    \ \n\t\t{\n\t\t\tbest = s;\n\t\t}\n\t}\n\treturn best;\n}\n/*\nWrite a function\
    \ that takes one parameter: an integer, \n    and returns an array of all prime\
    \ numbers that are \n    less than or equal to the given number.\n    Example:\n\
    \    >>> get_primes(10)\n    [2, 3, 5, 7]\n    >>> get_primes(15)\n    [2, 3,\
    \ 5, 7, 11, 13]\n    >>> get_primes(0)\n    []\n    >>> get_primes(1)\n    []\n\
    */\nlong[] get_primes(long n) \n{\n\tlong[] primes = [2];\n\tbool isPrime;\n\t\
    foreach(i; 3..n+1) \n\t{\n\t\tisPrime = true;\n\t\tforeach(p; primes) \n\t\t{\n\
    \t\t\tif(i % p == 0) \n\t\t\t{\n\t\t\t\tisPrime = false;\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n", "{\n    //long hexValue = 10;\n    long primes = 0;\n    long size\
    \ = num.length;\n    //string[] numbers = new string[size];\n    foreach(i;0..size)\n\
    \    {\n        if(num[i] == 'A' || num[i] == 'B' || num[i] == 'D' || num[i] ==\
    \ '2' || num[i] == '3' || num[i] == '5' || num[i] == '7')\n        {\n       \
    \     primes++;\n        }\n    }\n    return primes;\n}", "{\n    size_t count\
    \ = 0;\n    auto primes = [](in string s)\n    {\n        return any!(is_prime,\
    \ s.map!(a => int(a, 16)));\n    };\n    if(num.empty)\n        return 0;\n  \
    \  else\n        return count = num.map!(a => int(a, 16)).filter!(a => a == 2\
    \ || a == 3 || a == 5 || a == 7 || a == 11 || a == 13).length;\n}\n/*\nstatic\
    \ assert(hex_key(\"2020\") == 2);\nstatic assert(hex_key(\"AB\") == 1);\nstatic\
    \ assert(hex_key(\"1077E\") == 2);\nstatic assert(hex_key(\"ABED1A33\") == 4);\n\
    static assert(hex_key(\"123456789ABCDEF0\") == 6);\n*/\n/*\nYou have been tasked\
    \ to write a function that receives \n    a hexadecimal number as a string and\
    \ counts the number of hexadecimal \n    digits that are primes (prime number,\
    \ or a prime, is a natural number \n    greater than 1 that is not a product of\
    \ two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n\
    \    So you have to determine a number of the following digits: 2, 3, 5, 7, \n\
    \    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is\
    \ always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n\
    \    Examples:\n    >>> hex_key(\"AB\")\n    1L\n    >>> hex_key(\"1077E\")\n\
    \    2L\n    >>> hex_key(\"ABED1A33\")\n    4L\n    >>> hex_key(\"123456789ABCDEF0\"\
    )\n    6L\n    >>> hex_key(\"2020\")\n    2L\n    \n*/\nlong hex_key2(string num)\
    \ \n{\n    size_t count = 0", "{\n    /*\n    long result = 0;\n    if(num.empty)\n\
    \        return result;\n    auto primenum = [](size_t num){\n            size_t\
    \ result = 0;\n            bool isprime = true;\n            foreach(i; 2..num)\n\
    \            {\n                if(num % i == 0)\n                {\n        \
    \            isprime = false;\n                    break;\n                }\n\
    \            }\n            if(isprime)\n                result = num;\n     \
    \       return result;\n    };\n    size_t len = num.length;\n    foreach(i; 0..len)\n\
    \    {\n        char c = num[i];\n        if(c == 'A' || c == 'B' || c == 'D'\
    \ || c == 'E')\n            result++;\n        else if(c == 'C' || c == 'F')\n\
    \            continue;\n        else\n        {\n            if(primenum(c.to!size_t))\n\
    \                result++;\n        }\n    }\n    return result;\n    */\n   \
    \ import std.algorithm;\n    import std.array;\n    import std.conv;\n    import\
    \ std.range;\n    import std.typecons;\n    import std.math;\n    return num.filter!(x\
    \ => \n        x.to!ulong == 2 || x.to!ulong == 3 || x.to!ulong == 5 || x.to!ulong\
    \ == 7 || \n        x.to!ulong == 11 || x.to!ulong == 13).length;\n}", "{\n  \
    \  long res = 0;\n    foreach(immutable char c; num)\n    {\n        switch(c)\n\
    \        {\n            case '2':\n            case '3':\n            case '5':\n\
    \            case '7':\n            case 'B':\n            case 'D': res++; break;\n\
    \        }\n    }\n    return res;\n}", "{\n    long primes = 0;\n    long nums\
    \ = 0;\n    long nums2 = 0;\n    long res = 0;\n    long len = num.length;\n \
    \   long[] nums_arr = new long[len];\n    long[] nums_arr2 = new long[len];\n\
    \    for (int i = 0; i < len; i++)\n    {\n        char c = num[i];\n        switch\
    \ (c)\n        {\n            case '2':\n                primes++;\n         \
    \       break;\n            case '3':\n                primes++;\n           \
    \     break;\n            case '5':\n                primes++;\n             \
    \   break;\n            case '7':\n                primes++;\n               \
    \ break;\n            case 'B':\n                primes++;\n                break;\n\
    \            case 'D':\n                primes++;\n                break;\n  \
    \          case 'F':\n                break;\n            default:\n         \
    \       nums = c.to!int - 48;\n                nums_arr[i] = nums;\n         \
    \       nums2 = nums.pow(2);\n                nums_arr2[i] = nums2;\n        \
    \        res = nums_arr[i] - nums_arr2[i];\n                primes += (isPrime(res));\n\
    \                break;\n        }\n    }\n    return primes;\n}", "{\n  long\
    \ counter=0;\n  auto s = num.length;\n  immutable digits=[\"0\",\"1\",\"2\",\"\
    3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"];\n\
    \  for(long i=0;i<s;i++)\n  {\n    if(digits[11]==num[i]||digits[13]==num[i]||digits[17]==num[i]||digits[19]==num[i]||digits[11]==num[i]||digits[13]==num[i])\n\
    \    {\n      counter++;\n    }\n  }\n  return counter;\n}", "{\n    long out;\n\
    \    inout (long, int) pair;\n    // bool isHexDigit(char c)\n    bool isHexDigit(char\
    \ c)\n    {\n        if ((c >= '0' && c <= '9') ||\n            (c >= 'A' && c\
    \ <= 'F')) {\n            return true;\n        }\n        return false;\n   \
    \ }\n    // bool isPrime(long num)\n    bool isPrime(long num)\n    {\n      \
    \  if (num <= 1) {\n            return false;\n        }\n        if (num <= 3)\
    \ {\n            return true;\n        }\n        if (num % 2 == 0 || num % 3\
    \ == 0) {\n            return false;\n        }\n        long i = 5;\n       \
    \ while (i * i <= num) {\n            if (num % i == 0 || num % (i + 2) == 0)\
    \ {\n                return false;\n            }\n            i = i + 6;\n  \
    \      }\n        return true;\n    }\n    // inout (long, int) hexToLong(char\
    \ hex)\n    inout (long, int) hexToLong(char hex)\n    {\n        if (hex >= '0'\
    \ && hex <= '9') {\n            return pair(hex - '0', 1);\n        }\n      \
    \  if (hex >= 'A' && hex <= 'F') {\n            return pair(hex - 'A' + 10, 1);\n\
    \        }\n        return pair(0, 0);\n    }\n    // // long getDigit(long num,\
    \ long pos)\n    // long getDigit(long num, long pos)\n    // {\n    //     return\
    \ (num / pow(10, pos)) % 10;\n    // }\n    // // long getDigitToPos(long num,\
    \ long pos)\n    // long getDigitToPos(long num, long pos)\n    // {\n    // \
    \    return num % pow(10, pos);\n    // }\n    // // long getDigitToPos(long num,\
    \ long pos)\n    // long getDigitFromPos(long num, long pos)\n    // {\n    //\
    \     return num / pow(10, pos);", "{\n    int result = 0;\n    foreach(char c;\
    \ num)\n    {\n        if (in(c, '0', '7') || in(c, 'B', 'F'))\n            result++;\n\
    \    }\n    return result;\n}\n/*\nNeutralizing Agents: A chemical factory is\
    \ being attacked by terrorists. \n    You are in charge of calculating how much\
    \ neutralizing agent is needed \n    to neutralize all terrorists.\n    You have\
    \ at your disposal several types of neutralizing agents. \n    Every type of neutralizing\
    \ agent has a certain strength and also a \n    certain price.\n    You are given\
    \ a list of terrorists and a list of neutralizing agents. \n    When you use neutralizing\
    \ agent against terrorist you get the \n    neutralization strength of the chosen\
    \ neutralizing agent. \n    The total neutralization strength you get is the sum\
    \ of the neutralization \n    strengths of all neutralizing agents you used.\n\
    \    Terrorists can be neutralized only with a neutralization strength \n    equal\
    \ to their strength. \n    If some of the neutralizing agents used do not reach\
    \ the required \n    neutralization strength, the ones that reach it are used\
    \ and the \n    others remain unused.\n    You have to neutralize all terrorists,\
    \ using as few neutralizing \n    agents as possible and with minimal cost. You\
    \ have to return a \n    tuple (list, integer), where the list is the sequence\
    \ of the \n    neutralizing agents you used, and the integer is the total cost\
    \ \n    of the neutralizing agents you used.\n    You are given the following:\n\
    \    List of terrorists with their strengths.\n    List of neutralizing agents\
    \ with their strengths and prices.\n    Example:\n    >>> neutralize([(400, 25),\
    \ (900, 30), (1200, 20)], [(100, 5), (200, 10), (300, 15), (400, 20), (500, 25),\
    \ (600, 30), (700, 35), (800, 40), (900, 45), (1000, 50)])\n    ([(500, 25), (500,\
    \ 25), (500, 25), (200, 10), (200, 10)], 155)\n    \n    >>> neutralize([(100,\
    \ 20), (100, 20), (100, 20), (100", "{\n    long hexToDec[] = [0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n    string hexDigits = \"0123456789ABCDEF\"\
    ;\n    enum hexDigitsLen = hexDigits.length;\n    long primeCount = 0;\n    long\
    \ index = 0;\n    foreach(chr; num)\n    {\n        if(binarySearch(hexDigits,\
    \ chr))\n        {\n            index = hexDigits.indexOf(chr);\n            if(isPrime(hexToDec[index]))\n\
    \            {\n                primeCount++;\n            }\n        }\n    }\n\
    \    return primeCount;\n}", "{\n\tlong result=0;\n\tlong last;\n\tchar c;\n\t\
    if(num.length==0)\n\t\treturn 0;\n\telse\n\t{\n\t\tforeach(c;num)\n\t\t{\n\t\t\
    \tif(c>='A' && c<='F')\n\t\t\t\tlast=c-'A'+10;\n\t\t\telse\n\t\t\t\tlast=c-'0';\n\
    \t\t\tif(last==2 || last==3 || last==5 || last==7 || last==11 || last==13)\n\t\
    \t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n}", "{\n    alias isPrime = isPrime!\"\
    int\";\n    import std.format;\n    int count = 0;\n    foreach(i; num)\n    {\n\
    \        int n = format(\"%02x\", to!int(i)).to!int(16);\n        if(isPrime(n))\n\
    \            count++;\n    }\n    return count;\n}", "{\n\t// long[] primes =\
    \ [2, 3, 5, 7, 11, 13]; // 2, 3, 5, 7, B, D\n\tlong[] primes = [2, 3, 5, 7, 11,\
    \ 13];\n\tlong[] hex = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"\
    , \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n\t// long[] binary\
    \ = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"];\n\t\n\tlong cnt = 0;\n\tforeach(i;\
    \ num)\n\t{\n\t\tlong j = 0;\n\t\tforeach(item; primes)\n\t\t{\n\t\t\tif(binary[j]\
    \ == i)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\treturn cnt;\n\
    }", "{\n    uint64_t base = 16;\n    uint64_t hex_digits = 0;\n    uint64_t num_primes\
    \ = 0;\n    int[16] hex_to_dec = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\n  \
    \  bool[16] prime_hex = [false,false,true,true,false,true,false,true,false,false,true,true,false,true,false,false];\n\
    \    uint64_t[] primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,",
  "{\n    long result = 0;\n    long primes[] = [2, 3, 5, 7, 11, 13];\n    ubyte hexnums[]\
    \ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n    string hex_digits\
    \ = \"0123456789ABCDEF\";\n    ubyte hex_digits_len = hex_digits.length;\n   \
    \ long num_len = num.length;\n    for (int i = 0; i < num_len; i++)\n    {\n \
    \       for (int j = 0; j < hex_digits_len; j++)\n        {\n            if (num[i]\
    \ == hex_digits[j])\n            {\n                for (int k = 0; k < primes.length;\
    \ k++)\n                {\n                    if (hexnums[j] == primes[k])\n\
    \                    {\n                        result += 1;\n               \
    \     }\n                }\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    int[] primes = [2, 3, 5, 7, 11, 13];\n    int[] hex = [0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n    auto isPrime = (n) => n.find\
    \ !(i => (n % i == 0) || (n / i == 1)) == n.length;\n    return num.toupper().chunks(1)\n\
    \        .map!(hex[])\n        .filter!(isPrime)\n        .length;\n}", "{\n \
    \   long count = 0;\n    uint radix = 16;\n    foreach(c; num)\n    {\n      \
    \  if(c in \"ABCDEF\")\n        {\n            if(isPrime(parse!long(c, radix)))\n\
    \                count++;\n        }\n        else\n        {\n            long\
    \ d = parse!long(c, radix);\n            if(d < 10 && isPrime(d))\n          \
    \      count++;\n        }\n    }\n    return count;\n}", "{\n    static string\
    \ hex = \"0123456789ABCDEF\";\n    static bool[] is_prime = new bool[16];\n  \
    \  static bool is_inited = false;\n    if (!is_inited)\n    {\n        is_inited\
    \ = true;\n        //initialize the is_prime array\n        is_prime[0] = false;\n\
    \        is_prime[1] = false;\n        is_prime[2] = true;\n        is_prime[3]\
    \ = true;\n        is_prime[4] = false;\n        is_prime[5] = true;\n       \
    \ is_prime[6] = false;\n        is_prime[7] = true;\n        is_prime[8] = false;\n\
    \        is_prime[9] = false;\n        is_prime[10] = false;\n        is_prime[11]\
    \ = true;\n        is_prime[12] = false;\n        is_prime[13] = true;\n     \
    \   is_prime[14] = false;\n        is_prime[15] = false;\n    }\n    long result\
    \ = 0;\n    foreach(i; 0..num.length)\n    {\n        if (is_prime[hex.indexOf(num[i])])\n\
    \        {\n            result++;\n        }\n    }\n    return result;\n}\n//A\
    \ but back to the previous example\n// Try to change the for index variable to\
    \ lowercase\n/*\nYou have been tasked to write a function that receives \n   \
    \ a hexadecimal number as a string and counts the number of hexadecimal \n   \
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal\
    \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers\
    \ are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the\
    \ following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note:\
    \ you may assume the input is always", "{\n    bool [] arr = [false, false, true,\
    \ true, false, true, false, true, \n    false, false, false, true, false, true,\
    \ false, false];\n    return num.sum!(a => arr[a].take!(1).array);\n}", "{\n \
    \   //find how many hex digits are prime numbers\n    return 0;\n}\n/*\nYou have\
    \ been tasked to write a function that receives \n    a hexadecimal number as\
    \ a string and gets a length of \n    the longest continuous segment of prime\
    \ hexadecimal digits \n    in the given number.\n    Hexadecimal digits are 0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5,\
    \ 7, 11, 13, 17,...\n    So you have to determine a length of the longest continuous\
    \ segment \n    of the following digits: 2, 3, 5, 7, B (=decimal 11), D (=decimal\
    \ 13).\n    Note: you may assume the input is always correct or empty string,\
    \ \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    >>>\
    \ hex_lon(\"AB\")\n    2L\n    >>> hex_lon(\"A7E\")\n    2L\n    >>> hex_lon(\"\
    ABED1A33\")\n    3L\n    >>> hex_lon(\"123456789ABCDEF0\")\n    2L\n    >>> hex_lon(\"\
    ABBEE\")\n    2L\n    >>> hex_lon(\"2020\")\n    2L\n    >>> hex_lon(\"202020\"\
    )\n    3L\n*/\nlong hex_lon(string num) \n{\n    //find the length of the longest\
    \ continuous segment \n    //of prime hexadecimal digits\n    return 0;\n}\n/*\n\
    You have been tasked to write a function that receives \n    a hexadecimal number\
    \ as a string and gets a length of \n    the shortest continuous segment of prime\
    \ hexadecimal digits \n    in the given number.\n    Hexadecimal digits are 0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5,\
    \ 7, 11, 13, 17,...\n    So you have to determine a length of the shortest continuous\
    \ segment \n    of the following digits: 2, 3, 5, 7, B (=decimal 11), D", "{\n\
    \talias hex = Tuple!(char, int, char, int, char, int, char, int, char, int, char,\
    \ int, char, int, char, int);\n\talias hex_type = std.typecons.Tuple!(char, int,\
    \ char, int, char, int, char, int, char, int, char, int, char, int, char, int);\n\
    \thex h = hex_type( '0', 0, '1', 1, '2', 2, '3', 3, '4', 4, '5', 5, '6', 6, '7',\
    \ 7, '8', 8, '9', 9, 'A', 10, 'B', 11, 'C', 12, 'D', 13, 'E', 14, 'F', 15);\n\t\
    //char[] digits = \"0123456789ABCDEF\";\n\t//int[] d = cast(int[])[0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n\tauto isPrime = (int n)\n\t{\n\t\
    \tint i = 2;\n\t\tfor(; i < n; i++)\n\t\t{\n\t\t\tif(n % i == 0)\n\t\t\t\treturn\
    \ false;\n\t\t}\n\t\treturn true;\n\t};\n\tint count = 0;\n\tif(num.length > 0)\n\
    \t{\n\t\tchar[] num_array = num.dup;\n\t\tint i = 0;\n\t\tint len = num_array.length;\n\
    \t\tfor(; i < len; i++)\n\t\t{\n\t\t\tif(isPrime(h[num_array[i]]))\n\t\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    int sum = 0;\n    int x;\n    foreach(n;\
    \ num)\n    {\n        switch(n)\n        {\n            case 'A':\n         \
    \       x = 10;\n                break;\n            case 'B':\n             \
    \   x = 11;\n                break;\n            case 'C':\n                x\
    \ = 12;\n                break;\n            case 'D':\n                x = 13;\n\
    \                break;\n            case 'E':\n                x = 14;\n    \
    \            break;\n            case 'F':\n                x = 15;\n        \
    \        break;\n            default:\n                x = int(n);\n         \
    \       break;\n        }\n        if(x > 1 && x%2 != 0 && x%3 != 0 && x%5 !=\
    \ 0 && x%7 != 0 && x%11 != 0 && x%13 != 0)\n        {\n            sum++;\n  \
    \      }\n    }\n    return sum;\n}", "{\n    int i;\n    long count = 0;\n  \
    \  string hex_digits = \"0123456789ABCDEF\";\n    string primes = \"2357BDF\"\
    ;\n    foreach(i, c; num)\n    {\n        if(hex_digits.find(c) != string.npos)\n\
    \        {\n            if(primes.find(c) != string.npos)\n            {\n   \
    \             count++;\n            }\n        }\n    }\n    return count;\n}",
  "{\n    /*\n        Based on the fact that hexadecimal is just a base-16 number,\
    \ \n        we can convert it to a decimal base-10 number and then \n        use\
    \ that to determine primality with the help of a sieve algorithm.\n    */\n  \
    \  \n    /*\n        First we will convert num from its hexadecimal form to a\
    \ decimal \n        integer form.\n    */\n    enum hex = \"0123456789ABCDEF\"\
    ;\n    ulong total = 0L;\n    foreach(i, ch; num) \n    {\n        // Index i\
    \ is also the power of 16\n        total += hex.indexOf(ch) * pow(16L, num.length\
    \ - i - 1L);\n    }\n    \n    /*\n        We can now use the Sieve of Eratosthenes\
    \ algorithm to determine \n        the amount of primes in the range [0L, total].\n\
    \        This algorithm is used to find all prime numbers in a given range.\n\
    \        https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_and_variants\n\
    \        The algorithm works by eliminating composite numbers from the range \n\
    \        by marking them with an isComposite boolean value.\n        Every time\
    \ a prime number is found, we then mark all of its multiples \n        as composite.\n\
    \        At the end of the algorithm, we have a list of composite numbers and\
    \ \n        non-composite numbers, which are in fact the prime numbers in the\
    \ range.\n    */\n    // We need to add 2 since the algorithm starts checking\
    \ numbers at 2\n    ulong[] sieve = new ulong[total + 2L];\n    bool[] isComposite\
    \ = new bool[total + 2L];\n    isComposite[0L] = true;\n    isComposite[1L] =\
    \ true;\n    // Initially, we assume that all numbers are prime\n    // This lets\
    \ us access the primes in the range of [0L, total] by index.\n    // Note that\
    \ the number at sieve[i] is not necessarily i.\n    for(ulong i = 0L; i <= total;\
    \ i++) \n    {\n        sieve[i] = i;\n    }\n", "{\n    long cnt = 0;\n    foreach(inout\
    \ c; num)\n    {\n        if(c in ['2', '3', '5', '7', 'B', 'D'])\n          \
    \  cnt++;\n    }\n    return cnt;\n}", "{\n    long result = 0;\n    long temp;\n\
    \    long hexNumber;\n    int length = num.length;\n    foreach(i; 0..length)\n\
    \    {\n        temp = num[i..$];\n        hexNumber = std.typecons.to!long(temp,\
    \ 16);\n        if(hexNumber == 2 || hexNumber == 3 || hexNumber == 5 || hexNumber\
    \ == 7 || hexNumber == 11 || hexNumber == 13)\n        {\n            result =\
    \ result + 1;\n        }\n    }\n    return result;\n}\n```", "{\n    long sum\
    \ = 0;\n    for (auto d : num)\n    {\n        switch (d)\n        {\n       \
    \     case '0': case '1': case '4': case '6': case '8': case '9':\n          \
    \      break;\n            case '2': case '3': case '5': case '7':\n         \
    \       sum++;\n                break;\n            case 'B': case 'D':\n    \
    \            sum++;\n                break;\n        }\n    }\n    return sum;\n\
    }", "{\n    import std.typecons;\n    import std.conv;\n    import std.stdio;\n\
    \    import std.math;\n    // convert to num\n    auto hexNum = to!int(num, 16);\n\
    \    // get each digit of the number\n    auto digit = num.map!(c => c.digit);\n\
    \    // sum only those digits that are primes\n    return digit.filter!(d => isPrime(d)).sum;\n\
    }", "{\n    // 1. Convert input number from Hex to decimal\n    ulong decimal_num\
    \ = to!ulong(num, 16);\n    // 2. Convert the decimal number to the array of digits\n\
    \    ulong[] digits = num.to_ulongArray;\n    // 3. Check each digit whether it\
    \ is a prime number\n    size_t count = 0;\n    foreach(digit; digits)\n    {\n\
    \        if (isPrime(digit)) \n        {\n            count++;\n        }\n  \
    \  }\n    return cast(long)count;\n}", "{\n    long result = 0;\n    foreach(ch;\
    \ num)\n    {\n        static struct HexPrimes\n        {\n            ubyte operator[](char\
    \ c) @property\n            {\n                switch(c)\n                {\n\
    \                    case 'A': return 1;\n                    case 'B': return\
    \ 1;\n                    case 'D': return 1;\n                    default:  return\
    \ 0;\n                }\n            }\n        } hex_primes;\n        result\
    \ += hex_primes[ch];\n    }\n    return result;\n}\n/*\nYou have been tasked to\
    \ write a function that receives a hexadecimal number \n    as a string and counts\
    \ the number of hexadecimal digits that are primes \n    (prime number, or a prime,\
    \ is a natural number greater than 1 that is \n    not a product of two smaller\
    \ natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So\
    \ you have to determine a number of the following digits: 2, 3, 5, 7, \n    B\
    \ (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always\
    \ correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n\
    \    Examples:\n    >>> hex_key2(\"AB\")\n    1L\n    >>> hex_key2(\"1077E\")\n\
    \    2L\n    >>> hex_key2(\"ABED1A33\")\n    4L\n    >>> hex_key2(\"123456789ABCDEF0\"\
    )\n    6L\n    >>> hex_key2(\"2020\")\n    2L\n*/\nlong hex_key2(string num) \n\
    {\n    long result = 0;\n    foreach(ch; num)\n    {\n        static bool[16]\
    \ hex_primes = [true, false, true, false, false, true, \n                    \
    \                  false, true, false, false, false, true, \n                \
    \                      false, false, false, false];\n        result += hex_primes[",
  "{\n    long res = 0;\n    auto r = num.front;\n    for(; r != num.back; r++)\n\
    \    {\n        if(*r > 47 && *r < 58)\n        {\n            if(*r == '2' ||\
    \ *r == '3' || *r == '5' || *r == '7')\n                res++;\n        }\n  \
    \      else if(*r > 64 && *r < 71)\n        {\n            if(*r == 'A' || *r\
    \ == 'B' || *r == 'D')\n                res++;\n        }\n    }\n    return res;\n\
    }", "{\n    static immutable primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,\
    \ 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\
    \ 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\
    \ 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,\
    \ 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,\
    \ 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\
    \ 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\
    \ 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\
    \ 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919,\
    \ 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021,\
    \ 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103,\
    \ 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201,", "{\n\
    \    long count = 0;\n    immutable char[] chars = [ '0', '1', '2', '3', '4',\
    \ '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' ];\n    foreach(i; chars)\n\
    \    {\n        if(i == '2' || i == '3' || i == '5' || i == '7' || i == 'B' ||\
    \ i == 'D')\n        {\n            foreach(k; num)\n            {\n         \
    \       if(k == i)\n                {\n                    count++;\n        \
    \        }\n            }\n        }\n    }\n    return count;\n}", "{\n    int[]\
    \ prime = [2, 3, 5, 7, 11, 13];\n    int[] hexadecimal = [0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15];\n    long sum = 0;\n    string temp;\n   \
    \ for (int i = 0; i < num.length; i++)\n    {\n        temp = num[i];\n      \
    \  for (int j = 0; j < hexadecimal.length; j++)\n        {\n            if (temp\
    \ == hexadecimal[j])\n            {\n                for (int k = 0; k < prime.length;\
    \ k++)\n                {\n                    if (hexadecimal[j] == prime[k])\n\
    \                    {\n                        sum += 1;\n                  \
    \  }\n                }\n            }\n        }\n    }\n    return sum;\n}",
  "{\n    long count = 0;\n    long n = num.length;\n    for (size_t i = 0; i < n;\
    \ i++)\n    {\n        if (num[i] == '2' || num[i] == '3' || num[i] == '5' ||\
    \ num[i] == '7' ||\n            num[i] == 'B' || num[i] == 'D')\n        {\n \
    \           count += 1;\n        }\n    }\n    return count;\n}", "{\n    enum\
    \ isPrime = false;\n    long counter = 0;\n    foreach(element; num)\n    {\n\
    \        switch(element)\n        {\n            case '2':\n                counter++;\n\
    \                break;\n            case '3':\n                counter++;\n \
    \               break;\n            case '5':\n                counter++;\n  \
    \              break;\n            case '7':\n                counter++;\n   \
    \             break;\n            case 'B':\n                counter++;\n    \
    \            break;\n            case 'D':\n                counter++;\n     \
    \           break;\n            case 'F':\n                counter++;\n      \
    \          break;\n            default:\n                counter += 0;\n     \
    \           break;\n        }\n    }\n    return counter;\n}", "{\n    import\
    \ std.algorithm;\n    import std.conv;\n    import std.array;\n    import std.range;\n\
    \    import std.range.primitives;\n    import std.string;\n    import std.typecons;\n\
    \    import std.array;\n    int primes = 0;\n    auto possiblePrimes = [\"2\"\
    ,\"3\",\"5\",\"7\",\"B\",\"D\"];\n    foreach(char numChar; num)\n    {\n    \
    \    if(numChar in possiblePrimes)\n        {\n            primes++;\n       \
    \ }\n    }\n    return primes;\n}\n/*\nThe digits range is a sorted range containing\
    \ all integer numbers from low to high, including both. \nYou have to write a\
    \ function that returns a range containing only the digits that are primes, \n\
    \    in sorted order, including both low and high. Examples:\n    >>> import std.stdio;\n\
    \    >>> auto primes = primeDigits(0, 4);\n    >>> writeln(primes);\n    [2, 3]\n\
    \    >>> primes = primeDigits(5, 6);\n    >>> writeln(primes);\n    [5]\n    >>>\
    \ primes = primeDigits(5, 16);\n    >>> writeln(primes);\n    [5, 7, 11, 13]\n\
    \    >>> primes = primeDigits(0, 100);\n    >>> writeln(primes);\n    [2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97]\n    >>> primes = primeDigits(0, 1);\n    >>> writeln(primes);\n   \
    \ []\n*/\nauto primeDigits(long low, long high) \n{\n    import std.algorithm;\n\
    \    import std.conv;\n    import std.array;\n    import std.range;\n    import\
    \ std.range.primitives;\n    import std.string;\n    import std.typecons;\n  \
    \  import std.array;\n    import std.range;\n    // import std.stdio;\n    import\
    \ std.math;\n    long[] arr = [];\n    for", "{\n    long res = 0;\n    foreach(i;\
    \ num)\n    {\n        if (i == '2' || i == '3' || i == '5' || i == '7' || i ==\
    \ 'B' || i == 'D')\n            res++;\n    }\n    return res;\n}", "{\n    long[]\
    \ primes = new long[7];\n    long i = 0;\n    foreach(index, prime; [2, 3, 5,\
    \ 7, 11, 13, 17])\n    {\n        primes[i] = prime;\n        i++;\n    }\n  \
    \  // write function body\n    long count = 0;\n    foreach(c; num)\n    {\n \
    \       if(c >= 'A' && c <= 'F')\n        {\n            long v = cast(long)c\
    \ - cast(long)'A' + 10;\n            foreach(index, prime; primes)\n         \
    \   {\n                if(v == prime)\n                {\n                   \
    \ count++;\n                    break;\n                }\n            }\n   \
    \     }\n        else if(c >= '0' && c <= '9')\n        {\n            long v\
    \ = cast(long)c - cast(long)'0';\n            foreach(index, prime; primes)\n\
    \            {\n                if(v == prime)\n                {\n          \
    \          count++;\n                    break;\n                }\n         \
    \   }\n        }\n    }\n    return count;\n}", "{\n    static assert(allSatisfy!\"\
    to!int(c) > 0\"(\"0123456789ABCDEF\"));\n    static assert(allSatisfy!\"to!int(c)\
    \ in [2,3,5,7,11,13]\"(\"2357BDF\"));\n    static assert(allSatisfy!\"to!int(c)\
    \ < 11 || to!int(c) > 13\"(\"0123456789AB\"));\n    static assert(allSatisfy!\"\
    to!int(c) < 11 || to!int(c) > 13\"(\"0123456789CE\"));\n    static assert(allSatisfy!\"\
    to!int(c) < 13 || to!int(c) > 17\"(\"0123456789ABC\"));\n    static assert(allSatisfy!\"\
    to!int(c) < 13 || to!int(c) > 17\"(\"0123456789CEF\"));\n    static assert(allSatisfy!\"\
    to!int(c) < 17 || to!int(c) > 19\"(\"0123456789ABCD\"));\n    static assert(allSatisfy!\"\
    to!int(c) < 17 || to!int(c) > 19\"(\"0123456789CEFG\"));\n    long n = 0;\n  \
    \  foreach(c; num) \n    {\n        if(to!int(c) > 1 && to!int(c) < 20 && isPrime(to!int(c)))\n\
    \            n++;\n    }\n    return n;\n}", "{\n    static string hex_nums =\
    \ \"0123456789ABCDEF\";\n    static int[] primes = {2, 3, 5, 7, 11, 13};\n   \
    \ return num.transformed!((c) => hex_nums.indexOf(c))\n              .filter!(\
    \ (x) => x in [2, 3, 5, 7, 11, 13] )\n              .length;\n}\n/*", "{\n   \
    \ long sum = 0;\n    auto l = num.length;\n    for (int i = 0; i < l; i++)\n \
    \   {\n        if (num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] ==\
    \ '7' || num[i] == 'B' || num[i] == 'D')\n        {\n            sum++;\n    \
    \    }\n    }\n    return sum;\n}", "{\n    // <char,ulong> charMap = ['0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'A':10,'B':11,'C':12,'D':13,'E':14,'F':15];\n\
    \    // long[16] primeArray = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53];\n\
    \    long[16] primeArray = [0,0,2,3,0,5,0,7,0,0,0,11,0,13,0,0];\n    long count\
    \ = 0;\n    foreach(index,c;num)\n    {\n        if(primeArray[c] != 0) count++;\n\
    \    }\n    return count;\n}\n/*TEST\nlong[] test = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\n\
    foreach(i;test)\n{\n    long index = i;\n    char c = i;\n    assert(primeArray[c]\
    \ == primeArray[index]);\n}\n*/", "{\n    auto arr = num.map!(x => (x >='A' &&\
    \ x <='F')? 10 + x - 'A' : x - '0' );\n    long count = 0;\n    foreach(int i;\
    \ arr)\n    {\n        if(i == 2 || i == 3 || i == 5 || i == 7 || i == 11 || i\
    \ == 13)\n            count++;\n    }\n    return count;\n}", "{\n    long res\
    \ = 0;\n    long len = num.length;\n    if (num == \"\") \n        return res;\n\
    \    foreach (l; 0 .. len)\n    {\n        switch (num[l])\n        {\n      \
    \      case '2':\n            case '3':\n            case '5':\n            case\
    \ '7':\n            case 'B':\n            case 'D':\n                res++;\n\
    \                break;\n        }\n    }\n    return res;\n}", "{\n    return\
    \ num.filter!(x => \"2357BDF\".canFind(x)).length;\n}", "{\n    long prime_count\
    \ = 0;\n    foreach(x; num)\n    {\n        const long n = to!long(x, 16);\n \
    \       if(n > 1 && isPrime(n))\n        {\n            prime_count++;\n     \
    \   }\n    }\n    return prime_count;\n}", "{\n    auto size = num.length;\n \
    \   auto count = 0;\n    for (int i = 0; i < size; i++)\n    {\n        char symbol\
    \ = toUpper(num[i]);\n        switch (symbol)\n        {\n            case '2':\n\
    \            case '3':\n            case '5':\n            case '7':\n       \
    \     case 'B':\n            case 'D':\n                count++;\n           \
    \     break;\n        }\n    }\n    return count;\n}\n/*\n    In a forest, each\
    \ wolf can transform into a fox.\n    When a wolf turns into a fox, a fox cannot\
    \ turn into a wolf.\n    For the purpose of the task, the forest is represented\
    \ by a string \n    consisting of w (wolf) and f (fox) characters.\n    A fox\
    \ eats all the foxes immediately to the left and right of it \n    (a fox cannot\
    \ eat another foxes in front of or behind it, only to the left and right), \n\
    \    and then the fox transforms into a wolf.\n    One iteration for eating occurs\
    \ for each fox in the order from the leftmost fox to the rightmost fox.\n    If\
    \ after that iteration the string changed, the iteration continues.\n    Write\
    \ a function that will find the number of iterations required for the forest to\
    \ become empty.\n    A forest is empty when it consists of only one character.\n\
    \    Example\n    >>> howlong(\"fw\")\n    1L\n    >>> howlong(\"wffw\")\n   \
    \ 2L\n    >>> howlong(\"wffffffffff\")\n    1L\n    >>> howlong(\"wf\")\n    1L\n\
    \    >>> howlong(\"wfwfwf\")\n    3L\n    >>> howlong(\"ffwfwwf\")\n    3L\n*/\n\
    long howlong(string forest)\n{\n    auto count = 0;\n    while (forest.length\
    \ > 1)\n    {\n        count++;\n        auto i = 0;\n        while (i < forest.length)\n\
    \        {\n            if (forest[i] == 'f')\n            {\n               \
    \ forest = erase(forest, i);\n                if (i > 0)\n                {\n\
    \                    forest = erase(forest, i - 1);\n                    i -=\
    \ 2;\n                }\n                else", "{\n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    //make num into array\n  \
    \  //check if digits in num are primes\n    //count how many times true\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    ", "{\n    long count = 0;\n  \
    \  foreach(char c; num)\n    {\n        long n = c.to!long(16);\n        if(n\
    \ <= 1) continue;\n        else if(n == 2 || n == 3 || n == 5 || n == 7 || n ==\
    \ 11 || n == 13) count++;\n    }\n    return count;\n}", "{\n    string hex =\
    \ \"A B C D E F\";", "{\n    string hexDigits = \"0123456789ABCDEF\";\n    long\
    \ hexPrimeNumbers = 0;\n    foreach(numCh; num)\n    {\n        if(hexDigits.indexOf(numCh)\
    \ < 8)\n        {\n            hexPrimeNumbers += 0;\n        }\n        else\
    \ if(hexDigits.indexOf(numCh) == 8)\n        {\n            hexPrimeNumbers +=\
    \ 0;\n        }\n        else if(hexDigits.indexOf(numCh) == 9)\n        {\n \
    \           hexPrimeNumbers += 0;\n        }\n        else if(hexDigits.indexOf(numCh)\
    \ == 10)\n        {\n            hexPrimeNumbers += 1;\n        }\n        else\
    \ if(hexDigits.indexOf(numCh) == 11)\n        {\n            hexPrimeNumbers +=\
    \ 1;\n        }\n        else if(hexDigits.indexOf(numCh) == 12)\n        {\n\
    \            hexPrimeNumbers += 0;\n        }\n        else if(hexDigits.indexOf(numCh)\
    \ == 13)\n        {\n            hexPrimeNumbers += 1;\n        }\n        else\
    \ if(hexDigits.indexOf(numCh) == 14)\n        {\n            hexPrimeNumbers +=\
    \ 0;\n        }\n        else if(hexDigits.indexOf(numCh) == 15)\n        {\n\
    \            hexPrimeNumbers += 0;\n        }\n    }\n    return hexPrimeNumbers;\n\
    }", "{\n    enum uint ulong hexdigit;\n    auto primeNumbers = new int[16];\n\
    \    foreach(i; 0..16)\n    {\n        ulong = i;\n        primeNumbers[i] = isPrime(ulong);\n\
    \    }\n    auto sum = 0;\n    auto count = 0;\n    foreach(n; num)\n    {\n \
    \       if(n == 'A')\n        {\n            sum = 10;\n        }\n        else\
    \ if(n == 'B')\n        {\n            sum = 11;\n        }\n        else if(n\
    \ == 'C')\n        {\n            sum = 12;\n        }\n        else if(n == 'D')\n\
    \        {\n            sum = 13;\n        }\n        else if(n == 'E')\n    \
    \    {\n            sum = 14;\n        }\n        else if(n == 'F')\n        {\n\
    \            sum = 15;\n        }\n        else\n        {\n            sum =\
    \ n.to!int;\n        }\n        if(primeNumbers[sum] == 1)\n        {\n      \
    \      count++;\n        }\n    }\n    return count;\n}\nlong isPrime(ulong num)\n\
    {\n    if(num <= 1)\n    {\n        return 0;\n    }\n    foreach(i; 2..num)\n\
    \    {\n        if(num % i == 0)\n        {\n            return 0;\n        }\n\
    \    }\n    return 1;\n}", "{\n    long result = 0;\n    string valid_chars =\
    \ \"2357BD\";\n    foreach(value; num)\n    {\n        if( valid_chars.find(value)\
    \ != -1 )\n        {\n            result += 1;\n        }\n    }\n    return result;\n\
    }", "{\n\tsize_t count = 0;\n\tforeach(elem; num)\n\t{\n\t\tif(('0' <= elem <=\
    \ '9') || ('A' <= elem <= 'F'))\n\t\t{\n\t\t\tint p = hexToInt(elem);\n\t\t\t\
    if(isPrime(p))\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    import\
    \ std.string;\n    auto a = num.idup;\n    long sum = 0;\n    int[2] primes;\n\
    \    import std.array;\n    primes = [2,3,5,7,11,13];\n    foreach(immutable i;\
    \ 0..a.length)\n    {\n        if(a[i] >= '0' && a[i] <= '9')\n        {\n   \
    \         if(a[i] == '0' || a[i] == '1')\n            {\n                continue;\n\
    \            }\n            if(a[i] >= '4' && a[i] <= '7')\n            {\n  \
    \              continue;\n            }\n            sum += 1;\n        }\n  \
    \      else if(a[i] >= 'A' && a[i] <= 'F')\n        {\n            if(a[i] ==\
    \ 'A' || a[i] == 'C' || a[i] == 'E')\n            {\n                continue;\n\
    \            }\n            if(a[i] == 'B' || a[i] == 'D' || a[i] == 'F')\n  \
    \          {\n                sum += 1;\n            }\n        }\n    }\n   \
    \ return sum;\n}\n```", "{\n    auto str = lowercase(num);\n    size_t len = str.length;\n\
    \    size_t count = 0;\n    for (size_t i = 0; i < len; i++) {\n        switch\
    \ (str[i]) {\n            case 'a':\n            case 'b':\n            case 'd':\n\
    \            case 'e':\n                count++;\n                break;\n   \
    \         case '0':\n            case '1':\n            case '2':\n          \
    \  case '3':\n            case '4':\n            case '5':\n            case '6':\n\
    \            case '7':\n            case '8':\n            case '9':\n       \
    \         int n = str[i] - '0';\n                if (n == 2 || n == 3 || n ==\
    \ 5 || n == 7)\n                    count++;\n                break;\n       \
    \     default:\n                break;\n        }\n    }\n    return count;\n}",
  "{\n    long c = 0;\n    string hexa = \"2,3,5,7,11,13\";\n    foreach(immutable\
    \ j; 0 .. num.length)\n    {\n        if(any(i; hexa) == num[j])\n        {\n\
    \            c++;\n        }\n    }\n    return c;\n}\n/*\nYou have been tasked\
    \ to write a function that receives a number and \n    returns it with its digits\
    \ reversed.\n    If the number is negative, the sign is preserved.\n    Example:\n\
    \    >>> digit_reversal(12345)\n    54321\n    >>> digit_reversal(-12345)\n  \
    \  -54321\n    >>> digit_reversal(0)\n    0\n*/\nlong digit_reversal(long num)\
    \ \n{\n    long abs_num = abs(num);\n    long num1 = 0;\n    while(abs_num !=\
    \ 0)\n    {\n        num1 = num1 * 10 + abs_num % 10;\n        abs_num /= 10;\n\
    \    }\n    return sign(num) * num1;\n}", "{\n    const char hexDigits[16] = {'0',\
    \ '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\
    \    long decNum = 0;\n    // Convert hexadecimal number to decimal number\n \
    \   foreach(i, letter; num)\n    {\n        auto index = 0;\n        while(hexDigits[index]\
    \ != letter)\n        {\n            index++;\n        }\n        decNum += index\
    \ * intPow(16, num.length - i - 1);\n    }\n    long primeCounter = 0;\n    //\
    \ Count prime numbers\n    foreach(i, digit; num)\n    {\n        if(isPrime(digit))\n\
    \        {\n            primeCounter++;\n        }\n    }\n    return primeCounter;\n\
    }", "{\n    long result = 0;\n    char[] hexChars = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'];\n\
    \    for(int i = 0; i < num.length; i++)\n    {\n        if(hexChars[10..16].find(num[i])\
    \ != -1 && num[i] != 'B' && num[i] != 'D')\n        {\n            result++;\n\
    \        }\n    }\n    return result;\n}", "{\n    string digits = \"0123456789ABCDEF\"\
    ;\n    int[] primes = [2, 3, 5, 7, 11, 13];\n    // int[] primes = [2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,\
    \ 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,\
    \ 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353,\
    \ 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449,\
    \ 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\
    \ 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653,\
    \ 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\
    \ 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,\
    \ 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991,\
    \ 997];\n    // if (num == \"\")\n    //     return 0;\n    long hex_counter =\
    \ 0;\n    foreach (int i; 0 .. num.length)\n    {\n        int digit = digits.indexOf(",
  "{\n\tstring primes = \"2357BD\";\n\tlong result = 0;\n\tforeach(string ch; num)\n\
    \t{\n\t\tif(primes.find(ch) != string.npos)\n\t\t\tresult++;\n\t}\n\treturn result;\n\
    }", "{\n    auto hex = [=](char c) {\n        if (c >= '0' && c <= '9') return\
    \ c - '0';\n        else if (c >= 'A' && c <= 'F') return c - 'A' + 10;\n    \
    \    return -1;\n    };\n    long result = 0;\n    foreach (i, c; num)\n    {\n\
    \        long n = hex(c);\n        if (n == -1) continue;\n        if (n <= 1)\
    \ continue;\n        if (n % 2 == 0) continue;\n        bool flag = true;\n  \
    \      for (long i = 3; i <= sqrt(n); i+=2)\n        {\n            if (n % i\
    \ == 0)\n            {\n                flag = false;\n                break;\n\
    \            }\n        }\n        if (flag)\n            result++;\n    }\n \
    \   return result;\n}", "{\n    // long valid_digits = 0;\n    // foreach(wchar\
    \ val; num)\n    // {\n    //     if (val == '2' || val == '3' || val == '5' ||\
    \ val == '7' || val == 'B' || val == 'D')\n    //     {\n    //         valid_digits++;\n\
    \    //     }\n    // }\n    // return valid_digits;\n    long valid_digits =\
    \ 0;\n    import std.conv;\n    bool isPrime(int num)\n    {\n        bool isPrime\
    \ = true;\n        for (int i = 2; i < num; i++)\n        {\n            if (num\
    \ % i == 0)\n            {\n                isPrime = false;\n               \
    \ break;\n            }\n        }\n        return isPrime;\n    }\n    foreach(wchar\
    \ val; num)\n    {\n        if (isPrime(to!int(val, 16)))\n        {\n       \
    \     valid_digits++;\n        }\n    }\n    return valid_digits;\n}\n/*\nYour\
    \ task is to write a function that can find the sum of \n    all multiples of\
    \ a given number n below a certain limit x.\n    Example:\n    >>> sum_of_multiples(5,10)\n\
    \    5L\n    >>> sum_of_multiples(5,20)\n    45L\n    >>> sum_of_multiples(5,21)\n\
    \    45L\n    >>> sum_of_multiples(5,30)\n    75L\n    >>> sum_of_multiples(5,31)\n\
    \    75L\n    >>> sum_of_multiples(5,100)\n    950L\n    >>> sum_of_multiples(5,1000)\n\
    \    95550L\n    >>> sum_of_multiples(5,10000)\n    957750L\n*/\nlong sum_of_multiples(int\
    \ num, int limit) \n{\n    // long sum = 0;\n    // for (int i = 1; i < limit;\
    \ i++)\n    // {\n    //     if (i % num == 0)\n    //     {\n    //         sum\
    \ += i;\n    //", "{\n    string hexDigits = \"23456789ABCDEF\";\n    long ret\
    \ = 0;\n    foreach(hexDigit; num)\n    {\n        if(hexDigits.indexOf(hexDigit)\
    \ != -1) ret++;\n    }\n    return ret;\n}", "{\n    long res=0;\n    foreach(var\
    \ ch; num)\n    {\n        if(ch=='0' || ch=='1' || ch=='4' || ch=='6' || ch=='8'\
    \ || ch=='9' || ch=='C' || ch=='E' || ch=='F')\n            continue;\n      \
    \  else\n            res++;\n    }\n    return res;\n}\n/*\n2\n3\n5\n7\nB\nD\n\
    */", "{\n    struct TrueType { } true;\n    struct FalseType { } false;\n    TrueType\
    \    is_prime(in long num) pure nothrow @nogc\n    {\n        if (num < 2) return\
    \ false;\n        if (num == 2) return true;\n        for (long i = 2; i <= sqrt(num);\
    \ i++)\n        {\n            if (num % i == 0) return false;\n        }\n  \
    \      return true;\n    }\n    auto hex_to_int(in char ch) pure nothrow @nogc\n\
    \    {\n        auto s = ch.to!string.toLower();\n        if (s.length == 1)\n\
    \        {\n            switch (s[0])\n            {\n                case '0':\
    \ return 0;\n                case '1': return 1;\n                case '2': return\
    \ 2;\n                case '3': return 3;\n                case '4': return 4;\n\
    \                case '5': return 5;\n                case '6': return 6;\n  \
    \              case '7': return 7;\n                case '8': return 8;\n    \
    \            case '9': return 9;\n                case 'a': return 10;\n     \
    \           case 'b': return 11;\n                case 'c': return 12;\n     \
    \           case 'd': return 13;\n                case 'e': return 14;\n     \
    \           case 'f': return 15;\n            }\n        }\n        return -1;\n\
    \    }\n    long count = 0;\n    foreach (ch; num)\n    {\n        if (ch in ['2',\
    \ '3', '5', '7', 'B', 'D']) \n        {\n            count++;\n        }\n   \
    \ }\n    return count;\n}", "{\n    long val(0);\n    int i = 0;\n    long primecount\
    \ = 0;\n    long[] primes = [2,3,5,7,11,13];\n    string[] hexdigits = [\"0\"\
    ,\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\"\
    ,\"E\",\"F\"];\n    //string hexdigits = \"0123456789ABCDEF\";\n    //long hex\
    \ = 0xFFFF;\n    //for(long i = 0; i < 16; i++){\n    //    writeln(hexdigits[i]);\n\
    \    //}\n    //foreach(char c; num) {\n    //    writeln(c);\n    //}\n    if(num\
    \ == \"\"){\n        return 0;\n    }\n    for(i = 0; i < num.length; i++){\n\
    \        //writeln(num[i]);\n        foreach(long p; primes){\n            if(num[i]\
    \ == hexdigits[p]){\n                primecount++;\n            }\n        }\n\
    \    }\n    //val = primecount;\n    return primecount;\n    /*\n    writeln(i);\n\
    \    foreach(long p; primes){\n        //writeln(p);\n        if(num[i] == p){\n\
    \            //writeln(num[i]);\n            //writeln(num[i]);\n            val++;\n\
    \        }\n    }\n    return val;\n    */\n}", "{ \n    import std.digest.sha;\n\
    \    import std.string;\n    long result = 0;\n    foreach(ch; num)\n    {\n \
    \       if(uint(ch) > 7 && uint(ch) < 58)\n        {\n            if(isPrime(uint(ch)\
    \ - 48))\n            {\n                result++;\n            }\n        }\n\
    \        else if(uint(ch) > 64 && uint(ch) < 72)\n        {\n            if(isPrime(uint(ch)\
    \ - 55))\n            {\n                result++;\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    size_t i, counter = 0;\n    int num_int;\n\
    \    foreach(i, num)\n    {\n        if(num[i] >= 'A' && num[i] <= 'F')\n    \
    \    {\n            num_int = num[i] - 'A' + 10;\n        }\n        else\n  \
    \      {\n            num_int = num[i] - '0';\n        }\n        if(num_int ==\
    \ 2 || num_int == 3 || num_int == 5 || \n        num_int == 7 || num_int == 11\
    \ || num_int == 13)\n        {\n            counter++;\n        }\n    }\n   \
    \ return counter;\n}", "{\n    return num.count('A')+\n           num.count('B')+\n\
    \           num.count('D')+\n           num.count('7')+\n           num.count('3')+\n\
    \           num.count('2');\n}", "{\n    // your code here\n    \n    import std.algorithm;\n\
    \    import std.range;\n    import std.algorithm.iteration : map;\n    import\
    \ std.stdio;\n    import std.conv;\n    import std.string;\n    import std.array;\n\
    \    import std.math;\n    import std.typecons;\n    \n    long res;\n    int\
    \ count = 0;\n    ulong x = num.to!ulong;\n    //long x = to!long(num);\n    //\
    \ writeln(x);\n    string hex = format(\"0x%X\",x);\n    // writeln(hex);\n  \
    \  if(hex.length == 1)\n    {\n        return res;\n    }\n    else\n    {\n \
    \       int[] arr = num.split(\"\").map!(a => a.to!int(\"\")).array;\n       \
    \ foreach(auto n;arr)\n        {\n            if(n%2 == 0 && n != 2)\n       \
    \     {\n                count++;\n            }\n            else if(n%3 == 0\
    \ && n != 3)\n            {\n                count++;\n            }\n       \
    \     else if(n%5 == 0 && n != 5)\n            {\n                count++;\n \
    \           }\n            else if(n%7 == 0 && n != 7)\n            {\n      \
    \          count++;\n            }\n            else if(n%11 == 0 && n != 11)\n\
    \            {\n                count++;\n            }\n            else if(n%13\
    \ == 0 && n != 13)\n            {\n                count++;\n            }\n \
    \       }\n        // writeln(count);\n        res = num.length - count;\n   \
    \     return res;\n    }\n}", "{\n    uint64_t total = 0;\n    foreach(it; num)\n\
    \    {\n        if(it == '2' || it == '3' || it == '5' || it == '7' || it == 'B'\
    \ || it == 'D')\n        {\n            total++;\n        }\n    }\n    return\
    \ total;\n}", "{\n    if (num.empty) return 0;\n    ulong cnt = 0;\n    foreach\
    \ (i; 0 .. num.length)\n    {\n        char c = num[i];\n        ulong v = c;\n\
    \        if(v > 47 && v < 58) // ascii 0...9\n        {\n            ulong n =\
    \ v - 48;\n            if (n == 2 || n == 3 || n == 5 || n == 7)\n           \
    \     cnt++;\n        } else if (v > 64 && v < 71) //ascii A...F\n        {\n\
    \            switch(v)\n            {\n                case 66:\n            \
    \    case 68:\n                case 70:\n                    cnt++;\n        \
    \    }\n        }\n    }\n    return cnt;\n}", "{\n    ulong counter=0;\n    for(ulong\
    \ i=0;i<num.length;i++)\n    {\n        const(char) current = num[i];\n      \
    \  if(current=='2'||current=='3'||current=='5'||current=='7'||current=='B'||current=='D')\n\
    \        {\n            counter++;\n        }\n    }\n    return counter;\n}\n\
    /*\nA linked list with a new type \"Link\" is given to you. \nThe new type has\
    \ the following definition:", "{\n    long result = 0;\n    long dec_num = to!long(num,\
    \ 16);\n    string dec_str = num;\n    foreach(char c; dec_str) {\n        switch(c)\
    \ {\n            case '2':\n            case '3':\n            case '5':\n   \
    \         case '7':\n            case 'B':\n            case 'D':\n          \
    \      result++;\n                break;\n            default:\n             \
    \   break;\n        }\n    }\n    return result;\n}\n/*\nTask", "{\n\tlong result\
    \ = 0;\n\tforeach(i; 0 .. num.length)\n\t{\n\t\tresult += (num[i]=='2' || num[i]=='3'\
    \ || num[i]=='5' || num[i]=='7' || num[i]=='B' || num[i]=='D');\n\t}\n\treturn\
    \ result;\n}\n/*\nYou have been tasked to write a function that receives \n  \
    \  a decimal integer and returns a string with the binary \n    representation\
    \ of the number, without leading zeros. \n    Do not use \"format\" or \"to!string\"\
    \ built-in functions. \n    For example:\n    * 0 -> \"0\"\n    * 1 -> \"1\"\n\
    \    * 2 -> \"10\"\n    * 3 -> \"11\"\n    * 4 -> \"100\"\n    * 5 -> \"101\"\n\
    \    * 6 -> \"110\"\n    * 7 -> \"111\"\n    * 10 -> \"1010\"\n    * 11 -> \"\
    1011\"\n    * 12 -> \"1100\"\n    * 13 -> \"1101\"\n    * 14 -> \"1110\"\n   \
    \ * 15 -> \"1111\"\n    * 16 -> \"10000\"\n    * 17 -> \"10001\"\n    * 18 ->\
    \ \"10010\"\n    * 19 -> \"10011\"\n    * 20 -> \"10100\"\n*/\nstring int_to_bin(long\
    \ num) \n{\n\tint[] result;\n\twhile(num>0)\n\t{\n\t\tresult ~= num%2;\n\t\tnum\
    \ /= 2;\n\t}\n\tresult.reverse;\n\tstring str;\n\tforeach(i; result)\n\t{\n\t\t\
    str ~= i.to!string;\n\t}\n\treturn str;\n}\n/*\nYou have been tasked to write\
    \ a function that receives \n    a decimal integer and returns a string with the\
    \ binary \n    representation of the number, without leading zeros. \n    Use\
    \ \"format\" or \"to!string\" built-in functions. \n    For example:\n    * 0\
    \ -> \"0\"\n    * 1 -> \"1\"\n    * 2 -> \"10\"\n    * 3 -> \"11", "{\n    int[]\
    \ arr=new int[10];\n    auto primes = [3,5,7,11,13,17,19,23,29,31];\n    auto\
    \ n = num.length;\n    long cnt = 0;\n    foreach(i; 0..n)\n    {\n        if\
    \ (num[i] >= '0' && num[i] <= '9') arr[i] = num[i] - '0';\n        else arr[i]\
    \ = num[i] - 'A' + 10;\n        if (arr[i] < primes[arr[i] - 2]) cnt++;\n    }\n\
    \    return cnt;\n}\n/*", "{\n    long res = 0;\n    long temp = 0;\n    long[]\
    \ hex = [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n    foreach(auto\
    \ e; zip(num, hex))\n    {\n        temp = e[1];\n        if(temp > 10)\n    \
    \    {\n            temp -= 7;\n        }\n        if(temp % 2 == 0)\n       \
    \ {\n            temp--;\n        }\n        if(isPrime(temp))\n        {\n  \
    \          res++;\n        }\n    }\n    return res;\n}", "{\n    return 0;\n\
    }\n/*\n    Key takeaways:\n    - How to extract characters from string?\n    -\
    \ How to convert string to integer?\n    - How to work with const?\n    - How\
    \ to use switch/case?\n    - How to use tuples?\n    - How to use deque?\n   \
    \ - How to use hex as string?\n    - How to work with structs?\n*/\n \n/*\n  \
    \  static if (is(T == string))\n    {\n        import std.conv;\n        return\
    \ to!int(num, 16);\n    }\n    else\n    {\n        return num;\n    }\n*/", "{\n\
    \    if (num == \"\") \n        return 0;\n    immutable uint[] primes = [2, 3,\
    \ 5, 7, 11, 13];\n    uint total = 0;\n    foreach (i; primes) \n    {\n     \
    \   if (member(num, format(\"%X\", i))) \n            total++;\n    }\n    return\
    \ total;\n}", "{\n    static bool[16] isPrime = [true, false, true, true, false,\
    \ true, false, true, \n                               false, false, false, true,\
    \ false, true, false, false];\n    return sum(map!(ch => isPrime[toupper(ch) -\
    \ '0'], num));\n}", "{\n    uint[] key = [2, 3, 5, 7, 11, 13];\n    long result\
    \ = 0;\n    foreach(ch; num)\n    {\n        uint n = to!uint(ch);\n        if(\
    \ n > 9) n = n - 7;\n        if( n in key) result++;\n    }\n    return result;\n\
    }", "{\n    struct HexPrimesTuple\n    {\n        ubyte[] digits;\n        long[]\
    \ primes;\n        void opAssign(HexPrimesTuple rhs) \n        {\n           \
    \ digits[] = rhs.digits[];\n            primes[] = rhs.primes[];\n        }\n\
    \    }\n    auto hexPrimes = HexPrimesTuple\n    ([0x0, 0x1, 0x2, 0x3, 0x4, 0x5,\
    \ 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF], \n    [0, 0, 2, 3, 0, 5,\
    \ 0, 7, 0, 0, 0, 11, 0, 13, 0, 0]);\n    auto toPrimes = typeof(hexPrimes.digits).array();\n\
    \    foreach(i, num; i++)\n    {\n        if(num[i] >= 'A' && num[i] <= 'F')\n\
    \        {\n            toPrimes[num[i]-'A'+10] = 1;\n        }\n        else\
    \ if(num[i] >= '0' && num[i] <= '9')\n        {\n            toPrimes[num[i]-'0']\
    \ = 1;\n        }\n    }\n    long count = 0;\n    foreach(i, toPrimes; i++)\n\
    \    {\n        if(toPrimes[i] != 0) count++;\n    }\n    return count;\n}", "{\n\
    \    import std.algorithm;\n    import std.conv;\n    import std.range;\n    import\
    \ std.algorithm : count;\n    import std.typecons : Tuple;\n    import std.math\
    \ : isPrime;\n    import std.string : toUpper;\n    import std.array : slice;\n\
    \    import std.stdio : writeln;\n    import std.math : pow;\n    import std.typecons\
    \ : Tuple;\n    import std.range : iota;\n    import std.algorithm : sort;\n \
    \   import std.conv : to;\n    import std.string : strip;\n    import std.string\
    \ : join;\n    string hex_digits = \"0123456789ABCDEF\";\n    long res = 0;\n\
    \    foreach(i, x; num.toUpper().strip().split(\"\")){\n        long n = hex_digits.indexOf(x);\n\
    \        if(n.isPrime){\n            res += 1;\n        }\n    }\n    return res;\n\
    }", "{\n    auto hexes = \"0123456789ABCDEF\";\n    long result = 0;\n    foreach(char\
    \ hex; num)\n    {\n        if(hexes.indexOf(hex) == -1)\n            throw new\
    \ Exception(\"not correct hexadecimal number\");\n        long v = hexes.indexOf(hex);\n\
    \        if(v==1 || v==3 || v==5 || v==7 || v==11 || v==13)\n            result++;\n\
    \    }\n    return result;\n}", "{\n    long res=0;\n    long n=0;\n    foreach(immutable\
    \ c;num)\n    {\n        //cout.format(\"%c\",c);\n        if(c=='0'||c=='1'||c=='2'||c=='3'||c=='4'||c=='5'||c=='6'||c=='7'||c=='8'||c=='9')\n\
    \        {\n            n=c-'0';\n        }\n        else\n        {\n       \
    \     n=c-'A'+10;\n        }\n        //cout.format(\"%d\",n);\n        if(isPrime(n))\n\
    \        {\n            res++;\n        }\n    }\n    return res;\n}", "{\n  \
    \  long sum = 0;\n    const string primeNumbers = \"2357BD\";\n    foreach(n;\
    \ num)\n    {\n        if(primeNumbers.canFind(n))\n        {\n            sum++;\n\
    \        }\n    }\n    return sum;\n}", "{\n    long n = 0;\n    int primeNumber\
    \ = 0;\n    foreach(hex, num)\n    {\n        n = hex - '0';\n        if (n >\
    \ 9)\n            n = hex - 'A' + 10;\n        if (n == 2 || n == 3 || n == 5\
    \ || n == 7 || n == 11 || n == 13)\n            primeNumber++;\n    }\n    return\
    \ primeNumber;\n}", "{\n    long[] numbers = [2, 3, 5, 7, 11, 13];\n    long count\
    \ = 0;\n    foreach(i; numbers)\n    {\n        if(num.count(i.to!string()))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long len = num.length;\n    long primes = 0;\n    string digits = \"0123456789ABCDEF\"\
    ;\n    for (int i = 0; i < len; i++)\n    {\n        //std.conv.format(\"%c =\
    \ %d\\n\", num[i], digits.find(num[i]));\n        if (digits.find(num[i]) == 2\
    \ || digits.find(num[i]) == 3 || digits.find(num[i]) == 5 || digits.find(num[i])\
    \ == 7 || digits.find(num[i]) == 11 || digits.find(num[i]) == 13)\n        {\n\
    \            primes++;\n        }\n    }\n    return primes;\n}", "{\n    // string\
    \ hex = toUpper(num);\n    size_t count = 0;\n    foreach(hex;num)\n    {\n  \
    \      count +=  isPrime(to!int(hex));\n    }\n    return count;\n}", "{\n   \
    \ // Type alias\n    alias Digit = ubyte;\n    // Integer literal representing\
    \ all digits\n    auto all = 0x0123456789ABCDEF;\n    // Bit flag to tell if a\
    \ digit is a prime\n    static immutable bit isPrime = all.map!(\n        (Digit\
    \ x) => !x.isPrime\n    ).array;\n    // Bit flag to tell if a digit is a prime\n\
    \    static immutable bit isPrime = all.map!(\n        (Digit x) => !x.isPrime\n\
    \    ).array;\n    // Bit flag to tell if a digit is a prime\n    static immutable\
    \ bit isPrime = all.map!(\n        (Digit x) => !x.isPrime\n    ).array;\n   \
    \ // Bit flag to tell if a digit is a prime\n    static immutable bit isPrime\
    \ = all.map!(\n        (Digit x) => !x.isPrime\n    ).array;\n    // Bit flag\
    \ to tell if a digit is a prime\n    static immutable bit isPrime = all.map!(\n\
    \        (Digit x) => !x.isPrime\n    ).array;\n    // Bit flag to tell if a digit\
    \ is a prime\n    static immutable bit isPrime = all.map!(\n        (Digit x)\
    \ => !x.isPrime\n    ).array;\n    // Bit flag to tell if a digit is a prime\n\
    \    static immutable bit isPrime = all.map!(\n        (Digit x) => !x.isPrime\n\
    \    ).array;\n    // Bit flag to tell if a digit is a prime\n    static immutable\
    \ bit isPrime = all.map!(\n        (Digit x) => !x.isPrime\n    ).array;\n   \
    \ // Bit flag to tell if a digit is a prime\n    static immutable bit isPrime\
    \ = all.map!(\n        (Digit x) => !x.isPrime\n    ).array;\n    // Bit flag\
    \ to tell if a digit is a prime\n    static immutable bit isPrime = all.map!(\n\
    \        (Digit x) => !x.isPrime\n    ).array;\n    // Bit flag to tell if a digit\
    \ is a prime\n    static immutable bit isPrime = all.map!(\n        (Digit x)",
  "{\n    enum hex_to_dec = [\n        ('0', 0), ('1', 1), ('2', 2), ('3', 3), ('4',\
    \ 4), ('5', 5), ('6', 6), ('7', 7),\n        ('8', 8), ('9', 9), ('A', 10), ('B',\
    \ 11), ('C', 12), ('D', 13), ('E', 14), ('F', 15)\n    ];\n    assert(num.length\
    \ >= 1 && num.length <= 16, \"input is not valid\");\n    long counter = 0;\n\
    \    size_t len = num.length;\n    for (size_t i = 0; i < len; i++)\n    {\n \
    \       auto v = num[i];\n        auto [_, dec_v] = hex_to_dec[v];\n        if\
    \ (dec_v == 2 || dec_v == 3 || dec_v == 5 || dec_v == 7 || dec_v == 11 || dec_v\
    \ == 13)\n        {\n            counter++;\n        }\n    }\n    return counter;\n\
    }", "{\n    long ret = 0;\n    bool isprime;\n    int digit;\n    foreach(ch;\
    \ num)\n    {\n        isprime = true;\n        if (ch>='A')\n            digit\
    \ = 10 + ch - 'A';\n        else\n            digit = ch - '0';\n        // digit\
    \ is the number to check\n        foreach(divisor; 2..(int)(sqrt(digit) + 1))\n\
    \        {\n            if (digit % divisor == 0)\n            {\n           \
    \     isprime = false;\n                break;\n            }\n        }\n   \
    \     if (isprime)\n            ret += 1;\n    }\n    return ret;\n}", "{\n  \
    \  long sum = 0;\n    auto find = false;\n    foreach(ch;num)\n    {\n       \
    \ if(ch == 'A' || ch == 'B' || ch == 'D' || ch == '2' || ch == '3' || ch == '5'\
    \ || ch == '7')\n        {\n            find = true;\n        }\n        else\n\
    \        {\n            find = false;\n        }\n        if(find)\n        {\n\
    \            sum += 1;\n        }\n    }\n    return sum;\n}", "{\n    long cnt\
    \ = 0;\n    foreach(immutable c; num)\n    {\n        if(c in \"2357BDF\")\n \
    \           cnt++;\n    }\n    return cnt;\n}", "{\n    long result = 0;\n   \
    \ foreach(num; dchar v) \n    {\n        if(dchar.isDigit(v)) \n        {\n  \
    \          if(dchar.toDigit(v)<=7) \n            {\n                result++;\n\
    \            }\n        } \n        else \n        {\n            switch(v) \n\
    \            {\n                case 'B':\n                case 'D':\n       \
    \             result++;\n                    break;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*\nimport std.stdio;\nimport std.string;\nimport\
    \ std.conv;\nimport std.math;\nimport std.typecons;\nimport std.algorithm;", "{\n\
    \    long answer = 0;\n    long num_length = num.length;\n    char[] num_chars\
    \ = num.toUpperArray();\n    bool[] is_prime = [2L, 3L, 5L, 7L, 11L, 13L, 17L,\
    \ 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L,\
    \ 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L, 149L, 151L,\
    \ 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L, 223L, 227L,\
    \ 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L, 283L, 293L,\
    \ 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L, 373L, 379L,\
    \ 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L, 449L, 457L,\
    \ 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L, 541L, 547L,\
    \ 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L, 617L, 619L,\
    \ 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L, 701L, 709L,\
    \ 719L, 727L, 733L, 739L, 743L, 751L, 757L, 761L, 769L, 773L, 787L, 797L", "{\n\
    \    long ret = 0;\n    //char[] hx = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\
    \    int[] px = {2,3,5,7,11,13};\n    for(char c : num)\n    {\n        // immutable(int)\
    \ x = to!int(c);\n        // if(x.isIn(px)) ret++;\n        int x = cast(int)c;\n\
    \        foreach(inout int p; px)\n        {\n            if(x == p) ret++;\n\
    \        }\n    }\n    return ret;\n}", "{\n    long res = 0;\n    long[] primes\
    \ = [2, 3, 5, 7, 11, 13];\n    long[] dec = [10, 11, 12, 13, 14, 15];\n    dchar[]\
    \ hex = ['A', 'B', 'C', 'D', 'E', 'F'];\n    auto hex_digit = num.transitionTo!(dchar)().map!(a\
    \ => a.toUpper());\n    auto isPrime = hex_digit.map!(a => \n        a.isDigit\
    \ ? a - '0' : dec[hex.indexOf(a)]).map!(b => \n            b < 17 && primes.canFind(b)).map!(c\
    \ => if (c) { \n                res++; \n            } else { \n             \
    \   return; \n            });\n    isPrime.walkLength;\n    return res;\n}", "{\n\
    \    long ret = 0;\n    for (auto elem : num) {\n        int tmp = elem;\n   \
    \     if (tmp == '0' || tmp == '1')\n            continue;\n        if (tmp >\
    \ '9')\n            tmp -= 7;\n        if (isPrime(tmp))\n            ret++;\n\
    \    }\n    return ret;\n}\n/*\nWrite a function that receives two parameters.\
    \ The first is a sequence of \n    integers, the second a number. The function\
    \ should return an iterator\n    to the first element which is equal to the given\
    \ number or the end iterator\n    if there is no such element.\n    The expected\
    \ time complexity of this function is O(log(N)).\n    Examples:\n    >>> search([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10], 4)\n    [3]\n    >>> search([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10], 10)\n    [9]\n    >>> search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\
    \ 11)\n    [10]\n    >>> search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7)\n    [6]\n\
    \    >>> search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0)\n    [0]\n    >>> search([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10], 9)\n    [8]\n    >>> search([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10], 1)\n    [0]\n    >>> search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8)\n\
    \    [7]\n    >>> search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2)\n    [1]\n    >>>\
    \ search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n    [2]\n    >>> search([1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10], 4)\n", "{\n    string primes = \"2357BD\";\n    int c\
    \ = 0;\n    foreach(i; num) {\n        if(primes.canFind(i)) {\n            c++;\n\
    \        }\n    }\n    return c;\n}\n/*\nYour task is to write a function that\
    \ \n    simulates an elevator.\n    It will take 2 parameters:\n        people:\
    \ a 2D array of people's weights. You can imagine this is a \n        queue of\
    \ pairs in the form (weight, destination floor)\n        max_people: the maximum\
    \ number of people allowed in the elevator.\n        It will return an array of\
    \ 2 elements. The first element is the \n        list of people's final destinations.\
    \ The second element is the \n        list of floors where the elevator stopped.\n\
    \    Rules:\n        The elevator can only stop at floors where people want to\
    \ get off \n        or where people want to get in\n        The elevator can't\
    \ exceed the maximum number of people\n        If the elevator can't move (because\
    \ of the number of people), \n        return \"Stuck!\".\n        If the elevator\
    \ can't move (because of maximum weight), \n        return \"Crashed!\".\n   \
    \ Example:\n    >>> elevator([(60, 0), (80, 1), (40, 2)], 2)\n    [(0, 1), (2,)]\n\
    \    >>> elevator([(60, 0), (80, 1), (40, 2)], 1)\n    \"Crashed!\"\n    >>> elevator([(60,\
    \ 0), (40, 2), (80, 1)], 2)\n    [(0,), (2, 1)]\n    >>> elevator([(60, 2), (80,\
    \ 3), (40, 4)], 1)\n    \"Stuck!\"\n*/\nauto elevator(int[][] people, int max_people)\
    \ \n{\n    int current_floor = 0;\n    int[][] elevator_people = [];\n    int[]\
    \ elev_destinations = [];\n    int[] trip_destinations = [];\n    foreach(p; people)\
    \ {\n        int i = p[0];\n        int f = p[1];\n        if(elevator_people.length\
    \ < max_people) {\n            trip_destinations ~= f;\n", "{\n    //long result\
    \ = 0;\n    //return result;\n    //long result = 0;\n    int[] primes = [2, 3,\
    \ 5, 7, 11, 13];\n    //return length(primes);\n    auto hex_to_decimal = to!long(num,\
    \ 16);\n    //return hex_to_decimal;\n    int count = 0;\n    foreach(digit; hex_to_decimal)\n\
    \    {\n        if(digit in primes)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}", "{\n    size_t count = 0;\n    bool isPrime(int\
    \ n)\n    {\n        if (n < 2) return false;\n        for (int i = 2; i <= sqrt(n);\
    \ i++)\n        {\n            if (n % i == 0)\n                return false;\n\
    \        }\n        return true;\n    }\n    foreach(c; num)\n    {\n        if\
    \ (isPrime(c.to!int))\n            count++;\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    const size_t len = num.length;\n    for (size_t i =\
    \ 0; i < len; i++)\n    {\n        string s = num[i..i+1];\n        if (uint(to!int(s,\
    \ 16)) < 2)\n            continue;\n        bool prime = true;\n        for (uint\
    \ j = 2; j < uint(to!int(s, 16)); j++)\n        {\n            if (uint(to!int(s,\
    \ 16)) % j == 0)\n            {\n                prime = false;\n            \
    \    break;\n            }\n        }\n        if (prime)\n            count++;\n\
    \    }\n    return count;\n}", "{\n    long[] primes = [2, 3, 5, 7, 11, 13];\n\
    \    long[] hexLetters = [10, 11, 12, 13, 14, 15];\n    long[] nums = ['0', '1',\
    \ '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n   \
    \ long[] numsAndLetters = concatenate(nums, hexLetters);\n    char[] numbers =\
    \ to!char[](num);\n    long[] index = [];\n    for (long i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (long j = 0; j < numsAndLetters.length; j++)\n    \
    \    {\n            if (numbers[i] == cast(char)numsAndLetters[j])\n         \
    \   {\n                index ~= j;\n            }\n        }\n    }\n    long\
    \ count = 0;\n    for (long i = 0; i < index.length; i++)\n    {\n        for\
    \ (long j = 0; j < primes.length; j++)\n        {\n            if (index[i] ==\
    \ primes[j])\n            {\n                count++;\n            }\n       \
    \ }\n    }\n    return count;\n}", "{\n    return reduce!((a,b) => a + isPrime!(to!long(b,\
    \ 16)))(0L, filter!(a => to!long(a, 16) > 1)(num.dup));\n}", "{\n    static immutable\
    \ auto convert2 = tuple(\n        \"FEDCBA9876543210\",\n        [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n\
    \    );\n    immutable auto[hex,vals] = convert2;\n    long ans = 0;\n    foreach(immutable\
    \ ch;num)\n    {\n        immutable index = hex.indexOf(ch);\n        ans += vals[index];\n\
    \    }\n    return ans;\n}\n/*\nWrite a function that takes a list of integers\
    \ and returns a list \nof distinct elements from the list.\ndistinct_int_list([1,2,3,3,2,1])\
    \ == [1,2,3]\ndistinct_int_list([]) == []\ndistinct_int_list([-1,-1]) == [-1]\n\
    */", "{\n    auto hex_digit = [](in char c) inout @safe pure nothrow\n    {\n\
    \        if (c >= '0' && c <= '9') return c - '0';\n        else if (c >= 'A'\
    \ && c <= 'F') return c - 'A' + 10;\n        else return -1;\n    };\n    long\
    \ sum = 0;\n    bool isPrime = false;\n    string primes = \"1357BD\";\n    foreach\
    \ (i, c; num)\n    {\n        if (hex_digit(c) == -1)\n            continue;\n\
    \        foreach (p; primes)\n        {\n            if (c == p)\n           \
    \ {\n                isPrime = true;\n                break;\n            }\n\
    \        }\n        if (isPrime)\n        {\n            sum++;\n            isPrime\
    \ = false;\n        }\n    }\n    return sum;\n}", "{\n    static long[] primes\
    \ = [2, 3, 5, 7, 11, 13];\n    long res = 0;\n    char[] a = to!char[](num);\n\
    \    foreach(c; a) \n    {\n        if(primes.indexOf(to!long(c, 16)) != -1) \n\
    \        {\n            res++;\n        }\n    }\n    return res;\n}\n/*\n   \
    \ Create a function called validStrings(string s) that takes a string s, \n  \
    \  and determines if it is valid or not.\n    A string is valid when it has the\
    \ same number of 'x's and 'o's, \n    and the cases are all the same. If the cases\
    \ are different, it should \n    return false.\n    Examples:\n    >>> validStrings(\"\
    XXOo\")\n    true\n    >>> validStrings(\"xxoo\")\n    true\n    >>> validStrings(\"\
    XXoo\")\n    false\n    >>> validStrings(\"XXOO\")\n    false\n    >>> validStrings(\"\
    xxoo\")\n    true\n    >>> validStrings(\"\")\n    true\n*/", "{\n\tlong count\
    \ = 0;\n\tauto hex = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\
    \ \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n\tfor (int i = 0;\
    \ i < num.length; i++)\n\t{\n\t\tif (hex[11] == num[i] || hex[13] == num[i] ||\
    \ hex[2] == num[i] || hex[3] == num[i] || hex[5] == num[i] || hex[7] == num[i])\n\
    \t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    int[] primes =\
    \ new int[9];\n    primes[0] = 2;\n    primes[1] = 3;\n    primes[2] = 5;\n  \
    \  primes[3] = 7;\n    primes[4] = 11;\n    primes[5] = 13;\n    //primes[6] =\
    \ 17;\n    //primes[7] = 19;\n    //primes[8] = 23;\n    int count = 0;\n    string\
    \ hexChars = \"0123456789ABCDEF\";\n    //char[] hexChars = new char[16];\n  \
    \  //for (int i = 0; i < hexChars.length; i++) \n    //{\n    //    hexChars[i]\
    \ = (char)('0' + i);\n    //}\n    for (int i = 0; i < num.length; i++) \n   \
    \ {\n        char c = num[i];\n        int j = 0;\n        for (j = 0; j < hexChars.length;\
    \ j++) \n        {\n            if (c == hexChars[j]) \n            {\n      \
    \          break;\n            }\n        }\n        for (int k = 0; k < primes.length;\
    \ k++) \n        {\n            if (j == primes[k]) \n            {\n        \
    \        count++;\n                break;\n            }\n        }\n    }\n \
    \   return count;\n}", "{\n    long result = 0;\n    string binary = \"\";\n \
    \   for (int i = 0; i < num.length; i++)\n    {\n        int iNum = hexToDec(num[i]);\n\
    \        binary = to!string(iNum, 2);\n        if (isPrime(iNum))\n        {\n\
    \            result++;\n        }\n    }\n    return result;\n}", "{\n    // Best\
    \ practices\n    long counter = 0;\n    int[] primeHexList = [2, 3, 5, 7, 11,\
    \ 13];\n    foreach(char c; num)\n    {\n        foreach(int prime; primeHexList)\n\
    \        {\n            if(c == to!string(prime)[0])\n            {\n        \
    \        counter++;\n            }\n        }\n    }\n    return counter;\n}",
  "{\n\tstatic int[] primes = [2, 3, 5, 7, 11, 13];\n\tstring letters = \"ABCDEF\"\
    ;\n\treturn num.filter!(n => n >= 'A' && n <= 'F' ? (n - 'A' + 10) in primes :\n\
    \t\t\t\t\t\t\t\t\t\t\t\t   (n - '0') in primes).length;\n}", "{\n     return num.filter!isPrime.length;\n\
    }", "{\n    long result = 0;\n    for (long i = 0; i < num.length; i++)\n    {\n\
    \        result += std.math.isPrime(to!int(num[i], 16)) ? 1 : 0;\n    }\n    return\
    \ result;\n}\n/*\npublic const (\n    _ = iota;\n    KB = 1 << (10 * iota);\n\
    \    MB;\n    GB;\n    TB;\n    PB;\n    EB;\n    ZB;\n    YB;\n)\n*/\nimport\
    \ std.stdio;\n/*\nYou have been tasked to write a function that receives \n  \
    \  a floating point number as a string (scale) and returns the \n    approximate\
    \ storage capacity of digital information using units \n    of byte (B), kilobyte\
    \ (KB), megabyte (MB), gigabyte (GB), \n    terabyte (TB), petabyte (PB), exabyte\
    \ (EB), zettabyte (ZB), \n    and yottabyte (YB).\n    The scale should follow\
    \ the International System of Units \n    (SI) (https://en.wikipedia.org/wiki/International_System_of_Units)\
    \ \n    naming rules and standards (i.e. 1kB = 10^3B instead of \n    1kB = 2^10B)\
    \ and should be treated as an integer.\n    For simplicity, all units should be\
    \ treated as integers \n    while converting.\n    Examples:\n    >>> info(\"\
    10\")\n    \"10 B\"\n    >>> info(\"100\")\n    \"100 B\"\n    >>> info(\"1000\"\
    )\n    \"1 kB\"\n    >>> info(\"1001\")\n    \"1 kB\"\n    >>> info(\"1000000\"\
    )\n    \"1 MB\"\n    >>> info(\"1000000000\")\n    \"1 GB\"\n    >>> info(\"1000000000000\"\
    )\n    \"1 TB\"\n    >>> info(\"1000000000000000\")\n    \"1 PB\"\n    >>> info(\"\
    1000000000000000000\")\n    \"1 EB\"\n    >>> info(\"1000000000000000000000\"\
    )\n    \"1 ZB\"\n    >>> info(\"1000000000000000000000000\")\n    \"1 YB\"\n*/\n\
    string info(string scale) \n{\n    return to!string(to!double", "{\n    long result=0;\n\
    \    long [] hexDigits={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n    string []\
    \ hexPrimes={\"2\",\"3\",\"5\",\"7\",\"B\",\"D\"};\n    foreach(d;num)\n    {\n\
    \        bool isHexPrime=false;\n        foreach(p;hexPrimes)\n        {\n   \
    \         if(d==p)\n            {\n                isHexPrime=true;\n        \
    \        break;\n            }\n        }\n        if(isHexPrime)\n        {\n\
    \            result++;\n        }\n    }\n    return result;\n}", "{\n    auto\
    \ hex_digits = \"0123456789ABCDEF\";\n    auto is_prime = (int n)\n    {\n   \
    \     if (n < 2) return false;\n        if (n == 2) return true;\n        if (n\
    \ % 2 == 0) return false;\n        foreach (i; 3..(n-1))\n        {\n        \
    \    if (n % i == 0) return false;\n        }\n        return true;\n    };\n\
    \    auto to_integer = (char c) { return c - '0'; };\n    auto to_hex_integer\
    \ = (char c)\n    {\n        auto pos = hex_digits.indexOf(c);\n        return\
    \ pos == -1 ? null : to!int(pos);\n    };\n    auto to_decimal = (string hex_num)\n\
    \    {\n        auto result = 0;\n        for (auto i = 0; i < hex_num.length;\
    \ i++)\n        {\n            auto digit = to_hex_integer(hex_num[i]);\n    \
    \        if (digit == null) return null;\n            result += digit * int(pow(16.0,\
    \ cast(double)i));\n        }\n        return result;\n    };\n    return num.filter!(c\
    \ => is_prime(to_decimal(c))).length;\n}", "{\n\tauto digits = num.split;\n\t\
    long res = 0;\n\tforeach(digit; digits)\n\t{\n\t\tif(digit.length == 0)\n\t\t\t\
    continue;\n\t\tauto n = digit.representation;\n\t\tif(n == 'A' || n == 'B' ||\
    \ n == 'D')\n\t\t\tres += 1;\n\t\telse if(n == '2' || n == '3' || n == '5' ||\
    \ n == '7')\n\t\t\tres += 1;\n\t}\n\treturn res;\n}", "{\n    long count = 0;\n\
    \    for (long i = 0; i < num.length; i++)\n    {\n        if (num[i] == '2' ||\
    \ num[i] == '3' || num[i] == '5' || num[i] == '7' ||\n            num[i] == 'B'\
    \ || num[i] == 'D')\n        {\n            count += 1;\n        }\n    }\n  \
    \  return count;\n}\n/*\n    You have been tasked to create a keycode to pass\
    \ a special door. \n    The keycode is a decimal number, but the door only accepts\
    \ \n    keycodes that are the sum of consecutive prime numbers.\n    Example:\n\
    \    >>> door_keys(\"12\")\n    2L\n    >>> door_keys(\"7\")\n    0L\n    >>>\
    \ door_keys(\"20\")\n    2L\n    >>> door_keys(\"10000\")\n    1L\n    >>> door_keys(\"\
    100000\")\n    0L\n*/", "{\n    long count = 0;\n    bool[] tab = [true, false,\
    \ true, true, false, true, false, true, false, false, true, true, false, true,\
    \ false, true];\n    foreach(c; num)\n    {\n        if (tab[to!long(c)])\n  \
    \          count += 1;\n    }\n    return count;\n}", "{\n    long res = 0;\n\
    \    int primes[] = [2, 3, 5, 7, 11, 13];\n    auto primes_set = set(primes);\n\
    \    auto num_set = set(num);\n    foreach(uint i, string ch; zip(i, num)) {\n\
    \        if(ch in primes_set)\n            res++;\n    }\n    return res;\n}",
  "{\n    \n    import std.algorithm : count;\n    import std.conv : to;\n    import\
    \ std.range : filter;\n    auto toDigit = (alias A) => to!A;\n    auto toDigit16\
    \ = toDigit!long;\n    auto hexDigits = num.map!toDigit16.filter!(x => x < 16);\n\
    \    return hexDigits.count!(x => x.isPrime);\n}", "{\n    long count = 0;\n \
    \   long digits = 6;\n    int[char] num_map = [\"0\":0, \"1\":1, \"2\":2, \"3\"\
    :3, \"4\":4, \"5\":5, \"6\":6, \"7\":7, \"8\":8, \"9\":9, \"A\":10, \"B\":11,\
    \ \"C\":12, \"D\":13, \"E\":14, \"F\":15];\n    for(int i = 0; i < num.length;\
    \ i++) \n    {\n        auto res = num_map[num[i]];\n        if(res > digits)\
    \ \n        {\n            if(isPrime(res)) \n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}", "{\n    long i = 0;\n\
    \    long count = 0;\n    string digit;\n    size_t len = num.length;\n    while\
    \ (i < len)\n    {\n        digit = num[i];\n        if (digit.in([\"2\", \"3\"\
    , \"5\", \"7\", \"B\", \"D\"]))\n        {\n            count++;\n        }\n\
    \        i++;\n    }\n    return count;\n}", "{\n    long res = 0;\n    if(num.length\
    \ == 0) return res;\n    foreach(i; 0 .. num.length)\n    {\n        auto c =\
    \ num[i];\n        switch(c)\n        {\n            case '2': case '3': case\
    \ '5': case '7':\n            case 'B': case 'D':\n                res++;\n  \
    \              break;\n            default:\n                break;\n        }\n\
    \    }\n    return res;\n}", "{\n    // write your solution here\n    long result\
    \ = 0;\n    bool[] primenumbers = new bool[16];\n    primenumbers[2] = true;\n\
    \    primenumbers[3] = true;\n    primenumbers[5] = true;\n    primenumbers[7]\
    \ = true;\n    primenumbers[11] = true;\n    primenumbers[13] = true;\n    long\
    \ index = 0;\n    string temp = num.toUpper();\n    for(long i = 0; i < temp.length;\
    \ i++)\n    {\n        if(temp[i] >= '0' && temp[i] <= '9') index = temp[i] -\
    \ '0';\n        else index = temp[i] - 'A' + 10;\n        if(primenumbers[index])\
    \ result++;\n    }\n    return result;\n}", "{\n    long res = 0;\n    long length\
    \ = num.length;\n    long[] a = new long[length];\n    for (long i = 0; i < length;\
    \ i++) \n    {\n        a[i] = to!int(num[i]);\n    }\n    foreach (l; a) \n \
    \   {\n        if (l in (2, 3, 5, 7, 11, 13)) \n        {\n            res +=\
    \ 1;\n        }\n    }\n    return res;\n}", "{\n    long result = 0;\n    long[]\
    \ hex_primes = [ 2, 3, 5, 7, 11, 13 ];\n    for (int i = 0; i < num.length; i++)\n\
    \    {\n        ubyte c = num[i];\n        if (c >= 'A' && c <= 'F')\n       \
    \ {\n            auto idx = cast(ulong) (c - 'A' + 10);\n            if (hex_primes.front\
    \ <= idx && idx <= hex_primes.back)\n            {\n                result++;\n\
    \            }\n        }\n        else if (c >= '0' && c <= '9')\n        {\n\
    \            auto idx = cast(ulong) (c - '0');\n            if (hex_primes.front\
    \ <= idx && idx <= hex_primes.back)\n            {\n                result++;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    long res = 0;\n\
    \    long x;\n    int i = 0;\n    foreach(char c; num)\n    {\n        x = cast(long)c;\n\
    \        if(('0' <= x && x <= '9') || ('A' <= x && x <= 'F'))\n        {\n   \
    \         if(i < 2 || i == 11 || i == 13) \n                res++;\n        }\n\
    \        i++;\n    }\n    return res;\n}\n/*\n    Given a digit (between 1 and\
    \ 9), return a string that describes \n    the number in English. For example,\
    \ given the digit 5, the function \n    should return \"five\". The string should\
    \ use plural words when appropriate.\n    Examples:\n    >>> number_name(5)\n\
    \    \"five\"\n    >>> number_name(0)\n    \"zero\"\n    >>> number_name(1)\n\
    \    \"one\"\n    >>> number_name(9)\n    \"nine\"\n    >>> number_name(10)\n\
    \    \"one zero\"\n    >>> number_name(100)\n    \"one zero zero\"\n    >>> number_name(11)\n\
    \    \"one one\"\n    >>> number_name(21)\n    \"two one\"\n    >>> number_name(32)\n\
    \    \"three two\"\n    >>> number_name(123)\n    \"one two three\"\n    >>> number_name(12345)\n\
    \    \"one two three four five\"\n    >>> number_name(10000)\n    \"one zero zero\
    \ zero zero\"\n    >>> number_name(123456789)\n    \"one two three four five six\
    \ seven eight nine\"\n    >>> number_name(1234567890)\n    \"one two three four\
    \ five six seven eight nine zero\"\n    >>> number_name(12345678901)\n    \"one\
    \ two three four five six seven eight nine zero one\"\n    >>> number_name(123456789012)\n\
    \    \"one two three four five six seven eight nine zero one two\"\n    >>> number_name(9876543210)\n\
    \    \"nine eight seven six five four three two one zero\"\n*/\nstring number_name(long\
    \ num)\n{\n    if(num == 0)\n       ", "{\n    // .input and .output in the description\
    \ are real. \n    // and char to int is faster than toString\n    long[] primes\
    \ = [2, 3, 5, 7, 11, 13];\n    long sum = 0;\n    foreach(i; 0 .. num.length)\n\
    \    {\n        if(std.algorithm.find(primes, num[i]))\n            sum++;\n \
    \   }\n    return sum;\n}", "{\n    bool is_prime(int n) \n    {\n        if (n\
    \ < 2) \n            return false;\n        else if (n == 2) \n            return\
    \ true;\n        else if (n % 2 == 0) \n            return false;\n        else\
    \ \n        {\n            for (int i = 3; i <= trunc(sqrt(n)); i += 2) \n   \
    \         {\n                if (n % i == 0) \n                    return false;\n\
    \            }\n            return true;\n        }\n    }\n    if (num.empty)\
    \ \n        return 0;\n    int n = to!int(num, 16);\n    return count!(is_prime(i)\
    \ for i in iota(15));\n}", "{\n    static auto is_prime = [](int n)\n    {\n \
    \       return n > 1 && \n            all!((i) => (n % i) != 0, \n           \
    \     iota(2, cast(int) cast(float) sqrt(n) + 1));\n    };\n    static auto is_prime_hex\
    \ = [](long num)\n    {\n        return num > 1 && \n            all!((i) => (num\
    \ % i) != 0, \n                chain(iota(2, 6),\n                    iota(7,\
    \ cast(int) cast(float) sqrt(num) + 1, 6)));\n    };\n    static auto is_prime_hex16\
    \ = [](ulong num)\n    {\n        static auto small_primes = [](size_t n)\n  \
    \      {\n            static auto is_prime = [](size_t n)\n            {\n   \
    \             return n > 1 && \n                    all!((i) => (n % i) != 0,\
    \ \n                        iota(2, cast(int) cast(float) sqrt(n) + 1));\n   \
    \         };\n            static auto test = [](size_t n)\n            {\n   \
    \             return all!((i) => is_prime(i), \n                    iota(n + 1,\
    \ (n + 1) * 2));\n            };\n            static auto result = test(101);\n\
    \            return result[n - 1];\n        };\n        return num > 1 && small_primes(num);\n\
    \    };\n    return map!(a => a >= '0' && a <= '9' ? \n        a - '0' :\n   \
    \     (a >= 'A' && a <= 'F' ? \n            a - 'A' + 10 :\n            throw\
    \ new Exception(\"not hex\"))\n        )(num)\n        .map!((num) => num < 10\
    \ ? \n            is_prime(num) : \n            is_prime_hex(num))\n        .count;\n\
    \    // return map!(a => (a >= '0' && a <= '9' ? \n    //     a - '0' :\n    //\
    \     (a >= 'A' && a <= 'F' ? \n", "{\n    long result = 0;\n    if(num.length\
    \ == 0) \n    {\n        return result;\n    }\n    foreach(char c; num) \n  \
    \  {\n        if(c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c\
    \ == 'D') \n        {\n            result++;\n        }\n    }\n    return result;\n\
    }", "{\n    enum bool:bool[]\n    {\n        false=false,\n        true=true\n\
    \    }\n    enum bool:int[]\n    {\n        true=1,\n        false=0\n    }\n\
    \    int i;\n    bool[] is_prime;\n    int[] lookup;\n    i = 2;\n    while (i\
    \ < 17) {\n        if (i <= 2 || i % 2 != 0 && i % 3 != 0 && i % 5 != 0 && i %\
    \ 7 != 0) {\n            is_prime[i] = true;\n        }\n        i += 1;\n   \
    \ }\n    i = 10;\n    while (i < 17) {\n        lookup[i] = is_prime[i];\n   \
    \     i += 1;\n    }\n    auto result = 0;\n    foreach (c; num) {\n        i\
    \ = c;\n        if ('A' <= i && i <= 'F') {\n            i -= 55;\n        } else\
    \ {\n            i -= 48;\n        }\n        result += lookup[i];\n    }\n  \
    \  return result;\n}", "{\n  long res = 0;\n  foreach(i;0..num.length)\n    if\
    \ ( num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i]\
    \ == 'B' || num[i] == 'D' )\n      res++;\n  return res;\n}\n//******************************************************************************\n\
    /*\nYou have been tasked to write a function that determines a number of \n  \
    \  digits of a factorial number, factorial is described in details \n    here.\n\
    \    Example:\n    >>> digit_num(5)\n    3L\n    >>> digit_num(12)\n    7L\n \
    \   >>> digit_num(150)\n    183L\n    >>> digit_num(8)\n    19L\n    >>> digit_num(0)\n\
    \    1L\n*/\nlong digit_num(long num) \n{\n  if ( num == 0 ) return 1;\n  double\
    \ res = 0;\n  foreach(i; 1..num+1) res += log10(i);\n  return cast(long) res +\
    \ 1;\n}\n//******************************************************************************\n\
    /*\nYou have been tasked to write a function that determines a number of \n  \
    \  distinct digits of the factorial number.\n    Example:\n    >>> digit_num_distinct(5)\n\
    \    2L\n    >>> digit_num_distinct(12)\n    5L\n    >>> digit_num_distinct(150)\n\
    \    10L\n    >>> digit_num_distinct(8)\n    5L\n    >>> digit_num_distinct(0)\n\
    \    1L\n*/\nlong digit_num_distinct(long num) \n{\n  if ( num == 0 ) return 1;\n\
    \  auto fact = [](long n)\n  {\n    if ( n == 0 ) return 1;\n    long res = 1;\n\
    \    foreach(i; 1..n+1) res *= i;\n    return res;\n  };\n  long res = 0;\n  string\
    \ s = fact(num).to!string;\n  return s.count_if(i => s.find(i) == s.count_", "{\n\
    \    import std.string : startsWith;\n    import std.conv : to, text;\n    import\
    \ std.array : sort;\n    import std.algorithm : count;\n    import std.math :\
    \ isPrime;\n    enum a = Tuple!(string, '1', '2', '3', '4', '5', '6', '7', '8',\
    \ '9', 'A', 'B', 'C', 'D', 'E', 'F');\n    if (num.length > 0)\n    {\n      \
    \  int counter = 0;\n        long[] arr = new long[num.length];\n        foreach(i,\
    \ char; num)\n        {\n            if (a.startsWith(char))\n            {\n\
    \                arr[i] = to!long(char);\n            }\n        }\n        arr\
    \ = arr.filter!(x => x > 0).sort();\n        return arr.count!(x => isPrime(x));\n\
    \    }\n    return 0;\n}\n// auto hex_key(string num)\n// {\n//     import std.algorithm.searching\
    \ : endsWith;\n//     import std.conv : to, text;\n//     import std.array : sort;\n\
    //     import std.algorithm : count;\n//     import std.math : isPrime;\n//  \
    \   enum a = Tuple!(string, '2', '3', '5', '7', 'b', 'd');\n//     if (num.length\
    \ > 0)\n//     {\n//         int counter = 0;\n//         long[] arr = new long[num.length];\n\
    //         foreach(i, char; num)\n//         {\n//             if (a.endsWith(char))\n\
    //             {\n//                 arr[i] = to!long(char);\n//             }\n\
    //         }\n//         arr = arr.filter!(x => x > 0).sort();\n//         return\
    \ arr.count!(x => isPrime(x));\n//     }\n//     return 0;\n// }", "{\n    return\
    \ \n    (!num.empty && all(\"0123456789ABCDEF\".canFind(c) && \n        !(\"456789ABCDEF\"\
    .canFind(c)) || c == '0', num));\n}", "{\n    long result = 0;\n    foreach(num.byPair!(x\
    \ => to!int(x)))\n    {\n        if(isPrime(num))\n            result++;\n   \
    \ }\n    return result;\n}", "{ \n  long count = 0;\n  ulong number = to!ulong(num,\
    \ 16);\n  foreach(ulong digit; hexDigits(number)) \n  {\n    if (isPrime(digit))\
    \ \n    {\n      count += 1;\n    }\n  }\n  return count;\n}", "{\n    enum hex_digits\
    \ = \"0123456789ABCDEF\";\n    long count = 0;\n    int number = 0;\n    int indx\
    \ = 0;\n    while(num.length > 0) {\n        indx = hex_digits.find(num[0]);\n\
    \        //writeln(indx);\n        number = indx;\n        if(number > 1) {\n\
    \            bool isPrime = true;\n            for(int i = 2; i < number; i++)\
    \ {\n                if(number % i == 0) {\n                    isPrime = false;\n\
    \                    break;\n                }\n            }\n            if(isPrime)\
    \ {\n                count++;\n            }\n        }\n        num = num[1..$];\n\
    \    }\n    return count;\n}", "{\n\t/*\n\tconst(int) primes = [2, 3, 5, 7, 11,\
    \ 13];\n\tconst(char) hex_nums = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\
    \ '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n\tlong count = 0;\n\tint[] hex_primes =\
    \ [];\n\tint num_index = -1;\n\tint prime_index = -1;\n\t*/\n\t\n\tlong[] primes\
    \ = [2, 3, 5, 7, 11, 13];\n\tchar[] hex_nums = ['0', '1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n\tlong count = 0;\n\t\n\t\
    foreach(hex_num; hex_nums)\n\t{\n\t\tforeach(prime; primes)\n\t\t{\n\t\t\tif(hex_num\
    \ == prime)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    \t/*\n\tforeach(c; num)\n\t{\n\t\tforeach(i; hex_nums)\n\t\t{\n\t\t\tif(c == i)\n\
    \t\t\t{\n\t\t\t\tnum_index = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach(h; primes)\n\
    \t\t{\n\t\t\tif(num_index == h)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\
    }\n\t\n\treturn count;\n\t*/\n\t/*\n\tforeach(c; num)\n\t{\n\t\tforeach(i; hex_nums)\n\
    \t\t{\n\t\t\tif(c == i)\n\t\t\t{\n\t\t\t\thex_primes ~= i;\n\t\t\t}\n\t\t}\n\t\
    }\n\t\n\tforeach(h; hex_primes)\n\t{\n\t\t", "{\n    import std.conv;\n    long\
    \ result = 0;\n    foreach(ch; num) \n    {\n        long x = ch.toupper.to!long(16);\n\
    \        if(x == 2 || x == 3 || x == 5 || x == 7 || x == 11 || x == 13) \n   \
    \     {\n            result += 1;\n        }\n    }\n    return result;\n}\n/*\n\
    \    Given a string with words, you have to return a string \n    with length\
    \ of each word in it, separated by white space.\n    \n    Examples:\n    >>>\
    \ word_lengths(\"Hello world\")\n    \"5 5\"\n    >>> word_lengths(\"Once upon\
    \ a time\")\n    \"4 4 2 3\"\n    >>> word_lengths(\"Lorem ipsum dolor sit amet\"\
    )\n    \"5 5 4 3 4\"\n*/\nstring word_lengths(string str) \n{\n    import std.algorithm.comparison;\n\
    \    string res = str.split.map!(a => a.length.to!string).joiner.joiner;\n   \
    \ return res;\n}\n/*\n    Given two positive integers, write a function to find\
    \ out \n    if two numbers have the same frequency of digits.\n    Your solution\
    \ MUST have the following complexities:\n    Time: O(N)\n    Examples:\n    >>>\
    \ same_frequency(551122,221515)\n    True\n    >>> same_frequency(321142,3212215)\n\
    \    False\n    >>> same_frequency(1212, 2211)\n    True\n*/", "{\n    long counter\
    \ = 0;\n    bool[] isPrime = [true, true, true, true, true, true, true, true,\
    \ true, \n                    true, true, true, true, true, true, true];\n   \
    \ foreach(char d; num)\n    {\n        counter += to!long(d);\n    }\n    return\
    \ counter;\n}\n/*\nstring[] hex_key(string num) \n{\n    long counter = 0;\n \
    \   auto s = num.split(\"\");\n    int[] x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16];\n    foreach(char d; num)\n    {\n        counter += to!long(d);\n\
    \    }\n    return counter;\n}\n*/\n/*\nstring hex_key(string num) \n{\n    long\
    \ counter = 0;\n    auto s = num.split(\"\");\n    for(int i = 0; i < s.length;\
    \ i++)\n    {\n        if(s[i] == \"2\" || s[i] == \"3\" || s[i] == \"5\" || s[i]\
    \ == \"7\" || \n                s[i] == \"B\" || s[i] == \"D\")\n        {\n \
    \           counter++;\n        }\n    }\n    return counter;\n}\n*/\n/*\nlong\
    \ hex_key(string num) \n{\n    long counter = 0;\n    for(int i = 0; i < num.length;\
    \ i++)\n    {\n        if(num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i]\
    \ == '7' || \n                num[i] == 'B' || num[i] == 'D')\n        {\n   \
    \         counter++;\n        }\n    }\n    return counter;\n}\n*/\n/*\nlong hex_key(string\
    \ num) \n{\n    long counter = 0;\n    int[] hexList = ['0', '1', '2', '3', '4',\
    \ '5', '6', '7', '8', '9', 'A', 'B', '", "{\n  long digits = 0;\n  long number\
    \ = to!long(num, 16);\n  while (number > 0) {\n    if(isPrime(number % 16)) digits++;\n\
    \    number /= 16;\n  }\n  return digits;\n}", "{\n    long result = 0;\n    long[]\
    \ primes = [2, 3, 5, 7, 11, 13];\n    long[] hex = ['0', '1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n    for (int i = 0; i <\
    \ num.length; i++) {\n        for (int j = 0; j < primes.length; j++) {\n    \
    \        if (num[i] == hex[primes[j]]) {\n                result++;\n        \
    \    }\n        }\n    }\n    return result;\n}", "{\n    long count = 0;\n  \
    \  foreach(c;num)\n    {\n        switch(c)\n        {\n            case '2':\
    \ case '3': case '5': case '7': case 'B': case 'D':\n                count++;\n\
    \                break;\n            default:\n                break;\n      \
    \  }\n    }\n    return count;\n}", "{\n    long primes = 0;\n    string primeHexes\
    \ = \"2357bd\";\n    foreach(i; num)\n    {\n        auto hex = toUpper(num[i]);\n\
    \        if(hex.length > 1)\n        {\n            return 0;\n        }\n   \
    \     primes += count(primeHexes, hex);\n    }\n    return primes;\n}", "{\n \
    \ /*\n  int i;\n  string temp = \"\";\n  for(i = 0; i < num.length; i++)\n  {\n\
    \    temp = temp ~ \"0x\" ~ to!string(num[i]);\n    if(temp.length == 1)\n   \
    \   temp = temp ~ \"0\";\n  }\n  return to!int(temp);\n  */\n  return to!(int)(\"\
    0x\" ~ num);\n}\nlong hex_key2(string num) \n{\n  /*\n  int i;\n  string temp\
    \ = \"\";\n  for(i = 0; i < num.length; i++)\n  {\n    temp = temp ~ \"0x\" ~\
    \ to!string(num[i]);\n    if(temp.length == 1)\n      temp = temp ~ \"0\";\n \
    \ }\n  return to!int(temp);\n  */\n  return to!(int)(\"0x\" ~ num);\n}", "{\n\
    \    long res = 0;\n    foreach(c;num)\n    {\n        if(c>='A' && c<='F')\n\
    \        {\n            if(c=='B' || c=='D' || c=='F')\n                res++;\n\
    \        }\n        else\n        {\n            if(c%2!=0)\n                res++;\n\
    \        }\n    }\n    return res;\n}", "{\n    int res = 0;\n    for (int i =\
    \ 0; i < num.length; i++)\n    {\n        auto c = num[i];\n        if (c == 'A'\
    \ || c == 'B' || c == 'D')\n            res++;\n        else if (c == '2' || c\
    \ == '3' || c == '5' || c == '7')\n            res++;\n    }\n    return res;\n\
    }\n/*\nYou have been tasked to write a function that receives \n    a positive\
    \ integer number as a string and returns a new \n    string with the same number\
    \ but in a reversed order.\n    Examples:\n    >>> reverse_integer(\"1566\")\n\
    \    \"6651\"\n    >>> reverse_integer(\"153\")\n    \"351\"\n    >>> reverse_integer(\"\
    1234\")\n    \"4321\"\n    >>> reverse_integer(\"54321\")\n    \"12345\"\n   \
    \ >>> reverse_integer(\"1\")\n    \"1\"\n*/\nstring reverse_integer(string num)\
    \ \n{\n    return num.idup.reverse.idup;\n}\n/*\nYou have been tasked to write\
    \ a function that receives a \n    list of strings, each string is comprised of\
    \ digits, \n    and returns a list of integers, where each integer is \n    comprised\
    \ of the digits from the corresponding string.\n    For example:\n    >>> string_to_int([\"\
    123\", \"456\"])\n    [123, 456]\n    >>> string_to_int([\"742\", \"13\", \"9\"\
    ])\n    [742, 13, 9]\n    >>> string_to_int([\"10\", \"100\"])\n    [10, 100]\n\
    \    >>> string_to_int([\"0\", \"0\"])\n    [0, 0]\n*/", "{\n    enum bool is_even(long\
    \ n) { return (n % 2 == 0); }\n    enum bool is_prime(long n) \n    {\n      \
    \  if (n <= 1)\n            return false;\n        else if (n <= 3)\n        \
    \    return true;\n        else if (is_even(n) || n % 3 == 0)\n            return\
    \ false;\n        long i = 5;\n        while (i * i <= n)\n        {\n       \
    \     if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n   \
    \         i += 6;\n        }\n        return true;\n    }\n    enum bool is_hex(in\
    \ char c) \n    {\n        return std.array.array(\"0123456789ABCDEF\").any!(\n\
    \            (in char e) => e == c\n        );\n    }\n    enum bool is_key(in\
    \ char c) \n    {\n        return is_hex(c) && is_prime(hexToInt(c));\n    }\n\
    \    long hex_key(string num) \n    {\n        if (num.empty)\n            return\
    \ 0;\n        else\n            return num.filter!is_key.length;\n    }\n}", "{\n\
    \    int z = num.length;\n    int a;\n    long result = 0;\n    string p = \"\
    \ 2 3 5 7 B D \";\n    char[] t = to!char[](p);\n    for (int i = 0; i < z; i++)\n\
    \    {\n        if (num[i] >= '0' && num[i] <= '9')\n        {\n            a\
    \ = num[i] - '0';\n        }\n        else if (num[i] >= 'A' && num[i] <= 'F')\n\
    \        {\n            a = num[i] - 'A' + 10;\n        }\n        for (int j\
    \ = 0; j < 7; j++)\n        {\n            if (a == t[j])\n            {\n   \
    \             result++;\n            }\n        }\n    }\n    return result;\n\
    }\n//Alternative solution\nlong hex_key(string num)\n{\n    enum isPrime = [true,\
    \ false, true, true, false, true, true, false, false, false, true, true, true,\
    \ true, false, true];\n    long count = 0;\n    for (in char; num)\n    {\n  \
    \      count += isPrime[std.string.toupper(char).to!int - '0'.to!int];\n    }\n\
    \    return count;\n}\n/*\nYou have been tasked to write a function that receives\
    \ a list of numbers and returns the median value.\n    The median is a numeric\
    \ value separating the upper half of a sorted array of numbers from the lower\
    \ half.\n    In a list where there are an odd number of entities, the median is\
    \ the number found in the middle of the array.\n    If the array contains an even\
    \ number of entities, then there is no single middle value, \n    instead the\
    \ median becomes the average of the two numbers found in the middle.\n    For\
    \ this mission, you can assume that you will always get an odd number of numbers.\n\
    \    Example:\n    >>> median([1, 2, 3, 4, 5])\n    3\n    >>> median([3, 1, 2,\
    \ 5, 3])\n    3\n    >>> median([1, 300, 2, 200, 1])\n    2\n    >>> median([3,\
    \ 6, 20,", "{\n    const long primes[] = {2, 3, 5, 7, 11, 13};\n    return num.count!(ch\
    \ => (\n        (ch >= '0' && ch <= '9') || \n        (ch >= 'A' && ch <= 'F')\
    \ \n    ) && (\n        primes.count!(x => (ch >= '0' && ch <= '9') ? ch == '0'\
    \ + x : ch == 'A' + x - 10)\n    ))();\n}", "{\n    // Your code here...\n   \
    \ immutable int primes[8] = [2, 3, 5, 7, 11, 13, 17, 19];\n    long counter =\
    \ 0;\n    foreach(digit; num)\n    {\n        int d = to!int(digit);\n       \
    \ if(d > 57)\n            d -= 55;\n        else\n            d -= 48;\n     \
    \   if(primes.count(d))\n            counter++;\n    }\n    return counter;\n}",
  "{\n    int count = 0;\n    bool[] primes = [false, false, true, true, false, true,\
    \ false, true, false, false, false, true, false, true, false, false];\n    foreach(c;\
    \ num) \n    {\n        if(c in primes) \n        {\n            count++;\n  \
    \      }\n    }\n    return count;\n}", "{\n    return sum(map!(hex =&gt; isPrime(hex)\
    \ ? 1 : 0)(map!(x =&gt; cast(long)(x == 'A' || x == 'B' || x == 'C' || x == 'D'\
    \ || x == 'E' || x == 'F' ? x : to!string(x)))(num)));\n}", "{\n    long max =\
    \ 0;\n    if ( num.length == 0 ) return max;\n    bool [] primes = [true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true];\n    foreach (  e;iota(16) )\n    {\n        if ( primes[e] )\n     \
    \   {\n            // have a look at http://www.learntosolveit.com/cprogramming/Ex_5.1_sieve_of_eratosthenes.html\n\
    \            foreach ( i;iota(e*e,e) )\n            {\n                if ( i\
    \ > 15 ) break;\n                primes[i] = false;\n            }\n        }\n\
    \    }\n    char [][] hexArray = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'];\n\
    \    long [] hexDec = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\n    foreach (\
    \ i;0..num.length )\n    {\n        foreach ( j;0..hexArray.length )\n       \
    \ {\n            if ( num[i] == hexArray[j] )\n            {\n               \
    \ if ( primes[hexDec[j]] )\n                {\n                    max++;\n  \
    \              }\n            }\n        }\n    }\n    return max;\n}\n/*\nYour\
    \ task is to create a function that returns the sum of the eight \ndiagonals in\
    \ a 1001 by 1001 spiral.\nExample:\n>>> spiral_diagonals(1001)\n669171001L\n*/\n\
    long spiral_diagonals(int n) \n{\n    long sum = 1;\n    if ( n <= 1 ) return\
    \ sum;\n    if ( n % 2 == 0 ) return sum;\n    if ( n == 3 ) return sum + 8;\n\
    \    long number = 9;\n    foreach ( i;0..(n-3)/2 )\n    {\n        foreach (\
    \ j;1..4 )\n        {\n            sum += number;\n           ", "{\n    string\
    \ hexMap = \"0123456789ABCDEF\";\n    long[] hexPrimes = [2, 3, 5, 7, 11, 13];\n\
    \    long result = 0;\n    foreach(hexDigit; num)\n    {\n        long val = hexMap.indexOf(hexDigit);\n\
    \        if(hexPrimes.indexOf(val) != -1)\n        {\n            result++;\n\
    \        }\n    }\n    return result;\n}", "{\n    long count = 0;\n    if (num.length\
    \ == 0)\n        return count;\n    foreach (i; 0 .. num.length) \n    {\n   \
    \     if (num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' ||\
    \ num[i] == 'B' || num[i] == 'D')\n            count++;\n    }\n    return count;\n\
    }", "{\n    return num.count!((c) => \"2357BDF\".count(c));\n}", "{\n    long\
    \ l = num.length;\n    int res = 0;\n    string s = \"2357BD\";\n    for (long\
    \ i = 0; i < l; i++)\n    {\n        if (s.find(num[i]) > -1) res++;\n    }\n\
    \    return res;\n}", "{\n    if (num.empty)\n        return 0;\n    ulong sum\
    \ = 0;\n    for (ulong i = 0; i < num.length; i++)\n    {\n        ulong x = num[i];\n\
    \        if (x > '9')\n            x -= 7;\n        x -= '0';\n        if (x ==\
    \ 2 || x == 3 || x == 5 || x == 7 || x == 11 || x == 13)\n            sum++;\n\
    \    }\n    return sum;\n}", "{\n    string[] primes = [\"2\", \"3\", \"5\", \"\
    7\", \"B\", \"D\"];\n    int counter = 0;\n    foreach(c; num) {\n        if(c\
    \ in primes)\n            counter++;\n    }\n    return counter;\n}", "{\n   \
    \ long count = 0;\n    bool isPrime = true;\n    string alphabet = \"ABCDEF\"\
    ;\n    foreach(d; num) \n    {\n        if(d in '0' .. '9') \n        {\n    \
    \        for(long i = 2; i < d; i++) \n            {\n                if(d % i\
    \ == 0) \n                {\n                    isPrime = false;\n          \
    \          break;\n                }\n            }\n            if(isPrime &&\
    \ d != '1') \n            {\n                count++;\n            }\n       \
    \     isPrime = true;\n        }\n        else if(indexOf(alphabet, d) != -1)\
    \ \n        {\n            long n = indexOf(alphabet, d) + 10;\n            for(long\
    \ i = 2; i < n; i++) \n            {\n                if(n % i == 0) \n      \
    \          {\n                    isPrime = false;\n                    break;\n\
    \                }\n            }\n            if(isPrime && n != 1) \n      \
    \      {\n                count++;\n            }\n            isPrime = true;\n\
    \        }\n    }\n    return count;\n}", "{\n    long res = 0;\n    int[] arr\
    \ = [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,\
    \ 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,\
    \ 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353,\
    \ 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449,\
    \ 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\
    \ 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653,\
    \ 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\
    \ 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,\
    \ 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991,\
    \ 997];\n    foreach(int x; arr)\n    {\n        if(num.canFind(toUpper(format(\"\
    %x\", x))))\n            res++;\n    }\n    return res;\n}\n//Or better.\nlong\
    \ hex_key2(string num) \n{\n    return std.algorithm.count!(x => isPrime(cast(int)std.conv.",
  "{\n    auto sum = 0;\n    foreach(i; 0 .. num.length)\n    {\n        ubyte num\
    \ = num[i];\n        if (0x30 <= num && num <= 0x39)\n        {\n            sum\
    \ += (num - 0x30) <= 3;\n        }\n        else if (0x41 <= num && num <= 0x46)\n\
    \        {\n            sum += (num - 0x41) <= 5;\n        }\n    }\n    return\
    \ sum;\n}\n/*\n    Array of Products", "{\n    long result = 0;\n    int hex_dig;\n\
    \    foreach(char c; num) {\n        const(char[]) hex_digits = \"0123456789ABCDEF\"\
    ;\n        auto index = hex_digits.find(c);\n        if(index < 0)\n         \
    \   return 0;\n        hex_dig = index.array;\n        if (hex_dig == 2 || hex_dig\
    \ == 3 || hex_dig == 5 || hex_dig == 7 || \n            hex_dig == 11 || hex_dig\
    \ == 13)\n            result++;\n    }\n    return result;\n}\n/*\n    You are\
    \ given a rectangle that is divided horizontally into three sections \n    of\
    \ the same size.\n    The sections are labeled \"top\", \"middle\", and \"bottom\"\
    .\n    The result of your function will be a string which contains the labels\
    \ \n    of all the sections in order from left to right.\n    For example, if\
    \ you are looking for the value of the 5th section, you would \n    read the string\
    \ from the 5th character (counting from 0).\n    However, if you are given a number\
    \ that is greater than the number of \n    sections, you have to \"wrap around\"\
    \ and count from the left again.\n    For example, if you are given the value\
    \ 12, you need to return the value \n    of the 4th section (since there are only\
    \ 12 sections and 12 % 12 = 0).\n    Examples:\n    >>> rect_sequence(1)\n   \
    \ \"top\"\n    >>> rect_sequence(3)\n    \"middle\"\n    >>> rect_sequence(7)\n\
    \    \"top\"\n    >>> rect_sequence(11)\n    \"middle\"\n    >>> rect_sequence(13)\n\
    \    \"bottom\"\n    >>> rect_sequence(19)\n    \"top\"\n    >>> rect_sequence(24)\n\
    \    \"bottom\"\n*/\nstring rect_sequence(long n) \n{\n    const(char[]) sequence\
    \ = \"topmiddlebottom\";\n    int index = n % sequence.length;\n    return sequence[index..index+3];\n\
    }\n/*\n    Write a function that determines the divisibility of a natural number\
    \ by \n    the sum of its digits (in decimal representation).\n   "]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
