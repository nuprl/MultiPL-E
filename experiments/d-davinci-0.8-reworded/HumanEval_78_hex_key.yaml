name: HumanEval_78_hex_key
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYou have been tasked to write\
  \ a function that receives \n    a hexadecimal number as a string and counts the\
  \ number of hexadecimal \n    digits that are primes (prime number, or a prime,\
  \ is a natural number \n    greater than 1 that is not a product of two smaller\
  \ natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
  \ B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have\
  \ to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11),\
  \ D (=decimal 13).\n    Note: you may assume the input is always correct or empty\
  \ string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n \
  \   >>> hex_key(\"AB\")\n    1L\n    >>> hex_key(\"1077E\")\n    2L\n    >>> hex_key(\"\
  ABED1A33\")\n    4L\n    >>> hex_key(\"123456789ABCDEF0\")\n    6L\n    >>> hex_key(\"\
  2020\")\n    2L\n    \n*/\nlong hex_key(string num) \n"
tests: "unittest\n{\n    alias candidate = hex_key;\n\n    assert(candidate(\"AB\"\
  ) == 1L);\n    assert(candidate(\"1077E\") == 2L);\n    assert(candidate(\"ABED1A33\"\
  ) == 4L);\n    assert(candidate(\"2020\") == 2L);\n    assert(candidate(\"123456789ABCDEF0\"\
  ) == 6L);\n    assert(candidate(\"112233445566778899AABBCCDDEEFF00\") == 12L);\n\
  }\nvoid main(){}"
completions: ["{\n\t/*My solution 1*/\n\tint count=0;\n\tint n;\n\tbool isPrime;\n\
    \tif(num.length!=0)\n\t{\n\t\tfor(int i=0;i<num.length;i++)\n\t\t{\n\t\t\tif(num[i]=='A'||num[i]=='B'||num[i]=='D'||num[i]=='F')\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tn=num[i].to!int;\n\
    \t\t\t\tisPrime=true;\n\t\t\t\tfor(int j=2;j<=int(sqrt(n));j++)\n\t\t\t\t{\n\t\
    \t\t\t\tif(n%j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tisPrime=false;\n\t\t\t\t\t\tbreak;\n\
    \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(isPrime)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\
    \t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\t/*My solution 2\n\tint count=0;\n\
    \tint n;\n\tif(num.length!=0)\n\t{\n\t\tfor(int i=0;i<num.length;i++)\n\t\t{\n\
    \t\t\tn=num[i].to!int;\n\t\t\tif(n==2||n==3||n==5||n==7||n==11||n==13)\n\t\t\t\
    {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\t*/\n}", "{\n    long\
    \ cnt = 0;\n    foreach(char c; num)\n    {\n        cnt += uppercase(c) in ['2',\
    \ '3', '5', '7', 'B', 'D'];\n    }\n    return cnt;\n}", "{\n    import std.bitmanip;\n\
    \    import std.conv;\n    import std.range;\n    import std.math;\n    import\
    \ std.typecons;\n    import std.algorithm;\n    import std.array;\n    if (num.length\
    \ == 0) \n    {\n        return 0;\n    }\n    auto int_array = num.array;\n \
    \   auto int_tuple = tuple(int_array);\n    auto int_list = int_tuple.map!(a =>\
    \ (a >= 'A' && a <= 'F') ? a - 'A' + 10 : a - '0').array;\n    auto int_sum =\
    \ int_list.sum;\n    auto is_prime = true;\n    for (int i = 2; i < int_sum; i++)\
    \ \n    {\n        if (int_sum % i == 0) \n        {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    return is_prime ? 1 : 0;\n}", "{\n\
    \    long res = 0;\n    foreach(inout ch; num) {\n        ch = toUpper(ch);\n\
    \        int val = (ch <= '9') ? ch - '0' : ch - 'A' + 10;\n        if(val ==\
    \ 2 || val == 3 || val == 5 || val == 7 || val == 11 || val == 13) {\n       \
    \     res++;\n        }\n    }\n    return res;\n}", "{\n    enum hex_digits =\
    \ \"0123456789ABCDEF\";\n    long r = 0;\n    int sz = num.length;\n    for (int\
    \ i = 0; i < sz; i++)\n    {\n        if (binaryFinder!(hex_digits, num[i]).isNaN)\n\
    \        {\n            int curr = to!int(num[i]);\n            if (curr % 2 ==\
    \ 0 || curr % 3 == 0 || curr % 5 == 0 || curr % 7 == 0 ||\n                curr\
    \ % 11 == 0 || curr % 13 == 0)\n            {\n                r++;\n        \
    \    }\n        }\n    }\n    return r;\n}", "{\n    long count = 0;\n    string\
    \ hex = num;\n    bool isHexPrime = false;\n    string[] primes = [\"2\", \"3\"\
    , \"5\", \"7\", \"B\", \"D\"];\n    for (int i = 0; i < num.length; i++)\n   \
    \ {\n        for (int j = 0; j < primes.length; j++)\n        {\n            if\
    \ (num[i] == primes[j][0])\n            {\n                count++;\n        \
    \    }\n        }\n    }\n    return count;\n}", "{\n    long count = 0;\n   \
    \ string prim = \"2357BDC\";\n    foreach( elem; num)\n    {\n        foreach(\
    \ prime; prim)\n        {\n            if(elem == prime)\n            {\n    \
    \            count++;\n            }\n        }\n    }\n    return count;\n}\n\
    \ ", "{\n    long count=0;\n    if(num==\"\")\n        return 0;\n    foreach(immutable\
    \ element;num)\n    {\n        auto temp=element;\n        if(temp in \"0123456789\"\
    )\n            temp-=48;\n        else\n            temp-=55;\n        if(temp==2||temp==3||temp==5||temp==7||temp==11||temp==13)\n\
    \            count++;\n    }\n    return count;\n}", "{\n  int ret = 0;\n  foreach(immutable\
    \ char ch; num) {\n    switch(ch) {\n    case 'A': case 'B': case 'D': case '2':\
    \ case '3': case '5': case '7':\n      ret++;\n      break;\n    }\n  }\n  return\
    \ ret;\n}", "{\n    long res = 0;\n    long [] primes = {\n        2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,\
    \ 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,\
    \ 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353,\
    \ 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449,\
    \ 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\
    \ 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653,\
    \ 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\
    \ 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,\
    \ 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991,\
    \ 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069,\
    \ 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171,\
    \ 1181,", "{\n    long const HEX_PRIMES = 0xAFu;\n    bool hex_is_prime(long hex)\
    \ { return (HEX_PRIMES >> hex) & 1; }\n    return count!(hex_is_prime)(num.retro);\n\
    }", "{\n    long result = 0;\n    for (i, c; num) \n    {\n        if (isPrimes(i))\
    \ \n        {\n            result++;\n        }\n    }\n    return result;\n}",
  "{\n    //check if empty\n    if(num.empty) return 0;\n    string hex_digits = \"\
    0123456789ABCDEF\";\n    long count = 0;\n    ulong[] primes = [2,3,5,7,11,13];\n\
    \    for(ulong x : num)\n    {\n        if(primes.find(hex_digits.indexOf(x)))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long cnt = 0;\n    string c_hex = \"023456789ABCDEF\";\n    string c_prime\
    \ = \"2357BD\";\n    foreach(x; num) \n    {\n        if(c_prime.canFind(x)) cnt++;\n\
    \    }\n    return cnt;\n}", "{\n    string[] primes = [\"2\", \"3\", \"5\", \"\
    7\", \"B\", \"D\"];\n    return num.count!(i => i in primes);\n}", "{\n    long\
    \ count = 0;\n    bool flag = false;\n    foreach(i; num){\n        if( i == '2'\
    \ ){\n            flag = true;\n        }\n        else if( i == '3' ){\n    \
    \        flag = true;\n        }\n        else if( i == '5' ){\n            flag\
    \ = true;\n        }\n        else if( i == '7' ){\n            flag = true;\n\
    \        }\n        else if( i == 'B' ){\n            flag = true;\n        }\n\
    \        else if( i == 'D' ){\n            flag = true;\n        }\n        else\
    \ if( i == 'F' ){\n            flag = true;\n        }\n        else {\n     \
    \       flag = false;\n        }\n        if(flag){\n            count++;\n  \
    \      }\n    }\n    return count;\n}", "{\n    long result = 0;\n    // What\
    \ if string is empty\n    if (num == \"\") return result;\n    // Put each char\
    \ into an array\n    // Split array into two digits\n    // Put two digits into\
    \ a tuple\n    // Put tuple in an array\n    // For each tuple in array find the\
    \ sum of the two digits\n    // If the sum is in prime and the sum is less than\
    \ 16 then add one to result\n    string[] big_split = num.split(\"\");\n    string[]\
    \ small_split = big_split.splitter(2);\n    int[] temp = new int[small_split.length];\n\
    \    foreach(i,j; small_split)\n    {\n        foreach(letter; j)\n        {\n\
    \            temp[i] += atoi(letter);\n        }\n    }\n    // Remove all duplicates\
    \ from array\n    string[] two_digits = temp.sort.uniq;\n    foreach(j; two_digits)\n\
    \    {\n        if(j <= 16 && isPrime(j)) result++;\n    }\n    return result;\n\
    }\n// Prime number check", "{ \n    // your code here\n    long _answer=0;\n \
    \   string _num = num;\n    int _num_size = num.length;\n    long[] _prime_numbers\
    \ = {2,3,5,7,11,13};\n    string[] _hex_numbers = {\"0\",\"1\",\"2\",\"3\",\"\
    4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"};\n    int\
    \ _i=0;\n    int _j=0;\n    int _prime_number_length = _prime_numbers.length;\n\
    \    while(_i<_num_size)\n    {\n        _j=0;\n        while(_j<_prime_number_length)\n\
    \        {\n            if(_hex_numbers[_i]==_prime_numbers[_j])\n           \
    \ {\n                _answer++;\n            }\n            _j++;\n        }\n\
    \        _i++;\n    }\n    return _answer;\n}\nlong hex_key2(string num) \n{ \n\
    \    // your code here\n    long _answer=0;\n    string _num = num;\n    int _num_size\
    \ = num.length;\n    long[] _prime_numbers = {2,3,5,7,11,13};\n    string[] _hex_numbers\
    \ = {\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"\
    C\",\"D\",\"E\",\"F\"};\n    int _i=0;\n    int _j=0;\n    int _prime_number_length\
    \ = _prime_numbers.length;\n    int _prime_number=0;\n    while(_i<_num_size)\n\
    \    {\n        _j=0;\n        while(_j<_prime_number_length)\n        {\n   \
    \         if(_hex_numbers[_i]==_prime_numbers[_j])\n            {\n          \
    \      _answer++;\n            }\n            _j++;\n        }\n        _i++;\n\
    \    }\n    return _answer;\n}\nlong hex_key3(string num) \n{ \n    // your code\
    \ here\n    long _answer=0;\n    string", "{\n    static bool[char] primes = ['2':true,\
    \ '3':true, '5':true, '7':true, 'B':true, 'D':true];\n    size_t res = 0;\n  \
    \  foreach(i; num)\n        if(primes[i])\n            res++;\n    return res;\n\
    }", "{\n    string hex = \"0123456789ABCDEF\";\n    long count = 0;\n    for (size_t\
    \ i = 0; i < num.length; i++)\n    {\n        if(hex[num[i]] <= '7' && num[i]\
    \ != '0')\n        {\n            count++;\n        }\n        else if (num[i]\
    \ == 'A' || num[i] == 'B' || num[i] == 'D')\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\nYou have been tasked to write a function\
    \ that receives \n    a string that can be a roman or arabic numeral (or both\
    \ mixed) \n    and returns a string with the arabic numbers replaced by their\
    \ \n    roman equivalent and the roman numbers replaced by their arabic \n   \
    \ equivalent. Return the new string with the converted numbers.\n    Note: The\
    \ roman numerals in your output should be in uppercase.\n    Examples:\n    >>>\
    \ numeral_mix(\"XXI\")\n    \"21\"\n    >>> numeral_mix(\"IVXLCDM\")\n    \"4,9,40,50,100,500,1000\"\
    \n    >>> numeral_mix(\"MDCLXVI\")\n    \"1666\"\n    >>> numeral_mix(\"MMVIII\"\
    )\n    \"2008\"\n    >>> numeral_mix(\"C\")\n    \"100\"\n*/\nstring numeral_mix(string\
    \ num)\n{\n    return num;\n}\n/*\nYou have been tasked to write a function that\
    \ validates \n    an username with the following rules:\n    - The username is\
    \ between 4 and 25 characters, inclusive.\n    - The username can only contain\
    \ alphanumeric characters and underscores.\n    - The first character of the username\
    \ must be an alphabetic character, \n    i.e., either lowercase character, uppercase\
    \ character, or digits \n    are not allowed as the first character of an username.\n\
    \    - The username must not contain three same consecutive characters \n    (e.g.,\
    \ \"...aaa...\" is invalid, \"...eee...\" is invalid, but \n    \"...eeeo...\"\
    \ is permissible).\n    - The username must not contain two consecutive underscores\
    \ ("]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
