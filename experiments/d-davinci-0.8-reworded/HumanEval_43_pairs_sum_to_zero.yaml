name: HumanEval_43_pairs_sum_to_zero
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    pairs_sum_to_zero takes\
  \ an array of integers as an input.\n    it returns true if there are two distinct\
  \ elements in the array that\n    sum to zero, and false otherwise.\n    >>> pairs_sum_to_zero([1L,\
  \ 3L, 5L, 0L])\n    false\n    >>> pairs_sum_to_zero([1L, 3L, -2L, 1L])\n    false\n\
  \    >>> pairs_sum_to_zero([1L, 2L, 3L, 7L])\n    false\n    >>> pairs_sum_to_zero([2L,\
  \ 4L, -5L, 3L, 5L, 7L])\n    true\n    >>> pairs_sum_to_zero([1L])\n    false\n\
  \    \n*/\nbool pairs_sum_to_zero(long[] l) \n"
tests: "unittest\n{\n    alias candidate = pairs_sum_to_zero;\n\n    assert(candidate([1L,\
  \ 3L, 5L, 0L]) == false);\n    assert(candidate([1L, 3L, -2L, 1L]) == false);\n\
  \    assert(candidate([1L, 2L, 3L, 7L]) == false);\n    assert(candidate([2L, 4L,\
  \ -5L, 3L, 5L, 7L]) == true);\n    assert(candidate([1L]) == false);\n    assert(candidate([-3L,\
  \ 9L, -1L, 3L, 2L, 30L]) == true);\n    assert(candidate([-3L, 9L, -1L, 3L, 2L,\
  \ 31L]) == true);\n    assert(candidate([-3L, 9L, -1L, 4L, 2L, 30L]) == false);\n\
  \    assert(candidate([-3L, 9L, -1L, 4L, 2L, 31L]) == false);\n}\nvoid main(){}"
completions: ["{\n    if (l.length < 2)\n    {\n        return false;\n    }\n   \
    \ auto sorted_l = l.dup.sort;\n    long[] found_array = new long[0L];\n    foreach\
    \ (i, e; sorted_l)\n    {\n        if (sorted_l[i] == 0L && (found_array.length\
    \ == 0L || found_array[$ - 1L] != 0L))\n        {\n            found_array ~=\
    \ 0L;\n        }\n        else if (found_array.length != 0L && found_array[$ -\
    \ 1L] == 0L)\n        {\n            continue;\n        }\n        else\n    \
    \    {\n            auto before = find(sorted_l[0L .. i], -1L * e);\n        \
    \    auto after = find(sorted_l[i + 1L .. $], -1L * e);\n            if (before\
    \ !is null && (found_array.length == 0L || found_array[$ - 1L] != e))\n      \
    \      {\n                found_array ~= e;\n            }\n            if (after\
    \ !is null && (found_array.length == 0L || found_array[$ - 1L] != e))\n      \
    \      {\n                found_array ~= e;\n            }\n        }\n    }\n\
    \    return found_array.length >= 2;\n}\n/*", "{\n    return false;\n}\n/*", "{\
    \ \n    int sum = 0;\n    foreach(long i; l) \n    {\n        sum += i;\n    }\n\
    \    return sum == 0;\n}", "{\n    //too lazy to test the base case\n    bool\
    \ flag = false;\n    //put each item in the map and it's freq\n    Map!(size_t,size_t)\
    \ freq = new Map!(size_t,size_t);\n    foreach(e; l) \n    {\n        if (freq.contains(e))\
    \ \n        {\n            freq[e]++;\n        } \n        else \n        {\n\
    \            freq[e] = 1;\n        }\n    }\n    //check if the freq of the negative\
    \ value is not zero\n    //and of course if the value of the key is not zero\n\
    \    foreach(e; freq.keys) \n    {\n        if (e != 0) \n        {\n        \
    \    if (freq.contains(-e) && freq[-e] != 0) \n            {\n               \
    \ flag = true;\n                break;\n            }\n        }\n    }\n    return\
    \ flag;\n}", "{\n    bool b = false;\n    foreach(i; 0 .. l.length) \n    {\n\
    \        foreach(j; i + 1 .. l.length) \n        {\n            if (l[i] + l[j]\
    \ == 0) \n            {\n                b = true;\n            }\n        }\n\
    \    }\n    return b;\n}\n/*", "{ \n    for (size_t i = 0; i < l.length; i++)\
    \ \n    { \n        for (size_t j = i + 1; j < l.length; j++) \n        { \n \
    \           if (l[i] + l[j] == 0) \n            { \n                return true;\
    \ \n            } \n        } \n    } \n    return false; \n}", "{\n  // sort\
    \ the array\n  sort(l);\n  // set up two indices to search from the ends of the\
    \ array\n  size_t i = 0;\n  size_t j = l.length - 1;\n  // continue searching\
    \ for a pair that sums to zero\n  // as long as there are at least two elements\
    \ remaining\n  while (i < j) {\n    long sum = l[i] + l[j];\n    // a pair that\
    \ sums to zero has been found\n    if (sum == 0) {\n      return true;\n    }\n\
    \    // move the indices according to whether the\n    // sum is too small or\
    \ too large\n    if (sum < 0) {\n      i++;\n    } else {\n      j--;\n    }\n\
    \  }\n  // there are no pairs that sum to zero\n  return false;\n}", "{\n    long\
    \ count = 0L;\n    long n = l.length;\n    count = 0L;\n    long i = 0L;\n   \
    \ while (i < n)\n    {\n        long j = 0L;\n        while (j < n)\n        {\n\
    \            if (i != j)\n            {\n                if ((l[i] + l[j]) ==\
    \ 0L)\n                {\n                    count += 1L;\n                }\n\
    \            }\n            j += 1L;\n        }\n        i += 1L;\n    }\n   \
    \ if (count > 0L)\n    {\n        return true;\n    }\n    else\n    {\n     \
    \   return false;\n    }\n}", "{\n    // make a set of all values in array l\n\
    \    auto s = set();\n    foreach(long elt; l)\n    {\n        s.insert(elt);\n\
    \    }\n    // check if the negation of each element is in the set\n    foreach(long\
    \ elt; l)\n    {\n        if(s.find(-elt))\n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}", "{\n    if(l.length < 2) \n    {\n \
    \       return false;\n    }\n    else \n    {\n        auto t = map!((x => abs(x)))(l);\n\
    \        auto m = t.sort;\n        // this function sort the elements into a new\
    \ array m\n        for(int i = 1; i < m.length; i++) \n        {\n           \
    \ if(m[i] == m[i - 1]) \n            {\n                return true;\n       \
    \     }\n        }\n        return false;\n    }\n}\n/*", "{\n    if (l.length<2)\
    \ \n    {\n        return false;\n    } \n    else if (l.length == 2) \n    {\n\
    \        return l[0] == -l[1];\n    }\n    /*\n    c = divide_and_conquer(l, 0,\
    \ l.length);\n    writeln(c);\n    */\n    c = divide_and_conquer(l, 0, l.length);\n\
    \    return c;\n}", "{\n\tulong s = l.length;\n\tulong i = 0u;\n\tif(s == 1u)\n\
    \t{\n\t\treturn false;\n\t}\n\telse \n\t{\n\t\twhile(i < s)\n\t\t{\n\t\t\tlong\
    \ n = l[i];\n\t\t\tulong j = i+1u;\n\t\t\twhile(j < s)\n\t\t\t{\n\t\t\t\tif(n\
    \ + l[j] == 0L)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tj = j +\
    \ 1u;\n\t\t\t}\n\t\t\ti = i + 1u;\n\t\t}\n\t\treturn false;\n\t}\n}", "{\n   \
    \ for (int i = 0; i < l.length; i++){\n        for (int j = i+1; j < l.length;\
    \ j++){\n            if (l[i] + l[j] == 0){\n                return true;\n  \
    \          }\n        }\n    }\n    return false;\n}", "pure nothrow { \n    auto\
    \ set = unordered_set!(long)();\n    foreach(x; l) \n    {\n        if (x < 0L)\
    \ \n        {\n            if (set.count(-x)) \n            {\n              \
    \  return true;\n            }\n        }\n        else \n        {\n        \
    \    if (set.count(x)) \n            {\n                return true;\n       \
    \     }\n        }\n        set.insert(x);\n    }\n    return false;\n}", "{\n\
    \    // Your code here.\n    // You can use the following helper function 'count'.\n\
    \    // It takes a long array and an integer and returns the number of times the\n\
    \    // integer appears in the array.\n    // >>> count([1L, 3L, 5L, 0L], 0L)\n\
    \    // 1\n    // >>> count([1L, 3L, 5L, 0L], 5L)\n    // 1\n    // >>> count([1L,\
    \ 3L, 5L, 0L], 2L)\n    // 0\n    int count(long[] a, long item) {\n        int\
    \ counter = 0;\n        foreach(x; a)\n        {\n            if(x == item)\n\
    \            {\n                counter++;\n            }\n        }\n       \
    \ return counter;\n    }\n    foreach(number; l)\n    {\n        if(count(l, -number)\
    \ > 0)\n        {\n            return true;\n        }\n    }\n    return false;\n\
    }", "{\n    for (i in 0 .. l.length - 1) \n    {\n        for (j in i + 1 .. l.length\
    \ - 1) \n        {\n            if (l[i] + l[j] == 0) \n            {\n      \
    \          return true;\n            }\n        }\n    }\n    return false;\n}",
  "{\n    bool rslt = false;\n    long[] ltemp = sort(l);\n    long a_i = 0L;\n  \
    \  foreach (a_i; ltemp) \n    {\n        long b_i = 0L;\n        foreach (b_i;\
    \ ltemp) \n        {\n            if ((a_i != b_i) && (a_i + b_i == 0L)) \n  \
    \          {\n                rslt = true;\n            }\n        }\n    }\n\
    \    return rslt;\n}\n/*", "{\n    auto len = l.length;\n    if (len<2) \n   \
    \ {\n        return false;\n    }\n    else \n    {\n        auto m = new int[max(l)+1];\n\
    \        foreach (i;l) \n        {\n            m[i]++;\n        }\n        foreach\
    \ (i;l) \n        {\n            if (-i in m) \n            {\n              \
    \  if (-i==i) \n                {\n                    if (m[i]>1) \n        \
    \            {\n                        return true;\n                    }\n\
    \                }\n                else \n                {\n               \
    \     return true;\n                }\n            }\n        }\n        return\
    \ false;\n    }\n}\n// <div id=\"documentation\" class=\"type\">\n// === Documenter\
    \ ===\n//\n// If you have installed Ddoc and DMD on your system (which can be\
    \ conveniently\n// done through <a href=\"http://dlang.org/download.html\">the\
    \ download page</a>),\n// you can use `dmd -D` to generate documentation.\n//\n\
    // The simplest way to use it is to run the following command in your program's\n\
    // directory:\n//\n//     dmd -D *.d\n//\n// It will print the generated documentation\
    \ to stdout.\n//\n// By default, it will look for code in all files with the `.d`\
    \ extension.\n// To document only a subset of your code, provide the names of\
    \ the files to be\n// documented as an argument to `dmd -D`.\n//\n//     dmd -D\
    \ src/parser.d src/lexer.d\n//\n// You can also specify directories:\n//\n// \
    \    dmd -D src/app src/lib\n//\n// This will document the contents of the `src/app`\
    \ and `src/lib` directories.\n//\n// If you want to create a separate file for\
    \ the generated documentation, use\n// redirection:\n//\n//     dmd -D *.d > docs.html\n\
    //\n// This can also be combined with specifying files to document:\n//\n//  \
    \   dmd -D src/app/parser.d src/app/lexer.d > docs.html\n//\n// === Markup language",
  "in \n{\n    l.length >= 1\n}\nout \n(result)\n{\n    exists(pair tp; l.length ==\
    \ tp.length && tp.sum() == 0)\n}\n{\n    return exists(pair tp; \n        tp.length\
    \ == 2 && tp.sum() == 0 && \n        l.contains(tp.i) && l.contains(tp.j));\n}",
  "{\n    bool res;\n    long val;\n    ref long neg_val;\n    res = false;\n    foreach\
    \ (val; l) \n    {\n        if (val == 0L) \n        {\n            res = true;\n\
    \            break;\n        }\n        if (neg_val.ptr) \n        {\n       \
    \     if (neg_val.ptr == val) \n            {\n                res = true;\n \
    \               break;\n            }\n        }\n        else \n        {\n \
    \           neg_val.ptr = -val;\n        }\n    }\n    return res;\n}", "{\n \
    \   /*\n        It will be helpful to create a helper function for the solution.\n\
    \    */\n    // it takes an array of integers and an integer.\n    // it returns\
    \ true if there is an element in the array that\n    // is not the given integer\
    \ and sums to zero with the given integer, and false otherwise.\n    bool pair_sum_to_zero(long[]\
    \ m, long x) \n    {\n        /*\n            The items in the given array must\
    \ be compared with the given integer.\n            You may want to iterate over\
    \ the array, and check each item in the array\n            to see if it sums to\
    \ zero with the given integer.\n        */\n        foreach (long j; m) \n   \
    \     {\n            /*\n                You are going to compare the given integer\
    \ with every item in the given array.\n                It is also possible that\
    \ the given integer is equal to the item in the array.\n                The given\
    \ integer can not sum to zero with itself, so if it is equal to the item\n   \
    \             in the array, you must skip the item.\n            */\n        \
    \    if (j == x) \n            {\n                continue;\n            }\n \
    \           /*\n                If the given integer is not equal to the item\
    \ in the array,\n                you can compare them to see if their sum is zero.\n\
    \            */\n            if (x + j == 0) \n            {\n               \
    \ return true;\n            }\n        }\n        /*\n            You have iterated\
    \ over the entire array and found no such pair.\n            You must return false.\n\
    \        */\n        return false;\n    }\n    /*\n        We want to check if\
    \ there are two distinct elements in the array that sum to zero.\n        It will\
    \ be helpful to iterate over the array, and check each element in the array\n\
    \        to see if it sums to zero with another element in the array.\n    */\n\
    \    foreach (long i; l) \n    {\n        /*\n            If there is such a pair\
    \ for a given integer, you can return true.\n        */\n        if (pair_sum_to_zero(l,\
    \ i)) \n        {\n            return true;\n        }\n    }\n    /*\n      \
    \  You have iterated over the entire array and found no such pair.\n        You\
    \ must return false", "{\n    if (l.length < 2)\n    {\n        return false;\n\
    \    }\n    else\n    {\n        long[] l_sorted = l.sort();\n        int i =\
    \ 0;\n        int j = l_sorted.length - 1;\n        while (i < j)\n        {\n\
    \            if (l_sorted[i] + l_sorted[j] == 0)\n            {\n            \
    \    return true;\n            }\n            else if (l_sorted[i] + l_sorted[j]\
    \ < 0)\n            {\n                i++;\n            }\n            else\n\
    \            {\n                j--;\n            }\n        }\n        return\
    \ false;\n    }\n}\n/*", "{\n    if(l.length <= 1L)\n    {\n        return false;\n\
    \    }\n    else\n    {\n        /*\n            D is a subset of l\n        */\n\
    \        long[] D = [];\n        for(long n = 0L; n < l.length; n++)\n       \
    \ {\n            D ~= l[n];\n        }\n        D.sort;\n        /*\n        \
    \    i is the upper bound of the sum of any two elements\n            of D\n \
    \       */\n        long i = 0L;\n        /*\n            j is the lower bound\
    \ of the sum of any two elements\n            of D\n        */\n        long j\
    \ = 0L;\n        /*\n            We assume that there are two distinct elements\
    \ in D that sum to zero\n            and try to find a counterexample\n      \
    \  */\n        while(true)\n        {\n            /*\n                If i +\
    \ j == 0 then \n                there are two distinct elements in D that sum\
    \ to zero\n            */\n            if(i + j == 0L)\n            {\n      \
    \          return true;\n            }\n            /*\n                If i +\
    \ j < 0, then we want to make\n                the sum of any two elements of\
    \ D larger.\n                So, we increment j\n            */\n            else\
    \ if(i + j < 0L)\n            {\n                j = j + 1L;\n            }\n\
    \            /*\n                If i + j > 0, then we want to make\n        \
    \        the sum of any two elements of D smaller.\n                So, we decrement\
    \ i\n            */\n            else\n            {\n                i = i -\
    \ 1L;\n            }\n            /*\n                If i or j are outside of\
    \ the bounds of D,\n                then there are no two distinct elements in\
    \ D that sum to zero\n            */\n            if(i < 0L || j >= D.length)\n\
    \            {\n                return false;\n            }\n        }\n    }\n\
    }", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    l = l.map!((long\
    \ x) => x)().array;\n    l.sort;\n    int len = l.length;\n    int i = 0;\n  \
    \  int j = len - 1;\n    while (i < j) \n    {\n        long sum = l[i] + l[j];\n\
    \        if (sum == 0) \n        {\n            return true;\n        }\n    \
    \    else if (sum < 0) \n        {\n            i += 1;\n        }\n        else\
    \ \n        {\n            j -= 1;\n        }\n    }\n    return false;\n}\n/*",
  "{\n    if (l.length == 0)\n    {\n        return false;\n    }\n    return l.sort().each!(a\
    \ => (a - l.back) == 0);\n}", "{\n    if (l.length < 2) return false;\n    long[]\
    \ l1 = l.dup;\n    long[] l2 = l.dup;\n    sort(l1);\n    sort(l2, true);\n  \
    \  while (l1.length > 0 && l2.length > 0) {\n        if (l1[0] + l2[0] < 0) {\n\
    \            l1 = l1[1..$];\n        } else if (l1[0] + l2[0] > 0) {\n       \
    \     l2 = l2[1..$];\n        } else {\n            return true;\n        }\n\
    \    }\n    return false;\n}\n/*", "in {\n    assert l.length >= 0;\n}\nout {\n\
    \    assert if (exists int a, int b; 0 <= a && a < l.length && 0 <= b && b < l.length\
    \ && a != b; l[a] + l[b] == 0) { result } else { !result };\n}\n{\n    if (l.length\
    \ <= 1)\n        return false;\n    int num_iterations = 0;\n    int i = 0;\n\
    \    int j = l.length-1;\n    while (i < j) {\n        num_iterations++;\n   \
    \     invariant (i+1 < j);\n        invariant (j < l.length);\n        invariant\
    \ (l.length >= 2);\n        invariant (i < j);\n        invariant (j <= l.length-1);\n\
    \        invariant (0 <= i);\n        invariant (i <= l.length-1);\n        if\
    \ (l[i] + l[j] == 0) {\n            assert true;\n            return true;\n \
    \       }\n        if (l[i] + l[j] < 0) {\n            i++;\n        } else {\n\
    \            j--;\n        }\n    }\n    assert true;\n    return false;\n}",
  "{\n    long val = 0L;\n    long count = 0L;\n    long n = l.length;\n    for (long\
    \ i = 0L; i < n; i++) \n    {\n        for (long j = i + 1L; j < n; j++) \n  \
    \      {\n            if (l[i] + l[j] == 0L) \n            {\n               \
    \ count++;\n            }\n        }\n    }\n    if (count > 0L) \n    {\n   \
    \     return true;\n    }\n    else \n    {\n        return false;\n    }\n}\n\
    /*", "{\n    bool ret = false;\n    foreach( long elem1; l )\n    {\n        foreach(\
    \ long elem2; l )\n        {\n            if( elem1 != elem2 && elem1 + elem2\
    \ == 0 )\n            {\n                ret = true;\n                break;\n\
    \            }\n        }\n    }\n    return ret;\n}", "{\n    if (l.length <=\
    \ 1)\n    {\n        return false;\n    }\n    long first_two_sum = l[0] + l[1];\n\
    \    if (first_two_sum == 0)\n    {\n        return true;\n    }\n    long[] rest\
    \ = l[2..$];\n    return pairs_sum_to_zero(rest);\n}\n/*", "{ \n    bool ret;\n\
    \    size_t i;\n    size_t j;\n    size_t len;\n    size_t new_len;\n    long\
    \ temp;\n    long[] new_array;\n    bool isin;\n    ret = false;\n    len = l.length;\n\
    \    new_array = new long[len];\n    for (i = 0; i < len; i++) \n    {\n     \
    \   for (j = 0; j < len; j++) \n        {\n            if (i != j) \n        \
    \    {\n                if (l[i] + l[j] == 0) \n                {\n          \
    \          ret = true;\n                }\n            }\n        }\n    }\n \
    \   return ret;\n}\n/*", "{ \n    /* EDIT */\n    return false;\n}\n \n/*", "{\n\
    \    foreach (i; 0 .. l.length)\n    {\n        foreach (j; i+1 .. l.length)\n\
    \        {\n            if (l[i] + l[j] == 0)\n            {\n               \
    \ return true;\n            }\n        }\n    }\n    return false;\n}", "{\n \
    \   return false;\n}\n/*", "{\n    bool found = false;\n    foreach(long i; l)\
    \ \n    {\n        if (array(l).binarySearch(i * -1) != -1) \n        {\n    \
    \        if (array(l).binarySearch(i * -1) != array(l).binarySearch(i)) \n   \
    \         {\n                found = true;\n            }\n        }\n    }\n\
    \    return found;\n}\n//\n// END-OF-FILE\n//", "{\n    bool ret = false;\n  \
    \  long[] num = l;\n    long k;\n    for (long i = 0L; i < (num.length - 1L);\
    \ i += 1L) \n    {\n        k = i + 1L;\n        while ((k < num.length))\n  \
    \      {\n            if ((num[i] + num[k]) == 0L) \n            {\n         \
    \       ret = true;\n                break;\n            }\n            k += 1L;\n\
    \        }\n    }\n    return ret;\n}\n/*", "{\n    assert(l.length > 0);\n  \
    \  immutable N = l.length;\n    assert(N > 0);\n    if (N < 2) return false;\n\
    \    auto l1 = sort(l);\n    auto l2 = sort(l);\n    return pairs_sum_to_zero(l1,\
    \ l2);\n}\n/*", "{\n    foreach (i; 0 .. l.length) \n    {\n        foreach (j;\
    \ i + 1 .. l.length) \n        {\n            if (l[i] + l[j] == 0) \n       \
    \     {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}", "{\n    bool res = false;\n    long i = 0;\n    while (i < l.length)\
    \ \n    {\n        long num = l[i];\n        long j = i + 1;\n        while (j\
    \ < l.length) \n        {\n            if (l[j] == -num)\n            {\n    \
    \            res = true;\n            }\n            j = j + 1;\n        }\n \
    \       i = i + 1;\n    }\n    return res;\n}\n/*", "{\n  // Sorts the array\n\
    \  l.sort;\n  long n = l.length;\n  bool has_pair = false;\n  // Declares starting\
    \ and ending points of the array\n  size_t start = 0, end = n - 1;\n  // While\
    \ the array isn't empty and the starting point is less than the end\n  while (!has_pair\
    \ && start < end)\n  {\n    // Creates a tuple of the starting and ending points\n\
    \    auto tup = tuple(l[start], l[end]);\n    // If the sum of the tuple is 0,\
    \ sets the bool to true\n    if (tup[0] + tup[1] == 0)\n    {\n      has_pair\
    \ = true;\n    }\n    // If the sum of the tuple is less than 0, move the starting\
    \ point up\n    else if (tup[0] + tup[1] < 0)\n    {\n      start++;\n    }\n\
    \    // Otherwise, move the ending point down\n    else\n    {\n      end--;\n\
    \    }\n  }\n  return has_pair;\n}", "{\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    ", "in(l) \nout(l) \n{\n    const long size = l.length;\n    bool found\
    \ = false;\n    foreach (j; 0 .. size)\n    {\n        foreach (i; j + 1 .. size)\n\
    \        {\n            if (l[i] + l[j] == 0)\n            {\n               \
    \ found = true;\n            }\n        }\n    }\n    return found;\n}\n/*", "{\
    \ \n    foreach (ref a; l)\n    {\n        foreach (ref b; l)\n        {\n   \
    \         if (a != b && a + b == 0)\n            {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}\n/*", "    if (l.length\
    \ == 0) \n        return false;\n    else if (l.length == 1) \n        return\
    \ false;\n    else \n        bool res = false;\n        foreach (i, a; l) \n \
    \           foreach (j, b; l) \n                if (a + b == 0 && i != j) \n \
    \                   res = true;\n        return res;\n        ", "{\n    foreach\
    \ (i, a; l)\n    {\n        foreach (j, b; l)\n        {\n            if (i !=\
    \ j && a + b == 0)\n            {\n                return true;\n            }\n\
    \        }\n    }\n    return false;\n}\n/*", "{ \n    int i = 0;\n    int j =\
    \ 0;\n    for (int i = 0; i < l.length; i++)\n    {\n        for (int j = 0; j\
    \ < l.length; j++)\n        {\n            if (i == j)\n            {\n      \
    \          j++;\n            }\n            if (l[i] + l[j] == 0)\n          \
    \  {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}", "{\n    typeof(Tuple!(l[0], l[0])) tmp = Tuple!(l[0], l[0]);\n \
    \   foreach(i; 1..l.length) {\n        for(size_t j = 0; j < i; j++) {\n     \
    \       if(l[i] + l[j] == 0) {\n                return true;\n            }\n\
    \        }\n    }\n    return false;\n}\n/*", "{\n    if (l.length <= 1)\n   \
    \ {\n        return false;\n    }\n    else\n    {\n        // your code goes\
    \ here\n    }\n}\n \n/*", "{\n    /*\n        algorithm notes:\n        - create\
    \ a map of input values\n        - iterate over input values and see if their\
    \ negative counterpart\n          exists in the map\n        - this is O(n) in\
    \ time complexity and O(n) in space complexity\n    */\n    if (l.length < 2)\
    \ \n    {\n        return false;\n    }\n    Map!(long, long) x = Map!(long, long)();\n\
    \    foreach (i; l) \n    {\n        x[i] = i;\n    }\n    foreach (i; l) \n \
    \   {\n        auto r = x[-i];\n        if (r !is null && r != i) \n        {\n\
    \            return true;\n        }\n    }\n    return false;\n}", "{\n    int\
    \ n = l.length;\n    bool found = false;\n    int i = 0;\n    while(i < n) \n\
    \    {\n        if(l[i] >= 0) \n        {\n            found = true;\n       \
    \     break;\n        }\n        i = i + 1;\n    }\n    if(! found) \n    {\n\
    \        return false;\n    }\n    long[] l2 = new long[n];\n    int k = 0;\n\
    \    while(k < n) \n    {\n        l2[k] = abs(l[k]);\n        k = k + 1;\n  \
    \  }\n    sort(l2);\n    int start = 0;\n    int end = n - 1;\n    int sum = 0;\n\
    \    while(start < end) \n    {\n        sum = l2[start] + l2[end];\n        if(sum\
    \ > 0) \n        {\n            end = end - 1;\n        }\n        else if(sum\
    \ < 0) \n        {\n            start = start + 1;\n        }\n        else \n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    /*", "in {\n    forall(i, j in l.indices if i < j) \n        (l[i] > 0 && l[j]\
    \ > 0) || \n        (l[i] < 0 && l[j] < 0) || \n        (l[i] == 0 && l[j] ==\
    \ 0) ==> false\n}\nout (result) {\n    result == true || result == false\n}\n\
    {\n    if (l.length < 2) {\n        return false;\n    }\n    bool found_positive\
    \ = false;\n    bool found_negative = false;\n    for(int i = 0; i < l.length;\
    \ i++) {\n        if (l[i] > 0) {\n            found_positive = true;\n      \
    \  } else if (l[i] < 0) {\n            found_negative = true;\n        }\n   \
    \ }\n    return found_positive && found_negative;\n}\n/*", "{\n    bool res =\
    \ false;\n    if(l.length >= 2) \n    {\n        for(size_t i = 0; i < l.length\
    \ - 1; i++) \n        {\n            for(size_t j = i + 1; j < l.length; j++)\
    \ \n            {\n                if(l[i] + l[j] == 0) \n                {\n\
    \                    res = true;\n                }\n            }\n        }\n\
    \    }\n    return res;\n}\n/*", "{\n    bool b = false;\n    for (int i = 0;\
    \ i < l.length; i++)\n    {\n        for (int j = i + 1; j < l.length; j++)\n\
    \        {\n            if (l[i] + l[j] == 0)\n            {\n               \
    \ b = true;\n            }\n        }\n    }\n    return b;\n}\n/*", "{\n    long\
    \ i, x;\n    int j, y;\n    if (l.length > 1)\n    {\n        i = 0;\n       \
    \ while (i < l.length)\n        {\n            x = l[i];\n            if (x ==\
    \ 0)\n            {\n                i += 1;\n            }\n            else\n\
    \            {\n                if (i < l.length - 1)\n                {\n   \
    \                 j = i + 1;\n                    while (j < l.length)\n     \
    \               {\n                        y = l[j];\n                       \
    \ if (x == -y)\n                        {\n                            return\
    \ true;\n                        }\n                        else\n           \
    \             {\n                            j += 1;\n                       \
    \ }\n                    }\n                    i += 1;\n                }\n \
    \               else\n                {\n                    i += 1;\n       \
    \         }\n            }\n        }\n        return false;\n    }\n    else\n\
    \    {\n        return false;\n    }\n}", "{\n    // todo\n    return false;\n\
    }\n/*", "{\n    immutable N = l.length;\n    if (N < 2) \n    {\n        return\
    \ false;\n    }\n    long[N] ll = l.dup;\n    std.algorithm.sort(ll);\n    long[N]\
    \ rr = ll.dup;\n    std.algorithm.reverse(rr);\n    foreach (i, el1; rr) \n  \
    \  {\n        foreach (j, el2; ll) \n        {\n            if (el1 + el2 == 0)\
    \ \n            {\n                return true;\n            }\n        }\n  \
    \  }\n    return false;\n}\n/*", "{\n  // We loop over every possible pair (i,\
    \ j)\n  foreach ( i ; 0 .. l.length )\n  {\n    foreach ( j ; i + 1 .. l.length\
    \ )\n    {\n      // If the sum of the i-th and j-th elements is zero, we've succeeded.\n\
    \      if ( l[i] + l[j] == 0 )\n        return true;\n    }\n  }\n  // If we got\
    \ here, there were no pairs that sum to zero.\n  return false;\n}\n/*", "{\n \
    \   for (int i = 0; i < l.length; i++) \n    {\n        for (int j = i + 1; j\
    \ < l.length; j++) \n        {\n            if (l[i] + l[j] == 0) \n         \
    \   {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}\n/*", "    if (all!(a => a != 0L))\n    {\n        return false;\n\
    \    }\n    else\n    {\n        const x = array(l);\n        foreach(i, val;\
    \ x)\n        {\n            foreach(j, val2; x)\n            {\n            \
    \    if (i != j)\n                {\n                    if (val + val2 == 0L)\n\
    \                    {\n                        return true;\n               \
    \     }\n                }\n            }\n        }\n        return false;\n\
    \    }", "{\n    foreach (i; l)\n    {\n        foreach (j; l)\n        {\n  \
    \          if (j != i)\n            {\n                if (i + j == 0)\n     \
    \           {\n                    return true;\n                }\n         \
    \   }\n        }\n    }\n    return false;\n}", "{\n    int count = 0;\n    foreach(int\
    \ i; l)\n    {\n        if(i == 0)\n        {\n            count++;\n        }\n\
    \    }\n    if(count >= 2)\n    {\n        return true;\n    }\n    else\n   \
    \ {\n        return false;\n    }\n}\n/*", "{\n    bool found = false;\n    foreach(long\
    \ l1; l) \n    {\n        if (l1 > 0) \n        {\n            foreach(long l2;\
    \ l) \n            {\n                if (l2 < 0) \n                {\n      \
    \              if (l1 + l2 == 0) \n                    {\n                   \
    \     found = true;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return found;\n}", "{\n    long[] l_sorted = sort(l);\n\
    \    for (int i = 0; i <= l_sorted.length - 2; i++) \n    {\n        if (std.binarysearch.binarySearch(l_sorted,\
    \ -l_sorted[i], i + 1, l_sorted.length) != -1) \n        {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\n/*", "{\n    //iterate over all\
    \ pairs of numbers\n    foreach(i, a; l) {\n        foreach(j, b; l) {\n     \
    \       if (a + b == 0 && i != j)\n                return true;\n        }\n \
    \   }\n    return false;\n}\n/*", "{\n    switch (l.length) \n    {\n        case\
    \ 0U:\n        case 1U:\n            return false;\n        case 2U:\n       \
    \     return l[0L] + l[1L] == 0L;\n        default:\n            l = l.sort!((long\
    \ x, long y) => x < y)();\n            for (size_t i = 0; i < l.length - 1; i++)\
    \ \n            {\n                if (l[i] + l[i + 1] == 0L) \n             \
    \   {\n                    return true;\n                }\n            }\n  \
    \          return false;\n    }\n}\n/*", "{ \n  int n = l.length;\n  if (n < 2)\
    \ return false;\n  if (n == 2) return (l[0] + l[1] == 0);\n  int[] a = l[1..n];\n\
    \  sort(a);\n  foreach (int i; 0..n-1) {\n    if (binarySearch(a, -l[i]) != -1)\
    \ return true;\n  }\n  return false;\n}", "{\n  if (l.length < 2) \n  {\n    return\
    \ false;\n  }\n  long[] sorted_array = l.sort().dup;\n  /*\n  bsearch_le([1, 2,\
    \ 3, 3, 3, 4, 7], 3) == 3\n  bsearch_le([1, 2, 3, 3, 3, 4, 7], 5) == 6\n  bsearch_le([1,\
    \ 2, 3, 3, 3, 4, 7], 0) == 0\n  bsearch_le([1, 2, 3, 3, 3, 4, 7], 1) == 0\n  bsearch_le([1,\
    \ 2, 3, 3, 3, 4, 7], 7) == 6\n  bsearch_le([1, 2, 3, 3, 3, 4, 7], 8) == 7\n  */\n\
    \  long first_element = sorted_array[0];\n  if (first_element == 0) \n  {\n  \
    \  return true;\n  }\n  long last_element = sorted_array[sorted_array.length -\
    \ 1];\n  if (last_element == 0) \n  {\n    return true;\n  }\n  if (first_element\
    \ > 0) \n  {\n    return false;\n  }\n  if (last_element < 0) \n  {\n    return\
    \ false;\n  }\n  foreach (long element; sorted_array) \n  {\n    long target =\
    \ -element;\n    long index = binarySearch(sorted_array, target);\n    if (index\
    \ >= 0) \n    {\n      return true;\n    }\n  }\n  return false;\n}\n/*", "{\n\
    \    bool b = false;\n    foreach(long x; l)\n    {\n        foreach(long y; l)\n\
    \        {\n            if(y!=x)\n            {\n                if(x+y==0)\n\
    \                {\n                    b = true;\n                }\n       \
    \     }\n        }\n    }\n    return b;\n}", "{\n    /*\n     * There are 2 ways\
    \ of achieving this:\n     * 1. Build a map of elements in the array as the key\
    \ and their count as the value.\n     * Then, traverse the array and check if\
    \ the compliment (negative element) of the current element exists in the map.\n\
    \     * If yes, we return true, else we traverse the entire array to check if\
    \ the zero is present in the array.\n     * 2.  We sort the array first.\n   \
    \  * Then, we have 2 pointers, one starting from 0 (left) and one starting from\
    \ the last element (right).\n     * We traverse the pointers and check if the\
    \ sum of the element at left and right is equal to zero.\n     * If yes, we return\
    \ true.\n     * Else, we check if sum is lesser than zero, then we increment the\
    \ left pointer else we decrement the right pointer.\n     * We keep performing\
    \ this until we find the required sum or we exhaust the array.\n     * At the\
    \ end, we return false if we did not find the required sum.\n     * Since we are\
    \ using a map, the complexity of the first approach is O(n), where n is the size\
    \ of the array.\n     * Since we are sorting, the complexity of the second approach\
    \ is O(nlogn).\n     * But since the sorting operation is done just once, which\
    \ is generally negligible compared to the time taken by the second iteration,\n\
    \     * the overall time complexity is reduced to O(n).\n     * Thus, approach\
    \ 2 is chosen here.\n     */\n    int[] sortedArray = sort(l);\n    long left\
    \ = 0;\n    long right = l.length - 1;\n    while (left < right) {\n        long\
    \ sum = sortedArray[left] + sortedArray[right];\n        if (sum == 0) {\n   \
    \         return true;\n        }\n        else if (sum < 0) {\n            left\
    \ += 1;\n        }\n        else {\n            right -= 1;\n        }\n    }\n\
    \    return false;\n}\n/*", "    if (l.length < 2) \n        return false;\n \
    \   bool[] array_b_1 = new bool[l.length];\n    foreach (i; 0 .. l.length)\n \
    \       foreach (j; i + 1 .. l.length)\n            if (l[i] + l[j] == 0)\n  \
    \              array_b_1[i] = true;\n    foreach (i; 0 .. l.length)\n        if\
    \ (array_b_1[i])\n            return true;\n    return false;\n}\n/*", "{\n  /*\n\
    \    if the array is empty, we cannot find two distinct elements that sum to zero\n\
    \  */\n  if (l.empty) \n  {\n    return false;\n  }\n  /*\n    sort the array\n\
    \  */\n  sort(l);\n  auto sz = l.size;\n  /*\n    if the smallest element is negative,\n\
    \    and the largest element is positive,\n    then there are two distinct elements\
    \ that sum to zero\n  */\n  if (l[0] < 0 && l[sz - 1] > 0) \n  {\n    return true;\n\
    \  }\n  /*\n    at this point, either the smallest element is positive,\n    or\
    \ the largest element is negative.\n    In either case, there are no two distinct\
    \ elements that sum to zero.\n  */\n  return false;\n}\n/*", "{\n    return pairs_sum_to_zero(l,\
    \ 0, l.length);\n}", "{\n    long[long] counter = newMap();\n    foreach (x; l)\
    \ \n    {\n        long res = x.get;\n        if (counter.containsKey(res)) \n\
    \        {\n            counter[res] = counter[res] + 1;\n        }\n        else\
    \ \n        {\n            counter[res] = 1;\n        }\n    }\n    foreach (x;\
    \ l) \n    {\n        long res = x.get;\n        if (counter.containsKey(-res))\
    \ \n        {\n            if ((counter[-res] > 1) || ((counter[-res] == 1) &&\
    \ (res != -res))) \n            {\n                return true;\n            }\n\
    \        }\n    }\n    return false;\n}", "{\n  long len = l.length;\n  if (len\
    \ < 2L) \n  {\n    return false;\n  }\n  auto ht = typeof(ht)();\n  foreach (long\
    \ x; l) \n  {\n    ht[x] = 1L;\n  }\n  foreach (long x; l) \n  {\n    if (ht.count(-x)\
    \ > 0L) \n    {\n      return true;\n    }\n  }\n  return false;\n}\n/*", "{\n\
    \    bool flag = false;\n    foreach(var pair; cmp.combinations(l, 2))\n    {\n\
    \        if(pair[0] + pair[1] == 0)\n        {\n            flag = true;\n   \
    \         break;\n        }\n    }\n    return flag;\n}", "{\n    int n = l.length;\n\
    \    if (n <= 1) \n    {\n        return false;\n    }\n    bool[long] myset =\
    \ new bool[long]();\n    foreach (i; l) \n    {\n        if (myset.count(0L -\
    \ i)) \n        {\n            return true;\n        }\n        myset[i] = true;\n\
    \    }\n    return false;\n}", "{\n    if(l.empty())\n    {\n        return false;\n\
    \    }\n    long[] sorted_l = l.dup.sort;\n    for(size_t i = 0; i < sorted_l.length;\
    \ i++)\n    {\n        for(size_t j = 0; j < sorted_l.length; j++)\n        {\n\
    \            if(i != j)\n            {\n                if(sorted_l[i] + sorted_l[j]\
    \ == 0)\n                {\n                    return true;\n               \
    \ }\n            }\n        }\n    }\n    return false;\n}\n/*", "{ \n  bool result;\
    \ \n  result = false; \n  foreach (i; 0 .. l.length) \n  { \n    foreach (j; i+1\
    \ .. l.length) \n    { \n      if ((l[i] + l[j]) == 0) \n      { \n        result\
    \ = true; \n      } \n    } \n  } \n  return result; \n} \n// \n// Inspired by\
    \ http://stackoverflow.com/questions/8065560/what-is-the-simplest-way-to-remove-duplicates-from-a-sequence-of-integers-in-d\n\
    // \nlong[] removeDuplicates(long[] l) \n{ \n  auto m = std.algorithm.uniq(l);\
    \ \n  auto a = new long[](m.length); \n  size_t idx = 0; \n  foreach (i; m) \n\
    \  { \n    a[idx] = i; \n    idx++; \n  } \n  return a; \n} \n// \n// checkPairSums\
    \ tests whether the array it's given is a pair-sum partition \n// of the given\
    \ number. \n// ", "{\n    bool containsZero = false;\n    long min = -1L;\n  \
    \  long max = -1L;\n    foreach(e; l)\n    {\n        if(e == 0L)\n        {\n\
    \            containsZero = true;\n        }\n        else if(e < min || min ==\
    \ -1L)\n        {\n            min = e;\n        }\n        else if(e > max ||\
    \ max == -1L)\n        {\n            max = e;\n        }\n    }\n    return containsZero\
    \ && min*max < 0L;\n}\n/*", "{\n    // YOUR CODE GOES HERE\n    // You have to\
    \ use the array module to write this.\n    long[] y;\n    y = array([]);\n   \
    \ foreach(int x;l)\n    {\n        long[] z;\n        z = array([]);\n       \
    \ y ~= x;\n        z = y;\n        if(array(unique(z)).length != z.length)\n \
    \       {\n            return true;\n        }\n    }\n    return false;\n}\n\
    /*\n    a function which takes in an array of strings, and returns\n    the second\
    \ smallest string. \n    >>> second_smallest_string([\"a\", \"aa\", \"aaa\", \"\
    b\", \"ccc\"])\n    \"b\"\n    >>> second_smallest_string([\"a\", \"aa\", \"aaa\"\
    , \"b\", \"ccc\", \"cccc\"])\n    \"ccc\"\n    >>> second_smallest_string([\"\
    a\", \"aa\", \"aaa\", \"b\", \"ccc\", \"z\"])\n    \"aaa\"\n    >>> second_smallest_string([\"\
    a\", \"aa\", \"aaa\", \"b\", \"ccc\", \"dddd\", \"zzzzz\"])\n    \"aaa\"\n*/\n\
    string second_smallest_string(string[] a) \n{\n    // YOUR CODE GOES HERE\n  \
    \  string x;\n    string y;\n    x = \"\";\n    y = \"\";\n    foreach(int i;a)\n\
    \    {\n        if(x == \"\")\n        {\n            x = a[i];\n        }\n \
    \       else if(a[i] != x && y == \"\")\n        {\n            y = a[i];\n  \
    \      }\n        else if(a[i] < x)\n        {\n            y = x;\n         \
    \   x = a[i];\n        }\n        else if(a[i] < y && a[i] != x)\n        {\n\
    \            y = a[i];\n        }\n    }\n    return y;\n}", "{\n    assert(l.length\
    \ >= 1L);\n    if (l.length == 1L) {\n        return false;\n    }\n    int[]\
    \ l_distinct = std.algorithm.uniq(l);\n    foreach (i; 0 .. l_distinct.length)\
    \ {\n        foreach (j; i + 1 .. l_distinct.length) {\n            if (l_distinct[i]\
    \ + l_distinct[j] == 0L) {\n                return true;\n            }\n    \
    \    }\n    }\n    return false;\n}", "{\n    int i = 0;\n    int j = 0;\n   \
    \ bool t = false;\n    for (i = 0; i <= length(l) - 1; i++) \n    {\n        for\
    \ (j = i + 1; j <= length(l) - 1; j++) \n        {\n            if (l[i] + l[j]\
    \ == 0) \n            {\n                t = true;\n            }\n        }\n\
    \    }\n    return t;\n}\n/*", "    requires l.length >= 0;\n    ensures !result\
    \ <==> \n        (exists int i, int j; \n            0 <= i < l.length && \n \
    \           0 <= j < l.length && \n            i != j && \n            l[i] +\
    \ l[j] == 0\n        );\n{\n    if (l.length < 2) return false;\n    long first\
    \ = l[0];\n    l = l[1 .. $];\n    bool found = false;\n    for (int i = 0; i\
    \ < l.length; i++)\n        found = found || (first + l[i] == 0);\n    return\
    \ found || pairs_sum_to_zero(l);\n}", "{\n    auto sorted = l.sort();\n    long\
    \ j = 0L;\n    long k = sorted.length - 1L;\n    while (j < k) {\n        if (sorted[j]\
    \ + sorted[k] == 0L) {\n            return true;\n        } else if (sorted[j]\
    \ + sorted[k] < 0L) {\n            j += 1L;\n        } else {\n            k -=\
    \ 1L;\n        }\n    }\n    return false;\n}\n/*", "{\n    import std.algorithm;\n\
    \    import std.math;\n    import std.range;\n    import std.stdio;\n    long[]\
    \ a = l.dup;\n    a.sort;\n    long[] neg = a.map!((x) => -x).array;\n    long[]\
    \ b = a.array;\n    long[] c = neg.array;\n    writeln(b);\n    writeln(c);\n\
    \    long i = 0L;\n    long j = 0L;\n    long n = a.length;\n    long m = neg.length;\n\
    \    while ((i != n) && (j != m))\n    {\n        writeln(i, j);\n        if (b[i]\
    \ == c[j])\n        {\n            return true;\n        }\n        else if (b[i]\
    \ < c[j])\n        {\n            i += 1L;\n        }\n        else\n        {\n\
    \            j += 1L;\n        }\n    }\n    return false;\n}", "{\n    // type:\
    \ (array[long]) -> bool\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    // there can't be a solution of size 1, so let's work on the rest\n\
    \    auto e = l[1..$];\n    foreach (i; e) \n    {\n        auto f = e[1..$];\n\
    \        if (f.contains(-i)) \n        {\n            return true;\n        }\n\
    \    }\n    return false;\n}", "{\n    immutable m = l.min;\n    immutable q =\
    \ l.max;\n    if ((m <= 0) && (q >= 0)) {\n        foreach (i; 0 .. l.length)\
    \ {\n            immutable x = -l[i];\n            immutable j = l.indexOf(x);\n\
    \            if ((j != i) && (j != -1)) {\n                return true;\n    \
    \        }\n        }\n    }\n    return false;\n}\n/*", "{ \n  foreach (n; l)\
    \ \n  { \n    if (n + 0L == 0L) \n      return true; \n  } \n  return false; \n\
    }", "{ \n    if (l.length < 2) \n    { \n        return false; \n    } \n    auto\
    \ ht = SortedSet!(long)(); \n    foreach (item; l) \n    { \n        if (ht.contains(0\
    \ - item)) \n        { \n            return true; \n        } \n        ht.insert(item);\
    \ \n    } \n    return false; \n} \n/*", "{\n    return false;\n}", "{\n    //\
    \ as a precondition, l must be sorted\n    assert(is_sorted!(x => x, l));\n  \
    \  // create an empty array\n    long[] a = [];\n    // loop through l, starting\
    \ at index 0\n    for (size_t i = 0; i < l.length; i++) \n    {\n        long\
    \ el = l[i];\n        // if there is a negative and positive number that are equal,\n\
    \        // then there are two that sum to zero\n        if (array(el, -el).count!(x\
    \ => x == el) == 2) \n        {\n            return true;\n        }\n       \
    \ // otherwise, the negative number is not in the array,\n        // so we add\
    \ it\n        a ~= el;\n    }\n    // lastly, return true if there are two distinct\
    \ numbers that\n    // sum to zero\n    return a.count!(x => x == -a[0]) == 2;\n\
    }\n/*", "{ \n    bool b(false); \n    bool have_seen(false); \n    long[] arr\
    \ = map!\"a+b\"(l[0L..$-1L], l[1L..$]); \n    foreach(x; arr) \n    { \n     \
    \   if(x == 0L) \n        { \n            if(have_seen) \n            { \n   \
    \             b = true; \n                break; \n            } \n          \
    \  else \n            { \n                have_seen = true; \n            } \n\
    \        } \n    } \n    return b; \n}\n/*", "in {\n    assert l.length >= 0;\n\
    \    for (int i = 0; i < l.length; i++) {\n      assert -10000000 <= l[i] <= 10000000;\n\
    \    }\n  }\n  out {\n    assert l.length >= 0;\n    for (int i = 0; i < l.length;\
    \ i++) {\n      assert -10000000 <= l[i] <= 10000000;\n    }\n  }\n  body {\n\
    \  //var map = new HashMap[long, int](0, (a, b) => a == b);\n    var map = new\
    \ HashMap[long, int](0, (a, b) => a == b);\n    var it = l.iterator();\n    for\
    \ (int i = 0; i < l.length; i++) {\n      map.put(it.next(), i);\n    }\n    it\
    \ = l.iterator();\n    for (int i = 0; i < l.length; i++) {\n      if (map.contains(-(it.next())))\
    \ {\n        return true;\n      }\n    }\n    return false;\n  }", "{\n    immutable\
    \ l2 = map!(a => a * -1L)(l);\n    foreach(immutable a; l) \n    {\n        foreach(immutable\
    \ b; l2) \n        {\n            if (a == b) \n            {\n              \
    \  return true;\n            }\n        }\n    }\n    return false;\n}", "{ \n\
    \  auto a = std.array.array(l); \n  foreach(v; a) \n  { \n    if(a.count(v) >\
    \ 1) return true; \n  } \n  return false; \n}", "{\n    if (l.length<2)\n    \
    \    return false;\n    \n    bool b = false;\n    foreach(i; 0..l.length-1)\n\
    \    {\n        foreach(j; i+1..l.length)\n        {\n            if (l[i]+l[j]==0)\n\
    \                b = true;\n        }\n    }\n    return b;\n}", "{\n    std.sort(l);\n\
    \    int i = 0;\n    int j = l.length - 1;\n    while(i < j)\n    {\n        if\
    \ (l[i] + l[j] == 0)\n        {\n            return true;\n        }\n       \
    \ else if (l[i] + l[j] < 0)\n        {\n            i++;\n        }\n        else\n\
    \        {\n            j--;\n        }\n    }\n    return false;\n}", "{\n  \
    \  if ( l.length < 2 )\n        return false;\n    auto numbers = l.sorted;\n\
    \    for (int i = 0; i < numbers.length - 1; i++)\n    {\n        if (numbers[i]\
    \ + numbers[i + 1] == 0)\n            return true;\n    }\n    return false;\n\
    }\n/*", "{\n    foreach (int i; 0 .. l.length) \n    {\n        foreach (int j;\
    \ 0 .. l.length) \n        {\n            if ((i != j) && (l[i] + l[j] == 0))\
    \ \n            {\n                return true;\n            }\n        }\n  \
    \  }\n    return false;\n}\n/*", "{\n    /*\n        Create a map from integers\
    \ to integers.\n        We will use this to keep track of how many times we have\
    \ seen each integer\n        in the array.\n    */\n    auto m = std.typecons.Map!(long,\
    \ long)();\n    for (l1; l) {\n        /*\n            The key is the integer\
    \ we are looking at, and the value is the \n            number of times we have\
    \ seen it.\n        */\n        if (m.keys.canFind(l1)) {\n            m[l1] =\
    \ m[l1] + 1L;\n        } else {\n            m[l1] = 1L;\n        }\n    }\n \
    \   for (l1; l) {\n        /*\n            If the number of times we have seen\
    \ the integer we are looking at\n            is greater than one and the negative\
    \ of the integer we are looking at\n            is a key in the map, then we have\
    \ found a pair of distinct integers\n            that sum to zero.\n        */\n\
    \        if (m[l1] > 1L && m.keys.canFind(-l1)) {\n            return true;\n\
    \        }\n        /*\n            If the number of times we have seen the integer\
    \ we are looking at\n            is greater than zero and the negative of the\
    \ integer we are looking at\n            is a key in the map and the number of\
    \ times we have seen the integer\n            that is the negative of the integer\
    \ we are looking at is greater than zero,\n            then we have found a pair\
    \ of distinct integers that sum to zero.\n        */\n        if (m[l1] > 0L &&\
    \ m.keys.canFind(-l1) && m[-l1] > 0L) {\n            return true;\n        }\n\
    \    }\n    return false;\n}", "{\n    for (int i = 0; i < l.length; i++)\n  \
    \  {\n        for (int j = i + 1; j < l.length; j++)\n        {\n            if\
    \ (l[i] + l[j] == 0) return true;\n        }\n    }\n    return false;\n}\n/*",
  "{\n    for (int i = 0; i < l.length; i++)\n    {\n        for (int j = i + 1; j\
    \ < l.length; j++)\n        {\n            if (l[i] + l[j] == 0)\n           \
    \ {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}", "{\n    long[] s = sort(l);\n    long[] r = copy(s);\n    long[]\
    \ s_ = reverse(s);\n    //concat(s, s_);\n    auto p = zip(s, s_);\n    int i\
    \ = 0;\n    foreach(x; p)\n    {\n        if(x[0] + x[1] == 0)\n        {\n  \
    \          return true;\n        }\n        i++;\n    }\n    return false;\n}",
  "{ \n  typeof(l[0])[] list = l.dup;\n  return sort!((a, b) => a > b)(list).pairs!((x,\
    \ y) => x + y == 0).length > 0;\n}", "{ \n    for (int i = 0; i < l.length; i++)\
    \ \n    { \n        for (int j = i + 1; j < l.length; j++) \n        { \n    \
    \        if (l[i] + l[j] == 0) \n            { \n                return true;\
    \ \n            } \n        } \n    } \n    return false; \n} \n/*", "    if (l.length\
    \ < 2) \n        return false;\n    else\n        l.sort;\n        long[] l2 =\
    \ l.dup;\n        long[] l3 = l.dup;\n        long max = l.max;\n        for (int\
    \ i = 0; i < l.length; i++)\n            l2[i] = abs(l[i]);\n        long min\
    \ = l2.min;\n        for (int i = 0; i < l.length; i++)\n            l3[i] = l[i]\
    \ + min;\n        l3.sort;\n        int l3len = l3.length;\n        for (int i\
    \ = 0; i < l3len - 1; i++)\n            if (l3[i] == l3[i + 1])\n            \
    \    return true;\n        return false;\nend pairs_sum_to_zero;", "{\n    assert(l.length\
    \ >= 1);\n    if (l.length == 1)\n    {\n        return false;\n    }\n    else\n\
    \    {\n        auto sum = 0L;\n        foreach (i; l)\n        {\n          \
    \  if (sum == 0L)\n            {\n                sum = i;\n            }\n  \
    \          else\n            {\n                sum = sum + i;\n            }\n\
    \        }\n        if (sum == 0L)\n        {\n            return true;\n    \
    \    }\n        else\n        {\n            return false;\n        }\n    }\n\
    }\n/*", "{\n    // your code here\n    return false;\n}", "in\n    assert(l !is\
    \ null);\n{\n    bool ret = false;\n    long[] positive = new long[0];\n    long[]\
    \ negative = new long[0];\n    foreach(l_i; l)\n    {\n        if(l_i > 0)\n \
    \       {\n            positive ~= l_i;\n        }\n        else if(l_i < 0)\n\
    \        {\n            negative ~= l_i;\n        }\n        else\n        {\n\
    \            continue;\n        }\n    }\n    assert(positive.length >= 0);\n\
    \    assert(negative.length >= 0);\n    if(positive.length > 0 && negative.length\
    \ > 0)\n    {\n        ret = true;\n    }\n    return ret;\n}\n/*", "{\n    auto\
    \ count = std.range.iota(long.max).take(l.length).map!((a) => false);\n    foreach(i,\
    \ index; l) \n    {\n        if (count[i]) \n        {\n            return true;\n\
    \        }\n        count[-i] = true;\n    }\n    return false;\n}\n/*", "{\n\
    \    bool res;\n    if(l.length < 2)\n    {\n        res = false;\n    }\n   \
    \ else\n    {\n        res = false;\n        for(int i = 0; i < l.length; i++)\n\
    \        {\n            for(int j = i + 1; j < l.length; j++)\n            {\n\
    \                if(l[i] + l[j] == 0)\n                {\n                   \
    \ res = true;\n                }\n            }\n        }\n    }\n    return\
    \ res;\n}\n/*", "{\n    bool flag = false;\n    int i = 0;\n    int j = l.length;\n\
    \    while(i < j) {\n        foreach(x; l) {\n            if(x + l[i] == 0) {\n\
    \                flag = true;\n            }\n        }\n        i++;\n    }\n\
    \    return flag;\n}\n/*", "{\n    \n}", "    in (\n        l.length < 2 || \n\
    \        (\n            l.length > 1 && \n            forall(i; 0 .. l.length\
    \ - 1) \n                (\n                    l[i] != 0 || \n              \
    \      forall(j; i + 1 .. l.length)\n                        (\n             \
    \               l[j] != 0\n                        )\n                )\n    \
    \    )\n    )\n    out (true)\n{\n    if (l.length < 2) return false;\n    for\
    \ (int i = 0; i < l.length - 1; i++) {\n        if (l[i] == 0) {\n           \
    \ for (int j = i + 1; j < l.length; j++) {\n                if (l[j] == 0) return\
    \ false;\n            }\n        }\n    }\n    int[] a = copy(l);\n    std.sort.mergeSort(a);\n\
    \    int j = a.length - 1;\n    int i = 0;\n    while (i < j) {\n        if (a[i]\
    \ + a[j] == 0) return true;\n        else if (a[i] + a[j] < 0) i++;\n        else\
    \ j--;\n    }\n    return false;\n}\n/*", "{\n    auto n = l.length;\n    if(n\
    \ == 1)\n    {\n        return false;\n    }\n    if(n == 2)\n    {\n        return\
    \ l[0] + l[1] == 0;\n    }\n    long first = l[0];\n    long last = l[n - 1];\n\
    \    long i = first + 1;\n    long j = last - 1;\n    while(i < j)\n    {\n  \
    \      long k = i + j;\n        if(k == 0)\n        {\n            return true;\n\
    \        }\n        if(k < 0)\n        {\n            i++;\n        }\n      \
    \  else\n        {\n            j--;\n        }\n    }\n    return false;\n}",
  "{\n    foreach (x; l)\n    {\n        foreach (y; l)\n        {\n            if\
    \ (x != y && x + y == 0) \n            {\n                return true;\n     \
    \       }\n        }\n    }\n    return false;\n}", "    if (l.length >= 2) \n\
    \    {\n        unordered_set!long lset = new unordered_set!long();\n        foreach\
    \ (idx, x; l) \n        {\n            if (lset.count(-x) > 0) \n            {\n\
    \                return true;\n            }\n            lset.insert(x);\n  \
    \      }\n    }\n    return false;\n}\n/*", "in {\n    foreach(i;0..l.length)\n\
    \        assert(l[i] != 0);\n}\nout {\n    assert(l.length <= old(l.length));\n\
    \    foreach(i;0..l.length)\n        assert(l[i] == old(l[i]));\n}\nbody {\n \
    \   bool ret = false;\n    foreach(i;0..l.length) {\n        foreach(j;0..l.length)\
    \ {\n            if (l[i] + l[j] == 0) {\n                ret = true;\n      \
    \      }\n        }\n    }\n    return ret;\n}\n/*", "{\n    bool pairs_sum_to_zero(long[]\
    \ l) {\n    // Your code goes here\n    foreach(long i; l)\n    {\n    foreach(long\
    \ j; l)\n    {\n        if(i!=j)\n        {\n            if(i+j==0)\n        \
    \    {\n                return true;\n            }\n        }\n    }\n    }\n\
    \    return false;\n}\n}\n \n}", "{\n    assert(l.length >= 0L);\n    const size_t\
    \ N = l.length;\n    if (N < 2L) \n    {\n        return false;\n    }\n    long\
    \ s = 0L;\n    foreach (i; 0L .. N) \n    {\n        foreach (j; i + 1L .. N)\
    \ \n        {\n            s += l[i] + l[j];\n        }\n    }\n    return (s\
    \ == 0L);\n}\n/*", "{\n    int sz = l.length;\n    if (sz < 2) \n    {\n     \
    \   return false;\n    }\n    bool have_zero = false;\n    for (int i = 0; i <\
    \ sz; i++) \n    {\n        if (l[i] == 0) \n        {\n            have_zero\
    \ = true;\n            break;\n        }\n    }\n    if (have_zero) \n    {\n\
    \        for (int i = 0; i < sz; i++) \n        {\n            if (l[i] == 0 &&\
    \ i != 0) \n            {\n                return true;\n            }\n     \
    \   }\n    }\n    else \n    {\n        for (int i = 0; i < sz; i++) \n      \
    \  {\n            for (int j = i + 1; j < sz; j++) \n            {\n         \
    \       if (l[i] + l[j] == 0) \n                {\n                    return\
    \ true;\n                }\n            }\n        }\n    }\n    return false;\n\
    }\n/*", "    in (l.length >= 0 && forall(i in 0 .. l.length - 1) l[i] >= 0)\n\
    \    out (result == forall(i in 0 .. l.length - 1; j in i + 1 .. l.length - 1)\
    \ l[i] + l[j] != 0);\n{\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  for(int j = i + 1; j < l.length; j++)\n        {\n            if(l[i] + l[j]\
    \ == 0)\n            {\n                return true;\n            }\n        }\n\
    \    }\n    return false;\n}\n/*", "{\n    immutable int lsize = l.length;\n \
    \   if (lsize < 2) \n    {\n        return false;\n    }\n    immutable int msize\
    \ = lsize / 2;\n    immutable int rsize = lsize - msize;\n    immutable long[]\
    \ m = l[0 .. msize];\n    immutable long[] r = l[msize .. $];\n    if (array(m).sum\
    \ + array(r).sum == 0) \n    {\n        return true;\n    }\n    return pairs_sum_to_zero(m)\
    \ || pairs_sum_to_zero(r);\n}", "{\n    bool b;\n    for (int i=0; i<l.length;\
    \ i++) {\n        for (int j=i+1; j<l.length; j++) {\n            if (l[i] + l[j]\
    \ == 0) {\n                b = true;\n                break;\n            }\n\
    \        }\n    }\n    return b;\n}\n/*", "{ \n    bool res = false;\n    int\
    \ i = 0;\n    while (i < l.length)\n    {\n        int j = i + 1;\n        while\
    \ (j < l.length)\n        {\n            res = res or (l[i] + l[j] == 0);\n  \
    \          j = j + 1;\n        }\n        i = i + 1;\n    }\n    return res;\n\
    }\n/*", "{\n    long[] z = new long[0];\n    if (l.equal(z))\n    {\n        return\
    \ false;\n    }\n    foreach (elem; l)\n    {\n        foreach (elem2; l)\n  \
    \      {\n            if (elem != elem2)\n            {\n                if (elem\
    \ + elem2 == 0)\n                {\n                    return true;\n       \
    \         }\n            }\n        }\n    }\n    return false;\n}\n/*", "{ \n\
    \  long[int] d = (long[int])[:]; \n  bool b = false; \n  foreach (int i; 0 ..\
    \ l.length) \n  { \n    int key = l[i]; \n    if (d.count(key) > 0) \n    { \n\
    \      b = true; \n      break; \n    } \n    int neg = key * -1; \n    d[neg]\
    \ = neg; \n  } \n  return b; \n}\n/*", "{\n    foreach (i; 0 .. l.length)\n  \
    \  {\n        foreach (j; i+1 .. l.length)\n        {\n            if (l[i] +\
    \ l[j] == 0)\n            {\n                return true;\n            }\n   \
    \     }\n    }\n    return false;\n}\n// A title is a string that begins with\
    \ a single upper case letter.", "{\n    // takes an array of long integers and\
    \ returns a new array where\n    // each distinct element is repeated twice\n\
    \    // >>> repeat_distinct([1L, 2L, 3L, 4L])\n    // [1L, 1L, 2L, 2L, 3L, 3L,\
    \ 4L, 4L]\n    // >>> repeat_distinct([5L, 3L, 3L, 1L])\n    // [5L, 5L, 3L, 3L,\
    \ 1L, 1L]\n    auto repeat_distinct(long[] l) \n    {\n        auto s = set!(typeof(l))(l);\n\
    \        auto r = new long[][s.length](s.length);\n        auto i = 0;\n     \
    \   foreach (e; s) \n        {\n            r[i] = e;\n            i++;\n    \
    \    }\n        return repeat(r);\n    }\n    // takes an array of integers as\
    \ an input. it returns true if there are\n    // two distinct elements in the\
    \ array that sum to zero, and false\n    // otherwise.\n    // >>> pairs_sum_to_zero([1L,\
    \ 3L, 5L, 0L])\n    // false\n    // >>> pairs_sum_to_zero([1L, 3L, -2L, 1L])\n\
    \    // false\n    // >>> pairs_sum_to_zero([1L, 2L, 3L, 7L])\n    // false\n\
    \    // >>> pairs_sum_to_zero([2L, 4L, -5L, 3L, 5L, 7L])\n    // true\n    //\
    \ >>> pairs_sum_to_zero([1L])\n    // false\n    auto pairs_sum_to_zero(long[]\
    \ l) \n    {\n        if (l.length < 2) \n        {\n            return false;\n\
    \        }\n        else \n        {\n            auto s = set!(typeof(l))(l);\n\
    \            auto r = repeat_distinct(l);\n            // take an integer and\
    \ return its negative\n            // >>> neg(2L)\n            // -2L\n      \
    \      // >>> neg(-3L)\n            // 3L\n            auto neg(long", "{\n  \
    \  bool b = false;\n    for (long i = 0; i < l.length; i++)\n    {\n        for\
    \ (long j = 0; j < l.length; j++)\n        {\n            if (i != j)\n      \
    \      {\n                if (l[i] + l[j] == 0)\n                {\n         \
    \           b = true;\n                }\n            }\n        }\n    }\n  \
    \  return b;\n}\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n\
    \    }\n    else\n    {\n        bool res = false;\n        int i = 0;\n     \
    \   while (i < l.length && !res)\n        {\n            int j = i + 1;\n    \
    \        while (j < l.length && !res)\n            {\n                if (l[i]\
    \ + l[j] == 0)\n                {\n                    res = true;\n         \
    \       }\n                else\n                {\n                    j += 1;\n\
    \                }\n            }\n            i += 1;\n        }\n        return\
    \ res;\n    }\n}\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n\
    \    }\n    else\n    {\n        auto t = tuple(l[0], l[1]);\n        auto set1\
    \ = set(t);\n        for (int i = 2; i < l.length; i++)\n        {\n         \
    \   if (set1.count(l[i]) == 1)\n            {\n                return true;\n\
    \            }\n            else\n            {\n                for (int j =\
    \ 0; j < i; j++)\n                {\n                    auto t1 = tuple(l[i],\
    \ l[j]);\n                    set1.insert(t1);\n                }\n          \
    \  }\n        }\n        return false;\n    }\n}", "{\n    // What if l.length\
    \ is 1? \n    if (l.length == 1) \n    {\n        return false;\n    }\n    //\
    \ l.length is greater than 1.\n    // check for duplicate pairs.\n    for (int\
    \ i = 0; i < l.length; i++) \n    {\n        for (int j = i + 1; j < l.length;\
    \ j++) \n        {\n            if (l[i] == l[j]) \n            {\n          \
    \      return true;\n            }\n        }\n    }\n    // check for non-duplicate\
    \ pairs.\n    for (int i = 0; i < l.length; i++) \n    {\n        for (int j =\
    \ i + 1; j < l.length; j++) \n        {\n            if (l[i] + l[j] == 0) \n\
    \            {\n                return true;\n            }\n        }\n    }\n\
    \    return false;\n}", "{\n    foreach (i; 0 .. l.length) \n    {\n        foreach\
    \ (j; i + 1 .. l.length) \n        {\n            if (l[i] + l[j] == 0) \n   \
    \         {\n                return true;\n            }\n        }\n    }\n \
    \   return false;\n}\n/*", "{\n    auto x = l.sort;\n    immutable i = 0L;\n \
    \   immutable j = x.length - 1L;\n    while (i < j) {\n        if (x[i] + x[j]\
    \ == 0L) {\n            return true;\n        }\n        else if (x[i] + x[j]\
    \ < 0L) {\n            i += 1L;\n        }\n        else {\n            j -= 1L;\n\
    \        }\n    }\n    return false;\n}\n/*", "{\n    // Check that there are\
    \ enough longs in the input array.\n    if(l.length < 2) \n    {\n        return\
    \ false;\n    }\n    // Create an array to store the results.\n    bool[] b =\
    \ new bool[l.length];\n    // Iterate over all of the longs in the input array.\n\
    \    foreach(j; 0 .. l.length) \n    {\n        // Check to see if there is a\
    \ long in the array that is the negative\n        // of the current long.\n  \
    \      if(l[j] != 0L && l.canFind(-l[j])) \n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}", "{\n    bool b;\n    bool t;\n    {\n\
    \        bool[] tmp1;\n        bool[] tmp0;\n        size_t i;\n        size_t\
    \ j;\n        bool tmp2;\n        tmp1 = new bool[l.length];\n        t = false;\n\
    \        tmp0 = new bool[l.length];\n        i = 0;\n        while (i < l.length)\
    \ \n        {\n            j = 0;\n            while (j < l.length) \n       \
    \     {\n                if (l[i] + l[j] == 0) \n                {\n         \
    \           if ((i == j)) \n                    {\n                        tmp1[i]\
    \ = true;\n                    }\n                    else \n                \
    \    {\n                        tmp0[i] = true;\n                    }\n     \
    \           }\n                else \n                {\n                    if\
    \ ((i == j)) \n                    {\n                        tmp1[i] = false;\n\
    \                    }\n                    else \n                    {\n   \
    \                     tmp0[i] = false;\n                    }\n              \
    \  }\n                j = j + 1;\n            }\n            i = i + 1;\n    \
    \    }\n        tmp2 = false;\n        i = 0;\n        while (i < l.length) \n\
    \        {\n            if (tmp0[i]) \n            {\n                tmp2 = true;\n\
    \            }\n            i = i + 1;\n        }\n        b = tmp2;\n       \
    \ i = 0;\n        while (i < l.length) \n        {\n            if (tmp1[i]) \n\
    \            {\n                t = true;\n            }\n            i = i +\
    \ 1;\n        }\n    }\n    return t || b;\n}\n/*", "{\n    /*\n    Iterates over\
    \ the array and places each element in a map with the key\n    being the element\
    \ itself. If a second element with the same value\n    is encountered, return\
    \ true.\n    */\n    auto m = std.typecons.makeAssocArray!(long, bool)();\n  \
    \  foreach(e; l) {\n        if(m.exists(e)) {\n            return true;\n    \
    \    }\n        m[e] = true;\n    }\n    return false;\n}\n/*", "{\n    return\
    \ l.length >= 2 && (l[0] == 0L || l[1] == 0L);\n}\n/*", "{\n    if (l.length <\
    \ 2)\n    {\n        return false;\n    }\n    long[] result = new long[l.length];\n\
    \    // we only need to check i times, and only\n    // use j once.\n    // n(n+1)/2\n\
    \    // n^2, n^2+n\n    // n\n    for (int i = 0; i < l.length; i++)\n    {\n\
    \        for (int j = 0; j < l.length; j++)\n        {\n            if (i != j)\n\
    \            {\n                if (l[i] + l[j] == 0)\n                {\n   \
    \                 return true;\n                }\n            }\n        }\n\
    \    }\n    return false;\n}\n/*", "{\n    if (l.length <= 1)\n    {\n       \
    \ return false;\n    }\n    immutable sorted_l = l.sort();\n    bool found_pair\
    \ = false;\n    long current_min = sorted_l[0];\n    long current_max = sorted_l[sorted_l.length\
    \ - 1];\n    if (current_min < 0 && current_max > 0)\n    {\n        long mid_point\
    \ = (-current_min / (1 + current_min + current_max) *\n                      \
    \    (sorted_l.length - 1)) + .5;\n        long left_index = mid_point - 1;\n\
    \        long right_index = mid_point + 1;\n        found_pair = left_index >=\
    \ 0 && right_index < sorted_l.length;\n        while (!found_pair && left_index\
    \ >= 0 && right_index < sorted_l.length)\n        {\n            if (sorted_l[left_index]\
    \ + sorted_l[right_index] == 0)\n            {\n                found_pair = true;\n\
    \            }\n            else if (sorted_l[left_index] + sorted_l[right_index]\
    \ < 0)\n            {\n                right_index++;\n            }\n       \
    \     else\n            {\n                left_index--;\n            }\n    \
    \    }\n    }\n    return found_pair;\n}\n/*", "    in(l) => \n        l.length\
    \ > 0 && \n        (0L in l.zip(l.dropOne()).map!((x, y) => x + y));", "{\n  \
    \  assert(!l.empty);\n    if (l.length == 1)\n    {\n        return false;\n \
    \   }\n    assert(l.length >= 2);\n    l = l.sort();\n    long[long] h = l.map!(y\
    \ => tuple(y, true)).assocArray;\n    foreach (ref v; l)\n    {\n        auto\
    \ found = h.find(-v);\n        if (found !is null && (v != 0 || *found[1]))\n\
    \        {\n            if (v == 0)\n            {\n                *found[1]\
    \ = false;\n            }\n            return true;\n        }\n    }\n    return\
    \ false;\n}\n/*", "{\n    // Write your code here\n    //########################################\n\
    \    const int n = l.length;\n    int i;\n    bool found = false;\n    for (i\
    \ = 0; i < n; i++)\n    {\n        if (found) break;\n        for (int j = i +\
    \ 1; j < n; j++)\n        {\n            if (l[i] + l[j] == 0) found = true;\n\
    \        }\n    }\n    return found;\n    //########################################\n\
    }", "{\n    enum alen = l.length;\n    if (alen < 2)\n    {\n        return false;\n\
    \    }\n    if (alen == 2)\n    {\n        return l[0] + l[1] == 0;\n    }\n \
    \   int[] arr = std.algorithm.map!(a => a)(l);\n    int idx1 = 0;\n    int idx2\
    \ = alen - 1;\n    while (idx1 < idx2)\n    {\n        auto sum = arr[idx1] +\
    \ arr[idx2];\n        if (sum == 0)\n        {\n            return true;\n   \
    \     }\n        if (sum < 0)\n        {\n            idx1 += 1;\n        }\n\
    \        else\n        {\n            idx2 -= 1;\n        }\n    }\n    return\
    \ false;\n}", "{\n  int i;\n  long x;\n  foreach (i, x; l) \n  {\n    long y;\n\
    \    foreach (y; l[i+1..$])\n    {\n      if ((x + y) == 0) \n      {\n      \
    \  return true;\n      }\n    }\n  }\n  return false;\n}\n/*", "{\n    bool found\
    \ = false;\n    long i = 0L;\n    while (!(i >= l.length - 1L) && !found)\n  \
    \  {\n        long j = i + 1L;\n        while (!(j >= l.length) && !found)\n \
    \       {\n            found = (l[i] + l[j]) == 0L;\n            j += 1L;\n  \
    \      }\n        i += 1L;\n    }\n    return found;\n}", "{ \n    \n    \n  \
    \  \n    \n    \n    \n    int n = l.length; \n    foreach (i; 0 .. n - 1) \n\
    \    { \n        foreach (j; i + 1 .. n - 1) \n        { \n            if (l[i]\
    \ + l[j] == 0) \n                return true; \n        } \n    } \n    return\
    \ false; \n}\n/*", "{\n    bool flag = false;\n    std.typecons.Pair[int, int]\
    \ p;\n    p = std.typecons.Pair(0,0);\n    for (int i = 0; i < l.length; i++)\
    \ \n    {\n        for (int j = 0; j < l.length; j++) \n        {\n          \
    \  if (l[i] + l[j] == 0) \n            {\n                if (i != j) \n     \
    \           {\n                    flag = true;\n                    p = std.typecons.Pair(i,\
    \ j);\n                }\n            }\n        }\n    }\n    if (flag) \n  \
    \  {\n        writeln(\"There is a pair in position (\", p.first, \",\", p.second,\
    \ \") that sums to zero.\");\n    } \n    else \n    {\n        writeln(\"There\
    \ is no pair that sums to zero.\");\n    }\n    return flag;\n}", "{\n    // Sort\
    \ the elements of l\n    sort(l);\n    // Set i to 0\n    int i = 0;\n    // Set\
    \ j to the length of l minus 1\n    int j = l.length - 1;\n    while (i < j) \n\
    \    {\n        long sum = l[i] + l[j];\n        if (sum == 0) \n        {\n \
    \           return true;\n        }\n        else if (sum < 0) \n        {\n \
    \           i += 1;\n        }\n        else \n        {\n            j -= 1;\n\
    \        }\n    }\n    return false;\n}\n/*", "{\n    bool found_it = false;\n\
    \    foreach (i; l)\n    {\n        foreach (j; l)\n        {\n            if\
    \ (i + j == 0 && i != j)\n            {\n                found_it = true;\n  \
    \          }\n        }\n    }\n    return found_it;\n}\n/*", "{\n    return !(l[0]\
    \ < 0 || l[1] < 0);\n}", "{\n    long x;\n    bool b = false;\n    foreach(x;\
    \ l) \n    {\n        if (x == 0L) \n        {\n            b = true;\n      \
    \  }\n    }\n    return b;\n}\n/*", "{\n    if (l.length < 2)\n    {\n       \
    \ return false;\n    }\n    int i = 0;\n    int j = 1;\n    while (i < j && j\
    \ < l.length)\n    {\n        if (l[i] + l[j] == 0)\n        {\n            return\
    \ true;\n        }\n        else if (j == l.length - 1)\n        {\n         \
    \   i++;\n            j = i + 1;\n        }\n        else\n        {\n       \
    \     j++;\n        }\n    }\n    return false;\n}", "{\n    bool has_zero = false;\n\
    \    Map!(long, bool) seen = Map!(long, bool)();\n    foreach (a; l) {\n     \
    \   if (a == 0L) {\n            has_zero = true;\n        }\n        if (seen.contains(a))\
    \ {\n            return true;\n        }\n        seen[-a] = true;\n    }\n  \
    \  return has_zero && seen.contains(0L);\n}\n/*", "{\n    bool pairs = false;\n\
    \    int i = 0;\n    int j = 1;\n    int size = l.length;\n    while (i < size\
    \ && j < size)\n    {\n        if (l[i] + l[j] == 0)\n        {\n            pairs\
    \ = true;\n            break;\n        }\n        else if (l[i] + l[j] < 0)\n\
    \        {\n            j += 1;\n        }\n        else\n        {\n        \
    \    i += 1;\n        }\n    }\n    return pairs;\n}", "{ \n    if (l.length <=\
    \ 1) \n    { \n        return false; \n    } \n  \n    int n = l.length; \n  \
    \  long sum = 0; \n    foreach (i; 0 .. n) \n    { \n        sum += l[i]; \n \
    \   } \n  \n    if (sum == 0) \n    { \n        return true; \n    } \n  \n  \
    \  return false; \n} ", "{\n  long temp;\n  long j;\n  long k;\n  for (j=0L;j<=l.length-1L;j++)\
    \ \n  {\n    for (k=j+1L;k<=l.length-1L;k++) \n    {\n      if (l[j]+l[k]==0L)\
    \ \n      {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n/*",
  "{\n    immutable unique_set = l.sort().unique;\n    foreach(x; l)\n    {\n    \
    \    if(unique_set.contains(-x))\n        {\n            return true;\n      \
    \  }\n    }\n    return false;\n}", "{\n    int index = 0;\n    int flag = 0;\n\
    \    bool found = false;\n    for (int i = 0; i < l.length; i++)\n    {\n    \
    \    for (int j = i + 1; j < l.length; j++)\n        {\n            if (l[i] +\
    \ l[j] == 0)\n            {\n                found = true;\n                break;\n\
    \            }\n        }\n    }\n    return found;\n}\n// not working", "{\n\
    \    if (l.length > 1)\n    {\n        foreach (i; l)\n        {\n           \
    \ foreach (j; l)\n            {\n                if (i != j && i + j == 0)\n \
    \               {\n                    return true;\n                }\n     \
    \       }\n        }\n    }\n    return false;\n}\n/*", "{ \n    return l.tupleof.sort().product.map!(x\
    \ => x.expand).pairwise.any!(t => t[0] + t[1] == 0);\n} \n/*", "{\n    long[]\
    \ temp = l;\n    long x = 0L;\n    long y = 0L;\n    int found = 0;\n    /*\n\
    \    foreach (x; l) {\n        foreach (y; temp) {\n            if (x != y) {\n\
    \                if (x + y == 0L) {\n                    found = 1;\n        \
    \            break;\n                }\n            }\n        }\n        if (found\
    \ == 1) break;\n    }\n    */\n    foreach (x; l) {\n        foreach (y; temp)\
    \ {\n            if (x != y) {\n                if (x + y == 0L) {\n         \
    \           return true;\n                }\n            }\n        }\n    }\n\
    \    return false;\n}", "{\n    const long size = l.length;\n    if (size < 2)\
    \ return false;\n    long[] g = l[0..size];\n    // sort array\n    sort(g.ptr,\
    \ g.ptr + size);\n    long j = size - 1;\n    long i = 0;\n    while (i < j) {\n\
    \        long sum = g[i] + g[j];\n        if (sum == 0) return true;\n       \
    \ if (sum < 0) i++;\n        else j--;\n    }\n    return false;\n}\n// same as\
    \ above but with low-level foreach loops", "{\n    if (l.length <= 1) \n    {\n\
    \        return false;\n    }\n    auto is_positive = std.algorithm.count(l, x\
    \ => x > 0);\n    auto is_negative = std.algorithm.count(l, x => x < 0);\n   \
    \ if (is_positive > 0 && is_negative > 0) \n    {\n        // Avoid allocating\
    \ a set for the common case of\n        // no zero-sum pairs.\n        auto positive_numbers\
    \ = std.algorithm.filter!(a => a > 0)(l);\n        foreach (i, x; positive_numbers)\
    \ \n        {\n            if (std.binarysearch.equal_range(positive_numbers[i\
    \ + 1 .. $], -x).length > 0) \n            {\n                return true;\n \
    \           }\n        }\n    }\n    return false;\n}\n/*", "{\n    immutable\
    \ n = l.length;\n    l = sort(l);\n    for (size_t i = 0; i < n; i++) \n    {\n\
    \        if ((binarySearch(l, -l[i]) >= 0) && (binarySearch(l, -l[i]) != i)) \n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}",
  "{\n    bool flag = false;\n    for (int i = 0; i < l.length; i++)\n    {\n    \
    \    for (int j = 0; j < l.length; j++)\n        {\n            if (i == j)\n\
    \            {\n                continue;\n            }\n            else\n \
    \           {\n                if (l[i] + l[j] == 0)\n                {\n    \
    \                flag = true;\n                }\n            }\n        }\n \
    \   }\n    return flag;\n}\n/*", "{\n    assert(std.range.isSorted(l));\n    if\
    \ (l.length < 2) return false;\n    long start = 0;\n    long end = l.length -\
    \ 1;\n    while (start != end) \n    {\n        long sum = l[start] + l[end];\n\
    \        if (sum == 0) return true;\n        if (sum < 0) start++;\n        else\
    \ end--;\n    }\n    return false;\n}\n/*", "{\n    long[] nums = l.slice();\n\
    \    int[int] foo;\n    bool[int] bar;\n    int[int] baz;\n    for (int i = 0;\
    \ i < nums.length; i++)\n    {\n        foo[nums[i]] = 1;\n        baz[nums[i]]\
    \ = i;\n    }\n    for (int i = 0; i < nums.length; i++)\n    {\n        int num\
    \ = nums[i];\n        if (foo[-num] == 1 && baz[-num] != i)\n        {\n     \
    \       return true;\n        }\n    }\n    return false;\n}\n/*", "{\n    foreach\
    \ (i; 0 .. l.length)\n    {\n        foreach (j; i + 1 .. l.length)\n        {\n\
    \            if ((l[i] + l[j]) == 0)\n            {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}", "    in(l.ptr) \n   \
    \ trusted \n{\n    immutable long length = l.length;\n    if(length == 0L) return\
    \ false;\n    immutable long zero = 0L;\n    foreach(idx; 0 .. length)\n    {\n\
    \        auto x = l[idx];\n        foreach(idy; idx+1 .. length)\n        {\n\
    \            auto y = l[idy];\n            if(x + y == zero) return true;\n  \
    \      }\n    }\n    return false;\n}", "{\n    if (l.length < 2)\n    {\n   \
    \     return false;\n    }\n    long[] l2 = l[0..l.length];\n    sort(l2);\n \
    \   foreach (ref a; l2)\n    {\n        if (a < 0)\n        {\n            long\
    \ c = -a;\n            if (binarySearch(l2, c))\n            {\n             \
    \   return true;\n            }\n        }\n    }\n    return false;\n}\n/*",
  "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    auto seen =\
    \ new long[0L];\n    foreach (elem; l)\n    {\n        if (elem == 0L)\n     \
    \   {\n            return true;\n        }\n        else if (std.algorithm.any!((a)\
    \ => (a == -elem))(seen))\n        {\n            return true;\n        }\n  \
    \      else\n        {\n            seen ~= elem;\n        }\n    }\n    return\
    \ false;\n}", "{\n\tif (l.length < 2)\n\t{\n\t\treturn false;\n\t}\n\tlong[] temp\
    \ = l.dup;\n\ttemp.sort();\n\tsize_t i = 0;\n\twhile(i < temp.length)\n\t{\n\t\
    \tif(temp[i] == 0)\n\t\t{\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(temp.contains(-temp[i]))\n\
    \t\t{\n\t\t\treturn true;\n\t\t}\n\t\ti++;\n\t}\n\treturn false;\n}\n/*", "  \
    \  in (l.length > 0)\n    out(result)\n{\n    \n    //array.sort!(i => i)(l);\n\
    \    bool result = false;\n    long k = -1L;\n    //int temp = 0;\n    long j\
    \ = l.length - 1L;\n    foreach(int i, int e; l)\n    {\n        if (e < k)\n\
    \        {\n            while(l[j] > k)\n            {\n                if (i\
    \ == j)\n                {\n                    break;\n                }\n  \
    \              j--;\n            }\n            if (l[j] == k)\n            {\n\
    \                result = true;\n                break;\n            }\n     \
    \   }\n        k = -e;\n    }\n    return result;\n}\n// int i = 0;\n// int j\
    \ = l.length - 1;\n// while (j > i)\n// {\n//     if (l[i] + l[j] == 0)\n//  \
    \   {\n//         result = true;\n//         break;\n//     }\n//     else if\
    \ (l[i] + l[j] > 0)\n//     {\n//         j--;\n//     }\n//     else\n//    \
    \ {\n//         i++;\n//     }\n// }\n// return result;\n/*\n    unique_ints_of_length\
    \ takes two integers: n and len.\n    it returns a tuple containing two arrays:\n\
    \    (1) an array of unique integers of length len,\n    (2) an array of all integers\
    \ that were not included in the first array.\n    >>> unique_ints_of_length(5L,\
    \ 2L)\n    ([3L, 1L], [2L, 4L, 5L])\n    >>> unique_ints_of_length(7L, 5L)\n \
    \   ([1L, 5L, 2L, 6L, 3L], [4L, 7L])\n    >>> unique_ints_of_length(9L, 5L)\n\
    \    ([1L, 7L, 2L, 8L, 3L], [4L, 5L, 6L, 9L])\n    >>> unique_ints_of_length(10L,\
    \ 5L)", "{\n    int i = 0;\n    int j = l.length;\n    int s = 0;\n    while (i\
    \ < j) {\n        s = l[i] + l[j];\n        if (s == 0)\n            return true;\n\
    \        else if (s > 0) {\n            j--;\n        }\n        else {\n    \
    \        i++;\n        }\n    }\n    return false;\n}\n/*", "{\n    foreach (i;\
    \ 0 .. l.length - 1) \n    {\n        foreach (j; i + 1 .. l.length) \n      \
    \  {\n            if (l[i] + l[j] == 0) \n            {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}", "{\n    if(l.length\
    \ < 2)\n        return false;\n    else if(l.length == 2)\n        return l[0]\
    \ + l[1] == 0;\n    else \n    {\n        long[] negList = l.filter!(a => a <\
    \ 0);\n        long[] posList = l.filter!(a => a > 0);\n        int negLength\
    \ = negList.length;\n        int posLength = posList.length;\n        int i =\
    \ 0;\n        int j = 0;\n        while(i < negLength && j < posLength)\n    \
    \    {\n            if(negList[i] + posList[j] == 0)\n                return true;\n\
    \            else if(negList[i] + posList[j] < 0)\n                i++;\n    \
    \        else\n                j++;\n        }\n        return false;\n    }\n\
    }\n// split_digits takes a positive integer n as input and returns\n// a tuple\
    \ of two positive integers: the first integer should be\n// the first digit of\
    \ n and the second integer should be the\n// rest of the digits.\n/*", "{\n  \
    \  if (l.length < 2)\n    {\n        return false;\n    }\n    // sort the array\n\
    \    sort(l);\n    // find the value of the largest array element\n    long max_element\
    \ = 0;\n    foreach (i; l)\n    {\n        if (i > max_element)\n        {\n \
    \           max_element = i;\n        }\n    }\n    // create an array of bools\
    \ of length max_element\n    bool[] test = new bool[max_element];\n    // set\
    \ every element to be false\n    foreach (i; test)\n    {\n        i = false;\n\
    \    }\n    // set the array element to be true if the integer is in the list\n\
    \    foreach (i; l)\n    {\n        if (i > 0)\n        {\n            test[i\
    \ - 1] = true;\n        }\n        else\n        {\n            test[abs(i)] =\
    \ true;\n        }\n    }\n    // if both i and -i are in the list, it will be\
    \ true\n    bool result = false;\n    foreach (i; l)\n    {\n        if (i < 0)\n\
    \        {\n            if (test[abs(i)])\n            {\n                result\
    \ = true;\n            }\n        }\n        else\n        {\n            if (test[i\
    \ - 1])\n            {\n                result = true;\n            }\n      \
    \  }\n    }\n    return result;\n}\n//\n/*", "{\n    \n}", "{\n    unordered_set!long\
    \ s = new unordered_set!long();\n    foreach(i; l)\n    {\n        if(s.count(-i))\n\
    \        {\n            return true;\n        }\n        s.insert(i);\n    }\n\
    \    return false;\n}\n/*", "{\n    auto len = l.length;\n    if (len < 2) \n\
    \    {\n        return false;\n    }\n    auto lo = 0L;\n    while (lo < len)\
    \ \n    {\n        auto hi = lo + 1L;\n        while (hi < len) \n        {\n\
    \            if (l[lo] + l[hi] == 0L) \n            {\n                return\
    \ true;\n            }\n            hi += 1L;\n        }\n        lo += 1L;\n\
    \    }\n    return false;\n}", "{\n    bool r;\n    r = false;\n    for (int i\
    \ = 0; i < l.length - 1; i++)\n    {\n        for (int j = i + 1; j < l.length;\
    \ j++)\n        {\n            if (l[i] + l[j] == 0)\n            {\n        \
    \        r = true;\n            }\n        }\n    }\n    return r;\n}\n/*", " \
    \   if (l.length > 1) \n    {\n        if (l.any!(a => a == 0)) \n        {\n\
    \            return true;\n        } \n        else \n        {\n            l.sort;\n\
    \            long[] abs_l = l.map!(a => abs(a)).array;\n            long abs_total\
    \ = abs_l.sum;\n            long abs_max = abs_l.back;\n            if (abs_total\
    \ - 2 * abs_max > 0) \n            {\n                return true;\n         \
    \   } \n            else \n            {\n                return false;\n    \
    \        }\n        }\n    } \n    else \n    {\n        return false;\n    }",
  "{\n    immutable m = l.length;\n    for (immutable i = 0; i < m; i++) \n    {\n\
    \        for (immutable j = i + 1; j < m; j++) \n        {\n            if (l[i]\
    \ + l[j] == 0) \n            {\n                return true;\n            }\n\
    \        }\n    }\n    return false;\n}\n/*", "{\n    immutable size = l.length;\n\
    \    for (immutable i = 0; i < size; i++) \n    {\n        for (immutable j =\
    \ i + 1; j < size; j++) \n        {\n            if (l[i] + l[j] == 0) \n    \
    \        {\n                return true;\n            }\n        }\n    }\n  \
    \  return false;\n}\n/*", "{\n    bool ret = false;\n    for (immutable i = 0;\
    \ i < l.length; i++) \n    {\n        for (immutable j = i + 1; j < l.length;\
    \ j++) \n        {\n            if (l[i] + l[j] == 0) \n            {\n      \
    \          ret = true;\n            }\n        }\n    }\n    return ret;\n}\n\
    /*", "{\n    bool has_zero = false;\n    bool[] seen = new bool[];\n    foreach\
    \ (i; l) \n    {\n        if (i == 0)\n        {\n            has_zero = true;\n\
    \        }\n        else\n        {\n            seen[i] = true;\n        }\n\
    \    }\n    foreach (i; l) \n    {\n        if (i != 0 && seen[-i])\n        {\n\
    \            return true;\n        }\n    }\n    return has_zero;\n}", "{\n  \
    \  auto sorted_array = sort(l);\n    for (int i = 0; i < sorted_array.length;\
    \ i += 1) \n    {\n        if(binary_search!([\"a < b\", \"a == b\", \"a > b\"\
    ])(sorted_array, -sorted_array[i])) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}", "{\n    bool b = false;\n    foreach(\
    \ i; 0 .. l.length)\n    {\n        foreach( j; 0 .. l.length)\n        {\n  \
    \          if( i != j && l[i] + l[j] == 0)\n            {\n                b =\
    \ true;\n            }\n        }\n    }\n    return b;\n}", "{\n    return l.length\
    \ >= 2 && \n           (l[0] == 0L || \n            l[1] == 0L || \n         \
    \   pairs_sum_to_zero(l[2..$]) || \n            pairs_sum_to_zero(l[1..$]));\n\
    }\n/*", "{\n    if (l.length <= 1) \n    {\n        return false;\n    }\n   \
    \ sort(l);\n    foreach (i; 0 .. l.length) \n    {\n        if (binarySearch(l,\
    \ -l[i]) != -1) \n        {\n            return true;\n        }\n    }\n    return\
    \ false;\n}", "{\n    // Keep track of all the distinct integers in the array.\n\
    \    // This will help us to see if the current number and its\n    // negative\
    \ are in the array.\n    long[] distinct = distinct(l);\n    // Check if the array\
    \ is empty. If it is, there can be no pairs.\n    if (distinct.length == 0) \n\
    \    {\n        return false;\n    }\n    foreach (i; distinct) \n    {\n    \
    \    // Check if the current distinct integer and its negative\n        // are\
    \ both in the array. If so, we are done.\n        if (i == 0) \n        {\n  \
    \          continue;\n        }\n        if (std.algorithm.find(distinct, -i)\
    \ != std.algorithm.find(distinct, -i).empty) \n        {\n            return true;\n\
    \        }\n    }\n    // If we finish checking all the numbers and none of them\n\
    \    // sum to zero, return false.\n    return false;\n}\n/*", "{\n    \n}", "{\n\
    \    if(l.length < 2) return false;\n    for(long i = 0; i < l.length - 1; i++)\n\
    \    {\n        for(long j = i + 1; j < l.length; j++)\n        {\n          \
    \  if(l[i] + l[j] == 0)\n            {\n                return true;\n       \
    \     }\n        }\n    }\n    return false;\n}\n/*", "{\n    int n = l.length;\n\
    \    if (n == 0) return false;\n    foreach (int i; 0 .. n) {\n        foreach\
    \ (int j; i+1 .. n) {\n            if (l[i] + l[j] == 0) {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\n/*", "{\n    size_t\
    \ i = 0u;\n    while (i < l.length) {\n        long a = l[i];\n        size_t\
    \ j = i + 1u;\n        while (j < l.length) {\n            long b = l[j];\n  \
    \          if (a + b == 0L) {\n                return true;\n            }\n \
    \           ++j;\n        }\n        ++i;\n    }\n    return false;\n}\n/*", "{\
    \ \n    if (l.length < 2) \n    { \n        return false; \n    } \n    bool[]\
    \ b = new bool[l.length]; \n    for (size_t i = 0; i < l.length; i++) \n    {\
    \ \n        if (b[l[i]+5000]) \n        { \n            return true; \n      \
    \  } \n        b[-l[i]+5000] = true; \n    } \n    return false; \n}\n/*", "{\n\
    \    bool found = false;\n    long i = 0L;\n    while (!(i >= l.length - 1L) &&\
    \ !found) {\n        long j = i + 1L;\n        while (!(j >= l.length) && !found)\
    \ {\n            if (l[i] + l[j] == 0L) {\n                found = true;\n   \
    \         }\n            j += 1L;\n        }\n        i += 1L;\n    }\n    return\
    \ found;\n}\n/*", "{\n    long[long] h = new long[long];\n    foreach (i; l) {\n\
    \        if (h.contains(i)) return true;\n        h[-i] = i;\n    }\n    return\
    \ false;\n}\n/*"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
