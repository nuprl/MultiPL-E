name: HumanEval_16_count_distinct_characters
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Given a string, find out how\
  \ many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
  xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
  */\nlong count_distinct_characters(string string) \n"
tests: "unittest\n{\n    alias candidate = count_distinct_characters;\n\n    assert(candidate(\"\
  \") == 0L);\n    assert(candidate(\"abcde\") == 5L);\n    assert(candidate(\"abcdecadeCADE\"\
  ) == 5L);\n    assert(candidate(\"aaaaAAAAaaaa\") == 1L);\n    assert(candidate(\"\
  Jerry jERRY JeRRRY\") == 5L);\n}\nvoid main(){}"
completions: ["{\n\tconst char[] array = string.chars;\n\tlong result = 0;\n\tforeach(unichar\
    \ i; array)\n\t{\n\t\tif(result == 0)\n\t\t{\n\t\t\tresult = result + 1;\n\t\t\
    }\n\t\tforeach(unichar j; array)\n\t\t{\n\t\t\tif(tolower(i) == tolower(j))\n\t\
    \t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(j == cast(unichar)array.length - 1)\n\
    \t\t\t{\n\t\t\t\tresult = result + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n\
    }", "{\n    static bool[char] s;\n    foreach(c; string) \n    {\n        s[c]\
    \ = true;\n    }\n    return s.length;\n}", "{\n    return set(map!(char.toLower)(string)).length;\n\
    }", "{\n    alias List(Tuple!(char, bool)) L;\n    L letters_and_count(string.length);\n\
    \    foreach(char letter; string)\n    {\n        bool letter_already_counted\
    \ = false;\n        int letter_index;\n        foreach(ref letter_and_count; letters_and_count)\n\
    \        {\n            ++letter_index;\n            if(letter_and_count[0] ==\
    \ letter)\n            {\n                letter_already_counted = true;\n   \
    \             break;\n            }\n        }\n        if(!letter_already_counted)\n\
    \        {\n            letters_and_count ~= tuple(letter, true);\n        }\n\
    \    }\n    return letters_and_count.length;\n}\n/*\n Given a sorted array, find\
    \ out how many different values does it contain\n    >>> count_distinct_values([-2,\
    \ 0, 1, 2, 3, 4, 6, 7, 9, 10])\n    9L\n    >>> count_distinct_values([-2, 0,\
    \ 1, 1, 2, 3, 4, 6, 7, 9, 10])\n    9L\n    >>> count_distinct_values([-2, 0,\
    \ 1, 1, 2, 3, 4, 6, 7, 9, 10, 10])\n    9L\n    >>> count_distinct_values([-2,\
    \ 0, 1, 1, 2, 3, 4, 6, 7, 9, 10, 10, 10])\n    9L\n    >>> count_distinct_values([])\n\
    \    0L\n*/\nlong count_distinct_values(T[])(T[] array) \n{\n    if(array.length\
    \ == 0)\n    {\n        return 0;\n    }\n    int distinct_values_count = 1;\n\
    \    foreach(i, j; array[1 .. $])\n    {\n        if(array[i] != array[j])\n \
    \       {\n            ++distinct_values_count;\n        }\n    }\n    return\
    \ distinct_values_count;\n}\n/*\n Given a string, find out whether it contains\
    \ a character appearing only once\n    >>> has_unique_character(\"xyzXYZ\")\n\
    \   ", "{\n    auto lower_case_string = toLower(string);\n    return \n      \
    \  lower_case_string\n        .length\n        .iota\n        .map!(ch => lower_case_string[ch])\n\
    \        .dedup\n        .length;\n}", "{\n    string toUpperString=toUpper(string);\n\
    \    long[char] charLookup=new long[char];\n    foreach(char c;toUpperString)\n\
    \    {\n        if(charLookup.count(c)==0)\n        {\n            charLookup[c]=1;\n\
    \        }\n    }\n    return charLookup.length;\n}\n/*\n \n Given a string, find\
    \ out how many words it contains.\n    >>> count_words(\"abc def\")\n    2L\n\
    \    >>> count_words(\"abc def ghi\")\n    3L", "{\n    return string.toLower().dup.retro.distinct.length;\n\
    }\n/*\n Count of sequences in string str of length k, where\n        k is an integer,\
    \ k > 0\n        sequence is defined as a range of consecutive characters from\
    \ the string\n        if there are characters c1, c2, ... ck, then the sequence\
    \ (c1, c2, ... ck) is \n        valid iff c2 = c1 + 1, c3 = c2 + 1, ... ck = ck-1\
    \ + 1\n        input string is nonempty\n        input string contains only digits\
    \ from 0 to 9\n    >>> count_sequences(\"0212\", 2)\n    1L\n    >>> count_sequences(\"\
    012345\", 2)\n    3L\n*/\nlong count_sequences(string str, int k) \n{\n    long\
    \ count = 0;\n    auto char_array = str.dup.to!(immutable(char)[])();\n    size_t\
    \ n = char_array.length;\n    foreach(i;0..n) \n    {\n        if (i + k <= n)\
    \ \n        {\n            auto ok = true;\n            foreach(j;i..i+k-1) \n\
    \            {\n                if (char_array[j+1] != char_array[j] + 1) \n \
    \               {\n                    ok = false;\n                    break;\n\
    \                }\n            }\n            if (ok) \n            {\n     \
    \           count++;\n            }\n        }\n    }\n    return count;\n}\n\
    /*\n Given a string, return true iff it is a valid UTF-8 string\n    >>> is_valid_utf8(\"\
    \u0442\u0435\u0441\u0442\")\n    true\n    >>> is_valid_utf8(\"\u0442\u0435\u0441\
    \u0442. \u0435\u0449\u0435 \u0442\u0435\u0441\u0442\")\n    true\n    >>> is_valid_utf8(\"\
    \uC548\uB155 \uD558\uC138\uC694\")\n    true\n    >>> is_valid_utf8(\"invalid:\
    \ \\xd0\\x80\\xd0\\x80\")\n    false\n    >>> is_valid_utf8(\"invalid: \\xc0\\\
    x80\")\n    false\n", "{\n    auto set = std.container.set!(typeof(\"a\".toLower()));\n\
    \    foreach(char c; string)\n    {\n        set.insert(c.toLower());\n    }\n\
    \    return set.length;\n}", "{\n\tlong count = 0;\n\tforeach(c; to!string(std.array.array(string)))\
    \ \n\t{\n\t\tif(c.tolower() !in string)\n\t\t{\n\t\t\tstring ~= c.tolower();\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    auto s = set!(char)(string);\n\
    \    return s.length;\n}", "{\n    long result = 0;\n    foreach(char c; string)\
    \ \n    {\n        if (c.isAlpha) \n        {\n            ++result;\n       \
    \ }\n    }\n    return result;\n}", "{\n    ulong[char] chardict;\n    foreach(c;\
    \ string) {\n        if(c in chardict) \n            chardict[c] += 1;\n     \
    \   else \n            chardict[c] = 1;\n    }\n    return chardict.length;\n}",
  "{\n    // Creates a set (collection of unique elements)\n    auto s = set!char();",
  "{\n    Set!char letters = set();\n    foreach(char ch; string)\n    {\n       \
    \ letters.insert(ch);\n    }\n    return letters.length;\n}", "{\n    auto first\
    \ = string.front;\n    auto last = string.back;\n    static immutable IntRange\
    \ alphabet = 'a'..'z';\n    static immutable int alphabet_size = alphabet.length;\n\
    \    static immutable int ASCII_a = 'a';\n    immutable int char_to_index(char\
    \ c) {\n        immutable int ascii = cast(int)c;\n        if(ascii < ASCII_a)\
    \ return 0;\n        immutable int index = ascii - ASCII_a;\n        return index\
    \ < alphabet_size ? index : 0;\n    }\n    static immutable int[] distinct = new\
    \ int[alphabet_size];\n    static immutable int distinct_size = distinct.length;\n\
    \    //std.array.fill(distinct, 0);\n    foreach(char c; string) \n    {\n   \
    \     int index = char_to_index(c);\n        distinct[index] = 1;\n    }\n   \
    \ return std.array.sum(distinct[0..distinct_size]);\n}", "{\n    // your code\
    \ here\n    \n    // I will do it in 2 different ways:\n    // 1) Convert to uppercase\
    \ and then check the number of unique characters\n    // 2) use hash table\n \
    \   \n    // version 1 \n    auto new_string = string.toUpper;\n    long length\
    \ = new_string.length;\n    long count = 0;\n    foreach(char c; new_string){\n\
    \        if(new_string.countOf(c) == 1){\n            count++;\n        }\n  \
    \  }\n    return count;\n    \n    // version 2\n    auto hashTable = HashTable!char(string.length);\n\
    \    foreach(char c; string){\n        hashTable[c] = true;\n    }\n    return\
    \ hashTable.length;\n}\n/*", "{\n    return to!long(std.algorithm.uniq(string.chars.map!(x\
    \ => x.toLower()).array).length);\n}", "{\n    auto d = typeof(return)();\n  \
    \  foreach(c; string) {\n        if (c == '\\0') continue;\n        d[tolower(c)]\
    \ = c;\n    }\n    return d.length;\n}", "{\n\tstruct S {\n\t\tstring string;\n\
    \t\tint[] result;\n\t\tthis(string string) {\n\t\t\tthis.string = string;\n\t\t\
    \tresult = new int[127];\n\t\t}\n\t\t\n\t\tvoid some_function(string string) {\n\
    \t\t\tint k = 0;\n\t\t\tforeach(char c; string) {\n\t\t\t\tresult[cast(int)c]\
    \ = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint result_length() {\n\t\t\treturn result.length;\n\
    \t\t}\n\t\t\n\t\t@property {\n\t\t\treturn result.length;\n\t\t}\n\t}\n\t\n\t\
    S s = new S(string);\n\ts.some_function(string);\n\tint result = 0;\n\tforeach(e;\
    \ s.result) {\n\t\tresult += e;\n\t}\n\treturn result;\n}", "{\n    return string.length()\
    \ - string.toLower().length();\n}", "{\n\treturn set(cast(char[])string).length;\n\
    }", "{\n    long distinct_characters = 0;\n    auto character_counts = typeof(return)();\n\
    \    foreach(ch; string) \n    {\n        ch = toUpper(ch);\n        if(!character_counts.contains(ch))\
    \ \n        {\n            character_counts[ch] = 1;\n            distinct_characters++;\n\
    \        }\n    }\n    return distinct_characters;\n}", "{\n    long result =\
    \ 0;\n    dchar[] arr = to!dchar[](string);\n    auto alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    foreach(dchar ch; alphabet) {\n        if(ch in arr) {\n            result\
    \ += 1;\n        }\n    }\n    return result;\n}\n/*\n Given a long string, find\
    \ out how many words does it contain\n    >>> count_words(\"hello world!!!\")\n\
    \    2L\n    >>> count_words(\"Foo bar?\")\n    2L\n*/\nlong count_words(string\
    \ string) \n{\n    long result = 0;\n    dchar[] arr = to!dchar[](string);\n \
    \   result = count(arr, ' ');\n    return result + 1;\n}\n/*\n Given a string,\
    \ return a new string that is reversed\n    >>> reverse_string(\"hello\")\n  \
    \  \"olleh\"\n    >>> reverse_string(\"Foo bar\")\n    \"rab ooF\"\n*/\nstring\
    \ reverse_string(string string) \n{\n    string result = \"\";\n    dchar[] arr\
    \ = to!dchar[](string);\n    while(!arr.empty) {\n        result ~= arr.popFront();\n\
    \    }\n    return result;\n}\n/*\n Given a string, return a new string that is\
    \ reverse and all lower case\n    >>> reverse_string_lower(\"HELLO\")\n    \"\
    olleh\"\n    >>> reverse_string_lower(\"Foo BAR\")\n    \"rab oof\"\n*/\nstring\
    \ reverse_string_lower(string string) \n{\n    string result = \"\";\n    dchar[]\
    \ arr = to!dchar[](string);\n    while(!arr.empty) {\n        result ~= toLower(arr.popFront());\n\
    \    }\n    return result;\n}\n/*\n Given a long string, return a new string that\
    \ is reversed and all upper case\n    >>> reverse_string_upper(\"hello world\"\
    )\n    \"DLROW OLLEH\"\n    >>> reverse_string_upper(\"Foo BAR\")\n    \"RAB OOF\"\
    \n*/\nstring reverse_string_upper(string string) \n{\n", "{\n\tauto charArray\
    \ = string.toUpperArray();\n\tauto allChar = array(char[]).init;\n\tforeach(c;\
    \ charArray)\n\t{\n\t\tif(allChar.find(c) == -1) allChar ~= c;\n\t}\n\treturn\
    \ allChar.length;\n}", "{\n    immutable length = string.length;\n    long count\
    \ = 0;\n    foreach(character; string) \n    {\n        if (character != \" \"\
    ) \n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\nGiven the String containing the digits of a number, find the sum of those\
    \ digits.\n    >>> sum_of_digits(\"1234\")\n    10L\n    >>> sum_of_digits(\"\
    abc\")\n    0L\n*/\nlong sum_of_digits(string string) \n{\n    immutable length\
    \ = string.length;\n    long sum = 0;\n    foreach(character; string) \n    {\n\
    \        if (character != \" \") \n        {\n            sum += to!long(character);\n\
    \        }\n    }\n    return sum;\n}\n/*\nGiven a string of a number, print out\
    \ the individual digits of the number, one per line.\n    >>> print_digits(\"\
    1234\")\n    1\n    2\n    3\n    4\n    >>> print_digits(\"abc\")\n    0\n*/",
  "{\n    return to!string(string.tolower()).length;\n}", "{\n    return set(string.toLower).length;\n\
    }\n/*\n Given a list of distinct integers, return the number of elements that\
    \ occur more than once\n    >>> count_duplicates([1, 1, 2, 3, 4, 5, 6, 7, 7, 8,\
    \ 9, 0])\n    2L\n*/\nlong count_duplicates(list of long items)\n{\n    return\
    \ count(items, (long item) => {\n        return items.count(item) > 1;\n    });\n\
    }\n/*\n Given a list of integers, return the number of consecutive elements that\
    \ form increasing sequences\n    >>> count_increasing_sequences([1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10])\n    10L\n    >>> count_increasing_sequences([1, 2, 3, 4, 5,\
    \ 7, 8, 9, 10])\n    5L\n*/\nlong count_increasing_sequences(list of long items)\n\
    {\n    if (items.length < 2)\n    {\n        return items.length;\n    }\n   \
    \ return count(zip(items, items[1..$]), (tuple of (long value, long next_value)\
    \ item) => {\n        return item[0] < item[1];\n    }) + 1;\n}\n/*\n Given a\
    \ list of integers, return the number of times that a number occurs in the list\
    \ (excluding first and last elements)\n    >>> count_occurences([1, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5])\n    0L\n    >>> count_occurences([1, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 2])\n    1L\n*/\nlong count_occurences(list\
    \ of long items)\n{\n    if (items.length < 3)\n    {\n        return 0;\n   \
    \ }\n    long center = items[items.length / 2];\n    return count(items[1..($\
    \ - 1)], (long item) => {\n        return item == center;\n    });\n}\n/*\n Given\
    \ a list of integers, return the", "{\n    long result = 0;\n    foreach(char\
    \ c; string)\n    {\n        if(c != ' ')\n        {\n            result += 1;\n\
    \        }\n    }\n    return result;\n}", "{\n  auto result = typeof(result)();\n\
    \  foreach(c; string)\n    result[lower(c)] = 1;\n  return result.length;\n}",
  "{\n    Set!char set;\n    foreach(char ch; string) \n    {\n        ch = toLower(ch);\n\
    \        set.insert(ch);\n    }\n    return set.length;\n}\n/*\n Given a string,\
    \ find out how many different characters (regardless of case) does it consist\
    \ of\n    >>> count_different_characters(\"abcabcabcabcabcabcabcabcabc\")\n  \
    \  3L\n    >>> count_different_characters(\"abcabcabcabcabcabcabcabcabca\")\n\
    \    4L\n    \n*/\nlong count_different_characters(string string) \n{\n    long\
    \ result = 0;\n    Set!char set;\n    foreach(char ch; string) \n    {\n     \
    \   ch = toLower(ch);\n        if(set.insert(ch))\n            result++;\n   \
    \ }\n    return result;\n}", "{\n     return uniq(string.translate_set!(\"a-zA-Z\"\
    )).length;\n}", "{\n    auto distinctChars = to!string(set(map!(char[])(string)));\n\
    \    return distinctChars.length;\n}", "{\n    return set(map!(\"tolower\")(string)).length;\n\
    }", "{\n    Set!char set = new Set!char;\n    foreach(char c; string)\n    {\n\
    \        set.insert(toLower(c));\n    }\n    return set.length;\n}", "{\n    //\
    \ count all lower case and upper case\n    // return the result of set(string.lower().join(string.upper()).split())\n\
    \    // or count the total length of the set composed of string converted to lower\
    \ case and upper case\n    return strlen(to!string(to!set(string.lower ~ string.upper)));\n\
    }\n/*\nGiven a string, find out how many distinct characters (regardless of case)\n\
    does it consist of. The function should return a tuple of two long integers.\n\
    The first one is the number of distinct characters. The second one is the\nnumber\
    \ of occurrences of the most frequently occurring character in the\nstring. If\
    \ there are several characters that are all the most frequently\noccurring ones,\
    \ you can return any of them.\n    >>> count_distinct_characters(\"xyzXYZ\")\n\
    \    (3L, 3L)\n    >>> count_distinct_characters(\"Jerry\")\n    (4L, 2L)\n  \
    \  >>> count_distinct_characters(\"Mississippi\")\n    (4L, 4L)\n*/\nTuple!(long,\
    \ long) count_distinct_characters2(string string) \n{\n    auto counts = count(split(string.lower\
    \ ~ string.upper));\n    return tuple(counts.length, counts.values.max!(a => a));\n\
    }", "{\n    // convert string to char set\n    set!char charset = set(string.front,\
    \ string.back);\n    return charset.length;\n}", "{\n\t// Return the number of\
    \ distinct characters in the given string\n\tchar[] charArray = string.dup;\n\t\
    charArray.sort;\n\tcharArray.dedup;\n\treturn charArray.length;\n}", "{\n    long[]\
    \ chrs = string.map!(c => c.toLower().ord).array;\n    return chrs.length.iota.filter!(i\
    \ => chrs[i] != chrs[i+1]).length;\n}", "{\n    long count = 0;\n    foreach(char\
    \ ch; string)\n    {\n        count += lower(ch) == upper(ch);\n    }\n    return\
    \ count;\n}", "{\n    long result;\n    foreach(immutable character; string) \n\
    \    {\n        if(toLower(character) == character) \n        {\n            result++;\n\
    \        }\n    }\n    return result;\n}\n// How to convert a string to an array\
    \ of bytes", "{\n    return std.algorithm.uniq(string.toLower().toUTF8z()).length;\n\
    }\n```", "{\n    auto s = set!char;\n    foreach(c; string)\n    {\n        s.insert(toLower(c));\n\
    \    }\n    return s.length;\n}\n/*\n Given a string, find out the most frequent\
    \ character (regardless of case) in it\n \n    >>> find_most_frequent_character(\"\
    abcabcabcabcabcabcabcabc\")\n    Tuple!(char, \"c\", 12L)\n    >>> find_most_frequent_character(\"\
    Jerry\")\n    Tuple!(char, \"r\", 2L)\n    \n*/\nauto find_most_frequent_character(string\
    \ string) \n{\n    auto m = map!(char, long)();\n    foreach(c; string)\n    {\n\
    \        auto a = toLower(c);\n        if(m.contains(a))\n        {\n        \
    \    m[a] = m[a] + 1;\n        }\n        else\n        {\n            m[a] =\
    \ 1;\n        }\n    }\n    auto l = m.length;\n    auto most_frequent_char =\
    \ m.keys[0];\n    auto max_freq = m.values[0];\n    for(int i = 1; i < l; i++)\n\
    \    {\n        if(m.values[i] > max_freq)\n        {\n            max_freq =\
    \ m.values[i];\n            most_frequent_char = m.keys[i];\n        }\n    }\n\
    \    return tuple(most_frequent_char, max_freq);\n}\n/*\n Given a string, find\
    \ out how many vowels (lower and upper case) does it consist of\n    >>> count_vowels(\"\
    xyzXYZ\")\n    0L\n    >>> count_vowels(\"Jerry\")\n    2L\n    \n*/\nlong count_vowels(string\
    \ string) \n{\n    auto vowels = \"aeiou\";\n    auto c = 0;\n    foreach(v; string)\n\
    \    {\n        if(vowels.contains(toLower(v)))\n        {\n            c++;\n\
    \        }\n    }\n    return c;\n}\n/*\n", "{\n    auto lower = string.toLower();\n\
    \    unordered_set!char d_char;\n    foreach(index, char c; lower) {\n       \
    \ d_char.insert(c);\n    }\n    return d_char.length;\n}", "{\n    import std.algorithm.sorting\
    \ : sort;\n    long[]  chars = new long[string.length];\n    immutable last =\
    \ string.length - 1;\n    foreach(immutable i, immutable x; string)\n    {\n \
    \       chars[i] = x;\n    }\n    chars.sort();\n    long count = 0;\n    for(immutable\
    \ i = 0; i < last; i++)\n    {\n        count += chars[i] != chars[i + 1];\n \
    \   }\n    return count + 1;\n}\nunittest \n{\n    assert(count_distinct_characters(\"\
    xyzXYZ\") == 3);\n    assert(count_distinct_characters(\"Jerry\") == 4);\n}",
  "{\n\t/*\n\thttp://www.viva64.com/en/b/0255/\n\t*/\n\tchar[ulong] set;\n\tforeach(ch;\
    \ string) \n\t{\n\t\tset[cast(ulong)ch] = ch;\n\t}\n\treturn set.length;\n}",
  "{\n    foreach(char c; string)\n        writeln(c);\n    return string.length;\n\
    }", "{\n\tint count = 0;\n\t// for loop for chars 0 to the length of the string\n\
    \tfor (size_t i = 0; i < string.length; i++) \n\t{\n\t\t// for loop for chars\
    \ 0 to the length of the string\n\t\tfor (size_t j = 0; j < string.length; j++)\
    \ \n\t\t{\n\t\t\t// if i is equal to j and they are equal to each other\n\t\t\t\
    if (i == j) \n\t\t\t{\n\t\t\t\t// break out of loop\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t\t// if char at i is equal to char at j\n\t\t\tif (string[i] == string[j])\
    \ \n\t\t\t{\n\t\t\t\t// set both chars to null\n\t\t\t\tstring[i] = null;\n\t\t\
    \t\tstring[j] = null;\n\t\t\t}\n\t\t}\n\t}\n\tfor (size_t k = 0; k < string.length;\
    \ k++) \n\t{\n\t\t// if char at k is not equal to null\n\t\tif (string[k] != null)\
    \ \n\t\t{\n\t\t\t// increment count\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\nAn isogram is a word that has no repeating letters, consecutive or non-consecutive.\
    \ \nImplement a function that determines whether a string that contains only letters\
    \ is an isogram. \nAssume the empty string is an isogram. Ignore letter case.",
  "{\n    auto res = string.lower.unique;\n    return res.length;\n}", "{\n\treturn\
    \ string.toLowerCase.toHashSet.size();\n}", "{\n\treturn string.unique.length;\n\
    }", "{\n\tlong n = 0;\n\tlong i = 0;\n\tlong length = string.length;\n\tchar[]\
    \ characters = new char[128];\n\tforeach(char c;string)\n\t{\n\t\tif (c >= 'a'\
    \ && c <= 'z')\n\t\t{\n\t\t\tif (characters[c] == 0)\n\t\t\t{\n\t\t\t\tcharacters[c]\
    \ = 1;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\telse if (c >= 'A' && c <= 'Z')\n\t\t\
    {\n\t\t\tif (characters[c - 'A' + 'a'] == 0)\n\t\t\t{\n\t\t\t\tcharacters[c -\
    \ 'A' + 'a'] = 1;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (characters[c]\
    \ == 0)\n\t\t\t{\n\t\t\t\tcharacters[c] = 1;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn n;\n}", "{\n    long result = 0;\n    bool[] isVisited = new bool[string.length];\n\
    \    for (long i = 0; i < string.length; i++) \n    {\n        if (isVisited[i]\
    \ == false) \n        {\n            result++;\n            isVisited[i] = true;\n\
    \            char current = string[i];\n            for (long j = i + 1; j < string.length;\
    \ j++) \n            {\n                if (isVisited[j] == false && char.tolower(current)\
    \ == char.tolower(string[j])) \n                {\n                    isVisited[j]\
    \ = true;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n/*\n    Given two strings, find out if one of them is a permutation of the\
    \ other.\n    >>> is_permutation(\"abcd\", \"dcba\")\n    true\n    >>> is_permutation(\"\
    abcd\", \"dcbd\")\n    false\n    >>> is_permutation(\"abcd\", \"abcc\")\n   \
    \ false\n*/", "{\n    uint[] lower = std.string.toLower(string).toUTFz.group;\n\
    \    uint[] upper = std.string.toUpper(string).toUTFz.group;\n    uint[] tmp;\n\
    \    if (lower.length > upper.length)\n    {\n        tmp = upper;\n        upper\
    \ = lower;\n        lower = tmp;\n    }\n    foreach (uint x; lower)\n    {\n\
    \        uint index = upper.indexOf(x);\n        if (index != -1)\n        {\n\
    \            upper[index] = 0;\n        }\n    }\n    return (count!(bool)(upper));\n\
    }\n/*\n    Write a function that returns an array of Fibonacci numbers up to a\
    \ given number.\n        >>> fibonacci_numbers(10)\n        [0L, 1L, 1L, 2L, 3L,\
    \ 5L, 8L]\n*/\nlong[] fibonacci_numbers(long number) \n{\n    long[] result =\
    \ new long[];\n    foreach (long x; 0L .. number)\n    {\n        if (x == 0L\
    \ || x == 1L)\n        {\n            result ~= x;\n        }\n        else\n\
    \        {\n            long tmp = result[result.length - 1] + result[result.length\
    \ - 2];\n            if (tmp <= number)\n            {\n                result\
    \ ~= tmp;\n            }\n        }\n    }\n    return result;\n}\n/*\nGiven a\
    \ list of items, return the longest increasing subsequence.\n    >>> longest_increasing_subsequence([1,\
    \ 3, 4, 9, 5, 12, 6, 7, 8])\n    [1, 3, 4, 5, 6, 7, 8]\n    >>> longest_increasing_subsequence([3,\
    \ 5, 10, 2, 1, 20])\n    [3, 5, 10, 20]\n*/\nT[] longest_increasing_subsequence(T)(T[]\
    \ items) \n{\n    long[] result = new long[];\n    long[] result2 = new long[];\n\
    \    foreach (long x; 0L .. items.length)\n    {\n        if (x == 0L)\n     \
    \   {\n            result", "{\n\t//in case user forgets to lowercase\n\tchar[]\
    \ char_ = string.toLower.toCharArray();\n\treturn char_.uniq.length;\n}", "{\n\
    \    long distinctCount = 0;\n    foreach(immutable char current; string)\n  \
    \  {\n        distinctCount += !std.array.canFind(string[0..$-1], current.toLower);\n\
    \    }\n    return distinctCount;\n}\n/*\n Given a string, find out how many of\
    \ those characters occur more than once, case insensitive.\n    >>> count_duplicate_characters(\"\
    xyzXYZ\")\n    0L\n    >>> count_duplicate_characters(\"Jerry\")\n    4L\n   \
    \ >>> count_duplicate_characters(\"TomTom\")\n    3L\n*/\nlong count_duplicate_characters(string\
    \ string) \n{\n    long duplicateCount = 0;\n    foreach(immutable char current;\
    \ string)\n    {\n        foreach(immutable char other; string[0..$-1])\n    \
    \    {\n            if(current.toLower == other.toLower)\n            {\n    \
    \            duplicateCount++;\n                break;\n            }\n      \
    \  }\n    }\n    return duplicateCount;\n}\n/*\n Given a string, find out how\
    \ many of those characters occur more than once and how many times. \n The output\
    \ should be a two dimensional array with two columns and n rows, where n is the\
    \ number of characters that occur more than once in the input.\n The first column\
    \ should contain the character that occurs more than once.\n The second column\
    \ should contain the number of times that character occurs.\n    \n    >>> count_duplicate_characters_in_string(\"\
    xyzXYZ\")\n    []\n    >>> count_duplicate_characters_in_string(\"Jerry\")\n \
    \   [[\"e\", 2L], [\"r\", 2L], [\"J\", 1L], [\"y\", 1L]]\n    >>> count_duplicate_characters_in_string(\"\
    TomTom\")\n    [[\"T\", 2L], [\"o\", 2L], [\"m\", 2L]]\n*/\nlong[][] count_duplicate_characters_in_string(string\
    \ string) \n{\n    long[][] duplicateChars = [[],[]];\n    foreach(immutable char\
    \ current; string)\n    {\n        if(duplicateChars[0].canFind", "{\n    auto\
    \ set = SortedSet!(char)();\n    set.insert(string.toLower());\n    return set.length;\n\
    }\n/*\nWrite a function that converts a string (no newlines) to a rectangle of\
    \ characters with each character centered in its cell,\nhence a rectangle of the\
    \ smallest possible size that fits the string. You can pad empty space on any\
    \ side of the rectangle as needed\n    >>> make_rectangle(\"Hello there\")\n \
    \   \"\"\"\\\n    +-----+\n    |Hello|\n    | there|\n    +-----+\n    \"\"\"\n\
    \    >>> make_rectangle(\"Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn\"\
    )\n    \"\"\"\\\n    +-------------------------------------------------+\n   \
    \ |Ph'nglui                                         |\n    |mglw'nafh        \
    \                                |\n    |Cthulhu                             \
    \            |\n    |R'lyeh                                           |\n    |wgah'nagl\
    \                                        |\n    |fhtagn                      \
    \                     |\n    +-------------------------------------------------+\n\
    \    \"\"\"\n*/\nstring make_rectangle(string string) \n{\n    int length = string.length;\n\
    \    int height = length/2 + length%2;\n    string[] lines = new string[height];\n\
    \    foreach(i; 0..height)\n    {\n        string line = \"\";\n        foreach(j;\
    \ 0..(length - 1)/height + 1)\n        {\n            line ~= string[i + j*height];\n\
    \        }\n        lines[i] = line;\n    }\n    int maxLen = reduce!max((a, b)\
    \ => a.length > b.length ? a : b)(lines);\n    // centering\n    foreach(i; 0..height)\n\
    \    {\n        lines[i] = \"|\" ~ lines[i] ~ replicate(\" \", maxLen - lines[i].length)\
    \ ~ \"|\";\n    }\n    string topBottom = \"+\" ~ replicate(\"-\", maxLen) ~ \"\
    +\";\n    string res = topBottom ~ \"\\n\";\n    foreach(line; lines)\n    {\n\
    \        res ~= line ~ \"\\n\";\n    }\n    res ~= topBottom", "{\n    return\
    \ map!(toLowerCase)(string).toSet().length;\n}\n/*\n Given a string, find out\
    \ how many distinct characters (regardless of case) does it consist of, \n and\
    \ return the first unique character (in its original case)\n    >>> first_unique_character(\"\
    abcdabcd\")\n    'e'\n    >>> first_unique_character(\"xyzXYZ\")\n    'x'\n  \
    \  >>> first_unique_character(\"Jerry\")\n    'J'\n*/\nchar first_unique_character(string\
    \ string)\n{\n    auto [lowerCaseString, upperCaseString] = unzip(string.map!(toLowerCase)(string),\
    \ string);\n    foreach(i, c; lowerCaseString)\n    {\n        string[i] = c;\n\
    \    }\n    string = string.toSet();\n    foreach(c; string)\n    {\n        if(c.isUpper)\n\
    \        {\n            return c;\n        }\n    }\n    return '\\0';\n}\n/*\n\
    Given a string, return true if it is a palindrome, false otherwise\n    >>> is_palindrome(\"\
    abcba\")\n    true\n    >>> is_palindrome(\"abc\")\n    false\n*/", "{\n    string\
    \ result = \"\";", "{\n    return std.algorithm.uniq(string.toLower.toDchars.map!(x\
    \ => x.to!long)).length;\n}", "{\n    long count = 0;\n    foreach(char c; string)\
    \ \n    {\n        if(!c.isLetter())\n            continue;\n        count +=\
    \ c.toLower().isLetter ? c.toLower().isLetter : -1; \n    }\n    return count;\n\
    }\n/*\n Given a string, remove the first occurance of a char from the string\n\
    \    >>> remove_char(\"Jerry\", 'J')\n    erry\n*/", "{\n    /*string temp;\n\
    \    foreach(elem; string)\n    {\n        if(elem.length)\n        {\n      \
    \      temp ~= elem.upper;\n        }\n    }\n    string = temp;*/\n    long count\
    \ = 0;\n    for(long i = 0; i < string.length; i++)\n    {\n        if(string[i]\
    \ >= 'a' && string[i] <= 'z')\n        {\n            if(!string[i..i+1].canFind(\"\
    a\") && !string[i..i+1].canFind(\"A\"))\n            {\n                count++;\n\
    \            }\n        }\n        else if(string[i] >= 'A' && string[i] <= 'Z')\n\
    \        {\n            if(!string[i..i+1].canFind(\"a\") && !string[i..i+1].canFind(\"\
    A\"))\n            {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}", "{\n    return toSet(string.toLower()).length;\n}",
  "{\n    long res = 0;\n    foreach(char c; string.chars)\n    {\n        if (c.isUpper)\n\
    \        {\n            char lower = c.toLower;\n            if (lower !in res)\n\
    \            {\n                res ~= lower;\n            }\n        }\n    \
    \    else if (c !in res)\n        {\n            res ~= c;\n        }\n    }\n\
    \    return res.length;\n}\n/*\n    Given a string, find out how many distinct\
    \ characters (regardless of case) does it consist of\n    >>> count_distinct_characters_1(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters_1(\"Jerry\")\n    4L\n  \
    \  \n*/\nlong count_distinct_characters_1(string string) \n{\n    long res = 0;\n\
    \    foreach(char c; string.chars)\n    {\n        char lower = c.toLower;\n \
    \       if (lower !in res)\n        {\n            res ~= lower;\n        }\n\
    \    }\n    return res.length;\n}\n/*\n    Given a list of numbers, find out how\
    \ many duplicates there are, and return them as a list.\n    >>> count_duplicates([2,\
    \ 3, 4, 3, 5, 6, 4, 7, 8, 9, 10, 4, 11, 12, 13, 14, 15, 15, 16, 17, 17, 18, 19,\
    \ 20, 20])\n    4L\n    >>> count_duplicates([2, 3, 4, 3, 5, 6, 4, 7, 8, 9, 10,\
    \ 4, 11, 12, 13, 14, 15, 15, 16, 17, 17, 18, 19, 20, 20])\n    [4, 15, 17, 20]\n\
    */\nlong count_duplicates(long[] arr) \n{\n    //long res = 0;\n    auto res =\
    \ new long[];\n    foreach(long i; arr)\n    {\n        if (i in res)\n      \
    \  {\n            continue;\n        }\n        foreach(long j; arr)\n       \
    \ {\n            if (i == j)\n            {\n               ", "{\n    // Initially\
    \ fill the map with the characters of the string\n    auto char_map = typeof(return)();\n\
    \    foreach(c; string)\n    {\n        char_map[c] = true;\n    }\n    // Return\
    \ the number of distinct characters in the map\n    return char_map.length;\n}",
  "{\n    auto freq = count(string.release());\n    return freq.length;\n}\n// char\n\
    alias F = dchar;", "{\n\tstring l_string = toLower(string);\n\tbool[] table =\
    \ [false; 256];\n\tforeach(char c; l_string) {\n\t\ttable[c] = true;\n\t}\n\t\
    return count(table);\n}\n/*\n Given a string, print all unique characters (characters\
    \ in a string are not repeated)\n \n    >>> print_all_unique_characters(\"xyzXYZ\"\
    )\n    xyz\n    >>> print_all_unique_characters(\"Jerry\")\n    Jer\n    \n*/",
  "{\n    auto lower_string = toLower(string);\n    return to!string(lower_string).length;\n\
    }", "{\n    auto chars = string.toLower().chars.sort().unique;\n    return chars.length;\n\
    }\n \n/*\nGiven a string, check if it is a permutation of a palindrome\n    >>>\
    \ is_permutation_of_palindrome(\"Jerry\")\n    true\n    >>> is_permutation_of_palindrome(\"\
    Jerry is the best\")\n    false\n    >>> is_permutation_of_palindrome(\"race car\"\
    )\n    true\n*/", "{\n    long l=0;\n    foreach(c;string)\n    {\n        if(c!='\
    \ ')\n        {\n            l++;\n        }\n    }\n    return l;\n}", "{\n \
    \    static assert(is(typeof(string.front) == dchar));", "{\n    \n    return\
    \ std.uniq(std.sort(string)).length;\n}", "{\n     char[] char_array = string.chars();\n\
    \     return char_array.length.sort.uniq.length;\n}", "{\n\treturn string.toLower().unique.length;\n\
    }", "{\n    auto distinctChars = new HashSet!(char)();\n    foreach(char c; string)\n\
    \    {\n        distinctChars.insert(tolower(c));\n    }\n    return distinctChars.length;\n\
    }\n/*\nGiven an integer, find out if its divisible by 2, 3, or 5, or all three\n\
    \    >>> is_divisible_by_2_3_5(16)\n    (1L, 0L, 0L, 0L)\n    >>> is_divisible_by_2_3_5(56)\n\
    \    (1L, 1L, 0L, 0L)\n    >>> is_divisible_by_2_3_5(35)\n    (0L, 0L, 1L, 0L)\n\
    \    >>> is_divisible_by_2_3_5(0)\n    (1L, 1L, 1L, 1L)\n    >>> is_divisible_by_2_3_5(11)\n\
    \    (0L, 0L, 0L, 0L)\n*/\nTuple!(long, long, long, long) is_divisible_by_2_3_5(long\
    \ number) \n{\n    return tuple(number % 2 == 0, number % 3 == 0, number % 5 ==\
    \ 0, number == 0);\n}\n/*\nGiven a string, find out how many distinct characters\
    \ (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n    auto distinctChars\
    \ = new HashSet!(char)();\n    foreach(char c; string)\n    {\n        distinctChars.insert(tolower(c));\n\
    \    }\n    return distinctChars.length;\n}\n/*\nFind out if a string is a palindrome\
    \ (reads the same from left to right and from right to left)\n    >>> is_palindrome(\"\
    x\")\n    true\n    >>> is_palindrome(\"xy\")\n    false\n    >>> is_palindrome(\"\
    aaa\")", "{\n\timmutable uniqued_string = uniq(string.toLower());\n\treturn uniqued_string.length;\n\
    }\n/*\n Given a string, find out how many distinct consonants (regardless of case)\
    \ does it consist of\n    >>> count_distinct_consonants(\"xyzXYZ\")\n    2L\n\
    \    >>> count_distinct_consonants(\"Jerry\")\n    3L\n*/\nlong count_distinct_consonants(string\
    \ string) \n{\n\timmutable consonants = \"bcdfghjklmnpqrstvwxyz\";\n\timmutable\
    \ uniqued_string = uniq(string.toLower());\n\timmutable count = 0;\n\tforeach(letter;\
    \ uniqued_string)\n\t{\n\t\tif(letter in consonants)\n\t\t{\n\t\t\tcount++;\n\t\
    \t}\n\t}\n\treturn count;\n}\n/*\n Given a string, find out how many distinct\
    \ vowels (regardless of case) does it consist of\n    >>> count_distinct_vowels(\"\
    xyzXYZ\")\n    1L\n    >>> count_distinct_vowels(\"Jerry\")\n    1L\n*/\nlong\
    \ count_distinct_vowels(string string) \n{\n\timmutable vowels = \"aeiou\";\n\t\
    immutable uniqued_string = uniq(string.toLower());\n\timmutable count = 0;\n\t\
    foreach(letter; uniqued_string)\n\t{\n\t\tif(letter in vowels)\n\t\t{\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Given a string, find out how many\
    \ distinct consonants and vowels (regardless of case) does it consist of\n   \
    \ >>> count_distinct_consonants_and_vowels(\"xyzXYZ\")\n    3L\n    >>> count_distinct_consonants_and_vowels(\"\
    Jerry\")\n    4L\n*/\nlong count_distinct_consonants_and_vowels(string string)\
    \ \n{\n\timmutable vowels = \"aeiou\";\n\timmutable consonants = \"bcdfghjkl",
  "{\n    long result = 0;\n    foreach(char; string) \n    {\n        if(!result)\
    \ result++;\n        else if(result && char != string[$-1]) result++;\n    }\n\
    \    return result;\n}", "{\n    return to!Set(map!(toUpper,to!(dchar[])(string))).length;\n\
    }", "{\n\talias char_lower = to!char(0);\n\talias char_upper = to!char(0);\n\t\
    alias char_count = size_t;\n\t\n\tauto char_map = new char[256];\n\tauto char_count_map\
    \ = new size_t[256];\n\t\n\tauto len = string.length;\n\t\n\tforeach(i; 0..256)\n\
    \t{\n\t\tchar_map[i] = cast(char)i;\n\t\tchar_count_map[i] = 0;\n\t}\n\t\n\tforeach(i;\
    \ 0..len)\n\t{\n\t\tchar_lower = to!char(string[i]);\n\t\tchar_upper = to!char(string[i]);\n\
    \t\t\n\t\tchar_lower = toLower(char_lower);\n\t\tchar_upper = toUpper(char_upper);\n\
    \t\t\n\t\tauto char_idx = cast(size_t)char_lower;\n\t\tchar_count_map[char_idx]\
    \ = 1;\n\t\t\n\t\tif(char_upper != char_lower)\n\t\t{\n\t\t\tchar_idx = cast(size_t)char_upper;\n\
    \t\t\tchar_count_map[char_idx] = 1;\n\t\t}\n\t}\n\t\n\tchar_count = 0;\n\tforeach(i;\
    \ 0..256)\n\t{\n\t\tchar_count += char_count_map[i];\n\t}\n\t\n\treturn char_count;\n\
    }", "{\n    auto result = new Map!(string, int) ();\n    foreach(char character;\
    \ string) \n    {\n        result[character.toLower().toString()] = 0;\n    }\n\
    \    return result.length;\n}\n/*\n Given a string, find out how many unique characters\
    \ (regardless of case) does it consist of\n    >>> count_unique_characters(\"\
    xyzXYZ\")\n    6L\n    >>> count_unique_characters(\"Jerry\")\n    5L\n    \n\
    */\nlong count_unique_characters(string string) \n{\n    auto result = new Set!(string)\
    \ ();\n    foreach(char character; string) \n    {\n        result.insert(character.toLower().toString());\n\
    \    }\n    return result.length;\n}\n/*\n Given a string, find out the length\
    \ of the longest consecutive character (regardless of case) does it consist of\n\
    \    >>> longest_consecutive_character(\"xyzXYZ\")\n    3L\n    >>> longest_consecutive_character(\"\
    Jerry\")\n    1L\n    >>> longest_consecutive_character(\"aaaaaaaAAAAAA\")\n \
    \   7L\n    \n*/\nlong longest_consecutive_character(string string) \n{\n    auto\
    \ result = new Map!(string, int) ();\n    long maxResult = 0;\n    foreach(char\
    \ character; string) \n    {\n        const string key = character.toLower().toString();\n\
    \        const int value = result.get(key, -1) + 1;\n        result[key] = value;\n\
    \        maxResult = max(maxResult, value);\n    }\n    return maxResult;\n}\n\
    /*\n Given a string, find out the number of words (whitespace separated) in the\
    \ string\n    >>> count_words(\"Hello World\")\n    2L\n    >>> count_words(\"\
    D is the hardest programming language\")\n    7L\n    >>> count_words(\"   \"\
    )\n    0L\n    \n*/\nlong count_words(string string) \n{\n    return string.split().length;\n\
    }\n/*\n Given a string, find out the number of the words that begin with capital\
    \ letters.\n    >>> count_capped", "{\n    long counter = 0;\n    int i = 0;\n\
    \    while (i < string.length)\n    {\n        if (isupper(string[i]))\n     \
    \   {\n            string[i] = tolower(string[i]);\n        }\n        i++;\n\
    \    }\n    for (int i = 0; i < string.length; i++)\n    {\n        for (int k\
    \ = 0; k < string.length; k++)\n        {\n            if (string[i] == string[k])\n\
    \            {\n                string[k] = '\\0';\n            }\n        }\n\
    \    }\n    for (int i = 0; i < string.length; i++)\n    {\n        if (string[i]\
    \ != '\\0')\n        {\n            counter++;\n        }\n    }\n    return counter;\n\
    }", "{\n    return string.toLower.unique.length;\n}", "{\n    long j = 0;\n  \
    \  foreach(ch; string.lower)\n    {\n        if(!string.lower[0..j].contains(ch))\n\
    \        {\n            j++;\n        }\n    }\n    return j;\n}", "{\n    return\
    \ string.toLower.unique.length;\n}", "{\n    long count;\n    size_t len;\n  \
    \  long i;\n    int case_flag;\n    long j;\n    char dchar;\n    char case_pair[2];\n\
    \    struct case_pair{\n        char a;\n        char b;\n    } ;\n    struct\
    \ case_pair Ccase_pair[13] = \n    {\n        {'a','A'},\n        {'b','B'},\n\
    \        {'c','C'},\n        {'d','D'},\n        {'e','E'},\n        {'f','F'},\n\
    \        {'g','G'},\n        {'h','H'},\n        {'i','I'},\n        {'j','J'},\n\
    \        {'k','K'},\n        {'l','L'},\n        {'m','M'}\n    };\n    len =\
    \ strlen(string);\n    count = len;\n    for (i = 0; i < len; i++)\n    {\n  \
    \      for (j = 0; j < 13; j++)\n        {\n            if (string[i] == Ccase_pair[j].a)\n\
    \            {\n                string[i] = Ccase_pair[j].b;\n               \
    \ break;\n            }\n        }\n    }\n    for (i = 0; i < len; i++)\n   \
    \ {\n        dchar = string[i];\n        case_flag = 0;\n        for (j = i +\
    \ 1; j < len; j++)\n        {\n            if (dchar == string[j])\n         \
    \   {\n                case_flag = 1;\n                break;\n            }\n\
    \        }\n        if (case_flag == 1)\n        {\n            count = count\
    \ - 1;\n        }\n    }\n    return count;\n}", "{\n    auto result = string.toLower().dup.unique;\n\
    \    return result.length;\n}", "{\n    return distinct(toLower(string)).length;\n\
    }", "{\n    //return (long)std.array.uniq(string.tolower).length;\n    return\
    \ (long)string.tolower.length;\n}", "{\n    return set(string.tolower).length;\n\
    }", "{\n    // Convert string to lower case\n    string = lower(string);\n   \
    \ long length = string.length;\n    // Store characters in a set\n    auto set\
    \ = newSet();\n    foreach(i; 0..length)\n    {\n        set.insert(string[i]);\n\
    \    }\n    return set.length;\n}", "{\n    // create a map for all lower case\
    \ letters\n    char[char] seen;\n    // walk throught all the letters in the string\n\
    \    foreach(char c; string) \n    {\n        // put the lowercase version of\
    \ the char in the map\n        seen[toLower(c)] = c;\n    }\n    // return the\
    \ length of the map (the number of keys)\n    return seen.length;\n}\n/*\n Given\
    \ a list of string, find the most frequently used letter throughout the list\n\
    \    >>> find_most_frequent_letter([\"aaa\", \"bbbb\", \"ccc\"])\n    ('a', 3L)\n\
    \    >>> find_most_frequent_letter([\"abc\", \"abcd\", \"abcdef\", \"abcde\",\
    \ \"abcdefg\"])\n    ('a', 1L)\n    \n*/\nTuple!(char,long) find_most_frequent_letter(string[]\
    \ list) \n{\n    // create a map of char to int\n    char[long] seen;\n    //\
    \ walk through the list\n    foreach(string s; list) \n    {\n        // walk\
    \ through all the chars in the string\n        foreach(char c; s) \n        {\n\
    \            // put the lowercase version of the char in the map\n           \
    \ seen[toLower(c)]++;\n        }\n    }\n    // max we will use for finding the\
    \ largest value seen\n    long max = 0;\n    // char we will use for finding the\
    \ largest key seen\n    char maxKey;\n    // walk through the map to find the\
    \ largest value seen\n    foreach(char key, long value; seen) \n    {\n      \
    \  if(value > max) \n        {\n            max = value;\n            maxKey =\
    \ key;\n        }\n    }\n    // return a tuple of the max key and value\n   \
    \ return tuple(maxKey, max);\n}\n/*\n Given a list of string, find the longest\
    \ string in the list\n    >>> find_longest_string([\"aaa\", \"bbbb\", \"ccc\"\
    ])\n    \"bbbb\"\n    >>> find_longest_string([\"abc\", \"abcd\", \"abcdef\",\
    \ \"abcde\", \"abcdefg\"]", "{\n    return string.length.__unique().length;\n}",
  "{\n    // \n    auto isChar = tuple!(isAlpha, isNumeric, isPunct);\n    // \n \
    \   auto _ = isChar.tupleof.map!(a => a(string[0])).tupleof;\n    // \n    auto\
    \ result = _.foldLeft!((b, a) => b || a).tupleof;\n    // \n    return result;\n\
    \    // \n}", "{\n    return length(set(to!string(tolower(string))));\n}", "{\n\
    \    char[] chars = toUpper(string).dup;\n    std.algorithm.sort(chars);\n   \
    \ auto c = std.set.Cmp.byKey!((a, b) => a < b);\n    auto set = std.set(c);\n\
    \    set.insert(chars);\n    return set.length;\n}", "{\n    return distinct(string.tolower());\n\
    }\n/*\n Given a string, find out how many distinct characters (regardless of case)\
    \ does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3L\n\
    \    >>> count_distinct_characters(\"Jerry\")\n    4L\n*/\nlong count_distinct_characters2(string\
    \ string) \n{\n    return distinct(string.tolower().map!(a => a.isLower ? a :\
    \ a.toLower()));\n}\n/*\n Given a string, find out how many distinct characters\
    \ (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n*/\n\
    long count_distinct_characters3(string string) \n{\n    return distinct(string.toLower);\n\
    }", "{\n    size_t distinct_chars = 0;\n    size_t [] characters = new size_t[256];\n\
    \    foreach(char c; string) \n    {\n        size_t index = cast(size_t)toLower(c);\n\
    \        if(characters[index] == 0) \n        {\n            distinct_chars++;\n\
    \            characters[index] = 1;\n        }\n    }\n    return distinct_chars;\n\
    }\n/*\n Write a function that takes a string and returns it in reverse order (i.e.\
    \ the last character of the string becomes the first and vice versa)\n    >>>\
    \ reverse_string(\"Zagreb\")\n    \"bergaZ\"\n    >>> reverse_string(\"abcde\"\
    )\n    \"edcba\"\n    >>> reverse_string(\"a\")\n    \"a\"\n    >>> reverse_string(\"\
    \")\n    \"\"\n*/\nstring reverse_string(string string) \n{\n    string reverse\
    \ = \"\";\n    foreach(int index; reverse(0..string.length)) \n    {\n       \
    \ reverse ~= string[index];\n    }\n    return reverse;\n}\n/*\n Write a function\
    \ that takes a string and two integers index1 and index2 and returns the character\
    \ at the index1 in the string \n and the character at the index2 in the string.\n\
    \    >>> swap_characters(\"Zagreb\", 0, 4)\n    (\"a\", \"b\")\n    >>> swap_characters(\"\
    abcde\", 0, 4)\n    (\"e\", \"a\")\n    >>> swap_characters(\"a\", 0, 0)\n   \
    \ (\"a\", \"a\")\n    >>> swap_characters(\"\", 0, 0)\n    (\"\", \"\")\n*/\n\
    typeof(return) swap_characters(string string, int index1, int index2) \n{\n  \
    \  return (string[index1], string[index2]);\n}\n/*\n Write a function that takes\
    \ a string as an argument and returns a tuple consisting of the number of uppercase\
    \ characters and the number of lowercase characters in the string.\n    >>> count_uppercase_lowercase(\"\
    \")\n    (0L, 0L)\n    >>> count_uppercase_lowercase(\"a\")\n    (", "{\n    auto[chars,_,_]\
    \ = std.algorithm.group(string.lower);\n    return chars.length;\n}\n \n \n/*\n\
    \ Given a string, check whether it is a palindrome or not\n    >>> is_palindrome(\"\
    Jerry\")\n    true\n    >>> is_palindrome(\"Tom\")\n    false\n*/", "{\n    //get\
    \ the length of the string\n    size_t length = string.length;\n    //declare\
    \ an array of characters\n    char characters[length];\n    //set the contents\
    \ of the array of characters to the contents of the string\n    string.toCharArray(characters);\n\
    \    //initialize a counter for the number of distinct characters\n    long count\
    \ = 0;\n    //declare a string of distinct characters\n    string distinct_characters\
    \ = \"\";\n    //loop over the characters in the array of characters\n    for\
    \ (char character : characters)\n    {\n        //convert the character to uppercase\n\
    \        character = toupper(character);\n        //if the character is not already\
    \ contained in the string of distinct characters\n        if (!distinct_characters.contains(character))\n\
    \        {\n            //append the character to the string of distinct characters\n\
    \            distinct_characters += character;\n            //increment the count\n\
    \            count++;\n        }\n    }\n    //return the count\n    return count;\n\
    }\n/*\nGiven a file, read the contents of that file into a string.\n    >>> read_file(\"\
    foo.txt\")\n    \"some text\"\n*/\nstring read_file(string filename)\n{\n    //initialize\
    \ a string to hold the contents of the file\n    string contents = \"\";\n   \
    \ //declare a file and initialize it to the filename\n    File file = SD.open(filename);\n\
    \    //if the file exists\n    if (file)\n    {\n        //read the file one byte\
    \ at a time\n        while (file.available())\n        {\n            //add the\
    \ byte to the contents\n            contents += (char)file.read();\n        }\n\
    \        //close the file\n        file.close();\n    }\n    //return the contents\n\
    \    return contents;\n}\n/*\nGiven a string and a character, remove all instances\
    \ of that character in the string.\n    >>> remove_character(\"the quick brown\
    \ fox\", 't')\n    \"he quick brown fox\"\n*/\nstring remove_character(string\
    \ string, char character)\n{\n    //get the length of the string\n    size_t length\
    \ = string.length;\n    //declare an array of characters\n    char characters[length];\n",
  '    { return to!string(to!("", Tuple!(dchar))(string)).length; }', "{\n    long\
    \ count = 0;\n    auto keys = std.array.array!(string).make();\n    foreach(char\
    \ c; string)\n    {\n        if(keys.count == 0)\n        {\n            keys\
    \ ~= c.to!string;\n            count++;\n        }\n        else\n        {\n\
    \            foreach(char key; keys)\n            {\n                if(key !=\
    \ c.to!string)\n                {\n                    keys ~= c.to!string;\n\
    \                    count++;\n                }\n            }\n        }\n \
    \   }\n    return count;\n}\n/*\n Write a function to flatten a list of lists\
    \ in a single level\n    >>> flatten([[1,2,3],[4,5,6],[7,8,9]])\n    [1,2,3,4,5,6,7,8,9]\n\
    \    >>> flatten([[\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"],[\"g\",\"h\",\"i\"]])\n\
    \    [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\"]\n    >>> flatten([[1,2,3,4,5],[6,7,8,9,10]])\n\
    \    [1,2,3,4,5,6,7,8,9,10]\n*/\nT[] flatten(T)(T[][] arr)\n{\n    T[] result;\n\
    \    foreach(item; arr)\n    {\n        result ~= item;\n    }\n    return result;\n\
    }\n/*\n Given a list and a positive integer N, write a function to find the Nth\
    \ permutation of the elements in the list\n    >>> permutation([1,2,3], 1)\n \
    \   [1,2,3]\n    >>> permutation([1,2,3], 2)\n    [1,3,2]\n    >>> permutation([1,2,3],\
    \ 3)\n    [2,1,3]\n    >>> permutation([1,2,3], 4)\n    [2,3,1]\n    >>> permutation([1,2,3],\
    \ 5)\n    [3,1,2]\n    >>> permutation([1,2,3], 6)\n", "in\n{\n    auto alphabet\
    \ = tuple(string.toUpper());\n    int result = 0;\n    for (size_t i = 0; i <\
    \ alphabet.length; i++)\n    {\n        if (alphabet[i] >= 65 && alphabet[i] <=\
    \ 90)\n        {\n            result++;\n        }\n    }\n    return result;\n\
    }", "{\n    auto set = std.array.array!(char)(string.length);\n    foreach(c;string)\n\
    \    {\n        set.insert(c);\n    }\n    return set.length;\n}\n/*\n Given a\
    \ string of words,\n    >>> count_words(\"Hello world! It's a beautiful day, isn't\
    \ it?\")\n    6L\n    \n*/\nlong count_words(string string) \n{\n    if(string.length\
    \ == 0)\n        return 0;\n    else\n        return string.countSplitter(' ')\
    \ + 1;\n}\n/*\n Given a string, find out how many words does it consist of\n \
    \   >>> find_most_common_words(\"Hello world! It's a beautiful day, isn't it?\"\
    )\n    tuple(\"it\", 2L)\n    \n*/\ntuple!(string,long) find_most_common_words(string\
    \ string) \n{\n    if(string.length == 0)\n        return tuple(\"\",0);\n   \
    \ auto words = string.split(' ');\n    auto result = string.splitter(' ').reduce!((a,\
    \ b) => count_words(a) > count_words(b) ? a : b);\n    return tuple(result,count_words(result));\n\
    }\n/*\n Given a string, find out how many words does it consist of\n    >>> find_least_common_words(\"\
    Hello world! It's a beautiful day, isn't it?\")\n    tuple(\"Hello\", 1L)\n  \
    \  \n*/\ntuple!(string,long) find_least_common_words(string string) \n{\n    if(string.length\
    \ == 0)\n        return tuple(\"\",0);\n    auto words = string.split(' ');\n\
    \    auto result = string.splitter(' ').reduce!((a, b) => count_words(a) < count_words(b)\
    \ ? a : b);\n    return tuple(result,count_words(result));\n}\n/*\n Given a string,\
    \ find out how many words does it consist of\n    >>> get_list_of_all_substrings(\"\
    Hello world! It's a beautiful day, isn't it?\")\n    [\"Hello world! It's a beautiful",
  "{\n  auto t = d_string!(char);\n  t.length = cast(size_t)string.length;\n  t.ptr\
    \ = string.ptr;\n  return count_distinct_characters(t);\n}", "{\n    char[] chars\
    \ = to!char[](toUpper(string));\n    return reduce!((a, b) => a + (chars[b] in\
    \ chars[0 .. b] ? 0 : 1))(chars);\n}\n/*\n Given a string, find out if it consists\
    \ of only digits\n    >>> is_consists_of_digits(\"123\")\n    true\n    >>> is_consists_of_digits(\"\
    1234 \")\n    false\n    \n*/", "{\n    return uniq(string.toLower().dup).length;\n\
    }\n/*\n Convert a string to a format where each word starts with an uppercase\
    \ letter and the remaining letters are lowercase. For example:\n    >>> standardize_string(\"\
    The quick brown fox\")\n    \"The Quick Brown Fox\"\n    >>> standardize_string(\"\
    something like This\")\n    \"Something Like This\"\n*/\nstring standardize_string(string\
    \ string) \n{\n    return string.join(\" \").title;\n}\n/*\n Given a string, find\
    \ out the index of the first occurrence of the letter a\n    >>> find_a(\"alphabet\"\
    )\n    0L\n    >>> find_a(\"alphAbet\")\n    0L\n    >>> find_a(\"alphAbet\")\n\
    \    4L\n*/\nlong find_a(string string) \n{\n    return string.toLower().find(\"\
    a\");\n}\n/*\n Given two strings, swap the first two characters of each\n    >>>\
    \ swap_adjacent_characters(\"abcde\", \"fghij\")\n    (\"bacde\", \"gfhij\")\n\
    \    >>> swap_adjacent_characters(\"abcde\", \"fghi\")\n    (\"bacde\", \"gfhi\"\
    )\n*/\n(string, string) swap_adjacent_characters(string string1, string string2)\
    \ \n{\n    return (string1[1..$] ~ string1[0..0], string2[1..$] ~ string2[0..0]);\n\
    }\n/*\n Given a string that consists of several words separated by space characters,\
    \ return an array containing the length of each word. \n For example:\n    >>>\
    \ get_word_lengths(\"kata is interesting\")\n    [4L, 2L, 11L]\n*/\nlong[] get_word_lengths(string\
    \ string) \n{\n    return string.split().map!(x => x.length).array;\n}\n/*\n Given\
    \ a string of lowercase characters, find the index of the first unique character\n\
    \    >>> find_first_unique_character(\"abacab\")\n    3L\n    >>> find_first_unique_character(\"\
    aaabbbb\")\n    -1L\n*/\nlong find_first_unique", "{\n    auto m = typeof(return)();\n\
    \    for (auto c : string)\n    {\n        m[tolower(c)] = 1;\n    }\n    return\
    \ m.length;\n}\n \n/*\n Given a string, remove all characters that occur more\
    \ than once in it.\n    >>> remove_duplicate_characters(\"xyzxyz\")\n    \"xyz\"\
    \n    >>> remove_duplicate_characters(\"abcccdafg\")\n    \"bdf\"\n*/\nstring\
    \ remove_duplicate_characters(string string) \n{\n    auto m = typeof(return)();\n\
    \    foreach (c; string)\n    {\n        m[c]++;\n    }\n    string result;\n\
    \    foreach (c; string)\n    {\n        if (m[c] == 1)\n        {\n         \
    \   result ~= c;\n        }\n    }\n    return result;\n}", "{\n    long i = 0;\n\
    \    long uniqueCharCount = 0;\n    long length = string.length;\n    bool[] isCharFound\
    \ = false[256];\n    while (i < length) \n    {\n        if (!isCharFound[string[i]])\
    \ \n        {\n            isCharFound[string[i]] = true;\n            uniqueCharCount++;\n\
    \        }\n        i++;\n    }\n    return uniqueCharCount;\n}", "{\n\treturn\
    \ std.algorithm.sort.uniq(std.algorithm.map!(toLower)(string)).length;\n}\n/*\n\
    \ Given a list of integers and a positive integer target, return all pairs of\
    \ integers in the list that add up to the target\n \t>>> find_pairs([4, 7, 4,\
    \ 6, 8, 7, 10, 11, 9, 7], 13)\n\t[7: 6, 6: 7, 11: 2, 2: 11]\n*/\nauto find_pairs(int[]\
    \ list, int target) \n{\n\treturn std.algorithm.map!(a => a[0] ~ \": \" ~ a[1])(std.algorithm.filter!(a\
    \ => a[0] + a[1] == target)(std.algorithm.cartesianProduct(list, list)));\n}\n\
    /*\nGiven a list of integers, remove all duplicates (keep only the first instance)\n\
    \t>>> list_without_duplicates([4, 7, 4, 6, 8, 7, 10, 11, 9, 7])\n\t[4, 7, 6, 8,\
    \ 10, 11, 9]\n*/", "{\n    return string.toLower().distinct().length;\n}\n/*\n\
    \ For a given string \"abcd\", find out how many unique substrings does it consist\
    \ of\n    >>> count_unique_substrings(\"abcd\")\n    10L\n    >>> count_unique_substrings(\"\
    abdc\")\n    9L\n    \n*/\nsize_t count_unique_substrings(string string) \n{\n\
    \    return size_t(string.length * (string.length + 1) / 2);\n}\n/*\n Given a\
    \ string, find out all pairs of characters, that can be swapped to make the string\
    \ palindrome\n    >>> find_swap_pairs(\"abcdcb\")\n    []\n    >>> find_swap_pairs(\"\
    abcdcba\")\n    [(0,7),(1,6),(2,5),(3,4)]\n    >>> find_swap_pairs(\"acbaa\")\n\
    \    [(0,4),(1,3)]\n    \n*/\nalias Pair = Tuple!(size_t, size_t);", "{\n    return\
    \ set(string.toUpper().split(\"\")).length;\n}", "{\n    return string.toLower().unique.length;\n\
    }\n/*\n Given a list of strings, return a tuple of two lists: the first one will\
    \ contain all strings, that are\n  longer than 2 and the second one will contain\
    \ all the rest.\n    >>> split_list([\"b\", \"aaa\", \"c\"])\n    ([\"aaa\"],\
    \ [\"b\", \"c\"])\n    >>> split_list([\"a\", \"b\", \"c\"])\n    ([], [\"a\"\
    , \"b\", \"c\"])\n*/\nTuple!(string[], string[]) split_list(string[] lst) \n{\n\
    \    return Tuple!(string[], string[])(\n        lst.filter!(s => s.length > 2),\n\
    \        lst.filter!(s => s.length <= 2)\n    );\n}", "{\n  long count = 0;\n\
    \  for (char character = 'a'; character <= 'z'; character++) \n  {\n    if (std.string.count(string,\
    \ character) > 0 || std.string.count(string, character - 'a' + 'A') > 0) \n  \
    \  {\n      count++;\n    }\n  }\n  return count;\n}", "{\n    long count = 0;\n\
    \    foreach(char ch; string) \n    {\n        if (ch in uppercaseAlphabet) \n\
    \        {\n            count++;\n        }\n        else if (ch in lowercaseAlphabet)\
    \ \n        {\n            count++;\n        }\n    }\n    return count;\n}",
  "{\n    // return distinct(toLower(string)); \n    return toSet(toLower(string)).length;\n\
    }", "{\n    string lowercase = to!string(std.algorithm.map!(toLowerCase, string));\n\
    \    auto sorted = sort(lowercase);\n    auto unique = unique(sorted);\n    return\
    \ unique.length;\n}", "{\n    return distinct(map!(toupper)(string));\n}\n// Count\
    \ the number of nodes in a binary tree\nlong count_nodes(BinaryTreeNode!int node)\
    \ \n{\n    if (node is null)\n        return 0;\n    return 1 + count_nodes(node.left)\
    \ + count_nodes(node.right);\n}\n// Count the number of binary search trees that\
    \ can be made with n nodes\nlong count_bst(size_t n) \n{\n    return n == 0 ?\
    \ 1 : n * count_bst(n - 1);\n}\n// Create a string of the form \"binary search\
    \ tree\" if the nodes can be arranged as a BST, otherwise as \"not a binary search\
    \ tree\"\nstring is_bst(BinaryTreeNode!int node) \n{\n    if (node is null)\n\
    \        return \"binary search tree\";\n    if (node.left is null && node.right\
    \ is null)\n        return \"binary search tree\";\n    if (node.left !is null\
    \ && node.right is null)\n        return is_bst(node.left);\n    if (node.left\
    \ is null && node.right !is null)\n        return is_bst(node.right);\n    return\
    \ node.left.value < node.value && node.value < node.right.value ? is_bst(node.left)\
    \ : \"not a binary search tree\";\n}\n/*\n Given a list of strings, for each string\
    \ create a tuple containing the string and its length\n    >>> sort_strings_by_length([\"\
    abc\", \"xyz\", \"12\"])\n    [\"12\", \"abc\", \"xyz\"]\n    >>> sort_strings_by_length([\"\
    abc\", \"xyz\", \"12\", \"\", \"a\"])\n    [\"\", \"a\", \"12\", \"abc\", \"xyz\"\
    ]\n*/\nstring[] sort_strings_by_length(string[] strings) \n{\n    return strings.sort!(a\
    \ => a.length)();\n}\n/*\n Given a two dimensional array of positive integers,\
    \ create a new two dimensional array that contains the sums of the rectangles\
    \ of sub-arrays starting at (0, 0) to the bottom right corner\n    >>> sum", "{\n\
    \    auto count = Map!(char, bool)();\n    foreach(c; string)\n    {\n       \
    \ count[tolower(c)] = true;\n    }\n    return count.length;\n}", "{\n    // Comparing\
    \ characters of different case is equal in D.\n    // Use toLower() to treat them\
    \ as the same.\n    return sort(map!(ch => toLower(ch))(string.dup)).length;\n\
    }", "{\n\t\n\talias Upper =  std.ascii.toUpper;\n\tstring s = Upper(string);",
  "{\n    return set(to!string(map!(toUpperCase, string))).length;\n}", "{\n    return\
    \ string.lower().chars.length;\n}", "{\n    char[] chars = map!(char.toLower)(string);\n\
    \    auto result = set(chars);\n    return result.length;\n}\n/* \n Given a string\
    \ and a char, return the index of the char in the string\n*/\nsize_t string_char_index(string\
    \ s, char c) \n{\n    size_t n;\n    int res = s.find(c, 0, n);\n    if (res ==\
    \ -1) \n    {\n        return size_t.max;\n    }\n    return n;\n}\n/* \n Given\
    \ a string, find the first and last occurence of a char in the string, return\
    \ the first and last index\n*/\nTuple!(size_t, size_t) string_first_last_index(string\
    \ s, char c) \n{\n    size_t fi = string_char_index(s, c);\n    if (fi == size_t.max)\
    \ \n    {\n        return tuple(size_t.max, size_t.max);\n    }\n    size_t li\
    \ = string_char_index(s[fi+1..$], c);\n    if (li == size_t.max) \n    {\n   \
    \     return tuple(fi, fi);\n    }\n    return tuple(fi, fi + li + 1);\n}\n/*\
    \ \n Given a string, return a tuple of the indices of the first and last occurence\
    \ of \"ab\"\n*/\nTuple!(size_t, size_t) string_aba_index(string s) \n{\n    return\
    \ string_first_last_index(s, 'a');\n}\n/* \n Given a string, return a tuple of\
    \ the indices of the first and last occurence of \"aba\"\n*/\nTuple!(size_t, size_t)\
    \ string_aba_index2(string s) \n{\n    return string_first_last_index(s, 'a');\n\
    }\n/* \n Given a string, return the reverse string\n*/\nstring string_reverse(string\
    \ s) \n{\n    char[] res = s.dup;\n    return res.reverse.idup;\n}\n/* \n Given\
    \ a string,", "{\n    long count;\n    foreach(immutable char c; string) \n  \
    \  {\n        count += !std.algorithm.any!\"a.toLower() == c.toLower()\"(string[0\
    \ .. count]);\n    }\n    return count;\n}\n/*\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n*/",
  "{\n    // write your code here\n    return string.toLower().removeDuplicates().length;\n\
    }", "{\n    long total;\n    // for each character in the string\n    foreach(c;\
    \ string)\n    {\n        // convert the character to lower case\n        auto\
    \ lower = toLower(c);\n        // if lower is not already in lowerCharSet\n  \
    \      if (!lowerCharSet.contains(lower))\n        {\n            // add it to\
    \ lowerCharSet\n            lowerCharSet.put(lower);\n            // increment\
    \ the number of unique characters\n            total += 1;\n        }\n    }\n\
    \    return total;\n}", "{\n    string lower = string.toLower();\n    int counter\
    \ = 0;\n    foreach(c; lower)\n    {\n        if(c != ' ')\n        {\n      \
    \      if(!counter)\n            {\n                counter++;\n            }\n\
    \            else\n            {\n                bool exists = false;\n     \
    \           foreach(y; 0..counter)\n                {\n                    if(lower[y]\
    \ == c)\n                    {\n                        exists = true;\n     \
    \                   break;\n                    }\n                }\n       \
    \         if(!exists)\n                {\n                    counter++;\n   \
    \             }\n            }\n        }\n    }\n    return counter;\n}\n/*\n\
    \ Given a string, find the most common character (regardless of case) and return\
    \ it and the count of its occurences in a touple\n    >>> most_common_character(\"\
    xyzXYZ\")\n    ('z', 2L)\n    >>> most_common_character(\"Jerry\")\n    ('r',\
    \ 2L)\n    >>> most_common_character(\"\")\n    ('', 0L)\n    \n*/\ntuple!(char,\
    \ size_t) most_common_character(string string) \n{\n    string lower = string.toLower();\n\
    \    int counter = 0;\n    char mostcommon = ' ';\n    foreach(c; lower)\n   \
    \ {\n        if(c != ' ')\n        {\n            if(!counter)\n            {\n\
    \                counter++;\n                mostcommon = c;\n            }\n\
    \            else\n            {\n                int counter2 = 0;\n        \
    \        foreach(y; 0..lower.length)\n                {\n                    if(lower[y]\
    \ == c)\n                    {\n                        counter2++;\n        \
    \            }\n                }\n                if(counter2 > counter)\n  \
    \              {\n                    counter = counter2;\n                  \
    \  mostcommon = c;\n                }\n            }\n        }\n    }\n    return\
    \ tuple(mostcommon, counter);\n}\n/*\nGiven a string, find all the words that\
    \ start with a given letter (regardless of case) and return them in a tuple. \n\
    The order of words in the tuple does not matter.", "{\n    auto count_distinct_characters_impl\
    \ =\n        [&](auto count_distinct_characters_impl, string string) {\n     \
    \       auto count_distinct_characters_impl_ =\n                [&](string string)\
    \ {\n                    if (string.empty) return 0L;\n                    //\
    \ set is a sorted container, counts all unique values.\n                    auto\
    \ s = to!set(string.tolower());\n                    return s.length;\n      \
    \          };\n            return count_distinct_characters_impl_(string);\n \
    \       };\n    return count_distinct_characters_impl(count_distinct_characters_impl,\
    \ string);\n}", "{\n    alias UTF = wchar;\n    auto chars = string.toUpperArray.retro;\n\
    \    size_t count = 0;\n    while (chars.empty is false)\n    {\n        char\
    \ character = chars.front;\n        if (character.isAlpha) \n        {\n     \
    \       chars.retro.retro.remove(character);\n            count += 1;\n      \
    \  }\n        else\n        {\n            chars.popFront;\n        }\n    }\n\
    \    return count;\n}", "{\n    return to!(long)(set(map!tolower(string))).length;\n\
    }", "{\n\tlong result = string.lower.dup.sort.uniq.length;\n\treturn result;\n\
    }\n/*\nGiven a string, find out the number of occurrences of each character (regardless\
    \ of case)", "{\n    return to(string).byLowerCase().distinct.length;\n}", "{\n\
    \treturn string.lower.length;\n}\n/*\n Given a string, return true if it contains\
    \ a substring between given indices.\n   Only check the substring if they are\
    \ valid\n    >>> has_substring(\"hello\", 2, 4)\n    true\n    >>> has_substring(\"\
    hello\", 0, 3)\n    true\n    >>> has_substring(\"hello\", -1, 3)\n    false\n\
    \    >>> has_substring(\"hello\", 2, 100)\n    false\n*/", "{\n    long total\
    \ = 0;\n    auto charSet = TreeSet!(char)();\n    for(int i = 0; i < string.length;\
    \ i++)\n    {\n        charSet.insert(toLower(string[i]));\n    }\n    total =\
    \ charSet.length;\n    return total;\n}", "{\n    return (string.toUpper().toSet().length);\n\
    }", "{\n    // map each character to its lowercase counterpart\n    // e.g. 'A'\
    \ -> 'a', 'b' -> 'b', 'a' -> 'a'\n    string lowercased = map!(char.toLower)(string);\n\
    \    // store all distinct characters in a set\n    Set!char chars = set(lowercased);\n\
    \    // get the number of chars in the set\n    return chars.length;\n}", "{\n\
    \tlong result = 0;\n\tforeach(c; to!string(map!(toLower)(string)))\n\t{\n\t\t\
    if(result == 0 || c != result) result++;\n\t}\n\treturn result;\n}", "{\n    long\
    \ count=0;\n    int[char] result;\n    foreach(char d;string)\n    {\n       \
    \ if (result[toLower(d)]==0)\n        {\n            result[toLower(d)]=1;\n \
    \           count++;\n        }\n    }\n    return count;\n}", "{\n    immutable\
    \ char_counts = map!(char => uint)();\n    foreach(char c; string) \n    {\n \
    \       immutable lower = toLower(c);\n        immutable count = char_counts[lower];\n\
    \        char_counts[lower] = count ? count + 1 : 1;\n    }\n    return char_counts.length;\n\
    }\n ", "{\n    long res = 0;\n    char[char] memo = new char[char];\n    foreach(c;\
    \ string) {\n        if(c in memo) {\n            continue;\n        }\n     \
    \   else {\n            res += 1;\n            memo[c] = 'Y';\n        }\n   \
    \ }\n    return res;\n}", "{\n    return std.string.length(string.toUpper()) -\
    \ \n            std.algorithm.count(string.toUpper(),'-');\n}", "{\n    return\
    \ to!(long)(uniq(map!(toUpper)(string)));\n}\n/*\n Given a string and a delimiter,\
    \ split the string into a list of components\n    >>> split(\"hello,jerry,olivvy,lulu,crystal\"\
    , ',')\n    [\"hello\", \"jerry\", \"olivvy\", \"lulu\", \"crystal\"]\n    >>>\
    \ split(\"hello\", ',')\n    [\"hello\"]\n    >>> split(\"\", ',')\n    []\n*/\n\
    string[] split(string string, char delimiter)\n{\n    import std.algorithm.iteration\
    \ : find;\n    string[] split_string;\n    string temp;\n    size_t position =\
    \ 0;\n    while(position != string.length)\n    {\n        position = find(string[position..$],\
    \ delimiter);\n        if(position == string.length)\n        {\n            split_string\
    \ ~= temp;\n            break;\n        }\n        else\n        {\n         \
    \   temp = string[0..position];\n            split_string ~= temp;\n         \
    \   string = string[position+1..$];\n            position = 0;\n        }\n  \
    \  }\n    return split_string;\n}\n/*\n Given a string, find out how many words\
    \ (not word components) does it consist of\n    >>> count_words(\"hello,jerry,olivvy,lulu,crystal\"\
    )\n    5L\n    >>> count_words(\"hello\")\n    1L\n    >>> count_words(\"\")\n\
    \    0L\n*/\nlong count_words(string string)\n{\n    import std.algorithm.iteration\
    \ : find;\n    string[] split_string;\n    string temp;\n    size_t position =\
    \ 0;\n    long counter = 0;\n    while(position != string.length)\n    {\n   \
    \     position = find(string[position..$], ',');\n        if(position == string.length)\n\
    \        {\n            counter++;\n            break;\n        }\n        else\n\
    \        {\n            counter++;\n            string = string[position+1..$];\n\
    \            position = 0;\n        }\n    }\n    return counter;\n}\n/*\n Given\
    \ a string, find out how", "{\n\tauto set_of_characters = set!char();\n\tforeach(i,\
    \ x; string)\n\t{\n\t\tset_of_characters.insert(toLower(x));\n\t}\n\treturn set_of_characters.length;\n\
    }\n/*\n Given a string, find out how many distinct characters (regardless of case)\
    \ does it consist of\n    >>> count_distinct_characters_using_hash_table(\"xyzXYZ\"\
    )\n    3L\n    >>> count_distinct_characters_using_hash_table(\"Jerry\")\n   \
    \ 4L\n    \n*/\nlong count_distinct_characters_using_hash_table(string string)\
    \ \n{\n\tHashTable!(char, bool) ht = new HashTable!(char, bool)();\n\tforeach(i,\
    \ x; string)\n\t{\n\t\tht[toLower(x)] = true;\n\t}\n\treturn ht.length;\n}\nunittest\n\
    {\n\tassert(count_distinct_characters(\"xyzXYZ\") == 3L);\n\tassert(count_distinct_characters(\"\
    Jerry\") == 4L);\n\tassert(count_distinct_characters_using_hash_table(\"xyzXYZ\"\
    ) == 3L);\n\tassert(count_distinct_characters_using_hash_table(\"Jerry\") == 4L);\n\
    }", "    // Tuple\u7684\u4E00\u4E2A\u6784\u9020\u51FD\u6570\u662F\uFF0CTuple(ElementType[]\
    \ ts)\n    // \u6240\u4EE5\u8FD9\u91CC\u628Astring\u5185\u7684\u6BCF\u4E2A\u5B57\
    \u7B26\u4E32\u63D0\u53D6\u51FA\u6765\uFF0C\u653E\u5165\u4E00\u4E2AElementType\u6570\
    \u7EC4\u4E2D\uFF0C\n    // \u5373\u53EF\u6784\u9020\u51FATuple(ElementType[] ts)\n\
    \    // \u6CE8\u610Fcounts\u91CC\u9762\uFF0C\u6BCF\u4E2Aint\u90FD\u521D\u59CB\u5316\
    \u4E3A0\n    // tuples(t)\u8FD4\u56DE\u4E00\u4E2A\u6570\u7EC4\uFF0C\u6BCF\u4E2A\
    \u5143\u7D20\u90FD\u662Ftuple(t)\n    // tuple(t)\u8FD4\u56DE\u4E00\u4E2A\u5143\
    \u7EC4\uFF0C\u6709\u4E24\u4E2A\u5143\u7D20\uFF0C\u4E00\u4E2A\u662Ft\uFF0C\u4E00\
    \u4E2A\u662F0\n    // \u6240\u4EE5\uFF0Ccounts\u7684\u5143\u7D20\u7684\u5F62\u5F0F\
    \u5C31\u662F[tuple('a', 0), tuple('b', 0), ...]\n{ \n    long counts[0x80] = new\
    \ long[0x80];\n    foreach (ch; string) { \n        auto index = ch.to!char.tolower;\n\
    \        if (!counts[index]) { \n            counts[index] = 1;\n        }\n \
    \   }\n    return counts.length;\n}", "{\n    auto result = new Set!(char[])();",
  "{\n    auto table = long[char](0);\n    foreach(c; string)\n    {\n        table[toLower(c)]++;\n\
    \    }\n    return table.count!(ch => ch > 0L);\n}\n/*\nCount the number of occurrences\
    \ of a particular character in a string\n    >>> count_characters(\"Hello\", 'l')\n\
    \    2L\n*/\nlong count_characters(string string, in char c)\n{\n    long count\
    \ = 0L;\n    foreach(element; string)\n    {\n        if(element == c)\n     \
    \   {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nCount\
    \ the number of occurrences of each character in a string. Returns a mapping from\
    \ the character to the number of occurrences\n    >>> count_character_occurrences(\"\
    Hello\")\n    ['H': 1L, 'e': 1L, 'l': 2L, 'o': 1L]\n*/\nauto count_character_occurrences(string\
    \ string)\n{\n    auto table = long[char](0);\n    foreach(c; string)\n    {\n\
    \        table[c]++;\n    }\n    return table;\n}\n/*\nGiven a list, finds the\
    \ elements which has the highest frequency of occurrence and removes the rest,\
    \ keeping only one element of each\n    >>> filter_most_frequent_elements([1,\
    \ 2, 3, 1, 3, 3, 4, 5, 1, 4, 4, 5, 5, 5])\n    [1, 3, 4, 5]\n*/\nauto filter_most_frequent_elements(E[])(E[]\
    \ input)\n{\n    auto frequency = long[E](0);\n    foreach(e; input)\n    {\n\
    \        frequency[e]++;\n    }\n    long max_frequency = frequency.values.max;\n\
    \    auto filtered = E[](max_frequency);\n    foreach(pair; frequency)\n    {\n\
    \        if(pair.value == max_frequency)\n        {\n            filtered ~= pair.key;\n\
    \        }\n    }\n    return filtered;\n}\n/*\nFinds the index of the first occurrence\
    \ of a given element in a list. If the element does not occur in the", "{\n  \
    \  // set\n    auto characters = set!char;\n    foreach(char c; string)\n    {\n\
    \        characters.insert(toLower(c));\n    }\n    return characters.length;\n\
    }", "{\n    auto count = 0L;\n    auto chars = map!(ch => toUpper(ch))(string);\n\
    \    foreach(i, ch; chars) \n    {\n        if (i == 0 || chars[i - 1] != ch)\
    \ \n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n    Find the first character that does not repeat in the string\n    >>> find_first_non_repeating_character(\"\
    xyzxyz\")\n    'x'\n    >>> find_first_non_repeating_character(\"abcxyz\")\n \
    \   'a'\n*/\nchar find_first_non_repeating_character(string string) \n{\n    import\
    \ std.range : take, dropOne;\n    auto count = 0L;\n    auto chars = map!(ch =>\
    \ toUpper(ch))(string);\n    foreach(i, ch; chars) \n    {\n        if (i == 0\
    \ || chars[i - 1] != ch) \n        {\n            count++;\n        }\n      \
    \  if(i==chars.length-1)\n        {\n            if(count==1)\n            {\n\
    \                return ch;\n            }\n        }\n    }\n    return 'a';\n\
    }\n/*\n    >>> reverse_in_place(\"abcdef\")\n    \"fedcba\"\n    >>> reverse_in_place(\"\
    xyz\")\n    \"zyx\"\n*/\nstring reverse_in_place(string string) \n{\n    auto\
    \ count = 0L;\n    auto chars = map!(ch => toUpper(ch))(string);\n    auto rev\
    \ = string[$-1];\n    foreach(i, ch; chars) \n    {\n        if (i == 0 || chars[i\
    \ - 1] != ch) \n        {\n            count++;\n        }\n        if(i==chars.length-1)\n\
    \        {\n            if(count==1)\n            {\n                return rev;\n\
    \            }\n        }\n    }\n    return 'a';\n}", "{\n\t/*Use set to remove\
    \ duplicate*/\n\treturn set(to!string(toUpper(string))).length;\n}\n/*\n Given\
    \ a string, check if it is a palindrome.\n    >>> is_palindrome(\"A but tuba\"\
    )\n    true\n    >>> is_palindrome(\"A nut for a jar of tuna\")\n    true\n  \
    \  >>> is_palindrome(\"A nut for a jar of beans\")\n    false\n*/", "{\n    return\
    \ string.toUpper().countUntil(a=>a==string.toUpper().front);\n}\ncount_distinct_characters(\"\
    xyzXYZ\");\ncount_distinct_characters(\"Jerry\");\n \n ", "{\n    return string.length\
    \ - (string.toLower().translate(toupper).remove(tolower));\n}", "{\n    /*\n \
    \   //by using std.algorithm.uniq\n    uint[] u = string.chars.map!(toUpper)().uniq();\n\
    \    return u.length;\n    */\n    //by using std.array.array\n    uint[] a =\
    \ [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\
    \ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\
    \ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\
    \ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\
    \ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\
    \ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\
    \ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\
    \ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u", "{\n    string\
    \ upperString = to!string(to!wstring(string).toupper());\n    string[] array =\
    \ split(upperString);\n    return array.length;\n}", "{\n    return (string.length\
    \ - string.join(\"\").nchars).count;\n}", "{\n    return to!(\"string\")(\"\"\
    ).byChunk(string).distinct.length;\n}\n \n \n \n \n/*\n Given a number, find out\
    \ how many distinct digits (0-9) does it consist of\n    >>> count_distinct_digits(912)\n\
    \    3L\n    >>> count_distinct_digits(1)\n    1L\n    \n*/\nlong count_distinct_digits(long\
    \ number) \n{\n    return count_distinct_characters(to!string(number));\n}\n \n\
    \ \n \n \n/*\n Given a string, find out how many distinct characters (regardless\
    \ of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n\
    \    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong\
    \ count_distinct_characters(string string) \n{\n    return to!(\"string\")(\"\"\
    ).byChunk(string).distinct.length;\n}\n \n \n \n \n/*\n Given a number, find out\
    \ how many distinct digits (0-9) does it consist of\n    >>> count_distinct_digits(912)\n\
    \    3L\n    >>> count_distinct_digits(1)\n    1L\n    \n*/\nlong count_distinct_digits(long\
    \ number) \n{\n    return count_distinct_characters(to!string(number));\n}\n \n\
    \ \n \n \n/*\n Given a string, find out how many distinct characters (regardless\
    \ of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n\
    \    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong\
    \ count_distinct_characters(string string) \n{\n    return to!(\"string\")(\"\"\
    ).byChunk(string).distinct.length;\n}\n \n \n \n \n/*\n Given a number, find out\
    \ how many distinct digits (0-9) does it consist of\n    >>> count_distinct_digits(912)\n\
    \    3L\n    >>> count_distinct_dig", "{\n    return string.map!toLower.array.uniq.length;\n\
    }", "{\n    long res;\n    foreach(char; string) \n    {\n        res += (res\
    \ & 1L << (to!char(\"a\") <= char <= to!char(\"z\") ? char - to!char(\"a\") :\
    \ char - to!char(\"A\") + 26)) == 0L;\n    }\n    return res;\n}", "{\n    return\
    \ string.lower.unique;\n}", "    in \n    {\n        assert(string.length > 0);\n\
    \    }\n    body\n    {\n        return set(to!string(char)(string)).length;\n\
    \    }\n/*\n Given two strings, find out if the first string contains any character\
    \ that is not in the second string\n    >>> contains_uncommon_character(\"xyzXYZ\"\
    , \"XYZ\")\n    false\n    >>> contains_uncommon_character(\"xyzXYZ\", \"abcd\"\
    )\n    true\n*/", "{\n    // write the body of your function here\n    return\
    \ 0L;\n}", "{\n    string lower = toLower(string);\n    return std.algorithm.uniq(lower.byChunk(1)).length;\n\
    }\n/*\n Given an integer value, determine whether it is an odd number or not.\n\
    \    >>> is_odd(4)\n    false\n    >>> is_odd(1)\n    true\n*/", "{\n    dchar[bool]\
    \ charMap;\n    foreach(c; string)\n    {\n        charMap[c] = true;\n    }\n\
    \    return charMap.length;\n}", "{\n    long count = 0;\n    foreach(i; 0 ..\
    \ string.length) \n    {\n        long count_temp = 0;\n        for(long j = 0;\
    \ j < string.length; j++) \n        {\n            if(string[i] == string[j])\
    \ \n            {\n                count_temp++;\n            }\n        }\n \
    \       if(count_temp == 1) \n        {\n            count++;\n        }\n   \
    \ }\n    return count;\n}\n/*\n Given two positive numbers x and y and a non-empty\
    \ string s, return a string containing the binary representation of a number z\
    \ with z equal to the product of x and y.\n    >>> s = \"xyzXYZ\"\n    >>> find_product(3L,\
    \ 4L, s)\n    \"11b\"\n    >>> find_product(2L, 3L, s)\n    \"110\"\n    >>> find_product(8L,\
    \ 2L, s)\n    \"11000\"\n    >>> find_product(11L, 12L, s)\n    \"10101b\"\n*/\n\
    string find_product(long x, long y, string s) \n{\n    long product = x * y;\n\
    \    string product_binary = to!string(product, 2);\n    return product_binary;\n\
    }\n/*\n Find the subsequence of consecutive numbers in the given sequence that\
    \ produces the greatest sum\n    >>> max_sum_sequence([-1L, 1L, -1L, 1L, -1L,\
    \ 1L, -1L, 1L, -1L, 1L])\n    1L\n    >>> max_sum_sequence([-1L, 1L, -1L, 1L,\
    \ -1L, 1L, -1L, 1L, -1L, 1L, -1L, 1L])\n    3L\n    >>> max_sum_sequence([-3L,\
    \ -5L, -1L, -10L, -1L, -1L, -1L, -2L, -2L, -1L, -1L, -2L, -2L, -1L, -1L, -2L,\
    \ -1L, -1L, -2L, -", "{\n    return countUntil!(toLower)(string.sort)(ch=> toLower(ch)\
    \ != ch);\n}\n/*\n Given two strings, figure out whether one is a permutation\
    \ of the other.\n    >>> is_permutation(\"aaaa\", \"aaAa\")\n    true\n    >>>\
    \ is_permutation(\"abc\", \"bca\")\n    true\n    >>> is_permutation(\"abc\",\
    \ \"cab\")\n    true\n    >>> is_permutation(\"abc\", \"abc\")\n    true\n   \
    \ >>> is_permutation(\"abcc\", \"abca\")\n    false\n    >>> is_permutation(\"\
    abcc\", \"abcb\")\n    false\n    >>> is_permutation(\"cab\", \"abc\")\n    true\n\
    \    >>> is_permutation(\"xabx\", \"abx\")\n    false\n    >>> is_permutation(\"\
    abx\", \"xabx\")\n    false\n*/", "{\n    \n}", "{\n    //assume not the empty\
    \ string\n    long number_of_distinct_characters = 0;\n    long current_character_index\
    \ = 0;\n    long next_character_index = 1;\n    char current_character = string[current_character_index];\n\
    \    char next_character = string[next_character_index];\n    while(next_character_index\
    \ < string.length){\n        if(current_character != next_character){\n      \
    \      number_of_distinct_characters++;\n            current_character = next_character;\n\
    \        }\n        next_character_index++;\n        next_character = string[next_character_index];\n\
    \    }\n    return number_of_distinct_characters + 1;\n}", "{\n    // Return the\
    \ number of distinct characters in the string\n    int result = 0;\n    foreach(c;\
    \ string.toLower())\n    {\n        if(result == 0)\n        {\n            result\
    \ = 1;\n        }\n        else if(c != string[result - 1])\n        {\n     \
    \       result++;\n        }\n    }\n    return result;\n}", "{\n    return uniq(std.algorithm.map!(toLower)(string)).length;\n\
    }", "{\n    return uniq(to!(string[])(string.tolower())).length;\n}", "{\n\tauto\
    \ result = Appender!(ubyte[])();\n\tforeach(c; string)\n\t{\n\t\tif (result.indexOf(cast(ubyte)c)\
    \ == -1)\n\t\t\tresult.put(cast(ubyte)c);\n\t}\n\treturn result.length;\n}", "{\n\
    \    long result;\n    const(char)[] alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    auto chars = std.algorithm.map!(x => std.string.strip(x, \"\\n\\r\"))(std.string.split(string,\
    \ \"\"));\n    auto char_map = std.algorithm.map!(x => to!char(x))(chars);\n \
    \   auto unique_chars = std.algorithm.uniq(char_map);\n    auto count = std.algorithm.map!(x\
    \ => std.string.count(string, x.to!string))(unique_chars);\n    result = std.algorithm.reduce!\"\
    a + b\"(count);\n    return result;\n}\n```", "{\n    long char_count = 0;\n \
    \   foreach(char; string) \n    {\n        if (char_count == 0) \n        {\n\
    \            char_count++;\n        } \n        else \n        {\n           \
    \ bool flag = true;\n            foreach(y; 0..char_count) \n            {\n \
    \               if (tolower(char) == tolower(string[y])) \n                {\n\
    \                    flag = false;\n                    break;\n             \
    \   }\n            }\n            if (flag) \n            {\n                char_count++;\n\
    \            }\n        }\n    }\n    return char_count;\n}\n//=============================================================\n\
    /*\n Given an array of strings, find the one that has the largest number of distinct\
    \ characters\n    >>> find_most_distinct_characters([\"abcdefg\", \"abcabcabcabcabcabcabcabcabcabc\"\
    ])\n    \"abcdefg\"\n    >>> find_most_distinct_characters([\"cs50\", \"cs50isawesome\"\
    , \"CS50\"])\n    \"cs50isawesome\"\n*/\nstring find_most_distinct_characters(string[]\
    \ strings) \n{\n    long max = 0;\n    string max_string = \"\";\n    foreach(string;\
    \ strings) \n    {\n        long chars = count_distinct_characters(string);\n\
    \        if (chars > max) \n        {\n            max = chars;\n            max_string\
    \ = string;\n        }\n    }\n    return max_string;\n}\n//=============================================================\n\
    /*\n Given a string, return the first character that appears only once, otherwise\
    \ return the empty string\n    >>> find_first_unique_character(\"abcbcba\")\n\
    \    'a'\n    >>> find_first_unique_character(\"abccccb\")\n    \"\"\n*/\nchar\
    \ find_first_unique_character(string string) \n{\n    int flag = 0;\n    foreach(char;\
    \ string) \n    {\n        flag = 0;\n        foreach(x; 0..string.length) \n\
    \        {\n            if (x == flag) \n            {\n                continue;\n\
    \            }\n            if (char", "{\n    auto set = uniq(string);\n    return\
    \ set.length;\n}\n/*\n Sum of a given list\n    >>> sum_of_numbers([1,2,3,4,5])\n\
    \    15L\n*/\nlong sum_of_numbers(long[] numbers) \n{\n    long s = 0;\n    foreach(item;\
    \ numbers) \n    {\n        s += item;\n    }\n    return s;\n}\n/*\n Given a\
    \ string and a search pattern, find out how many times the search pattern matches\
    \ the given string.\n    >>> find_occurrence(\"dolly\",\"ll\")\n    1L\n    >>>\
    \ find_occurrence(\"dolly\",\"dd\")\n    0L\n*/\nlong find_occurrence(string string,\
    \ string search) \n{\n    long i = 0;\n    long j = 0;\n    long count = 0;\n\
    \    while(i < string.length && j < search.length) \n    {\n        if(string[i]\
    \ == search[j]) \n        {\n            i++;\n            j++;\n        } \n\
    \        else \n        {\n            i = i - j + 1;\n            j = 0;\n  \
    \      }\n        if(j == search.length) \n        {\n            count++;\n \
    \           j = 0;\n        }\n    }\n    return count;\n}\n/*\n Given a string,\
    \ find out if it is a palindrome or not.\n A palindrome is a word, phrase, number,\
    \ or other sequence of characters which reads the same backward as forward, such\
    \ as madam or racecar.\n    >>> is_palindrome(\"racecar\")\n    true\n    >>>\
    \ is_palindrome(\"Hello\")\n    false\n*/", "{\n    return set(string.toUpper).length;\n\
    }", "{\n    auto letters = string.to!string.replace(\" \", \"\").replace(\"-\"\
    , \"\").replace(\"\\n\", \"\").toLowerCase().byChar;\n    long count = 0;\n  \
    \  foreach(l; std.algorithm.uniq(letters)) \n    {\n        count++;\n    }\n\
    \    return count;\n}\n/*\nGiven a string, find out how many distinct characters\
    \ (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters2(string string) \n{\n    string = string.to!string.replace(\"\
    \ \", \"\").replace(\"-\", \"\").replace(\"\\n\", \"\").toLowerCase();\n    return\
    \ std.algorithm.uniq(string.byChar).length;\n}\n/*\nGiven a string, find out how\
    \ many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters3(string string) \n{\n    string = string.to!string.replace(\"\
    \ \", \"\").replace(\"-\", \"\").replace(\"\\n\", \"\").toLowerCase();\n    return\
    \ std.algorithm.uniq(string.byChar).length;\n}\n/*\nGiven a string, find out how\
    \ many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters4(string string) \n{\n    string = string.to!string.replace(\"\
    \ \", \"\").replace(\"-\", \"\").replace(\"\\n\", \"\").toLowerCase();\n    long\
    \ count = 0;\n    foreach(l; std.algorithm.uniq(string.byChar)) \n    {\n    \
    \    count++;\n    }\n    return count;\n}\n/*\nGiven a string, find", "{\n  \
    \  auto s = toLower(string);\n    return iota(1, s.length).map!(i => s[i]).uniq.length;\n\
    }", "{\n    auto ret = tuple(string.front());\n    for (size_t i = 1; i < string.length;\
    \ ++i) \n    {\n        const char c = string[i];\n        if (!std.algorithm.any!(unaryFun!(x\
    \ => c == toUpper(x)))(ret))\n            ret ~= c;\n    }\n    return ret.length;\n\
    }", "{\n    string str = toUpper(string);\n    return str.unique.length;\n}",
  "{\n    return size_t.max;\n}\n/*\n Given a string and a character, find out how\
    \ many times the character occurs in the string\n    >>> count_occurrences(\"\
    abcabcabcabcabcabcabcabcabcabc\", 'a')\n    8L\n    >>> count_occurrences(\"xyzxyzxyzxyzxyzxyzxyzxyzxyzxyz\"\
    , 'z')\n    8L\n*/\nlong count_occurrences(string string, char character) \n{\n\
    \    return size_t.max;\n}\n/*\n Given a string, find out if it is a palindrome\n\
    \    >>> is_palindrome(\"abcba\")\n    true\n    >>> is_palindrome(\"abcabc\"\
    )\n    false\n    >>> is_palindrome(\"abccba\")\n    true\n    >>> is_palindrome(\"\
    11121111\")\n    true\n*/", "{\n    return string.toLower.unique.length;\n}",
  "{\n\tauto result = Tuple!(\"characters\" => \"long\")(0L);", "{\n  int[] count\
    \ = new int[256];\n  long total = 0;\n  for (int i = 0; i < string.length; i++)\
    \ \n  {\n    count[cast(uint)string[i]]++;\n  }\n  for (int c = 0; c < 256; c++)\
    \ \n  {\n    if (count[c] > 0) \n    {\n      total++;\n    }\n  }\n  return total;\n\
    }", "{\n    string key_characters = \"\";\n    long n_characters = 0;\n    size_t\
    \ sz = string.length;\n    size_t length_key_characters = 0;\n    foreach(char\
    \ c; string)\n    {\n        string temp = \"\";\n        temp += c;\n       \
    \ string key_characters_temp = key_characters;\n        if( temp.length>0 && temp[0]\
    \ != key_characters_temp.length && key_characters_temp.find(temp) == -1)\n   \
    \     {\n            length_key_characters += 1;\n            key_characters +=\
    \ temp;\n        }\n    }\n    return length_key_characters;\n}", "{\n    return\
    \ _uniq(to!string(map!(toupper)(string))).length;\n}\n/*\n Given a string, find\
    \ out how many distinct characters (regardless of case) does it consist of\n \
    \   >>> count_distinct_characters(\"xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4L\n    \n*/\nlong count_distinct_characters_alt(string string)\
    \ \n{\n    return std.range.uniq(map!(toupper)(string)).length;\n}\n/*\n Given\
    \ a string and a character, count how many times the character\n occurs in the\
    \ string\n    >>> count_occurrences(\"Jerry\", 'r')\n    2L\n    >>> count_occurrences(\"\
    Mississippi\", 's')\n    4L\n    \n*/\nsize_t count_occurrences(string string,\
    \ char ch) \n{\n    return std.range.count(string, ch);\n}\n/*\n Given a string\
    \ and a character, count how many times the character\n occurs in the string\n\
    \    >>> count_occurrences(\"Jerry\", 'r')\n    2L\n    >>> count_occurrences(\"\
    Mississippi\", 's')\n    4L\n    \n*/\nsize_t count_occurrences_alt(string string,\
    \ char ch) \n{\n    size_t result = 0;\n    foreach (ch2; string) {\n        if\
    \ (ch2 == ch) {\n            result++;\n        }\n    }\n    return result;\n\
    }\n/*\n Given a string, find the first character that does not have duplicates\n\
    \ (regardless of case)\n    >>> find_unique_character(\"Jerry\")\n    'J'\n  \
    \  >>> find_unique_character(\"Mississippi\")\n    'M'\n    >>> find_unique_character(\"\
    apple\")\n    'a'\n    \n*/\nchar find_unique_character(string string) \n{\n \
    \   return to!char(std.range.min!(a => count_occurrences(string, a))(string));\n\
    }\n/*\n Given a string, find the first character that does not have duplicates\n\
    \ (regardless of case)\n    >>> find_", "{\n    auto key = SortedRange(string.chars);\n\
    \    auto map = KeyValueArray!(char, bool, key);\n    foreach(char c; string.chars)\
    \ {\n        auto result = map.insert(tuple(c, false));\n        if(result.isNew)\
    \ \n            result.keyValue.value = true;\n    }\n    return map.length;\n\
    }", "{\n    return set(string.lower).length;\n}", "{\n    return to!set(string.toLower).length;\n\
    }", "{\n    return  array(set(string.lowercase)).length;\n}", "{\n    long result;\n\
    \    int[string] characters;\n    foreach(character; string)\n    {\n        characters[character]\
    \ = 1;\n    }\n    result = characters.length;\n    return result;\n}\n/*\nGiven\
    \ a string, find out how many distinct characters (case sensitive) does it consist\
    \ of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    6L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4L\n*/\nlong count_distinct_characters_case_sensitive(string string)\
    \ \n{\n    long result;\n    string[char] characters;\n    foreach(character;\
    \ string)\n    {\n        characters[character] = 1;\n    }\n    result = characters.length;\n\
    \    return result;\n}\n/*", "{\n    // auto set=std.set.Set(string);\n    //\
    \ return set.length;\n    \n    // auto x=std.algorithm.unique!(a => a.toLower());\n\
    \    // auto x=string.split().uniq;\n    // return x.length;\n    \n    string[]\
    \ arr=string.split().uniq;\n    return arr.length;\n}", "{\n    // write your\
    \ solution here\n    /*\n    int len = string.length;\n    if (len == 0) return\
    \ 0;\n    int l = 0;\n    int r = 0;\n    bool chars[char.max];\n    for (int\
    \ i = 0; i < char.max; i++) {\n        chars[i] = false;\n    }\n    chars[char.tolower(string[l])]\
    \ = true;\n    int count = 1;\n    while (r < len) {\n        r++;\n        if\
    \ (r == len) break;\n        if (chars[char.tolower(string[r])] == false) {\n\
    \            chars[char.tolower(string[r])] = true;\n            count++;\n  \
    \      }\n    }\n    return count;\n    */\n    // solution 2\n    /*\n    HashSet!char\
    \ uniqueChars = new HashSet!char();\n    foreach (char ch; string)\n    {\n  \
    \      uniqueChars.insert(ch);\n    }\n    return uniqueChars.length;\n    */\n\
    \    // solution 3\n    import std.conv;\n    string = to!string(to!wstring(string).uniq);\n\
    \    return string.length;\n}", "{\n    long count = 0;\n    dchar[char] temp;\n\
    \    foreach(dchar c; string)\n    {\n        if(!temp.insert(c).second) // \u043F\
    \u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u043D\u0430\u043B\u0438\u0447\
    \u0438\u0435 \u0431\u0443\u043A\u0432\u044B \u0432 \u043C\u0430\u0441\u0441\u0438\
    \u0432\u0435\n        {\n            count ++;\n        }\n    }\n    return count;\n\
    }\n```", "{\n    return set!string(set(string.toUpper.to!char[]).array).length;\n\
    }", "{\n     auto result = [string[0]];\n     foreach(character; string)\n   \
    \  {\n       result ~= character;\n     }\n     return result.length;\n}", "{\n\
    \    return set(string.lower.split('')).length;\n}", "{\n    string s = to!string(string.map!(tolower));\n\
    \    return s.length == 0 ? 0 : s.chunks(1).distinct.length;\n}", "{\n    auto\
    \ cmp = (a, b) => toLower(a) == toLower(b); // equivalence relation\n    auto\
    \ to_distinct_chars = unique!cmp(string); // deduplicate using equivalence\n \
    \   return to_distinct_chars.length;\n}\n/*\n  Find the longest word in a sentence\n\
    \  >>> find_longest_word(\"Hello, my name is $firstname. I am $age old\")\n  \"\
    firstname\"\n  >>> find_longest_word(\"Today, I want to share my opinion with\
    \ you\")\n  \"opinion\"\n*/\nstring find_longest_word(string sentence) \n{\n \
    \   return max!((a, b) => a.length < b.length)(sentence.split(\" \"));\n}\n/*\n\
    Find the shortest word in a sentence\n    >>> find_shortest_word(\"My name is\
    \ $firstname. I am $age old\")\n    \"My\"\n    >>> find_shortest_word(\"Now,\
    \ I want to share my opinion with you\")\n    \"I\"", "{\n    long total = 0;\n\
    \    Map!char map;\n    foreach(char ch; string) \n    {\n        map[ch] = map.get(ch,\
    \ 0) + 1;\n    }\n    return map.length;\n}\n/*\n Given a string and a character,\
    \ calculate how many times that character occurs in the string\n    >>> count_character(\"\
    The quick brown fox\", 'o')\n    2L\n    >>> count_character(\"xxx\", 'x')\n \
    \   3L\n*/\nlong count_character(string string, char character) \n{\n    long\
    \ total = 0;\n    foreach(char ch; string) \n    {\n        if(ch == character)\n\
    \            total++;\n    }\n    return total;\n}\n/*\n Given a string, find\
    \ out the most frequent character in it\n    >>> find_most_frequent_character(\"\
    The quick brown fox\")\n    'o'\n    >>> find_most_frequent_character(\"JJJJ\"\
    )\n    'J'\n*/\nchar find_most_frequent_character(string string) \n{\n    char\
    \ max_character = ' ';\n    long max_number = 0;\n    foreach(char ch; string)\
    \ \n    {\n        long count = count_character(string, ch);\n        if(count\
    \ > max_number) \n        {\n            max_number = count;\n            max_character\
    \ = ch;\n        }\n    }\n    return max_character;\n}\n/*\n Given a string,\
    \ remove all duplicated characters from it.\n Remember that capitalization matters\
    \ here.\n    >>> remove_duplicated_characters(\"Jerry\")\n    \"Jery\"\n    >>>\
    \ remove_duplicated_characters(\"Mississippi\")\n    \"Misp\"\n*/\nstring remove_duplicated_characters(string\
    \ string) \n{\n    // Don't modify the input string, use a copy of it\n    string\
    \ temp = string;\n    string new_string = \"\";\n    foreach(char ch; temp) \n\
    \    {\n        size_t index = temp.indexOf(ch);\n        if(index != -1) \n \
    \       {\n            temp = temp[0..index] ~ temp[index", "{\n\tauto char_set\
    \ = std.set.make();\n\t\n\tfor(int i = 0; i < string.length; i++) \n\t{\n\t\t\
    char_set.insert(tolower(string[i]));\n\t}\n\t\n\treturn char_set.length;\n}\n\
    /*\nGiven a string, find out how many distinct characters (regardless of case)\
    \ does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3L\n\
    \    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong count_distinct_characters(string\
    \ string) \n{\n\tauto char_set = std.set.make();\n\t\n\tfor(int i = 0; i < string.length;\
    \ i++) \n\t{\n\t\tchar_set.insert(tolower(string[i]));\n\t}\n\t\n\treturn char_set.length;\n\
    }\nlong count_distinct_characters(string string) \n{\n\tauto char_set = std.set.make();\n\
    \t\n\tfor(int i = 0; i < string.length; i++) \n\t{\n\t\tchar_set.insert(tolower(string[i]));\n\
    \t}\n\t\n\treturn char_set.length;\n}\nlong count_distinct_characters(string string)\
    \ \n{\n\tauto char_set = std.set.make();\n\t\n\tfor(int i = 0; i < string.length;\
    \ i++) \n\t{\n\t\tchar_set.insert(tolower(string[i]));\n\t}\n\t\n\treturn char_set.length;\n\
    }\nlong count_distinct_characters(string string) \n{\n\tauto char_set = std.set.make();\n\
    \t\n\tfor(int i = 0; i < string.length; i++) \n\t{\n\t\tchar_set.insert(tolower(string[i]));\n\
    \t}\n\t\n\treturn char_set.length;\n}\nlong count_distinct_characters(string string)\
    \ \n{\n\tauto char_set = std.set.make();\n\t\n", "{\n    auto distinct_characters\
    \ = newSet!char;\n    foreach(character; string) \n    {\n        distinct_characters.insert(character);\n\
    \    }\n    return distinct_characters.length;\n}", "{\n    enum res = typeof(char.toLower(string[0]))[];\
    \ \n    foreach(char c; char.toLower(string)) \n    {\n        if(res.count(c)\
    \ == 0) \n        {\n            res ~= c;\n        }\n    }\n    return res.length;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
