name: HumanEval_16_count_distinct_characters
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Given a string, find out how\
  \ many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
  xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
  */\nlong count_distinct_characters(string string) \n"
tests: "unittest\n{\n    alias candidate = count_distinct_characters;\n\n    assert(candidate(\"\
  \") == 0L);\n    assert(candidate(\"abcde\") == 5L);\n    assert(candidate(\"abcdecadeCADE\"\
  ) == 5L);\n    assert(candidate(\"aaaaAAAAaaaa\") == 1L);\n    assert(candidate(\"\
  Jerry jERRY JeRRRY\") == 5L);\n}\nvoid main(){}"
completions: ["{\n\tconst char[] array = string.chars;\n\tlong result = 0;\n\tforeach(unichar\
    \ i; array)\n\t{\n\t\tif(result == 0)\n\t\t{\n\t\t\tresult = result + 1;\n\t\t\
    }\n\t\tforeach(unichar j; array)\n\t\t{\n\t\t\tif(tolower(i) == tolower(j))\n\t\
    \t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(j == cast(unichar)array.length - 1)\n\
    \t\t\t{\n\t\t\t\tresult = result + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n\
    }", "{\n    static bool[char] s;\n    foreach(c; string) \n    {\n        s[c]\
    \ = true;\n    }\n    return s.length;\n}", "{\n    return set(map!(char.toLower)(string)).length;\n\
    }", "{\n    alias List(Tuple!(char, bool)) L;\n    L letters_and_count(string.length);\n\
    \    foreach(char letter; string)\n    {\n        bool letter_already_counted\
    \ = false;\n        int letter_index;\n        foreach(ref letter_and_count; letters_and_count)\n\
    \        {\n            ++letter_index;\n            if(letter_and_count[0] ==\
    \ letter)\n            {\n                letter_already_counted = true;\n   \
    \             break;\n            }\n        }\n        if(!letter_already_counted)\n\
    \        {\n            letters_and_count ~= tuple(letter, true);\n        }\n\
    \    }\n    return letters_and_count.length;\n}\n/*\n Given a sorted array, find\
    \ out how many different values does it contain\n    >>> count_distinct_values([-2,\
    \ 0, 1, 2, 3, 4, 6, 7, 9, 10])\n    9L\n    >>> count_distinct_values([-2, 0,\
    \ 1, 1, 2, 3, 4, 6, 7, 9, 10])\n    9L\n    >>> count_distinct_values([-2, 0,\
    \ 1, 1, 2, 3, 4, 6, 7, 9, 10, 10])\n    9L\n    >>> count_distinct_values([-2,\
    \ 0, 1, 1, 2, 3, 4, 6, 7, 9, 10, 10, 10])\n    9L\n    >>> count_distinct_values([])\n\
    \    0L\n*/\nlong count_distinct_values(T[])(T[] array) \n{\n    if(array.length\
    \ == 0)\n    {\n        return 0;\n    }\n    int distinct_values_count = 1;\n\
    \    foreach(i, j; array[1 .. $])\n    {\n        if(array[i] != array[j])\n \
    \       {\n            ++distinct_values_count;\n        }\n    }\n    return\
    \ distinct_values_count;\n}\n/*\n Given a string, find out whether it contains\
    \ a character appearing only once\n    >>> has_unique_character(\"xyzXYZ\")\n\
    \   ", "{\n    auto lower_case_string = toLower(string);\n    return \n      \
    \  lower_case_string\n        .length\n        .iota\n        .map!(ch => lower_case_string[ch])\n\
    \        .dedup\n        .length;\n}", "{\n    string toUpperString=toUpper(string);\n\
    \    long[char] charLookup=new long[char];\n    foreach(char c;toUpperString)\n\
    \    {\n        if(charLookup.count(c)==0)\n        {\n            charLookup[c]=1;\n\
    \        }\n    }\n    return charLookup.length;\n}\n/*\n \n Given a string, find\
    \ out how many words it contains.\n    >>> count_words(\"abc def\")\n    2L\n\
    \    >>> count_words(\"abc def ghi\")\n    3L", "{\n    return string.toLower().dup.retro.distinct.length;\n\
    }\n/*\n Count of sequences in string str of length k, where\n        k is an integer,\
    \ k > 0\n        sequence is defined as a range of consecutive characters from\
    \ the string\n        if there are characters c1, c2, ... ck, then the sequence\
    \ (c1, c2, ... ck) is \n        valid iff c2 = c1 + 1, c3 = c2 + 1, ... ck = ck-1\
    \ + 1\n        input string is nonempty\n        input string contains only digits\
    \ from 0 to 9\n    >>> count_sequences(\"0212\", 2)\n    1L\n    >>> count_sequences(\"\
    012345\", 2)\n    3L\n*/\nlong count_sequences(string str, int k) \n{\n    long\
    \ count = 0;\n    auto char_array = str.dup.to!(immutable(char)[])();\n    size_t\
    \ n = char_array.length;\n    foreach(i;0..n) \n    {\n        if (i + k <= n)\
    \ \n        {\n            auto ok = true;\n            foreach(j;i..i+k-1) \n\
    \            {\n                if (char_array[j+1] != char_array[j] + 1) \n \
    \               {\n                    ok = false;\n                    break;\n\
    \                }\n            }\n            if (ok) \n            {\n     \
    \           count++;\n            }\n        }\n    }\n    return count;\n}\n\
    /*\n Given a string, return true iff it is a valid UTF-8 string\n    >>> is_valid_utf8(\"\
    \u0442\u0435\u0441\u0442\")\n    true\n    >>> is_valid_utf8(\"\u0442\u0435\u0441\
    \u0442. \u0435\u0449\u0435 \u0442\u0435\u0441\u0442\")\n    true\n    >>> is_valid_utf8(\"\
    \uC548\uB155 \uD558\uC138\uC694\")\n    true\n    >>> is_valid_utf8(\"invalid:\
    \ \\xd0\\x80\\xd0\\x80\")\n    false\n    >>> is_valid_utf8(\"invalid: \\xc0\\\
    x80\")\n    false\n", "{\n    auto set = std.container.set!(typeof(\"a\".toLower()));\n\
    \    foreach(char c; string)\n    {\n        set.insert(c.toLower());\n    }\n\
    \    return set.length;\n}", "{\n\tlong count = 0;\n\tforeach(c; to!string(std.array.array(string)))\
    \ \n\t{\n\t\tif(c.tolower() !in string)\n\t\t{\n\t\t\tstring ~= c.tolower();\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    auto s = set!(char)(string);\n\
    \    return s.length;\n}", "{\n    long result = 0;\n    foreach(char c; string)\
    \ \n    {\n        if (c.isAlpha) \n        {\n            ++result;\n       \
    \ }\n    }\n    return result;\n}", "{\n    ulong[char] chardict;\n    foreach(c;\
    \ string) {\n        if(c in chardict) \n            chardict[c] += 1;\n     \
    \   else \n            chardict[c] = 1;\n    }\n    return chardict.length;\n}",
  "{\n    // Creates a set (collection of unique elements)\n    auto s = set!char();",
  "{\n    Set!char letters = set();\n    foreach(char ch; string)\n    {\n       \
    \ letters.insert(ch);\n    }\n    return letters.length;\n}", "{\n    auto first\
    \ = string.front;\n    auto last = string.back;\n    static immutable IntRange\
    \ alphabet = 'a'..'z';\n    static immutable int alphabet_size = alphabet.length;\n\
    \    static immutable int ASCII_a = 'a';\n    immutable int char_to_index(char\
    \ c) {\n        immutable int ascii = cast(int)c;\n        if(ascii < ASCII_a)\
    \ return 0;\n        immutable int index = ascii - ASCII_a;\n        return index\
    \ < alphabet_size ? index : 0;\n    }\n    static immutable int[] distinct = new\
    \ int[alphabet_size];\n    static immutable int distinct_size = distinct.length;\n\
    \    //std.array.fill(distinct, 0);\n    foreach(char c; string) \n    {\n   \
    \     int index = char_to_index(c);\n        distinct[index] = 1;\n    }\n   \
    \ return std.array.sum(distinct[0..distinct_size]);\n}", "{\n    // your code\
    \ here\n    \n    // I will do it in 2 different ways:\n    // 1) Convert to uppercase\
    \ and then check the number of unique characters\n    // 2) use hash table\n \
    \   \n    // version 1 \n    auto new_string = string.toUpper;\n    long length\
    \ = new_string.length;\n    long count = 0;\n    foreach(char c; new_string){\n\
    \        if(new_string.countOf(c) == 1){\n            count++;\n        }\n  \
    \  }\n    return count;\n    \n    // version 2\n    auto hashTable = HashTable!char(string.length);\n\
    \    foreach(char c; string){\n        hashTable[c] = true;\n    }\n    return\
    \ hashTable.length;\n}\n/*", "{\n    return to!long(std.algorithm.uniq(string.chars.map!(x\
    \ => x.toLower()).array).length);\n}", "{\n    auto d = typeof(return)();\n  \
    \  foreach(c; string) {\n        if (c == '\\0') continue;\n        d[tolower(c)]\
    \ = c;\n    }\n    return d.length;\n}", "{\n\tstruct S {\n\t\tstring string;\n\
    \t\tint[] result;\n\t\tthis(string string) {\n\t\t\tthis.string = string;\n\t\t\
    \tresult = new int[127];\n\t\t}\n\t\t\n\t\tvoid some_function(string string) {\n\
    \t\t\tint k = 0;\n\t\t\tforeach(char c; string) {\n\t\t\t\tresult[cast(int)c]\
    \ = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint result_length() {\n\t\t\treturn result.length;\n\
    \t\t}\n\t\t\n\t\t@property {\n\t\t\treturn result.length;\n\t\t}\n\t}\n\t\n\t\
    S s = new S(string);\n\ts.some_function(string);\n\tint result = 0;\n\tforeach(e;\
    \ s.result) {\n\t\tresult += e;\n\t}\n\treturn result;\n}", "{\n    return string.length()\
    \ - string.toLower().length();\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
