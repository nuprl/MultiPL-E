name: HumanEval_30_get_positive
language: d
prompt: "import std.math;\n/*\nReturn only positive numbers in the array.\n    >>>\
  \ get_positive([-1L, 2L, -4L, 5L, 6L])\n    [2L, 5L, 6L]\n    >>> get_positive([5L,\
  \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, 2L, 3L, 9L, 123L,\
  \ 1L]\n    \n*/\nlong[] get_positive(long[] l) \n"
tests: "unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
  \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L,\
  \ 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
  \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
completions: ["{\n    long[] n = l.filter!(x => x > 0);\n    return n;\n}", "{\n \
    \ import std.conv;\n  import std.algorithm;\n  import std.math;\n  long[] temp;\n\
    \  foreach(el; l)\n  {\n    if(el > 0)\n    {\n      temp ~= el;\n    }\n  }\n\
    \  return temp;\n}", "{\n  int pos_count = 0;\n  foreach(long num; l)\n  {\n \
    \   if(num > 0)\n      pos_count++;\n  }\n  long[] result = new long[pos_count];\n\
    \  pos_count = 0;\n  foreach(long num; l)\n  {\n    if(num > 0)\n    {\n     \
    \ result[pos_count] = num;\n      pos_count++;\n    }\n  }\n  return result;\n\
    }\n/*\nReturn only negative numbers in the array.\n    >>> get_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[] get_negative(long[]\
    \ l) \n{\n  int neg_count = 0;\n  foreach(long num; l)\n  {\n    if(num < 0)\n\
    \      neg_count++;\n  }\n  long[] result = new long[neg_count];\n  neg_count\
    \ = 0;\n  foreach(long num; l)\n  {\n    if(num < 0)\n    {\n      result[neg_count]\
    \ = num;\n      neg_count++;\n    }\n  }\n  return result;\n}\n/*\nReturn the\
    \ minimum value in the array.\n    >>> get_min([1L, 2L, 3L, 4L, 5L])\n    1L\n\
    \    >>> get_min([123L, 3L, -5L, 20L, 0L, 1L, -3L, 20L, -10L])\n    -10L\n*/\n\
    long get_min(long[] l) \n{\n  long min = l[0];\n  foreach(long num; l)\n  {\n\
    \    if(num < min)\n      min = num;\n  }\n  return min;\n}\n/*\nReturn the maximum\
    \ value in the array.\n    >>> get_max([1L, 2L,", "{\n    long[] l2 = new long[0];\n\
    \    foreach(int j, num; l)\n    {\n        if(num > 0)\n        {\n         \
    \   l2 = l2 ~ num;\n        }\n    }\n    return l2;\n}\n/*\nImplement these two\
    \ functions.\n    >>> get_sum([1L, 2L, 3L, 4L, 5L])\n    15L\n    >>> get_sum([1L,\
    \ 2L, 3L, -5L, 10L])\n    11L\n    \n*/\nlong get_sum(long[] l) \n{\n    long\
    \ sum = 0;\n    foreach(int j, num; l)\n    {\n        sum += num;\n    }\n  \
    \  return sum;\n}\nlong get_sum2(long[] l) \n{\n    return foldl!(\"a + b\")(0,\
    \ l);\n}", "{\n\tint i;\n\t//long[] output;\n\tint size = 0;\n\t\n\tfor (i = 0;\
    \ i < l.length; i++) {\n\t\t//printf(\" %ld \", l[i]);\n\t\tif (l[i] >= 0)\n\t\
    \t\tsize++;\n\t}\n\tlong[] output = new long[size];\n\tint j = 0;\n\tfor (i =\
    \ 0; i < l.length; i++) {\n\t\tif (l[i] >= 0) {\n\t\t\toutput[j] = l[i];\n\t\t\
    \tj++;\n\t\t}\n\t}\n\treturn output;\n}", "{\n    auto result = new long[];\n\
    \    foreach(item; l) \n    {\n        if (item > 0) \n        {\n           \
    \ result ~= item;\n        }\n    }\n    return result;\n}", "    version(LDC)\n\
    {\n    return l.filter!(a => a > 0L);\n}", "{\n    // FIXME: implement the function\n\
    \    return l.filter!(a => a > 0);\n}", "{\n\tlong[] positive = new long[0];\n\
    \tforeach(e; l)\n\t{\n\t\tif(e > 0)\n\t\t{\n\t\t\tpositive ~= e;\n\t\t}\n\t}\n\
    \treturn positive;\n}", "{\n     long[] ret = new long[l.length];\n     int k\
    \ = 0;\n     for (int i = 0; i < l.length; i++)\n     {\n        if (l[i] > 0)\n\
    \        {\n            ret[k] = l[i];\n            k++;\n        }\n     }\n\
    \     long[] result = new long[k];\n     for (int i = 0; i < k; i++)\n       \
    \ result[i] = ret[i];\n     return result;\n}\n/*\nFilter array by even numbers.\n\
    \    >>> get_even([-1L, 2L, -4L, 5L, 6L])\n    [2L, -4L, 6L]\n    >>> get_even([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [2L, -10L]\n    \n*/\nlong[]\
    \ get_even(long[] l) \n{\n     long[] ret = new long[l.length];\n     int k =\
    \ 0;\n     for (int i = 0; i < l.length; i++)\n     {\n        if (l[i] % 2 ==\
    \ 0)\n        {\n            ret[k] = l[i];\n            k++;\n        }\n   \
    \  }\n     long[] result = new long[k];\n     for (int i = 0; i < k; i++)\n  \
    \      result[i] = ret[i];\n     return result;\n}\n/*\nFilter array by odd numbers.\n\
    \    >>> get_odd([-1L, 2L, -4L, 5L, 6L])\n    [-1L, 5L]\n    >>> get_odd([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, -5L, -3L, 3L, 9L,\
    \ 123L, 1L]\n    \n*/\nlong[] get_odd(long[] l) \n{\n     long[] ret = new long[l.length];\n\
    \     int k = 0;\n", "{\n    long[] l2;\n    foreach(val; l)\n    {\n        if(val\
    \ > 0)\n        {\n            l2 ~= val;\n        }\n    }\n    return l2;\n}",
  "{\n\tlong[] result = new long[0];\n\tforeach(long x; l)\n\t{\n\t\tif(x > 0)\n\t\
    \t{\n\t\t\tresult ~= x;\n\t\t}\n\t}\n\treturn result;\n}", "{ \n    return l.filter!(x\
    \ => x > 0)();\n}", "{\n  long[] result;\n  long[] pos;\n  foreach(l, x;\n   \
    \ if (x > 0)\n      pos ~= x;\n  )\n  result =  cast(long[]) pos;\n  return result;\n\
    }\n/*\n    Return the absolute values of each number in the array.\n    >>> absolute([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [1L, 2L, 4L, 5L, 6L]\n    >>> absolute([5L, 3L, -5L,\
    \ 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L, 1L, 10L]\n*/\nlong[] absolute(long[] l) \n{\n  long[] result;\n  long[]\
    \ pos;\n  foreach(l, x;\n    if (x < 0)\n      pos ~= x * -1;\n    else\n    \
    \  pos ~= x;\n  )\n  result =  cast(long[]) pos;\n  return result;\n}\n/*\nReturn\
    \ the sum of all numbers in the array.\n    >>> sum([-1L, 2L, -4L, 5L, 6L])\n\
    \    8L\n    >>> sum([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n   \
    \ 172L\n*/\nlong sum(long[] l) \n{\n  long result;\n  long pos;\n  foreach(l,\
    \ x;\n    pos += x;\n  )\n  result =  cast(long) pos;\n  return result;\n}\n/*\n\
    Return the largest number in the array.\n    >>> max([-1L, 2L, -4L, 5L, 6L])\n\
    \    6L\n    >>> max([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n   \
    \ 123L\n*/\nlong max(long[] l)", "{\n    long[] a;\n    foreach(n; l)\n    {\n\
    \        if(n > 0)\n        {\n            a ~= n;\n        }\n    }\n    return\
    \ a;\n}\n/*\nReturn a new array with no negative numbers.\n    >>> filter_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [2L, 5L, 6L]\n    >>> filter_negative([5L, 3L, -5L, 2L,\
    \ -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, 2L, 3L, 9L, 0L, 123L, 1L]\n\
    */\nlong[] filter_negative(long[] l) \n{\n    long[] a;\n    foreach(n; l)\n \
    \   {\n        if(n > 0)\n        {\n            a ~= n;\n        }\n    }\n \
    \   return a;\n}\n/*\nReturn a new array containing the absolute value of each\
    \ number.\n    >>> abs_all([-1L, 2L, -4L, 5L, 6L])\n    [1L, 2L, 4L, 5L, 6L]\n\
    \    >>> abs_all([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, 10L]\n*/\nlong[] abs_all(long[] l) \n\
    {\n    long[] a;\n    foreach(n; l)\n    {\n        a ~= abs(n);\n    }\n    return\
    \ a;\n}\n/*\nReturn the number of items in the input list that are not equal to\
    \ zero.\n    >>> count_nonzero([-1L, 2L, -4L, 5L, 6L])\n    4\n    >>> count_nonzero([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10", "{\n    return l.filter!(x =>\
    \ x > 0L);\n}", "{\n    /*\n    cast(long[])filter!(a => a >= 0L)(l);\n    */\n\
    \    auto p = filter!(a => a >= 0L)(l);\n    return cast(long[])p;\n}", "{\n \
    \   long[] res = {};\n    foreach(long i; l) \n    {\n        if (i > 0) \n  \
    \      {\n            res ~= i;\n        }\n    }\n    return res;\n}", "{\n \
    \ long[] g;\n  foreach(ll; l)\n    if(ll>0)\n    {\n      g ~= ll;\n    }\n  return\
    \ g;\n}", "{ \n   long[] res;\n   foreach(el; l)\n      if(el > 0)\n         res\
    \ ~= el;\n   return res;\n}", "{\n\tlong[] ret;\n\tforeach(long x; l) {\n\t\t\
    if (x > 0)\n\t\t\tret ~= x;\n\t}\n\treturn ret;\n}", "{\n    long[] r = new long[0];\n\
    \    int i = 0;\n    while (i < l.length)\n    {\n        if (l[i] >= 0)\n   \
    \     {\n            long[] t = new long[r.length + 1];\n            t[0..r.length]\
    \ = r;\n            t[r.length] = l[i];\n            r = t;\n        }\n     \
    \   i++;\n    }\n    return r;\n}\n/*\n Return only the negative numbers in the\
    \ array.\n    >>> get_negative([-1L, 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>>\
    \ get_negative([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L,\
    \ -3L, -10L]\n    \n*/\nlong[] get_negative(long[] l) \n{\n    long[] r = new\
    \ long[0];\n    int i = 0;\n    while (i < l.length)\n    {\n        if (l[i]\
    \ < 0)\n        {\n            long[] t = new long[r.length + 1];\n          \
    \  t[0..r.length] = r;\n            t[r.length] = l[i];\n            r = t;\n\
    \        }\n        i++;\n    }\n    return r;\n}\n/*\n Return the average of\
    \ only the negative numbers in the array.\n    >>> average_negative([-1L, 2L,\
    \ -4L, 5L, 6L])\n    -2.5\n    >>> average_negative([5L, 3L, -5L, 2L, -3L, 3L,\
    \ 9L, 0L, 123L, 1L, -10L])\n    -4.333333333333333\n    \n*/\ndouble average_negative(long[]\
    \ l) \n{\n    long sum = 0;\n    int count = 0;\n    int i = 0;\n    while (i\
    \ < l.length)\n    {\n        if (l[i] < 0)\n        {\n            sum += l[i];\n",
  "{\n    long[] result = {};\n    long length = cast(long) l.length;\n    foreach(index,\
    \ element; l)\n    {\n        if(element > 0)\n        {\n            result ~=\
    \ element;\n        }\n    }\n    return result;\n}", "{\n    long[] res;\n  \
    \  foreach(i; l) \n    {\n        if (i > 0) \n        {\n            res ~= i;\n\
    \        }\n    }\n    return res;\n}", "{\n    long[] ret = new long[l.length];\n\
    \    int n = 0;\n    for (int i = 0; i < l.length; i++)\n    {\n        if (l[i]\
    \ > 0)\n        {\n            ret[n] = l[i];\n            n++;\n        }\n \
    \   }\n    ret.length = n;\n    return ret;\n}", "{\n  l = filter!(a => a > 0L)(l);\n\
    \  return l;\n}", "{\n  long[] res = new long[0];\n  foreach(long i; l) \n  {\n\
    \    if (i > 0)\n      res ~= i;\n  }\n  return res;\n}", "{\n    long[] result\
    \ = new long[l.length];\n    int j = 0;\n    for (int i = 0; i < l.length; i++)\
    \ \n    {\n        if (l[i] > 0) \n        {\n            result[j] = l[i];\n\
    \            j++;\n        }\n    }\n    return result[0..j];\n}", "{\n    \n\
    \    long[] l2 = new long[0];\n    int n = 0;\n    foreach(p; l) \n    {\n   \
    \     if (p >= 0) \n        {\n            n++;\n            l2 ~= p;\n      \
    \  }\n    }\n    return l2;\n}", "{\n    long[] res = {};\n    foreach(e; l)\n\
    \    {\n        if(e > 0)\n        {\n            res ~= e;\n        }\n    }\n\
    \    return res;\n}", "{\n    long[] a;\n    int i;\n    foreach(l; e; idx)\n\
    \    {\n        if(e>0)\n        {\n            a~=e;\n        }\n    }\n    return\
    \ a;\n}", "{\n    long[] ret = new long[0];\n    foreach(long i; l) {\n      \
    \  if (i > 0)\n            ret ~= i;\n    }\n    return ret;\n}", "{\n    long[]\
    \ result = new long[l.length];\n    long count = 0;\n    foreach(long x; l)\n\
    \    {\n        if(x > 0)\n        {\n            result[count] = x;\n       \
    \     count++;\n        }\n    }\n    return result[0..count];\n}", "    {\n \
    \       return l.filter!(x => x > 0);\n    }", "{ \n    // --long[] l_ = new long[l.length];\n\
    \    long[] l_;\n    foreach(e; l) \n    {\n        if (e > 0) \n        {\n \
    \           l_ ~= e;\n        }\n    }\n    return l_;\n}", "{ \n    return l.filter!(a\
    \ => a > 0).array;\n}", "{\n    return l.filter!(x => x > 0);\n}", "    pure nothrow\
    \ @safe @nogc\n{\n    long[] positive;\n    foreach(ele; l)\n    {\n        if(ele\
    \ > 0)\n        {\n            positive ~= ele;\n        }\n    }\n    return\
    \ positive;\n}", "{\n    int i;\n    int len = l.length;\n    long[] temp = new\
    \ long[len];\n    int j = 0;\n    for (i = 0; i < len; i++)\n    {\n        if\
    \ (l[i] > 0)\n        {\n            temp[j] = l[i];\n            j++;\n     \
    \   }\n    }\n    return temp[0..j];\n}\n/*\nSort the array in ascending order.\n\
    \    >>> get_ordered([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n   \
    \ [-10L, -5L, -3L, 0L, 1L, 2L, 3L, 3L, 5L, 9L, 123L]\n*/\nlong[] get_ordered(long[]\
    \ l) \n{\n    long[] temp = new long[l.length];\n    int i;\n    int len = l.length;\n\
    \    for (i = 0; i < len; i++)\n    {\n        temp[i] = l[i];\n    }\n    std.sort(temp);\n\
    \    return temp;\n}\n/*\nReturn a unique array, removing all duplicate values.\n\
    \    >>> get_unique([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [-10L,\
    \ -5L, -3L, 0L, 1L, 2L, 3L, 5L, 9L, 123L]\n*/\nlong[] get_unique(long[] l) \n\
    {\n    int i;\n    int j;\n    int len = l.length;\n    for (i = 0; i < len; i++)\n\
    \    {\n        for (j = i + 1; j < len; j++)\n        {\n            if (l[i]\
    \ == l[j])\n            {\n                l[j] = 0;\n            }\n        }\n\
    \    }\n    long[] temp = get_positive(l);\n    return get_ordered(temp);\n}\n\
    /*\nReturn the smallest non-negative number.\n    >>> get_", "{\n  long[] finalL;\n\
    \  long i = 0;\n  for (; i < l.length; i++) \n  {\n    if (l[i] > 0)\n    {\n\
    \      finalL ~= l[i];\n    }\n  }\n  return finalL;\n}", "{\n    return l.filter!(x\
    \ => x > 0L);\n}", "{\n    long[] temp;\n    //allocate the array of the right\
    \ size\n    size_t pos_num = 0;\n    foreach(elem; l)\n    {\n        if(elem\
    \ > 0)\n        {\n            pos_num++;\n        }\n    }\n    temp.length =\
    \ pos_num;\n    //iterate over the input and put positive numbers into the new\
    \ array\n    pos_num = 0;\n    foreach(elem; l)\n    {\n        if(elem > 0)\n\
    \        {\n            temp[pos_num] = elem;\n            pos_num++;\n      \
    \  }\n    }\n    return temp;\n}\n/*\na) Return only a part of the array, specified\
    \ by given indexes.\n    >>> slice_array([1L, 2L, 3L, 4L, 5L], 2L, 4L)\n    [3L,\
    \ 4L]\n    >>> slice_array([2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L], 5L, 8L)\n  \
    \  [6L, 7L, 8L]\n*/\nlong[] slice_array(long[] l, long start, long end)\n{\n \
    \   long[] temp;\n    //allocate the array of the right size\n    temp.length\
    \ = end - start;\n    //iterate over the input and put positive numbers into the\
    \ new array\n    foreach(elem; l)\n    {\n        if(elem >= start && elem < end)\n\
    \        {\n            temp[elem - start] = elem;\n        }\n    }\n    return\
    \ temp;\n}\n/*\nb) Return only a part of the array, specified by given indexes\
    \ (for negative indexes, count from the end of the array).\n    >>> slice_array_2([1L,\
    \ 2L, 3L, 4L, 5L], -2L, 4L)\n    [3L, 4L]\n    >>> slice_array_2([1L, 2L, 3L,\
    \ 4L, 5L], -2L, -4L)\n    [4L]\n    >>> slice_array_2([2L, 3L, 4L, 5L", "{\n \
    \   return l.filter!(x => x > 0);\n}", "{\n    long[] t = {};\n    foreach(e;\
    \ l)\n    {\n        if(e > 0)\n        {\n            t ~= e;\n        }\n  \
    \  }\n    return t;\n}", "{\n    auto res = long[];\n    foreach(e; l)\n    {\n\
    \        if(e > 0)\n            res ~= e;\n    }\n    return res;\n}", "{\n  \
    \  auto list = l.filter!(a => a > 0);\n    return list.to!long[];\n}\n/*\n   \
    \ Return only negative numbers in the array.\n    >>> get_negative([-1L, 2L, -4L,\
    \ 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[] get_negative(long[] l)\
    \ \n{\n    auto list = l.filter!(a => a < 0);\n    return list.to!long[];\n}\n\
    /*\n    Return square roots of input array numbers.\n    >>> get_square_roots([4L,\
    \ 9L, 16L, 36L, 49L])\n    [2L, 3L, 4L, 6L, 7L]\n    >>> get_square_roots([49L,\
    \ 64L, 36L, 16L, 81L, 4L, 9L])\n    [7L, 8L, 6L, 4L, 9L, 2L, 3L]\n*/\nlong[] get_square_roots(long[]\
    \ l) \n{\n    auto list = l.map!(a => cast(long)sqrt(a));\n    return list.to!long[];\n\
    }\n/*\n    Return only the number which does not contains number 3.\n    >>> no_digit_3([31L,\
    \ 33L, 43L, 35L, 37L, 57L, 51L, 113L, 153L, 73L])\n    [57L, 51L]\n    >>> no_digit_3([31L,\
    \ 33L, 43L, 35L, 37L, 57L, 51L, 113L, 153L, 73L, 30L, 13L, 103L, 23L])\n    [57L,\
    \ 51L, 30L]\n*/\nlong[] no_digit_3(long[] l) \n{\n    auto list = l.filter!(a\
    \ => to!string(a).contains(\"3\"));\n    return list.to!long", "{\n    long[]\
    \ b = new long[0];\n    foreach(value; l)\n    {\n        if(value > 0)\n    \
    \    {\n            b ~= value;\n        }\n    }\n    return b;\n}\n/*\nReturn\
    \ the nth positive number.\n    >>> nth_positive([-1L, 2L, -4L, 5L, 6L], 3L)\n\
    \    5L\n    >>> nth_positive([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L],\
    \ 5L)\n    3L\n*/\nlong nth_positive(long[] l, long n) \n{\n    long[] b = new\
    \ long[0];\n    foreach(value; l)\n    {\n        if(value > 0)\n        {\n \
    \           b ~= value;\n        }\n    }\n    return b[n-1];\n}\n/*\nReturn a\
    \ sorted version of the array.\n    >>> sort_ascending([-1L, 2L, -4L, 5L, 6L])\n\
    \    [-4L, -1L, 2L, 5L, 6L]\n    >>> sort_ascending([5L, 3L, -5L, 2L, -3L, 3L,\
    \ 9L, 0L, 123L, 1L, -10L])\n    [-10L, -5L, -3L, 0L, 1L, 2L, 3L, 3L, 5L, 9L, 123L]\n\
    */\nlong[] sort_ascending(long[] l) \n{\n    return sort(l);\n}\n/*\nReturn the\
    \ range (highest value - lowest value) of the array.\n    >>> range([-1L, 2L,\
    \ -4L, 5L, 6L])\n    10L\n    >>> range([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L])\n    133L\n*/\nlong range(long[] l) \n{\n    return max(l) - min(l);\n\
    }\n/*\nReturn the number of elements", "{\n    long[] res;\n    foreach(idx, val;\
    \ l)\n    {\n        if(val > 0)\n        {\n            res ~= val;\n       \
    \ }\n    }\n    return res;\n}\n/*\nCapitalize the first letter of each word in\
    \ a string.\n    >>> capitalize(\"foo bar baz\")\n    \"Foo Bar Baz\"\n    >>>\
    \ capitalize(\"hello world\")\n    \"Hello World\"\n*/\nstring capitalize(string\
    \ s) \n{\n    string res;\n    foreach(idx, val; s)\n    {\n        if(idx ==\
    \ 0)\n        {\n            res ~= toupper(val);\n        }\n        else\n \
    \       {\n            res ~= tolower(val);\n        }\n    }\n    return res;\n\
    }\n/*\nCount the occurrences of each letter in a string.\n    >>> count_letters(\"\
    foo bar baz\")\n    ['f': 1, 'o': 3, ' ': 2, 'b': 2, 'a': 1, 'r': 1, 'z': 1]\n\
    \    >>> count_letters(\"hello world\")\n    ['h': 1, 'e': 1, 'l': 3, 'o': 2,\
    \ ' ': 1, 'w': 1, 'r': 1, 'd': 1]\n*/\nlong[char] count_letters(string s) \n{\n\
    \    long[char] res;\n    foreach(val; s)\n    {\n        res[val]++;\n    }\n\
    \    return res;\n}\n/*\nReturn true if a string is a palindrome, or false if\
    \ it is not.\n    >>> is_palindrome(\"foo\")\n    false\n    >>> is_palindrome(\"\
    racecar\")\n    true\n*/", "{\n    // TODO\n    auto s = l.filter!(a => a > 0)();\n\
    \    return s.array;\n}", "{\n\tlong[] res = new long[l.length];\n\tint j = 0;\n\
    \tforeach(i;l)\n\t{\n\t\tif(i > 0)\n\t\t{\n\t\t\tres[j] = i;\n\t\t\tj++;\n\t\t\
    }\n\t}\n\treturn res[0..j];\n}", "{\n    long[] new_l;\n    foreach(long i; l)\
    \ {\n        if (i > 0) new_l ~= i;\n    }\n    return new_l;\n}", "{\n    long[]\
    \ newList;\n    long[] newList1;\n    int i, j;\n    for (i = 0; i < l.length;\
    \ i++) \n    {\n        if (l[i] >= 0) \n        {\n            //we found a positive\
    \ number, next!\n            continue;\n        } \n        else \n        {\n\
    \            //we found a negative number, shift the rest of the list down\n \
    \           newList = new long[l.length - 1];\n            newList1 = new long[l.length\
    \ - 1];\n            for (j = 0; j < i; j++) \n            {\n               \
    \ newList[j] = l[j];\n            }\n            for (j = i; j < newList.length;\
    \ j++) \n            {\n                newList[j] = l[j + 1];\n            }\n\
    \            //next i, we will be checking this new list\n            i--;\n \
    \           l = newList;\n        }\n    }\n    return l;\n}\n/*\nRemove all instances\
    \ of a value from a list.\n    >>> remove_all(2L, [1L, 2L, 2L, 3L, 2L, 4L, 2L,\
    \ 5L])\n    [1L, 3L, 4L, 5L]\n*/\nlong[] remove_all(long value, long[] l) \n{\n\
    \    //remove all instances of a value from a list\n    long[] newList;\n    long[]\
    \ newList1;\n    int i, j;\n    for (i = 0; i < l.length; i++) \n    {\n     \
    \   if (l[i] != value) \n        {\n            //we found a non-matching number,\
    \ next!\n            continue;\n        } \n        else \n        {\n       \
    \     //we found a matching number, shift the rest of the list down\n        \
    \    newList = new long[l.length - 1];\n            newList1 = new long[l.length\
    \ - 1];\n            for (j = 0; j < i; j++) \n            {\n               \
    \ newList[j] = l[j];\n            }\n            for (j = i; j < newList.length;",
  "{\n    return \n        l.filter!(a => a > 0);\n}\n/*\n    Return only even numbers\
    \ in the array.\n    >>> get_even([-1L, 2L, -4L, 5L, 6L])\n    [2L, -4L, 6L]\n\
    \    >>> get_even([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [2L,\
    \ -4L, 6L]\n*/\nlong[] get_even(long[] l) \n{\n    return \n        l.filter!(a\
    \ => a % 2 == 0);\n}\n/*\n    Return only odd numbers in the array.\n    >>> get_odd([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, 5L]\n    >>> get_odd([5L, 3L, -5L, 2L, -3L, 3L,\
    \ 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, -5L, -3L, 3L, 9L, 123L, 1L, -10L]\n*/\n\
    long[] get_odd(long[] l) \n{\n    return \n        l.filter!(a => a % 2 != 0);\n\
    }\n/*\n    Return only prime numbers in the array.\n    >>> get_prime([-1L, 2L,\
    \ -4L, 5L, 6L])\n    [2L, 5L]\n    >>> get_prime([5L, 3L, -5L, 2L, -3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L])\n    [5L, 3L, 2L, 3L]\n*/\nlong[] get_prime(long[] l) \n\
    {\n    auto is_prime = (long n) {\n        if (n <= 1) return false;\n       \
    \ else if (n <= 3) return true;\n        else if (n % 2 == 0 || n % 3 == 0) return\
    \ false;\n        else {\n            foreach (d; 5 .. cast(int)", "{\n    auto\
    \ s = filter!(a => a > 0L)(l);\n    return to!(long[])(s);\n}\n/*", "{\n    long[]\
    \ res = new long[l.length];\n    int idx = 0;\n    foreach(idx2, val; l) {\n \
    \       if (val > 0) {\n            res[idx] = val;\n            idx++;\n    \
    \    }\n    }\n    return res[0..idx];\n}\n/*\nReturn only positive numbers in\
    \ the array.\n    >>> get_positive_vectors([-1L, 2L, -4L, 5L, 6L])\n    [2L, 5L,\
    \ 6L]\n    >>> get_positive_vectors([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L,\
    \ -10L])\n    [5L, 3L, 2L, 3L, 9L, 123L, 1L]\n    \n*/\nlong[] get_positive_vectors(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    int idx = 0;\n    foreach(val;\
    \ l) {\n        if (val > 0) {\n            res[idx] = val;\n            idx++;\n\
    \        }\n    }\n    return res[0..idx];\n}\n/*\nReturn only positive numbers\
    \ in the array.\n    >>> get_positive_gather([-1L, 2L, -4L, 5L, 6L])\n    [2L,\
    \ 5L, 6L]\n    >>> get_positive_gather([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L])\n    [5L, 3L, 2L, 3L, 9L, 123L, 1L]\n    \n*/\nlong[] get_positive_gather(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    int idx = 0;\n    foreach(val;\
    \ l) {\n        if (val > 0) {\n            res[idx] = val;\n            idx++;\n\
    \        }\n    }\n    return res[0..idx];\n}\n/*\nReturn only", "{\n    return\
    \ l.filter!(x => x > 0L);\n}", "{\n\tint l1 = l.length;\n\tauto nl = new long[];\n\
    \tforeach(i;0..l1)\n\t{\n\t\tif(l[i]>0)\n\t\t{\n\t\t\tnl ~= l[i];\n\t\t}\n\t}\n\
    \treturn nl;\n}", "{\n    return l.filter!(a => a >= 0)();\n}\n/*\nReturn only\
    \ negative numbers in the array.\n    >>> get_negative([-1L, 2L, -4L, 5L, 6L])\n\
    \    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[] get_negative(long[] l) \n{\n  \
    \  return l.filter!(a => a < 0)();\n}\n/*\nReturn a new array with only the odd\
    \ numbers from the given array.\n    >>> get_odds([1L, 2L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L, 10L])\n    [1L, 3L, 5L, 7L, 9L]\n    >>> get_odds([2L, 4L, 6L, 8L, 10L])\n\
    \    []\n*/\nlong[] get_odds(long[] l) \n{\n    return l.filter!(a => a % 2 ==\
    \ 1)();\n}\n/*\nReturn a new array with only the even numbers from the given array.\n\
    \    >>> get_evens([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n    [2L, 4L, 6L,\
    \ 8L, 10L]\n    >>> get_evens([2L, 4L, 6L, 8L, 10L])\n    [2L, 4L, 6L, 8L, 10L]\n\
    */\nlong[] get_evens(long[] l) \n{\n    return l.filter!(a => a % 2 == 0)();\n\
    }\n/*\nSum all the elements in the array.\n    >>> sum_list([1L, 2L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L, 10L])\n    55L\n    >>> sum_list([-1L, 2L, -4L, 5L,", "{\n\t\
    long[] a;\n\ta.length = 0;\n\tforeach(int i, long m; l)\n\t{\n\t\tif(m > 0)\n\t\
    \t{\n\t\t\ta.length++;\n\t\t\ta[a.length-1] = m;\n\t\t}\n\t}\n\treturn a;\n}",
  "{\n\tforeach(x; l)\n\t{\n\t\tif(x < 0)\n\t\t{\n\t\t\tl.remove(x);\n\t\t}\n\t}\n\
    \treturn l;\n}\n/*\nAssign to each element of the array its square root.\n   \
    \ >>> get_sqrt([0L, 1L, 4L, 9L, 16L, 25L, 36L, 49L, 64L, 81L, 100L])\n    [0L,\
    \ 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L]\n*/\nlong[] get_sqrt(long[] l) \n{\n\
    \tint i = 0;\n\tforeach(x; l)\n\t{\n\t\tl[i] = sqrt(x);\n\t\ti++;\n\t}\n\treturn\
    \ l;\n}\n/*\nDetermine the average of array elements.\n    >>> get_average([1.0,\
    \ 3.0, 5.0, 6.0, 8.0, 9.0])\n    5.0\n*/\ndouble get_average(double[] l) \n{\n\
    \tdouble avg = 0;\n\tforeach(x; l)\n\t{\n\t\tavg += x;\n\t}\n\tavg /= l.length;\n\
    \treturn avg;\n}\n/*\nReturn in reverse order.\n    >>> get_reverse([1L, 2L, 3L,\
    \ 4L, 5L])\n    [5L, 4L, 3L, 2L, 1L]\n*/\nlong[] get_reverse(long[] l) \n{\n\t\
    return l.reverse();\n}\n/*\nReturn the difference between the maximum and minimum.\n\
    \    >>> get_difference([-5L, 2L, -4L, 6L, 3L, 8L, 12L, -9L, 0L, 1L])\n    21L\n\
    */\nlong get_difference(long[] l) \n{\n\treturn l.max - l.min;\n}\n/*\nReturn\
    \ the first element that is greater than the average.\n    >>> get_first_above_average([1L,\
    \ 2L, 4L, 4L", "{\n    return l.filter!(e => e > 0)();\n}", "    pure nothrow\
    \ {\n    long[] result;\n    foreach(index, value; l) {\n        if (value > 0)\
    \ {\n            result ~= value;\n        }\n    }\n    return result;\n}", "{\n\
    \    /*\n    l = filter!(a => a > 0)(l);\n    */\n    long[] l_res = [];\n   \
    \ foreach(i;l) \n    {\n        if(i > 0) \n        {\n            l_res ~= i;\n\
    \        }\n    }\n    return l_res;\n}", "{\n  return filter!(x => x > 0)(l);\n\
    }", "{ \n  auto ret = filter!(a => a > 0)(l);\n  return ret.array;\n}\n/*\nReturn\
    \ only positive numbers in the array.\n    >>> get_positive([-1, 2, -4, 5, 6])\n\
    \    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    \    [5, 3, 2, 3, 9, 123, 1]\n    \n*/", "{\n    long[] result;\n    foreach(a;\
    \ l)\n    {\n        if(a > 0)\n        {\n            result ~= a;\n        }\n\
    \    }\n    return result;\n}\n/*\n    Return a vector of indexes of consecutive\
    \ negative numbers in the array.\n    >>> get_negative_indexes([3L, -1L, -2L,\
    \ -3L, 0L, 2L, 1L, -1L, -1L, -1L, 5L, -1L, 6L, -1L, -1L, 9L, -1L, -1L, -1L, 8L])\n\
    \    [1, 2, 3, 8, 10, 13, 15, 19]\n    >>> get_negative_indexes([1L, -1L, 2L,\
    \ -1L, 4L, -1L, 6L, -1L, 8L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L,\
    \ -1L])\n    [1, 3, 5, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n*/\nlong[]\
    \ get_negative_indexes(long[] l) \n{\n    long[] result;\n    long last_index\
    \ = 0;\n    foreach(i, a; l)\n    {\n        if(a < 0)\n        {\n          \
    \  if(last_index == 0)\n            {\n                result ~= i;\n        \
    \    }\n            else\n            {\n                if(i != last_index +\
    \ 1)\n                {\n                    result ~= i;\n                }\n\
    \            }\n            last_index = i;\n        }\n    }\n    return result;\n\
    }\n/*\n    Return a vector of indexes of positive numbers in the array.\n    >>>\
    \ get_positive_indexes([-1L, 2L, -4L, 5L, 6L])\n    [1, 3, 4]\n    >>> get_positive_indexes([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L,", "{\n    long[] tmp;\n    foreach(l; e; int i)\
    \ \n    {\n        if (e > 0) \n        {\n            tmp ~= e;\n        }\n\
    \    }\n    return tmp;\n}\n/*\nGather all even numbers in the array.\n    >>>\
    \ get_even([-1L, 2L, -4L, 5L, 6L])\n    [2L, -4L, 6L]\n    >>> get_even([5L, 3L,\
    \ -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [2L, 0L, -10L]\n*/\nlong[] get_even(long[]\
    \ l) \n{\n    long[] tmp;\n    foreach(l; e; int i) \n    {\n        if (e % 2\
    \ == 0) \n        {\n            tmp ~= e;\n        }\n    }\n    return tmp;\n\
    }\n/*\nReturn all the odd numbers in the array.\n    >>> get_odd([-1L, 2L, -4L,\
    \ 5L, 6L])\n    [-1L, 5L]\n    >>> get_odd([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L])\n    [5L, 3L, -5L, -3L, 3L, 9L, 123L, 1L]\n*/\nlong[] get_odd(long[]\
    \ l) \n{\n    long[] tmp;\n    foreach(l; e; int i) \n    {\n        if (e % 2\
    \ != 0) \n        {\n            tmp ~= e;\n        }\n    }\n    return tmp;\n\
    }\n/*\nCompute the average of all numbers in the array.\n    >>> get_average([-1L,\
    \ 2L, -4L, 5L, 6L])\n    0.8\n    >>> get_average([5L, 3L, -5L, 2L, -3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L])\n    19.", "{\n\tint len = l.length;\n\tlong[] ret;\n\t\
    foreach(l; e => e > 0)\n\t{\n\t\tret ~= e;\n\t}\n\treturn ret;\n}\n/*\nFind the\
    \ most common element in the array.\n    >>> get_most_common([3L, 7L, 1L, 1L,\
    \ 1L, 7L, 3L, 3L, 2L, 6L, 7L, 6L, 2L, 7L, 6L, 4L, 2L, 1L, 7L, 6L, 2L, 4L, 5L,\
    \ 2L, 2L, 6L, 7L, 6L, 2L, 7L, 6L, 4L, 2L, 1L, 7L, 6L, 2L, 4L, 5L, 2L, 2L, 6L,\
    \ 7L, 6L, 2L, 7L, 6L, 4L, 2L, 1L, 7L, 6L, 2L, 4L, 5L, 2L, 2L, 6L, 7L, 6L, 2L,\
    \ 7L, 6L, 4L, 2L, 1L, 7L, 6L, 2L, 4L, 5L, 2L, 2L, 6L, 7L, 6L, 2L, 7L, 6L, 4L,\
    \ 2L, 1L, 7L, 6L, 2L, 4L, 5L, 2L, 2L, 6L, 7L, 6L, 2L, 7L, 6L, 4L, 2L, 1L, 7L,\
    \ 6L, 2L, 4L, 5L, 2L, 2L, 6L, 7L, 6L, 2L, 7L, 6L, 4L, 2L, 1L, 7L, 6L, 2L, 4L,\
    \ 5L, 2L, 2L, 6L, 7L, 6L, 2L, 7L, 6L, 4L, 2L, 1L, 7L, 6L, 2L, 4L, 5L, 2L, 2L,\
    \ 6L, 7L, 6L, 2L, 7L, 6L, 4L, 2L, 1L, 7L", "{\n    long[] positive = new long[0];\n\
    \    foreach(long i; l)\n    {\n        if(i > 0)\n        {\n            positive\
    \ ~= i;\n        }\n    }\n    return positive;\n}", "{\n    long[] temp;", "{\n\
    \    long[] pos = [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 123L];\n    long[] pos_test\
    \ = [];\n    foreach(l;i)\n    {\n        if(l[i] > 0)\n        {\n          \
    \  pos_test ~= l[i];\n        }\n    }\n    assert(pos_test == pos);\n    return\
    \ pos_test;\n}", "{\n    long[] result;\n    foreach(value; l) \n    {\n     \
    \   if (value > 0) \n        {\n            result ~= value;\n        }\n    }\n\
    \    return result;\n}\n ", "{\n    return filter!((x) => x > 0)(l);\n}", "{\n\
    \    long[] ret;\n    ret[] = new long[l.length];\n    int j = 0;\n    foreach(i;\
    \ l)\n    {\n        if(i > 0)\n        {\n            ret[j] = i;\n         \
    \   j++;\n        }\n    }\n    ret.length = j;\n    return ret;\n}", "{\n\tlong[]\
    \ result = new long[0];\n\tfor (long element : l)\n\t{\n\t\tif (element > 0)\n\
    \t\t{\n\t\t\tresult ~= element;\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tint i\
    \ = 0;\n\tlong[] r = new long[0];\n\tforeach(var item; l) \n\t{\n\t\tif(item >\
    \ 0) {\n\t\t\tr ~= item;\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only even numbers\
    \ in the array.\n    >>> get_even([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n\
    \    [2L, 4L, 6L, 8L, 10L]\n    >>> get_even([1L, 0L, -2L, 3L, 5L, 7L, 9L, 11L,\
    \ 11L, 1L, -12L])\n    [0L, -2L, 10L, -12L]\n*/\nlong[] get_even(long[] l) \n\
    {\n\tint i = 0;\n\tlong[] r = new long[0];\n\tforeach(var item; l) \n\t{\n\t\t\
    if(item % 2 == 0) {\n\t\t\tr ~= item;\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn\
    \ only uneven numbers in the array.\n    >>> get_uneven([2L, 4L, 6L, 8L, 10L])\n\
    \    [1L, 3L, 5L, 7L, 9L]\n    >>> get_uneven([1L, 2L, 3L, 0L, 1L, 2L, 3L, 1L,\
    \ -1L, -3L, -5L, -7L, -9L])\n    [1L, 3L, 1L, 3L, 1L, -1L, -3L, -5L, -7L, -9L]\n\
    \    \n*/\nlong[] get_uneven(long[] l) \n{\n\tint i = 0;\n\tlong[] r = new long[0];\n\
    \tforeach(var item; l) \n\t{\n\t\tif(item % 2 != 0) {\n\t\t\tr ~= item;\n\t\t\
    }\n\t}\n\treturn r;\n}\n/*\nReturn the sum of all numbers", "{\n    // TODO: implement\n\
    }\nassert(equal(get_positive([-1L, 2L, -4L, 5L, 6L]), [2L, 5L, 6L]));\nassert(equal(get_positive([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L]), [5L, 3L, 2L, 3L, 9L, 123L, 1L]));",
  "{ \n    long[] l2 = new long[0];\n    foreach(i; l)\n    {\n        if(i>0) l2\
    \ ~= i;\n    }\n    return l2;\n}", "{\n    long[] b; \n    b.length = 0;\n  \
    \  foreach(i; l) \n    {\n        if (i > 0) \n        {\n            b ~= i;\n\
    \        }\n    }\n    return b;\n}", "{\n    return filter!(p => p > 0L)(l);\n\
    }", "{ \n    // int s = l.length;\n    long[] temp;\n    temp[] = new long[];\n\
    \    foreach(i; l)\n    {\n        if(i > 0)\n        {\n            temp ~= i;\n\
    \        }\n    }\n    return temp;\n}\n/*\nGet only the odd numbers from the\
    \ array.\n    >>> get_odds([0L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L])\n    [1L,\
    \ 3L, 5L, 7L, 9L]\n    >>> get_odds([0L, 1L, -2L, 3L, -4L, 5L, -6L, 7L, -8L, 9L])\n\
    \    [1L, 3L, 5L, 7L, 9L]\n*/\nlong[] get_odds(long[] l) \n{ \n    // int s =\
    \ l.length;\n    long[] temp;\n    temp[] = new long[];\n    foreach(i; l)\n \
    \   {\n        if(i % 2 == 1)\n        {\n            temp ~= i;\n        }\n\
    \    }\n    return temp;\n}\n/*\nReturn only the first n elements of the array.\n\
    \    >>> head([1L, 2L, 3L, 4L, 5L], 3L)\n    [1L, 2L, 3L]\n    >>> head([1L, 2L,\
    \ 3L, 4L, 5L], 2L)\n    [1L, 2L]\n*/\nlong[] head(long[] l, long n) \n{ \n   \
    \ // int s = l.length;\n    long[] temp;\n    temp[] = new long[];\n    if(n <=\
    \ l.length)\n    {\n        foreach(i; 0..n)\n        {\n            temp ~= l[i];\n\
    \        }\n    }\n    else\n    {\n        foreach(i; 0..l.length)\n        {\n\
    \            temp ~= l[i];\n        }\n    }\n    return temp;\n}\n/*\nReturn\
    \ only the last n elements of the array.\n    >>>", "    long[] output = new long[0];\n\
    \    foreach(i; l) {\n        if (i > 0) {\n            output ~= i;\n       \
    \ }\n    }\n    return output;\n}", "{\n    auto r = long[];\n    foreach(i; l)\n\
    \    {\n        if(i>0)\n            r ~= i;\n    }\n    return r;\n}\n/*\nReturn\
    \ only negative numbers in the array.\n    >>> get_negative([-1L, 2L, -4L, 5L,\
    \ 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[] get_negative(long[] l) \n\
    {\n    auto r = long[];\n    foreach(i; l)\n    {\n        if(i<0)\n         \
    \   r ~= i;\n    }\n    return r;\n}\n/*\nGet absolute values of the array.\n\
    \    >>> get_abs([-1L, 2L, -4L, 5L, 6L])\n    [1L, 2L, 4L, 5L, 6L]\n    >>> get_abs([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L, 1L, 10L]\n*/\nlong[] get_abs(long[] l) \n{\n    auto r = long[];\n\
    \    foreach(i; l)\n    {\n        r ~= abs(i);\n    }\n    return r;\n}\n/*\n\
    Get the maximum of the array.\n    >>> get_max([-1L, 2L, -4L, 5L, 6L])\n    6L\n\
    \    >>> get_max([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    123L\n\
    */\nlong get_max(long[] l) \n{\n    long r = l[0];\n    foreach(i;", "{\n\tlong[]\
    \ res = new long[l.length];\n\tint j = 0;\n\tforeach(int i; 0..l.length)\n\t{\n\
    \t\tif(l[i] > 0)\n\t\t{\n\t\t\tres[j] = l[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tres =\
    \ res[0..j];\n\treturn res;\n}", "{\n    return l.filter!(a => a > 0L);\n}", "{\n\
    \    return filter!((x) => x >= 0)(l);\n}\n/*\nReturn negative numbers in the\
    \ array.\n>>> get_negative([-1L, 2L, -4L, 5L, 6L])\n[-1L, -4L]\n>>> get_negative([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n[-5L, -3L, -10L]\n*/\nlong[]\
    \ get_negative(long[] l) \n{\n    return filter!((x) => x < 0)(l);\n}\n/*\nReturn\
    \ the sum of all numbers in the array.\n>>> sum_all([-1L, 2L, -4L, 5L, 6L])\n\
    8L\n>>> sum_all([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n160L\n*/\n\
    long sum_all(long[] l) \n{\n    return reduce!((a, b) => a + b)(l);\n}\n/*\nReturn\
    \ sum of positive numbers in the array.\n>>> sum_positive([-1L, 2L, -4L, 5L, 6L])\n\
    13L\n>>> sum_positive([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n137L\n\
    */\nlong sum_positive(long[] l) \n{\n    return reduce!((a, b) => a + b)(get_positive(l));\n\
    }\n/*\nReturn sum of negative numbers in the array.\n>>> sum_negative([-1L, 2L,\
    \ -4L, 5L, 6L])\n-5L\n>>> sum_negative([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L])\n-18L\n*/\nlong sum_negative(long[] l) \n{\n    return reduce!((a,\
    \ b) => a + b)(get_negative(l));\n", "{ \n    long[] temp = new long[l.length];\
    \ \n    int len = 0; \n    for (int i = 0; i < l.length; i++) \n    { \n     \
    \   if (l[i] > 0) \n        { \n            temp[len] = l[i]; \n            len++;\
    \ \n        } \n    } \n    l = temp; \n    return l; \n} ", "    {\n    auto\
    \ pos = filter!(x => x > 0)(l); \n    return pos.array;\n    }\n \nlong[] get_negative(long[]\
    \ l) \n    {\n    auto neg = filter!(x => x < 0)(l); \n    return neg.array;\n\
    \    }\n/*\nReturn a list of all numbers that occur more than once in the list.\n\
    \    >>> repeated([3L, 1L, 1L, 4L, 5L, 6L, 8L, 8L, 1L, 5L, 9L, 8L, 1L, 8L, 2L,\
    \ 3L, 3L, 4L, 9L, 6L, 6L, 3L, 2L, 7L, 4L, 5L, 9L, 2L, 5L, 4L, 2L, 7L, 4L, 5L,\
    \ 3L, 1L, 5L, 7L, 9L, 4L, 5L, 4L, 8L, 7L, 8L, 1L, 8L, 8L, 6L, 7L, 2L, 7L, 1L,\
    \ 5L, 9L, 8L, 1L, 3L, 2L, 7L, 4L, 5L, 9L, 2L, 5L, 4L, 2L, 7L, 4L, 5L, 9L, 2L,\
    \ 5L, 4L, 2L, 7L, 4L, 5L, 9L, 2L, 5L, 4L, 2L, 7L, 4L, 5L, 9L, 2L, 5L, 4L, 2L,\
    \ 7L, 4L, 5L, 9L, 2L, 5L, 4L, 2L, 7L, 4L, 5L, 9L, 2L, 5L, 4L, 2L, 7L, 4L, 5L,\
    \ 9L, 2L, 5L, 4L, 2L, 7L, 4L, 5L, 9L, 2L, 5L, 4L, 2L, 7L, 4L, 5L, 9L, 2L, 5L,\
    \ 4L, 2L, 7L, 4L, 5L, 9L, 2L, 5L, 4L, 2", "{ \n    return filter!(a => a > 0L)(l);\n\
    }", "{\n    return l.filter!(a => a > 0)();\n}", "{\n    long[] res;\n    auto\
    \ n = l.length;\n    foreach(e; l)\n    {\n        if(e > 0)\n        {\n    \
    \        res ~= e;\n        }\n    }\n    return res;\n}\n \n/*\nReturn only negative\
    \ numbers in the array.\n    >>> get_negative([-1L, 2L, -4L, 5L, 6L])\n    [-1L,\
    \ -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n\
    \    [-5L, -3L, -10L]\n    \n*/\nlong[] get_negative(long[] l) \n{\n    long[]\
    \ res;\n    auto n = l.length;\n    foreach(e; l)\n    {\n        if(e < 0)\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res;\n}\n \n/*\n\
    Given an array of longs, return the second largest number.\n    >>> second_largest([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    9L\n    >>> second_largest([1L,\
    \ 2L, -4L, 5L, 6L])\n    5L\n*/\nlong second_largest(long[] l) \n{\n    long[]\
    \ res;\n    auto n = l.length;\n    foreach(e; l)\n    {\n        if(e > 0)\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res[res.length\
    \ - 2];\n}\n \n/*\nGiven an array of longs, return the mean of all numbers.\n\
    \    >>> mean([1L, 2L, -4L, 5L, 6L])\n    2.6L\n    >>> mean([5L, 3L, -5L, 2L,\
    \ -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    8.090909090909091L\n", "{\n  return l.filter!(x\
    \ => x > 0)();\n}\n/*\nReturn only negative numbers in the array.\n    >>> get_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[] get_negative(long[]\
    \ l) \n{\n  return l.filter!(x => x < 0)();\n}\n/*\nReturn the sum of all positive\
    \ numbers in the array.\n    >>> get_positive_sum([-1L, 2L, -4L, 5L, 6L])\n  \
    \  13L\n    >>> get_positive_sum([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L,\
    \ -10L])\n    156L\n*/\nlong get_positive_sum(long[] l) \n{\n  long sum = 0;\n\
    \  foreach(i; 0 .. l.length)\n  {\n    if(l[i] > 0)\n    {\n      sum += l[i];\n\
    \    }\n  }\n  return sum;\n}\n/*\nReturn the sum of all negative numbers in the\
    \ array.\n    >>> get_negative_sum([-1L, 2L, -4L, 5L, 6L])\n    -5L\n    >>> get_negative_sum([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    -19L\n*/\nlong get_negative_sum(long[]\
    \ l) \n{\n  long sum = 0;\n  foreach(i; 0 .. l.length)\n  {\n    if(l[i] < 0)\n\
    \    {\n      sum += l[i];\n    }\n  }\n  return sum;\n}\n/*\nReturn the sum of\
    \ all numbers in the array.\n    >>> get_sum([", "{\n    int j = 0;\n    long[]\
    \ array2 = new long[l.length];\n    for (int i = 0; i < l.length; i++)\n    {\n\
    \        if (l[i] > 0)\n        {\n            array2[j] = l[i];\n           \
    \ j++;\n        }\n    }\n    return array2;\n}\n/*\nSum all the positive numbers\
    \ in the array.\n    >>> sum_positive([-1L, 2L, -4L, 5L, 6L])\n    13L\n    >>>\
    \ sum_positive([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    153L\n\
    \    >>> sum_positive([0L, 0L, 0L, 0L, 0L])\n    0L\n    >>> sum_positive([-1L,\
    \ -2L, -3L, -4L, -5L])\n    0L\n*/\nlong sum_positive(long[] l) \n{\n    long\
    \ sum = 0;\n    foreach (long x; l)\n    {\n        if (x > 0)\n        {\n  \
    \          sum += x;\n        }\n    }\n    return sum;\n}\n/*\nFind the largest\
    \ positive number in the array.\n    >>> max_positive([-1L, 2L, -4L, 5L, 6L])\n\
    \    6L\n    >>> max_positive([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n\
    \    123L\n    >>> max_positive([0L, 0L, 0L, 0L, 0L])\n    0L\n    >>> max_positive([-1L,\
    \ -2L, -3L, -4L, -5L])\n    0L\n*/\nlong max_positive(long[] l) \n{\n    long\
    \ max = 0;\n    foreach (long x; l)\n    {\n        if (x > max)\n        {\n\
    \            max = x;\n        }\n    }\n    return max;\n}\n/*\nReturn the sum\
    \ of", "{\n    long[] arr;\n    int i = 0;\n    foreach(x; l) \n    {\n      \
    \  if (x > 0) \n        {\n            i++;\n        }\n    }\n    arr = new long[i];\n\
    \    int j = 0;\n    foreach(x; l) \n    {\n        if (x > 0) \n        {\n \
    \           arr[j] = x;\n            j++;\n        }\n    }\n    return arr;\n\
    }", "{\n    return l.filter!(x => x > 0)();\n}\n/*\nReturn the sum of numbers\
    \ in the array\n    >>> sum_numbers([-1L, 2L, -4L, 5L, 6L])\n    9L\n    >>> sum_numbers([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    164L\n*/\nlong sum_numbers(long[]\
    \ l) \n{\n    return l.reduce!((x, y) => x + y)();\n}\n/*\nReturn the product\
    \ of numbers in the array\n    >>> multiply_numbers([-1L, 2L, -4L, 5L, 6L])\n\
    \    -240L\n    >>> multiply_numbers([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L])\n    -1710320L\n*/\nlong multiply_numbers(long[] l) \n{\n    return\
    \ l.reduce!((x, y) => x * y)();\n}\n/*\nReturn the sum of positive numbers in\
    \ the array\n    >>> sum_positive([-1L, 2L, -4L, 5L, 6L])\n    13L\n    >>> sum_positive([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    169L\n*/\nlong sum_positive(long[]\
    \ l) \n{\n    return get_positive(l).reduce!((x, y) => x + y)();\n}\n/*\nReturn\
    \ the product of positive numbers in the array\n    >>> multiply_positive([-1L,\
    \ 2L, -4L, 5L, 6L])\n    60L\n    >>> multiply_positive([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    945L\n*/\nlong multiply_positive(long[] l)\
    \ \n{\n    return get_positive(l).", "{\n    int size = 0;\n    foreach(num; l)\
    \ \n    {\n        if (num > 0) \n        {\n            size += 1;\n        }\n\
    \    }\n    long[] new_l = new long[];\n    resize(new_l, size);\n    size = 0;\n\
    \    foreach(num; l) \n    {\n        if (num > 0) \n        {\n            new_l[size]\
    \ = num;\n            size += 1;\n        }\n    }\n    return new_l;\n}\n/*\n\
    Count how many elements in the array are odd.\n    >>> count_odd([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n    5\n    >>> count_odd([-3L, -2L, -1L, 0L,\
    \ 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n    7\n    >>> count_odd([-3L, -5L,\
    \ -6L, -7L, -8L, -10L])\n    6\n*/", "{\n    int i;\n    int j;\n    auto r;\n\
    \    r = new long[];\n    j = 0;\n    foreach(i; l)\n    {\n        if (i > 0)\n\
    \        {\n            r ~= i;\n            j++;\n        }\n    }\n    return\
    \ r;\n}\n/*\nReturn only negative numbers in the array.\n    >>> get_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n    >>> get_negative([-5L,\
    \ -5L, -5L, -5L, -5L])\n    [-5L, -5L, -5L, -5L, -5L]\n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    int i;\n    int j;\n    auto r;\n    r = new long[];\n    j = 0;\n\
    \    foreach(i; l)\n    {\n        if (i < 0)\n        {\n            r ~= i;\n\
    \            j++;\n        }\n    }\n    return r;\n}\n/*\nReturn the sum of all\
    \ numbers in the array.\n    >>> sum_numbers([-1L, 2L, -4L, 5L, 6L])\n    9L\n\
    \    >>> sum_numbers([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n   \
    \ 146L\n    >>> sum_numbers([0L, 0L, 0L, 0L, 0L])\n    0L\n*/\nlong sum_numbers(long[]\
    \ l) \n{\n    int i;\n    int j;\n    auto r;\n    r = 0;\n    j = 0;\n    foreach(i;\
    \ l)\n    {\n        r += i;\n        j++;\n    }\n    return r;\n", "{ \n   \
    \ long[] ret = new long[0];\n    int i = 0;\n    foreach(long num; l) {\n    \
    \    if (num > 0) {\n            ret ~= num;\n        }\n    }\n    return ret;\n\
    }", "{\n\tlong length = l.length;\n\tlong[] a = new long[length];\n\tlong n =\
    \ 0;\n\tfor (long i = 0; i < length; i++) \n\t{\n\t\tif (l[i] > 0)\n\t\t{\n\t\t\
    \ta[n] = l[i];\n\t\t\tn = n + 1;\n\t\t}\n\t}\n\ta.length = n;\n\treturn a;\n}",
  "{\n    auto ret = std.array.empty!long[];\n    foreach(i; l) \n    {\n        if(i\
    \ > 0)\n            ret ~= i;\n    }\n    return ret;\n}\n/*\nFind a sum of the\
    \ array\n    >>> array_sum([1L, 2L, 3L, 4L, 5L])\n    15L\n    >>> array_sum([1L,\
    \ 4L, 4L, 5L, 6L, 7L, 5L, 1L, 9L, 0L, -5L, 5L, 6L, 9L, 4L, -3L, 5L, 8L, 2L, -2L,\
    \ 7L, 5L, 3L, -1L, 0L, -1L, 6L, 3L, 6L, 2L, 7L, 5L, 4L, -4L, 4L, 7L, 5L, -4L,\
    \ 5L, 3L, -2L, 6L, -1L, 6L, 4L, 7L, 6L, -4L, 8L, -2L, 8L, 8L, 8L, 4L, -1L, 5L,\
    \ 6L, 3L, 6L, 4L, 7L, 6L, -4L, 8L, -2L, 8L, 8L, 8L, 4L, -1L, 5L, 6L, 3L, 6L, 4L,\
    \ 7L, 6L, -4L, 8L, -2L, 8L, 8L, 8L, 4L, -1L, 5L, 6L, 3L, 6L, 4L, 7L, 6L, -4L,\
    \ 8L, -2L, 8L, 8L, 8L, 4L, -1L, 5L, 6L, 3L, 6L, 4L, 7L, 6L, -4L, 8L, -2L, 8L,\
    \ 8L, 8L, 4L, -1L, 5L, 6L, 3L, 6L, 4L, 7L, 6L, -4L, 8L, -2L, 8L, 8L, 8L, 4L, -1L",
  "{\n    long[] pos;\n    foreach(e; l) \n    {\n        if (e > 0)\n           \
    \ pos ~= e;\n    }\n    return pos;\n}", "{ \n    auto dl = new long[];\n    int\
    \ i = 0;\n    while (i < l.length) \n    {\n        if (l[i] > 0)\n        {\n\
    \            dl ~= l[i];\n        }\n        i++;\n    }\n    return dl;\n}",
  "{\n    long[] out = {};\n    foreach(l; i)\n    {\n        if(i > 0)\n        {\n\
    \            out ~= i;\n        }\n    }\n    return out;\n}", "{\n    return\
    \ l.filter!(x => x > 0);\n}", "{\n    long[] res = new long[l.length];\n    long\
    \ i = 0;\n    foreach(x; l) {\n        if (x > 0) {\n            res[i] = x;\n\
    \            i++;\n        }\n    }\n    return res[0..i];\n}", "{\n    long[]\
    \ xs = new long[];\n    foreach(index, e; l) \n    {\n        if (e > 0) \n  \
    \      {\n            xs ~= e;\n        }\n    }\n    return xs;\n}\n/*\nThis\
    \ function must be called with the name of a function,\nwhich takes a single long\
    \ parameter and returns a long.\nThe name may be fully qualified, but you cannot\
    \ use an alias.\n    >>> run(Math.pow, 2L, 4L)\n    16L\n    >>> run(Math.abs,\
    \ -3L)\n    3L\n    >>> run((long x) => x + 1L, 1L)\n    2L\n*/\nlong run(alias\
    \ func, long l)\n{\n    auto f = function(func);\n    return f(l);\n}", "{\n \
    \   auto positives = [];\n    foreach(li; l)\n    {\n        if(li > 0)\n    \
    \    {\n            positives ~= li;\n        }\n    }\n    return positives;\n\
    }\n/*\nReturn only negative numbers in the array.\n    >>> get_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    auto negatives = [];\n    foreach(li; l)\n    {\n        if(li <\
    \ 0)\n        {\n            negatives ~= li;\n        }\n    }\n    return negatives;\n\
    }\n/*", "{\n    return l.filter!(x => x > 0L);\n}", "{\n    auto ret = l.filter!(x\
    \ => x >= 0L)();\n    return ret;\n}", "{\n    int c = 0;\n    foreach(long i;\
    \ l)\n        if(i > 0)\n            c++;\n    int p = 0;\n    long[] result =\
    \ new long[c];\n    foreach(long i; l)\n        if(i > 0)\n            result[p++]\
    \ = i;\n    return result;\n}", "{ \n    long[] result;\n    foreach(x; l)\n \
    \   {\n        if(x > 0) \n        {\n            result ~= x;\n        }\n  \
    \  }\n    return result;\n}", "{\n    long[] result;\n    foreach(ele; l) \n \
    \   {\n        if(ele > 0) result ~= ele;\n    }\n    return result;\n}\n/*\n\
    Return only positive numbers in the array.\n    >>> get_positive([-1L, 2L, -4L,\
    \ 5L, 6L])\n    [2L, 5L, 6L]\n    >>> get_positive([5L, 3L, -5L, 2L, -3L, 3L,\
    \ 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, 2L, 3L, 9L, 123L, 1L]\n    \n*/\nlong[]\
    \ get_positive2(long[] l) \n{\n    return l.filter!(l => l > 0);\n}", "{\n   \
    \ auto result = [];\n    foreach(e; l) \n    {\n        if (e > 0)\n         \
    \   result ~= e;\n    }\n    return result;\n}", "{\n    return l.filter!(x =>\
    \ x > 0);\n}", "{\n\tint l_len= l.length;\n\tint[] pos_pos=new int[l_len];\n\t\
    int count=0;\n\tfor(int i=0;i<l_len;i++)\n\t{\n\t\tif(l[i]>0)\n\t\t{\n\t\t\tpos_pos[count]=i;\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\tlong[] positives=new long[count];\n\tfor(int i=0;i<count;i++)\n\
    \t{\n\t\tpositives[i]=l[pos_pos[i]];\n\t}\n\treturn positives;\n}", "{\n    return\
    \ l.filter!(x => x > 0L)();\n}", "{ \n    return l.filter!(a => a > 0);\n}", "{\n\
    \    long[] result = null;\n    int count = 0;\n    foreach(var i; l)\n    {\n\
    \        if(i > 0)\n        {\n            result ~= i;\n            count++;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn only even numbers in the\
    \ array.\n    >>> get_even([-1L, 2L, -4L, 5L, 6L])\n    [2L, -4L, 6L]\n    >>>\
    \ get_even([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [2L, -4L,\
    \ 0L, -10L]\n*/\nlong[] get_even(long[] l) \n{\n    long[] result = null;\n  \
    \  int count = 0;\n    foreach(var i; l)\n    {\n        if(i % 2 == 0)\n    \
    \    {\n            result ~= i;\n            count++;\n        }\n    }\n   \
    \ return result;\n}\n/*\nReturn only odd numbers in the array.\n    >>> get_odd([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, 5L]\n    >>> get_odd([5L, 3L, -5L, 2L, -3L, 3L,\
    \ 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, -5L, -3L, 3L, 9L, 123L, 1L]\n*/\nlong[]\
    \ get_odd(long[] l) \n{\n    long[] result = null;\n    int count = 0;\n    foreach(var\
    \ i; l)\n    {\n        if(i % 2 != 0)\n        {\n            result ~= i;\n\
    \            count++;\n        }\n    }\n    return result;\n}\n/*\nReturn a list\
    \ of divisors.\n    >>> get_divisors(12L)\n    [1L, 2L, 3L, 4L, 6L, 12L]\n   \
    \ >>> get_divisors(60L)\n    [1L", "{\n    long[] result = new long[0];\n    foreach(val;\
    \ l) {\n        if (val > 0)\n            result ~= val;\n    }\n    return result;\n\
    }\n \n/*\nReturn only odd numbers in the array.\n    >>> get_odd([-1L, 2L, -4L,\
    \ 5L, 6L])\n    [-1L, 5L]\n    >>> get_odd([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L])\n    [5L, 3L, -5L, -3L, 3L, 9L, 123L, 1L, -10L]\n*/\nlong[]\
    \ get_odd(long[] l) \n{\n    long[] result = new long[0];\n    foreach(val; l)\
    \ {\n        if (val % 2 != 0)\n            result ~= val;\n    }\n    return\
    \ result;\n}\n \n/*\nReturn only palindromes in the array.\n    >>> get_palindromes([\"\
    abc\", \"Abc\", \"cde\", \"aba\", \"Aba\", \"CDE\"])\n    [\"aba\", \"Aba\"]\n\
    \    >>> get_palindromes([\"abc\", \"Abc\", \"cde\", \"aba\", \"Aba\", \"CDE\"\
    , \"asdDsa\", \"dsaASD\", \"SDAasd\"])\n    [\"aba\", \"Aba\", \"asdDsa\", \"\
    dsaASD\", \"SDAasd\"]\n*/\nstring[] get_palindromes(string[] l) \n{\n    string[]\
    \ result = new string[0];\n    foreach(val; l) {\n        if (val.toLower() ==\
    \ val.toLower().dup.rev)\n            result ~= val;\n    }\n    return result;\n\
    }\n \n/*\nReturn only names starting with letter.\n    >>> get_with_letter([\"\
    abc\", \"Abc\", \"cde\", \"aba\", \"Aba\", \"CDE\"], \"A\")\n    [\"Abc\", \"\
    Aba\"]\n    >>> get_with_letter([\"", "{ \n    int counter = 0;\n    for (int\
    \ i = 0; i < l.length; i++)\n    {\n        if (l[i] > 0)\n        {\n       \
    \     counter++;\n        }\n    }\n    long[] new_array = new long[counter];\n\
    \    counter = 0;\n    for (int i = 0; i < l.length; i++)\n    {\n        if (l[i]\
    \ > 0)\n        {\n            new_array[counter] = l[i];\n            counter++;\n\
    \        }\n    }\n    return new_array;\n}", "{\n    long[] result;\n    auto\
    \ i = 0;\n    foreach(n; l)\n    {\n        if(n > 0)\n        {\n           \
    \ result ~= n;\n        }\n    }\n    return result;\n}", "{\n    long[] a = new\
    \ long[l.length];\n    int k = 0;\n    for (int i = 0; i < l.length; i++)\n  \
    \  {\n        if (l[i] > 0)\n        {\n            a[k] = l[i];\n           \
    \ k++;\n        }\n    }\n    a = a[0..k];\n    return a;\n}", "{\n    auto result\
    \ = [];\n    foreach(item; l)\n    {\n        if(item > 0)\n        {\n      \
    \      result ~= item;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(value; l) \n    {\n        if (value > 0) \n        {\n\
    \            result ~= value;\n        }\n    }\n    return result;\n}\n/*\nReturn\
    \ the first n primes.\n    >>> get_primes(1)\n    [2L]\n    >>> get_primes(3)\n\
    \    [2L, 3L, 5L]\n    >>> get_primes(7)\n    [2L, 3L, 5L, 7L, 11L, 13L, 17L]\n\
    */\nlong[] get_primes(long n) \n{\n    long[] prime = [2L];\n    long j = 1;\n\
    \    for (long i = 3; i <= n; i++) \n    {\n        if (j == n) break;\n     \
    \   bool is_prime = true;\n        foreach(prime_; prime) \n        {\n      \
    \      if (i % prime_ == 0) \n            {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if (is_prime) \n  \
    \      {\n            prime ~= i;\n            j++;\n        }\n    }\n    return\
    \ prime;\n}", "{\n    long[] ret;\n    foreach(a; l)\n    {\n        if(a > 0)\n\
    \        {\n            ret ~= a;\n        }\n    }\n    return ret;\n}", "{\n\
    \    assert(l.length > 0);\n    auto res = filter!(i => i >= 0)(l);\n    return\
    \ res;\n}", "{\n    int pos = 0;\n    for (int i = 0; i < l.length; i++) \n  \
    \  {\n        if (l[i] > 0) \n        {\n            l[pos] = l[i];\n        \
    \    pos++;\n        }\n    }\n    l.length = pos;\n    return l;\n}", "{\n  \
    \  return l.filter!(x => x > 0)();\n}\n/*\nReturn only numbers with length >=\
    \ 1 in the array.\n    >>> get_not_empty([2L, 3L, 5L, -2L, -3L, -5L, 0L, 9L, -1L,\
    \ -10L])\n    [2L, 3L, 5L, 9L]\n    >>> get_not_empty([5L, 3L, -5L, 2L, -3L, 3L,\
    \ 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, 2L, 3L, 9L, 123L, 1L]\n    >>> get_not_empty([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L, -23L, -99L, -100L, -101L, -102L,\
    \ -103L, -104L, -105L, -106L, -107L, -108L, -109L, -110L, -111L, -112L, -113L,\
    \ -114L, -115L, -116L, -117L, -118L, -119L, -120L, -121L, -122L, -123L, -124L,\
    \ -125L, -126L, -127L, -128L, -129L, -130L, -131L, -132L, -133L, -134L, -135L,\
    \ -136L, -137L, -138L, -139L, -140L, -141L, -142L, -143L, -144L, -145L, -146L,\
    \ -147L, -148L, -149L, -150L, -151L, -152L, -153L, -154L, -155L, -156L, -157L,\
    \ -158L, -159L, -160L, -161L, -162L, -163L, -164L, -165L, -166L, -167L, -168L,\
    \ -169L, -170L, -171L, -172L, -173L, -174", "{\n\tlong[] lReturn = new long[0];\n\
    \tint i=0;\n\tint j=0;\n\tfor(i=0;i<l.length;i++) {\n\t\tif(l[i]>0) {\n\t\t\t\
    int pos = lReturn.length;\n\t\t\tlong[] lReturnTemp = new long[pos+1];\n\t\t\t\
    for(j=0;j<pos;j++) {\n\t\t\t\tlReturnTemp[j] = lReturn[j];\n\t\t\t}\n\t\t\tlReturnTemp[pos]\
    \ = l[i];\n\t\t\tlReturn = lReturnTemp;\n\t\t}\n\t}\n\treturn lReturn;\n}", "{\n\
    \tlong[] res;\n\tres.length = 0;\n\tforeach(i; l)\n\t{\n\t\tif(i > 0)\n\t\t{\n\
    \t\t\tres ~= i;\n\t\t}\n\t}\n\treturn res;\n}\n/*\n    Return only positive numbers\
    \ in the array.\n    >>> get_positive_2([-1L, 2L, -4L, 5L, 6L])\n    [2L, 5L,\
    \ 6L]\n    >>> get_positive_2([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n\
    \    [5L, 3L, 2L, 3L, 9L, 123L, 1L]\n*/\nlong[] get_positive_2(long[] l) \n{\n\
    \treturn l.filter!(x => x > 0);\n}", "{\n    // long[] res = new long[0];\n  \
    \  // foreach(long i; l)\n    // {\n    //     if(i > 0)\n    //     {\n    //\
    \         res ~= i;\n    //     }\n    // }\n    // return res;\n    return l.filter!(i\
    \ => i > 0);\n}", "{\n    long[][] pos = l.filter!(a => a > 0);\n    return pos[0];\n\
    }", "{\n    long[] positiveList = new long[0];\n    int i = 0;\n    for (i = 0;\
    \ i < l.length; i++) \n    {\n        if (l[i] > 0) \n        {\n            positiveList\
    \ ~= l[i];\n        }\n    }\n    return positiveList;\n}\n/*\nReturn the sum\
    \ of the number of elements in the list,\nthe sum of all the elements in the list,\n\
    and the average.\n    >>> get_sum_of_elements([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L])\n    [11L, 141L, 12.818181818181818L]\n    >>> get_sum_of_elements([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n    [10L, 55L, 5.5L]\n    >>> get_sum_of_elements([-1L,\
    \ -2L, -3L, -4L, -5L, -6L, -7L, -8L, -9L, -10L])\n    [10L, -55L, -5.5L]\n*/\n\
    long[] get_sum_of_elements(long[] l) \n{\n    long[] result = new long[3];\n \
    \   result[0] = l.length;\n    long sum = 0;\n    int i = 0;\n    for (i = 0;\
    \ i < l.length; i++) \n    {\n        sum += l[i];\n    }\n    result[1] = sum;\n\
    \    result[2] = cast(long)sum / cast(long)l.length;\n    return result;\n}\n\
    /*\nReturn the highest and lowest values in the list.\n    >>> get_high_low([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [123L, -10L]\n    >>> get_high_low([1L,\
    \ 2L,", "{\n    long[] temp = new long[l.length];\n    int temp_count = 0;\n \
    \   for (int i = 0; i < l.length; i++) \n    {\n        if (l[i] > 0) \n     \
    \   {\n            temp[temp_count] = l[i];\n            temp_count++;\n     \
    \   }\n    }\n    long[] positive = new long[temp_count];\n    for (int i = 0;\
    \ i < temp_count; i++) \n    {\n        positive[i] = temp[i];\n    }\n    return\
    \ positive;\n}", "{\n    l = l.filter!(x => x > 0); \n    return l;\n}", "{ \n\
    \   return l.filter!(a => a > 0).array;\n}", "{\n    return filter!(a => a > 0)(l);\n\
    }\n/*\nReturn only integers in the array.\n    >>> get_integers([1.3, 5.0, 3.2,\
    \ 4.0, 3.2, 5.0, 1.1, 5.0, 6.0, 5.0, 4.0,\n                     1.3, 4.0, 1.3,\
    \ 5.0, 6.0, 3.2, 4.0, 1.1, 6.0, 5.0, 6.0,\n                     1.3, 5.0, 6.0,\
    \ 5.0, 1.1, 5.0, 1.3, 5.0, 6.0, 5.0, 6.0,\n                     3.2, 4.0, 3.2,\
    \ 4.0, 1.1, 6.0, 5.0, 6.0, 5.0, 4.0, 3.2,\n                     4.0, 1.1, 5.0,\
    \ 6.0, 5.0, 6.0, 5.0, 1.3, 5.0, 6.0, 5.0,\n                     4.0, 3.2, 1.1,\
    \ 5.0, 1.3, 5.0, 6.0, 5.0, 6.0, 5.0, 6.0,\n                     5.0, 1.3, 5.0,\
    \ 6.0, 5.0, 4.0, 3.2, 4.0, 1.1, 5.0, 6.0,\n                     5.0, 6.0, 5.0,\
    \ 1.3, 5.0, 6.0, 5.0, 6.0, 5.0, 6.0, 5.0,\n                     1.3, 5.0, 1.3,\
    \ 5.0, 6.0, 5.0, 6.0, 5.0, 6.0, 5.0, 6.0,\n                     5.0, 1.3, 5.0,\
    \ 6.0, 5.0, 6.0, 5.0, 6.0, 5.0, 6.0, 5.0,\n                     1.3, 5.0, 6.0,\
    \ 5.0,", "{\n    long[] ret = new long[(int)l.length];\n    int j = 0;\n    for\
    \ (int i = 0; i < l.length; i++)\n    {\n        if (l[i] > 0)\n        {\n  \
    \          ret[j] = l[i];\n            j++;\n        }\n    }\n    ret.length\
    \ = j;\n    return ret;\n}\n/*\nGiven an array of numbers, return the product\
    \ of all the elements.\n    >>> product([])\n    1L\n    >>> product([1L, 2L,\
    \ 3L, 4L, 5L])\n    120L\n    >>> product([0L, 2L, 3L, 4L, 5L])\n    0L\n*/\n\
    long product(long[] l)\n{\n    long ret = 1;\n    for (int i = 0; i < l.length;\
    \ i++)\n    {\n        ret *= l[i];\n    }\n    return ret;\n}\n/*\nGiven an array\
    \ of numbers, return the sum of all the elements.\n    >>> summation([])\n   \
    \ 0L\n    >>> summation([1L, 2L, 3L, 4L, 5L])\n    15L\n    >>> summation([0L,\
    \ 2L, 3L, 4L, 5L])\n    14L\n*/\nlong summation(long[] l)\n{\n    long ret = 0;\n\
    \    for (int i = 0; i < l.length; i++)\n    {\n        ret += l[i];\n    }\n\
    \    return ret;\n}\n/*\nGiven an array of numbers, return the mean of all the\
    \ elements.\n    >>> mean([])\n    0.0\n    >>> mean([1L, 2L, 3L, 4L, 5L])\n \
    \   3.0\n    >>> mean([0L, 2L, 3L, 4L, 5L])\n    2.8\n*/\ndouble mean(long[] l)\n\
    {\n    double ret = 0;\n    for (int i = 0; i < l.length; i++)\n    {\n      \
    \  ret += l[i];\n    }\n    return ret / l.length;\n}\n/*\nGiven an array of numbers,",
  "{\n    long[] res;\n    foreach(l; x)\n    {\n        if(x>0)\n        {\n    \
    \        res ~= x;\n        }\n    }\n    return res;\n}", "{\n    return l.filter!(a\
    \ => a > 0);\n}\n/*\nReturn only negative numbers in the array.\n    >>> get_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]", "{\n    long[] res = new\
    \ long[0];\n    foreach(n; l) if (n > 0) res ~= n;\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the array.\n    >>> get_negative([-1L, 2L, -4L, 5L,\
    \ 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n    \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[0];\n    foreach(n; l) if (n < 0) res ~= n;\n\
    \    return res;\n}\n/*\nReturn the sum of all the numbers in the array.\n   \
    \ >>> get_sum([-1L, 2L, -4L, 5L, 6L])\n    8L\n    >>> get_sum([5L, 3L, -5L, 2L,\
    \ -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    161L\n    \n*/\nlong get_sum(long[] l)\
    \ \n{\n    long res = 0;\n    foreach(n; l) res += n;\n    return res;\n}\n/*\n\
    Return the average of all the numbers in the array.\n    >>> get_avg([-1L, 2L,\
    \ -4L, 5L, 6L])\n    2L\n    >>> get_avg([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L])\n    13L\n    \n*/\nlong get_avg(long[] l) \n{\n    return get_sum(l)\
    \ / l.length;\n}\n/*\nReturn the number of times the key occurs in the array.\n\
    \    >>> get_count(5L, [-1L, 2L, -4L, 5L, 6L])\n    1L\n    >>> get_count(5L,",
  "{\n  auto res = new long[];\n  foreach(num; l)\n  {\n    if(num > 0)\n      res\
    \ ~= num;\n  }\n  return res;\n}\n/*\nReturn the negative numbers in the array.\n\
    \    >>> get_negative([-1L, 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n    \n\
    */\nlong[] get_negative(long[] l) \n{\n  auto res = new long[];\n  foreach(num;\
    \ l)\n  {\n    if(num < 0)\n      res ~= num;\n  }\n  return res;\n}\n/*\nReturn\
    \ the index of the given element in the array.\n    >>> get_index_of_element([\"\
    a\", \"b\", \"c\", \"d\"], \"c\")\n    2\n    >>> get_index_of_element([\"a\"\
    , \"b\", \"c\", \"d\"], \"e\")\n    null\n    \n*/", "{\n    int n = l.length;\n\
    \    long[] r = new long[n];\n    int i = 0;\n    foreach(long s; l)\n    {\n\
    \        if(s > 0)\n        {\n            r[i] = s;\n            i++;\n     \
    \   }\n    }\n    return r[0..i];\n}", "{\n    long[] result;\n    foreach(i;\
    \ l) \n    {\n        if (i > 0) \n        {\n            result ~= i;\n     \
    \   }\n    }\n    return result;\n}", "{\n    int i = 0;\n    long[] newArray\
    \ = new long[l.length];\n    for (; i < l.length; i++)\n    {\n        if (l[i]\
    \ > 0)\n        {\n            newArray[i] = l[i];\n        }\n    }\n    return\
    \ newArray;\n}\n/*\nGiven the factorial of a number, return the factorial of the\
    \ next number.\nAssume the factorial is represented as an array of digits.\n \
    \   >>> factorial_of_next_number([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L])\n    [3L,\
    \ 6L, 2L, 9L, 2L, 5L, 7L, 6L, 5L, 7L, 3L, 3L, 2L, 1L]\n*/\nlong[] factorial_of_next_number(long[]\
    \ l) \n{\n    long[] r = new long[l.length + 2];\n    return r;\n}\n/*\nCalculate\
    \ the difference between two numbers.\nAssume the numbers are represented as arrays\
    \ of digits.\n    >>> difference([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L], [1L, 2L,\
    \ 3L, 4L, 5L, 6L, 7L, 8L, 9L])\n    [0L]\n    >>> difference([1L, 2L, 3L, 4L,\
    \ 5L, 6L, 7L, 8L, 9L], [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 8L])\n    [1L]\n    >>>\
    \ difference([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L], [0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L])\n    [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]\n    >>> difference([2L,\
    \ 2L, 2L, 1L], [1L, 1L, 1L", "{\n\tauto count = 0L;\n\tforeach(i; l)\n\t{\n\t\t\
    if(i > 0)\n\t\t\tcount++;\n\t}\n\tauto j = 0L;\n\tauto result = new long[count];\n\
    \tforeach(i; l)\n\t{\n\t\tif(i > 0)\n\t\t{\n\t\t\tresult[j] = i;\n\t\t\tj++;\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    long[] result = filter!(x => x > 0)(l);\n\
    \    return result;\n}", "{\n    long[] nums = [];\n    foreach(num; l) \n   \
    \ {\n        if(num > 0) \n        {\n            nums ~= num;\n        }\n  \
    \  }\n    return nums;\n}", "{\n    long[] result;\n    foreach(l; i =>\n    {\n\
    \        if (i > 0)\n        {\n            result ~= i;\n        }\n    });\n\
    \    return result;\n}", "{\n\tl = l.filter!(a => a > 0)();\n\treturn l;\n}",
  "{\n    long[] res;\n    foreach(item; l) \n    {\n        if (item > 0) \n    \
    \    {\n            res ~= item;\n        }\n    }\n    return res;\n}", "{\n\
    \    long[] p;\n    int j = 0;\n    foreach(i; l)\n    {\n        if(i > 0)\n\
    \        {\n            j++;\n        }\n    }\n    p = new long[j];\n    j =\
    \ 0;\n    foreach(i; l)\n    {\n        if(i > 0)\n        {\n            p[j]\
    \ = i;\n            j++;\n        }\n    }\n    return p;\n}\n/*\nReturn only\
    \ even numbers in the array.\n    >>> get_even([-1L, 2L, -4L, 5L, 6L])\n    [2L,\
    \ -4L, 6L]\n    >>> get_even([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n\
    \    [2L, -10L]\n*/\nlong[] get_even(long[] l) \n{\n    long[] e;\n    int j =\
    \ 0;\n    foreach(i; l)\n    {\n        if(i % 2 == 0)\n        {\n          \
    \  j++;\n        }\n    }\n    e = new long[j];\n    j = 0;\n    foreach(i; l)\n\
    \    {\n        if(i % 2 == 0)\n        {\n            e[j] = i;\n           \
    \ j++;\n        }\n    }\n    return e;\n}\n/*\nReturn only odd numbers in the\
    \ array.\n    >>> get_odd([-1L, 2L, -4L, 5L, 6L])\n    [-1L, 5L]\n    >>> get_odd([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, -5L, -3L, 3L, 9L,\
    \ 123L, 1L]\n*/\nlong[] get_odd(long[] l) \n{\n    long[] o;\n    int j = 0;\n\
    \    foreach(i; l)\n    {\n        if(i % 2 != 0)\n       ", "{\n    long[] ret\
    \ = new long[l.length];\n    int cnt = 0;\n    for (int i = 0; i < l.length; i++)\n\
    \    {\n        if (l[i] > 0)\n        {\n            ret[cnt] = l[i];\n     \
    \       cnt++;\n        }\n    }\n    long[] ret2 = new long[cnt];\n    for (int\
    \ i = 0; i < cnt; i++)\n    {\n        ret2[i] = ret[i];\n    }\n    return ret2;\n\
    }", "{\n    l = filter!(a => a > 0)(l);\n    return l;\n}", "{\n    long[] r =\
    \ new long[l.length];\n    int idx = 0;\n    foreach(long elm; l)\n    {\n   \
    \     if(elm > 0)\n        {\n            r[idx] = elm;\n            idx++;\n\
    \        }\n    }\n    r.length = idx;\n    return r;\n}", "{\n    long[] pos_l;\n\
    \    foreach(l; p)\n    {\n        if(p > 0)\n        {\n            pos_l ~=\
    \ p;\n        }\n    }\n    return pos_l;\n}", "{ \n    long[] k = l;\n    return\
    \ filter!((a) => a > 0)(k);\n}", "{\n    int i;\n    int size = 0;\n    int count\
    \ = 0;\n    long[] result;\n    //count the # of elements in the array that are\
    \ larger than 0.\n    for (i = 0; i < l.length; i++)\n    {\n        if (l[i]\
    \ > 0)\n        {\n            size = size + 1;\n        }\n    }\n    //create\
    \ a new array with the correct size.\n    result = new long[size];\n    //populate\
    \ the new array with only the positive integers from the original array.\n   \
    \ for (i = 0; i < l.length; i++)\n    {\n        if (l[i] > 0)\n        {\n  \
    \          result[count] = l[i];\n            count = count + 1;\n        }\n\
    \    }\n    return result;\n}\n/*\nReturn only negative numbers in the array.\n\
    \    >>> get_negative([-1L, 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[]\
    \ get_negative(long[] l) \n{\n    int i;\n    int size = 0;\n    int count = 0;\n\
    \    long[] result;\n    //count the # of elements in the array that are less\
    \ than 0.\n    for (i = 0; i < l.length; i++)\n    {\n        if (l[i] < 0)\n\
    \        {\n            size = size + 1;\n        }\n    }\n    //create a new\
    \ array with the correct size.\n    result = new long[size];\n    //populate the\
    \ new array with only the negative integers from the original array.\n    for\
    \ (i = 0; i < l.length; i++)\n    {\n        if (l[i] < 0)\n        {\n      \
    \      result[count] = l[i];\n            count = count + 1;\n        }\n    }\n\
    \    return result;\n}\n/*\nReturn only z", "{\n    long[] ret = new long[0];\n\
    \    foreach(item; l)\n    {\n        if(item > 0)\n        {\n            ret\
    \ ~= item;\n        }\n    }\n    return ret;\n}", "{\n    long[] result = new\
    \ long[l.length];\n    int i = 0;\n    for (int j = 0; j < l.length; j++)\n  \
    \  {\n        if (l[j] > 0)\n        {\n            result[i] = l[j];\n      \
    \      i++;\n        }\n    }\n    return result[0..i];\n}", "{\n    long[] res\
    \ = new long[l.length];\n    uint n = 0;\n    foreach(long x; l)\n    {\n    \
    \    if(x > 0)\n        {\n            res[n] = x;\n            n++;\n       \
    \ }\n    }\n    res.length = n;\n    return res;\n}", "{\n    // Remove this line\
    \ and replace with your code\n    long[] result = new long[0];\n    foreach(long\
    \ i; l)\n    {\n        if(i>0)\n        {\n            result ~= i;\n       \
    \ }\n    }\n    return result;\n}\n/*\nCompute the factorial of n.\n    >>> factorial(4L)\n\
    \    24L\n    >>> factorial(5L)\n    120L\n    >>> factorial(6L)\n    720L\n*/\n\
    long factorial(long n) \n{\n    // Remove this line and replace with your code\n\
    \    long result=1;\n    if(n==0)\n    {\n        return result;\n    }\n    else\n\
    \    {\n        foreach(long i; 0..n)\n        {\n            result *= i+1;\n\
    \        }\n        return result;\n    }\n}\n/*\nCompute the sum of the integers\
    \ in the list.\n    >>> sum_ints([1L, 2L, 3L, 4L, 5L])\n    15L\n    >>> sum_ints([0L,\
    \ 1L, 2L, 3L, 4L, 5L])\n    15L\n    >>> sum_ints([0L, 0L, 0L, 0L, 0L])\n    0L\n\
    */\nlong sum_ints(long[] l) \n{\n    // Remove this line and replace with your\
    \ code\n    long result=0;\n    foreach(long i; l)\n    {\n        result += i;\n\
    \    }\n    return result;\n}\n/*\nCompute the sum of the factorials of the integers\
    \ in the list.\n    >>> sum_factorials([1L, 2L, 3L, 4L, 5L])\n    153L\n    >>>\
    \ sum_factorials([0L, 1L, 2L, 3L, 4L, 5L])\n    153L\n    >>> sum_factorials([0L,\
    \ 0L, 0L, 0L, 0L])\n    0L\n*/\nlong sum_factorials(long[] l) \n{\n    // Remove\
    \ this line and replace with your code\n    long result=0;\n    fore", "{\n  \
    \  return l.filter!(x => x > 0L);\n}\n/*\n    >>> insert_in_the_beginning(0L,\
    \ [1L, 2L, 3L, 4L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> insert_in_the_beginning(7L,\
    \ [1L, 2L, 3L, 4L, 5L])\n    [7L, 1L, 2L, 3L, 4L, 5L]\n    >>> insert_in_the_beginning(0L,\
    \ [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n    [0L, 1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L]\n*/\nlong[] insert_in_the_beginning(long x, long[] l) \n{\n\
    \    return [x] ~ l;\n}\n/*\n    >>> remove_in_the_end([1L, 2L, 3L, 4L, 5L])\n\
    \    [1L, 2L, 3L, 4L]\n    >>> remove_in_the_end([1L, 2L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L, 10L])\n    [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]\n*/\nlong[] remove_in_the_end(long[]\
    \ l) \n{\n    return l[0 .. $ - 1];\n}\n/*\n    >>> get_max([1L, 2L, 3L, 4L, 5L])\n\
    \    5L\n    >>> get_max([-1L, -2L, -3L, -4L, -5L])\n    -1L\n    >>> get_max([1L,\
    \ 2L, 3L, 4L, -5L])\n    4L\n*/\nlong get_max(long[] l) \n{\n    return l.max();\n\
    }\n/*\n    >>> rotate([1L, 2L", "    pure \n{\n    auto pos = filter!(a => a >\
    \ 0)(l);\n    return pos.array;\n}\n \n /*\nReturn only negative numbers in the\
    \ array.\n    >>> get_negative([-1L, 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>>\
    \ get_negative([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L,\
    \ -3L, -10L]\n */\nlong[] get_negative(long[] l) \n    pure \n{\n    auto neg\
    \ = filter!(a => a < 0)(l);\n    return neg.array;\n}", "{\n    return filter!((a)\
    \ => a > 0L)(l);\n}\n/*\nGenerate a series of Fibonacci numbers, starting with\
    \ a0 = 1, a1 = 1, a2 = 2, a3 = 3 and so on.\n    >>> fibs(10L)\n    [1L, 1L, 2L,\
    \ 3L, 5L, 8L, 13L, 21L, 34L, 55L]\n    >>> fibs(11L)\n    [1L, 1L, 2L, 3L, 5L,\
    \ 8L, 13L, 21L, 34L, 55L, 89L]\n*/\nlong[] fibs(long n)\n{\n    long[] result\
    \ = new long[n];\n    result[0] = 1L;\n    result[1] = 1L;\n    foreach(ref l;\
    \ result[2..$])\n    {\n        l = result[$-1] + result[$-2];\n    }\n    return\
    \ result;\n}", "{\n    auto r = new long[];\n    foreach(i; l)\n    {\n      \
    \  if(i > 0)\n            r ~= i;\n    }\n    return r;\n}", "{ \n    return l.filter!(x\
    \ => x > 0)();\n}", "{ \n    return l.filter!(x => x > 0).array;\n}", "    in\
    \ {\n        foreach(x in l)\n        {\n            assert(x<=1000);\n      \
    \      assert(x>=-1000);\n        }\n    }\n    out(result) {\n        foreach(x\
    \ in result)\n        {\n            assert(x>=0);\n        }\n    }\n{\n    long[]\
    \ pos_nums = new long[];\n    foreach(x in l)\n    {\n        if(x>=0)\n     \
    \   {\n            pos_nums ~= x;\n        }\n    }\n    return pos_nums;\n}",
  "{\n    long [] result = new long[l.length];\n    int counter = 0;\n    foreach(long\
    \ a; l)\n    {\n        if(a > 0)\n        {\n            result[counter] = a;\n\
    \            counter++;\n        }\n    }\n    return result[0..counter];\n}",
  "{ \n    \n\t\n\t\n\treturn filter!((x){return x>0;})(l);\n}", "{\n    int a = l.length;\n\
    \    long[] positivos = new long[a];\n    int q = 0;\n    for (int i = 0; i <\
    \ a; i++){\n        if (l[i] > 0){\n            positivos[q] = l[i];\n       \
    \     q = q + 1;\n        }\n    }\n    return positivos;\n}", "{ \n    long[]\
    \ res = new long[l.length]; \n    long count = 0; \n    foreach(i; l)\n    { \n\
    \        if(i > 0)\n        { \n            res[count] = i; \n            count++;\
    \ \n        } \n    } \n    long[] result = new long[count]; \n    for(long i\
    \ = 0; i < count; i++)\n    { \n        result[i] = res[i]; \n    } \n    return\
    \ result; \n} ", "{\n  auto positive = l.filter!(x => x > 0)();\n  return positive;\n\
    }", "{\n  int cnt = 0;\n  foreach(idx, e; l) \n  {\n    if (e > 0) \n    {\n \
    \     cnt++;\n    }\n  }\n  long[] ret;\n  ret.length = cnt;\n  int i = 0;\n \
    \ foreach(idx, e; l) \n  {\n    if (e > 0) \n    {\n      ret[i] = e;\n      i++;\n\
    \    }\n  }\n  return ret;\n}\n/*\nReturn only negative numbers in the array.\n\
    \    >>> get_negative([-1L, 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[]\
    \ get_negative(long[] l) \n{\n  int cnt = 0;\n  foreach(idx, e; l) \n  {\n   \
    \ if (e < 0) \n    {\n      cnt++;\n    }\n  }\n  long[] ret;\n  ret.length =\
    \ cnt;\n  int i = 0;\n  foreach(idx, e; l) \n  {\n    if (e < 0) \n    {\n   \
    \   ret[i] = e;\n      i++;\n    }\n  }\n  return ret;\n}\n/*\nReturn array of\
    \ positive and negative elements in the order they are in the original array.\n\
    \    >>> get_positive_and_negative([-1L, 2L, -4L, 5L, 6L])\n    [-1L, 2L, -4L,\
    \ 5L, 6L]\n    >>> get_positive_and_negative([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L])\n    [5L, 3L, -5L, 2L, -3L, 3L, 9L, 123L, 1L,", "{\n    long[]\
    \ l_;\n    l_ = l.filter!( (long x) {\n        return x > 0;\n    });\n    return\
    \ l_;\n}\n/*\nReturn only positive numbers in the array.\n    >>> get_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] l_;\n    l_ = l.filter!( (long x) {\n        return x < 0;\n\
    \    });\n    return l_;\n}\n/*\nReturn only the even numbers in the array.\n\
    \    >>> get_even([-1L, 2L, -4L, 5L, 6L])\n    [2L, -4L, 6L]\n    >>> get_even([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [2L, 0L, -10L]\n*/\nlong[]\
    \ get_even(long[] l) \n{\n    long[] l_;\n    l_ = l.filter!( (long x) {\n   \
    \     return x % 2 == 0;\n    });\n    return l_;\n}\n/*\nReturn only the odd\
    \ numbers in the array.\n    >>> get_odd([-1L, 2L, -4L, 5L, 6L])\n    [-1L, 5L]\n\
    \    >>> get_odd([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L,\
    \ 3L, -5L, -3L, 3L, 9L, 123L, 1L]\n*/\nlong[] get_odd(long[] l) \n{\n    long[]\
    \ l_;\n    l_ = l.filter!", "{\n    int pos_num = 0;\n    int _i = 0;\n    while\
    \ (_i < l.length) {\n        if (l[_i] > 0) {\n            pos_num++;\n      \
    \  }\n        _i++;\n    }\n    long[] out = new long[pos_num];\n    int cnt =\
    \ 0;\n    _i = 0;\n    while (_i < l.length) {\n        if (l[_i] > 0) {\n   \
    \         out[cnt] = l[_i];\n            cnt++;\n        }\n        _i++;\n  \
    \  }\n    return out;\n}\n/*\nReturn only odd numbers in the array.\n    >>> get_odds([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, 5L]\n    >>> get_odds([5L, 3L, -5L, 2L, -3L, 3L,\
    \ 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, -5L, -3L, 3L, 9L, 123L, 1L]\n*/\nlong[]\
    \ get_odds(long[] l) \n{\n    int odd_num = 0;\n    int _i = 0;\n    while (_i\
    \ < l.length) {\n        if (l[_i] % 2 != 0) {\n            odd_num++;\n     \
    \   }\n        _i++;\n    }\n    long[] out = new long[odd_num];\n    int cnt\
    \ = 0;\n    _i = 0;\n    while (_i < l.length) {\n        if (l[_i] % 2 != 0)\
    \ {\n            out[cnt] = l[_i];\n            cnt++;\n        }\n        _i++;\n\
    \    }\n    return out;\n}\n/*\nReturn only even numbers in the array.\n    >>>\
    \ get_evens([-1L, 2L, -4L, 5L, 6L])\n    [2L, -4L, 6L]\n    >>> get_evens([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L", "{\n    long[] result = new long[l.length];\n\
    \    foreach(long i; l) \n    {\n        if (i > 0) \n        {\n            result\
    \ ~= i;\n        }\n    }\n    return result;\n}\n/*\n    >>> get_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    foreach(long i; l) \n \
    \   {\n        if (i < 0) \n        {\n            result ~= i;\n        }\n \
    \   }\n    return result;\n}\n/*\nReturn only even numbers in the array.\n   \
    \ >>> get_even([-1L, 2L, -4L, 5L, 6L])\n    [2L, -4L, 6L]\n    >>> get_even([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [2L, 0L, -10L]\n*/\nlong[]\
    \ get_even(long[] l) \n{\n    long[] result = new long[l.length];\n    foreach(long\
    \ i; l) \n    {\n        if (i % 2 == 0) \n        {\n            result ~= i;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn only odd numbers in the array.\n\
    \    >>> get_odd([-1L, 2L, -4L, 5L, 6L])\n    [-1L, 5L]\n    >>> get_odd([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, -5L, -3", "{\n\
    \    \n    long[] positives = new long[l.length];\n    long j = 0;\n    foreach(n;\
    \ l)\n    {\n        if(n > 0)\n        {\n            positives[j] = n;\n   \
    \         j++;\n        }\n    }\n    return positives[0..j];\n}", "    long[]\
    \ output = new long[l.length];\n    long j = 0;\n    for (long i = 0; i < l.length;\
    \ i++) \n        if (l[i] > 0) {\n            output[j] = l[i];\n            j\
    \ = j + 1;\n        }\n    return output[0..j];\n}\n/*\nCalculate the sum of all\
    \ positive numbers in the array.\n    >>> sum_positive([-1L, 2L, -4L, 5L, 6L])\n\
    \    13L\n    >>> sum_positive([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n\
    \    152L\n*/\nlong sum_positive(long[] l) \n    long sum = 0;\n    for (long\
    \ i = 0; i < l.length; i++) \n        if (l[i] > 0)\n            sum = sum + l[i];\n\
    \    return sum;\n}\n/*\nCalculate the average value of all positive numbers in\
    \ the array.\n    >>> mean_positive([-1L, 2L, -4L, 5L, 6L])\n    6.5\n    >>>\
    \ mean_positive([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    6.2\n\
    */\nfloat mean_positive(long[] l) \n    long sum = 0;\n    long counter = 0;\n\
    \    for (long i = 0; i < l.length; i++) \n        if (l[i] > 0) {\n         \
    \   sum = sum + l[i];\n            counter = counter + 1;\n        }\n    return\
    \ float(sum) / float(counter);\n}\n/*\nCalculate the standard deviation of all\
    \ positive numbers in the array.\n    >>> std_positive([-1L, 2L, -4L, 5L, 6L])\n\
    \    2.6\n    >>> std_positive([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -",
  "{\n    long[] positive;\n    foreach(long i; l) {\n        if (i > 0) {\n     \
    \       positive ~= i;\n        }\n    }\n    return positive;\n}", "{\n    long[]\
    \ r = new long[l.length];\n    for (int i = 0; i < l.length; i++)\n    {\n   \
    \     if (l[i] > 0)\n        {\n            r[i] = l[i];\n        }\n    }\n \
    \   return r;\n}\n// BEGIN TEMPLATE\nlong[] get_positive(long[] l) \n{\n    long[]\
    \ r = new long[l.length];\n    int j = 0;\n    for (int i = 0; i < l.length; i++)\n\
    \    {\n        if (l[i] > 0)\n        {\n            r[j] = l[i];\n         \
    \   j++;\n        }\n    }\n    r.length = j;\n    return r;\n}\n// END TEMPLATE",
  "{\n    long[] r = new long[0];\n    foreach(i; l)\n    {\n        if(i>0)\n   \
    \     {\n            r ~= i;\n        }\n    }\n    return r;\n}\n/*\nAdd a value\
    \ to a tuple.\n    >>> add_to_tuple((1L, 2L, 3L), 4L)\n    (1L, 2L, 3L, 4L)\n\
    \    >>> add_to_tuple(([1L, 2L, 3L], 4L), 5L)\n    ([1L, 2L, 3L], 4L, 5L)\n  \
    \  >>> add_to_tuple((1L, [2L, 3L], 4L), 5L)\n    (1L, [2L, 3L], 4L, 5L)\n    >>>\
    \ add_to_tuple(([1L, 2L, 3L], [4L], 5L), 6L)\n    ([1L, 2L, 3L], [4L], 5L, 6L)\n\
    */\nTuple!(Variant, N + 1) add_to_tuple(Tuple!(Variant, N) t, T)\n{\n    return\
    \ t ~ T();\n}", "{ \n    long[] result = new long[l.length];\n    int j = 0;\n\
    \    foreach(int i, l)\n    {\n        if(i > 0)\n        {\n            result[j]\
    \ = i;\n            j++;\n        }\n    }\n    return result[0..j];\n}", "{\n\
    \    return filter!((a) => a > 0)(l);\n}\n/*\nReturn the number of positive numbers\
    \ in the array.\n    >>> get_positive_count([-1L, 2L, -4L, 5L, 6L])\n    3L\n\
    \    >>> get_positive_count([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n\
    \    8L\n*/\nlong get_positive_count(long[] l) \n{\n    return filter!((a) =>\
    \ a > 0)(l).length;\n}\n/*\nReturn only negative numbers in the array.\n    >>>\
    \ get_negative([-1L, 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[]\
    \ get_negative(long[] l) \n{\n    return filter!((a) => a < 0)(l);\n}\n/*\nReturn\
    \ the number of negative numbers in the array.\n    >>> get_negative_count([-1L,\
    \ 2L, -4L, 5L, 6L])\n    2L\n    >>> get_negative_count([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    3L\n*/\nlong get_negative_count(long[] l)\
    \ \n{\n    return filter!((a) => a < 0)(l).length;\n}\n/*\nReturn the sum of all\
    \ numbers in the array.\n    >>> get_sum([-1L, 2L, -4L, 5L, 6L])\n    8L\n   \
    \ >>> get_sum([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    145L\n\
    */\nlong get_sum(long[] l) \n", "{\n\treturn filter!(a => a > 0)(l);\n}\n/*\n\
    \    Given a list of numbers, return the largest difference between\n    two numbers\
    \ that are next to each other.", "{ \n    long[] tmp = [];\n    foreach(x; l)\n\
    \    {\n        if(x > 0)\n        {\n            tmp ~= x;\n        }\n    }\n\
    \    return tmp;\n}", "{\n    return l.filter!(x => x > 0);\n}", "{\n    \n  \
    \  int rlen = l.length;\n    foreach(int i; l) {\n        if (i < 0) {\n     \
    \       rlen--;\n        }\n    }\n    long[] result = new long[rlen];\n    int\
    \ j = 0;\n    foreach(int i; l) {\n        if (i >= 0) {\n            result[j]\
    \ = i;\n            j++;\n        }\n    }\n    return result;\n}", "{\n    auto\
    \ pos = l.filter!(a => a > 0)();\n    return pos;\n}", "{\n  long[] filtered =\
    \ new long[l.length];\n  int j = 0;\n  foreach(long x; l) {\n    if (x > 0) {\n\
    \      filtered[j] = x;\n      j++;\n    }\n  }\n  return filtered[0..j];\n}",
  "{\n    long[] result = null;\n    int i = 0;\n    int pos = 0;\n    foreach(long\
    \ elem; l) {\n        if (elem > 0) {\n            result ~= elem;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] r;\n    long i;\n    int j;\n \
    \   j = 0;\n    r = new long[__unittest_size];\n    foreach (i; l) {\n       \
    \ if (i > 0) {\n            r[j] = i;\n            j = j + 1;\n        }\n   \
    \ }\n    return r[0..j];\n}\n/*\nReturn only negative numbers in the array.\n\
    \    >>> get_negative([-1L, 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[]\
    \ get_negative(long[] l) \n{\n    long[] r;\n    long i;\n    int j;\n    j =\
    \ 0;\n    r = new long[__unittest_size];\n    foreach (i; l) {\n        if (i\
    \ < 0) {\n            r[j] = i;\n            j = j + 1;\n        }\n    }\n  \
    \  return r[0..j];\n}\n/*\nReturn only zeros in the array.\n    >>> get_zeros([-1L,\
    \ 2L, -4L, 5L, 6L])\n    []\n    >>> get_zeros([5L, 3L, -5L, 2L, -3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L])\n    [0L]\n*/\nlong[] get_zeros(long[] l) \n{\n    long[]\
    \ r;\n    long i;\n    int j;\n    j = 0;\n    r = new long[__unittest_size];\n\
    \    foreach (i; l) {\n        if (i == 0) {\n            r[j] = i;\n        \
    \    j = j + 1;\n        }\n    }\n    return r[0..j];\n}\n/*\nReturn only odd\
    \ numbers in the array.\n    >>> get_odd([-", "{\n    auto res = l.filter!(a =>\
    \ a > 0);\n    return res.array;\n}\n/*\nReverse the array.\n    >>> reverse_array([1L,\
    \ 2L, 3L, 4L, 5L])\n    [5L, 4L, 3L, 2L, 1L]\n    >>> reverse_array([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n    [10L, 9L, 8L, 7L, 6L, 5L, 4L, 3L, 2L, 1L]\n\
    */\nlong[] reverse_array(long[] l) \n{\n    auto res = l.reverse;\n    return\
    \ res.array;\n}\n/*\nCreate array of random numbers.\n    >>> random_array(10L)\n\
    \    [0L, 8L, 3L, 5L, 8L, 4L, 6L, 3L, 4L, 2L]\n    >>> random_array(5L)\n    [1L,\
    \ 4L, 5L, 4L, 2L]\n*/\nlong[] random_array(long length) \n{\n    long[] res;\n\
    \    foreach(a;0..length)\n    {\n        res ~= a;\n    }\n    return res;\n\
    }\n/*\nShuffle numbers in the array.\n    >>> shuffle_array([1L, 2L, 3L, 4L, 5L])\n\
    \    [4L, 2L, 1L, 5L, 3L]\n    >>> shuffle_array([2L, 4L, 3L, 1L, 5L, 6L, 7L,\
    \ 8L, 9L, 10L])\n    [4L, 1L, 9L, 2L, 5L, 7L, 3L, 8L, 6L, 10L]\n*/\nlong[] shuffle_array(long[]\
    \ l) \n{\n    auto res = l.randomShuffle;\n    return res.array;\n}\n/*\nFind\
    \ the largest number in the array.\n    >>> find_largest([1L, 2L, 3L, 4L, 5L])\n\
    \    5L\n    >>> find_largest([", "{\n    long[] l1;\n    foreach(long i; l) \n\
    \    {\n        if (i > 0) \n        {\n            l1 ~= i;\n        }\n    }\n\
    \    return l1;\n}\n// get_positive(L);", "{\n\tlong[] ret = new long[l.length];\n\
    \tauto count = 0;\n\tforeach(i; l)\n\t{\n\t\tif(i > 0)\n\t\t{\n\t\t\tret[count]\
    \ = i;\n\t\t\tcount++;\n\t\t}\n\t}\n\tret = ret[0..count];\n\treturn ret;\n}",
  "{\n    long[] result;\n    int n = 0;\n    foreach(x; l)\n    {\n        if(x >\
    \ 0)\n        {\n            n++;\n        }\n    }\n    result = new long[n];\n\
    \    int m = 0;\n    foreach(x; l)\n    {\n        if(x > 0)\n        {\n    \
    \        result[m] = x;\n            m++;\n        }\n    }\n    return result;\n\
    }\n/*\nReturn the square of each element in the array.\n    >>> get_squares([1L,\
    \ 2L, 3L, 4L, 5L])\n    [1L, 4L, 9L, 16L, 25L]\n    >>> get_squares([5L, -3L,\
    \ 0L, 1L, 3L, 6L, 2L, -1L, 0L, 10L])\n    [25L, 9L, 0L, 1L, 9L, 36L, 4L, 1L, 0L,\
    \ 100L]\n*/\nlong[] get_squares(long[] l) \n{\n    long[] result;\n    result\
    \ = new long[l.length];\n    int i = 0;\n    foreach(x; l)\n    {\n        result[i]\
    \ = x*x;\n        i++;\n    }\n    return result;\n}\n/*\nReturn the number of\
    \ times that x appears in the array.\n    >>> count(1L, [1L, 3L, 1L, 5L, 1L, 6L,\
    \ 0L, 2L, 1L, 9L])\n    4L\n    >>> count(0L, [1L, 3L, 1L, 5L, 1L, 6L, 0L, 2L,\
    \ 1L, 9L])\n    1L\n    >>> count(10L, [1L, 3L, 1L, 5L, 1L, 6L, 0L, 2L, 1L, 9L])\n\
    \    0L\n*/\nlong count(long x, long[] l) \n{\n    long n = 0;\n    foreach(y;\
    \ l)\n    {\n        if(x == y)\n        {\n            n++;", "    pure nothrow\
    \ @safe @nogc\n{\n    long[] positive = appender!(long[])();\n    for (long i\
    \ = 0; i < l.length; i++)\n    {\n        if (l[i] > 0)\n        {\n         \
    \   positive.put(l[i]);\n        }\n    }\n    return positive.data;\n}", "{\n\
    \    long[] result = new long[l.length];\n    foreach(i; 0 .. l.length)\n    {\n\
    \        if(l[i] > 0)\n        {\n            result ~= l[i];\n        }\n   \
    \ }\n    return result;\n}\n// This solution uses a foreach loop to iterate through\
    \ the list, and adds all numbers which are greater than 0 to the result list.\n\
    // Using ~= in this case allows for the result to be added to the end of the list.",
  "{\n    long[] ret;\n    foreach(int i, long j; l)\n    {\n        if(j > 0)\n \
    \       {\n            ret ~= j;\n        }\n    }\n    return ret;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
