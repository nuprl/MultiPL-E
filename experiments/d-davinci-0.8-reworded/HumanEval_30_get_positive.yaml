name: HumanEval_30_get_positive
language: d
prompt: "import std.math;\n/*\nReturn only positive numbers in the array.\n    >>>\
  \ get_positive([-1L, 2L, -4L, 5L, 6L])\n    [2L, 5L, 6L]\n    >>> get_positive([5L,\
  \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, 2L, 3L, 9L, 123L,\
  \ 1L]\n    \n*/\nlong[] get_positive(long[] l) \n"
tests: "unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
  \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L,\
  \ 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
  \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
completions: ["{\n    long[] n = l.filter!(x => x > 0);\n    return n;\n}", "{\n \
    \ import std.conv;\n  import std.algorithm;\n  import std.math;\n  long[] temp;\n\
    \  foreach(el; l)\n  {\n    if(el > 0)\n    {\n      temp ~= el;\n    }\n  }\n\
    \  return temp;\n}", "{\n  int pos_count = 0;\n  foreach(long num; l)\n  {\n \
    \   if(num > 0)\n      pos_count++;\n  }\n  long[] result = new long[pos_count];\n\
    \  pos_count = 0;\n  foreach(long num; l)\n  {\n    if(num > 0)\n    {\n     \
    \ result[pos_count] = num;\n      pos_count++;\n    }\n  }\n  return result;\n\
    }\n/*\nReturn only negative numbers in the array.\n    >>> get_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [-1L, -4L]\n    >>> get_negative([5L, 3L, -5L, 2L, -3L,\
    \ 3L, 9L, 0L, 123L, 1L, -10L])\n    [-5L, -3L, -10L]\n*/\nlong[] get_negative(long[]\
    \ l) \n{\n  int neg_count = 0;\n  foreach(long num; l)\n  {\n    if(num < 0)\n\
    \      neg_count++;\n  }\n  long[] result = new long[neg_count];\n  neg_count\
    \ = 0;\n  foreach(long num; l)\n  {\n    if(num < 0)\n    {\n      result[neg_count]\
    \ = num;\n      neg_count++;\n    }\n  }\n  return result;\n}\n/*\nReturn the\
    \ minimum value in the array.\n    >>> get_min([1L, 2L, 3L, 4L, 5L])\n    1L\n\
    \    >>> get_min([123L, 3L, -5L, 20L, 0L, 1L, -3L, 20L, -10L])\n    -10L\n*/\n\
    long get_min(long[] l) \n{\n  long min = l[0];\n  foreach(long num; l)\n  {\n\
    \    if(num < min)\n      min = num;\n  }\n  return min;\n}\n/*\nReturn the maximum\
    \ value in the array.\n    >>> get_max([1L, 2L,", "{\n    long[] l2 = new long[0];\n\
    \    foreach(int j, num; l)\n    {\n        if(num > 0)\n        {\n         \
    \   l2 = l2 ~ num;\n        }\n    }\n    return l2;\n}\n/*\nImplement these two\
    \ functions.\n    >>> get_sum([1L, 2L, 3L, 4L, 5L])\n    15L\n    >>> get_sum([1L,\
    \ 2L, 3L, -5L, 10L])\n    11L\n    \n*/\nlong get_sum(long[] l) \n{\n    long\
    \ sum = 0;\n    foreach(int j, num; l)\n    {\n        sum += num;\n    }\n  \
    \  return sum;\n}\nlong get_sum2(long[] l) \n{\n    return foldl!(\"a + b\")(0,\
    \ l);\n}", "{\n\tint i;\n\t//long[] output;\n\tint size = 0;\n\t\n\tfor (i = 0;\
    \ i < l.length; i++) {\n\t\t//printf(\" %ld \", l[i]);\n\t\tif (l[i] >= 0)\n\t\
    \t\tsize++;\n\t}\n\tlong[] output = new long[size];\n\tint j = 0;\n\tfor (i =\
    \ 0; i < l.length; i++) {\n\t\tif (l[i] >= 0) {\n\t\t\toutput[j] = l[i];\n\t\t\
    \tj++;\n\t\t}\n\t}\n\treturn output;\n}", "{\n    auto result = new long[];\n\
    \    foreach(item; l) \n    {\n        if (item > 0) \n        {\n           \
    \ result ~= item;\n        }\n    }\n    return result;\n}", "    version(LDC)\n\
    {\n    return l.filter!(a => a > 0L);\n}", "{\n    // FIXME: implement the function\n\
    \    return l.filter!(a => a > 0);\n}", "{\n\tlong[] positive = new long[0];\n\
    \tforeach(e; l)\n\t{\n\t\tif(e > 0)\n\t\t{\n\t\t\tpositive ~= e;\n\t\t}\n\t}\n\
    \treturn positive;\n}", "{\n     long[] ret = new long[l.length];\n     int k\
    \ = 0;\n     for (int i = 0; i < l.length; i++)\n     {\n        if (l[i] > 0)\n\
    \        {\n            ret[k] = l[i];\n            k++;\n        }\n     }\n\
    \     long[] result = new long[k];\n     for (int i = 0; i < k; i++)\n       \
    \ result[i] = ret[i];\n     return result;\n}\n/*\nFilter array by even numbers.\n\
    \    >>> get_even([-1L, 2L, -4L, 5L, 6L])\n    [2L, -4L, 6L]\n    >>> get_even([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [2L, -10L]\n    \n*/\nlong[]\
    \ get_even(long[] l) \n{\n     long[] ret = new long[l.length];\n     int k =\
    \ 0;\n     for (int i = 0; i < l.length; i++)\n     {\n        if (l[i] % 2 ==\
    \ 0)\n        {\n            ret[k] = l[i];\n            k++;\n        }\n   \
    \  }\n     long[] result = new long[k];\n     for (int i = 0; i < k; i++)\n  \
    \      result[i] = ret[i];\n     return result;\n}\n/*\nFilter array by odd numbers.\n\
    \    >>> get_odd([-1L, 2L, -4L, 5L, 6L])\n    [-1L, 5L]\n    >>> get_odd([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, -5L, -3L, 3L, 9L,\
    \ 123L, 1L]\n    \n*/\nlong[] get_odd(long[] l) \n{\n     long[] ret = new long[l.length];\n\
    \     int k = 0;\n", "{\n    long[] l2;\n    foreach(val; l)\n    {\n        if(val\
    \ > 0)\n        {\n            l2 ~= val;\n        }\n    }\n    return l2;\n}",
  "{\n\tlong[] result = new long[0];\n\tforeach(long x; l)\n\t{\n\t\tif(x > 0)\n\t\
    \t{\n\t\t\tresult ~= x;\n\t\t}\n\t}\n\treturn result;\n}", "{ \n    return l.filter!(x\
    \ => x > 0)();\n}", "{\n  long[] result;\n  long[] pos;\n  foreach(l, x;\n   \
    \ if (x > 0)\n      pos ~= x;\n  )\n  result =  cast(long[]) pos;\n  return result;\n\
    }\n/*\n    Return the absolute values of each number in the array.\n    >>> absolute([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [1L, 2L, 4L, 5L, 6L]\n    >>> absolute([5L, 3L, -5L,\
    \ 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L, 1L, 10L]\n*/\nlong[] absolute(long[] l) \n{\n  long[] result;\n  long[]\
    \ pos;\n  foreach(l, x;\n    if (x < 0)\n      pos ~= x * -1;\n    else\n    \
    \  pos ~= x;\n  )\n  result =  cast(long[]) pos;\n  return result;\n}\n/*\nReturn\
    \ the sum of all numbers in the array.\n    >>> sum([-1L, 2L, -4L, 5L, 6L])\n\
    \    8L\n    >>> sum([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n   \
    \ 172L\n*/\nlong sum(long[] l) \n{\n  long result;\n  long pos;\n  foreach(l,\
    \ x;\n    pos += x;\n  )\n  result =  cast(long) pos;\n  return result;\n}\n/*\n\
    Return the largest number in the array.\n    >>> max([-1L, 2L, -4L, 5L, 6L])\n\
    \    6L\n    >>> max([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n   \
    \ 123L\n*/\nlong max(long[] l)", "{\n    long[] a;\n    foreach(n; l)\n    {\n\
    \        if(n > 0)\n        {\n            a ~= n;\n        }\n    }\n    return\
    \ a;\n}\n/*\nReturn a new array with no negative numbers.\n    >>> filter_negative([-1L,\
    \ 2L, -4L, 5L, 6L])\n    [2L, 5L, 6L]\n    >>> filter_negative([5L, 3L, -5L, 2L,\
    \ -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L, 3L, 2L, 3L, 9L, 0L, 123L, 1L]\n\
    */\nlong[] filter_negative(long[] l) \n{\n    long[] a;\n    foreach(n; l)\n \
    \   {\n        if(n > 0)\n        {\n            a ~= n;\n        }\n    }\n \
    \   return a;\n}\n/*\nReturn a new array containing the absolute value of each\
    \ number.\n    >>> abs_all([-1L, 2L, -4L, 5L, 6L])\n    [1L, 2L, 4L, 5L, 6L]\n\
    \    >>> abs_all([5L, 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10L])\n    [5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, 10L]\n*/\nlong[] abs_all(long[] l) \n\
    {\n    long[] a;\n    foreach(n; l)\n    {\n        a ~= abs(n);\n    }\n    return\
    \ a;\n}\n/*\nReturn the number of items in the input list that are not equal to\
    \ zero.\n    >>> count_nonzero([-1L, 2L, -4L, 5L, 6L])\n    4\n    >>> count_nonzero([5L,\
    \ 3L, -5L, 2L, -3L, 3L, 9L, 0L, 123L, 1L, -10", "{\n    return l.filter!(x =>\
    \ x > 0L);\n}", "{\n    /*\n    cast(long[])filter!(a => a >= 0L)(l);\n    */\n\
    \    auto p = filter!(a => a >= 0L)(l);\n    return cast(long[])p;\n}", "{\n \
    \   long[] res = {};\n    foreach(long i; l) \n    {\n        if (i > 0) \n  \
    \      {\n            res ~= i;\n        }\n    }\n    return res;\n}", "{\n \
    \ long[] g;\n  foreach(ll; l)\n    if(ll>0)\n    {\n      g ~= ll;\n    }\n  return\
    \ g;\n}", "{ \n   long[] res;\n   foreach(el; l)\n      if(el > 0)\n         res\
    \ ~= el;\n   return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
