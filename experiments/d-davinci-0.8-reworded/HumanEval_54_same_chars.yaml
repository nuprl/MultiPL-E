name: HumanEval_54_same_chars
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Check if two words have\
  \ the same characters.\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"\
  )\n    true\n    >>> same_chars(\"abcd\", \"dddddddabc\")\n    true\n    >>> same_chars(\"\
  dddddddabc\", \"abcd\")\n    true\n    >>> same_chars(\"eabcd\", \"dddddddabc\"\
  )\n    false\n    >>> same_chars(\"abcd\", \"dddddddabce\")\n    false\n    >>>\
  \ same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n    false\n    \n*/\nbool same_chars(string\
  \ s0, string s1) \n"
tests: "unittest\n{\n    alias candidate = same_chars;\n\n    assert(candidate(\"\
  eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(candidate(\"abcd\", \"\
  dddddddabc\") == true);\n    assert(candidate(\"dddddddabc\", \"abcd\") == true);\n\
  \    assert(candidate(\"eabcd\", \"dddddddabc\") == false);\n    assert(candidate(\"\
  abcd\", \"dddddddabcf\") == false);\n    assert(candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"\
  ) == false);\n    assert(candidate(\"aabb\", \"aaccc\") == false);\n}\nvoid main(){}"
completions: ["{\n    if (s0.length == s1.length) {\n        bool[] bs = new bool[s0.length];\n\
    \        foreach (char ch; s0) {\n            for (size_t i = 0; i < s1.length;\
    \ i++) {\n                if (s1[i] == ch && !bs[i]) {\n                    bs[i]\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n        return all(bs);\n    }\n    return false;\n}\n/*", "{\n    ubyte[]\
    \ arr0 = s0.dup.byCodeUnits;\n    ubyte[] arr1 = s1.dup.byCodeUnits;\n    arr0.sort;\n\
    \    arr1.sort;\n    return arr0 == arr1;\n}\n/*", "{\n    int[] count = new int[26];\n\
    \    for (immutable int c : s0) \n    {\n        count[c - 'a']++;\n    }\n  \
    \  for (immutable int c : s1) \n    {\n        count[c - 'a']--;\n    }\n    foreach\
    \ (i; count) \n    {\n        if (i != 0) \n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n/*", "{\n    if (s0.length != s1.length)\
    \ \n    {\n        return false;\n    }", "{\n    // count characters in s0\n\
    \    int[char] c0 = count(s0);\n    // count characters in s1\n    int[char] c1\
    \ = count(s1);\n    // make sure c0 and c1 have the same contents\n    return\
    \ c0.equal(c1);\n}\n \n/*", "{\n    int[] c0 = new int[26];\n    int[] c1 = new\
    \ int[26];\n    s0.toLower().each!(a => ++c0[a - 'a']);\n    s1.toLower().each!(a\
    \ => ++c1[a - 'a']);\n    return c0 == c1;\n}", "{\n    auto c0 = s0.countChar();\n\
    \    auto c1 = s1.countChar();\n    foreach(ch; c0.keys)\n    {\n        if(c0[ch]\
    \ != c1[ch])\n            return false;\n    }\n    return true;\n}\nassert(same_chars(\"\
    eabcdzzzz\", \"dddzzzzzzzddeddabc\"));\nassert(same_chars(\"abcd\", \"dddddddabc\"\
    ));\nassert(same_chars(\"dddddddabc\", \"abcd\"));\nassert(!same_chars(\"eabcd\"\
    , \"dddddddabc\"));\nassert(!same_chars(\"abcd\", \"dddddddabce\"));\nassert(!same_chars(\"\
    eabcdzzzz\", \"dddzzzzzzzddddabc\"));\n/*", "{\n    auto c0 = makeCounter(s0);\n\
    \    auto c1 = makeCounter(s1);\n    return c0 == c1;\n}", "{\n    auto c0 = Counter!char(s0);\n\
    \    auto c1 = Counter!char(s1);\n    return c0 == c1;\n}", "{\n    if (s0.length\
    \ != s1.length) \n    {\n        return false;\n    }", "{\n    if (s0.length\
    \ != s1.length)\n        return false;\n    int[char] dict;\n    foreach (ch;\
    \ s0) \n    {\n        if (dict.contains(ch))\n            dict[ch]++;\n     \
    \   else\n            dict[ch] = 1;\n    }\n    foreach (ch; s1) \n    {\n   \
    \     if (dict.contains(ch))\n            dict[ch]--;\n        else\n        \
    \    return false;\n    }\n    foreach (ch, count; dict) \n    {\n        if (count\
    \ != 0)\n            return false;\n    }\n    return true;\n}\n/*", "{\n    uint[]\
    \ table0 = new uint[256];\n    uint[] table1 = new uint[256];\n    foreach (c;\
    \ s0) table0[c]++;\n    foreach (c; s1) table1[c]++;\n    return table0 == table1;\n\
    }", "{\n    int[] char_counts = new int[256];\n    for (int c : s0) \n    {\n\
    \        ++char_counts[c];\n    }\n    for (int c : s1) \n    {\n        --char_counts[c];\n\
    \    }\n    foreach (n; char_counts) \n    {\n        if (n != 0) \n        {\n\
    \            return false;\n        }\n    }\n    return true;\n}", "{\n    if\
    \ (s0.length != s1.length) \n    {\n        return false;\n    }\n    auto c0\
    \ = s0.dup;\n    sort(c0);\n    auto c1 = s1.dup;\n    sort(c1);\n    return c0\
    \ == c1;\n}", "{\n    /*\n    s0.length == s1.length\n    s0.chars.count == s1.chars.count\n\
    \    else false\n    */\n    auto size = s0.length;\n    if (size != s1.length)\
    \ return false;\n    auto c0 = s0.countMap;\n    auto c1 = s1.countMap;\n    foreach\
    \ (c; c0.keys) {\n        if (c0[c] != c1[c]) return false;\n    }\n    return\
    \ true;\n}", "{\n    auto add(T)(inout long[T] counts, T ch) {\n        counts[ch]++;\n\
    \    }\n    auto sub(T)(inout long[T] counts, T ch) {\n        counts[ch]--;\n\
    \    }\n    auto is_count_zero(T)(inout long[T] counts, T ch) {\n        return\
    \ counts[ch] == 0;\n    }\n    long[char] counts0 = [], counts1 = [];\n    auto\
    \ s0 = s0.dup;\n    auto s1 = s1.dup;\n    add(s0, s0[0]);\n    sub(s1, s1[0]);\n\
    \    auto iter0 = s0.splitter;\n    auto iter1 = s1.splitter;\n    auto check_str(inout\
    \ string s, inout string s0, inout string s1, inout auto iter, inout long[char]\
    \ counts) {\n        foreach (ch; s) {\n            if (is_count_zero(counts,\
    \ ch)) {\n                if (iter.empty) {\n                    return false;\n\
    \                }\n                s ~= ch;\n                ch = iter.front;\n\
    \                iter.popFront;\n                if (s == s0) {\n            \
    \        add(counts, ch);\n                } else {\n                    sub(counts,\
    \ ch);\n                }\n            } else {\n                if (s == s0)\
    \ {\n                    sub(counts, ch);\n                } else {\n        \
    \            add(counts, ch);\n                }\n            }\n        }\n \
    \       return true;\n    }\n    return check_str(s0, s0, s1, iter0, counts0)\
    \ \n        && check_str(s1, s0, s1, iter1, counts1);\n}\n/*", "{\n    const int8[256]\
    \ dict0 = new int8[256](-1);\n    int32 count = 0;\n    foreach (i, ch; s0) {\n\
    \        dict0[ch]++;\n        if (dict0[ch] == 0) {\n            count++;\n \
    \       }\n    }\n    const int8[256] dict1 = new int8[256](-1);\n    foreach\
    \ (i, ch; s1) {\n        dict1[ch]++;\n        if (dict1[ch] == 0) {\n       \
    \     count--;\n        }\n    }\n    return count == 0;\n}", "{\n    bool[] bs\
    \ = new bool[256];\n    foreach (dchar x; s0) \n    {\n        bs[x] = true;\n\
    \    }\n    foreach (dchar x; s1) \n    {\n        if (!bs[x]) \n        {\n \
    \           return false;\n        }\n    }\n    return true;\n}", "{\n    //\
    \ https://stackoverflow.com/questions/15095909/how-to-check-if-two-strings-have-the-same-characters\n\
    \    bool result;\n    if (s0.length < s1.length) {\n        result = false;\n\
    \    } else {\n        auto d = std.typecons.makeDMap!(string, uint)();\n    \
    \    foreach (c; s0) {\n            if (d.contains(c)) {\n                d[c]\
    \ += 1;\n            } else {\n                d[c] = 1;\n            }\n    \
    \    }\n        foreach (c; s1) {\n            if (d.contains(c)) {\n        \
    \        d[c] -= 1;\n            } else {\n                result = false;\n \
    \               break;\n            }\n        }\n        if (d.empty) {\n   \
    \         result = true;\n        } else {\n            result = std.algorithm.any!(a\
    \ => a != 0)(d.values);\n        }\n    }\n    return result;\n}", "{\n    int[char]\
    \ cmap;\n    foreach(c; s0) \n    {\n        cmap[c]++;\n    }\n    foreach(c;\
    \ s1) \n    {\n        cmap[c]--;\n    }\n    foreach(v; cmap) \n    {\n     \
    \   if(v!=0) \n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
