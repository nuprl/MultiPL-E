name: HumanEval_20_find_closest_elements
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of numbers\
  \ (of length at least two) select and return two that are the closest to each\n\
  \    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float)\
  \ find_closest_elements(float[] numbers) \n"
tests: "unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
  \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) ==\
  \ tuple(2.2, 3.1));\n}\nvoid main(){}"
completions: ["{\n    double min = double.max;\n    size_t minIndex = 0;\n    size_t\
    \ len = numbers.length;\n    for (size_t i = 0; i < len; i++) \n    {\n      \
    \  if (i + 1 < len) \n        {\n            double newDiff = abs(numbers[i] -\
    \ numbers[i + 1]);\n            if (newDiff < min) \n            {\n         \
    \       min = newDiff;\n                minIndex = i;\n            }\n       \
    \ }\n    }\n    return tuple(numbers[minIndex], numbers[minIndex + 1]);\n}", "{\n\
    \    float[] args = numbers[1..$];\n    float smallest_diff = args[0] - numbers[0];\n\
    \    float[] smallest_tuple = [numbers[0], args[0]];\n    float smallest_diff_abs\
    \ = abs(smallest_diff);\n    for (size_t i = 0; i < numbers.length - 1; i++) \n\
    \    {\n        for (size_t j = i + 1; j < numbers.length; j++) \n        {\n\
    \            float diff = numbers[i] - numbers[j];\n            float diff_abs\
    \ = abs(diff);\n            if (diff_abs < smallest_diff_abs) \n            {\n\
    \                smallest_diff = diff;\n                smallest_diff_abs = diff_abs;\n\
    \                smallest_tuple = [numbers[i], numbers[j]];\n            }\n \
    \       }\n    }\n    float[] sorted_tuple = sort(smallest_tuple);\n    return\
    \ tuple(sorted_tuple[0], sorted_tuple[1]);\n}", "{\n    float diff = 99999;\n\
    \    float lower = 99999;\n    float higher = 99999;\n    int i = 0;\n    foreach(float\
    \ x; numbers) \n    {\n        if(i != numbers.length-1) \n        {\n       \
    \     float newdiff = abs(x - numbers[i+1]);\n            if(newdiff < diff) \n\
    \            {\n                diff = newdiff;\n                lower = min(x,\
    \ numbers[i+1]);\n                higher = max(x, numbers[i+1]);\n           \
    \ }\n        }\n        i++;\n    }\n    return tuple(lower, higher);\n}", "{\n\
    \    float minDist = float.infinity;\n    Tuple!(float, float) result = tuple(0.0,\
    \ 0.0);\n    foreach(i, a; numbers)\n    {\n        foreach(j, b; numbers)\n \
    \       {\n            if(i != j)\n            {\n                float dist =\
    \ abs(a - b);\n                if(dist < minDist)\n                {\n       \
    \             minDist = dist;\n                    result = tuple(min(a, b), max(a,\
    \ b));\n                }\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    assert(numbers.length >= 2);\n    int n = numbers.length;\n    float[]\
    \ distance = new float[n];", "{\n    //asume that numbers is not empty\n    float\
    \ min = abs(numbers[0] - numbers[1]);\n    float num1 = numbers[0];\n    float\
    \ num2 = numbers[1];\n    int size = numbers.length;\n    for (int i = 0; i <\
    \ size - 1; i++)\n    {\n        for (int j = i + 1; j < size; j++)\n        {\n\
    \            float temp = abs(numbers[i] - numbers[j]);\n            if (temp\
    \ < min)\n            {\n                min = temp;\n                num1 = numbers[i];\n\
    \                num2 = numbers[j];\n            }\n        }\n    }\n    if (num1\
    \ > num2)\n    {\n        float temp = num1;\n        num1 = num2;\n        num2\
    \ = temp;\n    }\n    return tuple(num1, num2);\n}", "{ \n    auto diff_max =\
    \ 1.0e20;\n    auto diff_min = 1.0e20;\n    auto diff_max_min = 1.0e20;\n    float\
    \ num1 = 0.0;\n    float num2 = 0.0;\n    float num1_max = 0.0;\n    float num2_max\
    \ = 0.0;\n    float num1_min = 0.0;\n    float num2_min = 0.0;\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        for (int j = 0; j < numbers.length;\
    \ j++)\n        {\n            if (i != j)\n            {\n                diff_max\
    \ = max(numbers[i], numbers[j]);\n                diff_min = min(numbers[i], numbers[j]);\n\
    \                if ((diff_max - diff_min) < diff_max_min)\n                {\n\
    \                    diff_max_min = diff_max - diff_min;\n                   \
    \ num1_max = numbers[i];\n                    num2_max = numbers[j];\n       \
    \             num1_min = numbers[i];\n                    num2_min = numbers[j];\n\
    \                }\n            }\n        }\n    }\n    return tuple(num1_min,\
    \ num2_min);\n}", "{\n    float small_difference = float.max;\n    float a = 0.0;\n\
    \    float b = 0.0;\n    foreach(i, num; numbers) \n    {\n        // start at\
    \ the next element, stop when we have looked at all elements\n        foreach_i\
    \ (j, end) \n        {\n            if (j > i) \n            {\n             \
    \   // for each pair of numbers calculate the difference\n                float\
    \ difference = abs(num - numbers[j]);\n                // if this difference is\
    \ less than the previous minimum, update the minimum\n                if (difference\
    \ < small_difference) \n                {\n                    small_difference\
    \ = difference;\n                    a = num;\n                    b = numbers[j];\n\
    \                }\n            }\n        }\n    }\n    return tuple(a, b);\n\
    }", "{\n    float min_distance = 1000000.0;\n    Tuple!(float, float) closest_elements;\n\
    \    foreach(i, number; numbers)\n    {\n        foreach(j, other_number; numbers)\n\
    \        {\n            if(other_number > number)\n            {\n           \
    \     float distance = other_number - number;\n                if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         closest_elements = tuple(number, other_number);\n                }\n\
    \            }\n        }\n    }\n    return closest_elements;\n}", "{\n    float\
    \ closest = 1000;\n    float[] result = null;\n    foreach(float element1; numbers)\n\
    \    {\n        foreach(float element2; numbers)\n        {\n            if(element1\
    \ == element2) continue;\n            float distance = abs(element1 - element2);\n\
    \            if(distance < closest)\n            {\n                closest =\
    \ distance;\n                result = [element1, element2];\n            }\n \
    \       }\n    }\n    return tuple(result[0], result[1]);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float minDistance = DBL_MAX;\n    Tuple!(float, float) result;\n\
    \    for (int i = 0; i < numbers.length - 1; i++)\n    {\n        for (int j =\
    \ i + 1; j < numbers.length; j++)\n        {\n            float dist = abs(numbers[i]\
    \ - numbers[j]);\n            if (dist < minDistance)\n            {\n       \
    \         minDistance = dist;\n                result = tuple(numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    float diff;\n\
    \    float mindiff = INFINITY;\n    int i = 0;\n    int j = 1;\n    for (i = 0;\
    \ i < numbers.length - 1; i++)\n    {\n        for (j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            diff = abs(numbers[i] - numbers[j]);\n        \
    \    if (diff < mindiff)\n            {\n                mindiff = diff;\n   \
    \         }\n        }\n    }\n    float ret1;\n    float ret2;\n    for (i =\
    \ 0; i < numbers.length - 1; i++)\n    {\n        for (j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            diff = abs(numbers[i] - numbers[j]);\n        \
    \    if (diff == mindiff)\n            {\n                ret1 = numbers[i];\n\
    \                ret2 = numbers[j];\n                return tuple(ret1, ret2);\n\
    \            }\n        }\n    }\n}", "{\n    auto closest = tuple(2.0f, 2.0f);\n\
    \    foreach(n1; 0 .. numbers.length - 1)\n    {\n        foreach(n2; n1 + 1 ..\
    \ numbers.length)\n        {\n            auto diff = abs(numbers[n1] - numbers[n2]);\n\
    \            if(abs(closest[0] - closest[1]) > diff)\n            {\n        \
    \        closest = tuple(numbers[n1], numbers[n2]);\n            }\n        }\n\
    \    }\n    return closest;\n}", "{\n    assert(numbers.length>=2);\n    float\
    \ smaller = numbers[0];\n    float larger = numbers[1];\n    float small = abs(numbers[0]-numbers[1]);\n\
    \    for(int i=0;i<numbers.length;i++)\n    {\n        for(int j=i+1;j<numbers.length;j++)\n\
    \        {\n            if(abs(numbers[i]-numbers[j])<small)\n            {\n\
    \                small = abs(numbers[i]-numbers[j]);\n                smaller\
    \ = numbers[i];\n                larger = numbers[j];\n            }\n       \
    \ }\n    }\n    return tuple(smaller,larger);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float min = numbers[0];\n    float minDiff = 1.0e20;\n    float\
    \ max = numbers[0];\n    foreach(i, ref e; numbers) \n    {\n        if (e < min)\
    \ \n        {\n            min = e;\n        }\n        if (e > max) \n      \
    \  {\n            max = e;\n        }\n        if (i > 0) \n        {\n      \
    \      float diff = abs(e - numbers[i - 1]);\n            if (diff < minDiff)\
    \ \n            {\n                minDiff = diff;\n            }\n        }\n\
    \    }\n    return tuple(min, max);\n}", "{\n    float min_distance = numbers[1]\
    \ - numbers[0];\n    float a = numbers[0];\n    float b = numbers[1];\n    for\
    \ (size_t i = 1; i < numbers.length; i++)\n    {\n        float distance = abs(numbers[i]\
    \ - numbers[i - 1]);\n        if (distance < min_distance)\n        {\n      \
    \      min_distance = distance;\n            a = numbers[i - 1];\n           \
    \ b = numbers[i];\n        }\n    }\n    return tuple(a, b);\n}", "{\n    float\
    \ diff = 0.0;\n    float minDiff = abs(numbers[0] - numbers[1]);\n    size_t index\
    \ = 0;\n    for (size_t i = 0; i < numbers.length - 1; i++) \n    {\n        diff\
    \ = abs(numbers[i] - numbers[i + 1]);\n        if (diff < minDiff) \n        {\n\
    \            minDiff = diff;\n            index = i;\n        }\n    }\n    return\
    \ tuple(numbers[index], numbers[index + 1]);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float min_difference = std.float.infinity;\n    int min_difference_index\
    \ = 0;\n    for (int i = 0; i < numbers.length - 1; i++)\n    {\n        float\
    \ abs_difference = abs(numbers[i] - numbers[i + 1]);\n        if (abs_difference\
    \ < min_difference)\n        {\n            min_difference = abs_difference;\n\
    \            min_difference_index = i;\n        }\n    }\n    return tuple(numbers[min_difference_index],\
    \ numbers[min_difference_index + 1]);\n}\n \n/*\nFrom a supplied array of strings,\
    \ remove those that contain duplicate characters.\n    >>> remove_duplicate_characters([\"\
    hello\", \"world\", \"goodbye\", \"mars\"])\n    [\"world\", \"mars\"]\n    >>>\
    \ remove_duplicate_characters([\"hello\", \"world\", \"goodbye\", \"mars\", \"\
    goodbye\", \"world\"])\n    [\"mars\"]\n*/\nstring[] remove_duplicate_characters(string[]\
    \ words)\n{\n    HashSet!(string) unique_words = new HashSet!(string)();\n   \
    \ foreach (word; words)\n    {\n        unique_words.insert(word);\n    }\n  \
    \  string[] unique_words_array = unique_words.byKey().array;\n    for (int i =\
    \ 0; i < unique_words_array.length; i++)\n    {\n        for (int j = 0; j < unique_words_array[i].length;\
    \ j++)\n        {\n            char char1 = unique_words_array[i][j];\n      \
    \      for (int k = j + 1; k < unique_words_array[i].length; k++)\n          \
    \  {\n                char char2 = unique_words_array[i][k];\n               \
    \ if (char1 == char2)\n                {\n                    unique_words_array[i]\
    \ = \"\";\n                }\n            }\n        }\n    }\n    return unique_words_array.filter!(a\
    \ => a != \"\");\n}\n \n/*", "{\n    Tuple!(float, float) result;\n    float min_difference\
    \ = 1e20;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        for (int\
    \ j = i + 1; j < numbers.length; j++)\n        {\n            float diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < min_difference)\n            {\n    \
    \            min_difference = diff;\n                result = tuple(numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    Tuple!(float, float) output;\n    double temp = 1000000;\n    foreach(i,\
    \ element; numbers)\n    {\n        foreach(j, secondElement; numbers)\n     \
    \   {\n            if(j != i)\n            {\n                if(abs(element -\
    \ secondElement) < temp)\n                {\n                    output = tuple(element,\
    \ secondElement);\n                    temp = abs(element - secondElement);\n\
    \                }\n            }\n        }\n    }\n    return output;\n}\n/*\n\
    Print the elements in the range [low, high).\n>>> print_range(1,4)\n>>> 1 2 3\n\
    */"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
