name: HumanEval_20_find_closest_elements
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of numbers\
  \ (of length at least two) select and return two that are the closest to each\n\
  \    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float)\
  \ find_closest_elements(float[] numbers) \n"
tests: "unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
  \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) ==\
  \ tuple(2.2, 3.1));\n}\nvoid main(){}"
completions: ["{\n    double min = double.max;\n    size_t minIndex = 0;\n    size_t\
    \ len = numbers.length;\n    for (size_t i = 0; i < len; i++) \n    {\n      \
    \  if (i + 1 < len) \n        {\n            double newDiff = abs(numbers[i] -\
    \ numbers[i + 1]);\n            if (newDiff < min) \n            {\n         \
    \       min = newDiff;\n                minIndex = i;\n            }\n       \
    \ }\n    }\n    return tuple(numbers[minIndex], numbers[minIndex + 1]);\n}", "{\n\
    \    float[] args = numbers[1..$];\n    float smallest_diff = args[0] - numbers[0];\n\
    \    float[] smallest_tuple = [numbers[0], args[0]];\n    float smallest_diff_abs\
    \ = abs(smallest_diff);\n    for (size_t i = 0; i < numbers.length - 1; i++) \n\
    \    {\n        for (size_t j = i + 1; j < numbers.length; j++) \n        {\n\
    \            float diff = numbers[i] - numbers[j];\n            float diff_abs\
    \ = abs(diff);\n            if (diff_abs < smallest_diff_abs) \n            {\n\
    \                smallest_diff = diff;\n                smallest_diff_abs = diff_abs;\n\
    \                smallest_tuple = [numbers[i], numbers[j]];\n            }\n \
    \       }\n    }\n    float[] sorted_tuple = sort(smallest_tuple);\n    return\
    \ tuple(sorted_tuple[0], sorted_tuple[1]);\n}", "{\n    float diff = 99999;\n\
    \    float lower = 99999;\n    float higher = 99999;\n    int i = 0;\n    foreach(float\
    \ x; numbers) \n    {\n        if(i != numbers.length-1) \n        {\n       \
    \     float newdiff = abs(x - numbers[i+1]);\n            if(newdiff < diff) \n\
    \            {\n                diff = newdiff;\n                lower = min(x,\
    \ numbers[i+1]);\n                higher = max(x, numbers[i+1]);\n           \
    \ }\n        }\n        i++;\n    }\n    return tuple(lower, higher);\n}", "{\n\
    \    float minDist = float.infinity;\n    Tuple!(float, float) result = tuple(0.0,\
    \ 0.0);\n    foreach(i, a; numbers)\n    {\n        foreach(j, b; numbers)\n \
    \       {\n            if(i != j)\n            {\n                float dist =\
    \ abs(a - b);\n                if(dist < minDist)\n                {\n       \
    \             minDist = dist;\n                    result = tuple(min(a, b), max(a,\
    \ b));\n                }\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    assert(numbers.length >= 2);\n    int n = numbers.length;\n    float[]\
    \ distance = new float[n];", "{\n    //asume that numbers is not empty\n    float\
    \ min = abs(numbers[0] - numbers[1]);\n    float num1 = numbers[0];\n    float\
    \ num2 = numbers[1];\n    int size = numbers.length;\n    for (int i = 0; i <\
    \ size - 1; i++)\n    {\n        for (int j = i + 1; j < size; j++)\n        {\n\
    \            float temp = abs(numbers[i] - numbers[j]);\n            if (temp\
    \ < min)\n            {\n                min = temp;\n                num1 = numbers[i];\n\
    \                num2 = numbers[j];\n            }\n        }\n    }\n    if (num1\
    \ > num2)\n    {\n        float temp = num1;\n        num1 = num2;\n        num2\
    \ = temp;\n    }\n    return tuple(num1, num2);\n}", "{ \n    auto diff_max =\
    \ 1.0e20;\n    auto diff_min = 1.0e20;\n    auto diff_max_min = 1.0e20;\n    float\
    \ num1 = 0.0;\n    float num2 = 0.0;\n    float num1_max = 0.0;\n    float num2_max\
    \ = 0.0;\n    float num1_min = 0.0;\n    float num2_min = 0.0;\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        for (int j = 0; j < numbers.length;\
    \ j++)\n        {\n            if (i != j)\n            {\n                diff_max\
    \ = max(numbers[i], numbers[j]);\n                diff_min = min(numbers[i], numbers[j]);\n\
    \                if ((diff_max - diff_min) < diff_max_min)\n                {\n\
    \                    diff_max_min = diff_max - diff_min;\n                   \
    \ num1_max = numbers[i];\n                    num2_max = numbers[j];\n       \
    \             num1_min = numbers[i];\n                    num2_min = numbers[j];\n\
    \                }\n            }\n        }\n    }\n    return tuple(num1_min,\
    \ num2_min);\n}", "{\n    float small_difference = float.max;\n    float a = 0.0;\n\
    \    float b = 0.0;\n    foreach(i, num; numbers) \n    {\n        // start at\
    \ the next element, stop when we have looked at all elements\n        foreach_i\
    \ (j, end) \n        {\n            if (j > i) \n            {\n             \
    \   // for each pair of numbers calculate the difference\n                float\
    \ difference = abs(num - numbers[j]);\n                // if this difference is\
    \ less than the previous minimum, update the minimum\n                if (difference\
    \ < small_difference) \n                {\n                    small_difference\
    \ = difference;\n                    a = num;\n                    b = numbers[j];\n\
    \                }\n            }\n        }\n    }\n    return tuple(a, b);\n\
    }", "{\n    float min_distance = 1000000.0;\n    Tuple!(float, float) closest_elements;\n\
    \    foreach(i, number; numbers)\n    {\n        foreach(j, other_number; numbers)\n\
    \        {\n            if(other_number > number)\n            {\n           \
    \     float distance = other_number - number;\n                if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         closest_elements = tuple(number, other_number);\n                }\n\
    \            }\n        }\n    }\n    return closest_elements;\n}", "{\n    float\
    \ closest = 1000;\n    float[] result = null;\n    foreach(float element1; numbers)\n\
    \    {\n        foreach(float element2; numbers)\n        {\n            if(element1\
    \ == element2) continue;\n            float distance = abs(element1 - element2);\n\
    \            if(distance < closest)\n            {\n                closest =\
    \ distance;\n                result = [element1, element2];\n            }\n \
    \       }\n    }\n    return tuple(result[0], result[1]);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float minDistance = DBL_MAX;\n    Tuple!(float, float) result;\n\
    \    for (int i = 0; i < numbers.length - 1; i++)\n    {\n        for (int j =\
    \ i + 1; j < numbers.length; j++)\n        {\n            float dist = abs(numbers[i]\
    \ - numbers[j]);\n            if (dist < minDistance)\n            {\n       \
    \         minDistance = dist;\n                result = tuple(numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    float diff;\n\
    \    float mindiff = INFINITY;\n    int i = 0;\n    int j = 1;\n    for (i = 0;\
    \ i < numbers.length - 1; i++)\n    {\n        for (j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            diff = abs(numbers[i] - numbers[j]);\n        \
    \    if (diff < mindiff)\n            {\n                mindiff = diff;\n   \
    \         }\n        }\n    }\n    float ret1;\n    float ret2;\n    for (i =\
    \ 0; i < numbers.length - 1; i++)\n    {\n        for (j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            diff = abs(numbers[i] - numbers[j]);\n        \
    \    if (diff == mindiff)\n            {\n                ret1 = numbers[i];\n\
    \                ret2 = numbers[j];\n                return tuple(ret1, ret2);\n\
    \            }\n        }\n    }\n}", "{\n    auto closest = tuple(2.0f, 2.0f);\n\
    \    foreach(n1; 0 .. numbers.length - 1)\n    {\n        foreach(n2; n1 + 1 ..\
    \ numbers.length)\n        {\n            auto diff = abs(numbers[n1] - numbers[n2]);\n\
    \            if(abs(closest[0] - closest[1]) > diff)\n            {\n        \
    \        closest = tuple(numbers[n1], numbers[n2]);\n            }\n        }\n\
    \    }\n    return closest;\n}", "{\n    assert(numbers.length>=2);\n    float\
    \ smaller = numbers[0];\n    float larger = numbers[1];\n    float small = abs(numbers[0]-numbers[1]);\n\
    \    for(int i=0;i<numbers.length;i++)\n    {\n        for(int j=i+1;j<numbers.length;j++)\n\
    \        {\n            if(abs(numbers[i]-numbers[j])<small)\n            {\n\
    \                small = abs(numbers[i]-numbers[j]);\n                smaller\
    \ = numbers[i];\n                larger = numbers[j];\n            }\n       \
    \ }\n    }\n    return tuple(smaller,larger);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float min = numbers[0];\n    float minDiff = 1.0e20;\n    float\
    \ max = numbers[0];\n    foreach(i, ref e; numbers) \n    {\n        if (e < min)\
    \ \n        {\n            min = e;\n        }\n        if (e > max) \n      \
    \  {\n            max = e;\n        }\n        if (i > 0) \n        {\n      \
    \      float diff = abs(e - numbers[i - 1]);\n            if (diff < minDiff)\
    \ \n            {\n                minDiff = diff;\n            }\n        }\n\
    \    }\n    return tuple(min, max);\n}", "{\n    float min_distance = numbers[1]\
    \ - numbers[0];\n    float a = numbers[0];\n    float b = numbers[1];\n    for\
    \ (size_t i = 1; i < numbers.length; i++)\n    {\n        float distance = abs(numbers[i]\
    \ - numbers[i - 1]);\n        if (distance < min_distance)\n        {\n      \
    \      min_distance = distance;\n            a = numbers[i - 1];\n           \
    \ b = numbers[i];\n        }\n    }\n    return tuple(a, b);\n}", "{\n    float\
    \ diff = 0.0;\n    float minDiff = abs(numbers[0] - numbers[1]);\n    size_t index\
    \ = 0;\n    for (size_t i = 0; i < numbers.length - 1; i++) \n    {\n        diff\
    \ = abs(numbers[i] - numbers[i + 1]);\n        if (diff < minDiff) \n        {\n\
    \            minDiff = diff;\n            index = i;\n        }\n    }\n    return\
    \ tuple(numbers[index], numbers[index + 1]);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float min_difference = std.float.infinity;\n    int min_difference_index\
    \ = 0;\n    for (int i = 0; i < numbers.length - 1; i++)\n    {\n        float\
    \ abs_difference = abs(numbers[i] - numbers[i + 1]);\n        if (abs_difference\
    \ < min_difference)\n        {\n            min_difference = abs_difference;\n\
    \            min_difference_index = i;\n        }\n    }\n    return tuple(numbers[min_difference_index],\
    \ numbers[min_difference_index + 1]);\n}\n \n/*\nFrom a supplied array of strings,\
    \ remove those that contain duplicate characters.\n    >>> remove_duplicate_characters([\"\
    hello\", \"world\", \"goodbye\", \"mars\"])\n    [\"world\", \"mars\"]\n    >>>\
    \ remove_duplicate_characters([\"hello\", \"world\", \"goodbye\", \"mars\", \"\
    goodbye\", \"world\"])\n    [\"mars\"]\n*/\nstring[] remove_duplicate_characters(string[]\
    \ words)\n{\n    HashSet!(string) unique_words = new HashSet!(string)();\n   \
    \ foreach (word; words)\n    {\n        unique_words.insert(word);\n    }\n  \
    \  string[] unique_words_array = unique_words.byKey().array;\n    for (int i =\
    \ 0; i < unique_words_array.length; i++)\n    {\n        for (int j = 0; j < unique_words_array[i].length;\
    \ j++)\n        {\n            char char1 = unique_words_array[i][j];\n      \
    \      for (int k = j + 1; k < unique_words_array[i].length; k++)\n          \
    \  {\n                char char2 = unique_words_array[i][k];\n               \
    \ if (char1 == char2)\n                {\n                    unique_words_array[i]\
    \ = \"\";\n                }\n            }\n        }\n    }\n    return unique_words_array.filter!(a\
    \ => a != \"\");\n}\n \n/*", "{\n    Tuple!(float, float) result;\n    float min_difference\
    \ = 1e20;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        for (int\
    \ j = i + 1; j < numbers.length; j++)\n        {\n            float diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < min_difference)\n            {\n    \
    \            min_difference = diff;\n                result = tuple(numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    Tuple!(float, float) output;\n    double temp = 1000000;\n    foreach(i,\
    \ element; numbers)\n    {\n        foreach(j, secondElement; numbers)\n     \
    \   {\n            if(j != i)\n            {\n                if(abs(element -\
    \ secondElement) < temp)\n                {\n                    output = tuple(element,\
    \ secondElement);\n                    temp = abs(element - secondElement);\n\
    \                }\n            }\n        }\n    }\n    return output;\n}\n/*\n\
    Print the elements in the range [low, high).\n>>> print_range(1,4)\n>>> 1 2 3\n\
    */", "{\n    float[] closest;\n    float min_delta = INFINITY;\n    foreach(float\
    \ number1; numbers) \n    {\n        foreach(float number2; numbers) \n      \
    \  {\n            float delta = abs(number1 - number2);\n            if (delta\
    \ < min_delta) \n            {\n                closest = [number1, number2];\n\
    \                min_delta = delta;\n            }\n        }\n    }\n    assert(closest.length\
    \ == 2);\n    return closest[0] < closest[1] ? tuple(closest[0], closest[1]) :\
    \ tuple(closest[1], closest[0]);\n}", "{\n    assert(numbers.length >= 2);\n \
    \   auto diffs = [ numbers[i] - numbers[i + 1] for (i = 0 .. numbers.length -\
    \ 1) ];\n    auto idx = argmin(diffs);\n    return tuple(min(numbers[idx], numbers[idx\
    \ + 1]), max(numbers[idx], numbers[idx + 1]));\n}", "{\n\tfloat smallest = numbers[0];\n\
    \tfloat closest = abs(numbers[0] - numbers[1]);\n\t\n\tfor (size_t i = 0; i <\
    \ numbers.length; i++)\n\t{\n\t\tfor (size_t j = 0; j < numbers.length; j++)\n\
    \t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tif (abs(numbers[i] - numbers[j]) <\
    \ closest)\n\t\t\t\t{\n\t\t\t\t\tclosest = abs(numbers[i] - numbers[j]);\n\t\t\
    \t\t\tsmallest = numbers[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn tuple(smallest,\
    \ smallest + closest);\n}", "{\n    Tuple!(float, float) tmp, res;\n    res =\
    \ tuple(numbers[0], numbers[1]);\n    for (size_t i = 0; i < numbers.length; i++)\n\
    \    {\n        for (size_t j = i + 1; j < numbers.length; j++)\n        {\n \
    \           tmp = tuple(numbers[i], numbers[j]);\n            if (abs(tmp[0] -\
    \ tmp[1]) < abs(res[0] - res[1]))\n            {\n                res = tmp;\n\
    \            }\n        }\n    }\n    return res;\n}", "{\n    assert(numbers.length\
    \ >= 2);", "{\n\tfloat prev = numbers[0];\n\tfloat closest = prev;\n\tfloat closest_prev\
    \ = prev;\n\tfor (size_t i = 1; i < numbers.length; i++) \n\t{\n\t\tfloat diff\
    \ = abs(numbers[i] - prev);\n\t\tif (diff < closest) \n\t\t{\n\t\t\tclosest =\
    \ diff;\n\t\t\tclosest_prev = prev;\n\t\t}\n\t\tprev = numbers[i];\n\t}\n\treturn\
    \ tuple(closest_prev, prev);\n}", "{\n    float a = 0.0;\n    float b = 0.0;\n\
    \    float min = 99.0;\n    int minIndex = 0;\n    foreach(i, num; numbers)\n\
    \    {\n        if(i > 0)\n        {\n            float diff = abs(num - numbers[i-1]);\n\
    \            if(diff < min)\n            {\n                min = diff;\n    \
    \            minIndex = i;\n            }\n        }\n    }\n    a = numbers[minIndex-1];\n\
    \    b = numbers[minIndex];\n    Tuple!(float, float) result = tuple(a, b);\n\
    \    return result;\n}", "{\n    assert(numbers.length >= 2);\n    if (numbers.length\
    \ == 2)\n        return tuple(numbers[0], numbers[1]);\n    \n    float delta\
    \ = abs(numbers[0] - numbers[1]);\n    float minOne = numbers[0];\n    float minTwo\
    \ = numbers[1];\n    for (uint i = 0; i < numbers.length - 1; i++) \n    {\n \
    \       for (uint j = i + 1; j < numbers.length; j++) \n        {\n          \
    \  float curDelta = abs(numbers[i] - numbers[j]);\n            if (curDelta <\
    \ delta) \n            {\n                delta = curDelta;\n                minOne\
    \ = numbers[i];\n                minTwo = numbers[j];\n            }\n       \
    \ }\n    }\n    return tuple(minOne, minTwo);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float diff = numbers[1] - numbers[0];\n    int index1 = 0;\n   \
    \ int index2 = 1;\n    foreach(int i; 1 .. numbers.length - 1) \n    {\n     \
    \   if(abs(numbers[i] - numbers[i + 1]) < diff) \n        {\n            diff\
    \ = abs(numbers[i] - numbers[i + 1]);\n            index1 = i;\n            index2\
    \ = i + 1;\n        }\n    }\n    return tuple(numbers[index1], numbers[index2]);\n\
    }", "{\n    float[] sorted_numbers = numbers[].dup.sort;\n    float[] diff = sorted_numbers[0..sorted_numbers.length\
    \ - 1].zip(sorted_numbers[1..sorted_numbers.length]).map!((a, b) => abs(a - b));\n\
    \    float min = diff.min;\n    int min_index = diff.indexOf(min);\n    Tuple!(float,\
    \ float) found_tuple = tuple(sorted_numbers[min_index], sorted_numbers[min_index\
    \ + 1]);\n    return found_tuple;\n}\n \n // From a supplied array of numbers\
    \ (of length at least two) select and return two that are the most distant\n //\
    \ from each other and return them in order (smaller number, larger number).\n\
    \ // >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n // tuple(1.0,\
    \ 5.0)\n \nTuple!(float, float) find_furthest_elements(float[] numbers) \n{\n\
    \    float[] sorted_numbers = numbers[].dup.sort;\n    float[] diff = sorted_numbers[0..sorted_numbers.length\
    \ - 1].zip(sorted_numbers[1..sorted_numbers.length]).map!((a, b) => abs(a - b));\n\
    \    float max = diff.max;\n    int max_index = diff.indexOf(max);\n    Tuple!(float,\
    \ float) found_tuple = tuple(sorted_numbers[max_index], sorted_numbers[max_index\
    \ + 1]);\n    return found_tuple;\n}\n \n \n /*\n In a supplied string, replace\
    \ all punctuation characters with a space. Return the new string.\n >>> replace_punctuation(\"\
    Hello, world!\")\n \"Hello  world \"\n */\n string replace_punctuation(string\
    \ a) \n {\n     string new_string = a.replace(\",.\", \" \");\n     return new_string;\n\
    \ }\n \n /*\n Return the length of the longest word in a supplied string\n >>>\
    \ find", "{\n    float mindiff = abs(numbers[0] - numbers[1]);\n    auto minpair\
    \ = tuple(numbers[0], numbers[1]);\n    for (size_t i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (size_t j = i + 1; j < numbers.length; j++)\n     \
    \   {\n            float diff = abs(numbers[i] - numbers[j]);\n            if\
    \ (diff < mindiff)\n            {\n                mindiff = diff;\n         \
    \       minpair = tuple(numbers[i], numbers[j]);\n            }\n        }\n \
    \   }\n    return minpair;\n}", "{\n    auto r1 = tuple(numbers[0], numbers[1]);\n\
    \    float md = abs(numbers[0] - numbers[1]);\n    foreach(i, ref a; numbers)\
    \ \n    {\n        foreach(j, ref b; numbers) \n        {\n            if (i ==\
    \ j) \n                continue;\n            auto d = abs(a - b);\n         \
    \   if (d < md) \n            {\n                md = d;\n                r1 =\
    \ tuple(a, b);\n            }\n        }\n    }\n    return r1;\n}", "{\n    if\
    \ (numbers.length <= 1) \n    {\n        throw new Exception(\"must have at least\
    \ two numbers\");\n    }\n    if (numbers.length == 2) \n    {\n        return\
    \ tuple(numbers[0], numbers[1]);\n    }\n    float closest = numbers[1] - numbers[0];\n\
    \    int index = 0;\n    for (int i = 1; i < numbers.length - 1; i++) \n    {\n\
    \        float abs = numbers[i + 1] - numbers[i];\n        if (abs < closest)\
    \ \n        {\n            closest = abs;\n            index = i;\n        }\n\
    \    }\n    return tuple(numbers[index], numbers[index + 1]);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float m = min(numbers[0], numbers[1]);\n    float M = max(numbers[0],\
    \ numbers[1]);\n    float mn = abs(numbers[0] - numbers[1]);\n    foreach(n; numbers[2..$])\n\
    \    {\n        float nn = abs(n - M);\n        if (nn < mn) \n        {\n   \
    \         mn = nn;\n            m = min(n, M);\n            M = max(n, M);\n \
    \       }\n    }\n    return tuple(m, M);\n}", "{\n    assert(numbers.length >=\
    \ 2);\n    assert(numbers.length % 2 == 0);\n    assert(numbers[0] <= numbers[1]);\n\
    \    auto min_elements = tuple(numbers[0], numbers[1]);\n    for (int i = 0; i\
    \ < numbers.length - 1; i++) \n    {\n        if (abs(numbers[i] - numbers[i +\
    \ 1]) < abs(min_elements[0] - min_elements[1])) \n        {\n            min_elements\
    \ = tuple(numbers[i], numbers[i + 1]);\n        }\n    }\n    return min_elements;\n\
    }", "{\n    float min_diff = float.infinity;\n    float min_1, min_2;\n    float[]\
    \ numbers_copy = numbers[];\n    sort(numbers_copy);\n    foreach( i, n ; numbers_copy\
    \ )\n    {\n        if(i < numbers_copy.length - 1)\n        {\n            float\
    \ diff = abs(numbers_copy[i] - numbers_copy[i+1]);\n            if(diff < min_diff)\n\
    \            {\n                min_diff = diff;\n                min_1 = numbers_copy[i];\n\
    \                min_2 = numbers_copy[i+1];\n            }\n        }\n    }\n\
    \    return tuple(min_1, min_2);\n}", "{\n\tassert(numbers.length >= 2);\n\tfloat\
    \ smallestDistance = float.max;\n\tfloat smallerValue = float.max;\n\tfloat largerValue\
    \ = float.max;\n\tfor (uint i = 0; i < numbers.length - 1; i++)\n\t{\n\t\tfor\
    \ (uint j = i + 1; j < numbers.length; j++)\n\t\t{\n\t\t\tfloat distance = abs(numbers[i]\
    \ - numbers[j]);\n\t\t\tif (distance < smallestDistance)\n\t\t\t{\n\t\t\t\tsmallestDistance\
    \ = distance;\n\t\t\t\tsmallerValue = min(numbers[i], numbers[j]);\n\t\t\t\tlargerValue\
    \ = max(numbers[i], numbers[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn tuple(smallerValue,\
    \ largerValue);\n}", "{\n\timmutable len = numbers.length;\n\tassert(len >= 2);\n\
    \tfloat minDiff = numbers[1] - numbers[0];\n\tTuple!(float, float) closestElements\
    \ = tuple(numbers[0], numbers[1]);\n\tfor (int i = 1; i < len - 1; i++)\n\t{\n\
    \t\tfloat diff = numbers[i + 1] - numbers[i];\n\t\tif (diff < minDiff)\n\t\t{\n\
    \t\t\tminDiff = diff;\n\t\t\tclosestElements = tuple(numbers[i], numbers[i + 1]);\n\
    \t\t}\n\t}\n\treturn closestElements;\n}\n/*\nWrite a function that returns the\
    \ letter associated with a given telephone number.\n    >>> letter_for_number(2)\n\
    \    'ABC'\n    >>> letter_for_number(3)\n    'DEF'\n    >>> letter_for_number(8)\n\
    \    'TUV'\n*/\nstring letter_for_number(int number) \n{\n\timmutable char[] letters\
    \ = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\timmutable int n =\
    \ letters.length;\n\tif (number < 2 || number > 9)\n\t{\n\t\treturn \"\";\n\t\
    }\n\telse\n\t{\n\t\tstring ret = \"\";\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\
    {\n\t\t\tint index = (number - 2) * 3 + i;\n\t\t\tret ~= letters[index];\n\t\t\
    }\n\t\treturn ret;\n\t}\n}\n/*\nWrite a function that returns the shortest string\
    \ in a supplied array of strings. If two strings are the same length,\n    then\
    \ return the first of them.\n    >>> shortest_string([\"first\", \"second\", \"\
    third\", \"a\", \"bb\"])\n    \"a\"\n    >>> shortest_string([\"first", "{\n \
    \   assert(numbers.length>=2);\n    //T[] xs = numbers;\n    auto ret = tuple(numbers[0],\
    \ numbers[1]);\n    auto min_diff = abs(numbers[0] - numbers[1]);\n    foreach(i,\
    \ x; numbers)\n    {\n        foreach(j, y; numbers[i+1..$])\n        {\n    \
    \        auto d = abs(x - y);\n            if(d < min_diff)\n            {\n \
    \               ret = tuple(x, y);\n                min_diff = d;\n          \
    \  }\n        }\n    }\n    return ret;\n}", "{\n  float currentClosest = 0.0;\n\
    \  float currentClosest2 = 0.0;\n  float currentDistance = 0.0;\n  float currentDistance2\
    \ = 0.0;\n  float smallestDistance = 1e6;\n  float smallestDistance2 = 1e6;\n\
    \  for (int i = 0; i < numbers.length; i++)\n  {\n    for (int j = 0; j < numbers.length;\
    \ j++)\n    {\n      if (i == j)\n      {\n        continue;\n      }\n      currentDistance\
    \ = abs(numbers[i] - numbers[j]);\n      if (currentDistance < smallestDistance)\n\
    \      {\n        currentClosest = numbers[i];\n        currentClosest2 = numbers[j];\n\
    \        currentDistance2 = smallestDistance;\n        smallestDistance = currentDistance;\n\
    \      }\n      else if (currentDistance < smallestDistance2)\n      {\n     \
    \   currentDistance2 = currentDistance;\n      }\n    }\n  }\n  if (currentClosest\
    \ < currentClosest2)\n  {\n    return tuple(currentClosest, currentClosest2);\n\
    \  }\n  else\n  {\n    return tuple(currentClosest2, currentClosest);\n  }\n}",
  "{\n    float closest = abs(numbers[0] - numbers[1]);\n    int smallest = 0;\n \
    \   int largest = 1;\n    for (int a = 0; a < numbers.length; a++) \n    {\n \
    \       for (int b = a + 1; b < numbers.length; b++) \n        {\n           \
    \ float dist = abs(numbers[a] - numbers[b]);\n            if (dist < closest)\
    \ \n            {\n                closest = dist;\n                smallest =\
    \ a;\n                largest = b;\n            }\n        }\n    }\n    return\
    \ tuple(numbers[smallest], numbers[largest]);\n}", "{\n    float first, second;\n\
    \    float diff, min = float.max;\n    foreach(i, f; numbers) \n    {\n      \
    \  if (i != 0) \n        {\n            diff = abs(f - numbers[i - 1]);\n    \
    \        if (diff < min) \n            {\n                min = diff;\n      \
    \          first = numbers[i - 1];\n                second = f;\n            }\n\
    \        }\n    }\n    return tuple(first, second);\n}", "{\n\tassert(numbers.length\
    \ > 1);\n\t\n\tfloat[] absolute_diffs = [0.0f];\n\t\n\tforeach(n; numbers)\n\t\
    {\n\t\tabsolute_diffs ~= abs(numbers[$-1] - n);\n\t}\n\t\n\tabsolute_diffs.length--;\n\
    \t\n\tint[] min_index = [0];\n\t\n\tforeach(i; absolute_diffs)\n\t{\n\t\tif(absolute_diffs[min_index[0]]\
    \ > absolute_diffs[i])\n\t\t{\n\t\t\tmin_index[0] = i;\n\t\t}\n\t}\n\t\n\treturn\
    \ tuple(numbers[min_index[0]], numbers[min_index[0] + 1]);\n}\n/*\nFrom a supplied\
    \ array of numbers (of length at least two) return the second largest one.\n \
    \   >>> find_second_largest([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    4.0\n    >>>\
    \ find_second_largest([1.0, 2.0, 3.0, 4.0, 5.0, -1.0])\n    4.0\n    >>> find_second_largest([1.0,\
    \ 1.0, 1.0, 1.0, 1.0, 1.0])\n    1.0\n*/\nfloat find_second_largest(float[] numbers)\
    \ \n{\n\tassert(numbers.length > 1);\n\t\n\tfloat[] largest = [float.min];\n\t\
    \n\tforeach(n; numbers)\n\t{\n\t\tif(largest[0] < n)\n\t\t{\n\t\t\tlargest[0]\
    \ = n;\n\t\t}\n\t}\n\t\n\tfloat[] second_largest = [largest[0]];\n\t\n\tforeach(n;\
    \ numbers)\n\t{\n\t\tif(n != largest[0] && second_largest[0] < n)\n\t\t{\n\t\t\
    \tsecond_largest[0] = n;\n\t\t}\n\t}\n\t\n\treturn second_largest[0];\n}\n/*\n\
    Return the sum of the numbers in", "{\n    assert(numbers.length >= 2);\n    Tuple!(float,\
    \ float) result = tuple(numbers[0], numbers[1]);\n    float current_distance =\
    \ fabs(numbers[0] - numbers[1]);\n    for (int i = 0; i < numbers.length - 1;\
    \ i++) \n    {\n        float distance = fabs(numbers[i] - numbers[i + 1]);\n\
    \        if (distance < current_distance) \n        {\n            current_distance\
    \ = distance;\n            result = tuple(numbers[i], numbers[i + 1]);\n     \
    \   }\n    }\n    return result;\n}", "{\n    assert(numbers.length >= 2);\n \
    \   float min_distance = INFINITY;\n    auto i = 0;\n    Tuple!(float, float)\
    \ closest_numbers;\n    foreach(number; numbers) \n    {\n        if (i == 0)\
    \ \n        {\n            i++;\n            continue;\n        }\n        float\
    \ diff = abs(number - numbers[i - 1]);\n        if (diff < min_distance) \n  \
    \      {\n            min_distance = diff;\n            closest_numbers = tuple(min(number,\
    \ numbers[i - 1]), max(number, numbers[i - 1]));\n        }\n        i++;\n  \
    \  }\n    return closest_numbers;\n}\n \n/*\n  Given a number n, return the sum\
    \ of the squares of the first n numbers (from 1 to n inclusive)\n  >>> sum_of_squares(10)\n\
    \  385\n  >>> sum_of_squares(1)\n  1\n*/", "{\n    assert(numbers.length >= 2);\n\
    \    float diff = abs(numbers[0] - numbers[1]);\n    Tuple!(float, float) tup;\n\
    \    tup.field1 = numbers[0];\n    tup.field2 = numbers[1];\n    float tup_diff\
    \ = abs(tup.field1 - tup.field2);\n    for (int i = 0; i < numbers.length; i++)\
    \ \n    {\n        for (int j = i + 1; j < numbers.length; j++) \n        {\n\
    \            diff = abs(numbers[i] - numbers[j]);\n            if (diff < tup_diff)\
    \ \n            {\n                tup_diff = diff;\n                tup.field1\
    \ = numbers[i];\n                tup.field2 = numbers[j];\n            }\n   \
    \     }\n    }\n    return tup;\n}\n/*\n * Test case\n *\n */", "{\n    float\
    \ x = 0.0f;\n    float y = 0.0f;\n    float temp = 0.0f;\n    float minDistance\
    \ = cast(float) INFINITY;\n    float currentDistance = 0.0f;\n    foreach(index1,\
    \ elem1; numbers)\n    {\n        foreach(index2, elem2; numbers)\n        {\n\
    \            if(index1 != index2)\n            {\n                currentDistance\
    \ = abs(elem1 - elem2);\n                if(currentDistance < minDistance)\n \
    \               {\n                    x = elem1;\n                    y = elem2;\n\
    \                    minDistance = currentDistance;\n                }\n     \
    \       }\n        }\n    }\n    return tuple(x, y);\n}\n/*\n From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ closest to each\n    other and return them in order (smaller number, larger\
    \ number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  \
    \  tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
    \    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements_slow(float[]\
    \ numbers) \n{\n    float x = 0.0f;\n    float y = 0.0f;\n    float temp = 0.0f;\n\
    \    float minDistance = cast(float) INFINITY;\n    float currentDistance = 0.0f;\n\
    \    foreach(index1, elem1; numbers)\n    {\n        foreach(index2, elem2; numbers)\n\
    \        {\n            if(index1 != index2)\n            {\n                currentDistance\
    \ = abs(elem1 - elem2);\n                if(currentDistance < minDistance)\n \
    \               {\n                    x = elem1;\n                    y = elem2;\n\
    \                    minDistance = currentDistance;\n                }\n     \
    \       }\n        }\n", "{\n    import std.algorithm;\n    import std.range;\n\
    \    auto smallest_range = numbers[1] - numbers[0];\n    auto pair = tuple(numbers[0],\
    \ numbers[1]);\n    auto min = minElement(numbers);\n    foreach(n; min.dropOne())\n\
    \    {\n        auto range = n - min.front;\n        if(abs(range) < smallest_range)\n\
    \        {\n            smallest_range = range;\n            pair = tuple(min.front,\
    \ n);\n        }\n    }\n    return pair;\n}", "{\n    float[] pair = new float[2];\n\
    \    float diff = float.infinity;\n    for (size_t i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (size_t j = i + 1; j < numbers.length; j++)\n     \
    \   {\n            float diff_;\n            if ((diff_ = abs(numbers[i] - numbers[j]))\
    \ < diff)\n            {\n                diff = diff_;\n                pair[0]\
    \ = numbers[i];\n                pair[1] = numbers[j];\n            }\n      \
    \  }\n    }\n    return tuple(pair[0], pair[1]);\n}", "{\n    float min_diff =\
    \ DBL_MAX;\n    float a = -1.0;\n    float b = -1.0;\n    for (size_t i = 0; i\
    \ < numbers.length; i++)\n    {\n        for (size_t j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            float diff = abs(numbers[i] - numbers[j]);\n  \
    \          if (diff < min_diff)\n            {\n                min_diff = diff;\n\
    \                a = numbers[i];\n                b = numbers[j];\n          \
    \  }\n        }\n    }\n    assert(a != -1.0 && b != -1.0);\n    return tuple(a,\
    \ b);\n}", "{\n    assert(numbers.length >= 2);\n    float min = abs(numbers[0]\
    \ - numbers[1]);\n    float argMin = numbers[0];\n    float argMin2 = numbers[1];\n\
    \    for (int i = 0; i < numbers.length - 1; i++)\n    {\n        float k = abs(numbers[i]\
    \ - numbers[i + 1]);\n        if (k < min)\n        {\n            min = k;\n\
    \            argMin = numbers[i];\n            argMin2 = numbers[i + 1];\n   \
    \     }\n    }\n    if (argMin > argMin2)\n    {\n        return tuple(argMin2,\
    \ argMin);\n    }\n    else\n    {\n        return tuple(argMin, argMin2);\n \
    \   }\n}", "{\n    double d = abs(numbers[0] - numbers[1]);\n    auto closest_pair\
    \ = tuple(numbers[0], numbers[1]);\n    for (uint i = 0; i < numbers.length; i++)\n\
    \    {\n        for (uint j = i + 1; j < numbers.length; j++)\n        {\n   \
    \         if (abs(numbers[i] - numbers[j]) < d)\n            {\n             \
    \   d = abs(numbers[i] - numbers[j]);\n                closest_pair = tuple(numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    return closest_pair;\n}",
  "{\n    float small = numbers[0];\n    float large = numbers[1];\n    float distance\
    \ = large - small;\n    foreach(num; numbers) \n    {\n        float smaller =\
    \ min(num, small);\n        float larger = max(num, small);\n        float dist\
    \ = larger - smaller;\n        if (dist < distance) \n        {\n            distance\
    \ = dist;\n            small = smaller;\n            large = larger;\n       \
    \ }\n    }\n    return tuple(small, large);\n}", "{\n    float minDiff = abs(numbers[0]\
    \ - numbers[1]);\n    Tuple!(float, float) closestPair = tuple(numbers[0], numbers[1]);\n\
    \    foreach(n1; 1..numbers.length - 1)\n    {\n        foreach(n2; n1 + 1..numbers.length)\n\
    \        {\n            if(abs(numbers[n1] - numbers[n2]) < minDiff)\n       \
    \     {\n                minDiff = abs(numbers[n1] - numbers[n2]);\n         \
    \       closestPair = tuple(numbers[n1], numbers[n2]);\n            }\n      \
    \  }\n    }\n    return closestPair;\n}", "{\n    assert(numbers.length >= 2);\n\
    \    float first = numbers[0];\n    float second = numbers[1];\n    float diff\
    \ = abs(first - second);\n    foreach(i, value; numbers)\n    {\n        foreach(j,\
    \ value2; numbers)\n        {\n            if(j == i) continue;\n            float\
    \ newDiff = abs(value - value2);\n            if(newDiff < diff)\n           \
    \ {\n                first = value;\n                second = value2;\n      \
    \          diff = newDiff;\n            }\n        }\n    }\n    return tuple(first,\
    \ second);\n}", "{ \n    assert(numbers.length>1);\n    float closest = abs(numbers[0]-numbers[1]);\n\
    \    auto a = numbers[0];\n    auto b = numbers[1];\n    foreach(i, float ni;\
    \ numbers)\n    {\n        foreach(j, float nj; numbers)\n        {\n        \
    \    if(i!=j)\n            {\n                auto val = abs(ni-nj);\n       \
    \         if(val<closest)\n                {\n                    closest = val;\n\
    \                    a = ni;\n                    b = nj;\n                }\n\
    \            }\n        }\n    }\n    return tuple(a,b);\n}", "{\n    Tuple!(float,\
    \ float) tuple = tuple(numbers[0], numbers[1]);\n    for (size_t i = 0; i < numbers.length;\
    \ i++) \n    {\n        float element = numbers[i];\n        for (size_t j = 0;\
    \ j < numbers.length; j++) \n        {\n            if (i != j) \n           \
    \ {\n                float closest = abs(tuple[0] - tuple[1]);\n             \
    \   float compareTo = abs(element - numbers[j]);\n                if (compareTo\
    \ < closest) \n                {\n                    tuple = tuple(min(element,\
    \ numbers[j]), max(element, numbers[j]));\n                }\n            }\n\
    \        }\n    }\n    return tuple;\n}\n \n/*\n Given an array of user-defined\
    \ objects (of at least two different types) determine the type to which a majority\n\
    \    of them belong.\n    >>> class A { }\n    >>> class B { }\n    >>> class\
    \ C { }\n    >>> find_majority_type!A([A(), A(), B(), C()])\n    A\n    >>> find_majority_type!A([A(),\
    \ A(), B(), C(), A()])\n    A\n    >>> find_majority_type!A([A(), A(), B(), C(),\
    \ A(), B()])\n    A\n    >>> find_majority_type!A([A(), A(), B(), C(), A(), B(),\
    \ B()])\n    B\n    >>> find_majority_type!A([A(), A(), B(), C(), A(), B(), B(),\
    \ C()])\n    B\n    >>> find_majority_type!A([A(), A(), B(), C(), A(), B(), B(),\
    \ C(), C()])\n    C\n*/\nA find_majority_type(A[] objects) \n{\n    TypeInfo[]\
    \ types = new TypeInfo[objects.length];\n    size_t a_count = 0;\n    size_t b_count\
    \ = 0;\n    size_t c_count = 0;\n    for (size_t i = 0; i < objects.length; i++)\
    \ \n    {\n        TypeInfo info = objects[i].classinfo;\n        if (info ==\
    \ A.class", "{\n    assert(numbers.length >= 2);\n    assert(numbers.length %\
    \ 2 == 0);", "{\n  assert(numbers.length >= 2);\n  // we assume the first two\
    \ are the closest\n  float n1 = numbers[0];\n  float n2 = numbers[1];\n  float\
    \ d = abs(n1 - n2);\n  // iterate through every other number to determine if it's\
    \ better\n  for (size_t i = 2; i < numbers.length; i++)\n  {\n    for (size_t\
    \ j = i + 1; j < numbers.length; j++)\n    {\n      float v = abs(numbers[i] -\
    \ numbers[j]);\n      if (v < d)\n      {\n        d = v;\n        n1 = numbers[i];\n\
    \        n2 = numbers[j];\n      }\n    }\n  }\n  return tuple(n1, n2);\n}", "{\n\
    \    assert(numbers.length >= 2);\n    float curmin = abs(numbers[0] - numbers[1]);\n\
    \    float a = numbers[0];\n    float b = numbers[1];\n    for (int i = 0; i <\
    \ numbers.length; i++)\n    {\n        for (int j = i+1; j < numbers.length; j++)\n\
    \        {\n            float cur = abs(numbers[i] - numbers[j]);\n          \
    \  if (cur < curmin)\n            {\n                curmin = cur;\n         \
    \       a = numbers[i];\n                b = numbers[j];\n            }\n    \
    \    }\n    }\n    return tuple(a, b);\n}\n \n/*", "{\n    float min = abs(numbers[0]\
    \ - numbers[1]);\n    Tuple!(float, float) closestPair;\n    foreach(index, value1;\
    \ numbers)\n    {\n        foreach(value2; numbers[index+1..$])\n        {\n \
    \           if(abs(value1 - value2) < min)\n            {\n                closestPair\
    \ = tuple(value1, value2);\n                min = abs(value1 - value2);\n    \
    \        }\n        }\n    }\n    return closestPair;\n}", "{\n    return find_closest_elements_rec(numbers,\
    \ numbers.length);\n}", "{\n    if (numbers.length < 2)\n        return tuple(0.0,\
    \ 0.0);\n    if (numbers.length == 2)\n        return tuple(numbers[0], numbers[1]);\n\
    \    \n    float smallest_diff = abs(numbers[0] - numbers[1]);\n    int smallest_diff_idx1\
    \ = 0;\n    int smallest_diff_idx2 = 1;\n    \n    for (int i = 0; i < numbers.length\
    \ - 1; i++)\n    {\n        for (int j = i + 1; j < numbers.length; j++)\n   \
    \     {\n            float diff = abs(numbers[i] - numbers[j]);\n            if\
    \ (diff < smallest_diff)\n            {\n                smallest_diff = diff;\n\
    \                smallest_diff_idx1 = i;\n                smallest_diff_idx2 =\
    \ j;\n            }\n        }\n    }\n    \n    return tuple(numbers[smallest_diff_idx1],\
    \ numbers[smallest_diff_idx2]);\n}", "{\n    assert(numbers.length >= 2);\n  \
    \  //Start with first two numbers in array and compare them\n    float[2] diff\
    \ = [numbers[1] - numbers[0], numbers[1] - numbers[0]];\n    foreach(i, number1;\
    \ numbers)\n    {\n        foreach(j, number2; numbers)\n        {\n         \
    \   //If difference is smaller than current smallest difference and both numbers\
    \ are different, \n            //update smallest difference and record which numbers\
    \ they are.\n            if(abs(number1 - number2) < abs(diff[0]) && number1 !=\
    \ number2)\n            {\n                diff[0] = number1 - number2;\n    \
    \            diff[1] = number1;\n                diff[2] = number2;\n        \
    \    }\n        }\n    }\n    //Return smallest difference and numbers in order\n\
    \    return tuple(min(diff[1], diff[2]), max(diff[1], diff[2]));\n}", "{\n   \
    \ float dmin = float.max;\n    float i_min = 0.0;\n    float j_min = 0.0;\n  \
    \  for (size_t i = 0; i < numbers.length; i++)\n    {\n        for (size_t j =\
    \ i + 1; j < numbers.length; j++)\n        {\n            float d = abs(numbers[i]\
    \ - numbers[j]);\n            if (d < dmin)\n            {\n                dmin\
    \ = d;\n                i_min = numbers[i];\n                j_min = numbers[j];\n\
    \            }\n        }\n    }\n    if (i_min < j_min)\n    {\n        return\
    \ tuple(i_min, j_min);\n    }\n    else\n    {\n        return tuple(j_min, i_min);\n\
    \    }\n}\n \n/*\n \n Given an integer and an array of integers, return the location\
    \ of the integer in the array,\n    or -1 if the integer is not in the array.\n\
    \    >>> find_integer_location(3, [1, 2, 3, 4, 5])\n    2\n    >>> find_integer_location(6,\
    \ [1, 2, 3, 4, 5])\n    -1\n*/", "{\n    assert(numbers.length >= 2);\n    float\
    \ closest = abs(numbers[0] - numbers[1]);\n    size_t i = 0;\n    size_t j = 1;\n\
    \    for (size_t k = 0; k < numbers.length; k++) \n    {\n        for (size_t\
    \ l = k + 1; l < numbers.length; l++) \n        {\n            if (abs(numbers[k]\
    \ - numbers[l]) < closest) \n            {\n                closest = abs(numbers[k]\
    \ - numbers[l]);\n                i = k;\n                j = l;\n           \
    \ }\n        }\n    }\n    return tuple(numbers[i], numbers[j]);\n}\n/*\nRun-length\
    \ encoding is a simple form of data compression in which runs of data are stored\
    \ as a single data value and\ncount.\n>>> rle_encoding([1, 2, 2, 2, 3, 3, 3, 3,\
    \ 3, 3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,", "{\n    if (numbers.length < 2)\n \
    \       throw new Exception(\"numbers.length < 2\");\n    if (numbers.length ==\
    \ 2)\n        return tuple(numbers[0], numbers[1]);\n    // sort numbers and find\
    \ closest elements\n    numbers.sort();\n    auto min_pair = tuple(numbers[0],\
    \ numbers[1]);\n    auto min_diff = abs(numbers[0] - numbers[1]);\n    for (size_t\
    \ i = 1; i < numbers.length - 1; i++) \n    {\n        if (numbers[i + 1] - numbers[i]\
    \ < min_diff) \n        {\n            min_pair = tuple(numbers[i], numbers[i\
    \ + 1]);\n            min_diff = numbers[i + 1] - numbers[i];\n        }\n   \
    \ }\n    return min_pair;\n}", "{\n    assert(numbers.length >= 2);\n    float\
    \ min = abs(numbers[0] - numbers[1]);\n    int first = 0;\n    int second = 1;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        for (int j = i +\
    \ 1; j < numbers.length; j++)\n        {\n            float diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < min)\n            {\n               \
    \ min = diff;\n                first = i;\n                second = j;\n     \
    \       }\n        }\n    }\n    return tuple(numbers[first], numbers[second]);\n\
    }", "{\n\tsize_t n = numbers.length;\n\tassert(n > 1);\n\t\n\tfloat min;\n\tfloat\
    \ minp;\n\tfloat minv;\n\t\n\tmin = numbers[1] - numbers[0];\n\tminp = numbers[0];\n\
    \tminv = numbers[1];\n\t\n\tfor (size_t i = 1; i < n; i++) \n\t{\n\t\tfloat diff\
    \ = numbers[i] - numbers[i-1];\n\t\tif (diff < min) \n\t\t{\n\t\t\tmin = diff;\n\
    \t\t\tminp = numbers[i-1];\n\t\t\tminv = numbers[i];\n\t\t}\n\t}\n\t\n\treturn\
    \ tuple(minp, minv);\n}", "{\n    assert(numbers.length >= 2);\n    float min\
    \ = numeric_limits!float.infinity;\n    float a = 0.0;\n    float b = 0.0;\n \
    \   for (uint i = 0; i < numbers.length; i++)\n    {\n        for (uint j = i\
    \ + 1; j < numbers.length; j++)\n        {\n            if (abs(numbers[i] - numbers[j])\
    \ < min)\n            {\n                min = abs(numbers[i] - numbers[j]);\n\
    \                a = numbers[i];\n                b = numbers[j];\n          \
    \  }\n        }\n    }\n    return tuple(a, b);\n}\n// / runnable", "{ \n    Tuple!(float,\
    \ float) closest_elements; \n    float min_difference = float.infinity; \n   \
    \ // check each pair \n    for (auto i = 0; i < numbers.length; i++) \n    { \n\
    \        for (auto j = i + 1; j < numbers.length; j++) \n        { \n        \
    \    float difference = abs(numbers[i] - numbers[j]); \n            if (difference\
    \ < min_difference) \n            { \n                min_difference = difference;\
    \ \n                closest_elements = tuple(numbers[i], numbers[j]); \n     \
    \       } \n        } \n    } \n    return closest_elements; \n} ", "{\n    assert(numbers.length\
    \ >= 2);\n    // this code is buggy\n    float closest_delta = abs(numbers[0]\
    \ - numbers[1]);\n    float a = numbers[0];\n    float b = numbers[1];\n    for\
    \ (int i = 0; i < numbers.length; i++) \n    {\n        for (int j = i + 1; j\
    \ < numbers.length; j++) \n        {\n            float delta = abs(numbers[i]\
    \ - numbers[j]);\n            if (delta < closest_delta) \n            {\n   \
    \             closest_delta = delta;\n                a = numbers[i];\n      \
    \          b = numbers[j];\n            }\n        }\n    }\n    return tuple(a,\
    \ b);\n}", "{\n    assert(numbers.length >= 2);\n    float minDiff = abs(numbers[0]\
    \ - numbers[1]);\n    int minDiffIndex = 0;\n    for (int i = 0; i < numbers.length\
    \ - 1; i++)\n    {\n        float diff = abs(numbers[i] - numbers[i + 1]);\n \
    \       if (diff < minDiff)\n        {\n            minDiff = diff;\n        \
    \    minDiffIndex = i;\n        }\n    }\n    return tuple(numbers[minDiffIndex],\
    \ numbers[minDiffIndex + 1]);\n}", "{\n    float smallestDiff;\n    float smallest1;\n\
    \    float smallest2;\n    float currentDiff;\n    float current1;\n    float\
    \ current2;\n    //sort the list\n    sort(numbers);\n    //set the first pair\
    \ as the ones to return \n    current1 = numbers[0];\n    current2 = numbers[1];\n\
    \    currentDiff = current2 - current1;\n    smallest1 = current1;\n    smallest2\
    \ = current2;\n    smallestDiff = currentDiff;\n    //loop through the rest of\
    \ the numbers in the list\n    for(uint i = 1; i < numbers.length; i++) \n   \
    \ {\n        current1 = numbers[i];\n        current2 = numbers[i+1];\n      \
    \  currentDiff = current2 - current1;\n        //if the current pair has a smaller\
    \ difference than the previous smallest,\n        //set the current pair as the\
    \ new smallest pair\n        if(currentDiff < smallestDiff) \n        {\n    \
    \        smallest1 = current1;\n            smallest2 = current2;\n          \
    \  smallestDiff = currentDiff;\n        }\n    }\n    return tuple(smallest1,\
    \ smallest2);\n}", "{\n    float min=0.0,max=0.0;\n    if(numbers.length<2)\n\
    \        return tuple(min,max);\n    float diff=abs(numbers[0]-numbers[1]);\n\
    \    foreach(a,b; zip(numbers[0..$-1],numbers[1..$]))\n    {\n        if(abs(a-b)<diff)\n\
    \        {\n            diff=abs(a-b);\n            min=a;\n            max=b;\n\
    \        }\n    }\n    return tuple(min,max);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float minDiff = float.max;\n    float minDiffNum1 = 0;\n    float\
    \ minDiffNum2 = 0;\n    for (uint i = 0; i < numbers.length; i++)\n    {\n   \
    \     for (uint j = i + 1; j < numbers.length; j++)\n        {\n            float\
    \ diff = abs(numbers[i] - numbers[j]);\n            if (diff < minDiff)\n    \
    \        {\n                minDiff = diff;\n                minDiffNum1 = numbers[i];\n\
    \                minDiffNum2 = numbers[j];\n            }\n        }\n    }\n\
    \    return tuple(minDiffNum1, minDiffNum2);\n}", "{ \n  float small = numbers[0];\n\
    \  float large = numbers[1];\n  size_t n = numbers.length;\n  float distance =\
    \ abs(large - small);\n  for (size_t i = 0; i < n; i++) \n  {\n    for (size_t\
    \ j = i + 1; j < n; j++) \n    {\n      float nd = abs(numbers[j] - numbers[i]);\n\
    \      if (nd < distance) \n      {\n        small = numbers[i];\n        large\
    \ = numbers[j];\n        distance = nd;\n      }\n    }\n  }\n  return tuple(small,\
    \ large);\n}", "{\n    assert(numbers.length > 1);\n    float minDifference =\
    \ INFINITY;\n    size_t minAIndex = 0;\n    size_t minBIndex = 0;\n    for (size_t\
    \ i = 0; i < numbers.length; i++)\n    {\n        for (size_t j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            float difference = abs(numbers[i] - numbers[j]);\n\
    \            if (difference < minDifference)\n            {\n                minDifference\
    \ = difference;\n                minAIndex = i;\n                minBIndex = j;\n\
    \            }\n        }\n    }\n    return tuple(numbers[minAIndex], numbers[minBIndex]);\n\
    }\n/*", "{\n    float temp;\n    if (numbers.length < 2)\n    {\n        throw\
    \ new Exception(\"Not enough elements\");\n    }\n    float[] closest = [numbers[0],\
    \ numbers[1]];\n    if (numbers[0] > numbers[1])\n    {\n        temp = numbers[0];\n\
    \        numbers[0] = numbers[1];\n        numbers[1] = temp;\n    }\n    for\
    \ (int i = 1; i < numbers.length - 1; i++)\n    {\n        if (abs(numbers[i]\
    \ - numbers[i + 1]) < abs(closest[0] - closest[1]))\n        {\n            closest[0]\
    \ = numbers[i];\n            closest[1] = numbers[i + 1];\n        }\n    }\n\
    \    return tuple(closest[0], closest[1]);\n}", "{\n    float minDiff = abs(numbers[0]\
    \ - numbers[1]);\n    int idxA = 0;\n    int idxB = 1;\n    for (int i = 0; i\
    \ < numbers.length; i++)\n    {\n        for (int j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            float diff = abs(numbers[i] - numbers[j]);\n  \
    \          if (diff < minDiff)\n            {\n                minDiff = diff;\n\
    \                idxA = i;\n                idxB = j;\n            }\n       \
    \ }\n    }\n    return tuple(numbers[idxA], numbers[idxB]);\n}", "{\n    immutable\
    \ float min_distance = abs(numbers[0] - numbers[1]);\n    immutable float tmp;\n\
    \    immutable float num1 = numbers[0];\n    immutable float num2 = numbers[1];\n\
    \    immutable size_t min_index = 0;\n    immutable size_t min_index2 = 1;\n \
    \   for (size_t i = 0; i < numbers.length - 1; i++) \n    {\n        for (size_t\
    \ j = i + 1; j < numbers.length; j++) \n        {\n            tmp = abs(numbers[i]\
    \ - numbers[j]);\n            if (tmp < min_distance) \n            {\n      \
    \          min_distance = tmp;\n                min_index = i;\n             \
    \   min_index2 = j;\n            }\n        }\n    }\n    if (numbers[min_index]\
    \ < numbers[min_index2]) \n    {\n        return tuple(numbers[min_index], numbers[min_index2]);\n\
    \    } \n    else \n    {\n        return tuple(numbers[min_index2], numbers[min_index]);\n\
    \    }\n}", "{\n\tfloat firstElement = numbers[0];\n\tfloat secondElement = numbers[1];\n\
    \t\n\tfor(int i = 0; i < numbers.length; i++) \n\t{\n\t\tfor(int j = i + 1; j\
    \ < numbers.length; j++) \n\t\t{\n\t\t\tif(abs(numbers[i] - numbers[j]) < abs(firstElement\
    \ - secondElement)) \n\t\t\t{\n\t\t\t\tfirstElement = numbers[i];\n\t\t\t\tsecondElement\
    \ = numbers[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn tuple(firstElement, secondElement);\n\
    }", "{\n    auto result = tuple(numbers[0], numbers[1]);\n    auto diff = abs(result[0]\
    \ - result[1]);\n    auto n1 = numbers[0];\n    foreach(n; numbers[1..$])\n  \
    \  {\n        auto new_diff = abs(n - n1);\n        if (new_diff < diff)\n   \
    \     {\n            result = tuple(n1, n);\n            diff = new_diff;\n  \
    \      }\n        n1 = n;\n    }\n    return result;\n}\n/*\n From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ farthest from each\n    other and return them in order (smaller number, larger\
    \ number).\n    >>> find_farthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n \
    \   tuple(1.0, 5.0)\n    >>> find_farthest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0])\n    tuple(1.0, 5.0)\n    \n*/\nTuple!(float, float) find_farthest_elements(float[]\
    \ numbers) \n{\n    auto result = tuple(numbers[0], numbers[1]);\n    auto diff\
    \ = abs(result[0] - result[1]);\n    auto n1 = numbers[0];\n    foreach(n; numbers[1..$])\n\
    \    {\n        auto new_diff = abs(n - n1);\n        if (new_diff > diff)\n \
    \       {\n            result = tuple(n1, n);\n            diff = new_diff;\n\
    \        }\n        n1 = n;\n    }\n    return result;\n}\n/*\n From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ closest to each\n    other and return them in order (smaller number, larger\
    \ number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  \
    \  tuple(2.0, 2.2)\n    >>> find", "{\n\tfloat min_diff = abs(numbers[0] - numbers[1]);\n\
    \tfloat min_diff_number = numbers[0];\n\tfloat next_min_diff_number = numbers[1];\n\
    \tfloat current_diff;\n\tfor (int i = 0; i < numbers.length; i++)\n\t{\n\t\tfor\
    \ (int j = i+1; j < numbers.length; j++)\n\t\t{\n\t\t\tcurrent_diff = abs(numbers[i]\
    \ - numbers[j]);\n\t\t\tif (current_diff < min_diff)\n\t\t\t{\n\t\t\t\tmin_diff\
    \ = current_diff;\n\t\t\t\tmin_diff_number = numbers[i];\n\t\t\t\tnext_min_diff_number\
    \ = numbers[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn tuple(min_diff_number, next_min_diff_number);\n\
    }", "{\n    float[] arr = [float.infinity, float.infinity];\n    for (int i =\
    \ 0; i < numbers.length; i++)\n    {\n        if(abs(numbers[i] - numbers[i+1])\
    \ < abs(arr[0] - arr[1])) \n        {\n            arr[0] = numbers[i];\n    \
    \        arr[1] = numbers[i+1];\n        }\n    }\n    return tuple(arr[0], arr[1]);\n\
    }\n \n/*", "{ \n    int indexA = 0; \n    int indexB = 1; \n    float smallestDiff\
    \ = abs(numbers[indexA] - numbers[indexB]); \n    foreach (int i, float a; numbers)\
    \ \n    { \n        foreach (int j, float b; numbers) \n        { \n         \
    \   if (i != j) \n            { \n                float diff = abs(a - b); \n\
    \                if (diff < smallestDiff) \n                { \n             \
    \       indexA = i; \n                    indexB = j; \n                    smallestDiff\
    \ = diff; \n                } \n            } \n        } \n    } \n    return\
    \ tuple(numbers[indexA], numbers[indexB]); \n} ", "{\n    assert(numbers.length\
    \ >= 2);\n    //find closest element\n    auto range = numbers[1..$];\n    float\
    \ dif = abs(numbers[0] - range[0]);\n    float j = numbers[0];\n    foreach(num;\
    \ range)\n    {\n        if(abs(numbers[0] - num) < dif)\n        {\n        \
    \    dif = abs(numbers[0] - num);\n            j = num;\n        }\n    }\n  \
    \  //find second closest element\n    float res1 = float.max;\n    float res2\
    \ = float.max;\n    foreach(num; numbers)\n    {\n        if(num != j)\n     \
    \   {\n            if(abs(num - j) < dif)\n            {\n                dif\
    \ = abs(num - j);\n                res1 = num;\n                res2 = j;\n  \
    \          }\n        }\n    }\n    return tuple(res1, res2);\n}\n/*\n Given an\
    \ array of positive numbers, return two that are the closest to each other in\
    \ the order that they\n    appear in the array (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n*/\nTuple!(float, float) find_closest_elements(float[] numbers) \n{\n\
    \    assert(numbers.length >= 2);\n    //find closest element\n    auto range\
    \ = numbers[1..$];\n    float dif = abs(numbers[0] - range[0]);\n    float j =\
    \ numbers[0];\n    foreach(num; range)\n    {\n        if(abs(numbers[0] - num)\
    \ < dif)\n        {\n            dif = abs(numbers[0] - num);\n            j =\
    \ num;\n        }\n    }\n    //find second", "{\n    import std.typecons;\n \
    \   assert(numbers.length >= 2);\n    float a, b;\n    a = numbers[0];\n    b\
    \ = numbers[1];\n    for (size_t i = 0; i < numbers.length - 1; i++) \n    {\n\
    \        for (size_t j = i + 1; j < numbers.length; j++) \n        {\n       \
    \     if (abs(numbers[i] - numbers[j]) < abs(a - b)) \n            {\n       \
    \         a = numbers[i];\n                b = numbers[j];\n            }\n  \
    \      }\n    }\n    return tuple(a, b);\n}", "{\n    static assert(numbers.length\
    \ >= 2);\n    Tuple!(float, float) closest = tuple(numbers[0], numbers[1]);\n\
    \    float min_diff = abs(closest[0] - closest[1]);\n    float diff;\n    foreach(i,\
    \ num1; numbers)\n    {\n        foreach(j, num2; numbers[i + 1 .. $])\n     \
    \   {\n            diff = abs(num1 - num2);\n            if (diff < min_diff)\n\
    \            {\n                closest = tuple(num1, num2);\n               \
    \ min_diff = diff;\n            }\n        }\n    }\n    return closest;\n}",
  "{\n    float[] result = new float[2];\n    float tmp = 0.0;\n    float first =\
    \ numbers[0];\n    float second = numbers[1];\n    float value = abs(first - second);\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        for (int j = i +\
    \ 1; j < numbers.length; j++)\n        {\n            tmp = abs(numbers[i] - numbers[j]);\n\
    \            if (tmp < value)\n            {\n                value = tmp;\n \
    \               first = numbers[i];\n                second = numbers[j];\n  \
    \          }\n        }\n    }\n    result[0] = first;\n    result[1] = second;\n\
    \    return tuple(result[0], result[1]);\n}", "{ \n    // assert(numbers.length\
    \ >= 2, \"Array length must be at least 2\"); \n    if (numbers.length < 2) \n\
    \        return tuple(0.0, 0.0); \n    auto closest_pair = tuple(numbers[0], numbers[1]);\
    \ \n    float closest_diff = closest_pair[1] - closest_pair[0]; \n    foreach\
    \ (i, a; numbers[0 .. $ - 1]) \n    { \n        foreach (j, b; numbers[i + 1 ..\
    \ $]) \n        { \n            float diff = abs(a - b); \n            if (diff\
    \ < closest_diff) \n            { \n                closest_pair = tuple(a, b);\
    \ \n                closest_diff = diff; \n            } \n        } \n    } \n\
    \    return closest_pair; \n}", "{\n    float min = absolute(numbers[0] - numbers[1]);\n\
    \    int index = 0;\n    for (int i = 1; i < numbers.length - 1; i++) \n    {\n\
    \        float current = absolute(numbers[i] - numbers[i + 1]);\n        if (current\
    \ < min) \n        {\n            min = current;\n            index = i;\n   \
    \     }\n    }\n    return tuple(numbers[index], numbers[index + 1]);\n}", "{\n\
    \    // O(n^2) time complexity\n    float ret_a, ret_b;\n    double min_diff =\
    \ INFINITY;\n    foreach(a, b; numbers)\n    {\n        foreach(x; numbers)\n\
    \        {\n            float diff = abs(x - a);\n            if (diff < min_diff)\n\
    \            {\n                ret_a = a;\n                ret_b = x;\n     \
    \           min_diff = diff;\n            }\n        }\n    }\n    return tuple(ret_a,\
    \ ret_b);\n}", "{\n    assert(numbers.length >= 2);\n    float previous = numbers[0];\n\
    \    float current;\n    float smallestDifference = INFINITY;\n    Tuple!(float,\
    \ float) closestTuple = tuple(numbers[0], numbers[1]);\n    for (int i = 1; i\
    \ < numbers.length; i++)\n    {\n        current = numbers[i];\n        float\
    \ difference = abs(current - previous);\n        if (difference < smallestDifference)\n\
    \        {\n            smallestDifference = difference;\n            closestTuple\
    \ = tuple(previous, current);\n        }\n        previous = current;\n    }\n\
    \    return closestTuple;\n}", "{\n    float min = cast(float)INFINITY;\n    Tuple!(float,\
    \ float) minTuple = tuple(0.0, 0.0);\n    foreach(i, v; numbers)\n    {\n    \
    \    foreach(j, w; numbers)\n        {\n            if(i != j)\n            {\n\
    \                float abs = abs(v - w);\n                if(abs < min)\n    \
    \            {\n                    min = abs;\n                    minTuple =\
    \ tuple(min(v, w), max(v, w));\n                }\n            }\n        }\n\
    \    }\n    return minTuple;\n}", "{\n    int first, second;\n    float distance,\
    \ minDistance = INFINITY;\n    foreach(i, element; numbers)\n    {\n        foreach(j,\
    \ element2; numbers)\n        {\n            if(i != j)\n            {\n     \
    \           distance = abs(element - element2);\n                if(distance <\
    \ minDistance)\n                {\n                    minDistance = distance;\n\
    \                    first = i;\n                    second = j;\n           \
    \     }\n            }\n        }\n    }\n    return tuple(numbers[first], numbers[second]);\n\
    }", "{ \n    assert(numbers.length > 1);\n    float smallestDiff = 9999999999;\n\
    \    float first = 0;\n    float second = 0;\n    foreach(index, number; numbers)\n\
    \    {\n        if(index == 0)\n        {\n            first = number;\n     \
    \       second = numbers[index + 1];\n            smallestDiff = abs(first - second);\n\
    \        }\n        else if(index == numbers.length - 1)\n        {\n        \
    \    continue;\n        }\n        else\n        {\n            float diff = abs(number\
    \ - numbers[index + 1]);\n            if(diff < smallestDiff)\n            {\n\
    \                first = number;\n                second = numbers[index + 1];\n\
    \                smallestDiff = diff;\n            }\n        }\n    }\n    Tuple!(float,\
    \ float) result = tuple(first, second);\n    return result;\n}", "{\n    assert(numbers.length\
    \ > 1);\n    float result1 = 0;\n    float result2 = 0;\n    float temp = 0;\n\
    \    float difference = 10000;\n    //float \n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (int j = i+1; j < numbers.length; j++)\n        {\n\
    \            temp = abs(numbers[i] - numbers[j]);\n            if (temp < difference)\n\
    \            {\n                difference = temp;\n                result1 =\
    \ numbers[i];\n                result2 = numbers[j];\n            }\n        \
    \    else if (temp == difference)\n            {\n                if (numbers[i]\
    \ < result1)\n                {\n                    result1 = numbers[i];\n \
    \                   result2 = numbers[j];\n                }\n            }\n\
    \        }\n    }\n    return tuple(result1, result2);\n}", "{\n    if (numbers.length\
    \ < 2)\n        throw new Exception(\"array must have at least two elements\"\
    );\n    size_t i, j;\n    float d, min_d;\n    Tuple!(float, float) closest;\n\
    \    min_d = abs(numbers[0] - numbers[1]);\n    closest = tuple(numbers[0], numbers[1]);\n\
    \    for (i = 0; i < numbers.length; i++)\n    {\n        for (j = i + 1; j <\
    \ numbers.length; j++)\n        {\n            d = abs(numbers[i] - numbers[j]);\n\
    \            if (d < min_d)\n            {\n                min_d = d;\n     \
    \           closest = tuple(numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    return closest;\n}", "{\n    auto smallest_diff = numbers[1] - numbers[0];\n\
    \    auto output = tuple(numbers[0], numbers[1]);\n    foreach(n; numbers) \n\
    \    {\n        foreach(m; numbers) \n        {\n            if (n > m)\n    \
    \        {\n                auto diff = n - m;\n                if (diff < smallest_diff)\n\
    \                {\n                    smallest_diff = diff;\n              \
    \      output = tuple(m, n);\n                }\n            }\n        }\n  \
    \  }\n    return output;\n}", "{\n    assert(numbers.length > 1);\n    float[]\
    \   diffs;\n    float   min, max;\n    float   tempDiff;\n    float   minDiff;\n\
    \    int i,j;\n    // create an array of the differences between each number and\
    \ its neighbour\n    // the first and last elements will be ignored, as they have\
    \ no neighbour\n    diffs = new float[numbers.length-1];\n    for (i=0; i<diffs.length;\
    \ i++)\n    {\n        diffs[i] = abs(numbers[i] - numbers[i+1]);\n    }\n   \
    \ // find the smallest difference, which will give the two closest numbers\n \
    \   minDiff = diffs[0];\n    for (i=1; i<diffs.length; i++)\n    {\n        if\
    \ (diffs[i] < minDiff)\n        {\n            minDiff = diffs[i];\n        }\n\
    \    }\n    // find the first number in the array of differences that matches\
    \ the smallest difference\n    // the index of that number is the index of the\
    \ smaller number in the original array\n    for (i=0; i<diffs.length; i++)\n \
    \   {\n        if (diffs[i] == minDiff)\n        {\n            break;\n     \
    \   }\n    }\n    // the smaller number is in i, the larger number is in i+1\n\
    \    return tuple(numbers[i], numbers[i+1]);\n}", "{\n    assert(numbers.length\
    \ > 1);\n    size_t min_index1 = 0;\n    size_t min_index2 = 1;\n    float min_delta\
    \ = abs(numbers[0] - numbers[1]);\n    for (size_t i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (size_t j = i + 1; j < numbers.length; j++)\n     \
    \   {\n            if (abs(numbers[i] - numbers[j]) < min_delta)\n           \
    \ {\n                min_delta = abs(numbers[i] - numbers[j]);\n             \
    \   min_index1 = i;\n                min_index2 = j;\n            }\n        }\n\
    \    }\n    return tuple(numbers[min_index1], numbers[min_index2]);\n}", "{\n\t\
    Tuple!(float, float) ClosestPair;\n\tClosestPair = tuple(numbers[0], numbers[1]);\n\
    \tfloat ClosestDifference = abs(ClosestPair[0] - ClosestPair[1]);\n\tfor (int\
    \ i = 0; i < numbers.length; i++)\n\t{\n\t\tfor (int j = i + 1; j < numbers.length;\
    \ j++)\n\t\t{\n\t\t\tfloat Difference = abs(numbers[i] - numbers[j]);\n\t\t\t\
    if (Difference < ClosestDifference)\n\t\t\t{\n\t\t\t\tClosestDifference = Difference;\n\
    \t\t\t\tClosestPair = tuple(numbers[i], numbers[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\
    return ClosestPair;\n}", "{\n    float first = numbers[0];\n    float second =\
    \ numbers[1];\n    float minimum = abs(first - second);\n    foreach(n; 1..numbers.length)\n\
    \    {\n        float temp = abs(numbers[n] - numbers[n-1]);\n        if(temp\
    \ < minimum)\n        {\n            minimum = temp;\n            first = numbers[n-1];\n\
    \            second = numbers[n];\n        }\n    }\n    return tuple(first, second);\n\
    }", "{ \n    import std.algorithm; \n    //Sort the array\n    numbers.sort;\n\
    \    //Get the length of the array\n    int len = numbers.length;\n    //Create\
    \ a tuple to return\n    auto tuple_to_return = tuple(numbers[0], numbers[1]);\n\
    \    //Current closest value\n    float close_value = abs(numbers[0] - numbers[1]);\n\
    \    //Loop through the array\n    for(int i = 0; i < len; i++)\n    {\n     \
    \   if(i + 1 < len)\n        {\n            //Get the value\n            float\
    \ current_value = abs(numbers[i] - numbers[i + 1]);\n            //If it is less,\
    \ then set it and set the tuple\n            if(current_value < close_value)\n\
    \            {\n                close_value = current_value;\n               \
    \ tuple_to_return = tuple(numbers[i], numbers[i + 1]);\n            }\n      \
    \  }\n    }\n    return tuple_to_return;\n}\n \n/*\n    From a supplied array\
    \ of numbers return only those that are evenly divisible by the supplied divisor.\n\
    \    >>> find_divisible_by_n([3, 4, 5, 6, 7, 8, 9, 10], 2)\n    [4, 6, 8, 10]\n\
    \    >>> find_divisible_by_n([3, 4, 5, 6, 7, 8, 9, 10], 3)\n    [3, 6, 9]\n  \
    \  >>> find_divisible_by_n([3, 4, 5, 6, 7, 8, 9, 10], 5)\n    [5, 10]\n*/", "{\n\
    \    static if (numbers.length < 2) {\n        return tuple(numbers[0], numbers[0]);\n\
    \    }\n    else {\n        float temp_distance = abs(numbers[0] - numbers[1]);\n\
    \        Tuple!(float, float) closest_elements = tuple(numbers[0], numbers[1]);\n\
    \        for (int i = 0; i < numbers.length; i++) {\n            for (int j =\
    \ i + 1; j < numbers.length; j++) {\n                if (abs(numbers[i] - numbers[j])\
    \ < temp_distance) {\n                    temp_distance = abs(numbers[i] - numbers[j]);\n\
    \                    closest_elements = tuple(numbers[i], numbers[j]);\n     \
    \           }\n            }\n        }\n        return closest_elements;\n  \
    \  }\n}", "{\n    assert(numbers.length >= 2);\n    float min_diff = float.infinity;\n\
    \    float[] min_pair = null;\n    for (float i = 0; i < numbers.length; i++)\
    \ \n    {\n        for (float j = i + 1; j < numbers.length; j++) \n        {\n\
    \            float diff = abs(numbers[i] - numbers[j]);\n            if (diff\
    \ < min_diff) \n            {\n                min_diff = diff;\n            \
    \    min_pair = [numbers[i], numbers[j]];\n            }\n        }\n    }\n \
    \   return tuple(min_pair[0], min_pair[1]);\n}", "{ \n    float min_diff = real.infinity;\
    \ \n    float a; \n    float b; \n    foreach (n1; numbers) { \n        foreach\
    \ (n2; numbers) { \n            if (abs(n1 - n2) < min_diff) { \n            \
    \    min_diff = abs(n1 - n2); \n                a = n1; \n                b =\
    \ n2; \n            } \n        } \n    } \n    return tuple(a, b); \n}", "{\n\
    \    assert(numbers.length >= 2);\n    float min_diff = abs(numbers[0] - numbers[1]);\n\
    \    float result_a = numbers[0];\n    float result_b = numbers[1];\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        for (int j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            float diff = abs(numbers[i] - numbers[j]);\n  \
    \          if (diff < min_diff)\n            {\n                min_diff = diff;\n\
    \                result_a = numbers[i];\n                result_b = numbers[j];\n\
    \            }\n        }\n    }\n    return tuple(result_a, result_b);\n}", "{\n\
    \    // your code here\n    auto closestNumber1 = numbers[0];\n    auto closestNumber2\
    \ = numbers[1];\n    auto minDiff = abs(closestNumber1 - closestNumber2);\n  \
    \  for (auto i = 0; i < numbers.length; i++)\n    {\n        for (auto j = i+1;\
    \ j < numbers.length; j++)\n        {\n            auto diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < minDiff)\n            {\n           \
    \     minDiff = diff;\n                closestNumber1 = numbers[i];\n        \
    \        closestNumber2 = numbers[j];\n            }\n        }\n    }\n    return\
    \ tuple(closestNumber1, closestNumber2);\n}", "{\n    assert(numbers.length >=\
    \ 2);\n    float[] differences = new float[numbers.length - 1];\n    for (int\
    \ i = 0; i < numbers.length - 1; i++)\n    {\n        differences[i] = abs(numbers[i]\
    \ - numbers[i + 1]);\n    }\n    int index_min = 0;\n    for (int i = 0; i < differences.length;\
    \ i++)\n    {\n        if (differences[i] < differences[index_min])\n        {\n\
    \            index_min = i;\n        }\n    }\n    return tuple(numbers[index_min],\
    \ numbers[index_min + 1]);\n}", "{\n    static assert(numbers.length >= 2);\n\
    \    float min = abs(numbers[0] - numbers[1]);\n    Tuple!(float, float) result\
    \ = tuple(numbers[0], numbers[1]);\n    for (uint i = 0; i < numbers.length; i++)\
    \ \n    {\n        for (uint j = i + 1; j < numbers.length; j++) \n        {\n\
    \            float cur = abs(numbers[i] - numbers[j]);\n            if (cur <\
    \ min) \n            {\n                min = cur;\n                result = tuple(numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    // calculating the closest elements in an array to each other\n    float[]\
    \ array = numbers[];\n    int len = array.length;\n    float diff = array[1] -\
    \ array[0];\n    float a = array[0];\n    float b = array[1];\n    for (int i\
    \ = 0; i < len; i++)\n    {\n        for (int j = i + 1; j < len; j++)\n     \
    \   {\n            if (array[j] - array[i] < diff)\n            {\n          \
    \      a = array[i];\n                b = array[j];\n                diff = b\
    \ - a;\n            }\n        }\n    }\n    return tuple(a, b);\n}\n/*\nFrom\
    \ a supplied array of numbers (of length at least two) select and return two that\
    \ are the farthest from each\nother and return them in order (smaller number,\
    \ larger number).\n>>> find_farthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
    tuple(1.0, 5.0)\n>>> find_farthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
    tuple(1.0, 5.0)\n*/\nTuple!(float, float) find_farthest_elements(float[] numbers)\
    \ \n{\n    // calculating the farthest elements in an array from each other\n\
    \    float[] array = numbers[];\n    int len = array.length;\n    float diff =\
    \ array[1] - array[0];\n    float a = array[0];\n    float b = array[1];\n   \
    \ for (int i = 0; i < len; i++)\n    {\n        for (int j = i + 1; j < len; j++)\n\
    \        {\n            if (array[j] - array[i] > diff)\n            {\n     \
    \           a = array[i];\n                b = array[j];\n                diff\
    \ = b - a;\n            }\n        }\n    }\n    return tuple(a, b);\n}", "{\n\
    \    float minDiff;\n    Tuple!(float, float) result;\n    assert(numbers.length\
    \ > 1);", "{\n    assert(numbers.length >= 2);\n    float minDiff = float.max;\n\
    \    float minA = 0.0;\n    float minB = 0.0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        float n = numbers[i];\n        for (int j = i + 1; j <\
    \ numbers.length; j++)\n        {\n            float m = numbers[j];\n       \
    \     float diff = abs(n - m);\n            if (diff < minDiff)\n            {\n\
    \                minDiff = diff;\n                minA = min(n, m);\n        \
    \        minB = max(n, m);\n            }\n        }\n    }\n    return tuple(minA,\
    \ minB);\n}", "{\n    assert(numbers.length >= 2);\n    return zip(numbers[1..$],\
    \ numbers[0..$-1])\n        .map!(pair => (pair[0] - pair[1]).abs)\n        .minIndex\n\
    \        .reduce!((prev, x) => (prev[0] + x[0], prev[1] + x[1]))\n        .map!(pair\
    \ => (numbers[pair[0]], numbers[pair[1]]))\n        .map!(pair => (min(pair[0],\
    \ pair[1]), max(pair[0], pair[1])))\n        .reduce!((a, b) => a);\n}", "{\n\
    \    assert(numbers.length >= 2);\n    float min = numbers[0];\n    float second\
    \ = numbers[1];\n    if (min > second)\n    {\n        min = numbers[1];\n   \
    \     second = numbers[0];\n    }\n    float dist = second - min;\n    for (size_t\
    \ i = 2; i < numbers.length; i++)\n    {\n        float n = numbers[i];\n    \
    \    if (n < min)\n        {\n            if (min - n < dist)\n            {\n\
    \                dist = min - n;\n                second = min;\n            \
    \    min = n;\n            }\n        }\n        else if (n > second)\n      \
    \  {\n            if (n - second < dist)\n            {\n                dist\
    \ = n - second;\n                min = second;\n                second = n;\n\
    \            }\n        }\n        else\n        {\n            if (min - n <\
    \ dist)\n            {\n                dist = min - n;\n                second\
    \ = n;\n            }\n            else if (n - second < dist)\n            {\n\
    \                dist = n - second;\n                min = n;\n            }\n\
    \        }\n    }\n    return tuple(min, second);\n}", "{\n    float min_delta\
    \ = abs(numbers[0] - numbers[1]);\n    float a = numbers[0];\n    float b = numbers[1];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        for (int j = i\
    \ + 1; j < numbers.length; j++) \n        {\n            float delta = abs(numbers[i]\
    \ - numbers[j]);\n            if (delta < min_delta) \n            {\n       \
    \         min_delta = delta;\n                a = numbers[i];\n              \
    \  b = numbers[j];\n            }\n        }\n    }\n    return tuple(a, b);\n\
    }", "{\n    //{   Tuple!(float, float) result;\n    //    float diff=999.0;\n\
    \    //    for(uint i=0; i<numbers.length; ++i)\n    //    {\n    //        for(uint\
    \ j=i+1; j<numbers.length; ++j)\n    //        {\n    //            if(abs(numbers[i]-numbers[j])<diff)\n\
    \    //            {\n    //                diff=abs(numbers[i]-numbers[j]);\n\
    \    //                result=tuple(numbers[i], numbers[j]);\n    //         \
    \   }\n    //        }\n    //    }\n    //    return result;\n    //}\n    float\
    \ n1, n2;\n    float diff=999.0;\n    for(uint i=0; i<numbers.length; ++i)\n \
    \   {\n        for(uint j=i+1; j<numbers.length; ++j)\n        {\n           \
    \ if(abs(numbers[i]-numbers[j])<diff)\n            {\n                diff=abs(numbers[i]-numbers[j]);\n\
    \                n1=numbers[i];\n                n2=numbers[j];\n            }\n\
    \        }\n    }\n    return tuple(n1, n2);\n}", "{\n    double difference =\
    \ 1e40;\n    Tuple!(double, double) closestNumbers = Tuple!(double, double)(1e40,\
    \ 1e40);\n    for (int i = 0; i < numbers.length; i++)\n    {\n        for (int\
    \ j = i+1; j < numbers.length; j++)\n        {\n            if (abs(numbers[i]\
    \ - numbers[j]) < difference)\n            {\n                difference = abs(numbers[i]\
    \ - numbers[j]);\n                closestNumbers = Tuple!(double, double)(numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    return Tuple!(float, float)(cast(float)closestNumbers[0],\
    \ cast(float)closestNumbers[1]);\n}", "{\n    float minDiff = 9999.0;\n    float[]\
    \ result = new float[2];\n    foreach(float x; numbers)\n    {\n        foreach(float\
    \ y; numbers)\n        {\n            if(x == y)\n                continue;\n\
    \            if(abs(x - y) < minDiff)\n            {\n                minDiff\
    \ = abs(x - y);\n                result[0] = min(x, y);\n                result[1]\
    \ = max(x, y);\n            }\n        }\n    }\n    return tuple(result[0], result[1]);\n\
    }", "{ \n    if (numbers.length == 2) \n    {\n        if (numbers[0] < numbers[1])\n\
    \            return tuple(numbers[0], numbers[1]);\n        else\n           \
    \ return tuple(numbers[1], numbers[0]);\n    }\n    else\n    {\n        float\
    \ minNum = numbers[0];\n        float maxNum = numbers[0];\n        for (int i\
    \ = 1; i < numbers.length; i++)\n        {\n            if (numbers[i] < minNum)\
    \ minNum = numbers[i];\n            if (numbers[i] > maxNum) maxNum = numbers[i];\n\
    \        }\n        float delta = maxNum - minNum;\n        for (int i = 0; i\
    \ < numbers.length; i++)\n        {\n            for (int j = i+1; j < numbers.length;\
    \ j++)\n            {\n                float temp = abs(numbers[i] - numbers[j]);\n\
    \                if (temp < delta)\n                {\n                    minNum\
    \ = min(numbers[i], numbers[j]);\n                    maxNum = max(numbers[i],\
    \ numbers[j]);\n                    delta = temp;\n                }\n       \
    \     }\n        }\n        return tuple(minNum, maxNum);\n    }\n}", "{\n   \
    \ float[] difference = new float[];\n    foreach(n; numbers)\n    {\n        difference\
    \ ~= abs(numbers[0] - n);\n    }\n    size_t min = minIndex(difference);\n   \
    \ return tuple(numbers[0], numbers[min]);\n}", "{ \n    float min = 3;\n    float\
    \ a, b;\n    foreach(i, n; numbers)\n    {\n        foreach(j, m; numbers)\n \
    \       {\n            if(i != j)\n            {\n                float diff =\
    \ abs(n - m);\n                if(diff < min)\n                {\n           \
    \         min = diff;\n                    a = n;\n                    b = m;\n\
    \                }\n            }\n        }\n    }\n    return tuple(a, b);\n\
    }", "{\n    float first, second;\n    float diff;\n    float diffMin = abs(numbers[0]\
    \ - numbers[1]);\n    float diffTemp;\n    first = numbers[0];\n    second = numbers[1];\n\
    \    foreach(i, e1; numbers)\n    {\n        foreach(e2; numbers[i + 1 .. $])\n\
    \        {\n            diffTemp = abs(e1 - e2);\n            if(diffTemp < diffMin)\n\
    \            {\n                diffMin = diffTemp;\n                first = e1;\n\
    \                second = e2;\n            }\n        }\n    }\n    return tuple(first,\
    \ second);\n}", "{\n    float closestDistance = float.max;\n    float closestNumber\
    \ = float.max;\n    float farthestNumber = float.max;\n    for (size_t i = 0;\
    \ i < numbers.length; i++)\n    {\n        for (size_t j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            float difference = abs(numbers[i] - numbers[j]);\n\
    \            if (difference < closestDistance)\n            {\n              \
    \  closestDistance = difference;\n                closestNumber = min(numbers[i],\
    \ numbers[j]);\n                farthestNumber = max(numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    return tuple(closestNumber, farthestNumber);\n\
    }\n/*\n Define an immutable struct to represent a complex number (https://en.wikipedia.org/wiki/Complex_number).\n\
    \    * Provide means to add, subtract, multiply, and divide complex numbers.\n\
    \    * Provide means to find the magnitude of a complex number.\n    * Provide\
    \ means to compare complex numbers by magnitude.\n    * Provide a function that\
    \ returns an array of complex numbers each shifted by a random angle\n      (https://en.wikipedia.org/wiki/Complex_number#Polar_form_and_argument)\
    \ of between 0 to 2\u03C0.\n    >>> cnums = random_complex_numbers(4);\n    >>>\
    \ cnums.map!(a => a.magnitude).sum\n    17.0547677036\n    >>> cnums.map!(a =>\
    \ a.magnitude).sum\n    18.0127336899\n    >>> cnums.map!(a => a.magnitude).sum\n\
    \    16.7606296527\n    >>> cnums.map!(a => a.magnitude).sum\n    18.3529853948\n\
    \    >>> cnums.map!(a => a.magnitude).sum\n    16.3336409242\n*/\nstruct Complex\
    \ \n{\n    // https://en.wikipedia.org/wiki/Complex_number#Complex_plane\n   \
    \ public float re, im;", "{\n    assert(numbers.length >= 2);\n    float diff\
    \ = abs(numbers[0] - numbers[1]);\n    float a = numbers[0];\n    float b = numbers[1];\n\
    \    float curr;\n    float curr2;\n    foreach(i; 2..numbers.length)\n    {\n\
    \        curr = numbers[i];\n        curr2 = numbers[i-1];\n        if(abs(curr\
    \ - curr2) < diff)\n        {\n            diff = abs(curr - curr2);\n       \
    \     a = curr2;\n            b = curr;\n        }\n    }\n    return tuple(a,\
    \ b);\n}\n/*\nArrays with negative indices are not allowed, but slicing can be\
    \ used to achieve a similar behavior.\n    >>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][-2:]\n\
    \    [8, 9]\n    \n*/", "{\n    assert(numbers.length >= 2);\n    float minDistance\
    \ = float.infinity;\n    int index = 0;\n    for (int i = 0; i < numbers.length\
    \ - 1; i++) \n    {\n        float distance = abs(numbers[i] - numbers[i + 1]);\n\
    \        if (distance < minDistance) \n        {\n            minDistance = distance;\n\
    \            index = i;\n        }\n    }\n    return tuple(numbers[index], numbers[index\
    \ + 1]);\n}\n/*\n Given a string S, return the number of syllables it contains.\
    \ Follow the rules below:\n \n    Every 'a', 'e', 'i', 'o', 'u' and 'y' is a vowel.\n\
    \    If there is a 'y' after a consonant, it is a vowel.\n    Two or more consecutive\
    \ vowels form a dipthong.\n    Two or more consecutive consonants form a cluster.\n\
    \    Syllables are separated by one or more vowels.\n    The first and last letters\
    \ of S are always consonants.\n    \n    There will be no invalid cases (the string\
    \ will always be of the correct form).", "{\n    float first = numbers[0];\n \
    \   float second = numbers[1];\n    float diff = second - first;\n    foreach(float\
    \ current; numbers)\n    {\n        foreach(float next; numbers)\n        {\n\
    \            if(current == next)\n                continue;\n            if(diff\
    \ > abs(current - next))\n            {\n                diff = abs(current -\
    \ next);\n                first = current;\n                second = next;\n \
    \           }\n        }\n    }\n    return tuple(first, second);\n}", "{\n  \
    \  //sort the array\n    sort(numbers);\n    float best_diff = 2.0;\n    float\
    \ best_idx1 = 0.0;\n    float best_idx2 = 0.0;\n    for (int i = 0; i < numbers.length\
    \ - 1; i ++) \n    {\n        float diff = abs(numbers[i] - numbers[i + 1]);\n\
    \        if (diff < best_diff) \n        {\n            best_diff = diff;\n  \
    \          best_idx1 = numbers[i];\n            best_idx2 = numbers[i + 1];\n\
    \        }\n    }\n    return tuple(best_idx1, best_idx2);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    Tuple!(float, float) res = tuple(numbers[0], numbers[1]);\n    float\
    \ min_diff =  abs(numbers[0] - numbers[1]);\n    for (int i = 0; i < numbers.length\
    \ - 1; i++)\n    {\n        for (int j = i + 1; j < numbers.length; j++)\n   \
    \     {\n            float diff = abs(numbers[i] - numbers[j]);\n            if\
    \ (diff < min_diff)\n            {\n                min_diff = diff;\n       \
    \         res = tuple(numbers[i], numbers[j]);\n            }\n        }\n   \
    \ }\n    return res;\n}\n/*\n From a supplied array of numbers (of length at least\
    \ three) select and return three that are the closest to each\n    other and return\
    \ them in order (smallest number, middle number, largest number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2, 3.0)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0, 3.0)\n    \n*/\nTuple!(float,\
    \ float, float) find_closest_elements(float[] numbers) \n{\n    assert(numbers.length\
    \ >= 3);\n    Tuple!(float, float, float) res = tuple(numbers[0], numbers[1],\
    \ numbers[2]);\n    float min_diff =  abs(numbers[0] - numbers[1]);\n    for (int\
    \ i = 0; i < numbers.length - 2; i++)\n    {\n        for (int j = i + 1; j <\
    \ numbers.length - 1; j++)\n        {\n            for (int k = j + 1; k < numbers.length;\
    \ k++)\n            {\n                float diff = abs(numbers[i] - numbers[j])\
    \ + abs(numbers[j] - numbers[k]);\n                if (diff", "{\n    assert(numbers.length\
    \ > 1);\n    float smallest_distance;\n    float first_element;\n    float second_element;\n\
    \    float first_index;\n    float second_index;\n    foreach(index, element;\
    \ numbers)\n    {\n        for(int i = index+1; i < numbers.length; i++)\n   \
    \     {\n            float distance = abs(element - numbers[i]);\n           \
    \ if (first_element == 0.0f)\n            {\n                smallest_distance\
    \ = distance;\n                first_element = element;\n                second_element\
    \ = numbers[i];\n                first_index = index;\n                second_index\
    \ = i;\n            }\n            else if (distance < smallest_distance)\n  \
    \          {\n                smallest_distance = distance;\n                first_element\
    \ = element;\n                second_element = numbers[i];\n                first_index\
    \ = index;\n                second_index = i;\n            }\n        }\n    }\n\
    \    if (first_index < second_index)\n    {\n        return tuple(first_element,\
    \ second_element);\n    }\n    else\n    {\n        return tuple(second_element,\
    \ first_element);\n    }\n}", "{\n    float smallest_gap = std.float.max;\n  \
    \  float smallest = 0.0;\n    float largest = 0.0;\n    for (int i = 0; i < numbers.length\
    \ - 1; i++) \n    {\n        float diff = abs(numbers[i] - numbers[i + 1]);\n\
    \        if (diff < smallest_gap) \n        {\n            smallest_gap = diff;\n\
    \            smallest = min(numbers[i], numbers[i + 1]);\n            largest\
    \ = max(numbers[i], numbers[i + 1]);\n        }\n    }\n    return tuple(smallest,\
    \ largest);\n}", "{\n    float min = 1e6;\n    Tuple!(float, float) best_pair\
    \ = tuple(numbers[0], numbers[1]);\n    for (auto n1, n2; zip(numbers[0..$-1],\
    \ numbers[1..$]))\n    {\n        float diff = abs(n1 - n2);\n        if (diff\
    \ < min)\n        {\n            min = diff;\n            best_pair = tuple(n1,\
    \ n2);\n        }\n    }\n    return best_pair;\n}", "{\n    import std.range:\
    \ max;\n    import std.algorithm: sort;\n    import std.algorithm: map;\n    import\
    \ std.array: array;\n    import std.conv: to;\n    import std.format: format;\n\
    \    import std.math: abs;\n    import std.stdio: writeln;\n    auto sorted =\
    \ numbers.sort().map!(n => n.to!string).array;\n    auto r = sorted.max();\n \
    \   return tuple(r[0], r[1]);\n}", "{\n    float min = 0.0;\n    float min1 =\
    \ 0.0;\n    float min2 = 0.0;\n    for (int i = 0; i < numbers.length - 1; i++)\n\
    \    {\n        if (min > abs(numbers[i] - numbers[i + 1]))\n        {\n     \
    \       min = abs(numbers[i] - numbers[i + 1]);\n            min1 = numbers[i];\n\
    \            min2 = numbers[i + 1];\n        }\n    }\n    return tuple(min1,\
    \ min2);\n}", "{\n    float min = infinity;\n    float result1, result2;\n   \
    \ for (int i = 0; i < numbers.length; i++)\n    {\n        float diff = abs(numbers[i]\
    \ - numbers[i + 1]);\n        if (diff < min)\n        {\n            min = diff;\n\
    \            result1 = numbers[i];\n            result2 = numbers[i + 1];\n  \
    \      }\n    }\n    return tuple(result1, result2);\n}\n \nTuple!(float, float)\
    \ find_closest_elements2(float[] numbers) \n{\n    import std.algorithm : min,\
    \ max;\n    import std.range : move;\n    float min = infinity;\n    float result1,\
    \ result2;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        float\
    \ diff = abs(numbers[i] - numbers[i + 1]);\n        if (diff < min)\n        {\n\
    \            min = diff;\n            result1 = min(numbers[i], numbers[i + 1]);\n\
    \            result2 = max(numbers[i], numbers[i + 1]);\n        }\n    }\n  \
    \  return tuple(result1, result2);\n}\n \n/*\nSuppose you have a list of numbers\
    \ stored in a file and you want to sort them.\n    Instead of loading them into\
    \ memory you want to sort them in place in the file.\n    Given that you have\
    \ enough memory to hold a set of indices of the values to sort,\n    how would\
    \ you do it?\n    Write a function that receives a filename, a number of numbers\
    \ to sort, and the number of bytes\n    to use for each number.\n*/", "{\n   \
    \ assert(numbers.length >= 2);\n    float minimumDiff = abs(numbers[0] - numbers[1]);\n\
    \    int[] idx = [0, 1];\n    for (int i = 0; i < numbers.length; i++) \n    {\n\
    \        for (int j = i + 1; j < numbers.length; j++) \n        {\n          \
    \  float currDiff = abs(numbers[i] - numbers[j]);\n            if (currDiff <\
    \ minimumDiff) \n            {\n                minimumDiff = currDiff;\n    \
    \            idx = [i, j];\n            }\n        }\n    }\n    return tuple(numbers[idx[0]],\
    \ numbers[idx[1]]);\n}", "{\n    float smallestDiff = float.max;\n    float num1\
    \ = numbers[0];\n    float num2 = numbers[1];\n    foreach(i, a; numbers)\n  \
    \  {\n        foreach(j, b; numbers)\n        {\n            if(i != j)\n    \
    \        {\n                float diff = abs(a - b);\n                if(diff\
    \ < smallestDiff)\n                {\n                    num1 = a;\n        \
    \            num2 = b;\n                    smallestDiff = diff;\n           \
    \     }\n            }\n        }\n    }\n    return tuple(num1, num2);\n}\nunittest\n\
    {\n    assert(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0,\
    \ 2.2));\n    assert(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) ==\
    \ tuple(2.0, 2.0));\n}", "{\n    double firstElement = numbers[0];\n    double\
    \ secondElement = numbers[1];\n    double minDistance = abs(firstElement - secondElement);\n\
    \    int length = numbers.length;\n    for (int i = 0; i < length; i++)\n    {\n\
    \        for (int j = i + 1; j < length; j++)\n        {\n            double currentDistance\
    \ = abs(numbers[i] - numbers[j]);\n            if (currentDistance < minDistance)\n\
    \            {\n                minDistance = currentDistance;\n             \
    \   firstElement = numbers[i];\n                secondElement = numbers[j];\n\
    \            }\n        }\n    }\n    return tuple(firstElement, secondElement);\n\
    }", "    @safe pure nothrow\n{\n    assert(numbers.length >= 2);\n    float minDistance\
    \ = abs(numbers[0] - numbers[1]);\n    float first = numbers[0];\n    float second\
    \ = numbers[1];\n    for (int i = 0; i < numbers.length; i++) {\n        for (int\
    \ j = i + 1; j < numbers.length; j++) {\n            float distance = abs(numbers[i]\
    \ - numbers[j]);\n            if (distance < minDistance) {\n                minDistance\
    \ = distance;\n                first = numbers[i];\n                second = numbers[j];\n\
    \            }\n        }\n    }\n    return tuple(first, second);\n}", "{\n \
    \   auto start = 0;\n    auto end = 1;\n    auto closest = abs(numbers[start]\
    \ - numbers[end]);\n    for (auto i = 0; i < numbers.length - 1; i++)\n    {\n\
    \        for (auto j = i + 1; j < numbers.length; j++)\n        {\n          \
    \  auto diff = abs(numbers[i] - numbers[j]);\n            if (diff < closest)\n\
    \            {\n                start = i;\n                end = j;\n       \
    \         closest = diff;\n            }\n        }\n    }\n    return tuple(numbers[start],\
    \ numbers[end]);\n}", "{\n    assert(numbers.length >= 2);\n    auto minDistance\
    \ = numbers[1] - numbers[0];\n    auto minTuple = tuple(numbers[0], numbers[1]);\n\
    \    foreach(int i; 1..numbers.length - 1)\n    {\n        auto distance = numbers[i+1]\
    \ - numbers[i];\n        if(distance < minDistance)\n        {\n            minDistance\
    \ = distance;\n            minTuple = tuple(numbers[i], numbers[i+1]);\n     \
    \   }\n    }\n    return minTuple;\n}", "{\n    size_t t = numbers.length;\n \
    \   assert(t >= 2);\n    float m_diff = abs(numbers[0] - numbers[1]);\n    Tuple!(float,\
    \ float) m_closest = tuple(numbers[0], numbers[1]);\n    for (size_t i = 0; i\
    \ < t - 1; i++) \n    {\n        for (size_t j = i + 1; j < t; j++) \n       \
    \ {\n            float diff = abs(numbers[i] - numbers[j]);\n            if (diff\
    \ < m_diff) \n            {\n                m_diff = diff;\n                m_closest\
    \ = tuple(numbers[i], numbers[j]);\n            }\n        }\n    }\n    return\
    \ m_closest;\n}", "{ \n\tfloat a, b;\n\ta = b = numbers[0];\n\tfloat diff = a\
    \ - b;\n\tforeach(i, e; numbers)\n\t{\n\t\tfloat temp = numbers[i] - numbers[i+1];\n\
    \t\tif(temp < diff)\n\t\t{\n\t\t\ta = numbers[i];\n\t\t\tb = numbers[i+1];\n\t\
    \t\tdiff = temp;\n\t\t}\n\t}\n\treturn tuple(a, b);\n}", "{\n    auto copy = numbers[];\n\
    \    sort(copy);\n    float mindiff = copy[1] - copy[0];\n    for (int i = 1;\
    \ i < copy.length - 1; i++)\n    {\n        auto diff = copy[i + 1] - copy[i];\n\
    \        if (diff < mindiff)\n        {\n            mindiff = diff;\n       \
    \ }\n    }\n    Tuple!(float, float) output = tuple(0.0, 0.0);\n    for (int i\
    \ = 0; i < copy.length - 1; i++)\n    {\n        auto diff = copy[i + 1] - copy[i];\n\
    \        if (diff == mindiff)\n        {\n            output = tuple(copy[i],\
    \ copy[i + 1]);\n        }\n    }\n    return output;\n}", "{\n    import std.range;\n\
    \    // Find the smallest difference between two items in a range\n    auto smallestDifference\
    \ = (a, b) => a - b;\n    float smallest = smallestDifference(numbers[0], numbers[1]);\n\
    \    // Store the pair of numbers to return\n    float[] result;\n    foreach\
    \ (index, item; numbers.skip(1)) \n    {\n        if (float difference = smallestDifference(item,\
    \ numbers[index - 1]);\n            abs(difference) < abs(smallest)) \n      \
    \  {\n            smallest = difference;\n            result ~= item;\n      \
    \      result ~= numbers[index - 1];\n        }\n    }\n    return tuple(min(result[0],\
    \ result[1]), max(result[0], result[1]));\n}", "{\n    assert(numbers.length >=\
    \ 2);\n    return find_closest_elementsImpl(numbers);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float a = numbers[0];\n    float b = numbers[1];\n    float diff\
    \ = abs(a - b);\n    foreach(i, value; numbers) \n    {\n        if (i == 0) \n\
    \        {\n            continue;\n        }\n        float candidate = abs(value\
    \ - numbers[i - 1]);\n        if (candidate < diff) \n        {\n            a\
    \ = numbers[i - 1];\n            b = value;\n            diff = candidate;\n \
    \       }\n    }\n    return tuple(a, b);\n}", "{ \n    enum minDist = DBL_MAX;\
    \ \n    size_t index1, index2; \n    for (size_t i = 0; i < numbers.length; i++)\
    \ \n    { \n        for (size_t j = i + 1; j < numbers.length; j++) \n       \
    \ { \n            float dist = abs(numbers[i] - numbers[j]); \n            if\
    \ (dist < minDist) \n            { \n                minDist = dist; \n      \
    \          index1 = i; \n                index2 = j; \n            } \n      \
    \  } \n    } \n    return tuple(numbers[index1], numbers[index2]); \n} \n ", "{\n\
    \    if (numbers.length < 2) return tuple();", "{\n    float min = 1.0e32;\n \
    \   int index1 = 0;\n    int index2 = 0;\n    for (int i = 0; i < numbers.length\
    \ - 1; i++)\n    {\n        for (int j = i + 1; j < numbers.length; j++)\n   \
    \     {\n            float dif = abs(numbers[i] - numbers[j]);\n            if\
    \ (dif < min)\n            {\n                min = dif;\n                index1\
    \ = i;\n                index2 = j;\n            }\n        }\n    }\n    return\
    \ tuple(numbers[index1], numbers[index2]);\n}\n/*\n From a supplied array of numbers\
    \ (of length at least two) select and return two that are the furthest from each\n\
    \    other and return them in order (smaller number, larger number).\n    >>>\
    \ find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(1.0, 5.0)\n\
    \    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(1.0,\
    \ 5.0)\n*/\nTuple!(float, float) find_furthest_elements(float[] numbers) \n{\n\
    \    float max = -1.0e32;\n    int index1 = 0;\n    int index2 = 0;\n    for (int\
    \ i = 0; i < numbers.length - 1; i++)\n    {\n        for (int j = i + 1; j <\
    \ numbers.length; j++)\n        {\n            float dif = abs(numbers[i] - numbers[j]);\n\
    \            if (dif > max)\n            {\n                max = dif;\n     \
    \           index1 = i;\n                index2 = j;\n            }\n        }\n\
    \    }\n    return tuple(numbers[index1], numbers[index2]);\n}\n/*", "{\n    assert(numbers.length\
    \ >= 2);\n    float small, large;\n    small = large = numbers[0];\n    foreach(n;\
    \ numbers)\n    {\n        if(n < small)\n            small = n;\n        if(n\
    \ > large)\n            large = n;\n    }\n    return tuple(small, large);\n}",
  "{\n\tauto n = numbers.length;\n\tauto minDist = abs(numbers[1] - numbers[0]);\n\
    \tauto p = tuple(numbers[0], numbers[1]);\n\tfor (auto i = 0; i < n; i++)\n\t\
    {\n\t\tfor (auto j = i + 1; j < n; j++)\n\t\t{\n\t\t\tauto dist = abs(numbers[i]\
    \ - numbers[j]);\n\t\t\tif (dist < minDist)\n\t\t\t{\n\t\t\t\tp = tuple(numbers[i],\
    \ numbers[j]);\n\t\t\t\tminDist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}",
  "{\n    float d_min = numeric_limits!float.infinity;\n    float a = numbers[0];\n\
    \    float b = numbers[1];\n    foreach(int i, float m; numbers) \n    {\n   \
    \     foreach(int j, float n; numbers) \n        {\n            if (i != j) \n\
    \            {\n                float d = abs(m - n);\n                if (d <\
    \ d_min) \n                {\n                    d_min = d;\n               \
    \     a = m;\n                    b = n;\n                }\n            }\n \
    \       }\n    }\n    return tuple(a, b);\n}", "{\n    assert(numbers.length >\
    \ 1);\n    float minimum = abs(numbers[0] - numbers[1]);\n    int idx = 0;\n \
    \   for (int i = 0; i < numbers.length - 1; i++)\n    {\n        auto c = abs(numbers[i]\
    \ - numbers[i + 1]);\n        if (c < minimum)\n        {\n            minimum\
    \ = c;\n            idx = i;\n        }\n    }\n    return tuple(numbers[idx],\
    \ numbers[idx + 1]);\n}", "{\n    assert(numbers.length > 1);\n    float min_diff\
    \ = numbers[1] - numbers[0];\n    float min_val1 = numbers[0];\n    float min_val2\
    \ = numbers[1];\n    for (int i = 0; i < numbers.length; i++) \n    {\n      \
    \  for (int j = i + 1; j < numbers.length; j++) \n        {\n            float\
    \ diff = abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) \n  \
    \          {\n                min_diff = diff;\n                min_val1 = numbers[i];\n\
    \                min_val2 = numbers[j];\n            }\n        }\n    }\n   \
    \ return tuple(min_val1, min_val2);\n}", "{\n    float closestDiff = float.max;\n\
    \    float closestPair = tuple(0, 0);\n    foreach(i, ref n; numbers)\n    {\n\
    \        float n1 = n;\n        foreach(j, ref m; numbers)\n        {\n      \
    \      float n2 = m;\n            if (i != j)\n            {\n               \
    \ float diff = abs(n1 - n2);\n                if (diff < closestDiff)\n      \
    \          {\n                    closestDiff = diff;\n                    closestPair\
    \ = tuple(n1, n2);\n                }\n            }\n        }\n    }\n    return\
    \ closestPair;\n}", "{\n    auto len = numbers.length;\n    assert(len >= 2);\n\
    \    immutable diff = abs(numbers[0] - numbers[1]);\n    immutable lhs = numbers[0];\n\
    \    immutable rhs = numbers[1];\n    foreach(i; 1..len)\n    {\n        foreach(j;\
    \ i..len)\n        {\n            auto tmp = abs(numbers[i] - numbers[j]);\n \
    \           if(tmp < diff)\n            {\n                diff = tmp;\n     \
    \           lhs = numbers[i];\n                rhs = numbers[j];\n           \
    \ }\n        }\n    }\n    return tuple(lhs, rhs);\n}", "{\n    auto smallerNumber\
    \ = numbers[0];\n    auto largerNumber = numbers[1];\n    float dif = largerNumber\
    \ - smallerNumber;\n    auto c;\n    foreach(i,num; numbers)\n    {\n        for(auto\
    \ n = i+1; n < numbers.length; n++)\n        {\n            if (numbers[n] - num\
    \ < dif)\n            {\n                smallerNumber = num;\n              \
    \  largerNumber = numbers[n];\n                dif = largerNumber - smallerNumber;\n\
    \            }\n        }\n    }\n    return tuple(smallerNumber, largerNumber);\n\
    }", "{ \n    float closest = numbers[1] - numbers[0]; \n    Tuple!(float, float)\
    \ ret; \n    foreach (i, v; numbers) \n    { \n        foreach (j, w; numbers[i+1..$])\
    \ \n        { \n            float temp = w - v; \n            if (temp < closest)\
    \ \n            { \n                closest = temp; \n                ret = tuple(v,\
    \ w); \n            } \n        } \n    } \n    return ret; \n}\n/*\n Make a string\
    \ from the first and last two letters of a string, swapping the letters in each\
    \ word if they are the same.\n    If the string is less than two characters return\
    \ an empty string. If the string is exactly two characters return it.\n    >>>\
    \ make_string(\"Alphabet\")\n    \"Aabtle\"\n    >>> make_string(\"s\")\n    \"\
    \"\n    >>> make_string(\"hello\")\n    \"heol\"\n*/\nstring make_string(string\
    \ s)\n{\n\tif(s.length < 2)\n\t\treturn \"\";\n\telse if(s.length == 2)\n\t\t\
    return s;\n\telse\n\t{\n\t\tstring first = s[0..1];\n\t\tstring last = s[s.length-2..$];\n\
    \t\tif(first[0] == first[1])\n\t\t\tfirst = first[1..0];\n\t\tif(last[0] == last[1])\n\
    \t\t\tlast = last[1..0];\n\t\treturn first ~ last;\n\t}\n}\n/*\n Given a positive\
    \ int n, return an int array of length n+1 where each element is the sum of the\
    \ previous two elements.\n    If the result array has two elements, they should\
    \ be 1, 1.\n    >>> fibonacci(2)\n    [1, 1, 2]\n    >>> fibonacci(3)\n    [1,\
    \ 1, 2, 3]\n    >>> fibonacci(7)\n    [1, 1, 2, 3, 5, 8, 13, 21]\n*/", "{\n  \
    \  assert(numbers.length >= 2);\n    float min_distance = max_float;\n    Tuple!(float,\
    \ float) closest_elements;\n    for (int i = 0; i < numbers.length; i++)\n   \
    \ {\n        for (int j = i + 1; j < numbers.length; j++)\n        {\n       \
    \     float distance = abs(numbers[i] - numbers[j]);\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               closest_elements = tuple(numbers[i], numbers[j]);\n          \
    \  }\n        }\n    }\n    return closest_elements;\n}\n/*\n Remove from string\
    \ the middle character if it has even length. If it has odd length remove the\
    \ two middle ones.\n    >>> remove_middle_characters(\"abc\")\n    \"abc\"\n \
    \   >>> remove_middle_characters(\"abcde\")\n    \"ae\"\n    >>> remove_middle_characters(\"\
    abcdeg\")\n    \"abeg\"\n*/\nstring remove_middle_characters(string s)\n{\n  \
    \  import std.array;\n    s = s.dup;\n    if (s.length % 2 == 0)\n    {\n    \
    \    int middle = s.length / 2;\n        s = s[0 .. middle] ~ s[middle + 1 ..\
    \ $];\n    }\n    else\n    {\n        int middle = s.length / 2;\n        s =\
    \ s[0 .. middle - 1] ~ s[middle + 1 .. $];\n    }\n    return s;\n}\n// Write\
    \ a function that returns the number of occurrences of value in the array.\nuint\
    \ number_of_occurrences(int[] arr, int value)\n{\n    uint count = 0;\n    foreach\
    \ (int elem; arr)\n    {\n        if (elem == value)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}", "{\n    //sort numbers to eliminate\
    \ some comparisons\n    sort(numbers);\n    float smallestDiff = numbers[1] -\
    \ numbers[0];\n    int pos = 0;\n    //grab first two elements as benchmark\n\
    \    float num1 = numbers[0];\n    float num2 = numbers[1];\n    //for each element,\
    \ compare to previous element and replace if smaller difference\n    for (int\
    \ i = 1; i < numbers.length; i++)\n    {\n        float diff = numbers[i] - numbers[i-1];\n\
    \        if (diff < smallestDiff)\n        {\n            smallestDiff = diff;\n\
    \            num1 = numbers[i-1];\n            num2 = numbers[i];\n        }\n\
    \    }\n    return tuple(num1, num2);\n}", "{\n    float minDiff = 100;\n    float\
    \ min1, min2;\n    float diff;\n    foreach(i, float n1; numbers) \n    {\n  \
    \      float n2 = numbers[i + 1];\n        if (i + 1 > numbers.length) \n    \
    \    {\n            break;\n        }\n        else \n        {\n            diff\
    \ = abs(n1 - n2);\n            if (diff < minDiff) \n            {\n         \
    \       minDiff = diff;\n                min1 = n1;\n                min2 = n2;\n\
    \            }\n        }\n    }\n    return tuple(min1, min2);\n}\n/*\n From\
    \ a supplied array of numbers (of length at least two) select and return two that\
    \ are the furthest from each\n    other and return them in order (smaller number,\
    \ larger number).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
    \    tuple(1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0])\n    tuple(1.0, 5.0)\n    \n*/\nTuple!(float, float) find_furthest_elements(float[]\
    \ numbers) \n{\n    float maxDiff = 0;\n    float max1, max2;\n    float diff;\n\
    \    foreach(i, float n1; numbers) \n    {\n        float n2 = numbers[i + 1];\n\
    \        if (i + 1 > numbers.length) \n        {\n            break;\n       \
    \ }\n        else \n        {\n            diff = abs(n1 - n2);\n            if\
    \ (diff > maxDiff) \n            {\n                maxDiff = diff;\n        \
    \        max1 = n1;\n                max2 = n2;\n            }\n        }\n  \
    \  }\n    return tuple(max1, max2);\n}\n/*", "{\n    float[] result;\n    float\
    \ best = 100.0f;\n    foreach(index, num; numbers)\n    {\n        foreach(index2,\
    \ num2; numbers)\n        {\n            if(abs(num - num2) < best && num != num2)\n\
    \            {\n                best = abs(num - num2);\n                result\
    \ = tuple(num, num2);\n            }\n        }\n    }\n    return result;\n}",
  "{\n    assert(numbers.length>=2, \"numbers must be length of at least 2\");\n \
    \   float tmp = -1;\n    float min = -1;\n    Tuple!(float, float) t = tuple(-1,-1);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        for(int j = i+1;\
    \ j < numbers.length; j++)\n        {\n            tmp = abs(numbers[i] - numbers[j]);\n\
    \            if (min == -1 || tmp < min)\n            {\n                min =\
    \ tmp;\n                t = tuple(numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    return t;\n}\n/*\nselect and return the element of the array\
    \ that is the furthest from its average.\n    >>> average_distance([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n    1.0\n    >>> average_distance([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0])\n    5.0\n*/\nfloat average_distance(float[] numbers) \n{\n    assert(numbers.length>=2,\
    \ \"numbers must be length of at least 2\");\n    float tmp = -1;\n    float max\
    \ = -1;\n    float max_element = -1;\n    float average = sum(numbers) / numbers.length;\n\
    \    foreach(e; numbers)\n    {\n        tmp = abs(e - average);\n        if (max\
    \ == -1 || tmp > max)\n        {\n            max = tmp;\n            max_element\
    \ = e;\n        }\n    }\n    return max_element;\n}\n/*\nselect and return the\
    \ element of the array that is the furthest from its median.\n    >>> median_distance([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    5.0\n    >>> median_distance([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    5.0\n*/\nfloat median_distance(float[] numbers)", "{\n\
    \    static assert(numbers.length > 1);\n    float minimumDifference = numbers[1]\
    \ - numbers[0];\n    float resultNumber1 = numbers[0];\n    float resultNumber2\
    \ = numbers[1];\n    foreach(index, number; numbers) \n    {\n        if (index\
    \ == 0) continue;\n        float difference = abs(number - numbers[index - 1]);\n\
    \        if (difference < minimumDifference) \n        {\n            minimumDifference\
    \ = difference;\n            resultNumber1 = numbers[index - 1];\n           \
    \ resultNumber2 = number;\n        }\n    }\n    return tuple(resultNumber1, resultNumber2);\n\
    }", "{\n    float \n        minDiff = FLT_MAX, \n        diff = 0.0, \n      \
    \  a = numbers[0], \n        b = numbers[1];\n    \n    foreach (n, num; numbers)\
    \ \n    {\n        if (n == 0) \n            continue;\n        diff = abs(num\
    \ - numbers[n - 1]);\n        if (diff < minDiff) \n        {\n            minDiff\
    \ = diff;\n            a = numbers[n - 1];\n            b = num;\n        }\n\
    \    }\n    return tuple(a, b);\n}", "{\n  float n1, n2;\n  n1 = numbers[0];\n\
    \  n2 = numbers[1];\n  float dif = abs(n1 - n2);\n  for (int i = 0; i < numbers.length;\
    \ i++) \n  {\n    for (int j = i+1; j < numbers.length; j++) \n    {\n      float\
    \ dif_cur = abs(numbers[i] - numbers[j]);\n      if (dif_cur < dif) \n      {\n\
    \        dif = dif_cur;\n        n1 = numbers[i];\n        n2 = numbers[j];\n\
    \      }\n    }\n  }\n  return tuple(n1, n2);\n}", "{\n    int minIndex1 = 0;\n\
    \    int minIndex2 = 1;\n    float minDistance = numbers[minIndex1] - numbers[minIndex2];\n\
    \    float tmpDistance;\n    float tmpNum1;\n    float tmpNum2;\n    int n = numbers.length;\n\
    \    assert(n >= 2);\n    for (int i = 0; i < n; i++)\n    {\n        for (int\
    \ j = i + 1; j < n; j++)\n        {\n            tmpDistance = numbers[i] - numbers[j];\n\
    \            if (abs(tmpDistance) < abs(minDistance))\n            {\n       \
    \         minDistance = tmpDistance;\n                minIndex1 = i;\n       \
    \         minIndex2 = j;\n            }\n        }\n    }\n    return tuple(numbers[minIndex1],\
    \ numbers[minIndex2]);\n}", "{\n    int index = 0;\n    float smalldiff = 1000.0;\n\
    \    float bigdiff = -1.0;\n    float small = -1.0;\n    float big = 1000.0;\n\
    \    float temp = 0.0;\n    while(index < numbers.length)\n    {\n        //numbers[index];\n\
    \        if(index + 1 < numbers.length)\n        {\n            temp = abs(numbers[index\
    \ + 1] - numbers[index]);\n        }\n        if(temp < smalldiff)\n        {\n\
    \            smalldiff = temp;\n            small = numbers[index];\n        \
    \    big = numbers[index + 1];\n        }\n        index++;\n    }\n    return\
    \ tuple(small, big);\n}", "{\n    assert(numbers.length > 1);\n    float c = numbers[0];\n\
    \    float d = numbers[1];\n    float a = c;\n    float b = d;\n    float current\
    \ = abs(c - d);\n    float min;\n    for (int i = 0; i < numbers.length; i++)\
    \ \n    {\n        for (int j = i+1; j < numbers.length; j++) \n        {\n  \
    \          min = abs(numbers[i] - numbers[j]);\n            if (min < current)\
    \ \n            {\n                current = min;\n                a = numbers[i];\n\
    \                b = numbers[j];\n            }\n        }\n    }\n    if (a >\
    \ b) return tuple(b, a);\n    return tuple(a, b);\n}", "{\n    import std.algorithm.comparison\
    \ : min;\n    import std.array : minIndex;\n    import std.math : abs;\n    import\
    \ std.typecons : tuple;\n    return tuple(\n        numbers[minIndex!(a => abs(a\
    \ - numbers[numbers.minIndex]))(numbers[1 .. $])],\n        numbers[minIndex!(a\
    \ => abs(a - numbers[numbers.minIndex]))(numbers[0 .. $ - 1])]\n    );\n}", "{\n\
    \    assert(numbers.length >= 2);\n    float d = abs(numbers[0] - numbers[1]);\n\
    \    size_t ind0 = 0;\n    size_t ind1 = 1;\n    for (size_t i = 0; i < numbers.length;\
    \ i++) \n    {\n        for (size_t j = i + 1; j < numbers.length; j++) \n   \
    \     {\n            float tmp = abs(numbers[i] - numbers[j]);\n            if\
    \ (tmp < d) \n            {\n                d = tmp;\n                ind0 =\
    \ i;\n                ind1 = j;\n            }\n        }\n    }\n    return tuple(numbers[ind0],\
    \ numbers[ind1]);\n}\n/*\n    From a supplied array of numbers (of length at least\
    \ one) select and return two numbers that\n    maximise their difference.\n  \
    \  >>> find_max_difference([2.0, 1.0, 5.0, 8.0, 5.0, 2.0])\n    tuple(1.0, 8.0)\n\
    \    >>> find_max_difference([2.0, 2.0, 2.0, 2.0, 2.0, 2.0])\n    tuple(2.0, 2.0)\n\
    \    >>> find_max_difference([2.0])\n    tuple(2.0, 2.0)\n    >>> find_max_difference([2.0,\
    \ 3.0])\n    tuple(2.0, 3.0)\n*/\nTuple!(float, float) find_max_difference(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 1);\n    float max = numbers[0];\n\
    \    float min = numbers[0];\n    for (size_t i = 1; i < numbers.length; i++)\
    \ \n    {\n        if (numbers[i] > max)\n            max = numbers[i];\n    \
    \    if (numbers[i] < min)\n            min = numbers[i];\n    }\n    return tuple(min,\
    \ max);\n}\n/*\n    From a supplied array of numbers (of length at least three)\
    \ select and return two numbers that\n    maximise their difference", "{\n   \
    \ float closest_distance = max_float;\n    Tuple!(float, float) closest_numbers;\n\
    \    foreach (i, n1; numbers)\n    {\n        foreach (j, n2; numbers)\n     \
    \   {\n            if (i != j)\n            {\n                float d = abs(n1\
    \ - n2);\n                if (d < closest_distance)\n                {\n     \
    \               closest_distance = d;\n                    closest_numbers = tuple(min(n1,\
    \ n2), max(n1, n2));\n                }\n            }\n        }\n    }\n   \
    \ return closest_numbers;\n}", "{\n    import std.algorithm;\n    assert(numbers.length\
    \ >= 2);\n    float min = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    foreach(i,\
    \ index1; numbers)\n    {\n        foreach(j, index2; numbers)\n        {\n  \
    \          if (index1 != index2)\n            {\n                float temp =\
    \ abs(i - j);\n                if (temp < min || min == 0.0)\n               \
    \ {\n                    min = temp;\n                    a = i;\n           \
    \         b = j;\n                }\n            }\n        }\n    }\n    return\
    \ tuple(a, b);\n}\n/*\n    From a supplied array of numbers (of length at least\
    \ two) and a boolean array of length equal to the\n    supplied array, select\
    \ and return the two numbers which are closest to each other, such that their\n\
    \    corresponding boolean element is true.\n    >>> find_closest_elements_boolean([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2], [true, false, true, false, true, true])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements_boolean([1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ [true, false, true, false, true, true])\n    tuple(2.0, 2.0)\n*/\nTuple!(float,\
    \ float) find_closest_elements_boolean(float[] numbers, bool[] boolean) \n{\n\
    \    import std.algorithm;\n    assert(numbers.length >= 2);\n    assert(boolean.length\
    \ == numbers.length);\n    float min = 0.0;\n    float a = 0.0;\n    float b =\
    \ 0.0;\n    foreach(i, index1; numbers)\n    {\n        foreach(j, index2; numbers)\n\
    \        {\n            if (index1 != index2 && boolean[index1] && boolean[index2])\n\
    \            {\n                float temp = abs(i - j);\n                if (temp\
    \ < min || min == 0", "{ \n  float first = numbers[0];\n  float second = numbers[1];\n\
    \  float closest_pair = abs(first - second);\n  // FIXME: Need to make sure length\
    \ is at least 2\n  foreach (current; numbers[2..$])\n  {\n    float difference\
    \ = abs(first - current);\n    if (difference < closest_pair)\n    {\n      closest_pair\
    \ = difference;\n      second = current;\n    }\n  }\n  return tuple(first, second);\n\
    }", "{\n  auto index = 0;\n  auto min = abs(numbers[0] - numbers[1]);\n  auto\
    \ min_index = tuple(0, 1);\n  foreach(i, e; numbers) \n  {\n    if (i + 1 < numbers.length)\
    \ \n    {\n      auto temp = abs(e - numbers[i + 1]);\n      if (temp < min) \n\
    \      {\n        min = temp;\n        min_index = tuple(i, i + 1);\n      }\n\
    \    }\n  }\n  return tuple(numbers[min_index[0]], numbers[min_index[1]]);\n}",
  "{\n\tassert(numbers.length > 1);\n\treturn numbers.sorted.tupleOf[2];\n}\n/*\n\
    \ Given an array of numbers and an index, return the product of the array, except\
    \ for the element at the index.\n \n    >>> product_of_others([1.0, 2.0, 3.0,\
    \ 4.0, 5.0], 2)\n    120.0\n    >>> product_of_others([1.0, 2.0, 3.0, 4.0, 5.0],\
    \ 1)\n    120.0\n    >>> product_of_others([1.0, 2.0, 3.0, 4.0, 5.0], 0)\n   \
    \ 120.0\n    >>> product_of_others([1.0, 2.0, 3.0, 4.0, 5.0], 3)\n    60.0\n \
    \   >>> product_of_others([1.0, 2.0, 3.0, 4.0, 5.0], 4)\n    30.0\n*/\nfloat product_of_others(float[]\
    \ numbers, size_t index) \n{\n\tassert(numbers.length > 1);\n\tfloat sum = 1;\n\
    \tfor(auto number; numbers)\n\t{\n\t\tif(number != numbers[index])\n\t\t\tsum\
    \ *= number;\n\t}\n\treturn sum;\n}\n/*\n Given an array of numbers, and an index,\
    \ return a tuple containing the products of all numbers excluding those at the\n\
    \    index.\n    >>> products_of_others([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n    tuple(60.0,\
    \ 30.0, 120.0, 20.0, 12.0)\n    >>> products_of_others([1.0, 2.0, 3.0, 4.0, 5.0],\
    \ 1)\n    tuple(60.0, 120.0, 40.0, 30.0, 15.0)\n    >>> products_of_others([1.0,\
    \ 2.0, 3.0, 4.0, 5.0], 0)\n    tuple(120.0, 60.0,", "{\n    float num1, num2;\n\
    \    int index1, index2;\n    float min = abs(numbers[0] - numbers[1]);\n    index1\
    \ = 0;\n    index2 = 1;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        for (int j = 0; j < numbers.length; j++)\n        {\n            if (i\
    \ != j)\n            {\n                if (abs(numbers[i] - numbers[j]) < min)\n\
    \                {\n                    min = abs(numbers[i] - numbers[j]);\n\
    \                    index1 = i;\n                    index2 = j;\n          \
    \      }\n            }\n        }\n    }\n    num1 = numbers[index1];\n    num2\
    \ = numbers[index2];\n    if (num1 > num2)\n    {\n        float tmp = num1;\n\
    \        num1 = num2;\n        num2 = tmp;\n    }\n    return tuple(num1, num2);\n\
    }", "{\n    if (numbers.length < 2)\n        throw new Exception(\"List must have\
    \ at least two numbers\");\n    auto closest = tuple(numbers[0], numbers[1]);\n\
    \    auto pair = tuple(numbers[0], numbers[1]);\n    auto start = numbers[0];\n\
    \    auto last = numbers[1];\n    foreach (i, element; numbers)\n    {\n     \
    \   if (element == start)\n            continue;\n        if (element == last)\n\
    \            continue;\n        if (abs(start - element) < abs(closest[0] - closest[1]))\n\
    \        {\n            closest = tuple(start, element);\n        }\n        start\
    \ = element;\n    }\n    return closest;\n}", "{\n    float minDist = float.max;\n\
    \    Tuple!(float, float) minPair;\n    foreach(i, a; numbers)\n    {\n      \
    \  foreach(j, b; numbers[i+1..])\n        {\n            if(abs(a-b) < minDist)\n\
    \            {\n                minDist = abs(a-b);\n                minPair =\
    \ tuple(a, b);\n            }\n        }\n    }\n    return minPair;\n}", "{\n\
    \    Tuple!(float, float) min(cast(float) 1.0e100,cast(float) 1.0e100);\n    foreach(index1,i;\
    \ numbers)\n    {\n        foreach(index2,j; numbers)\n        {\n           \
    \ if(index1!=index2)\n            {\n                if(min.length>abs(i-j))\n\
    \                {\n                    min.length=abs(i-j);\n               \
    \     min.first=min(i,j);\n                    min.second=max(i,j);\n        \
    \        }\n            }\n        }\n    }\n    return min;\n}", "{\n    assert(numbers.length\
    \ > 1);\n    //float[] difference = new float[numbers.length];\n    float[] difference;\n\
    \    float[] distance = new float[numbers.length];\n    float smallest_num;\n\
    \    float largest_num;\n    float closest;\n    int i = 0;\n    foreach(number1;\
    \ numbers) \n    {\n        if(i >= 1) \n        {\n            //difference[i]\
    \ = abs(number1 - number2);\n            difference ~= abs(number1 - numbers[i-1]);\n\
    \            distance[i] = difference[i-1];\n        }\n        i++;\n    }\n\
    \    difference = difference[1..$];\n    assert(distance.length == difference.length);\n\
    \    //writefln(\"%s\",distance);\n    //writefln(\"%s\",difference);\n    smallest_num\
    \ = min(difference);\n    largest_num = max(difference);\n    int smallest_index\
    \ = difference.indexOf(smallest_num);\n    //writefln(\"%s\", smallest_index);\n\
    \    closest = distance[smallest_index];\n    //smallest_num = numbers[smallest_index];\n\
    \    //writefln(\"%s\", smallest_num);\n    //largest_num = numbers[smallest_index\
    \ + 1];\n    largest_num = numbers[smallest_index];\n    //writefln(\"%s\", largest_num);\n\
    \    writefln(\"%s\", closest);\n    return tuple(smallest_num, largest_num);\n\
    }", "{\n    if (numbers.length < 2)\n        return tuple(0.0, 0.0);\n    if (numbers.length\
    \ == 2)\n        return tuple(numbers[0], numbers[1]);\n    float min = min(numbers[0],\
    \ numbers[1]), max = max(numbers[0], numbers[1]);\n    float diff = abs(min -\
    \ max);\n    for (int i = 0; i < numbers.length; i++) \n    {\n        for (int\
    \ j = i + 1; j < numbers.length; j++) \n        {\n            float d = abs(numbers[i]\
    \ - numbers[j]);\n            if (d < diff) \n            {\n                min\
    \ = min(numbers[i], numbers[j]);\n                max = max(numbers[i], numbers[j]);\n\
    \                diff = d;\n            }\n        }\n    }\n    return tuple(min,\
    \ max);\n}", "{\n    assert(numbers.length >= 2);\n    auto min_difference = abs(numbers[0]\
    \ - numbers[1]);\n    Tuple!(float, float) min_pair = tuple(numbers[0], numbers[1]);\n\
    \    foreach (i, number; numbers)\n    {\n        foreach (j, another_number;\
    \ numbers[i+1..$])\n        {\n            auto difference = abs(number - another_number);\n\
    \            if (difference < min_difference)\n            {\n               \
    \ min_difference = difference;\n                min_pair = tuple(number, another_number);\n\
    \            }\n        }\n    }\n    return min_pair;\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float min = infinity;\n    Tuple!(float, float) minTuple = Tuple!(float,\
    \ float)(-1, -1);\n    foreach(i, item; numbers)\n    {\n        foreach(j, elem;\
    \ numbers)\n        {\n            if(i != j)\n            {\n               \
    \ if(abs(item - elem) < min)\n                {\n                    min = abs(item\
    \ - elem);\n                    minTuple = Tuple!(float, float)(item, elem);\n\
    \                }\n            }\n        }\n    }\n    return minTuple;\n}",
  "{\n\tassert(numbers.length >= 2);\n\tfloat min_diff = abs(numbers[0] - numbers[1]);\n\
    \tfloat n1 = numbers[0];\n\tfloat n2 = numbers[1];\n\tfor (size_t i = 0; i < numbers.length;\
    \ i++)\n\t{\n\t\tfor (size_t j = i + 1; j < numbers.length; j++)\n\t\t{\n\t\t\t\
    float diff = abs(numbers[i] - numbers[j]);\n\t\t\tif (diff < min_diff)\n\t\t\t\
    {\n\t\t\t\tmin_diff = diff;\n\t\t\t\tn1 = numbers[i];\n\t\t\t\tn2 = numbers[j];\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn tuple(n1, n2);\n}", "{ \n    if (numbers.length\
    \ &lt; 2) \n    { \n        throw new Exception(\"There must be at least two elements\
    \ in the array.\"); \n    } \n    float smallestDifference = numbers[0] - numbers[1];\
    \ \n    auto result = tuple(numbers[0], numbers[1]); \n    foreach (number; numbers)\
    \ \n    { \n        foreach (anotherNumber; numbers) \n        { \n          \
    \  if (number == anotherNumber) continue; \n            float diff = number -\
    \ anotherNumber; \n            if (abs(diff) &lt; abs(smallestDifference)) \n\
    \            { \n                smallestDifference = diff; \n               \
    \ result = tuple(min(number, anotherNumber), max(number, anotherNumber)); \n \
    \           } \n        } \n    } \n    return result; \n} \nunittest \n{ \n \
    \   assert(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0,\
    \ 2.2)); \n    assert(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) ==\
    \ tuple(2.0, 2.0)); \n}\n</code>\n", "{\n    assert(numbers.length >= 2);\n  \
    \  float closest_pair_distance = abs(numbers[0] - numbers[1]);\n    Tuple!(float,\
    \ float) closest_pair = tuple(numbers[0], numbers[1]);\n    foreach (number_index_1,\
    \ number_1; numbers)\n    {\n        foreach (number_index_2, number_2; numbers[number_index_1\
    \ + 1 .. $])\n        {\n            float distance = abs(number_1 - number_2);\n\
    \            if (distance < closest_pair_distance)\n            {\n          \
    \      closest_pair_distance = distance;\n                closest_pair = tuple(number_1,\
    \ number_2);\n            }\n        }\n    }\n    return closest_pair;\n}\n \n\
    \ /*\n  From a supplied string (s) return a new string which is the same as s,\
    \ except that all the letters of s are now in\n    reverse order (i.e. with the\
    \ first letter of s now being the last letter, the second letter of s now being\
    \ the\n    second last letter, etc.).\n    >>> reverse_string(\"abcdefg\")\n \
    \   \"gfedcba\"\n    >>> reverse_string(\"\")\n    \"\"\n */\nstring reverse_string(string\
    \ s) \n{\n    string reverse_s = \"\";\n    foreach (index, character; s[s.length\
    \ - 1 .. -1])\n    {\n        reverse_s ~= character;\n    }\n    return reverse_s;\n\
    }\n \n /*\n  From a supplied string (s) return a new string which is the same\
    \ as s, except that all vowels are changed to 'X'.\n    >>> remove_vowels(\"abcdefg\"\
    )\n    \"XbcdXfg\"\n    >>> remove_vowels(\"\")\n    \"\"\n */\nstring remove_vowels(string\
    \ s) \n{\n    string without_vowels = \"\";\n    foreach (character; s)\n    {\n\
    \        if (character.isAlpha && character.toLower.in(\"aeiou\"))\n        {\n\
    \            without_vowels ~= \"X\";\n        }\n        else\n        {\n  \
    \          without_vowels ~", "    nogc pure nothrow @nogc \n{\n    // find closest\
    \ match from numbers, \n    // \n    // we search for a value that is either to\
    \ the left or to the right of the current position\n    // and at distance less\
    \ than the current distance\n    float temp = 9999999.9f; // initialize to something\
    \ bigger than any difference we can find\n    float smallest_difference = 0.0f;\
    \ // value of the smallest difference\n    float first = 0.0f; // the first smallest\
    \ difference number\n    float second = 0.0f; // the second smallest difference\
    \ number\n    int numbers_len = numbers.length;\n    int i; // array index\n \
    \   for (i = 0; i < numbers_len; i++) \n    {\n        // go to the right\n  \
    \      if (i < numbers_len - 1) \n        {\n            temp = numbers[i + 1]\
    \ - numbers[i];\n            if (smallest_difference == 0.0f || temp < smallest_difference)\
    \ \n            {\n                smallest_difference = temp;\n             \
    \   first = numbers[i];\n                second = numbers[i + 1];\n          \
    \  }\n        }\n        // go to the left\n        if (i > 0) \n        {\n \
    \           temp = numbers[i] - numbers[i - 1];\n            if (smallest_difference\
    \ == 0.0f || temp < smallest_difference) \n            {\n                smallest_difference\
    \ = temp;\n                first = numbers[i - 1];\n                second = numbers[i];\n\
    \            }\n        }\n    }\n    return tuple(first, second);\n}", "{\n \
    \   assert(numbers.length >= 2);\n    float min = numbers[0] - numbers[1];\n \
    \   float minIndex = 0;\n    float maxIndex = 1;\n    for (float i = 0; i < numbers.length\
    \ - 1; i++)\n    {\n        float num = numbers[i] - numbers[i + 1];\n       \
    \ if (abs(num) < abs(min)) \n        {\n            min = num;\n            minIndex\
    \ = i;\n            maxIndex = i + 1;\n        }\n    }\n    return tuple(numbers[minIndex],\
    \ numbers[maxIndex]);\n}\n//---------------------------------------------------------------",
  "{\n    return tuple(2.0, 2.0);\n}", "{\n    float diff = 100000.0f;\n    float\
    \ first;\n    float second;\n    foreach(int i; 0..numbers.length-1)\n    {\n\
    \        if( abs(numbers[i] - numbers[i+1]) < diff)\n        {\n            diff\
    \ = abs(numbers[i] - numbers[i+1]);\n            first = numbers[i];\n       \
    \     second = numbers[i+1];\n        }\n    }\n    return tuple(first, second);\n\
    }", "{\n    assert(numbers.length >= 2);\n    float minDelta = min(abs(numbers[0]\
    \ - numbers[1]), abs(numbers[1] - numbers[2]));\n    int minIndex = 1;\n    for\
    \ (int i = 2; i < numbers.length - 1; i++)\n    {\n        float delta = abs(numbers[i]\
    \ - numbers[i+1]);\n        if (delta < minDelta)\n        {\n            minDelta\
    \ = delta;\n            minIndex = i;\n        }\n    }\n    return tuple(numbers[minIndex],\
    \ numbers[minIndex+1]);\n}", "{\n    assert(numbers.length >= 2);\n    float diff\
    \ = abs(numbers[0] - numbers[1]);\n    auto p = tuple(numbers[0], numbers[1]);\n\
    \    if (diff == 0) return p;\n    foreach (x; numbers[2..$])\n    {\n       \
    \ float d = abs(x - numbers[$-1]);\n        if (d < diff) \n        {\n      \
    \      diff = d;\n            p = tuple(numbers[$-1], x);\n        }\n    }\n\
    \    return p;\n}\nTuple!(float, float) find_closest_elements_sorted(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float diff = abs(numbers[0] - numbers[1]);\n\
    \    auto p = tuple(numbers[0], numbers[1]);\n    if (diff == 0) return p;\n \
    \   for (int i = 2; i < numbers.length; i++)\n    {\n        float d = abs(numbers[i]\
    \ - numbers[i-1]);\n        if (d < diff) \n        {\n            diff = d;\n\
    \            p = tuple(numbers[i-1], numbers[i]);\n        }\n    }\n    return\
    \ p;\n}\n/*\nGiven an array of numbers (of length at least two) find the pair\
    \ of numbers such that they are the farthest apart\n    and return them in order\
    \ (smaller number, larger number).\n    >>> find_farthest_elements([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n    tuple(1.0, 5.0)\n    >>> find_farthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(1.0, 5.0)\n*/\nTuple!(float, float) find_farthest_elements(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 2);\n    float diff = abs(numbers[0]\
    \ - numbers[1]);\n    auto p = tuple(numbers[0], numbers[", "{\n    assert(numbers.length\
    \ >= 2);\n    return tuple(numbers[0], numbers[1]);\n}\n/*\n    From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ furthest away\n    from each other and return them in order (smaller number,\
    \ larger number).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
    \    tuple(1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0])\n    tuple(1.0, 5.0)\n*/\nTuple!(float, float) find_furthest_elements(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 2);\n    return tuple(numbers[0],\
    \ numbers[1]);\n}\n/*\n    From a supplied array of numbers (of length at least\
    \ two) select and return two that are the furthest away\n    from each other and\
    \ return them in order (smaller number, larger number).\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(1.0, 5.0)\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(1.0, 5.0)\n*/\nTuple!(float, float) find_furthest_elements2(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 2);\n    return tuple(numbers[0],\
    \ numbers[1]);\n}\n/*\n    From a supplied array of numbers (of length at least\
    \ two) select and return two that are the furthest away\n    from each other and\
    \ return them in order (smaller number, larger number).\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(1.0, 5.0", "{\n    float min = numbers[0]\
    \ + numbers[1];\n    float index = 0;\n    for (int i = 0; i < numbers.length\
    \ - 1; i++)\n    {\n        float newmin = numbers[i] + numbers[i + 1];\n    \
    \    if (abs(min) > abs(newmin))\n        {\n            min = newmin;\n     \
    \       index = i;\n        }\n    }\n    return tuple(numbers[index], numbers[index\
    \ + 1]);\n}", "{\n    assert(numbers.length >= 2);\n    double currentClosest\
    \ = numbers[1] - numbers[0];\n    Tuple!(float, float) currentClosestTwo = tuple(numbers[0],\
    \ numbers[1]);\n    for (int i = 0; i < numbers.length; i++)\n    {\n        for\
    \ (int j = i + 1; j < numbers.length; j++)\n        {\n            if (abs(numbers[i]\
    \ - numbers[j]) < currentClosest)\n            {\n                currentClosest\
    \ = abs(numbers[i] - numbers[j]);\n                currentClosestTwo = tuple(numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    return currentClosestTwo;\n\
    }", "{\n    assert(numbers.length >= 2);\n    float minDistance = cast(float)abs(numbers[0]\
    \ - numbers[1]);\n    float a = numbers[0];\n    float b = numbers[1];\n    for\
    \ (int i = 0; i < numbers.length; i++) \n    {\n        for (int j = i + 1; j\
    \ < numbers.length; j++) \n        {\n            float distance = cast(float)abs(numbers[i]\
    \ - numbers[j]);\n            if (distance < minDistance) \n            {\n  \
    \              minDistance = distance;\n                a = numbers[i];\n    \
    \            b = numbers[j];\n            }\n        }\n    }\n    return tuple(a,\
    \ b);\n}\n/*\nWrite a function that takes a list of strings, and returns a string\
    \ that is a combination of all the strings,\n    with a \"/\" inserted between\
    \ each. The string should not have a trailing slash.\n    >>> join_slash_strings([\"\
    one\", \"two\", \"three\"])\n    \"one/two/three\"\n*/\nstring join_slash_strings(string[]\
    \ words)\n{\n    string result = \"\";\n    for (int i = 0; i < words.length;\
    \ i++)\n    {\n        result ~= words[i];\n        if (i != words.length - 1)\n\
    \        {\n            result ~= \"/\";\n        }\n    }\n    return result;\n\
    }\n/*\nWrite a function that generates a dictionary where the keys are the numbers\
    \ between 0 and 100 inclusive,\n    and the values are the squares of the corresponding\
    \ keys.\n    >>> generate_dictionary_of_squares()\n    [0: 0, 1: 1, 2: 4, 3: 9,\
    \ 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100, ...]\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
