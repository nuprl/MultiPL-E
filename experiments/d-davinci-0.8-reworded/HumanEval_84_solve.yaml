name: HumanEval_84_solve
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nGiven a positive integer N, return\
  \ the total sum of its digits in binary.\n    \n    Example\n    >>> solve(1000L)\n\
  \    \"1\"\n    >>> solve(150L)\n    \"110\"\n    >>> solve(147L)\n    \"1100\"\n\
  \    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N\
  \ \u2264 10000.\n    Output:\n         a string of binary number\n    \n*/\nstring\
  \ solve(long N) \n"
tests: "unittest\n{\n    alias candidate = solve;\n\n    assert(candidate(1000L) ==\
  \ \"1\");\n    assert(candidate(150L) == \"110\");\n    assert(candidate(147L) ==\
  \ \"1100\");\n    assert(candidate(333L) == \"1001\");\n    assert(candidate(963L)\
  \ == \"10010\");\n}\nvoid main(){}"
completions: ["{\n    return toString(N,2);\n}", "{\n  return format(\"%=b\", N);\n\
    }\n/*", "{\n    return to!string(N, 2);\n}", "{\n    return to!string(N, 2);\n\
    }", "{\n    auto arr = split[0..N](x => N % 2 == 0, N /= 2);\n    return format(\"\
    %s\", chomp(arr));\n}", "{\n    string result;\n    for (; N; N >>= 1) \n    \
    \    result = (N & 1 ? \"1\" : \"0\") ~ result;\n    return result.empty ? \"\
    0\" : result;\n}\n/*\npublic class Solution {\n    public static String solve(long\
    \ N) {\n        String r = \"\";\n        while (N > 0) {\n            r = N %\
    \ 2 + r;\n            N /= 2;\n        }\n        return r;\n    }\n}\n*/", "{\n\
    \    string result;\n    result = to!string(N, 2);\n    return result;\n}", "{\n\
    \    //masukkan ke dalam list\n    auto list = new int[];\n    while(N>0)\n  \
    \  {\n        list ~= N%2;\n        N = N/2;\n    }\n    // return string(list.reverse);\n\
    \    string str;\n    foreach(i;list.reverse) str ~= i;\n    return str;\n}",
  "{\n    return to!string(N,2);\n}", "{\n    //var r = N.to!string;\n    //return\
    \ r;\n    // The idea is to work backwards\n    // start by \n    if (N == 0)\n\
    \        return \"0\";\n    auto ret = new string[];\n    // The idea is to start\
    \ from the last digit which is two\n    auto two = 2;\n    while (N > 0)\n   \
    \ {\n        // First divide by two\n        // If it is odd add one\n       \
    \ if (N % two == 1)\n            ret ~= \"1\";\n        else\n            ret\
    \ ~= \"0\";\n        N /= two;\n    }\n    //return ret.text;\n    return ret.reversed.text;\n\
    }", "{\n    // Write your code here\n    string str = \"\";\n    int remainder;\n\
    \    int count = 0;\n    long num = N;\n    while(num > 0)\n    {\n        remainder\
    \ = num % 2;\n        count++;\n        str = cast(string)remainder + str;\n \
    \       num = num / 2;\n    }\n    return str;\n}", "{\n    return N.text.to!string.d\n\
    }\n/*\n|a|>=|b|\n        \"1101110\"\n        \"1101\"\n    For each digit of\
    \ a, if it's 0, make it 1\n    For each digit of b, if it's 1, make it 0\n   \
    \         \"0001000\"\n            \"0000\"\n    +1\n*/", "{\n    return format(\"\
    %s\", to!string(N, 2));\n}", "{\n    return to!string(N, 2);\n}\n```", "{\n  \
    \  return to!string(N,2);\n}", "{\n    string result = \"\";\n    if (N == 0)\
    \ return \"0\";\n    while (N > 0) {\n        result = (N % 2 ? \"1\" : \"0\"\
    ) ~ result;\n        N /= 2;\n    }\n    return result;\n}", "{\n    static assert(0\
    \ <= N <= 10000);\n    int result = (N == 0 ? 0 : N % 2 + 10 * solve(N / 2));\n\
    \    return format(\"%d\", result);\n}", "{\n    auto b = to!string(N,2);\n  \
    \  return b;\n}", "{\n    return to!string(N, 2);\n}", "{\n    auto x = to!string(N,\
    \ 2);\n    return x;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
