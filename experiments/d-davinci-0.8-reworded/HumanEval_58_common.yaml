name: HumanEval_58_common
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common elements\
  \ for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
  \ 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L,\
  \ 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n"
tests: "unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
  \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
  \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L,\
  \ 8L], []) == []);\n}\nvoid main(){}"
completions: ["    if (l1.length > l2.length) {\n        auto tmp = l1;\n        l1\
    \ = l2;\n        l2 = tmp;\n    }\n    return sort(array(l1).map!(a => a in l2).filter!(a\
    \ => a).keys);\n}", "{\n    long[] ret = new long[];\n    auto i1 = l1.dup.sort;\n\
    \    auto i2 = l2.dup.sort;\n    foreach(i, x; i1)\n    {\n        foreach(j,\
    \ y; i2)\n        {\n            if(x == y)\n            {\n                i2.remove(j);\n\
    \                ret ~= x;\n                break;\n            }\n        }\n\
    \    }\n    return ret;\n}", "{\n    size_t l1s = l1.length;\n    size_t l2s =\
    \ l2.length;\n    if(l1s == 0 || l2s == 0)\n    {\n        return [];\n    }\n\
    \    if(l1s > l2s)\n    {\n        long[] temp = l1;\n        l1 = l2;\n     \
    \   l2 = temp;\n    }\n    size_t l2s2 = l2.length;\n    Map!(long, bool) l1_m\
    \ = Map!(long, bool)();\n    foreach(item; l1)\n    {\n        l1_m[item] = true;\n\
    \    }\n    long[] ret_arr = [];\n    foreach(item; l2)\n    {\n        if(l1_m.contains(item))\n\
    \        {\n            ret_arr ~= item;\n        }\n    }\n    return ret_arr;\n\
    }\n//difference of two lists\nlong[] difference(long[] l1, long[] l2) \n{\n  \
    \  size_t l1s = l1.length;\n    size_t l2s = l2.length;\n    if(l1s == 0 || l2s\
    \ == 0)\n    {\n        return [];\n    }\n    if(l1s > l2s)\n    {\n        long[]\
    \ temp = l1;\n        l1 = l2;\n        l2 = temp;\n    }\n    size_t l2s2 = l2.length;\n\
    \    Map!(long, bool) l1_m = Map!(long, bool)();\n    foreach(item; l1)\n    {\n\
    \        l1_m[item] = true;\n    }\n    long[] ret_arr = [];\n    foreach(item;\
    \ l2)\n    {\n        if(!l1_m.contains(item))\n        {\n            ret_arr\
    \ ~= item;\n        }\n    }\n    return ret_arr;\n}\n/*\nReturn sorted unique\
    \ common elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L,",
  "{\n     if (l1.length == 0 || l2.length == 0) return new long[0];\n    auto lSet\
    \ = new HashSet!(long)(l1);\n    auto lOut = [];\n    foreach (e; l2)\n    {\n\
    \        if (lSet.contains(e))\n        {\n            lOut ~= e;\n        }\n\
    \    }\n    lOut.sort;\n    return lOut;\n}\n/*\nReturn sorted unique elements\
    \ that are in one of the arrays but not both.\n    >>> extra([1L, 4L, 3L, 34L,\
    \ 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [2L, 3L, 4L, 7L, 9L, 34L,\
    \ 121L]\n    >>> extra([5L, 3L, 2L, 8L], [3L, 2L])\n    [5L, 8L]\n*/\nlong[] extra(long[]\
    \ l1, long[] l2) \n{\n    if (l1.length == 0 && l2.length == 0) return new long[0];\n\
    \    if (l1.length == 0) return l2;\n    if (l2.length == 0) return l1;\n    auto\
    \ lSet = new HashSet!(long)(l1);\n    auto lOut = [];\n    foreach (e; l2)\n \
    \   {\n        if (!lSet.contains(e))\n        {\n            lOut ~= e;\n   \
    \     }\n    }\n    lOut.sort;\n    return lOut;\n}", "{\n    SortedRange!long\
    \ set1 = l1;\n    SortedRange!long set2 = l2;\n    ulong[] common = new ulong[](min(set1.length,\
    \ set2.length));\n    ulong[] common_out = common.dup;\n    ulong c;\n    c =\
    \ set1.common(set2, common);\n    common_out.length = c;\n    return common_out;\n\
    }", "{\n    long[] ret = null;\n    long[] l = merge(l1, l2);\n    l = sort(l);\n\
    \    l = unique(l);\n    if (l.length == 0)\n    {\n        return ret;\n    }\n\
    \    else\n    {\n        ulong cnt = l.length;\n        foreach (i; l)\n    \
    \    {\n            if (cnt == l.length)\n            {\n                ret ~=\
    \ i;\n            }\n            else\n            {\n                if (i !=\
    \ ret[$ - 1])\n                {\n                    ret ~= i;\n            \
    \    }\n            }\n            cnt--;\n        }\n        return ret;\n  \
    \  }\n}\n/*\nReturn sorted unique elements from both arrays.\n    >>> merge([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L,\
    \ 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> merge([4L, 3L, 2L, 8L], [3L, 2L])\n\
    \    [2L, 3L, 4L, 8L]\n    >>> merge([1L, 2L, 3L], [1L, 2L, 3L])\n    [1L, 2L,\
    \ 3L]\n*/\nlong[] merge(long[] l1, long[] l2) \n{\n    long[] ret = null;\n  \
    \  foreach (i; l1)\n    {\n        ret ~= i;\n    }\n    foreach (i; l2)\n   \
    \ {\n        ret ~= i;\n    }\n    ret = sort(ret);\n    ret = unique(ret);\n\
    \    return ret;\n}\n/*\nReturn sorted unique elements from array.\n    >>> unique([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L])\n    [1L, 2L, 3L, 4L, 5L, 34L, 653L]\n    >>> unique([5L,\
    \ 7L, 1L, 5L", "{\n    long[] result = null;\n    long length = 0;\n    if (l1.length\
    \ > l2.length) \n    {\n        result = l1.dup;\n        length = l2.length;\n\
    \    }\n    else \n    {\n        result = l2.dup;\n        length = l1.length;\n\
    \    }\n    for (int i = 0; i < length; i++) \n    {\n        if (l1[i] != l2[i])\
    \ \n        {\n            result = result[0..$-1];\n        }\n    }\n    return\
    \ result.sort.unique;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n\tauto l3 = l1.sorted;\n\tauto l4 = l2.sorted;\n\tlong[] result;\n\twhile(l3.length\
    \ != 0 && l4.length != 0)\n\t{\n\t\tif(l3[0] == l4[0])\n\t\t{\n\t\t\tresult ~=\
    \ l3[0];\n\t\t\tl3 = l3[1..$];\n\t\t\tl4 = l4[1..$];\n\t\t}\n\t\telse if(l3[0]\
    \ < l4[0])\n\t\t{\n\t\t\tl3 = l3[1..$];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl4 = l4[1..$];\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    Map!(dchar, size_t) map1 = new Map!(dchar,\
    \ size_t)();\n    size_t[] l1_uniq = new size_t[];\n    foreach (i, v; l1) \n\
    \    {\n        map1[v] = i;\n        l1_uniq ~= v;\n    }\n    long[] l1_uniq_sorted\
    \ = sort(l1_uniq);\n    long[] res = new long[];\n    foreach (i, v; l2) \n  \
    \  {\n        if (map1.count(v)) \n        {\n            res ~= v;\n        }\n\
    \    }\n    return sort(res);\n}", "{\n    long len1 = l1.length;\n    long len2\
    \ = l2.length;\n    if (len1 == 0L || len2 == 0L)\n    {\n        return new long[0L];\n\
    \    }\n    if (len1 == 1L)\n    {\n        if (cast(long)l2.count(l1[0L]) > 0L)\n\
    \        {\n            return l1;\n        }\n        else\n        {\n     \
    \       return new long[0L];\n        }\n    }\n    if (len2 == 1L)\n    {\n \
    \       if (cast(long)l1.count(l2[0L]) > 0L)\n        {\n            return l2;\n\
    \        }\n        else\n        {\n            return new long[0L];\n      \
    \  }\n    }\n    return std.algorithm.setIntersection(l1, l2).array();\n}", "{\n\
    \tstatic if (__VERSION__ >= 2060) \n    {\n        auto hash = new HashTable!(long,\
    \ long);\n        foreach (i; 0 .. l1.length) hash[l1[i]] = 1;\n        foreach\
    \ (i; 0 .. l2.length) hash[l2[i]] = hash[l2[i]] == 1 ? 2 : 0;\n        hash.popFront();\n\
    \        return hash.byKey.sort.filter!(a => a.value > 1).map!(a => a.key).array;\n\
    \    } \n    else \n    {\n        sort(l1);\n        sort(l2);\n        return\
    \ filter!(a => a[0] == a[1])(zip(l1, l2)).map!(a => a[0]).array;\n    }\n}", "{\n\
    \    assert(l1.length > 0);\n    assert(l2.length > 0);\n    auto s1 = l1.sort();\n\
    \    auto s2 = l2.sort();\n    long[][] tmp = [s1, s2];\n    auto s3 = tmp.sort();\n\
    \    long[] c1 = l1.sort();\n    long[] c2 = l2.sort();\n    long[] c3 = [];\n\
    \    for (int i = 0; i < s1.length; i++)\n    {\n        if (s1[i] == s2[i])\n\
    \        {\n            c3 ~= s1[i];\n        }\n    }\n    return c3;\n}\n/*\n\
    Create a 2-D array from 1-D\n    >>> create_2d([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L,\
    \ 9L], 3L)\n    [[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]\n*/\nlong[][] create_2d(long[]\
    \ data, size_t dim1) \n{\n    assert(data.length > 0);\n    long[][] res = [];\n\
    \    size_t i = 0;\n    while (i < data.length)\n    {\n        res ~= data[i..i\
    \ + dim1];\n        i += dim1;\n    }\n    return res;\n}\n/*\nPair an array with\
    \ the cumulative sum of its elements\n    >>> cumulate([1L, 2L, 3L, 4L])\n   \
    \ [(1L, 1L), (2L, 3L), (3L, 6L), (4L, 10L)]\n    >>> cumulate([5L, 6L, 7L, 8L,\
    \ 9L])\n    [(5L, 5L), (6L, 11L), (7L, 18L), (8L, 26L), (9L, 35L)]\n*/\nTuple!(long,\
    \ long)[][] cumulate(long[] data) \n{\n    assert(data.length > 0);\n    Tuple!(long,\
    \ long)[][]", "{\n\treturn std.algorithm.setIntersection(l1, l2).array();\n}",
  "{\n    auto us = union(l1, l2);\n    auto is = intersection(l1, l2);\n    return(is);\n\
    }\n/*\nRemove all duplicate elements.\n    >>> unique([1L, 4L, 3L, 2L, 34L, 653L,\
    \ 2L, 5L])\n    [1L, 4L, 3L, 2L, 34L, 653L, 5L]\n    >>> unique([2L, 3L, 2L, 3L,\
    \ 2L, 3L])\n    [2L, 3L]\n*/\nlong[] unique(long[] l) \n{\n    l.sort();\n   \
    \ return(l.uniq);\n}\n/*\nGiven two arrays, return all of the elements that are\
    \ in both arrays.\n    >>> intersection([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> intersection([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n*/\nlong[] intersection(long[] l1, long[]\
    \ l2) \n{\n    auto us = union(l1, l2);\n    return(us.uniq);\n}\n/*\nGiven two\
    \ arrays, return all of the elements that are in only one array.\n    >>> difference([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [4L, 3L,\
    \ 34L, 2L]\n    >>> difference([5L, 3L, 2L, 8L], [3L, 2L])\n    [5L, 8L]\n*/\n\
    long[] difference(long[] l1, long[] l2) \n{\n    auto us = union(l1, l2);\n  \
    \  auto is = intersection(l1, l2);\n    return(us.difference(is));\n}\n/*\nReturn\
    \ the elements that are only in one array.\n    >>>", "{\n    l1.sort;\n    l2.sort;\n\
    \    return l1.uniq.filter!(x => x in l2.uniq).idup;\n}\n/*\nYou have a function\
    \ rand7() that generates a random integer from 1 to 7. Use it to write a function\
    \ rand5() that generates a random integer from 1 to 5.\n    rand7() returns each\
    \ integer with equal probability. rand5() must also return each integer with equal\
    \ probability.\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5()\
    \ in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n\
    \    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5()\
    \ in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n\
    \    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5()\
    \ in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n\
    \    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n    True\n*/", "{\n    size_t\
    \ n1 = l1.length;\n    size_t n2 = l2.length;\n    long[][] arr = [l1, l2];\n\
    \    size_t[] n = [n1, n2];\n    size_t[] idx = [0, 0];\n    long[] value = [l1[0],\
    \ l2[0]];\n    size_t m = 0;\n    long[] result = new long[min(n1, n2)];\n   \
    \ while(true) \n    {\n        if (idx[0] == n[0] || idx[1] == n[1])\n       \
    \     break;\n        auto a = idx[0];\n        auto b = idx[1];\n        if (value[0]\
    \ == value[1]) \n        {\n            result[m] = value[0];\n            value[0]\
    \ = arr[0][++a];\n            value[1] = arr[1][++b];\n            idx[0] = a;\n\
    \            idx[1] = b;\n            m++;\n        }\n        else if (value[0]\
    \ < value[1]) \n        {\n            value[0] = arr[0][++a];\n            idx[0]\
    \ = a;\n        }\n        else \n        {\n            value[1] = arr[1][++b];\n\
    \            idx[1] = b;\n        }\n    }\n    return result[0..m];\n}", "{\n\
    \    auto unique1 = set(l1);\n    auto unique2 = set(l2);\n    return unique1.intersection(unique2).array;\n\
    }", "{\n    auto result = l1.dup;\n    foreach(e; l2)\n    {\n        auto index\
    \ = result.indexOf(e);\n        if(index > -1)\n        {\n            result[index]\
    \ = 0;\n        }\n    }\n    return result.filter!(x => x > 0).array;\n}\n/*\n\
    Return sorted unique common elements for two arrays.\n    >>> common([1, 4, 3,\
    \ 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]", "{\n  return sort(toSet(l1) & toSet(l2));\n}",
  "{\n    \n    long[] first = l1.sort.unique;\n    long[] second = l2.sort.unique;\n\
    \    auto res = long[].init;\n    for (int i = 0; i < first.length; i++) \n  \
    \  {\n        for (int j = 0; j < second.length; j++) \n        {\n          \
    \  if (first[i] == second[j]) \n            {\n                res ~= first[i];\n\
    \            }\n        }\n    }\n    return res;\n}\n/*\nFind if string is made\
    \ up of number characters.\n    >>> is_number(\"123\")\n    true\n    >>> is_number(\"\
    123abc\")\n    false\n    >>> is_number(\"12 3\")\n    false\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
