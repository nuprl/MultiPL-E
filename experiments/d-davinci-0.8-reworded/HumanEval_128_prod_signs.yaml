name: HumanEval_128_prod_signs
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
  \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
  \ by product of all signs\n    of each number in the array, represented by 1, -1\
  \ or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
  \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
  \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
  \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
  \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
  \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
  \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n\
  \        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n\
  \        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
  \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
  \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto\
  \ result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get\
  \ == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n      \
  \  assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
completions: ["{\n    if (arr.length == 0) return null;", "{\n    //write your code\
    \ here\n    auto signs = arr.map!(x => sign(x));\n    auto total = 1L;\n    foreach(num;\
    \ signs)\n    {\n        total *= num;\n    }\n    if(total != 0)\n    {\n   \
    \     return arr.map!(abs).sum * total;\n    }\n    else\n    {\n        return\
    \ null;\n    }\n}", "{\n    if (arr.length == 0) return null;", "{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long prod_signs\
    \ = 1L;\n        long magn = 0L;\n        foreach (num; arr) \n        {\n   \
    \         magn += abs(num);\n            prod_signs *= sign(num);\n        }\n\
    \        return nullable(magn * prod_signs);\n    }\n}", "in\n{\n    assert(arr.length\
    \ < 100);\n}\nout(result)\n{\n    assert(result is null || (result >= 0L && result\
    \ <= 300L));\n}\nbody\n{\n    if (arr.length == 0)\n        return Nullable!(long).init;\n\
    \    long sum = 0L;\n    long sign = 1L;\n    foreach (elem; arr)\n    {\n   \
    \     sign *= elem >= 0L ? 1L : -1L;\n        sum += abs(elem);\n    }\n    return\
    \ sum * sign;\n}", "{\n    long total = 0;\n    long sign = 1;\n    foreach(long\
    \ i; arr) \n    {\n        if (i > 0) \n        {\n            sign *= 1;\n  \
    \      } \n        else if (i < 0) \n        {\n            sign *= -1;\n    \
    \    } \n        else \n        {\n            sign = 0;\n        }\n        total\
    \ += i.abs;\n    }\n    return sign ? total * sign : null;\n}", "{\n    long signs\
    \ = 1L;\n    long magnitude = 0L;\n    foreach(i; arr) \n    {\n        if(i >\
    \ 0) \n        {\n            signs *= 1L;\n            magnitude += i;\n    \
    \    } \n        else if(i < 0) \n        {\n            signs *= -1L;\n     \
    \       magnitude += -i;\n        } \n        else \n        {\n            signs\
    \ *= 0L;\n        }\n    }\n    if(signs == 0L) \n    {\n        return Nullable!(long)(0L);\n\
    \    }\n    return Nullable!(long)(magnitude * signs);\n}", "{\n    auto signs\
    \ = arr.map!(a => sign(a));\n    auto magnitudes = arr.map!(a => abs(a));\n  \
    \  return magnitudes.sum * product(signs);\n}\n \n/*", "{\n    return arr.length\
    \ == 0 \n                ? null \n                : arr.map!((l) => l > 0 ? l\
    \ : abs(l)).product \n                * arr.map!((l) => l == 0 ? 0 : (l > 0 ?\
    \ 1 : -1)).product;\n}", "{\n    long[] signs = arr.map!((x) => x < 0 ? -1L :\
    \ x > 0 ? 1L : 0L)();\n    return arr.empty ? null : signs.product * signs.map!(abs).sum;\n\
    }", "{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod\
    \ = 1;\n    foreach (a; arr)\n    {\n        sum += abs(a);\n        prod *= sign(a);\n\
    \    }\n    return sum * prod;\n}", "{\n\tif (arr.length == 0) return null;\n\t\
    int prod = 1;\n\tlong sum = 0;\n\tforeach (i; arr)\n\t{\n\t\tsum += abs(i);\n\t\
    \tprod *= sign(i);\n\t}\n\treturn make!(Nullable)(sum * prod);\n}", "{\n    long\
    \ num = 1;\n    long den = 1;\n    if (arr.length == 0)\n        return null;\n\
    \    foreach (long n; arr)\n    {\n        num *= n;\n        den *= (n == 0)\
    \ ? 1 : (n < 0) ? -1 : 1;\n    }\n    return num * den;\n}", "{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    int prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            continue;\n    \
    \    sum += abs(i);\n    }\n    return Nullable!(long)(sum * prod);\n}", "{\n\
    \    if (arr.length == 0)\n        return null;\n    else\n    {\n        size_t\
    \ t = arr.length;\n        long result = 1L;\n        for (size_t i = 0; i < t;\
    \ i++)\n        {\n            auto number = arr[i];\n            if (number >\
    \ 0)\n                result *= 1L;\n            else if (number < 0)\n      \
    \          result *= -1L;\n            else\n                result *= 0L;\n \
    \       }\n        return result;\n    }\n}", "in {\n    assert(arr.length > 0);\n\
    } \nout(result) \n{\n    assert(result is null || result >= 0);\n}\nbody {\n \
    \   if (arr.length > 0) {\n        long res = 1;\n        long prod = 1;\n   \
    \     foreach (l; arr) {\n            res += abs(l);\n            prod *= sign(l);\n\
    \        }\n        return check(res * prod);\n    }\n    return null;\n}\n \n\
    /*", "{ \n    return reduce!\"a + b\"(map!\"abs(a) * b\"(arr, 1L), 0L);\n}", "{\n\
    \    // setup variables to calculate our final value\n    long product = 1L;\n\
    \    long sum = 0L;\n    long zero_count = 0L;\n    //loop over input array and\
    \ do work to setup final variables\n    foreach(num; arr)\n    {\n        //check\
    \ if 0\n        if(num == 0L)\n        {\n            zero_count += 1L;\n    \
    \    }\n        //check if negative and multiply by -1\n        else if(num <\
    \ 0L)\n        {\n            product *= -1L;\n            sum += abs(num);\n\
    \        }\n        //else number is positive so just add the magnitude to sum\n\
    \        else\n        {\n            sum += num;\n        }\n    }\n    //check\
    \ if we had any 0's\n    if(zero_count > 0L)\n    {\n        return Nullable!(long)();\n\
    \    }\n    //return null for empty array\n    else if(arr.length == 0)\n    {\n\
    \        return Nullable!(long)();\n    }\n    //return the final product\n  \
    \  else\n    {\n        return Nullable!(long)(product * sum);\n    }\n    \n}",
  "{\n    if (arr.length == 0)\n        return null;\n    else\n    {\n        long\
    \ sum = 0L;\n        long prod = 1L;\n        foreach (i; arr)\n        {\n  \
    \          sum += abs(i);\n            if (i != 0)\n                prod *= sign(i);\n\
    \        }\n        return sum * prod;\n    }\n}", "{\n    if (arr.length == 0)\
    \ \n    {\n        return null;\n    }\n    else \n    {\n        long prod =\
    \ 1L;\n        long sum = 0L;\n        foreach (i; arr) \n        {\n        \
    \    prod *= (i < 0) ? -1L : i == 0 ? 0L : 1L;\n            sum += abs(i);\n \
    \       }\n        return tuple(sum, prod)();\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
