name: HumanEval_128_prod_signs
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
  \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
  \ by product of all signs\n    of each number in the array, represented by 1, -1\
  \ or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
  \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
  \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
  \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
  \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
  \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
  \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n\
  \        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n\
  \        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
  \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
  \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto\
  \ result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get\
  \ == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n      \
  \  assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
completions: ["{\n    if (arr.length == 0) return null;", "{\n    //write your code\
    \ here\n    auto signs = arr.map!(x => sign(x));\n    auto total = 1L;\n    foreach(num;\
    \ signs)\n    {\n        total *= num;\n    }\n    if(total != 0)\n    {\n   \
    \     return arr.map!(abs).sum * total;\n    }\n    else\n    {\n        return\
    \ null;\n    }\n}", "{\n    if (arr.length == 0) return null;", "{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long prod_signs\
    \ = 1L;\n        long magn = 0L;\n        foreach (num; arr) \n        {\n   \
    \         magn += abs(num);\n            prod_signs *= sign(num);\n        }\n\
    \        return nullable(magn * prod_signs);\n    }\n}", "in\n{\n    assert(arr.length\
    \ < 100);\n}\nout(result)\n{\n    assert(result is null || (result >= 0L && result\
    \ <= 300L));\n}\nbody\n{\n    if (arr.length == 0)\n        return Nullable!(long).init;\n\
    \    long sum = 0L;\n    long sign = 1L;\n    foreach (elem; arr)\n    {\n   \
    \     sign *= elem >= 0L ? 1L : -1L;\n        sum += abs(elem);\n    }\n    return\
    \ sum * sign;\n}", "{\n    long total = 0;\n    long sign = 1;\n    foreach(long\
    \ i; arr) \n    {\n        if (i > 0) \n        {\n            sign *= 1;\n  \
    \      } \n        else if (i < 0) \n        {\n            sign *= -1;\n    \
    \    } \n        else \n        {\n            sign = 0;\n        }\n        total\
    \ += i.abs;\n    }\n    return sign ? total * sign : null;\n}", "{\n    long signs\
    \ = 1L;\n    long magnitude = 0L;\n    foreach(i; arr) \n    {\n        if(i >\
    \ 0) \n        {\n            signs *= 1L;\n            magnitude += i;\n    \
    \    } \n        else if(i < 0) \n        {\n            signs *= -1L;\n     \
    \       magnitude += -i;\n        } \n        else \n        {\n            signs\
    \ *= 0L;\n        }\n    }\n    if(signs == 0L) \n    {\n        return Nullable!(long)(0L);\n\
    \    }\n    return Nullable!(long)(magnitude * signs);\n}", "{\n    auto signs\
    \ = arr.map!(a => sign(a));\n    auto magnitudes = arr.map!(a => abs(a));\n  \
    \  return magnitudes.sum * product(signs);\n}\n \n/*", "{\n    return arr.length\
    \ == 0 \n                ? null \n                : arr.map!((l) => l > 0 ? l\
    \ : abs(l)).product \n                * arr.map!((l) => l == 0 ? 0 : (l > 0 ?\
    \ 1 : -1)).product;\n}", "{\n    long[] signs = arr.map!((x) => x < 0 ? -1L :\
    \ x > 0 ? 1L : 0L)();\n    return arr.empty ? null : signs.product * signs.map!(abs).sum;\n\
    }", "{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod\
    \ = 1;\n    foreach (a; arr)\n    {\n        sum += abs(a);\n        prod *= sign(a);\n\
    \    }\n    return sum * prod;\n}", "{\n\tif (arr.length == 0) return null;\n\t\
    int prod = 1;\n\tlong sum = 0;\n\tforeach (i; arr)\n\t{\n\t\tsum += abs(i);\n\t\
    \tprod *= sign(i);\n\t}\n\treturn make!(Nullable)(sum * prod);\n}", "{\n    long\
    \ num = 1;\n    long den = 1;\n    if (arr.length == 0)\n        return null;\n\
    \    foreach (long n; arr)\n    {\n        num *= n;\n        den *= (n == 0)\
    \ ? 1 : (n < 0) ? -1 : 1;\n    }\n    return num * den;\n}", "{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    int prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            continue;\n    \
    \    sum += abs(i);\n    }\n    return Nullable!(long)(sum * prod);\n}", "{\n\
    \    if (arr.length == 0)\n        return null;\n    else\n    {\n        size_t\
    \ t = arr.length;\n        long result = 1L;\n        for (size_t i = 0; i < t;\
    \ i++)\n        {\n            auto number = arr[i];\n            if (number >\
    \ 0)\n                result *= 1L;\n            else if (number < 0)\n      \
    \          result *= -1L;\n            else\n                result *= 0L;\n \
    \       }\n        return result;\n    }\n}", "in {\n    assert(arr.length > 0);\n\
    } \nout(result) \n{\n    assert(result is null || result >= 0);\n}\nbody {\n \
    \   if (arr.length > 0) {\n        long res = 1;\n        long prod = 1;\n   \
    \     foreach (l; arr) {\n            res += abs(l);\n            prod *= sign(l);\n\
    \        }\n        return check(res * prod);\n    }\n    return null;\n}\n \n\
    /*", "{ \n    return reduce!\"a + b\"(map!\"abs(a) * b\"(arr, 1L), 0L);\n}", "{\n\
    \    // setup variables to calculate our final value\n    long product = 1L;\n\
    \    long sum = 0L;\n    long zero_count = 0L;\n    //loop over input array and\
    \ do work to setup final variables\n    foreach(num; arr)\n    {\n        //check\
    \ if 0\n        if(num == 0L)\n        {\n            zero_count += 1L;\n    \
    \    }\n        //check if negative and multiply by -1\n        else if(num <\
    \ 0L)\n        {\n            product *= -1L;\n            sum += abs(num);\n\
    \        }\n        //else number is positive so just add the magnitude to sum\n\
    \        else\n        {\n            sum += num;\n        }\n    }\n    //check\
    \ if we had any 0's\n    if(zero_count > 0L)\n    {\n        return Nullable!(long)();\n\
    \    }\n    //return null for empty array\n    else if(arr.length == 0)\n    {\n\
    \        return Nullable!(long)();\n    }\n    //return the final product\n  \
    \  else\n    {\n        return Nullable!(long)(product * sum);\n    }\n    \n}",
  "{\n    if (arr.length == 0)\n        return null;\n    else\n    {\n        long\
    \ sum = 0L;\n        long prod = 1L;\n        foreach (i; arr)\n        {\n  \
    \          sum += abs(i);\n            if (i != 0)\n                prod *= sign(i);\n\
    \        }\n        return sum * prod;\n    }\n}", "{\n    if (arr.length == 0)\
    \ \n    {\n        return null;\n    }\n    else \n    {\n        long prod =\
    \ 1L;\n        long sum = 0L;\n        foreach (i; arr) \n        {\n        \
    \    prod *= (i < 0) ? -1L : i == 0 ? 0L : 1L;\n            sum += abs(i);\n \
    \       }\n        return tuple(sum, prod)();\n    }\n}", "{\n    long prod =\
    \ 1L;\n    long sum = 0L;\n    foreach(el; arr)\n    {\n        if(el == 0L)\n\
    \        {\n            return 0L;\n        }\n        sum += abs(el);\n     \
    \   prod *= el / abs(el);\n    }\n    return nullable(prod * sum);\n}", "{\n \
    \   static assert(arr.length == 0, \"nullable\");\n    long res = 1L;\n    long\
    \ tmp = 0L;\n    foreach(elem; arr) \n    {\n        if(elem > 0) \n        {\n\
    \            res *= 1L;\n            tmp += elem;\n        }\n        else if(elem\
    \ < 0) \n        {\n            res *= -1L;\n            tmp += -elem;\n     \
    \   }\n        else \n        {\n            res *= 0L;\n            tmp += 0L;\n\
    \        }\n    }\n    return make!Nullable(res * tmp);\n}\n/*", "{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }", "{\n    import std.math\
    \ : abs;\n    import std.algorithm : map, reduce;\n    return arr.empty ? null\
    \ :\n        arr.map!(abs).reduce!(a, b => a * b) * arr.map!(el => el == 0 ? 0\
    \ : el < 0 ? -1 : 1).reduce!(a, b => a * b);\n}", "{\n    if (arr.length == 0)\n\
    \        return null;\n    auto prod = 1;\n    foreach (el; arr) \n    {\n   \
    \     prod *= sign(el);\n    }\n    auto res = 0;\n    foreach (el; arr) \n  \
    \  {\n        res += abs(el);\n    }\n    return res * prod;\n}", "{\n    if (arr.length==0)\n\
    \        return Nullable!(long)().init;\n    long p = 1;\n    long s = 0;\n  \
    \  foreach (z; arr)\n    {\n        if (z > 0)\n            p = p * 1;\n     \
    \   else if (z < 0)\n            p = p * -1;\n        else\n            continue;\n\
    \        s = s + abs(z);\n    }\n    return Nullable!(long)(p * s);\n}\n ", "{\n\
    \    // your code here\n    if (arr.length == 0)\n    {\n        return null;\n\
    \    }\n    else\n    {\n        long sum = 0;\n        foreach (elem; arr)\n\
    \        {\n            if (elem != 0)\n            {\n                sum +=\
    \ abs(elem);\n            }\n        }\n        double prod = 1;\n        foreach\
    \ (elem; arr)\n        {\n            if (elem != 0)\n            {\n        \
    \        prod *= elem / abs(elem);\n            }\n        }\n        return sum\
    \ * prod;\n    }\n}", "{\n    long sum = 0L;\n    long prod = 1L;\n    foreach(value;\
    \ arr) \n    {\n        if (value != 0L) \n        {\n            auto tmp = value\
    \ / abs(value);\n            sum += abs(value);\n            prod *= tmp;\n  \
    \      }\n    }\n    return sum * prod;\n}", "{\n    if (arr.length == 0) \n \
    \   {\n        return null;\n    }\n    else \n    {\n        long sum_of_magnitudes\
    \ = 0;\n        long product_of_signs = 1;\n        foreach (i; arr) \n      \
    \  {\n            long sign = sign(i);\n            sum_of_magnitudes += abs(i);\n\
    \            product_of_signs *= sign;\n        }\n        return product_of_signs\
    \ * sum_of_magnitudes;\n    }\n}", "in {\n    assert(arr != null);\n}\nout (result)\
    \ \ninout(arr) {\n    assert(arr != null);\n    assert(result == null || result\
    \ is long);\n}\nbody {\n    if (arr.length == 0) {\n        return null;\n   \
    \ } else {\n        Nullable!(long) signs = product_of_signs(arr);\n        Nullable!(long)\
    \ magnitudes = sum_of_magnitudes(arr);\n        if (signs is long && magnitudes\
    \ is long) {\n            return magnitudes * signs;\n        } else {\n     \
    \       return null;\n        }\n    }\n}", "{\n    static if(arr.length > 0)\n\
    \    {\n        long[] signs = [];\n        foreach(i; 0 .. arr.length)\n    \
    \    {\n            static if(arr[i] > 0)\n            {\n                signs\
    \ ~= 1L;\n            }\n            else static if(arr[i] < 0)\n            {\n\
    \                signs ~= -1L;\n            }\n            else static if(arr[i]\
    \ == 0)\n            {\n                signs ~= 0L;\n            }\n        }\n\
    \        long prod_signs = product(signs);\n        long[] array_abs = map!(abs)(arr);\n\
    \        long sum_abs = reduce!q{a + b}(array_abs);\n        return Tuple!(long,\
    \ long)(sum_abs, prod_signs);\n    }\n    else\n    {\n        return null;\n\
    \    }\n}", "in {\n    assert(arr.length > 0);\n} \nout (result) {\n    assert(result\
    \ is null || result > 0);\n}\nbody {\n    long signs = 1L;\n    long magnitude\
    \ = 0L;\n    foreach (elem; arr) {\n        if (elem > 0) {\n            signs\
    \ *= 1L;\n        }\n        else if (elem < 0) {\n            signs *= -1L;\n\
    \        }\n        else {\n            signs *= 0L;\n        }\n        magnitude\
    \ += abs(elem);\n    }\n    if (signs == 0L) {\n        return null;\n    }\n\
    \    return signs * magnitude;\n}", "{\n    typeof(null) res = null;\n    long\
    \ mult = 1L;\n    long sum = 0L;\n    long sign = 0L;\n    foreach(num; arr)\n\
    \    {\n        if(num < 0L)\n        {\n            sign = -1L;\n        }\n\
    \        else if(num > 0L)\n        {\n            sign = 1L;\n        }\n   \
    \     else\n        {\n            sign = 0L;\n        }\n        mult *= sign;\n\
    \        sum += abs(num);\n    }\n    if(arr.length != 0)\n    {\n        res\
    \ = sum * mult;\n    }\n    return res;\n}", "{\n    if (arr.length == 0)\n  \
    \      return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (int i,\
    \ x; arr) \n    {\n        sum += abs(x);\n        prod *= sign(x);\n    }\n \
    \   return sum * prod;\n}", "{\n    import std.conv : to;\n    import std.algorithm\
    \ : map;\n    import std.numeric : product;\n    import std.range : empty;\n \
    \   if (arr.empty)\n        return null;\n    return product(arr.map!(to!(int)()).map!(signbit));\n\
    }", "{\n    Nullable!(long) ret;\n    long prod_signs;\n    long sum_magn;\n \
    \   if (arr.length == 0)\n    {\n        ret = null;\n    }\n    else\n    {\n\
    \        // Make all signs in the array positive\n        // and get the product\
    \ of all signs\n        sum_magn = 0;\n        prod_signs = 1;\n        foreach\
    \ (l; arr)\n        {\n            if (l < 0)\n            {\n               \
    \ l = abs(l);\n                prod_signs *= -1;\n            }\n            sum_magn\
    \ += l;\n        }\n        ret = prod_signs * sum_magn;\n    }\n    return ret;\n\
    }", "{\n    if (arr.length == 0) return null;\n    long sum = 0L;\n    long prd\
    \ = 1L;\n    foreach (v; arr) \n    {\n        if (v > 0) sum += v;\n        else\
    \ if (v < 0) { sum += v.abs; prd *= -1; }\n    }\n    return tuple(sum, prd).opMul;\n\
    }", "{\n    long product = 1L;\n    long sum = 0L;\n    Nullable!(long) total;\n\
    \    foreach(index, value; arr)\n    {\n        if(value == 0L)\n        {\n \
    \           product *= 1L;\n        }\n        else if(value > 0L)\n        {\n\
    \            product *= 1L;\n        }\n        else if(value < 0L)\n        {\n\
    \            product *= -1L;\n        }\n        sum += abs(value);\n    }\n \
    \   total = product * sum;\n    return total;\n}", "{\n    if (arr.length == 0)\
    \ \n    {\n        return null;\n    }", "{\n\tif (arr.length == 0)\n\t\treturn\
    \ null;\n\tlong ret = 0;\n\tlong cur = 1;\n\tforeach (a; arr) \n\t{\n\t\tif (a\
    \ < 0) \n\t\t{\n\t\t\tret += cur * abs(a);\n\t\t\tcur *= -1;\n\t\t}\n\t\telse\
    \ if (a > 0) \n\t\t{\n\t\t\tret += cur * a;\n\t\t}\n\t\telse if (a == 0) \n\t\t\
    {\n\t\t\tret = 0;\n\t\t\tcur = 1;\n\t\t}\n\t}\n\treturn ret;\n}", "{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable.init;\n    }\n    long sum = 0;\n   \
    \ long prod = 1;\n    foreach (l; arr) \n    {\n        sum += abs(l);\n     \
    \   prod *= sign(l);\n    }\n    return prod * sum;\n}", "{\n    return arr.empty\
    \ ? null : arr.map!(a => abs(a) * product(arr.map!(b => sign(b))).to!long)().sum();\n\
    }", "{\n    long res;\n    if (arr.length == 0)\n        return null;\n    else\n\
    \    {\n        foreach (i; arr)\n        {\n            if (i != 0)\n       \
    \         res *= i / abs(i);\n            else\n                res *= i;\n  \
    \      }\n        foreach (i; arr)\n        {\n            if (i != 0)\n     \
    \           res *= abs(i);\n        }\n        return res;\n    }\n}", "{\n  \
    \  if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum\
    \ = 0;\n    foreach (i; arr)\n    {\n        i > 0 ? prod *= 1 : i < 0 ? prod\
    \ *= -1 : prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}",
  "{\n    Nullable!(long) x;\n    long res = 0;\n    foreach(i; arr)\n    {\n    \
    \    if(i != 0)\n        {\n            res += abs(i);\n            x = (cast(long)sgn(i));\n\
    \            res *= x;\n        }\n    }\n    return res;\n}", "{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }\n    long sum = 0;\n\
    \    long prod = 1;\n    for (long i = 0; i < arr.length; i++) \n    {\n     \
    \   if (arr[i] < 0) \n        {\n            prod *= -1;\n        }\n        else\
    \ if (arr[i] == 0) \n        {\n            return 0;\n        }\n        sum\
    \ += abs(arr[i]);\n    }\n    return sum * prod;\n}", "{\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.math;\n    import\
    \ std.typecons;\n    /*\n        Convert signs to [-1L, 1L].\n        Sum up magnitudes\
    \ of all integers.\n        Multiply magnitudes by product of all signs.\n   \
    \     Divide product by 2.\n        Return sum.\n    */\n    static long magnitude_and_sign(long\
    \ n) {\n        auto s = signbit(n);\n        auto m = abs(n);\n        return\
    \ (n == 0L) ? 0L : (s ? -m : m);\n    }\n    if (arr.empty)\n        return Nullable!(long)();\n\
    \    auto ms = arr.map!magnitude_and_sign;\n    return ms.sum() * product(ms)\
    \ / 2L;\n}\n \n/*", "{\n    if (arr.length == 0) return null;\n    long product\
    \ = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        long sign = signbit(i)\
    \ ? -1 : 1;\n        product *= sign;\n        sum += abs(i);\n    }\n    return\
    \ sum * product;\n}\n \n/*\n    You are given two strings s and t, each of them\
    \ composed of \"-\" or \"+\" symbols.\n    If the strings are equal return \"\
    0\", if the first string is greater return \"1\", if\n    the second string is\
    \ greater return \"-1\".", "{\n    long sum = 0L;\n    long sign = 1L;\n    foreach(value;\
    \ arr)\n    {\n        if(value < 0L)\n        {\n            sign *= -1L;\n \
    \       }\n        sum += abs(value);\n    }\n    if(arr.length == 0)\n    {\n\
    \        return null;\n    }\n    return sign * sum;\n}", "{\n    return cast(Nullable!(long))\
    \ (arr.length \n                              ? arr.map!(a => \n             \
    \                       cast(tuple(long, int))([abs(a), sign(a)]))\n         \
    \                           .fold!((t, s) => [t[0] + s[0], t[1] * s[1]])\n   \
    \                                 .reduce!((a, b) => a * b)\n                \
    \              : null);\n}", "{ \n    long sum = 0L;\n    long prod = 1L;\n  \
    \  foreach(i; arr)\n    {\n        // Replaced by 'i!=0' after DIP 1018,\n   \
    \     // DIP 1036 or DIP 1043, depending on\n        // their future fate.\n \
    \       if (i != 0) \n        {\n            sum += abs(i);\n            prod\
    \ *= i/abs(i);\n        }\n    }\n    return Nullable!(long)(prod * sum);\n}",
  "{\n    if (arr.length==0) \n        return null;\n    auto r = 1L;\n    for (auto\
    \ e : arr)\n        r*=sign(e);\n    return abs(r)*sum(map!abs(a => a)(arr));\n\
    }", "{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    auto\
    \ sign = long.sign;\n    auto signs = arr.map!(a => sign(a)).array;\n    long\
    \ prod = product(signs);\n    long abs_sum = abs(arr).sum;\n    return prod *\
    \ abs_sum;\n}\nlong product(long[] arr) \n{\n    long prod = 1L;\n    foreach\
    \ (idx, x; arr) \n    {\n        prod *= x;\n    }\n    return prod;\n}\nlong\
    \ abs(long[] arr) \n{\n    return arr.map!(a => a < 0 ? -a : a).array;\n}\nlong\
    \ sum(long[] arr) \n{\n    long sum = 0L;\n    foreach (idx, x; arr) \n    {\n\
    \        sum += x;\n    }\n    return sum;\n}", "{\n    if (arr.length == 0)\n\
    \        return Nullable!(long)();\n    int sign = 1;\n    long mags = 0;\n  \
    \  foreach (el; arr)\n    {\n        sign *= sign(el);\n        mags += abs(el);\n\
    \    }\n    return Nullable!(long)(sign * mags);\n}", "{\n    auto result = 1L;\n\
    \    auto sum_magnitudes = 0L;\n    if (arr.length == 0) return null;\n    foreach\
    \ (el; arr) \n    {\n        sum_magnitudes += el > 0 ? el : -el;\n        result\
    \ *= el < 0 ? -1 : el > 0 ? 1 : 0;\n    }\n    return result * sum_magnitudes;\n\
    }\n/*\n    You are given an array of integers that you want to process\n    with\
    \ a function f .\n    Write a function process that takes an alias to a function\
    \ f and\n    an array arr and returns a tuple with the result of f applied to\n\
    \    each element of arr and the length of arr.", "{\n    int len = arr.length;\n\
    \    if (len == 0) return typeof(return).init;\n    long sum = 0L;\n    long prod\
    \ = 1L;\n    foreach (ref int x; arr) \n    {\n        if (x > 0) \n        {\n\
    \            prod *= 1L;\n            sum += x;\n        }\n        else if (x\
    \ < 0) \n        {\n            prod *= -1L;\n            sum += x.abs;\n    \
    \    }\n        else \n        {\n            prod *= 0L;\n        }\n    }\n\
    \    return prod*sum;\n}", "{\n    if (arr.length == 0) return null;\n    long\
    \ prod = 1;\n    long sum = 0;\n    foreach (item; arr) \n    {\n        if (item\
    \ > 0) prod *= 1;\n        else if (item < 0) prod *= -1;\n        else prod *=\
    \ 0;\n        sum += abs(item);\n    }\n    return sum * prod;\n}", "{\n    long\
    \ prod = 1;\n    long sum = 0;\n    foreach(x; arr)\n    {\n        if(x == 0)\n\
    \        {\n            prod = 0;\n            sum = 0;\n            break;\n\
    \        }\n        else if(x < 0)\n        {\n            prod *= -1;\n     \
    \       sum += abs(x);\n        }\n        else\n        {\n            sum +=\
    \ x;\n        }\n    }\n    auto r = sum * prod;\n    if(arr.length == 0) return\
    \ null;\n    return r;\n}", "{\n    static int sign(long x) \n    {\n        if\
    \ (x == 0) return 0;\n        return x > 0 ? 1 : -1;\n    }\n    if (arr.length\
    \ == 0) return null;\n    long p = 1;\n    long s = 0;\n    foreach (i; arr) \n\
    \    {\n        p *= sign(i);\n        s += abs(i);\n    }\n    return s * p;\n\
    }", "{ \n    // your code here \n    if (arr.length == 0)\n    {\n        return\
    \ null;\n    }\n    long p = 1;\n    long s = 0;\n    foreach (x; arr)\n    {\n\
    \        if (x < 0)\n        {\n            p *= -1;\n        }\n        else\
    \ if (x > 0)\n        {\n            p *= 1;\n        }\n        else\n      \
    \  {\n            p *= 0;\n        }\n        s += abs(x);\n    }\n    return\
    \ p * s;\n}", "{\n    Nullable!(long) final_sum;", "{\n    long magnitudeSum =\
    \ 0L;\n    long product = 1L;\n    foreach(idx,elem; arr)\n    {\n        if(elem\
    \ > 0)\n        {\n            magnitudeSum += elem;\n            product *= 1L;\n\
    \        }\n        else if(elem < 0)\n        {\n            magnitudeSum +=\
    \ abs(elem);\n            product *= -1L;\n        }\n        else \n        {\n\
    \            product *= 0L;\n        }\n    }\n    if(arr.length == 0)\n    {\n\
    \        return null;\n    }\n    return product * magnitudeSum;\n}", "{\n   \
    \ if (arr.length == 0) return null;\n    return reduce!(\"a * b\", arr.map!(abs)).product()\
    \ * \n        reduce!(\"a * b\", arr.map!(a => a > 0 ? 1 : (a < 0 ? -1 : 0)));\n\
    }", "{\n    Nullable!(long) result = 0L;\n    long[] signs = map!((x) => if (x\
    \ < 0) -1L else if (x > 0) 1L else 0L)(arr);\n    long prodSigns = product(signs);\n\
    \    if (prodSigns == 0L) \n    {\n        return result;\n    }\n    long[] magnitudes\
    \ = map!((x) => abs(x))(arr);\n    long sumMagnitudes = sum(magnitudes);\n   \
    \ result = sumMagnitudes * prodSigns;\n    return result;\n}\n// TESTING", "{\n\
    \    if (arr.length == 0) \n    {\n        return null;\n    }\n    else \n  \
    \  {\n        long res;\n        res = arr[0];\n        foreach (i; 1 .. arr.length)\
    \ \n        {\n            res *= sign(arr[i]);\n        }\n        foreach (i;\
    \ 0 .. arr.length) \n        {\n            res *= abs(arr[i]);\n        }\n \
    \       return res;\n    }\n}", "{\n    // Convert long[] to some long[].\n  \
    \  auto someArr = to!(Some!(long[]))(arr);\n    // Calculate product of signs\
    \ of numbers in the array.\n    return someArr.map!(a => a.magnitude).reduce!q{a\
    \ + b}\n        * arr.map!q{a == 0 ? 0 : a > 0 ? 1 : -1}.reduce!q{a * b};\n}",
  "{ \n    if (arr.length == 0) \n        return null;\n    \n    Tuple!(int, long)[]\
    \ arr2 = new Tuple!(int, long)[arr.length];\n    for (int i = 0; i < arr.length;\
    \ i++) \n    {\n        if (arr[i] > 0) \n            arr2[i] = tuple(1, arr[i]);\n\
    \        else if (arr[i] < 0) \n            arr2[i] = tuple(-1, arr[i]);\n   \
    \     else\n            arr2[i] = tuple(0, arr[i]);\n    }\n    \n    int product\
    \ = 1;\n    long sum = 0;\n    foreach (a; arr2) \n    {\n        product *= a[0];\n\
    \        sum += abs(a[1]);\n    }\n    \n    return product * sum;\n}", "{\n \
    \   import std.algorithm;\n    if (arr.empty)\n        return null;\n    return\
    \ arr.map!(x => x < 0 ? -1 : (x > 0 ? 1 : 0))\n    .reduce!((a, b) => a * b) *\
    \ arr.map!abs.reduce!((a, b) => a + b);\n}\n/*\n    Given two arrays, write a\
    \ function to compute their intersection.\n    Example:\n    >>> intersect([1,\
    \ 2, 2, 1], [2, 2])\n    [2L, 2L]\n    >>> intersect([4, 9, 5], [9, 4, 9, 8, 4])\n\
    \    [4L, 9L]\n    >>> intersect([3, 2, 3], [3, 3])\n    [3L, 3L]\n*/\nlong[]\
    \ intersect(long[] nums1, long[] nums2) \n{\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.range;\n    import std.conv;\n    if (nums1.empty\
    \ || nums2.empty)\n        return [];\n    nums1.sort;\n    nums2.sort;\n    auto[i,\
    \ j] = tuple(0, 0);\n    int n1 = nums1.length;\n    int n2 = nums2.length;\n\
    \    long[] result;\n    while(i < n1 && j < n2) \n    {\n        while(i < n1\
    \ && j < n2 && nums1[i] < nums2[j])\n            i++;\n        while(i < n1 &&\
    \ j < n2 && nums1[i] > nums2[j])\n            j++;\n        if (i < n1 && j <\
    \ n2 && nums1[i] == nums2[j]) \n        {\n            result ~= nums1[i];\n \
    \           i++;\n            j++;\n        }\n    }\n    return result;\n}\n\
    /*\n    Return the maximum sum of three non-overlapping subarrays.\n    Example:\n\
    \    >>> maxSumOfThreeSubarrays([1, 2, 1, 2, 6, 7, 5", "{\n    int sign = 1;\n\
    \    long magnitude = 0;\n    foreach(x; arr) \n    {\n        if (x < 0) \n \
    \       {\n            sign *= -1;\n            magnitude += abs(x);\n       \
    \ }\n        else if (x > 0) \n        {\n            magnitude += x;\n      \
    \  }\n        else\n        {\n            return Nullable!(long)();\n       \
    \ }\n    }\n    return Nullable!(long)(sign * magnitude);\n}", "{\n    Nullable!(long)\
    \ result = Nullable!(long)(null);\n    long prod = 1L;\n    long sum = 0L;\n \
    \   foreach(var val; arr) \n    {\n        sum += abs(val);\n        prod *= sign(val);\n\
    \    }\n    if(arr.length > 0)\n        result = Nullable!(long)(sum * prod);\n\
    \    return result;\n}", "{\n    //TODO: return product of all signs multiplied\
    \ by sum of all magnitude.\n    return null;\n}", "{\n    if (arr.length == 0)\n\
    \        return null;\n    \n    auto res = 1L;\n    foreach (i; arr)\n    {\n\
    \        if (i < 0)\n            res *= -1;\n        else if (i == 0)\n      \
    \      res = 0;\n        res *= abs(i);\n    }\n    return res;\n}\n/*", "{\n\
    \    // Your code goes here\n    if (arr.length == 0) return null;\n    long prod\
    \ = 1;\n    long s = 0;\n    foreach (x; arr)\n    {\n        if (x > 0)\n   \
    \     {\n            prod *= 1;\n            s += x;\n        }\n        else\
    \ if (x < 0)\n        {\n            prod *= -1;\n            s += abs(x);\n \
    \       }\n        else\n        {\n            prod *= 0;\n        }\n    }\n\
    \    return prod * s;\n}", "{\n    long sign, prod, sum;\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        sign = arr[i] == 0 ? 0 : arr[i] < 0 ? -1\
    \ : 1;\n        prod *= sign;\n        sum += sign == 0 ? 0 : abs(arr[i]);\n \
    \   }\n    return sum == 0 ? null : sum * prod;\n}", "{\n    if (arr.length ==\
    \ 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (a; arr) \n    {\n        if (a == 0) \n        {\n            prod = 0;\n \
    \           break;\n        }\n        sum += abs(a);\n        prod *= (a < 0)\
    \ ? -1 : 1;\n    }\n    return make!(Nullable)(sum * prod);\n}", "{\n    if (arr.length\
    \ == 0) return null;\n    long prod_signs = 1L;\n    long prod_mag = 1L;\n   \
    \ for (long l : arr)\n    {\n        prod_signs *= sign(l);\n        prod_mag\
    \ *= abs(l);\n    }\n    return make!Nullable(prod_signs * prod_mag);\n}", "{\
    \ \n    if (arr.length == 0) return null;\n    long s = product(map!((x) => sign(x))(arr));\n\
    \    long m = sum(map!((x) => abs(x))(arr));\n    return s * m;\n}", "{ \n   \
    \ auto res = arr.map!((n) => n == 0 ? 0 : n > 0 ? 1 : -1).product;\n    return\
    \ arr.empty ? null : res * arr.map!((n) => abs(n)).sum;\n}", "{\n    Nullable!(long)\
    \ prod_signs = long.init;", "{\n    // Your code here\n    int product = 1;\n\
    \    long sum = 0;\n    foreach(num; arr)\n    {\n        product *= sign(num);\n\
    \        sum += num;\n    }\n    if(sum == 0)\n        return null;\n    return\
    \ sum * product;\n}", "{\n    if (arr.length == 0) return null;", "{\n    if (arr.length\
    \ == 0) return typeof(return).init;\n    long mag = 0L;\n    int sign = 1;\n \
    \   foreach (i; arr) \n    {\n        if (i == 0) continue;\n        sign *= signbit(i)\
    \ ? -1 : 1;\n        mag += abs(i);\n    }\n    return mag * sign;\n}", "{\n \
    \   if (arr.length == 0)\n        return null;\n    else \n    {\n        long\
    \ res = 1;\n        long sum = 0;\n        foreach (elem; arr) \n        {\n \
    \           if (elem > 0)\n                res *= 1;\n            else if (elem\
    \ < 0)\n                res *= -1;\n            else\n                res *= 0;\n\
    \            sum += abs(elem);\n        }\n        return sum*res;\n    }\n}",
  "{\n    if (arr.length == 0)\n        return Nullable!(long)();\n    long prod =\
    \ 1L;\n    long sum = 0L;\n    foreach (idx, val; arr)\n    {\n        if (val\
    \ > 0)\n            prod *= 1L;\n        else if (val < 0)\n            prod *=\
    \ -1L;\n        else\n            prod *= 0L;\n        sum += abs(val);\n    }\n\
    \    return Nullable!(long)(sum * prod);\n}", "{\n\tif (arr.length == 0) return\
    \ null;\n\tlong sum = 0L;\n\tlong prod = 1L;\n\tforeach (i; arr) \n\t{\n\t\tsum\
    \ += i > 0 ? i : -i;\n\t\tprod *= sign(i);\n\t}\n\treturn tuple(sum, prod).product;\n\
    }", "{\n    // write your code here\n    // Return null for empty arr\n    if\
    \ (arr.length == 0) return null;\n    Nullable!(long) res;\n    long sum = 0;\n\
    \    long prod = 1;\n    foreach (elem; arr)\n    {\n        if (elem > 0) \n\
    \        {\n            sum += elem;\n            prod *= 1;\n        }\n    \
    \    else if (elem < 0) \n        {\n            sum += abs(elem);\n         \
    \   prod *= -1;\n        }\n        else\n        {\n            prod *= 0;\n\
    \        }\n    }\n    if (prod == 0) return 0;\n    res = sum * prod;\n    return\
    \ res;\n}", "in {\n  assert(arr.length == 0 || arr.length > 0);\n}\nout(result)\
    \ {\n  assert(arr.length == 0 || result == null || (result > 0 && result % 1 ==\
    \ 0));\n}\n{\n  if (arr.length == 0) {\n    return null;\n  }\n  else {\n    long\
    \ sign_product = 1;\n    long mag_sum = 0;\n    for (long n in arr) {\n      sign_product\
    \ *= sign(n);\n      mag_sum += abs(n);\n    }\n    return mag_sum * sign_product;\n\
    \  }\n}", "{\n    long sum = 0;\n    long prod = 1;\n    foreach(i; arr) \n  \
    \  {\n        if (i > 0) \n        {\n            sum += i;\n        }\n     \
    \   else if (i < 0) \n        {\n            sum += -i;\n            prod *= -1;\n\
    \        }\n        else \n        {\n            return null;\n        }\n  \
    \  }\n    return make!Nullable(sum * prod);\n}\n/*", "{\n    if (arr.length ==\
    \ 0)\n        return null;\n    long res = 1;\n    long sum = 0;\n    foreach\
    \ (l; arr) \n    {\n        int sign = (l > 0) ? 1 : -1;\n        sum += sign\
    \ * abs(l);\n        res *= sign;\n    }\n    return sum * res;\n}", "{\n    /*\n\
    \    return -1L;\n    */\n    Nullable!(long) rval = Nullable!(long)();\n    if\
    \ (arr.length == 0)\n    {\n        rval = Nullable!(long)();\n    }\n    else\n\
    \    {\n        long sum = 0L;\n        long prod = 1L;\n        foreach (a; arr)\n\
    \        {\n            sum += abs(a);\n            prod *= sign(a);\n       \
    \ }\n        rval = Nullable!(long)(sum * prod);\n    }\n    return rval;\n}\n\
    static assert(prod_signs([1L, 2L, 2L, -4L]) == 9L);\nstatic assert(prod_signs([0L,\
    \ 1L]) == 0L);\nstatic assert(prod_signs([]) is null);", "{ \n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (elem;\
    \ arr)\n    {\n        int sign = elem == 0 ? 0 : elem > 0 ? 1 : -1;\n       \
    \ sum += abs(elem);\n        prod *= sign;\n    }\n    return sum * prod;\n}",
  "{\n    if (arr.length == 0)\n        return null;\n    \n    long prodSigns = 1L;\n\
    \    long sumMagnitudes = 0L;\n    foreach (index, val; arr)\n    {\n        if\
    \ (val == 0)\n            continue;\n        if (val < 0)\n            prodSigns\
    \ *= -1;\n        sumMagnitudes += abs(val);\n    }\n    return sumMagnitudes\
    \ * prodSigns;\n}", "{\n    if (arr.length == 0) return null;\n    return arr.map!(abs).product\
    \ * arr.map!(x => signbit(x) ? -1 : 1).product;\n}", "{\n    import std.algorithm\
    \ : map, reduce;\n    return arr.length ? reduce!((a, b) => a * b)(arr.map!(i\
    \ => sign(i)) * arr.map!(i => abs(i))) : null;\n}", "{\n    if (arr.length ==\
    \ 0)\n        return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach\
    \ (i; arr)\n    {\n        prod *= sign(i);\n        sum += abs(i);\n    }\n \
    \   return sum * prod;\n}", "{\n    /*\n    long output = 0;\n    if (arr.length\
    \ == 0) return null;\n    foreach (i; arr) {\n        switch (sign(i)) {\n   \
    \         case -1:\n                output += abs(i);\n                break;\n\
    \            case 0:\n                continue;\n            case 1:\n       \
    \         output += abs(i);\n                break;\n        }\n    }\n    return\
    \ output;\n    */\n    if (arr.length == 0) return null;\n    return arr.map!(abs).sum;\n\
    }", "{\n    auto prod = 1L;\n    auto sum = 0L;\n    auto e = arr.empty;\n   \
    \ if(e)\n        return null;\n    else\n    {\n        foreach(l; arr)\n    \
    \    {\n            auto s = abs(l) / l;\n            if(s == 0)\n           \
    \     continue;\n            else\n            {\n                sum += abs(l);\n\
    \                prod *= s;\n            }\n        }\n        return sum * prod;\n\
    \    }\n}\n/*\n    Function that receives array of integers and returns true\n\
    \    if the array is sorted, otherwise returns false.\n    Note: return true for\
    \ empty arr.", "{\n    Nullable!(long) res = Nullable!(long)();\n    if(arr.length\
    \ == 0)\n        return res;\n    long prod = 1L;\n    long sum = 0L;\n    foreach(i;\
    \ arr)\n    {\n        if(i < 0)\n            prod *= -1L;\n        else if(i\
    \ == 0)\n            prod = 0L;\n        sum += abs(i);\n    }\n    res.set(sum\
    \ * prod);\n    return res;\n}", "in\n{\n    assert(arr.length == 0 || arr.length\
    \ >= 2);\n}\nout\n(result)\n{\n    assert(result != null);\n}\ndo\n{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (index,\
    \ element; arr)\n    {\n        if (element == 0) continue;\n        sum += abs(element);\n\
    \        prod *= sign(element);\n    }\n    return product(sum, prod);\n}", "{\n\
    \    import std.algorithm;\n    import std.conv;\n    import std.math;\n    import\
    \ std.typecons;\n    if (arr.length == 0)\n        return null;\n    return arr.map!(a\
    \ => (a > 0) ? 1L : (a < 0) ? -1L : 0L).product() * arr.map!(abs).sum();\n}",
  "{ \n\tlong sum = 0;\n\tlong prod = 1;\n\tforeach(num; arr)\n\t{\n\t\tif(num > 0)\n\
    \t\t{\n\t\t\tsum += num;\n\t\t\tprod *= 1;\n\t\t}\n\t\telse if(num < 0)\n\t\t\
    {\n\t\t\tsum += abs(num);\n\t\t\tprod *= -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum\
    \ += 0;\n\t\t\tprod *= 0;\n\t\t}\n\t}\n\tif(arr.length == 0)\n\t{\n\t\treturn\
    \ null;\n\t}\n\telse\n\t{\n\t\treturn (sum * prod);\n\t}\n}", "{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum_magnitudes = 0;\n    long product_signs\
    \ = 1;\n    foreach (ele; arr) \n    {\n        long sign = signbit(ele) ? -1\
    \ : 1;\n        long magnitude = abs(ele);\n        product_signs *= sign;\n \
    \       sum_magnitudes += magnitude;\n    }\n    return make!(Nullable)(sum_magnitudes\
    \ * product_signs);\n}", "{\n    long prod = 1L;\n    long sum = 0L;\n    long[]\
    \ arr;\n    foreach(el; arr)\n    {\n        if(el < 0)\n        {\n         \
    \   prod *= -1;\n        }\n        else if(el == 0)\n        {\n            prod\
    \ = 0;\n        }\n        sum += abs(el);\n    }\n    return prod * sum;\n}",
  "{\n    import std.algorithm : reduce;\n    import std.conv : text;\n    import\
    \ std.range : zip;\n    import std.typecons : tuple;\n    if (arr.length == 0)\n\
    \        return null;\n    else\n    {\n        auto signs = arr.map!((e) => tuple(e,\
    \ (e > 0) ? 1 : (e < 0) ? -1 : 0));\n        return signs.reduce!((a, b) => tuple(a[0],\
    \ a[1] * b[1])).map!((a) => a[0] * a[1]).array;\n    }\n}", "{\n    // TODO\n}",
  "{\n\tlong cumProd = 1L;\n\tlong cumSum = 0L;\n\tif (arr.length == 0)\n\t{\n\t\t\
    return null;\n\t}\n\telse\n\t{\n\t\tforeach (element; arr)\n\t\t{\n\t\t\tcumProd\
    \ *= sign(element);\n\t\t\tcumSum += abs(element);\n\t\t}\n\t\treturn cumProd\
    \ * cumSum;\n\t}\n}", "{\n    Nullable!(long) result = Nullable!(long)(0L);\n\
    \    foreach(n; arr)\n    {\n        if(n > 0)\n        {\n            result.assign(result.get!(long)\
    \ + n);\n        } else if(n < 0)\n        {\n            result.assign(result.get!(long)\
    \ - n);\n        }\n    }\n    return result;\n}\n/*\n    You are given two lists\
    \ a and b. If a[0] is 0, then b[0] should be returned\n    as result, if a[1]\
    \ is 0, then b[1] should be returned as result, etc.\n    If no numbers in a is\
    \ 0, then return 0.\n    Example:\n    >>> bingo([1L, 2L, 0L, 4L, 0L], [9L, 7L,\
    \ 5L, 3L, 1L])\n    5L\n    >>> bingo([0L, 1L, 2L, 3L, 4L], [5L, 6L, 7L, 8L, 9L])\n\
    \    5L\n    >>> bingo([1L, 2L, 3L, 4L, 5L], [6L, 7L, 8L, 9L, 10L])\n    0L\n\
    \    >>> bingo([], [])\n    0L\n*/\nlong bingo(long[] a, long[] b) \n{\n    foreach(i,\
    \ value; a)\n    {\n        if(value == 0)\n        {\n            return b[i];\n\
    \        }\n    }\n    return 0L;\n}\n/*\n    Given an array of integers, return\
    \ the sum of products of all non-unique numbers\n    Example:\n    >>> sum_of_nonunique_products([1L,\
    \ 2L, 3L, 2L, 4L])\n    12L\n    >>> sum_of_nonunique_products([1L, 2L, 3L, 3L,\
    \ 4L])\n    11L\n    >>> sum_of_nonunique_products([1L, 2L, 3L, 1L, 4L])\n   \
    \ 10L\n    >>> sum_of_nonunique_products([1L, 2L", "{\n    if (arr.length == 0)\
    \ \n    {\n        return null;\n    }\n    Tuple!(long, int) fold_f(Tuple!(long,\
    \ int) acc, long x) \n    {\n        return tuple(acc[0] + abs(x), acc[1] * sign(x));\n\
    \    }\n    auto sum_prod = arr.fold!fold_f(tuple(0L, 1));\n    return sum_prod[0]\
    \ * sum_prod[1];\n}", "{\n    if (arr.length == 0)\n        return null;\n   \
    \ long mul = 1;\n    long sum = 0;\n    foreach (elem; arr) \n    {\n        if\
    \ (elem > 0)\n            mul *= 1;\n        else if (elem < 0)\n            mul\
    \ *= -1;\n        else\n            mul *= 0;\n        sum += abs(elem);\n   \
    \ }\n    return sum * mul;\n}", "{\n    if (arr.length == 0) \n    {\n       \
    \ return null;\n    }\n    size_t prod = 1;\n    long result = 0;\n    for (int\
    \ i = 0; i < arr.length; i++) \n    {\n        if (arr[i] < 0) \n        {\n \
    \           prod *= -1;\n        }\n        if (arr[i] != 0) \n        {\n   \
    \         result += abs(arr[i]);\n        }\n    }\n    return prod * result;\n\
    }", "{\n    Nullable!(long) val = 0L;\n    if (arr.length == 0)\n        return\
    \ null;\n    else\n    {\n        for (long d : arr)\n        {\n            val.assign(abs(d)\
    \ * (val.isNull ? 1L : val.get) * sign(d));\n        }\n        return val;\n\
    \    }\n}", "{\n    Nullable!(long) signs = product(0L, arr.length, (idx) => {\n\
    \        if (arr[idx] < 0)\n            return -1L;\n        else if (arr[idx]\
    \ > 0)\n            return 1L;\n        else\n            return 0L;\n    });\n\
    \    Nullable!(long) magnitudes = sum(0L, arr.length, (idx) => abs(arr[idx]));\n\
    \    return nullableFun1(signs, (x) => nullableFun1(magnitudes, (y) => x * y));\n\
    }", "{\n    if (arr.length == 0) return null;\n    long magnitudes = 0;\n    long\
    \ signs = 1;\n    foreach (i; arr) \n    {\n        magnitudes += abs(i);\n  \
    \      signs *= sign(i);\n    }\n    return magnitudes * signs;\n}", "{\n    if\
    \ (arr.length == 0) \n    {\n        return null;\n    }", "{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach (num;\
    \ arr)\n    {\n        if (num < 0) prod *= -1;\n        if (num == 0) prod =\
    \ 0;\n        sum += abs(num);\n    }\n    return prod * sum;\n}", "{\n\tif (arr.length\
    \ == 0)\n\t{\n\t\treturn Nullable!(long)();\n\t}\n\tlong[] signs = arr.map!(x\
    \ =>\n\t{\n\t\tif (x == 0)\n\t\t{\n\t\t\treturn long(0);\n\t\t}\n\t\treturn (x\
    \ > 0) ? long(1) : long(-1);\n\t});\n\tlong sum = arr.map!(x => abs(x)).sum;\n\
    \tlong prod = signs.product;\n\treturn Nullable!(long)(sum * prod);\n}", "{\n\
    \    if (arr.length == 0) return null;\n    long prod = 1L;\n    long sum = 0L;\n\
    \    foreach (elem; arr) \n    {\n        sum += abs(elem);\n        prod *= sign(elem);\n\
    \    }\n    return tuple(sum, prod);\n}", "{\n    long[] signs;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] > 0)\n        {\n   \
    \         sign = 1;\n        }\n        else if (arr[i] < 0)\n        {\n    \
    \        sign = -1;\n        }\n        else\n        {\n            sign = 0;\n\
    \        }\n        signs ~= sign;\n    }\n    int product = 1;\n    for (int\
    \ i = 0; i < signs.length; i++)\n    {\n        product *= signs[i];\n    }\n\
    \    long magnitude = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n  \
    \      magnitude += abs(arr[i]);\n    }\n    return product * magnitude;\n}",
  "{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long\
    \ sum  = 0;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod\
    \ *= sign(i);\n    }\n    return sum * prod;\n}\n ", "{\n    if (arr.length ==\
    \ 0) \n    {\n        return null;\n    }\n    long prod = 1L;\n    long sum =\
    \ 0L;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n        \
    \    prod *= 1L;\n        } \n        else if (i < 0) \n        {\n          \
    \  prod *= -1L;\n        } \n        else \n        {\n            prod *= 0L;\n\
    \        }\n        sum += i.abs;\n    }\n    return sum * prod;\n}", "{\n   \
    \ if (arr.length == 0) \n    {\n        return null;\n    }", "{\n    import std.range;\n\
    \    import std.algorithm;\n    return arr.empty ? null : \n           product!((a,\
    \ b) => a * b)(\n               arr.map!(abs)\n                  .zip(arr.map!(x\
    \ => \n                         x > 0L ? 1L : (x < 0L ? -1L : 0L)))\n        \
    \          .map!(a => a[0] * a[1]));\n}\n ", "{\n    auto sign = 1;\n    long\
    \ sum = 0;\n    foreach(el; arr)\n    {\n        sign *= el < 0 ? -1 : el == 0\
    \ ? 0 : 1;\n        sum += abs(el);\n    }\n    return sign != 0 ? sum * sign\
    \ : null;\n}", "{\n    // 1. calculate product of signs\n    // 2. calculate sum\
    \ of magnitudes\n    // 3. return product of 1 and 2\n    if (arr.length == 0)\n\
    \        return null;\n    \n    auto sign_product = 1L;\n    auto magnitude_sum\
    \ = 0L;\n    foreach (v; arr) \n    {\n        auto sign = v > 0 ? 1L : (v < 0\
    \ ? -1L : 0L);\n        sign_product *= sign;\n        magnitude_sum += abs(v);\n\
    \    }\n    return sign_product * magnitude_sum;\n}", "{\n    long prod = 1L;\n\
    \    long sum = 0L;\n    // Iterating through array and assigning elements \n\
    \    // to 'x' variable.\n    foreach(long x; arr) \n    {\n        if (x < 0)\n\
    \        {\n            prod *= -1;\n        }\n        else if (x == 0)\n   \
    \     {\n            return 0L;\n        }\n        sum += abs(x);\n    }\n  \
    \  return sum * prod;\n}", "{\n    if (arr.length == 0)\n        return null;\n\
    \    if (arr.length == 1)\n        return arr[0];\n    int prod;\n    long sum;\n\
    \    auto signs = arr.map!(a => abs(a)/a);\n    prod = reduce!((a, b) => a * b)(signs);\n\
    \    sum = reduce!((a, b) => a + b)(arr.map!(a => abs(a)));\n    return sum *\
    \ prod;\n}", "{\n\tif (arr.length == 0)\n\t\treturn null;\n\t\n\tlong product\
    \ = 1;\n\tlong sum = 0;\n\t\n\tfor (long element; element in arr) \n\t{\n\t\t\
    long val = abs(element);\n\t\t\n\t\tif (element == 0)\n\t\t\tval = 1;\n\t\t\n\t\
    \tsum += val;\n\t\tproduct *= sign(element);\n\t}\n\t\n\treturn sum * product;\n\
    }", "{\n    if (arr.length == 0)\n        return null;\n    /*\n    long prod\
    \ = 0L;\n    long sum = 0L;\n    long sign = 0L;\n    foreach (i; arr) \n    {\n\
    \        if (i > 0)\n            sign = 1L;\n        else if (i < 0)\n       \
    \     sign = -1L;\n        else\n            sign = 0L;\n        prod *= sign;\n\
    \        sum += i;\n    }\n    return prod * sum;\n    */\n    long prod = arr.map!(sign)().product;\n\
    \    long sum = arr.map!(abs).sum;\n    return prod * sum;\n}\n// you can also\
    \ write a function for sign of a number\nlong sign(long i) \n{\n    if (i > 0)\n\
    \        return 1L;\n    else if (i < 0)\n        return -1L;\n    else\n    \
    \    return 0L;\n}\n```", "in\n{\n    assert(arr.length > 0);\n}\nout\n(\n   \
    \ long result\n)\n{\n    result = 0L;\n    foreach (i, v; arr) {\n        switch\
    \ (v)\n        {\n            case 0L:\n                break;\n            case\
    \ -1L:\n                result += abs(v);\n                break;\n          \
    \  default:\n                result += abs(v);\n                break;\n     \
    \   }\n    }\n}\nbody\n{\n    long value = 1L;\n    foreach (i, v; arr) {\n  \
    \      switch (v)\n        {\n            case 0L:\n                result = 0L;\n\
    \                break;\n            case -1L:\n                value *= -1L;\n\
    \                break;\n            default:\n                break;\n      \
    \  }\n    }\n    result *= value;\n}", "{\n    if (arr.length == 0) return null;\n\
    \    long product = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n    \
    \    if (i > 0) product *= 1;\n        else if (i < 0) product *= -1;\n      \
    \  else product *= 0;\n        sum += abs(i);\n    }\n    return product * sum;\n\
    }\n \n/*", "{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n\
    \    auto sign_prod = -1L;\n    auto sum_of_magnitudes = 0L;\n    for (long elem;\
    \ arr) \n    {\n        auto sign = (elem > 0) ? 1L : -1L;\n        sign_prod\
    \ *= sign;\n        sum_of_magnitudes += abs(elem);\n    }\n    return sign_prod\
    \ * sum_of_magnitudes;\n}", "{\n    Nullable!(long) result = null;\n    long sumMagnitudes\
    \ = 0;\n    long prodSigns = 1;\n    foreach(idx, val; arr) \n    {\n        sumMagnitudes\
    \ += abs(val);\n        prodSigns *= sign(val);\n    }\n    result = sumMagnitudes\
    \ * prodSigns;\n    return result;\n}", "{\n    Nullable!(long) sum = Nullable!(long).init;\n\
    \    long[] signs = arr.map!(a => sign(a));\n    if(signs.length == 0)\n     \
    \   return sum;\n    else\n    {\n        sum = signs.product * signs.map!(a =>\
    \ abs(a)).sum;\n        return sum;\n    }\n}", "{\n\tif (arr.length == 0)\n\t\
    \treturn null;\n\telse\n\t{\n\t\tlong sum = 0L;\n\t\tlong prod = 1L;\n\t\tforeach\
    \ (i; arr)\n\t\t{\n\t\t\tsum += abs(i);\n\t\t\tif (i != 0)\n\t\t\t\tprod *= i\
    \ < 0 ? -1 : 1;\n\t\t}\n\t\treturn sum * prod;\n\t}\n}", "{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n\
    \    {\n        sum += i.abs;\n        prod *= i.sign;\n    }\n    return sum\
    \ * prod;\n}", "{\n    if (arr.length == 0)\n        return null;\n    else\n\
    \    {\n        long sign = 1;\n        long magnitude = 0;\n        foreach (n;\
    \ arr)\n        {\n            sign *= n > 0 ? 1 : n < 0 ? -1 : 0;\n         \
    \   magnitude += abs(n);\n        }\n        return magnitude * sign;\n    }\n\
    }", "{\n    return std.algorithm.reduce!((prev, num) => \n    {\n        if (prev\
    \ is null)\n            return num;\n        else if (num is null)\n         \
    \   return null;\n        else\n            return prev + abs(num);\n    })(arr);\n\
    }", "{\n    static assert(arr.length >= 0);\n    static if (arr.length == 0)\n\
    \        return null;\n    else\n    {\n        long prodSigns = 1L;\n       \
    \ long sumMagnitudes = 0L;\n        foreach (int index, ref long value; arr)\n\
    \        {\n            if (value > 0)\n                prodSigns *= 1L;\n   \
    \         else if (value < 0)\n                prodSigns *= -1L;\n           \
    \ else if (value == 0)\n                prodSigns *= 0L;\n            sumMagnitudes\
    \ += abs(value);\n        }\n        return sumMagnitudes * prodSigns;\n    }\n\
    }", "{\n    Nullable!(long) result = Nullable!(long)(long.init);\n    if(arr.length\
    \ == 0L)\n    {\n        return null;\n    }\n    long signs = 1L;\n    long mags\
    \ = 0L;\n    foreach(num; arr)\n    {\n        if(num < 0L)\n        {\n     \
    \       signs *= -1L;\n        }\n        else if(num == 0L)\n        {\n    \
    \        signs = 0L;\n        }\n        mags += abs(num);\n    }\n    result.some\
    \ = signs * mags;\n    return result;\n}", "{\n    long sum = 0;\n    long prod\
    \ = 1;\n    if (arr.length == 0) \n    {\n        return typeof(return).init;\n\
    \    }\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n       \
    \     sum += i;\n        } \n        else if (i < 0) \n        {\n           \
    \ sum += abs(i);\n            prod *= -1;\n        }\n    }\n    return sum *\
    \ prod;\n}", "{\n    // can be simplified using std.functional.map.reduce\n  \
    \  if (arr.length == 0) return null;\n    return arr.map!(a => (a < 0) ? -1 :\
    \ (a > 0) ? 1 : 0).reduce!((a, b) => a * b)(0) * arr.map!(a => abs(a)).reduce!((a,\
    \ b) => a + b)(0);\n}", "{\n    long result = 1L;\n    foreach(num; arr) \n  \
    \  {\n        if (num > 0) \n        {\n            result *= num;\n        }\
    \ \n        else if (num < 0) \n        {\n            result *= -num;\n     \
    \   } \n        else \n        {\n            return tuple(result, 0L).idup;\n\
    \        }\n    }\n    return tuple(result, 1L).idup;\n}", "{\n  if (arr.length\
    \ == 0)\n    return null;\n  else \n  {\n    long prod = 1L;\n    long res = 0L;\n\
    \    foreach (num; arr) \n    {\n      prod *= sign(num);\n      res += abs(num);\n\
    \    }\n    return make!Nullable(res * prod);\n  }\n}", "{\n    Nullable!(long)\
    \ none;\n    if (arr.length == 0)\n        return none;\n    long sign_prod =\
    \ 1L;\n    long mag_sum = 0L;\n    foreach (index, value; arr) \n    {\n     \
    \   sign_prod *= sign(value);\n        mag_sum += abs(value);\n    }\n    return\
    \ tup(sign_prod * mag_sum);\n}\n/*\n    Answer:\n    >>> prod_signs([1L, 2L, 2L,\
    \ -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n*/\n// Example of chained function calls with if/else\n// functions\
    \ can be defined in any order.\n// main is executed last.", "{\n    if (arr.length\
    \ == 0) return null;", "{\n    if (arr.length == 0)\n        return null;\n  \
    \  \n    long magnitude = 0L;\n    long product = 1L;\n    foreach (long index,\
    \ int value; arr)\n    {\n        if (value > 0)\n            product *= 1;\n\
    \        else if (value < 0)\n            product *= -1;\n        else \n    \
    \        product *= 0;\n        \n        magnitude += abs(value);\n    }\n  \
    \  \n    return makeNullable!(long)(magnitude * product);\n}", "{\n    if (arr.length\
    \ == 0) \n    {\n        return typeof(return).init;\n    }\n    int prod = 1;\n\
    \    ulong sum = 0UL;\n    foreach (elem; arr) \n    {\n        if (elem == 0)\
    \ \n        {\n            prod = 0;\n            break;\n        }\n        if\
    \ (elem < 0) \n        {\n            prod *= -1;\n        }\n        sum += cast(ulong)abs(elem);\n\
    \    }\n    return (sum * cast(ulong)prod);\n}\n/*", "{\n    if (arr.length ==\
    \ 0) \n    {\n        return null;\n    }\n    long sign_prod = 1L;\n    long\
    \ sum_magn = 0L;\n    foreach (el; arr) \n    {\n        sum_magn += el.abs;\n\
    \        sign_prod *= el.sign;\n    }\n    return sum_magn * sign_prod;\n}", "{\n\
    \    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long\
    \ sum = 0;\n    long temp;\n    for (auto i = 0; i < arr.length; i++) \n    {\n\
    \        temp = arr[i];\n        if (temp < 0)\n            prod *= -1;\n    \
    \    sum += abs(temp);\n    }\n    return sum * prod;\n}", "{\n    Nullable!(long)\
    \ res = Nullable!(long)();\n    if (arr.length > 0)\n    {\n        long sign_prod\
    \ = 1L;\n        long abs_sum = 0L;\n        foreach (x; arr)\n        {\n   \
    \         sign_prod *= (x == 0) ? 0 : ((x > 0) ? 1 : -1);\n            abs_sum\
    \ += abs(x);\n        }\n        res = Nullable!(long)(sign_prod * abs_sum);\n\
    \    }\n    return res;\n}", "{\n    if (arr.length == 0)\n        return Nullable!(long)();\n\
    \    long prod = 1;\n    long sum  = 0;\n    foreach (i; arr) \n    {\n      \
    \  if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *=\
    \ i >= 0 ? 1 : -1;\n    }\n    return Nullable!(long)(sum * prod);\n}", "{\n \
    \   if (arr.length == 0) \n    {\n        return null;\n    }\n    long prod =\
    \ 1L;\n    foreach (item; arr) \n    {\n        prod *= item < 0 ? -1L : item\
    \ > 0 ? 1L : 0L;\n    }\n    if (prod == 0L) \n    {\n        return 0L;\n   \
    \ }\n    long sum = 0L;\n    foreach (item; arr) \n    {\n        sum += item\
    \ * (item < 0 ? -1L : 1L);\n    }\n    return sum;\n}", "{\n    long r;\n    if\
    \ (arr.length == 0) \n    {\n        return null;\n    }\n    r = arr[0];\n  \
    \  foreach (i; 1 .. arr.length) \n    {\n        auto t = arr[i];\n        r *=\
    \ t / abs(t);\n    }\n    return map!(a => abs(a))(arr).reduce!(\"a + b\") * r;\n\
    }", "{\n    if (arr.length == 0)\n        return null;\n    Nullable!(long) product\
    \ = Nullable!(long)(1L);\n    long sum = 0L;\n    for (long i = 0L; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] == 0L)\n            product = null;\n      \
    \  if (arr[i] < 0L)\n            product *= -1L;\n        sum += abs(arr[i]);\n\
    \    }\n    if (product is null)\n        return 0L;\n    return product * sum;\n\
    }", "{\n    if (arr.length == 0)\n        return Nullable!(long)();\n    return\
    \ abs(arr.product) * arr.sum;\n}\n \n/*\n*   Write a function, which takes two\
    \ objects and checks if they have the same\n*   properties and values.\n*/", "{\n\
    \    if (arr.length == 0)\n        return null;\n    long[] signs = arr.map!(a\
    \ => a < 0 ? -1L : a > 0 ? 1L : 0L);\n    long product = signs.reduce!((a, b)\
    \ => a * b)(1L);\n    long sum_magnitudes = arr.map!(a => a < 0 ? -a : a).reduce!((a,\
    \ b) => a + b)(0L);\n    return product * sum_magnitudes;\n}\n ", "{\n    // if\
    \ the array is empty return null\n    if (arr.length == 0) return null;\n    //\
    \ initialize a product to 1\n    long product = 1;\n    // initialize a sum of\
    \ magnitudes to 0\n    long sum_of_magnitudes = 0;\n    // for each value in the\
    \ array\n    foreach (value; arr)\n    {\n        // add the magnitude of the\
    \ value to the sum\n        sum_of_magnitudes += abs(value);\n        // multiply\
    \ the product by the sign of the value\n        product *= (long)sign(value);\n\
    \    }\n    // return the product of the sign times the sum of the magnitudes\n\
    \    return product * sum_of_magnitudes;\n}\n/*\n    You are given an array, which\
    \ will contain either positive or\n    negative integers or empty strings.", "{\n\
    \    if (arr.length == 0)\n        return null;\n    // Alternative:\n    // if\
    \ (arr.empty)\n    //     return null;\n    // if (arr.length == 0)\n    //  \
    \   return null;\n    long prod_signs = 1L;\n    long sum_magnitudes = 0L;\n \
    \   for (int i = 0; i < arr.length; i++)\n    {\n        long sign = signbit(arr[i]);\n\
    \        if (sign == 0)\n            sign = 1L;\n        else if (sign == 1)\n\
    \            sign = -1L;\n        prod_signs *= sign;\n        sum_magnitudes\
    \ += abs(arr[i]);\n    }\n    return sum_magnitudes * prod_signs;\n}", "{\n  \
    \  Nullable!(long) prod = Nullable!(long)(1L);\n    Nullable!(long) mag = Nullable!(long)(0L);\n\
    \    for (long index = 0; index < arr.length; index++) \n    {\n        if (arr[index]\
    \ > 0)\n        {\n            prod = prod.get * 1L;\n            mag = mag.get\
    \ + arr[index];\n        } \n        else if (arr[index] < 0)\n        {\n   \
    \         prod = prod.get * -1L;\n            mag = mag.get + abs(arr[index]);\n\
    \        }\n        else\n        {\n            prod = Nullable!(long)();\n \
    \           mag = Nullable!(long)();\n            break;\n        }\n    }\n \
    \   return prod * mag;\n}", "{\n    if (arr.length == 0)\n        return null;\n\
    \    \n    long prod = 1;\n    foreach (num; arr) \n    {\n        if (num > 0)\n\
    \            prod *= 1;\n        else if (num < 0)\n            prod *= -1;\n\
    \        else\n            prod *= 0;\n    }\n    \n    long sum = 0;\n    foreach\
    \ (num; arr) \n    {\n        if (num > 0)\n            sum += num;\n        else\
    \ if (num < 0)\n            sum += -num;\n        else\n            sum += 0;\n\
    \    }\n    \n    return sum * prod;\n}", "{\n    if (arr.length == 0) \n    {\n\
    \        return Nullable!(long)();\n    }\n    long sum = 0;\n    long prod =\
    \ 1;\n    foreach (i; arr) \n    {\n        if (i == 0) \n        {\n        \
    \    prod = 0;\n            break;\n        }\n        if (i < 0) \n        {\n\
    \            prod *= -1;\n        }\n        sum += abs(i);\n    }\n    return\
    \ Nullable!(long)(sum * prod);\n}", "{\n    if (arr.length == 0) \n    {\n   \
    \     return Nullable!(long)();\n    }\n    long[] signs = map!(sign)(arr);\n\
    \    long signs_product = reduce!(mul)(signs);\n    long[] magnitudes = map!(abs)(arr);\n\
    \    long magnitudes_sum = reduce!(add)(magnitudes);\n    return Nullable!(long)(magnitudes_sum\
    \ * signs_product);\n}", "{\n    // You need to write your code here\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long result\
    \ = 0;\n        long product = 1;\n        foreach (long i; arr) \n        {\n\
    \            if (i != 0) \n            {\n                result += abs(i);\n\
    \                product *= i / abs(i);\n            }\n        }\n        return\
    \ result * product;\n    }\n}", "{\n    long ret;\n    int i;\n    int p;\n  \
    \  if (arr.length == 0)\n        return null;\n    ret = 0;\n    p = 1;\n    for\
    \ (i = 0; i < arr.length; i++)\n    {\n        ret += arr[i] * arr[i];\n     \
    \   if (arr[i] > 0)\n            p *= 1;\n        else if (arr[i] < 0)\n     \
    \       p *= -1;\n        else\n            p *= 0;\n    }\n    return ret * p;\n\
    }\n/*\n    You are given an array of ints.\n    You are to return the sum of all\
    \ positive numbers in the array,\n    or null if the array is empty.", "{\n  \
    \  if (arr.length == 0)\n        return null;\n    auto prod = 1L;\n    auto sum\
    \ = 0L;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *=\
    \ 1L;\n        else if (i < 0)\n            prod *= -1L;\n        else\n     \
    \       prod *= 0L;\n        sum += abs(i);\n    }\n    return sum * prod;\n}",
  "{\n    if (arr.length == 0)\n        return null;\n    long sum = 0L;\n    long\
    \ prod = 1L;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod\
    \ *= sign(i);\n    }\n    return sum * prod;\n}", "{\n    import std.algorithm;\n\
    \    import std.array;\n    import std.range;\n    import std.range.primitives;\n\
    \    import std.typecons;\n    import std.numeric;\n    import std.numeric.interval;\n\
    \    alias null long;\n    long default_value = null;\n    if (arr.empty) \n \
    \   {\n        return default_value;\n    }\n    long result = reduce!\"*\"(map!\"\
    abs(a) * signum(a)\".array(arr));\n    return result;\n}", "{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long product\
    \ = 1L;\n        long sum = 0L;\n        foreach (element; arr) \n        {\n\
    \            product *= element >= 0 ? 1L : -1L;\n            sum += abs(element);\n\
    \        }\n        return product * sum;\n    }\n}", "{\n    if (arr.length ==\
    \ 0) \n    {\n        return Nullable!(long)();\n    }", "{\n    if (arr.length\
    \ == 0)\n        return null;\n    else\n    {\n        long prod = 1L;\n    \
    \    long sum = 0L;\n        foreach (num; arr)\n        {\n            if (num\
    \ > 0)\n                prod *= 1L;\n            else if (num < 0)\n         \
    \       prod *= -1L;\n            else\n                prod *= 0L;\n        \
    \    sum += abs(num);\n        }\n        return sum * prod;\n    }\n}", "{\n\
    \    if (arr.length == 0) \n    {\n        return null;\n    }\n    auto prod\
    \ = new product(arr);\n    return prod.get_sum();\n}", "{\n    long prod = 1;\n\
    \    long sum = 0;\n    if (arr.length == 0)\n        return Nullable!(long)();\n\
    \    foreach (elem; arr)\n    {\n        prod *= signbit(elem);\n        sum +=\
    \ abs(elem);\n    }\n    return prod * sum;\n}", "{\n    if (arr.length == 0)\n\
    \        return null;\n    long sign = 1;\n    foreach (i; arr) \n    {\n    \
    \    sign *= i < 0 ? -1 : i > 0 ? 1 : 0;\n    }\n    long abs_sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        abs_sum += abs(i);\n    }\n    return sign * abs_sum;\n\
    }\n/*\n    You are given an array arr of integers.\n    Your task is to sort the\
    \ array by first odd numbers\n    in ascending order and then even numbers in\
    \ descending order.\n    If there are no odd numbers, you should sort all elements\
    \ in ascending order.\n    If there are no even numbers, you should sort all elements\
    \ in descending order.\n    Note: return sorted array.", "{\n    if (arr.length\
    \ == 0) return null;\n    else \n    {\n        long prod = 1;\n        long sum\
    \ = 0;\n        foreach (el; arr) \n        {\n            if (el == 0) continue;\n\
    \            else if (el > 0) \n            {\n                prod *= 1;\n  \
    \              sum += el;\n            }\n            else \n            {\n \
    \               prod *= -1;\n                sum += -el;\n            }\n    \
    \    }\n        return make!(Nullable)(sum * prod);\n    }\n}", "{\n    long acc_magn\
    \ = 1;\n    long acc_sign = 1;\n    if (arr.length == 0) \n    {\n        return\
    \ null;\n    }\n    foreach (l; arr) \n    {\n        acc_magn *= abs(l);\n  \
    \      acc_sign *= sign(l);\n    }\n    return acc_magn * acc_sign;\n}", "{\n\
    \    if (arr.length == 0) return null;", "{\n    Nullable!(long) prod_signs(long[]\
    \ arr) \n    {\n        import std.algorithm.iteration : filter, map, reduce;\n\
    \        import std.math : sign;\n        import std.array : array;\n        import\
    \ std.conv : to;\n        if (arr.empty) return null;\n        return arr.map!(a\
    \ => abs(a))\n            .reduce!((a, b) => a * b)(1) * \n            arr.filter!(a\
    \ => a != 0)\n                .map!(a => sign(a))\n                .reduce!((a,\
    \ b) => a * b)(1);\n    }\n}", "{\n    import std.algorithm : map, reduce;\n \
    \   return arr.empty ? null : \n        arr.map!((n) => tuple(n, n.sign)).reduce!((a,\
    \ b) => \n            tuple(a[0] * a[1] + b[0] * b[1], a[1] * b[1])).\n      \
    \  reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a, b)\
    \ => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0] *\
    \ b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n\
    \        reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a,\
    \ b) => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0]\
    \ * b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0] * b[1], a[1] *\
    \ b[1])).\n        reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n     \
    \   reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a, b)\
    \ => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0] *\
    \ b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n\
    \        reduce!((a, b) => tuple(a[0] * b[1], a[1", "{\n    if (arr.length ==\
    \ 0)\n        return null;\n    long prodSigns = 1;\n    long sum = 0;\n    foreach\
    \ (num; arr) \n    {\n        prodSigns *= sign(num);\n        sum += abs(num);\n\
    \    }\n    return tuple(sum, prodSigns);\n}\n \n/*\n    We have n bananas with\
    \ identical shape but different weights\n    (weights are given in array arr),\
    \ and m people.", "{\n    if (arr.length == 0) return null;\n    long sumOfMagnitudes\
    \ = 0;\n    long productOfSigns = 1;\n    foreach (i; arr)\n    {\n        sumOfMagnitudes\
    \ += abs(i);\n        if (i != 0) productOfSigns *= sign(i);\n    }\n    return\
    \ sumOfMagnitudes * productOfSigns;\n}\n ", "{\n    import std.typecons;\n   \
    \ import std.algorithm;\n    import std.math;\n    Nullable!(long) result = reduce!((a,\
    \ b) => a * b)(map!(i => sign(i))(arr));\n    if (arr.length > 0) \n    {\n  \
    \      return result * reduce!((a, b) => a + b)(map!(i => abs(i))(arr));\n   \
    \ }\n    else\n    {\n        return null;\n    }\n}", "{\n    import std.math\
    \ : abs;\n    import std.typecons : toNullable;\n    if (arr.length > 0)\n   \
    \ {\n        long prod = 1L;\n        long sum = 0L;\n        foreach (num; arr)\n\
    \        {\n            prod *= num.sign;\n            sum += abs(num);\n    \
    \    }\n        return toNullable(sum * prod);\n    }\n    return null;\n}", "{\n\
    \    static import std.array : all;\n    static import std.math : sign;\n    static\
    \ import std.conv : to;\n    import std.typecons : Nullable;\n    alias long ntype\
    \ = long;\n    long signs = arr.map!(sign).all!((a, b) => a * b).to!ntype;\n \
    \   Nullable!ntype result = Nullable!ntype();\n    if (arr.length == 0)\n    \
    \    return null;\n    foreach (elem; arr)\n    {\n        result.get!ntype +=\
    \ abs(elem);\n    }\n    return result.get!ntype * signs;\n}", "{\n    if (arr.length\
    \ == 0)\n        return null;\n    //int product = 1;\n    long product = 1L;\n\
    \    long sum = 0L;\n    foreach (int i, int x; arr)\n    {\n        if (x ==\
    \ 0)\n            continue;\n        if (x > 0)\n            product *= 1;\n \
    \       else if (x < 0)\n            product *= -1;\n        sum += abs(x);\n\
    \    }\n    return product * sum;\n}", "{\n    if (arr.length == 0) \n    {\n\
    \        return null;\n    }", "{\n    if (arr.length == 0) \n    {\n        return\
    \ null;\n    }\n    auto res = arr[0];\n    for (auto i = 1; i < arr.length; i++)\
    \ \n    {\n        res *= arr[i];\n    }\n    if (res < 0) \n    {\n        res\
    \ = -res;\n    }\n    return res;\n}", "{\n    long sum = 0;\n    long prod =\
    \ 1;\n    foreach(i; arr)\n    {\n        if(i != 0)\n        {\n            sum\
    \ += abs(i);\n            prod *= i > 0 ? 1 : -1;\n        }\n    }\n    return\
    \ prod * sum;\n}", "{\n    if (arr.length == 0) \n    {\n        return null;\n\
    \    }\n    else\n    {\n        long sign, res;\n        sign = 1;\n        res\
    \ = 0;\n        foreach (idx, elem; arr)\n        {\n            if (elem == 0)\n\
    \            {\n                continue;\n            }\n            else if\
    \ (elem < 0)\n            {\n                sign *= -1;\n                res\
    \ += abs(elem);\n            }\n            else \n            {\n           \
    \     res += elem;\n            }\n        }\n        return tuple(res, sign).expand;\n\
    \    }\n}", "{\n    auto prod = 1;\n    auto sm = 0;\n    foreach(n; arr) \n \
    \   {\n        prod *= n < 0 ? -1 : n > 0 ? 1 : 0;\n        sm += abs(n);\n  \
    \  }\n    return prod * sm;\n}", "{\n    Nullable!(long) res = null;\n    if (arr.length\
    \ > 0) \n    {\n        long sign = 1;\n        long mul = 1;\n        for (i;\
    \ arr.length) \n        {\n            long tmp = arr[i];\n            if (tmp\
    \ > 0)\n                sign *= 1;\n            else if (tmp < 0)\n          \
    \      sign *= -1;\n            else\n                sign *= 0;\n           \
    \ mul *= tmp;\n        }\n        res = abs(mul) * sign;\n    }\n    return res;\n\
    }\n/*\n    1. i, mul and sign are initialized to 0 and 1 respectively.\n    2.\
    \ Iterate over all elements of the array.\n    3. If the value is positive, the\
    \ sign is multiplied by 1,\n       if negative by -1, otherwise by 0.\n    4.\
    \ The value is multiplied to the product.\n    5. The result is calculated as\
    \ the product sign multiplied by\n       the absolute value of the product.\n\
    */", "{ \n    return arr.length == 0 ? null : \n    (arr.map!(a => a > 0 ? 1L\
    \ : (a < 0 ? -1L : 0L)).product) *\n    (arr.map!(a => abs(a)).sum);\n}", "{\n\
    \    Nullable!(long) result = Nullable!(long)();\n    if (arr.length > 0) \n \
    \   {\n        long prod = 1L;\n        long sum = 0L;\n        foreach (i; arr)\
    \ \n        {\n            prod *= typeof(i) == int ? i.sign : 1L;\n         \
    \   sum += abs(i);\n        }\n        result = sum * prod;\n    }\n    return\
    \ result;\n}", "{\n    // TODO: implement your solution here.\n    if (arr.length\
    \ == 0)\n        return null;\n    if (arr.length == 1)\n        return arr[0];\n\
    \    auto sign = 1;\n    auto sum = 0;\n    foreach (val; arr)\n    {\n      \
    \  if (val < 0)\n            sign *= -1;\n        sum += abs(val);\n    }\n  \
    \  return sum * sign;\n}", "{\n    if (arr.length == 0) return null;\n    long\
    \ sum = 0L;\n    int sign = 1;\n    foreach (i; arr)\n    {\n        if (i !=\
    \ 0)\n        {\n            sum += abs(i);\n            sign *= signbit(i) ?\
    \ -1 : 1;\n        }\n    }\n    return sum * sign;\n}\n \n// Function prod_signs\
    \ should work with any array of signed integers.\nstatic assert(prod_signs(cast(int[])[])\
    \ is null);\nstatic assert(prod_signs(cast(int[])[0, 1]) == 0);\nstatic assert(prod_signs(cast(int[])[1,\
    \ 2, 2, -4]) == 9);", "{\n    // TODO\n    return null;\n}\n \n/*\n    You are\
    \ given an array arr of integers and you need to return\n    true if array contains\
    \ a subset with sum of integers equals to 0.\n    Note: return null for empty\
    \ arr.", "{\n    long res = 1L;\n    long abs_sum = 0L;\n    if (arr.length ==\
    \ 0)\n        return null;\n    foreach (idx, val; arr)\n    {\n        if (val\
    \ > 0)\n            res *= 1L;\n        else if (val < 0)\n            res *=\
    \ -1L;\n        else\n            res *= 0L;\n        abs_sum += abs(val);\n \
    \   }\n    return Nullable!(long)(res * abs_sum);\n}", "{\n    if (arr.length\
    \ == 0)\n        return null;\n    long total = 1;\n    long sum_of_magnitudes\
    \ = 0;\n    foreach (num; arr) \n    {\n        if (num != 0) \n        {\n  \
    \          sum_of_magnitudes += abs(num);\n            total *= sign(num);\n \
    \       }\n    }\n    return total * sum_of_magnitudes;\n}", "{\n    //TODO: write\
    \ body of prod_signs\n    //\n    long i = 0;\n    Nullable!(long) s = null;\n\
    \    if (arr.length < 1)\n        return null;\n    else {\n        while (i <\
    \ arr.length) {\n            if (s is null) {\n                s = sign(arr[i]);\n\
    \            }\n            else {\n                s *= sign(arr[i]);\n     \
    \       }\n            i++;\n        }\n        return s * product(map!(abs)(arr));\n\
    \    }\n}", "in {\n    if (arr.length > 0)\n    {\n        long x = arr[0];\n\
    \        int v1 = (x > 0L) ? 1 : ((x < 0L) ? -1 : 0);\n        if (v1 == 0) return\
    \ true;\n        foreach (i, x; arr[1 .. $]) \n        {\n            int v2 =\
    \ (x > 0L) ? 1 : ((x < 0L) ? -1 : 0);\n            if (v2 == 0) return true;\n\
    \            if (v1 == v2) return true;\n            v1 = v2;\n        }\n   \
    \ }\n    return true;\n} \nout (Nullable!(long) result) \n{\n    if (arr.length\
    \ == 0) {\n        result = null;\n    }\n    else \n    {\n        long sum_of_magnitudes\
    \ = 0L;\n        int product_of_signs = 1;\n        foreach (x; arr) \n      \
    \  {\n            if (x == 0L) { product_of_signs = 0; }\n            else \n\
    \            {\n                sum_of_magnitudes += abs(x);\n               \
    \ product_of_signs *= sign(x);\n            }\n        }\n        result = product_of_signs\
    \ * sum_of_magnitudes;\n    }\n}", "{\n    if (arr.length == 0) \n    {\n    \
    \    return null;\n    }\n    long res = 1;\n    foreach (num; arr) \n    {\n\
    \        long sign = signbit(num) ? -1 : 1;\n        long mag = num * sign;\n\
    \        res *= mag;\n    }\n    return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
