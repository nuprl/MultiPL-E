name: HumanEval_8_sum_product
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n For a given array of integers,\
  \ return a tuple consisting of a sum and a product of all the integers in an array.\n\
  \    Empty sum should be equal to 0 and empty product should be equal to 1.\n  \
  \  >>> sum_product([])\n    tuple(0L, 1L)\n    >>> sum_product([1L, 2L, 3L, 4L])\n\
  \    tuple(10L, 24L)\n    \n*/\nTuple!(long, long) sum_product(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = sum_product;\n\n    assert(candidate([])\
  \ == tuple(0L, 1L));\n    assert(candidate([1L, 1L, 1L]) == tuple(3L, 1L));\n  \
  \  assert(candidate([100L, 0L]) == tuple(100L, 0L));\n    assert(candidate([3L,\
  \ 5L, 7L]) == tuple(15L, 105L));\n    assert(candidate([10L]) == tuple(10L, 10L));\n\
  }\nvoid main(){}"
completions: ["{\n\tTuple!(long, long) result;\n\tresult.field1 = result.field2 =\
    \ 0;\n\tforeach(n; numbers)\n\t{\n\t\tresult.field1 += n;\n\t\tresult.field2 *=\
    \ n;\n\t}\n\treturn result;\n}\n/*\n Given a list of keywords and a sentence,\
    \ return a dictionary where each keyword maps to a set of indexes where it was\
    \ found in the sentence.\n    >>> find_keywords(\"D D is D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D", "{\n    long sum = 0L;\n    long product = 1L;\n    foreach(n;\
    \ numbers)\n    {\n        sum += n;\n        product *= n;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n    long sum = 0;\n    long product = 1;\n   \
    \ foreach(i; numbers) \n    {\n        sum += i;\n        product *= i;\n    }\n\
    \    return tuple(sum, product);\n}\n/*\nThe output of a process is a string but\
    \ you have to parse it in order to extract the data you are interested in.\nWrite\
    \ a function that returns a tuple.\nThe first element of a tuple is an array of\
    \ integers and the second element is a dictionary which contains\nfrequency of\
    \ occurrence of each of the words in the input string.", "{\n    long sum = 0L;\n\
    \    long product = 1L;\n    foreach(n; numbers) \n    {\n        sum += n;\n\
    \        product *= n;\n    }\n    return tuple(sum, product);\n}\n/*\n For an\
    \ integer array, return an array consisting of two elements:\n    the first is\
    \ the array's sum,\n    the second is the array's product.\n    If the array is\
    \ empty, return an array with two zeros.\n    >>> sum_product_2([])\n    [0L,\
    \ 0L]\n    >>> sum_product_2([1L, 2L, 3L, 4L])\n    [10L, 24L]\n*/\nlong[] sum_product_2(long[]\
    \ numbers) \n{\n    long sum = 0L;\n    long product = 1L;\n    foreach(n; numbers)\
    \ \n    {\n        sum += n;\n        product *= n;\n    }\n    return [sum, product];\n\
    }\n/*\n Return all the integers from a given array that are larger than all the\
    \ elements to their right.\n    >>> larger_than_right([])\n    []\n    >>> larger_than_right([2L,\
    \ 3L, 1L, 5L, 0L])\n    [3L, 5L]\n    >>> larger_than_right([1L, 2L, 3L, 4L, 5L])\n\
    \    [5L]\n*/\nlong[] larger_than_right(long[] numbers) \n{\n    long[] result\
    \ = [];\n    long rightMax = -1L;\n    for(int i = numbers.length - 1; i >= 0;\
    \ i--) \n    {\n        if(numbers[i] > rightMax) \n        {\n            rightMax\
    \ = numbers[i];\n            result ~= numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n Return a tuple consisting of a number and the sum of its digits.\n\
    \    >>> find_number_and_sum_of_digits(7L)\n    tuple(7L, 7L)\n    >>> find_number_and_sum_of_digits(1234L)\n\
    \    tuple(1234L, 10", "{\n    long t_sum = 0;\n    long t_prod = 1;\n    foreach(num;\
    \ numbers) \n    {\n        t_sum += num;\n        t_prod *= num;\n    }\n   \
    \ return tuple(t_sum, t_prod);\n}\n// void main() \n// {\n//     writeln(sum_product([1,\
    \ 2, 3, 4]));\n// }", "{\n    long sum = 0;\n    long product = 1;\n    foreach(num;\
    \ numbers)\n    {\n        sum += num;\n        product *= num;\n    }\n    return\
    \ tuple(sum, product);\n}\n/*\n    Write a function that returns a tuple of a\
    \ minimum and a maximum value in a non-empty array of integers.\n    >>> min_max([2L,\
    \ 4L, 3L, 6L, 1L])\n    tuple(1L, 6L)\n*/\nTuple!(long, long) min_max(long[] numbers)\
    \ \n{\n    long min;\n    long max;\n    foreach(num; numbers)\n    {\n      \
    \  if(num > max)\n        {\n            max = num;\n        }\n        if(num\
    \ < min)\n        {\n            min = num;\n        }\n    }\n    return tuple(min,\
    \ max);\n}\n/*\n    Given an array of integers, return an array of the same integers\
    \ in reverse order.\n    >>> reverse_array([2L, 4L, 3L, 6L, 1L])\n    [1L, 6L,\
    \ 3L, 4L, 2L]\n*/\nlong[] reverse_array(long[] numbers) \n{\n    long[] temp =\
    \ [1];\n    foreach(num; numbers)\n    {\n        temp ~= [num];\n    }\n    temp.reverse;\n\
    \    return temp;\n}\n/*\n    Write a function that takes a string and returns\
    \ a tuple containing the number of upper case letters, lower case letters, \n\
    \    spaces, and punctuation characters.\n    >>> count_chars(\"Aa kiu, I swd\
    \ skieo 236587. GH kiu: sieo?? 25.33\")\n    tuple(3L, 19L, 4L, 5L)\n*/\nTuple!(long,\
    \ long, long, long) count_chars(string str) \n{\n    long spaces = 0;\n    long\
    \ upper = 0;\n    long lower = 0;\n    long punct = 0;\n    foreach(ch; str)\n\
    \    {\n        if(ch == ' ')\n        {\n            spaces++;\n        }\n \
    \       else if(", "{\n    long result_sum = 0L;\n    long result_product = 1L;\n\
    \    foreach(number; numbers)\n    {\n        result_sum += number;\n        result_product\
    \ *= number;\n    }\n    return tuple(result_sum, result_product);\n}", "{\n \
    \   long sum = 0;\n    long product = 1;\n    if (numbers.length > 0)\n    {\n\
    \        for (auto n : numbers)\n        {\n            sum += n;\n          \
    \  product *= n;\n        }\n    }\n    return tuple(sum, product);\n}", "{\n\
    \    // lazy evaluation.\n    long sum = reduce!q{a + b}(0, numbers);\n    long\
    \ product = reduce!q{a * b}(1, numbers);\n    return tuple(sum, product);\n}\n\
    /*\nWrite a function which returns elements that are in the first list but not\
    \ in the second list.", "{\n    static assert(numbers.length == 0 || (isInputRange!(typeof(numbers))\
    \ && is(ElementType!(typeof(numbers)) == long)));\n    return tuple(reduce!((a,\
    \ b) => a + b)(numbers), reduce!((a, b) => a * b)(numbers));\n}", "{\n    long\
    \ sum = 0L;\n    long prod = 1L;\n    foreach(n; numbers) \n    {\n        sum\
    \ += n;\n        prod *= n;\n    }\n    return tuple(sum, prod);\n}", "{\n   \
    \ long sum = 0;\n    long product = 1;\n    foreach(index, number; numbers)\n\
    \    {\n        sum += number;\n        product *= number;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n    return tuple(numbers.sum, numbers.product);\n\
    }\n/*\n Given a tuple of integer coordinates (x, y), you have to swap them.\n\
    \     >>> swap_coordinates((1L, 2L))\n     tuple(2L, 1L)\n     >>> swap_coordinates((0L,\
    \ -1L))\n     tuple(-1L, 0L)\n*/\nTuple!(long, long) swap_coordinates(Tuple!(long,\
    \ long) point) \n{\n    return tuple(point[1], point[0]);\n}\n/*\n You have an\
    \ array of integers, where -99999 stands for empty cell.\n    Your task is to\
    \ find the number of squares of empty cells.\n    >>> empty_cells([[5L, 9L, 6L,\
    \ -99999L, 1L],\n                     [2L, 3L, 7L, 5L, -99999L],\n           \
    \          [7L, -99999L, -99999L, 1L, 2L],\n                     [3L, -99999L,\
    \ 6L, -99999L, 3L],\n                     [1L, 6L, 4L, -99999L, 9L]])\n    2L\n\
    */\nlong empty_cells(long[][] table) \n{\n    long counter = 0;\n    foreach(row;\
    \ table) \n    {\n        foreach(cell; row) \n        {\n            if(cell\
    \ == -99999) \n            {\n                counter++;\n            }\n    \
    \    }\n    }\n    return counter;\n}\n/*\n    You have a list of integer coordinates\
    \ of circles centers and their radiuses.\n    Your task is to find the number\
    \ of overlapping circles.\n    To get the overlapping circles count, you need\
    \ to find the number of points that belong to at least two circles.\n    >>> circles_overlap([((0L,\
    \ 0L), 5L), ((-5L, 5L), 3L), ((5L, 5L), 3L), ((5L, -5L), 3L), ((-5L, -5L), 3L)])\n\
    \    1L\n*/\nlong circles_overlap(Tuple!(Tuple!(long, long), long)[] circles",
  "{\n    auto s = 0L;\n    auto p = 1L;\n    foreach(n; numbers) \n    {\n      \
    \  s += n;\n        p *= n;\n    }\n    return tuple(s, p);\n}", "{\n    return\
    \ numbers.reduce!((a, b) => tuple(a[0] + b, a[1] * b));\n}", "{\n    long product\
    \ = 1;\n    long sum = 0;\n    if (numbers.length == 0)\n    {\n        return\
    \ tuple(sum, product);\n    }\n    for (long num; num in numbers)\n    {\n   \
    \     product *= num;\n        sum += num;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    long p = 1;\n    long s = 0;\n    for(long i = 0; i < numbers.length;\
    \ i++)\n    {\n        p *= numbers[i];\n        s += numbers[i];\n    }\n   \
    \ return tuple(s, p);\n}\n/*\nWe need a function that can transform a number into\
    \ a string.\n    What ways of achieving this do you know?\n    \n*/\nstring number_to_string(long\
    \ n)\n{\n    return to!string(n);\n}\n/*\nGiven an array of strings, you need\
    \ to find the longest string\n    \n*/\nstring find_longest_string(string[] ss)\n\
    {\n    string s = \"\";\n    foreach(string x; ss)\n    {\n        if(x.length\
    \ > s.length)\n        {\n            s = x;\n        }\n    }\n    return s;\n\
    }\n/*\n    You have an array of numbers.\n    Your task is to sort ascending odd\
    \ numbers but even numbers must be on their places.\n    \n    Zero isn't an odd\
    \ number and you don't need to move it. If you have an empty array, you need to\
    \ return it.\n*/", "{\n    long sum = 0L;\n    long product = 1L;\n    foreach(number;\
    \ numbers)\n    {\n        sum += number;\n        product *= number;\n    }\n\
    \    return tuple(sum, product);\n}", "{\n    long sum = 0L;\n    long product\
    \ = 1L;\n    foreach(num; numbers)\n    {\n        sum += num;\n        product\
    \ *= num;\n    }\n    return tuple(sum, product);\n}\n//this is not a good example\
    \ of the tuple usage \n//but it demonstrates that value obtained from the tuple\n\
    // can be unpacked directly into variables", "{\n    long sum = 0;\n    long product\
    \ = 1;\n    foreach(number; numbers) \n    {\n        sum += number;\n       \
    \ product *= number;\n    }\n    return tuple(sum, product);\n}", "{\n    long\
    \ sum = 0L;\n    long product = 1L;\n    foreach(n; numbers) \n    {\n       \
    \ sum += n;\n        product *= n;\n    }\n    return tuple(sum, product);\n}",
  "{\n    long sum = 0L;\n    long product = 1L;\n    foreach(number; numbers) \n\
    \    {\n        sum += number;\n        product *= number;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n    long sum = 0;\n    long prod = 1;\n    foreach(n;\
    \ numbers)\n    {\n        sum += n;\n        prod *= n;\n    }\n    return tuple(sum,\
    \ prod);\n}", "{\n    if (numbers.length == 0)\n        return tuple(0L, 1L);\n\
    \    \n    return tuple(numbers.reduce!(a => a += b) , numbers.reduce!(a => a\
    \ *= b));\n}\n/*\n    Write a function word_count(path) that takes a path to a\
    \ file and counts the occurrences of each word in that file and returns a dictionary\
    \ {word: count}.\n    >>> word_count(\"toy_story.txt\")\n    dictionary[\"and\"\
    : 115, \"you\": 45, \"somewhere\": 1, \"to\": 120, \"woody\": 4, \"mom\": 1, \"\
    car\": 17, \"my\": 31, \"just\": 39, \"are\": 30, \"me\": 7, \"better\": 5, \"\
    they\": 12, \"not\": 9, \"things\": 6, \"nice\": 3, \"the\": 214, \"there\": 9,\
    \ \"out\": 16, \"how\": 8, \"here\": 1, \"little\": 10, \"around\": 7, \"oh\"\
    : 2, \"you'll\": 1, \"get\": 7, \"somewhere.\": 1, \"a\": 113, \"his\": 10, \"\
    what\": 9, \"to.\": 1, \"in\": 32, \"far\": 1, \"me.\": 2, \"so\": 18, \"good\"\
    : 9, \"as\": 20, \"in.\": 1, \"this\": 9, \"like\": 10, \"have\": 23, \"of\":\
    \ 98, \"help\": 4, \"stupid\": 1, \"if\": 18, \"while\": 1, \"back\": 9, \"got\"\
    : 4, \"all\": 35, \"on\": 71, \"he\": 13, \"have.\": 1, \"it\": 58, \"day\": 1,\
    \ \"you're\": 2, \"at\": 21, \"cowboy\": 1, \"and,\": 1, \"i\": 47, \"lost\":\
    \ 2, \"hand-me-down\": 1, \"love\": 6, \"day.\": 1, \"when\": 6, \"can\": 15,\
    \ \"can't\": 7, \"rubbish\": 1, \"be\": 34, \"even\": 3, \"should\": 3, \"when\"\
    : 4, \"but\": 32, \"toy\": 3, \"with\": 33, \"for\":", "{\n\tlong sum = 0L;\n\t\
    long pro = 1L;\n\tforeach(num; numbers)\n\t{\n\t\tsum += num;\n\t\tpro *= num;\n\
    \t}\n\treturn tuple(sum, pro);\n}", "{\n\tauto sum = 0L;\n\tauto product = 1L;\n\
    \tforeach(n; numbers)\n\t{\n\t\tsum += n;\n\t\tproduct *= n;\n\t}\n\treturn tuple(sum,\
    \ product);\n}", "{\n    long p = 1L;\n    long s = 0L;\n    foreach(num; numbers)\n\
    \    {\n        p *= num;\n        s += num;\n    }\n    return tuple(s, p);\n\
    }", "{\n    return Tuple!(long, long)(sum(numbers), reduce!(a * b)(numbers));\n\
    }\n```", "{\n    return numbers.sum!(a => a)(0L),\n           numbers.product!(a\
    \ => a)(1L);\n}", "{\n    long _sum = 0;\n    long _product = 1;\n    foreach(int\
    \ i; 0 .. numbers.length)\n    {\n        _sum += numbers[i];\n        _product\
    \ *= numbers[i];\n    }\n    return tuple(_sum, _product);\n}", "{\n    auto result\
    \ = tuple(0L, 1L);\n    foreach(number; numbers) \n    {\n        result[0] +=\
    \ number;\n        result[1] *= number;\n    }\n    return result;\n}", "{\n \
    \   long sum = 0L;\n    long product = 1L;\n    foreach(val; numbers)\n    {\n\
    \        sum += val;\n        product *= val;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    import std.algorithm : reduce;\n    return (reduce!((a, b) => a +\
    \ b)(numbers), reduce!((a, b) => a * b)(numbers));\n}\n/*\n    For a given array\
    \ of integers, return a tuple consisting of a sum and a product of\n    all the\
    \ integers in an array.\n    Empty sum should be equal to 0 and empty product\
    \ should be equal to 1.\n    >>> sum_product([])\n    tuple(0L, 1L)\n    >>> sum_product([1L,\
    \ 2L, 3L, 4L])\n    tuple(10L, 24L)\n    */", "{\n\tlong sum = 0;\n\tlong product\
    \ = 1;\n\tforeach(n; numbers)\n\t{\n\t\tsum += n;\n\t\tproduct *= n;\n\t}\n\t\
    return tuple(sum, product);\n}", "{\n  long sum = 0;\n  long product = 1;\n  foreach(n;\
    \ numbers) \n  {\n    sum += n;\n    product *= n;\n  }\n  return tuple(sum, product);\n\
    }", "{\n    return Tuple!(long, long)(sum(numbers), reduce! \"a * b\"(1L, numbers));\n\
    }\n/*\n    Create a function that finds the sum of all the numbers in a list that\
    \ are divisible by 3 and greater than 1.\n    Assume the list contains only integers.\n\
    \    >>> sum_divisible_by_3([])\n    0\n    >>> sum_divisible_by_3([1L, 2L, 3L,\
    \ 4L, 5L, 6L])\n    9\n    >>> sum_divisible_by_3([100L, 101L, 102L, 103L, 104L,\
    \ 105L])\n    303\n*/\nlong sum_divisible_by_3(long[] numbers) \n{\n    return\
    \ reduce! \"a + b\"(0L, filter!((n) => n % 3 == 0)(numbers));\n}\n/*\n    Given\
    \ a sorted integer array without duplicates, return the summary of its ranges.\n\
    \    >>> summary_ranges([])\n    [\"\"]\n    >>> summary_ranges([1L, 2L, 3L, 4L,\
    \ 5L])\n    [\"1-5\"]\n    >>> summary_ranges([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L,\
    \ 9L, 15L, 16L, 18L, 19L, 20L, 21L, 22L])\n    [\"1-9\", \"15-16\", \"18-22\"\
    ]\n*/\nstring[] summary_ranges(long[] numbers) \n{\n    immutable first = numbers[0];\n\
    \    immutable last = numbers[0];\n    immutable result = [\"\"];\n    for (immutable\
    \ n = 1; n < numbers.length; n++) \n    {\n        if (numbers[n] == numbers[n\
    \ - 1] + 1) \n        {\n            last = numbers[n];\n        } \n        else\
    \ \n        {\n            if (first == last) \n            {\n              \
    \  result ~= to!string(first);\n            } \n            else \n          \
    \  {\n                result ~= to!string(first) ~ \"-\" ~ to!string(last);\n\
    \            }\n            first = numbers[n];", "{\n    return numbers.length\
    \ == 0 ? tuple(0L, 1L) : \n        tuple(numbers.sum, numbers.reduce!(\"a * b\"\
    ));\n}", "{\n    if (numbers.length == 0)\n        return tuple(0L, 1L);\n   \
    \ else\n    {\n        return tuple(reduce!((a, b) => a + b)(numbers),\n     \
    \                reduce!((a, b) => a * b)(numbers));\n    }\n}", "{\n\tif (numbers.length\
    \ == 0) \n\t{\n\t\treturn tuple(0L, 1L);\n\t} \n\telse \n\t{\n\t\tlong sum = numbers[0];\n\
    \t\tlong product = numbers[0];\n\t\tfor (size_t i = 1; i < numbers.length; i++)\
    \ \n\t\t{\n\t\t\tsum += numbers[i];\n\t\t\tproduct *= numbers[i];\n\t\t}\n\t\t\
    return tuple(sum, product);\n\t}\n}", "{\n    //return tuple(0L, 1L);\n    return\
    \ tuple(reduce!((a, b) => a + b)(numbers), reduce!((a, b) => a * b)(numbers));\n\
    }", "{\n    Tuple!(long, long) result = tuple(0L, 1L);\n    foreach(n; numbers)\
    \ \n    {\n        // use the opBinary* functions\n        result.field1 += n;\n\
    \        result.field2 *= n;\n    }\n    return result;\n}", "{\n    long sum\
    \ = 0;\n    long product = 1;\n    foreach(n; numbers)\n    {\n        sum +=\
    \ n;\n        product *= n;\n    }\n    return tuple(sum, product);\n}", "{\n\
    \    long sum = 0;\n    long product = 1;\n    for (i,n; numbers) \n    {\n  \
    \      sum += n;\n        product *= n;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    long sum = 0L;\n    long product = 1L;\n    for (auto i = 0; i < numbers.length;\
    \ i++) \n    {\n        sum += numbers[i];\n        product *= numbers[i];\n \
    \   }\n    return tuple(sum, product);\n}\n/*\n    The function takes a list of\
    \ words and returns a list of indexes sorted by the word lengths.\n    >>> sort_by_length([\"\
    cat\", \"dog\", \"elephant\"])\n    [0L, 1L, 2L]\n    >>> sort_by_length([\"a\"\
    , \"ccc\", \"dddd\", \"bb\"])\n    [0L, 3L, 1L, 2L]\n    >>> sort_by_length([\"\
    apple\", \"pie\", \"shortcake\"])\n    [2L, 0L, 1L]\n*/\nlong[] sort_by_length(string[]\
    \ words)\n{\n    int[] indexes = [];\n    for (auto i = 0; i < words.length; i++)\n\
    \    {\n        indexes ~= i;\n    }\n    for (int j = 0; j < indexes.length;\
    \ j++)\n    {\n        for (int i = 0; i < indexes.length - 1; i++)\n        {\n\
    \            if (words[indexes[i]].length > words[indexes[i + 1]].length)\n  \
    \          {\n                int tmp = indexes[i];\n                indexes[i]\
    \ = indexes[i + 1];\n                indexes[i + 1] = tmp;\n            }\n  \
    \      }\n    }\n    return indexes;\n}\n/*\n    For a given string return a tuple\
    \ of its hash value and length.\n    >>> hash_len(\"asdf\")\n    tuple(94208091L,\
    \ 4L)\n    >>> hash_len(\"\")\n    tuple(0L, 0L)\n    >>> hash_len(\"Hello World!\"\
    )\n    tuple(1168366735L, 12L)\n*/\nTuple!(int, int) hash_len(string s)\n{\n \
    \   int hash = 0;\n    foreach (c; s)\n    {\n        hash = ((hash << 5) - hash)\
    \ + cast(int)c;", "{\n\tlong sum = 0;\n\tlong product = 1;\n\tforeach(n; numbers)\
    \ \n\t{\n\t\tsum += n;\n\t\tproduct *= n;\n\t}\n\treturn tuple(sum, product);\n\
    }", "{\n    long sum = 0;\n    long product = 1;\n    foreach(n; numbers)\n  \
    \  {\n        sum += n;\n        product *= n;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    long sum = 0;\n    long product = 1;\n    foreach(number; numbers)\
    \ \n    {\n        sum += number;\n        product *= number;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n  Tuple!(long, long) sum_prod = tuple(0L, 1L);\n\
    \  foreach(num; numbers)\n  {\n    sum_prod[0] += num;\n    sum_prod[1] *= num;\n\
    \  }\n  return sum_prod;\n}", "{\n\tlong sum = 0;\n\tlong prod = 1;\n\tforeach(i;\
    \ numbers)\n\t{\n\t\tsum += i;\n\t\tprod *= i;\n\t}\n\treturn tuple(sum, prod);\n\
    }", "{\n    if (numbers.length == 0)\n        return tuple(0L, 1L);\n    return\
    \ tuple(numbers.sum, numbers.product);\n}", "{\n    long sum = 0;\n    long product\
    \ = 1;\n    foreach(n; numbers) \n    {\n        sum += n;\n        product *=\
    \ n;\n    }\n    return tuple(sum, product);\n}", "{\n  if (numbers.length ==\
    \ 0) \n  {\n    return tuple(0L, 1L);\n  }\n  return tuple(numbers.sum, reduce!((i,\
    \ j) => i * j)(numbers));\n}", "{\n    auto sum = 0;\n    auto product = 1;\n\
    \    for (auto n = numbers) \n    {\n        sum += n;\n        product *= n;\n\
    \    }\n    return tuple(sum, product);\n}", "{\n    long resultSum = 0;\n   \
    \ long resultProduct = 1;\n    foreach(idx, val; numbers) \n    {\n        resultSum\
    \ += val;\n        resultProduct *= val;\n    }\n    return tuple(resultSum, resultProduct);\n\
    }", "{\n    long total = 0;\n    long product = 1;\n    foreach(n; numbers)\n\
    \    {\n        total += n;\n        product *= n;\n    }\n    return tuple(total,\
    \ product);\n}", "{\n    return tuple(sum(numbers), product(numbers));\n}\n/*\n\
    \ For a given array of integers, return a tuple consisting of a sum and a product\
    \ of all the integers in an array.\n    Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n    >>> sum_product([])\n    tuple(0, 1)\n  \
    \  >>> sum_product([1, 2, 3, 4])\n    tuple(10, 24)\n    \n*/", "{\n    long sum\
    \ = 0;\n    long product = 1;\n    foreach(number; numbers)\n    {\n        sum\
    \ += number;\n        product *= number;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    Tuple!(long, long) sum_product = tuple(0L, 1L);\n    foreach(elem;\
    \ numbers)\n    {\n        sum_product[0] += elem;\n        sum_product[1] *=\
    \ elem;\n    }\n    return sum_product;\n}", "{\n    if (numbers.length == 0)\n\
    \        return tuple(0L, 1L);\n    auto sum = reduce!((a, b) => a + b)(numbers);\n\
    \    auto product = reduce!((a, b) => a * b)(numbers);\n    return tuple(sum,\
    \ product);\n}", "{\n    long[] products = [], sums = [];\n    foreach(n; numbers)\n\
    \    {\n        append(products, n);\n        append(sums, n);\n    }\n    if(products.length\
    \ == 0)\n        return tuple(0L, 1L);\n    return tuple(reduce!((a, b) => a +\
    \ b)(sums), reduce!((a, b) => a * b)(products));\n}", "{\n    alias Result = Tuple!(long,\
    \ long);\n    if (numbers.length == 0) \n    {\n        return Result(0, 1);\n\
    \    }\n    long sum = 0;\n    long product = 1;\n    foreach (value; numbers)\
    \ \n    {\n        sum += value;\n        product *= value;\n    }\n    return\
    \ Result(sum, product);\n}", "{\n\tlong sum = 0;\n\tlong product = 1;\n\tfor (int\
    \ i = 0; i < numbers.length; i++)\n\t{\n\t\tsum += numbers[i];\n\t\tproduct *=\
    \ numbers[i];\n\t}\n\treturn tuple(sum, product);\n}\n/*\n  For a given string,\
    \ return a new string with all the consecutive duplicates eliminated.\n    >>>\
    \ unique_in_order(\"AAAABBBCCDAABBB\")\n    \"ABCDAB\"\n*/\nstring unique_in_order(string\
    \ input)\n{\n\tstring result = \"\";\n\tforeach (i, ch; input)\n\t{\n\t\tif (i\
    \ == 0 || input[i - 1] != ch)\n\t\t{\n\t\t\tresult ~= ch;\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\n  Given a string, find the first non-repeating character in\
    \ it and return it's index. If it doesn't exist, return -1.\n    >>> first_non_repeating_letter(\"\
    a\")\n    0\n    >>> first_non_repeating_letter(\"stress\")\n    1\n    >>> first_non_repeating_letter(\"\
    moonmen\")\n    3\n*/", "{\n    long sum=0, pro=1;\n    foreach(num; numbers)\
    \ \n    {\n        sum += num;\n        pro *= num;\n    }\n    return tuple(sum,\
    \ pro);\n}", "{\n    auto sum = 0L;\n    auto product = 1L;\n    foreach(i; numbers)\n\
    \    {\n        sum += i;\n        product *= i;\n    }\n    return tuple(sum,\
    \ product);\n}", "{\n    auto sum = 0L;\n    auto product = 1L;\n    foreach(n;\
    \ numbers)\n    {\n        sum += n;\n        product *= n;\n    }\n    return\
    \ tuple(sum, product);\n}\n/*\n    Write a function that takes a list of numbers,\
    \ and returns the largest possible product of any three numbers in a list.\n \
    \   The list may contain both positive and negative numbers. Assume the list will\
    \ always have at least three numbers.\n    >>> largest_product([-3, 1, 2, -2,\
    \ 5, 6])\n    60\n    >>> largest_product([-10, -10, 5, 2])\n    500\n*/\nlong\
    \ largest_product(long[] numbers) \n{\n    assert(numbers.length >= 3);\n    auto\
    \ largest1 = numbers[0];\n    auto largest2 = numbers[1];\n    auto largest3 =\
    \ numbers[2];\n    auto smallest1 = numbers[0];\n    auto smallest2 = numbers[1];\n\
    \    foreach(n; numbers)\n    {\n        if(n > largest1)\n        {\n       \
    \     largest3 = largest2;\n            largest2 = largest1;\n            largest1\
    \ = n;\n        }\n        else if(n > largest2)\n        {\n            largest3\
    \ = largest2;\n            largest2 = n;\n        }\n        else if(n > largest3)\n\
    \        {\n            largest3 = n;\n        }\n        if(n < smallest1)\n\
    \        {\n            smallest2 = smallest1;\n            smallest1 = n;\n \
    \       }\n        else if(n < smallest2)\n        {\n            smallest2 =\
    \ n;\n        }\n    }\n    auto largestPossibleProduct = max(largest1 * largest2\
    \ * largest3, largest1 * smallest1 * smallest2);\n    return largestPossibleProduct;\n\
    }\n/*\n    Write a function that takes a list of strings and returns the list\
    \ of strings sorted by the length of each string.\n    >>> sorted_by_length([\"\
    Google\", \"Apple\", \"Microsoft\"])\n    [\"Apple\", \"Google\", \"Microsoft\"\
    ]\n    >>> sorted_by_length([\"Leonardo\", \"Michelangelo\", \"Raphael\", \"Donatello\"\
    ])", "{\n    long sum = 0;\n    long product = 1;\n    foreach(i; numbers)\n \
    \   {\n        sum += i;\n        product *= i;\n    }\n    return tuple(sum,\
    \ product);\n}", "{\n\tlong sum = 0;\n\tlong product = 1;\n\tforeach(num; numbers)\n\
    \t{\n\t\tsum += num;\n\t\tproduct *= num;\n\t}\n\t\n\treturn tuple(sum, product);\n\
    }", "{\n\tlong sum = 0;\n\tlong product = 1;\n\t\n\tforeach(num; numbers)\n\t\
    {\n\t\tsum += num;\n\t\tproduct *= num;\n\t}\n\t\n\treturn tuple(sum, product);\n\
    }", "{\n    return tuple(reduce!((a, b) => a + b)(0L, numbers),\n        reduce!((a,\
    \ b) => a * b)(1L, numbers));\n}", "{\n    long sum = 0;\n    long prod = 1;\n\
    \    foreach(index, num; numbers)\n    {\n        sum += num;\n        prod *=\
    \ num;\n    }\n    return tuple(sum, prod);\n}\n/*\nGiven a filename and a size,\
    \ return a list of lists of (size)-size chunks of the file.\n    >>> chunks('file.txt',\
    \ 5)\n    [['a', 'b', 'c', 'd', 'e'], ['f', 'g', 'h', 'i', 'j'], ['k', 'l', 'm',\
    \ 'n', 'o'], ['p', 'q', 'r', 's', 't'], ['u', 'v', 'w', 'x', 'y'], ['z']]\n  \
    \  >>> chunks('file.txt', 15)\n    [['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o'], ['p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z']]\n*/\nchar[][] chunks(string fileName, size_t size) \n{\n    auto\
    \ f = File(fileName);\n    f.open();\n    string[] a = f.byLine();\n    f.close();\n\
    \    string str = \"\";\n    char[][] res = new char[a.length][];\n    int k =\
    \ 0;\n    foreach(i, ch; a)\n    {\n        str ~= ch;\n    }\n    foreach(i,\
    \ ch; str)\n    {\n        if (i % size == 0)\n        {\n            res[k] =\
    \ ch.chunks(size);\n            k++;\n        }\n    }\n    return res;\n}\n/*\n\
    Given a positive number n, return a list of lists of (n)-size pascal\u2019s triangle.\n\
    \    >>> pascal(5)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1],\
    \ [", "{\n    return (reduce!((a, b) => a + b)(0L, numbers),\n            reduce!((a,\
    \ b) => a * b)(1L, numbers));\n}", "{\n    long sum = 0;\n    long product = 1;\n\
    \    foreach(n; numbers) \n    {\n        sum += n;\n        product *= n;\n \
    \   }\n    return tuple(sum, product);\n}", "{\n\tlong sum, product;\n\tsum =\
    \ product = 0;\n\tforeach(num; numbers) \n\t{\n\t\tsum += num;\n\t\tproduct *=\
    \ num;\n\t}\n\treturn tuple(sum, product);\n}\n/*\n Create a function that takes\
    \ a string and returns a tuple of (int, string).\n    The function should add\
    \ the length of the string to the integer and return a tuple.\n    >>> add_length(\"\
    Hello world\")\n    tuple(11L, \"Hello world\")\n    >>> add_length(\"Udacity\"\
    )\n    tuple(7L, \"Udacity\")\n*/\nTuple!(long, string) add_length(string text)\
    \ \n{\n\treturn tuple(text.length, text);\n}\n/*\nCreate a function that takes\
    \ two integers and returns a tuple containing sum and the difference of the integers.\n\
    >>> compute_sum_diff(3L, 2L)\ntuple(5L, 1L)\n*/\nTuple!(long, long) compute_sum_diff(long\
    \ num1, long num2) \n{\n\treturn tuple(num1 + num2, num1 - num2);\n}\n/*\nCreate\
    \ a function that takes a tuple with three integers. Add up the first two integers\
    \ and divide by the third integer.\n>>> divide_sum(tuple(1L, 2L, 3L))\n1.0\n>>>\
    \ divide_sum(tuple(2L, 3L, 4L))\n1.1666666666666667\n*/\ndouble divide_sum(Tuple!(long,\
    \ long, long) nums) \n{\n\treturn (nums[0] + nums[1]) / nums[2];\n}\n/*\nCreate\
    \ a function that takes a tuple with three integers. Add up the first two integers\
    \ and divide by the third integer.\n>>> divisible_by_ten(tuple(10L, 10L, 10L))\n\
    true\n>>> divisible_by_ten(tuple(10L, 10L, 11L))\nfalse\n*/", "{\n    return Tuple!(long,\
    \ long)(sum(numbers), product(numbers));\n}", "{\n    long sum = 0L;\n    long\
    \ product = 1L;\n    foreach(num; numbers)\n    {\n        sum += num;\n     \
    \   product *= num;\n    }\n    return tuple(sum, product);\n}", "{\n    Tuple!(long,\
    \ long) result;\n    if (numbers.length == 0)\n    {\n        result = tuple(0L,\
    \ 1L);\n    }\n    else\n    {\n        result = tuple(numbers.sum, numbers.product);\n\
    \    }\n    return result;\n}\n/*\n    The function should return a tuple of two\
    \ integers.\n    The first integer is the number of positives values in the array.\n\
    \    The second integer is the number of negative values in the array.\n    >>>\
    \ positives_negatives([])\n    tuple(0L, 0L)\n    >>> positives_negatives([1L,\
    \ -1L, 0L, 2L, -3L])\n    tuple(3L, 2L)\n    >>> positives_negatives([-1L, -2L,\
    \ -3L])\n    tuple(0L, 3L)\n    >>> positives_negatives([1L, 2L, 3L])\n    tuple(3L,\
    \ 0L)\n*/\nTuple!(long, long) positives_negatives(long[] numbers)\n{\n    Tuple!(long,\
    \ long) result;\n    if (numbers.length == 0)\n    {\n        result = tuple(0L,\
    \ 0L);\n    }\n    else\n    {\n        result = tuple(numbers.filter!(x => x\
    \ > 0).length, numbers.filter!(x => x < 0).length);\n    }\n    return result;\n\
    }\n/*\n    Write a function that takes a filename and returns the number of lines\
    \ the file consists. It should return zero if the file not exists.\n    >>> number_of_lines(\"\
    example.txt\")\n    4L\n    >>> number_of_lines(\"nonexistent.txt\")\n    0L\n\
    */\nlong number_of_lines(const(char)[] filename)\n{\n    long lines = 0;\n   \
    \ if (File(filename).exists)\n    {\n        lines = 0;\n        foreach (line;\
    \ File(filename).byLine())\n        {\n            lines++;\n        }\n    }\n\
    \    return lines;\n}\n/*\n    You are given an array of tuples.\n    Your task\
    \ is to sum the elements in the", "{\n    long sum = 0;\n    long product = 1;\n\
    \    foreach(num; numbers) \n    {\n        sum += num;\n        product *= num;\n\
    \    }\n    return tuple(sum, product);\n}", "{\n    auto sum = 0L;\n    auto\
    \ product = 1L;\n    foreach(number; numbers)\n    {\n        sum += number;\n\
    \        product *= number;\n    }\n    return tuple(sum, product);\n}\n/*\nWrite\
    \ a function which takes a sentence as input and returns a tuple where the first\
    \ item \nis the sentence with all uppercase letters and the second is the sentence\
    \ with all lowercase letters.", "{\n    long sum = 0L;\n    long product = 1L;\n\
    \    foreach(num; numbers)\n    {\n        sum += num;\n        product *= num;\n\
    \    }\n    return tuple(sum, product);\n}\n/*\n For a given integer, return a\
    \ tuple consisting of a sum and a product of the digits of an integer.\n    >>>\
    \ sum_product_digits(123L)\n    tuple(6L, 6L)\n    >>> sum_product_digits(0L)\n\
    \    tuple(0L, 0L)\n*/\nTuple!(long, long) sum_product_digits(long num) \n{\n\
    \    long sum = 0L;\n    long product = 1L;\n    while(num > 0)\n    {\n     \
    \   sum += num % 10;\n        product *= num % 10;\n        num /= 10;\n    }\n\
    \    return tuple(sum, product);\n}\n/*\n Return a tuple consisting of the minimum\
    \ and maximum values in a list.\n    >>> min_max([])\n    tuple(0, 0)\n    >>>\
    \ min_max([1L, 2L, 3L, 4L])\n    tuple(1L, 4L)\n*/\nTuple!(long, long) min_max(long[]\
    \ arr) \n{\n    long min = arr[0];\n    long max = arr[0];\n    foreach(n; arr)\n\
    \    {\n        if(n < min)\n            min = n;\n        if(n > max)\n     \
    \       max = n;\n    }\n    return tuple(min, max);\n}\n/*\n Build a tuple from\
    \ individual values.\n    >>> tuple(1L, 2L, 3L)\n    tuple(1L, 2L, 3L)\n*/\nTuple!(long,\
    \ long, long) tuple(long a, long b, long c) \n{\n    return tuple(a, b, c);\n\
    }\n/*\n Return the number of characters in a string\n    >>> num_chars(\"\")\n\
    \    0\n    >>> num_chars(\"Hello World!\")\n    12\n*/\nlong num_chars(string\
    \ str) \n{\n    return str.length;\n}", "{\n    long sum = 0;\n    long product\
    \ = 1;\n    for (auto i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        product *= numbers[i];\n    }\n    return tuple(sum, product);\n}", "{\n\
    \    long sum = 0;\n    long prod = 1;\n    foreach(n; numbers)\n    {\n     \
    \   sum += n;\n        prod *= n;\n    }\n    return tuple(sum, prod);\n}", "{\n\
    \tif (numbers.length == 0)\n\t\treturn tuple(0L, 1L);\n\telse\n\t{\n\t\tlong[]\
    \ last = numbers[1..$];\n\t\tTuple!(long, long) sub_tuple = sum_product(last);\n\
    \t\treturn tuple(numbers[0] + sub_tuple[0], numbers[0] * sub_tuple[1]);\n\t}\n\
    }", "{\n    long sum = 0;\n    long product = 1;\n    foreach(number; numbers)\n\
    \    {\n        sum += number;\n        product *= number;\n    }\n    return\
    \ tuple(sum, product);\n}\n/*\n    For a given positive integer n, return a tuple\
    \ consisting of two elements:\n    1. Sum of all proper divisors of n (i.e. all\
    \ divisors except for n itself).\n    2. Perfection coefficient of n: a real number\
    \ between 0 and 1 (it can be represented as a fraction) that denotes how close\
    \ n is to a perfect number.\n    For example, for a number 6:\n    >>> aliquot_sum(6)\n\
    \    tuple(6L, 0.5)\n    >>> aliquot_sum(6L)\n    tuple(6L, 0.5)\n    >>> aliquot_sum(6.0)\n\
    \    tuple(6L, 0.5)\n    >>> aliquot_sum(7)\n    tuple(1L, 0.0)\n    >>> aliquot_sum(12)\n\
    \    tuple(16L, 0.3333333333333333L)\n    >>> aliquot_sum(12L)\n    tuple(16L,\
    \ 0.3333333333333333L)\n    >>> aliquot_sum(12.0)\n    tuple(16L, 0.3333333333333333L)\n\
    \    >>> aliquot_sum(3)\n    tuple(1L, 0.0)\n    >>> aliquot_sum(1)\n    tuple(0L,\
    \ 0.0)\n    >>> aliquot_sum(0)\n    tuple(0L, 0.0)\n    >>> aliquot_sum(-1)\n\
    \    tuple(0L, 0.0)\n    >>> aliquot_sum(-2)\n    tuple(0L, 0.0)\n    >>> aliquot_sum(-3)\n\
    \    tuple(0L, 0.0)\n    For example, for a number 28:\n    >>> aliquot_sum(28)\n\
    \    tuple(28L, 1.0)\n    >>> aliquot_sum(28L)\n    tuple(28L, 1.0)\n    >>> aliqu",
  "{\n    return (reduce!((a, b) => a + b)(0, numbers), reduce!((a, b) => a * b)(1,\
    \ numbers));\n}\n/*\n Given a list of lists of strings, return the longest string.\n\
    \    >>> longest_string([['a'], ['aa', 'bbb'], ['cccc']])\n    'cccc'\n*/\nstring\
    \ longest_string(string[][] strings)\n{\n    string result = \"\";\n    foreach(i;\
    \ 0 .. strings.length)\n    {\n        auto curr_result = reduce!((a, b) => a.length\
    \ > b.length ? a : b)(strings[i]);\n        if(curr_result.length > result.length)\n\
    \        {\n            result = curr_result;\n        }\n    }\n    return result;\n\
    }\n/*\n Given a dictionary of people's ages, print out the oldest age and the\
    \ average age.\n    >>> dict_of_ages = {'Joe': 15, 'Bob': 18, 'Sally': 14, 'Lucy':\
    \ 13}\n    >>> oldest_and_average(dict_of_ages)\n    (18, 15.0)\n*/\nTuple!(ulong,\
    \ float) oldest_and_average(string[ulong] ages)\n{\n    auto ages_list = ages.values;\n\
    \    return (reduce!((a, b) => a > b ? a : b)(ages_list), reduce!((a, b) => a\
    \ + b)(0.0, ages_list) / ages_list.length);\n}\n/*\n Given a string, reverse it.\n\
    \    >>> reverse('hello world')\n    'dlrow olleh'\n*/\nstring reverse(string\
    \ s)\n{\n    return reduce!((a, b) => b ~ a)(s);\n}\n/*\n Given a dictionary,\
    \ create a new dictionary that contains the keys of the original dictionary that\
    \ are repeated.\n    >>> repeated_keys({'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 4})\n\
    \    dict['d': 4, 'e': 4]\n*/", "{\n    if (numbers.length == 0) \n    {\n   \
    \     return tuple(0L, 1L);\n    }\n    long s = 0;\n    long p = 1;\n    foreach\
    \ (n; numbers) \n    {\n        s += n;\n        p *= n;\n    }\n    return tuple(s,\
    \ p);\n}", "{\n    long sum = 0L;\n    long product = 1L;\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        product\
    \ *= numbers[i];\n    }\n    return tuple(sum, product);\n}", "{\n    long sum\
    \ = 0;\n    long prod = 1;\n    foreach(n; numbers)\n    {\n        sum += n;\n\
    \        prod *= n;\n    }\n    return tuple(sum, prod);\n}", "{\n    long sum\
    \ = 0;\n    long product = 1;\n    for (auto i : numbers) \n    {\n        sum\
    \ += i;\n        product *= i;\n    }\n    return tuple(sum, product);\n}", "{\n\
    \    return tuple(numbers.sum, numbers.product);\n}", "{\n    if (numbers.length\
    \ == 0)\n        return tuple(0L, 1L);\n    if (numbers.length == 1)\n       \
    \ return tuple(numbers[0], numbers[0]);\n    return tuple(sum(numbers), product(numbers));\n\
    }", "{\n  if (numbers.length == 0) \n    return tuple(0L, 1L);\n  else \n  {\n\
    \    long sum = numbers[0];\n    long product = numbers[0];\n    foreach (i, number;\
    \ numbers[1 .. $]) \n    {\n      sum += number;\n      product *= number;\n \
    \   }\n    return tuple(sum, product);\n  }\n}", "{\n    long sum = 0;\n    long\
    \ product = 1;\n    foreach(n; numbers) \n    {\n        sum += n;\n        product\
    \ *= n;\n    }\n    return tuple(sum, product);\n}", "{\n    size_t sum = 0, product\
    \ = 1;\n    foreach(num; numbers)\n    {\n        sum += num;\n        product\
    \ *= num;\n    }\n    return tuple(sum, product);\n}", "{\n    long sum = 0;\n\
    \    long product = 1;\n    foreach(num; numbers)\n    {\n        sum += num;\n\
    \        product *= num;\n    }\n    return tuple(sum, product);\n}", "{\n   \
    \ long sum = 0;\n    long product = 1;\n    foreach(i; numbers) \n    {\n    \
    \    sum += i;\n        product *= i;\n    }\n    return tuple(sum, product);\n\
    }", "{\n\tif (numbers.length == 0)\n\t\treturn tuple(0L, 1L);\n\t\n\tlong sum\
    \ = 0;\n\tlong product = 1;\n\t\n\tforeach (i; numbers)\n\t{\n\t\tsum += i;\n\t\
    \tproduct *= i;\n\t}\n\t\n\treturn tuple(sum, product);\n}", "{\n    long res=0;\n\
    \    long res2=1;\n    foreach(i;numbers)\n    {\n        res+=i;\n        res2*=i;\n\
    \    }\n    return tuple(res,res2);\n}", "{\n    long sum = 0;\n    long product\
    \ = 1;\n    foreach(n; numbers) \n    {\n        sum += n;\n        product *=\
    \ n;\n    }\n    return tuple(sum, product);\n}", "{\n\tforeach(i;numbers)\n\t\
    {\n\t\tif(i!=0)\n\t\t{\n\t\t\treturn tuple(sum(numbers),product(numbers));\n\t\
    \t}\n\t}\n\treturn tuple(0L,1L);\n}\n/*\n The distance between two points is calculated\
    \ by the sum of the squares of their differences in position.\n    For example,\
    \ the distance between (1, 1) and (2, 2) is\n    \\sqrt{(1 - 2)^2 + (1 - 2)^2}\
    \ = \\sqrt{2}.\n    >>> distance((1L, 1L), (2L, 2L))\n    1.4142135623730951\n\
    \    >>> distance((-1L, 1L), (1L, 2L))\n    3.1622776601683795\n*/\ndouble distance(Tuple!(long,\
    \ long) point1, Tuple!(long, long) point2) \n{\n\treturn sqrt(pow(point1[0]-point2[0],2)+pow(point1[1]-point2[1],2));\n\
    }", "{\n    /*\n    Tuple!(long, long) t = tuple(0L, 1L);\n    foreach(n; numbers)\n\
    \    {\n        t[0] += n;\n        t[1] *= n;\n    }\n    return t;\n    */\n\
    \    auto r = tuple(0L, 1L);\n    foreach(n; numbers)\n    {\n        r[0] +=\
    \ n;\n        r[1] *= n;\n    }\n    return r;\n}", "{\n  long sum = 0L;\n  long\
    \ product = 1L;\n  foreach(number; numbers) \n  {\n    sum += number;\n    product\
    \ *= number;\n  }\n  return tuple(sum, product);\n}", "{\n    long sum = 0;\n\
    \    long product = 1;\n    for (long num; num in numbers) \n    {\n        sum\
    \ += num;\n        product *= num;\n    }\n    return tuple(sum, product);\n}",
  "{\n    if (numbers.length == 0)\n        return tuple(0L, 1L);\n    long sum =\
    \ 0L;\n    long product = 1L;\n    foreach (l; numbers)\n    {\n        sum +=\
    \ l;\n        product *= l;\n    }\n    return tuple(sum, product);\n}\n/*\n \
    \   For a given integer x, define a sequence of integers x0 = x, x1 = f(x0), x2\
    \ = f(x1), ... where f(y) = y / 2 if y is even, f(y) = 3 * y + 1 if y is odd.\n\
    \    >>> hailstone(7)\n    [7L, 22L, 11L, 34L, 17L, 52L, 26L, 13L, 40L, 20L, 10L,\
    \ 5L, 16L, 8L, 4L, 2L, 1L]\n*/\nlong[] hailstone(long x) \n{\n    long[] result\
    \ = new long[0];\n    while (x != 1)\n    {\n        result ~= x;\n        if\
    \ (x % 2 == 0)\n            x /= 2;\n        else\n            x = 3 * x + 1;\n\
    \    }\n    result ~= 1;\n    return result;\n}\n/*\n    For a given string, return\
    \ a new string in which the case of each letter is reversed.\n    >>> lower_up(\"\
    Hello World\")\n    \"hELLO wORLD\"\n    >>> lower_up(\"\")\n    \"\"\n    >>>\
    \ lower_up(\"aBc\")\n    \"AbC\"\n*/\nstring lower_up(string s) \n{\n    string\
    \ result = \"\";\n    foreach (c; s)\n    {\n        if (c >= 'a' && c <= 'z')\n\
    \            result ~= (char)(c - 32);\n        else if (c >= 'A' && c <= 'Z')\n\
    \            result ~= (char)(c + 32);\n        else\n            result ~= c;\n\
    \    }\n    return result;\n}\n/*\n    Given a list of integers, return a string\
    \ of the form \"1..3, 5, 8..11, 15, ...\".\n    >>> format_", "{\n    if (numbers.length\
    \ == 0)\n        return tuple(0L, 1L);\n    else \n    {\n        auto result\
    \ = reduce!((x, y) => tuple(x[0] + y, x[1] * y))(numbers);\n        return result;\n\
    \    }\n}", "{\n\tlong sum = 0;\n\tlong product = 1;\n\tfor (i, v; numbers)\n\t\
    {\n\t\tsum += v;\n\t\tproduct *= v;\n\t}\n\treturn tuple(sum, product);\n}", "{\n\
    \    // TODO: implement\n    long sum = 0;\n    long product = 1;\n    foreach(n;\
    \ numbers)\n    {\n        sum += n;\n        product *= n;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n    long sum = 0;\n    long product = 1;\n   \
    \ foreach(x; numbers) \n    {\n        sum += x;\n        product *= x;\n    }\n\
    \    return tuple(sum, product);\n}", "{\n    return numbers.reduce!((a,b) =>\
    \ tuple(a[0] + b, a[1] * b))(tuple(0L, 1L));\n}", "{\n    long sum = 0;\n    long\
    \ product = 1;\n    foreach(n; numbers)\n    {\n        sum += n;\n        product\
    \ *= n;\n    }\n    return tuple(sum, product);\n}", "{\n    long product = numbers.length\
    \ == 0 ? 1 : numbers[0];\n    long sum = numbers.length == 0 ? 0 : numbers[0];\n\
    \    foreach(i, val; numbers[1..$])\n    {\n        product *= val;\n        sum\
    \ += val;\n    }\n    return tuple(sum, product);\n}\n/*\n Given a string, return\
    \ a new string with the characters reversed.\n    >>> reverse(\"ABC\")\n    \"\
    CBA\"\n    >>> reverse(\"abcdefgh\")\n    \"hgfedcba\"\n    >>> reverse(\"\")\n\
    \    \"\"\n*/\nstring reverse(string s) \n{\n    string result = \"\";\n    foreach(index,\
    \ val; s[$-1..0])\n    {\n        result ~= val;\n    }\n    return result;\n\
    }\n/*\n Given two lists of integers, [listA] and [listB], return true if they\
    \ have the same length, and the elements in [listA] \n    are equal to the elements\
    \ in [listB] except at the index.\n    >>> equal_except([1L, 2L, 3L], [1L, 3L,\
    \ 2L], 1)\n    true\n    >>> equal_except([1L, 2L, 3L], [1L, 2L, 3L], 1)\n   \
    \ false\n    >>> equal_except([1L, 2L, 3L], [1L, 3L, 2L], 0)\n    false\n    >>>\
    \ equal_except([1L, 2L, 3L], [1L, 2L, 3L], 2)\n    false\n    >>> equal_except([1L,\
    \ 2L, 3L], [1L, 3L, 2L], 9)\n    false\n    >>> equal_except([1L, 2L, 3L], [1L,\
    \ 3L, 2L], -1)\n    false\n    >>> equal_except([], [], 0)\n    false\n*/", "{\n\
    \    long[] sum_prod = [0L, 1L];\n    foreach(int i, long number; numbers)\n \
    \   {\n        sum_prod[0] += number;\n        sum_prod[1] *= number;\n    }\n\
    \    return tuple(sum_prod[0], sum_prod[1]);\n}", "{\n    long sum = 0;\n    long\
    \ product = 1;\n    foreach( num; numbers)\n    {\n        sum += num;\n     \
    \   product *= num;\n    }\n    return tuple(sum, product);\n}\n/*\n    Given\
    \ a dictionary, return a list of all the even keys from a dictionary.\n    >>>\
    \ dict_to_list({1L: \"one\", 2L: \"two\", 3L: \"three\"})\n    [2L]\n    >>> dict_to_list({1L:\
    \ \"one\", 2L: \"two\", 3L: \"three\", 4L: \"four\"})\n    [2L, 4L]\n    >>> dict_to_list({})\n\
    \    []", "{\n    long sum = 0;\n    long prod = 1;\n    foreach(number; numbers)\
    \ \n    {\n        sum += number;\n        prod *= number;\n    }\n    return\
    \ tuple(sum, prod);\n}", "{\n    long prod = 1;\n    long sum = 0;\n    foreach(n;\
    \ numbers)\n    {\n        prod *= n;\n        sum += n;\n    }\n    return tuple(sum,\
    \ prod);\n}", "{\n    long sum = 0;\n    long product = 1;\n    foreach(index,\
    \ num; numbers)\n    {\n        sum += num;\n        product *= num;\n    }\n\
    \    return tuple(sum, product);\n}", "{\n    long sum = 0;\n    long product\
    \ = 1;\n    foreach(long x; numbers)\n    {\n        sum += x;\n        product\
    \ *= x;\n    }\n    return tuple(sum, product);\n}\n/*\nImplement a function that\
    \ works as a simple preprocessor for Pascal language. The function takes a single\
    \ argument. The function takes a string as an argument and transforms it according\
    \ to the following rules:\n    Remove all comments. Comments in Pascal can be\
    \ nested.\n    Remove all extra whitespace, including newlines and tabs.\n   \
    \ Convert all reserved keywords to UPPERCASE.\n    You can find a list of all\
    \ Pascal reserved keywords here (you can safely ignore RESULT in that list).\n\
    \    \n*/\nstring simple_preprocessor(string source) \n{\n    string result =\
    \ \"\";\n    bool in_comment = false;\n    foreach(char c; source)\n    {\n  \
    \      if(in_comment)\n        {\n            if(c == ')' && !in_comment)\n  \
    \          {\n                in_comment = false;\n            }\n           \
    \ continue;\n        }\n        if(c == ' ' || c == '\\t' || c == '\\n')\n   \
    \     {\n            if(result.length > 0 && result[$-1] != ' ')\n           \
    \ {\n                result ~= ' ';\n            }\n            continue;\n  \
    \      }\n        if(c == '(')\n        {\n            in_comment = true;\n  \
    \          continue;\n        }\n        result ~= c;\n    }\n    return result;\n\
    }\n/*\nThe function takes two arguments. The function takes two arguments: a string\
    \ with the name of the computer scientist, and a dictionary with computer scientists\
    \ and the name of one of their famous works.\n    The function must return a string\
    \ with the name of a famous work. If the computer scientist is not in the dictionary,\
    \ the function should return an empty string.\n    If the computer scientist is\
    \ in the dictionary, but they have no famous works, the function should return\
    \ the string None.\n    Do not use mutable variables.\n*/\nstring get_work(string\
    \ name, string[string] works) \n{\n    if(!works.contains(name))\n    {\n    \
    \    return \"", "{\n    long sum = 0L;\n    long product = 1L;\n    foreach(n;\
    \ numbers)\n    {\n        sum += n;\n        product *= n;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n    long sum = 0;\n    long product = 1;\n   \
    \ foreach(int number; numbers) \n    {\n        sum += number;\n        product\
    \ *= number;\n    }\n    return tuple(sum, product);\n}\n \n/*\n \n A number is\
    \ considered perfect if its digits sum up to exactly 10. Given a positive integer\
    \ n, return a pair of perfect numbers formed by concatenating the string representation\
    \ of n to itself.\n    If there are no such perfect numbers for given n, return\
    \ null.\n    >>> pair_perfect_numbers(1L)\n    tuple(11L, 11L)\n    >>> pair_perfect_numbers(13L)\n\
    \    tuple(119L, 199L)\n    >>> pair_perfect_numbers(11L)\n    null\n    >>> pair_perfect_numbers(9999L)\n\
    \    tuple(999999999999999999L, 999999999999999999L)\n    \n*/\nTuple!(long, long)\
    \ pair_perfect_numbers(long n) \n{\n    long m = n;\n    while (n > 0) \n    {\n\
    \        m += n % 10;\n        n /= 10;\n    }\n    if (m != 10) \n    {\n   \
    \     return null;\n    }\n    return tuple(m * 10 + n, m * 10 + n);\n}\n \n/*\n\
    \ \n Given a file name and a word, find the number of times the word appears in\
    \ the file.\n    A word is a sequence of non-whitespace characters.\n    A file\
    \ name is a string consisting of letters, digits and symbols.\n    >>> word_count(\"\
    test.txt\", \"this\")\n    2L\n    >>> word_count(\"test.txt\", \"and\")\n   \
    \ 0L\n    >>> word_count(\"test.txt\", \"for\")\n    1L\n    \n*/\nlong word_count(string\
    \ filename, string word) \n{\n    long count = 0;\n    import std.file;\n    foreach(line;\
    \ file(filename).byLine()) \n    {\n        foreach(token; line.split(` `)) \n\
    \        {\n            if (token == word) \n            {\n                count++;",
  "{\n    long sum = 0;\n    long product = 1;\n    foreach(n; numbers) \n    {\n\
    \        sum += n;\n        product *= n;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    if (numbers.length == 0) return tuple(0L, 1L);\n    else \n    {\n\
    \        auto sum = 0L;\n        auto product = 1L;\n        foreach (i; numbers)\n\
    \        {\n            sum += i;\n            product *= i;\n        }\n    \
    \    return tuple(sum, product);\n    }\n}", "{\n    long sum = 0L;\n    long\
    \ product = 1L;\n    foreach(index, number; numbers)\n    {\n        sum += number;\n\
    \        product *= number;\n    }\n    return tuple(sum, product);\n}\n/*\nA\
    \ tuple of integers (first, second) is called balanced, if first is equal to second\
    \ and their absolute difference is equal to 1.", "{\n    import std.algorithm\
    \ : reduce;\n    import std.conv : to;\n    if (numbers.empty) return tuple(0L,\
    \ 1L);\n    long sum = numbers.reduce!((a, b) => a + b)(0L);\n    long product\
    \ = numbers.reduce!((a, b) => a * b)(1L);\n    return tuple(sum, product);\n}",
  "{\n    auto s = 0L;\n    auto p = 1L;\n    foreach(i; numbers)\n    {\n       \
    \ s += i;\n        p *= i;\n    }\n    return tuple(s, p);\n}", "{\n    auto res\
    \ = tuple(0L, 1L);\n    foreach(i; numbers) \n    {\n        res[0] += i;\n  \
    \      res[1] *= i;\n    }\n    return res;\n}", "{\n    long s = 0L;\n    long\
    \ p = 1L;\n    foreach(i; numbers)\n    {\n        s += i;\n        p *= i;\n\
    \    }\n    return tuple(s, p);\n}", "{\n    // TODO\n    return tuple(0L, 1L);\n\
    }", "{\n    if (numbers.length == 0)\n        return tuple(0L, 1L);\n    return\
    \ tuple(sum(numbers), product(numbers));\n}", "{\n    long sum = 0;\n    long\
    \ product = 1;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        product *= numbers[i];\n    }\n    return tuple(sum,\
    \ product);\n}\n/*\n// BUG\nFor a given array of strings, return a tuple of strings\
    \ (located before the first numeric string and after the last numeric string).\n\
    \    Example:\n    >>>get_str_substring([\"a\", \"b\", \"123\", \"d\", \"456\"\
    , \"e\", \"f\"])\n    tuple(\"ab\", \"def\")\n*/\nTuple!(string, string) get_str_substring(string[]\
    \ strings) \n{\n    string beginning_substring = \"\";\n    string ending_substring\
    \ = \"\";\n    for (int i = 0; i < strings.length; i++)\n    {\n        if (strings[i].indexOfAny(\"\
    0123456789\") == -1)\n        {\n            beginning_substring += strings[i];\n\
    \        }\n        else\n        {\n            break;\n        }\n    }\n  \
    \  for (int i = strings.length - 1; i >= 0; i--)\n    {\n        if (strings[i].indexOfAny(\"\
    0123456789\") == -1)\n        {\n            ending_substring = strings[i] + ending_substring;\n\
    \        }\n        else\n        {\n            break;\n        }\n    }\n  \
    \  return tuple(beginning_substring, ending_substring);\n}\n/*\nFor a given tuple\
    \ of two numbers, return a tuple of the same two numbers swapped.\n    Example:\n\
    \    >>> swap_tuple(tuple(1, 2))\n    tuple(2, 1)\n    >>> swap_tuple(tuple(\"\
    str1\", \"str2\"))\n    tuple(\"str2\", \"str1\")\n*/\nTuple!(T, T) swap_tuple(Tuple!(T,\
    \ T) t) \n{\n    return tuple(t[1], t[0]);\n}\n/*\nFor a given array of integers,\
    \ return a tuple consisting of a maximum and a minimum of all the", "{\n    long\
    \ sum = 0;\n    long product = 1;\n    foreach(number; numbers) \n    {\n    \
    \    sum += number;\n        product *= number;\n    }\n    return tuple(sum,\
    \ product);\n}\n/*\nGet the grade for a given mark. The mark will be converted\
    \ to a grade according to the following rules.", "{\n    long sum = 0;\n    long\
    \ product = 1;\n    foreach(n; numbers) \n    {\n        sum += n;\n        product\
    \ *= n;\n    }\n    return tuple(sum, product);\n}", "{\n\tTuple!(long, long)\
    \ result;\n\t\n\tresult.field0 = 0;\n\tresult.field1 = 1;\n\t\n\tforeach(num;\
    \ numbers)\n\t{\n\t\tresult.field0 += num;\n\t\tresult.field1 *= num;\n\t}\n\t\
    \n\treturn result;\n}", "{\n    long sum = 0;\n    long product = 1;\n    for\
    \ (long n; n = numbers.front) \n    {\n        sum += n;\n        product *= n;\n\
    \        numbers.popFront();\n    }\n    return tuple(sum, product);\n}\n/*\n\
    For a given array of integers, return an array that contains the elements of the\
    \ given array that are not equal to 0.\n    >>> non_zero([1L, 2L, 0L, 4L, 0L,\
    \ 0L, 0L, 5L])\n    [1L, 2L, 4L, 5L]\n    >>> non_zero([1L, 2L, 3L, 4L, 5L])\n\
    \    [1L, 2L, 3L, 4L, 5L]\n    >>> non_zero([0L, 0L, 0L, 0L, 0L])\n    []\n*/\n\
    long[] non_zero(long[] numbers) \n{\n    long[] result;\n    for (long n; n =\
    \ numbers.front) \n    {\n        if (n != 0) \n        {\n            result\
    \ ~= n;\n        }\n        numbers.popFront();\n    }\n    return result;\n}\n\
    /*\nFor a given array of integers, find the maximal absolute difference between\
    \ any two of its adjacent elements.\n    >>> max_abs_diff([1L, 2L, 3L, 4L, 5L])\n\
    \    4L\n    >>> max_abs_diff([1L, 2L, 3L, 4L, 5L, 1L])\n    4L\n    >>> max_abs_diff([1L,\
    \ 2L, 3L, 4L, 5L, 1L, 5L])\n    4L\n    >>> max_abs_diff([1L, 2L, 3L, 4L, 5L,\
    \ 1L, 5L, 0L])\n    5L\n    >>> max_abs_diff([1L, 2L, 3L, 4L, 5L, 1L, 5L, 0L,\
    \ 1L])\n    5L\n    >>> max_abs_diff([1L, 2L, 3L, 4L, 5L, 1L, 5L, 0L, 1L", "{\n\
    \    long sum = 0;\n    long product = 1;\n    foreach(number; numbers) \n   \
    \ {\n        sum += number;\n        product *= number;\n    }\n    return tuple(sum,\
    \ product);\n}", "{\n    return tuple(numbers.sum, numbers.product);\n}", "{\n\
    \    long sum = 0L;\n    long product = 1L;\n    foreach(long number; numbers)\
    \ \n    {\n        sum += number;\n        product *= number;\n    }\n    return\
    \ tuple(sum, product);\n}\n/*\nGiven a dictionary, return its product sum.\nThe\
    \ product sum is the sum of all the product of the key and value in the dictionary.\n\
    It's a sum of the product of the key and value for every element in the dictionary.\n\
    If the value is a dictionary, we add the product sum of the nested dictionary\
    \ to the product sum.\nExample:\n{\n    \"d1\": {\"a\": 5, \"b\": 10, \"c\": {\"\
    c1\": 3, \"c2\": 2}},\n    \"d2\": 4\n}\n>>> product_sum({})\n0\n>>> product_sum({\"\
    d1\": {\"a\": 5, \"b\": 10, \"c\": {\"c1\": 3, \"c2\": 2}}, \"d2\": 4})\n114\n\
    */\nlong product_sum(ref Map!(string, Map!(string, long) | long) dictionary)\n\
    {\n    if(dictionary.length == 0)\n        return 0L;\n    \n    long productSum\
    \ = 0L;\n    foreach(string key; dictionary.keys)\n    {\n        if(is(typeof(dictionary[key])\
    \ == Map!(string, long)))\n        {\n            productSum += product_sum(dictionary[key]);\n\
    \        }\n        else\n        {\n            productSum += dictionary[key];\n\
    \        }\n    }\n    return productSum;\n}", "{\n    long sum = 0;\n    long\
    \ product = 1;\n    foreach(elem; numbers)\n    {\n        sum += elem;\n    \
    \    product *= elem;\n    }\n    return tuple(sum, product);\n}", "{\n    long\
    \ sum = 0;\n    long product = 1;\n    foreach(num; numbers) \n    {\n       \
    \ sum += num;\n        product *= num;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    auto sum = 0L;\n    auto product = 1L;\n    foreach(n; numbers) \n\
    \    {\n        sum += n;\n        product *= n;\n    }\n    return tuple(sum,\
    \ product);\n}\nTuple!(long, long) sum_product2(long[] numbers) \n{\n    auto\
    \ sum = reduce!((a, b) => a + b)(0L, numbers);\n    auto product = reduce!((a,\
    \ b) => a * b)(1L, numbers);\n    return tuple(sum, product);\n}\n/*\nFor a given\
    \ array of integers, return a tuple consisting of a minimum, maximum, and average\
    \ value of all the integers in an array.\n    >>> min_max_avg([1L, 2L, 3L, 4L])\n\
    \    tuple(1L, 4L, 2.5L)\n    >>> min_max_avg([])\n    tuple(0L, 0L, 0L)\n*/\n\
    Tuple!(long, long, long) min_max_avg(long[] numbers) \n{\n    auto min = min(numbers);\n\
    \    auto max = max(numbers);\n    auto avg = reduce!((a, b) => a + b)(0L, numbers)\
    \ / cast(long)numbers.length;\n    return tuple(min, max, avg);\n}\n/*\nFor a\
    \ given array of integers, return an array of all the subarrays (not just their\
    \ elements), sorted from the shortest to the longest.\n*/\nlong[][] subarrays(long[]\
    \ array) \n{\n    return array.slices;\n}\n//2.2.21\n/*\nFor a given array of\
    \ integers, return an array of all the subarrays (not just their elements), sorted\
    \ from the shortest to the longest.\n*/\nlong[][] subarrays2(long[] array) \n\
    {\n    auto result = array.slices;\n    sort!((a, b) => a.length < b.length)(result);\n\
    \    return result;\n}\n/*\nFor a given array of integers, return an array of\
    \ all the subarrays (not just their elements), sorted from the shortest to the\
    \ longest.\n*/", "{\n    auto result = tuple(0L, 1L);\n    if(numbers.length)\
    \ \n    {\n        foreach(n; numbers)\n        {\n            result[0] += n;\n\
    \            result[1] *= n;\n        }\n    }\n    return result;\n}\n//\nunittest\
    \ \n{\n    // Empty sum should be equal to 0 and empty product should be equal\
    \ to 1.\n    assert(tuple(0L, 1L) == sum_product([]));\n    assert(tuple(10L,\
    \ 24L) == sum_product([1L, 2L, 3L, 4L]));\n}\n/*\n    Given a number n, return\
    \ a list containing all the divisors of n, sorted in ascending order.\n    >>>\
    \ divisors(12)\n    [1L, 2L, 3L, 4L, 6L, 12L]\n    >>> divisors(1)\n    [1L]\n\
    \    >>> divisors(15)\n    [1L, 3L, 5L, 15L]\n*/\nlong[] divisors(long number)\
    \ \n{\n    long[] divisors = [];\n    foreach(d; 1..number)\n    {\n        if(number\
    \ % d == 0)\n        {\n            divisors ~= d;\n        }\n    }\n    return\
    \ divisors;\n}\n//\nunittest \n{\n    assert(divisors(12) == [1L, 2L, 3L, 4L,\
    \ 6L, 12L]);\n    assert(divisors(1) == [1L]);\n    assert(divisors(15) == [1L,\
    \ 3L, 5L, 15L]);\n}\n/*\n Given a list of integers, return a list of lists containing\
    \ the elements of the input list grouped in groups of n items.\n >>> group(3,\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9])\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n >>> group(3,\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n   ", "{\n    long sum = 0;\n    long\
    \ prod = 1;\n    foreach(num; numbers) \n    {\n        sum += num;\n        prod\
    \ *= num;\n    }\n    return tuple(sum, prod);\n}", "{\n    return tuple(reduce!((a,\
    \ b) => a + b)(0L, numbers), reduce!((a, b) => a * b)(1L, numbers));\n}\nstatic\
    \ assert(sum_product([]) == tuple(0L, 1L));\nstatic assert(sum_product([1L, 2L,\
    \ 3L, 4L]) == tuple(10L, 24L));", "{\n    int sum = 0;\n    int product = 1;\n\
    \    foreach(n; numbers)\n    {\n        sum += n;\n        product *= n;\n  \
    \  }\n    return tuple(sum, product);\n}", "{\n\treturn reduce!((a,b) => Tuple!(long,\
    \ long)(a[0] + b, a[1] * b), \n\t\t\t\t\tzip(numbers, cycle(Tuple!(long, long)(1L,\
    \ 1L)))).front;\n}", "{\n    return tuple(std.algorithm.reduce!((a, b) => a +\
    \ b)(0, numbers),\n                 std.algorithm.reduce!((a, b) => a * b)(1,\
    \ numbers));\n}", "{\n    long sum=0;\n    long product=1;\n    foreach(n; numbers)\n\
    \    {\n        sum+=n;\n        product*=n;\n    }\n    return tuple(sum, product);\n\
    }\n \n /*\n Given an array of integers, create a function that takes a string\
    \ as an argument \n and replace each value from array with its corresponding index\
    \ from the string.\n    >>> strings_to_index(['a', 'b', 'c'])\n    'abc'\n   \
    \ >>> strings_to_index(['c', 'b', 'c', 'a'])\n    'cba'\n    >>> strings_to_index(['d',\
    \ 'b', 'c', 'a'])\n    'dcba'\n*/\nstring strings_to_index(string[] string_)\n\
    {\n    string result = \"\";\n    foreach(s; string_)\n    {\n        result ~=\
    \ s;\n    }\n    return result;\n}\n/*\n Given an array of strings, create a function\
    \ that takes a string as an argument and returns an array of indices of the given\
    \ string.\n    >>> strings_to_index(['a', 'b', 'c'])\n    [0, 1, 2]\n    >>> strings_to_index(['c',\
    \ 'b', 'c', 'a'])\n    [2, 1, 2, 0]\n    >>> strings_to_index(['d', 'b', 'c',\
    \ 'a'])\n    [3, 1, 2, 0]\n*/", "{\n    return (tuple(reduce!((a, b) => a + b)(0L,\
    \ numbers), reduce!((a, b) => a * b)(1L, numbers)));\n}", "{\n    Tuple!(long,\
    \ long) result;\n    foreach(num; numbers) \n    {\n        result.first += num;\n\
    \        result.second *= num;\n    }\n    return result;\n}", "{\n    long sum\
    \ = 0L;\n    long product = 1L;\n    if (numbers.length == 0) {\n        return\
    \ tuple(sum, product);\n    } else {\n        for (int i = 0; i < numbers.length;\
    \ i++) {\n            sum += numbers[i];\n            product *= numbers[i];\n\
    \        }\n        return tuple(sum, product);\n    }\n}\n/*\n In a given array\
    \ of tuples, find a tuple where the first element is equal to the second element.\n\
    \ >>> find_equal_pair([])\n None\n >>> find_equal_pair([tuple(1L, 1L), tuple(2L,\
    \ 3L), tuple(3L, 3L), tuple(4L, 5L)])\n tuple(3L, 3L)\n >>> find_equal_pair([tuple(1L,\
    \ 1L), tuple(2L, 2L), tuple(3L, 3L)])\n tuple(1L, 1L)\n*/\ntuple(long, long) find_equal_pair(tuple(long,\
    \ long)[] pairs) \n{\n    if (pairs.length == 0) {\n        return null;\n   \
    \ } else {\n        for (int i = 0; i < pairs.length; i++) {\n            if (pairs[i][0]\
    \ == pairs[i][1]) {\n                return pairs[i];\n            }\n       \
    \ }\n        return null;\n    }\n}\n/*\n Given a string of lowercase characters\
    \ in the range ascii[a-z], determine a character that can be removed to make the\
    \ string a palindrome.\n >>> find_extra_letter(\"abcda\")\n 'c'\n >>> find_extra_letter(\"\
    abcde\")\n '\\0'\n*/\nchar find_extra_letter(string input) \n{\n    if (input.length\
    \ == 0) {\n        return 0;\n    } else {\n        for (int i = 0; i < input.length;\
    \ i++) {\n            string temp = input.dup;\n            temp.remove(i);\n\
    \            if (temp == temp.dup.reverse) {\n                return input[i];\n\
    \            }\n        }\n        return 0;\n   ", "{\n    long sum = 0;\n  \
    \  long product = 1;\n    foreach(number; numbers) \n    {\n        sum += number;\n\
    \        product *= number;\n    }\n    return tuple(sum, product);\n}", "{\n\t\
    return numbers.length == 0 ? tuple(0L, 1L) : numbers.reduce!((a,b) => tuple(a[0]\
    \ + b, a[1] * b));\n}", "{\n    long sum = 0;\n    long product = 1;\n    foreach(v;\
    \ numbers)\n    {\n        sum += v;\n        product *= v;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n    long sum = 0;\n    long product = 1;\n   \
    \ foreach(number; numbers) \n    {\n        sum += number;\n        product *=\
    \ number;\n    }\n    return tuple(sum, product);\n}", "{\n    long sum = 0L;\n\
    \    long prod = 1L;\n    foreach(index, long num; numbers) \n    {\n        sum\
    \ += num;\n        prod *= num;\n    }\n    return tuple(sum, prod);\n}", "{\n\
    \    long s = 0;\n    long p = 1;\n    foreach(n; numbers)\n    {\n        s +=\
    \ n;\n        p *= n;\n    }\n    return tuple(s, p);\n}", "{\n    long sum =\
    \ 0;\n    long product = 1;\n    foreach(idx, elem; numbers) \n    {\n       \
    \ sum += elem;\n        product *= elem;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    return tuple(reduce!((a, b) => a + b)(0L, numbers), reduce!((a, b)\
    \ => a * b)(1L, numbers));\n}", "{\n    long s = 0;\n    long p = 1;\n    foreach(n;\
    \ numbers) \n    {\n        s += n;\n        p *= n;\n    }\n    return tuple(s,\
    \ p);\n}\n/*\n    For a given string, return a tuple consisting of a sum and a\
    \ product of all the characters in the string. \n    Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n    >>> sum_product(\"\")\n  \
    \  tuple(0L, 1L)\n    >>> sum_product(\"abcd\")\n    tuple(394L, 6L)\n*/\nTuple!(long,\
    \ long) sum_product(string str) \n{\n    long s = 0;\n    long p = 1;\n    foreach(c;\
    \ str) \n    {\n        s += c;\n        p *= c;\n    }\n    return tuple(s, p);\n\
    }\n/*\n    Create a tuple t = tuple(1L, 2L, 3L, 4L) using Tuple constructor.\n\
    \    >>> t = tuple(1L, 2L, 3L, 4L)\n    >>> t\n    tuple(1L, 2L, 3L, 4L)\n   \
    \ >>> t[0]\n    1L\n    >>> t[3]\n    4L\n    >>> t[4]\n    Error: tuple index\
    \ 4 is out of range 0..3\n    >>> t.length\n    4\n    >>> t.empty\n    0\n  \
    \  >>> t.front\n    1L\n    >>> t.back\n    4L\n    >>> t.popFront\n    tuple(2L,\
    \ 3L, 4L)\n    >>> t.popBack\n    tuple(1L, 2L, 3L)\n    >>> t\n    tuple(1L,\
    \ 2L, 3L, 4L)\n    >>> swap(t[0], t[1])\n    >>> t\n    tuple(2L, 1L, 3L, 4L)\n\
    \    >>> reverse(t)\n    >>> t\n    tuple(4L, 3L, 1L, 2L)\n    >>> t.array\n \
    \   [4L, 3L, 1L, 2L]\n    >>> t.array.length", "{\n    long sum = 0;\n    long\
    \ product = 1;\n    foreach(n; numbers) \n    {\n        sum += n;\n        product\
    \ *= n;\n    }\n    return tuple(sum, product);\n}\n/*\n A given binary tree is\
    \ symmetric if its data and shape remain unchanged when it is reflected about\
    \ the root node.\n    Write a function that determines whether a binary tree is\
    \ symmetric. \n    For example, the following tree is symmetric:\n        4\n\
    \      /   \\\n    3       3\n  /   \\   /   \\\n9      4 4      9\n    But the\
    \ following tree is not:\n    4\n  /   \\\n9       4\n    Hint: Write a recursive\
    \ function that compares the sub-trees and returns true if they are equal.\n*/\n\
    // Returns true if a tree is symmetric.", "{\n    long sum = 0;\n    long prod\
    \ = 1;\n    foreach(n; numbers) \n    {\n        sum += n;\n        prod *= n;\n\
    \    }\n    return tuple(sum, prod);\n}\n/*\n    Write a function, which takes\
    \ tuple of three integers and returns a tuple of sorted integers.\n    >>> sort_tuple((3L,\
    \ 1L, 2L))\n    tuple(1L, 2L, 3L)\n    >>> sort_tuple((-1L, 0L, 1L))\n    tuple(-1L,\
    \ 0L, 1L)\n    \n*/\nTuple!(long, long, long) sort_tuple(Tuple!(long, long, long)\
    \ t) \n{\n    import std.algorithm;\n    auto l = t.tupleof;\n    l.sort;\n  \
    \  return tuple(l[0], l[1], l[2]);\n}\n/*\n    Write a function, which converts\
    \ a tuple of three floats into a tuple of three integer numbers (int).\n    >>>\
    \ float_to_int((1.5, 1.5, 1.5))\n    tuple(1L, 1L, 1L)\n    >>> float_to_int((1.0,\
    \ 2.0, 3.0))\n    tuple(1L, 2L, 3L)\n    \n*/\nTuple!(long, long, long) float_to_int(Tuple!(real,\
    \ real, real) t) \n{\n    long l1 = cast(long)t[0];\n    long l2 = cast(long)t[1];\n\
    \    long l3 = cast(long)t[2];\n    return tuple(l1, l2, l3);\n}\n/*\n    Write\
    \ a function, which converts a tuple of three integers into a tuple of three float\
    \ numbers (float).\n    >>> int_to_float((1L, 1L, 1L))\n    tuple(1.0f, 1.0f,\
    \ 1.0f)\n    >>> int_to_float((1L, 2L, 3L))\n    tuple(1.0f, 2.0f, 3.0f)\n   \
    \ \n*/\nTuple!", "{\n    long sum = 0;\n    long product = 1;\n    foreach(n;\
    \ numbers)\n    {\n        sum += n;\n        product *= n;\n    }\n    return\
    \ tuple(sum, product);\n}\n/*\nFor a given integer N return an array containing\
    \ all the prime numbers up to N, or an empty array if N is less than 2.\n>>> primes(2)\n\
    [2L]\n>>> primes(11)\n[2L, 3L, 5L, 7L, 11L]\n*/\nlong[] primes(long N) \n{\n \
    \   assert(N >= 2);\n    bool[] isPrime = new bool[N+1];\n    foreach(i; 0..N+1)\
    \ isPrime[i] = true;\n    isPrime[0] = false;\n    isPrime[1] = false;\n    foreach(i;\
    \ 2..N+1)\n    {\n        if(isPrime[i])\n        {\n            for(int j = 2;\
    \ j*i <= N; j++)\n            {\n                isPrime[j*i] = false;\n     \
    \       }\n        }\n    }\n    return filter!((i) => isPrime[i])(iota(0, N+1));\n\
    }\n/*\nFor two strings s1 and s2, find the longest common prefix of s1 and s2\n\
    >>> longest_common_prefix(\"abc\", \"a\")\n\"a\"\n>>> longest_common_prefix(\"\
    abc\", \"abcd\")\n\"abc\"\n>>> longest_common_prefix(\"abc\", \"abd\")\n\"ab\"\
    \n*/\nstring longest_common_prefix(string s1, string s2) \n{\n    int len = min(s1.length,\
    \ s2.length);\n    int prefix_len = 0;\n    foreach(i; 0..len)\n    {\n      \
    \  if(s1[i] == s2[i])\n        {\n            prefix_len++;\n        }\n     \
    \   else\n        {\n            break;\n        }\n    }\n    return s1[0..prefix_len];\n\
    }\n/*\nFor two strings s1 and s2, find the longest substring which is contained\
    \ in both of the", "{\n    long sum = 0;\n    long product = 1;\n    foreach(n;\
    \ numbers)\n    {\n        sum += n;\n        product *= n;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n  long a = 0;\n  long b = 1;\n  for(int i = 0;\
    \ i < numbers.length; i++)\n  {\n    a += numbers[i];\n    b *= numbers[i];\n\
    \  }\n  return tuple(a, b);\n}", "{\n    long sum = 0;\n    long product = 1;\n\
    \    foreach(number; numbers) \n    {\n        sum += number;\n        product\
    \ *= number;\n    }\n    return tuple(sum, product);\n}", "{\n    if (numbers.length\
    \ == 0) \n    {\n        return tuple(0L, 1L);\n    }", "{\n    long sum = 0L;\n\
    \    long prod = 1L;\n    foreach(number; numbers) \n    {\n        sum += number;\n\
    \        prod *= number;\n    }\n    return tuple(sum, prod);\n}", "{\n    long\
    \ sum = 0;\n    long prod = 1;\n    foreach(n; numbers)\n    {\n        sum +=\
    \ n;\n        prod *= n;\n    }\n    return tuple(sum, prod);\n}\n/*\nGiven a\
    \ string of words separated by whitespace, return a tuple of the words of the\
    \ string.\n    Ignore punctuation.\n    >>> words(\"a b c\\nd e f\")\n    tuple(\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\")\n    >>> words(\"\")\n    tuple()\n*/\n\
    Tuple!(string[]) words(string str) \n{\n    string[] words = str.split(c => c.isWhite);\n\
    \    return tuple(words);\n}", "{\n    long sum = 0;\n    long product = 1;\n\
    \    foreach(i; numbers)\n    {\n        sum += i;\n        product *= i;\n  \
    \  }\n    return tuple(sum, product);\n}", "{\n    long sum = 0;\n    long product\
    \ = 1;\n    foreach(number; numbers) \n    {\n        sum += number;\n       \
    \ product *= number;\n    }\n    return tuple(sum, product);\n}", "{\n    long\
    \ sum = 0;\n    long product = 1;\n    foreach(i; numbers)\n    {\n        sum\
    \ += i;\n        product *= i;\n    }\n    return tuple(sum, product);\n}", "{\n\
    \t long n = 0;\n\t long s = 1;\n\t foreach(l; numbers)\n\t {\n\t\t n += l;\n\t\
    \t s *= l;\n\t }\n\t return tuple(n, s);\n}", "{\n    long sum = 0;\n    long\
    \ prod = 1;\n    foreach(num; numbers)\n    {\n        sum += num;\n        prod\
    \ *= num;\n    }\n    return tuple(sum, prod);\n}", "{\n\treturn foldl!(\n\t\t\
    ((long sum, long prod) tuple, long x) => \n\t\t\ttuple.product *= x, \n\t\ttuple(0L,\
    \ 1L),\n\t\tnumbers\n\t);\n}", "{\n\tif (numbers.length == 0) \n\t{\n\t\treturn\
    \ tuple(0L, 1L);\n\t}\n\tlong sum = 0;\n\tlong product = 1;\n\tforeach (i; numbers)\
    \ \n\t{\n\t\tsum += i;\n\t\tproduct *= i;\n\t}\n\treturn tuple(sum, product);\n\
    }", "{\n\tTuple!(long, long) result = tuple(0L, 1L);\n\tforeach(index, value;\
    \ numbers)\n\t{\n\t\tresult[0] += value;\n\t\tresult[1] *= value;\n\t}\n\treturn\
    \ result;\n}", "{\n    long sum = 0;\n    long product = 1;\n    foreach(n; numbers)\
    \ \n    {\n        sum += n;\n        product *= n;\n    }\n    return tuple(sum,\
    \ product);\n}", "{\n    long sum;\n    long product;\n    foreach(index, num;\
    \ numbers)\n    {\n        sum += num;\n        product *= num;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n    auto sum = 0;\n    auto product = 1;\n   \
    \ foreach(num; numbers)\n    {\n        sum += num;\n        product *= num;\n\
    \    }\n    return tuple(sum, product);\n}", "{\n    long sum = 0;\n    long product\
    \ = 1;\n    foreach(i; numbers) \n    {\n        sum += i;\n        product *=\
    \ i;\n    }\n    return tuple(sum, product);\n}\n//for better performance\nTuple!(long,\
    \ long) sum_product_fast(long[] numbers) \n{\n    return tuple(sum(numbers), product(numbers));\n\
    }\n/*\nYou have to split a given integer by a given integer.", "{\n    long sum\
    \ = 0;\n    long product = 1;\n    foreach(number; numbers)\n    {\n        sum\
    \ += number;\n        product *= number;\n    }\n    return tuple(sum, product);\n\
    }", "{\n\tlong sum = 0L;\n\tlong product = 1L;\n\tforeach(long i; numbers)\n\t\
    {\n\t\tsum += i;\n\t\tproduct *= i;\n\t}\n\treturn tuple(sum, product);\n}\n/*\n\
    \ Return a list of numbers that are in the range(start, stop) of the given numbers.\n\
    \  Skip numbers which are divisible by 5.\n    >>> skip_range([-5L, 0L, 5L, 10L,\
    \ 15L, 20L, 25L, 30L, 35L], -10L, 25L)\n    [-5L, 0L, 10L, 20L]\n*/\nlong[] skip_range(long[]\
    \ numbers, long start, long stop)\n{\n\tlong[] result = new long[];\n\tforeach(long\
    \ i; numbers)\n\t{\n\t\tif(i > start && i < stop && i % 5 != 0)\n\t\t{\n\t\t\t\
    result ~= i;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Return a set of all the common\
    \ elements(no duplicates) in given two ranges.\n    >>> common_range([-5L, 0L,\
    \ 5L, 10L, 15L, 20L, 25L, 30L, 35L], [-20L, 0L, 20L, 40L, 60L, 80L])\n    [0L]\n\
    */\nlong[] common_range(long[] first, long[] second)\n{\n\tlong[] result = new\
    \ long[];\n\tforeach(long i; first)\n\t{\n\t\tforeach(long j; second)\n\t\t{\n\
    \t\t\tif(i == j)\n\t\t\t{\n\t\t\t\tresult ~= i;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\n Find the shortest distance between two words in a given text.\n\
    \    >>> text = \"This is an example\"\n    >>> distance(\"this\", \"is\", text)\n\
    \    1\n    >>> distance(\"an\", \"example\", text)\n    2\n    >>> distance(\"\
    foo\", \"bar\", text)\n    -1\n*/", "{\n\treturn reduce!((a,b) => tuple(a[0] +\
    \ b, a[1] * b))(numbers, tuple(0L, 1L));\n}", "{\n    long sum = 0;\n    long\
    \ product = 1;\n    foreach(num; numbers) \n    {\n        sum += num;\n     \
    \   product *= num;\n    }\n    return tuple(sum, product);\n}", "{\n    long\
    \ sum = 0;\n    long product = 1;\n    foreach(num; numbers)\n    {\n        sum\
    \ += num;\n        product *= num;\n    }\n    return tuple(sum, product);\n}",
  "{\n    auto sum = 0L;\n    auto product = 1L;\n    for (auto n : numbers)\n   \
    \ {\n        sum += n;\n        product *= n;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    auto result = tuple(0L, 1L);\n    for (long num; num = numbers[])\
    \ \n    {\n        result[0] += num;\n        result[1] *= num;\n    }\n    return\
    \ result;\n}\n/*\nFor a given array of floating point numbers, return a tuple\
    \ consisting of a sum and a product of all the floating point numbers in an array.\n\
    \    Empty sum should be equal to 0.0 and empty product should be equal to 1.0.\n\
    \    >>> sum_product([1.0, 2.0, 3.0, 4.0])\n    tuple(10.0, 24.0)\n*/\nTuple!(double,\
    \ double) sum_product(double[] numbers)\n{\n    auto result = tuple(0.0, 1.0);\n\
    \    for (double num; num = numbers[]) \n    {\n        result[0] += num;\n  \
    \      result[1] *= num;\n    }\n    return result;\n}\n/*\nFor a given array\
    \ of strings, return a tuple consisting of a sum and a product of all the strings\
    \ in an array.\n    Empty sum should be equal to 0 and empty product should be\
    \ equal to 1.\n    >>> sum_product([\"1\", \"2\", \"3\", \"4\"])\n    tuple(10,\
    \ 24)\n*/\nTuple!(ulong, ulong) sum_product(string[] numbers)\n{\n    auto result\
    \ = tuple(0, 1);\n    for (string num; num = numbers[]) \n    {\n        result[0]\
    \ += to!ulong(num);\n        result[1] *= to!ulong(num);\n    }\n    return result;\n\
    }\n//void main() {\n//    //sum_product([\"1\", \"2\", \"3\", \"4\"]);\n//   \
    \ //sum_product([1.0, 2.0, 3.0, 4.0]);\n//    sum_product([1L, 2L, 3L, 4L]);\n\
    //}", "{\n    return tuple(numbers.reduce!((a, b) => a + b), numbers.reduce!((a,\
    \ b) => a * b));\n}", "{\n\treturn numbers.empty \n\t\t? tuple(0L, 1L) \n\t\t\
    : numbers.reduce!((long x, long y) => tuple(x[0] + y, x[1] * y));\n}", "{\n  \
    \  long sum = 0;\n    long product = 1;\n    foreach(idx, num; numbers) \n   \
    \ {\n        sum += num;\n        product *= num;\n    }\n    return tuple(sum,\
    \ product);\n}\n/*\nGiven a tuple of float numbers, return a tuple of the same\
    \ size, where all numbers are rounded to the nearest integer.\n    >>> round_nearest((0.5f,\
    \ 1.1f, 1.5f, 2.9f))\n    tuple(1L, 1L, 2L, 3L)\n*/\nstatic Tuple!(long) round_nearest(Tuple!(float)\
    \ tuple) \n{\n    Tuple!(long) round_tuple;\n    foreach(idx, num; tuple) \n \
    \   {\n        round_tuple ~= cast(long) round(num);\n    }\n    return round_tuple;\n\
    }\n/*\n Given a tuple of two elements, return the sum of their elements.\n   \
    \ >>> sum_tuple((1L, 2L))\n    3L\n*/\nlong sum_tuple(Tuple!(long, long) tuple)\
    \ \n{\n    return tuple[0] + tuple[1];\n}\n/*\n Given a range of integers, return\
    \ the sum of all numbers in the range.\n    >>> sum_range(0 .. 10)\n    55L\n\
    */\nlong sum_range(int lwr, int upr) \n{\n    long sum = 0;\n    foreach(num;\
    \ lwr .. upr) \n    {\n        sum += num;\n    }\n    return sum;\n}\n/*\n Given\
    \ a string with a number, return that number.\n    >>> extract_number(\"abc34\"\
    )\n    34L\n*/\nlong extract_number(string str) \n{\n    long num = 0;\n    foreach(c;\
    \ str) \n    {\n        if('0' <= c && c <= '9') \n        {\n            num\
    \ = num * 10 + cast(long) c - '0';\n        }\n    }\n    return num;\n}\n/*\n\
    \ Given a string, return a tuple with all the letters and numbers in a string.\n\
    \    >>>", "{\n    long sum = 0L;\n    long product = 1L;\n    foreach(i; numbers)\n\
    \    {\n        sum += i;\n        product *= i;\n    }\n    return tuple(sum,\
    \ product);\n}", "{\n    long sum = 0;\n    long product = 1;\n    foreach(n;\
    \ numbers) \n    {\n        sum += n;\n        product *= n;\n    }\n    return\
    \ tuple(sum, product);\n}\n/*\n    Write a function that takes a string that consists\
    \ of only lowercase letters and returns a new string with all the vowels removed.\n\
    \    >>> remove_vowels(\"hello\")\n    \"hll\"\n    >>> remove_vowels(\"sydney\"\
    )\n    \"sydny\"\n*/\nstring remove_vowels(string s)\n{\n    string result = \"\
    \";\n    foreach(c; s)\n    {\n        if(!c.isVowel)\n        {\n           \
    \ result ~= c;\n        }\n    }\n    return result;\n}\n/*\n    Write a function\
    \ that takes a two-dimensional array of numbers and returns the sum of each row.\n\
    \    >>> sum_rows([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    [6, 15, 24]\n*/\nlong[]\
    \ sum_rows(long[][] array)\n{\n    long[] result;\n    foreach(row; array)\n \
    \   {\n        long sum = 0;\n        foreach(e; row)\n        {\n           \
    \ sum += e;\n        }\n        result ~= sum;\n    }\n    return result;\n}\n\
    /*\n    Write a function that takes a two-dimensional array of numbers and returns\
    \ the sum of each column.\n    >>> sum_columns([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\
    \    [12, 15, 18]\n*/\nlong[] sum_columns(long[][] array)\n{\n    long[] result;\n\
    \    for(long i = 0; i < array[0].length; i++)\n    {\n        long sum = 0;\n\
    \        foreach(row; array)\n        {\n            sum += row[i];\n        }\n\
    \        result ~= sum;\n    }\n    return result;\n}\n/*\n    Write a function\
    \ that takes a string consisting of whitespace and letters and returns a string\
    \ where", "{\n\tlong sum = 0;\n\tlong product = 1;\n\tforeach(n; numbers)\n\t\
    {\n\t\tsum += n;\n\t\tproduct *= n;\n\t}\n\treturn tuple(sum, product);\n}", "{\n\
    \    if (numbers.length == 0) \n    {\n        return tuple(0L, 1L);\n    }\n\
    \    else \n    {\n        auto sum = reduce!(\"a + b\")(numbers);\n        auto\
    \ prod = reduce!(\"a * b\")(numbers);\n        return tuple(sum, prod);\n    }\n\
    }", "{\n    auto result = tuple(0L, 1L);\n    foreach(idx, number; numbers)\n\
    \    {\n        result[0] += number;\n        result[1] *= number;\n    }\n  \
    \  return result;\n}", "{\n\tauto sum = 0;\n\tauto product = 1;\n\tforeach(n;\
    \ numbers)\n\t{\n\t\tsum += n;\n\t\tproduct *= n;\n\t}\n\treturn tuple(sum, product);\n\
    }\n/*\nGiven a tuple of three elements, determine whether it can be split into\
    \ two tuples of equal sum.\n    >>> equal_sum([1L, 2L, 3L])\n    true\n    >>>\
    \ equal_sum([1L, 2L, 1L])\n    false\n*/", "{\n\tlong sum = 0;\n\tlong prod =\
    \ 1;\n\t\n\tforeach(num; numbers)\n\t{\n\t\tsum += num;\n\t\tprod *= num;\n\t\
    }\n\t\n\treturn tuple(sum, prod);\n}", "{\n    return Tuple!(long, long)(numbers.reduce!((a,\
    \ b) => a + b)(0), numbers.reduce!((a, b) => a * b)(1));\n}\n/*\n For a given\
    \ array of integers, return a tuple consisting of a min and a max of all the integers\
    \ in an array.\n    >>> min_max([])\n    tuple(-Infinity, Infinity)\n    >>> min_max([1L,\
    \ 2L, 3L, 4L])\n    tuple(1L, 4L)\n    >>> min_max([2L, 2L, 2L, 2L])\n    tuple(2L,\
    \ 2L)\n*/\nTuple!(long, long) min_max(long[] numbers) \n{\n    return Tuple!(long,\
    \ long)(numbers.reduce!((a, b) => min(a, b))(0), numbers.reduce!((a, b) => max(a,\
    \ b))(0));\n}\n/*\nCheck if a given positive integer is a square of another integer.\n\
    \    >>> is_square(2L)\n    false\n    >>> is_square(3L)\n    false\n    >>> is_square(4L)\n\
    \    true\n    >>> is_square(16L)\n    true\n    >>> is_square(25L)\n    true\n\
    \    >>> is_square(26L)\n    false\n*/", "{\n    long sum = 0;\n    long product\
    \ = 1;\n    foreach(n; numbers)\n    {\n        sum += n;\n        product *=\
    \ n;\n    }\n    return tuple(sum, product);\n}", "{\n    long sum = 0;\n    long\
    \ product = 1;\n    foreach(int n; numbers) \n    {\n        sum += n;\n     \
    \   product *= n;\n    }\n    return tuple(sum, product);\n}", "{\n    auto sum\
    \ = 0;\n    auto prod = 1;\n    foreach(num; numbers)\n    {\n        sum += num;\n\
    \        prod *= num;\n    }\n    return tuple(sum, prod);\n}\n \n/*\nReturn a\
    \ list of all pairs of numbers from a given list. Each pair should be represented\
    \ as a tuple of two numbers.\n    >>> cartesian_product([1L, 2L, 3L], [4L, 5L])\n\
    \    [tuple(1L, 4L), tuple(1L, 5L), tuple(2L, 4L), tuple(2L, 5L), tuple(3L, 4L),\
    \ tuple(3L, 5L)]\n    \n*/\nTuple!(long, long)[] cartesian_product(long[] a, long[]\
    \ b) \n{\n    auto result = [];\n    foreach(x; a)\n    {\n        foreach(y;\
    \ b)\n        {\n            result ~= tuple(x, y);\n        }\n    }\n    return\
    \ result;\n}\n \n/*\n Implement cartesian_product function where the number of\
    \ lists to be multiplied and the sizes of the lists may vary.\n    >>> cartesian_product([1L,\
    \ 2L, 3L], [4L, 5L], [6L, 7L])\n    [tuple(1L, 4L, 6L), tuple(1L, 4L, 7L), tuple(1L,\
    \ 5L, 6L), tuple(1L, 5L, 7L), tuple(2L, 4L, 6L), tuple(2L, 4L, 7L), tuple(2L,\
    \ 5L, 6L), tuple(2L, 5L, 7L), tuple(3L, 4L, 6L), tuple(3L, 4L, 7L), tuple(3L,\
    \ 5L, 6L), tuple(3L, 5L, 7L)]\n    \n*/\nTuple!(long[]) cartesian_product(long[][]\
    \ lists) \n{\n    auto result = [];\n    foreach(x; lists[0])\n    {\n       \
    \ if(lists.length == 1)\n        {\n            result ~= tuple(x);\n        }\n",
  "{\n    import std.algorithm;\n    return make!(Tuple!(long, long))(reduce!((a,\
    \ b) => a + b)(numbers), reduce!((a, b) => a * b)(numbers));\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
