name: HumanEval_8_sum_product
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n For a given array of integers,\
  \ return a tuple consisting of a sum and a product of all the integers in an array.\n\
  \    Empty sum should be equal to 0 and empty product should be equal to 1.\n  \
  \  >>> sum_product([])\n    tuple(0L, 1L)\n    >>> sum_product([1L, 2L, 3L, 4L])\n\
  \    tuple(10L, 24L)\n    \n*/\nTuple!(long, long) sum_product(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = sum_product;\n\n    assert(candidate([])\
  \ == tuple(0L, 1L));\n    assert(candidate([1L, 1L, 1L]) == tuple(3L, 1L));\n  \
  \  assert(candidate([100L, 0L]) == tuple(100L, 0L));\n    assert(candidate([3L,\
  \ 5L, 7L]) == tuple(15L, 105L));\n    assert(candidate([10L]) == tuple(10L, 10L));\n\
  }\nvoid main(){}"
completions: ["{\n\tTuple!(long, long) result;\n\tresult.field1 = result.field2 =\
    \ 0;\n\tforeach(n; numbers)\n\t{\n\t\tresult.field1 += n;\n\t\tresult.field2 *=\
    \ n;\n\t}\n\treturn result;\n}\n/*\n Given a list of keywords and a sentence,\
    \ return a dictionary where each keyword maps to a set of indexes where it was\
    \ found in the sentence.\n    >>> find_keywords(\"D D is D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D", "{\n    long sum = 0L;\n    long product = 1L;\n    foreach(n;\
    \ numbers)\n    {\n        sum += n;\n        product *= n;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n    long sum = 0;\n    long product = 1;\n   \
    \ foreach(i; numbers) \n    {\n        sum += i;\n        product *= i;\n    }\n\
    \    return tuple(sum, product);\n}\n/*\nThe output of a process is a string but\
    \ you have to parse it in order to extract the data you are interested in.\nWrite\
    \ a function that returns a tuple.\nThe first element of a tuple is an array of\
    \ integers and the second element is a dictionary which contains\nfrequency of\
    \ occurrence of each of the words in the input string.", "{\n    long sum = 0L;\n\
    \    long product = 1L;\n    foreach(n; numbers) \n    {\n        sum += n;\n\
    \        product *= n;\n    }\n    return tuple(sum, product);\n}\n/*\n For an\
    \ integer array, return an array consisting of two elements:\n    the first is\
    \ the array's sum,\n    the second is the array's product.\n    If the array is\
    \ empty, return an array with two zeros.\n    >>> sum_product_2([])\n    [0L,\
    \ 0L]\n    >>> sum_product_2([1L, 2L, 3L, 4L])\n    [10L, 24L]\n*/\nlong[] sum_product_2(long[]\
    \ numbers) \n{\n    long sum = 0L;\n    long product = 1L;\n    foreach(n; numbers)\
    \ \n    {\n        sum += n;\n        product *= n;\n    }\n    return [sum, product];\n\
    }\n/*\n Return all the integers from a given array that are larger than all the\
    \ elements to their right.\n    >>> larger_than_right([])\n    []\n    >>> larger_than_right([2L,\
    \ 3L, 1L, 5L, 0L])\n    [3L, 5L]\n    >>> larger_than_right([1L, 2L, 3L, 4L, 5L])\n\
    \    [5L]\n*/\nlong[] larger_than_right(long[] numbers) \n{\n    long[] result\
    \ = [];\n    long rightMax = -1L;\n    for(int i = numbers.length - 1; i >= 0;\
    \ i--) \n    {\n        if(numbers[i] > rightMax) \n        {\n            rightMax\
    \ = numbers[i];\n            result ~= numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n Return a tuple consisting of a number and the sum of its digits.\n\
    \    >>> find_number_and_sum_of_digits(7L)\n    tuple(7L, 7L)\n    >>> find_number_and_sum_of_digits(1234L)\n\
    \    tuple(1234L, 10", "{\n    long t_sum = 0;\n    long t_prod = 1;\n    foreach(num;\
    \ numbers) \n    {\n        t_sum += num;\n        t_prod *= num;\n    }\n   \
    \ return tuple(t_sum, t_prod);\n}\n// void main() \n// {\n//     writeln(sum_product([1,\
    \ 2, 3, 4]));\n// }", "{\n    long sum = 0;\n    long product = 1;\n    foreach(num;\
    \ numbers)\n    {\n        sum += num;\n        product *= num;\n    }\n    return\
    \ tuple(sum, product);\n}\n/*\n    Write a function that returns a tuple of a\
    \ minimum and a maximum value in a non-empty array of integers.\n    >>> min_max([2L,\
    \ 4L, 3L, 6L, 1L])\n    tuple(1L, 6L)\n*/\nTuple!(long, long) min_max(long[] numbers)\
    \ \n{\n    long min;\n    long max;\n    foreach(num; numbers)\n    {\n      \
    \  if(num > max)\n        {\n            max = num;\n        }\n        if(num\
    \ < min)\n        {\n            min = num;\n        }\n    }\n    return tuple(min,\
    \ max);\n}\n/*\n    Given an array of integers, return an array of the same integers\
    \ in reverse order.\n    >>> reverse_array([2L, 4L, 3L, 6L, 1L])\n    [1L, 6L,\
    \ 3L, 4L, 2L]\n*/\nlong[] reverse_array(long[] numbers) \n{\n    long[] temp =\
    \ [1];\n    foreach(num; numbers)\n    {\n        temp ~= [num];\n    }\n    temp.reverse;\n\
    \    return temp;\n}\n/*\n    Write a function that takes a string and returns\
    \ a tuple containing the number of upper case letters, lower case letters, \n\
    \    spaces, and punctuation characters.\n    >>> count_chars(\"Aa kiu, I swd\
    \ skieo 236587. GH kiu: sieo?? 25.33\")\n    tuple(3L, 19L, 4L, 5L)\n*/\nTuple!(long,\
    \ long, long, long) count_chars(string str) \n{\n    long spaces = 0;\n    long\
    \ upper = 0;\n    long lower = 0;\n    long punct = 0;\n    foreach(ch; str)\n\
    \    {\n        if(ch == ' ')\n        {\n            spaces++;\n        }\n \
    \       else if(", "{\n    long result_sum = 0L;\n    long result_product = 1L;\n\
    \    foreach(number; numbers)\n    {\n        result_sum += number;\n        result_product\
    \ *= number;\n    }\n    return tuple(result_sum, result_product);\n}", "{\n \
    \   long sum = 0;\n    long product = 1;\n    if (numbers.length > 0)\n    {\n\
    \        for (auto n : numbers)\n        {\n            sum += n;\n          \
    \  product *= n;\n        }\n    }\n    return tuple(sum, product);\n}", "{\n\
    \    // lazy evaluation.\n    long sum = reduce!q{a + b}(0, numbers);\n    long\
    \ product = reduce!q{a * b}(1, numbers);\n    return tuple(sum, product);\n}\n\
    /*\nWrite a function which returns elements that are in the first list but not\
    \ in the second list.", "{\n    static assert(numbers.length == 0 || (isInputRange!(typeof(numbers))\
    \ && is(ElementType!(typeof(numbers)) == long)));\n    return tuple(reduce!((a,\
    \ b) => a + b)(numbers), reduce!((a, b) => a * b)(numbers));\n}", "{\n    long\
    \ sum = 0L;\n    long prod = 1L;\n    foreach(n; numbers) \n    {\n        sum\
    \ += n;\n        prod *= n;\n    }\n    return tuple(sum, prod);\n}", "{\n   \
    \ long sum = 0;\n    long product = 1;\n    foreach(index, number; numbers)\n\
    \    {\n        sum += number;\n        product *= number;\n    }\n    return\
    \ tuple(sum, product);\n}", "{\n    return tuple(numbers.sum, numbers.product);\n\
    }\n/*\n Given a tuple of integer coordinates (x, y), you have to swap them.\n\
    \     >>> swap_coordinates((1L, 2L))\n     tuple(2L, 1L)\n     >>> swap_coordinates((0L,\
    \ -1L))\n     tuple(-1L, 0L)\n*/\nTuple!(long, long) swap_coordinates(Tuple!(long,\
    \ long) point) \n{\n    return tuple(point[1], point[0]);\n}\n/*\n You have an\
    \ array of integers, where -99999 stands for empty cell.\n    Your task is to\
    \ find the number of squares of empty cells.\n    >>> empty_cells([[5L, 9L, 6L,\
    \ -99999L, 1L],\n                     [2L, 3L, 7L, 5L, -99999L],\n           \
    \          [7L, -99999L, -99999L, 1L, 2L],\n                     [3L, -99999L,\
    \ 6L, -99999L, 3L],\n                     [1L, 6L, 4L, -99999L, 9L]])\n    2L\n\
    */\nlong empty_cells(long[][] table) \n{\n    long counter = 0;\n    foreach(row;\
    \ table) \n    {\n        foreach(cell; row) \n        {\n            if(cell\
    \ == -99999) \n            {\n                counter++;\n            }\n    \
    \    }\n    }\n    return counter;\n}\n/*\n    You have a list of integer coordinates\
    \ of circles centers and their radiuses.\n    Your task is to find the number\
    \ of overlapping circles.\n    To get the overlapping circles count, you need\
    \ to find the number of points that belong to at least two circles.\n    >>> circles_overlap([((0L,\
    \ 0L), 5L), ((-5L, 5L), 3L), ((5L, 5L), 3L), ((5L, -5L), 3L), ((-5L, -5L), 3L)])\n\
    \    1L\n*/\nlong circles_overlap(Tuple!(Tuple!(long, long), long)[] circles",
  "{\n    auto s = 0L;\n    auto p = 1L;\n    foreach(n; numbers) \n    {\n      \
    \  s += n;\n        p *= n;\n    }\n    return tuple(s, p);\n}", "{\n    return\
    \ numbers.reduce!((a, b) => tuple(a[0] + b, a[1] * b));\n}", "{\n    long product\
    \ = 1;\n    long sum = 0;\n    if (numbers.length == 0)\n    {\n        return\
    \ tuple(sum, product);\n    }\n    for (long num; num in numbers)\n    {\n   \
    \     product *= num;\n        sum += num;\n    }\n    return tuple(sum, product);\n\
    }", "{\n    long p = 1;\n    long s = 0;\n    for(long i = 0; i < numbers.length;\
    \ i++)\n    {\n        p *= numbers[i];\n        s += numbers[i];\n    }\n   \
    \ return tuple(s, p);\n}\n/*\nWe need a function that can transform a number into\
    \ a string.\n    What ways of achieving this do you know?\n    \n*/\nstring number_to_string(long\
    \ n)\n{\n    return to!string(n);\n}\n/*\nGiven an array of strings, you need\
    \ to find the longest string\n    \n*/\nstring find_longest_string(string[] ss)\n\
    {\n    string s = \"\";\n    foreach(string x; ss)\n    {\n        if(x.length\
    \ > s.length)\n        {\n            s = x;\n        }\n    }\n    return s;\n\
    }\n/*\n    You have an array of numbers.\n    Your task is to sort ascending odd\
    \ numbers but even numbers must be on their places.\n    \n    Zero isn't an odd\
    \ number and you don't need to move it. If you have an empty array, you need to\
    \ return it.\n*/", "{\n    long sum = 0L;\n    long product = 1L;\n    foreach(number;\
    \ numbers)\n    {\n        sum += number;\n        product *= number;\n    }\n\
    \    return tuple(sum, product);\n}", "{\n    long sum = 0L;\n    long product\
    \ = 1L;\n    foreach(num; numbers)\n    {\n        sum += num;\n        product\
    \ *= num;\n    }\n    return tuple(sum, product);\n}\n//this is not a good example\
    \ of the tuple usage \n//but it demonstrates that value obtained from the tuple\n\
    // can be unpacked directly into variables", "{\n    long sum = 0;\n    long product\
    \ = 1;\n    foreach(number; numbers) \n    {\n        sum += number;\n       \
    \ product *= number;\n    }\n    return tuple(sum, product);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
