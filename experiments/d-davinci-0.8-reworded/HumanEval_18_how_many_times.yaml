name: HumanEval_18_how_many_times
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
  \ substring can be found in the original string. Count overlaping cases.\n    >>>\
  \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
  \    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
  \ string, string substring) \n"
tests: "unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
  \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
  cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n\
  }\nvoid main(){}"
completions: ["{\n\tconst auto length_of_string = string.length;\n\tconst auto length_of_substring\
    \ = substring.length;\n\t\n\tlong count = 0;\n\t\n\tif(!length_of_string || !length_of_substring)\n\
    \t\treturn count;\n\t\t\n\tfor(long i = 0; i <= length_of_string - length_of_substring;\
    \ i++)\n\t{\n\t\tif(string[i .. i + length_of_substring] == substring)\n\t\t\t\
    count++;\n\t}\n\t\n\treturn count;\n}", "{\n    long count = 0;\n    for (int\
    \ i = 0; i < string.length - substring.length; i++) \n    {\n        if (string[i\
    \ .. i + substring.length] == substring) \n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find the number of times a given\
    \ substring can be found in the original string.\n >>> count_substrings(\"This\
    \ is a test string\", \"is\")\n 2L\n    >>> count_substrings(\"babababa\", \"\
    baba\")\n 3L\n    >>> count_substrings(\"Python is an awesome language to program\
    \ in!\", \"o\")\n 4L\n    >>> count_substrings(\"We have nothing in common!\"\
    , \"really?\")\n 0L\n    >>> count_substrings(\"This is this and that is this\"\
    , \"this\")\n 2L", "{\n    long string_length = string.length;\n    long substring_length\
    \ = substring.length;\n    if (substring_length > string_length) \n    {\n   \
    \     return 0L;\n    }\n    long[] string_substring_table = build_substring_table(substring);\n\
    \    return count_substring_matches(string, substring, string_substring_table);\n\
    }", "in{\n    assert(substring.length <= string.length);\n}\nout(count) {\n  \
    \  assert(count <= string.length - substring.length + 1);\n} body {\n    long\
    \ count = 0;\n    size_t sublen = substring.length;\n    if (sublen == 0)\n  \
    \      return 0;\n    for (size_t i = 0; i < string.length - sublen + 1; i++)\
    \ {\n        //printf(\"i: %i\\n\", i);\n        if (string[i..i+sublen] == substring)\
    \ {\n            count++;\n        }\n    }\n    return count;\n}", "{\n    long\
    \ count = 0;\n    foreach(immutable k; 0 .. string.length)\n    {\n        if(string[k\
    \ .. k + substring.length - 1] == substring)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find the position of the first occurence\
    \ of the given substring. Return (size_t)-1 if not found. Count overlaping cases.\n\
    \    >>> find_first_pos(\"\", \"a\")\n    -1L\n    >>> find_first_pos(\"aaa\"\
    , \"a\")\n    0L\n    >>> find_first_pos(\"aaab\", \"ab\")\n    2L\n    \n*/\n\
    long find_first_pos(string string, string substring) \n{\n    foreach(immutable\
    \ k; 0 .. string.length)\n    {\n        if(string[k .. k + substring.length -\
    \ 1] == substring)\n        {\n            return k;\n        }\n    }\n    return\
    \ -1;\n}\n/*\n Find the position of the last occurence of the given substring.\
    \ Return (size_t)-1 if not found. Count overlaping cases.\n    >>> find_last_pos(\"\
    \", \"a\")\n    -1L\n    >>> find_last_pos(\"aaa\", \"a\")\n    2L\n    >>> find_last_pos(\"\
    aaab\", \"ab\")\n    2L\n    \n*/\nlong find_last_pos(string string, string substring)\
    \ \n{\n    immutable r = -1;\n    foreach(immutable k; 0 .. string.length)\n \
    \   {\n        if(string[k .. k + substring.length - 1] == substring)\n      \
    \  {\n            r = k;\n        }\n    }\n    return r;\n}\n/*\n Check if the\
    \ given string ends with the given substring.\n    >>> ends_with(\"\", \"a\")\n\
    \    false\n    >>> ends_with(\"aaa\", \"a\")\n    true\n    >>> ends_with(\"\
    aaa\", \"aaaa\")\n    false\n    \n*/", "{\n    long result = 0;\n    for (long\
    \ i = 0; i < string.length; i++) \n    {\n        if (string[i .. i + substring.length]\
    \ == substring) \n        {\n            result++;\n        }\n    }\n    return\
    \ result;\n}", "    pure \n{\n    long ret = 0;\n    size_t pos = 0;\n    while\
    \ ((pos = string.find(substring, pos)) != string.npos) \n    {\n        ret++;\n\
    \        pos += 2;\n    }\n    return ret;\n}", "{\n    long count = 0;\n    if\
    \ (empty(substring)) \n    {\n        return count;\n    }\n    else \n    {\n\
    \        for (long i = 0; i < len(string); i++) \n        {\n            for (long\
    \ j = 0; j < len(substring); j++) \n            {\n                if (string[i\
    \ + j] != substring[j]) \n                {\n                    break;\n    \
    \            }\n                if (j == len(substring) - 1) \n              \
    \  {\n                    count++;\n                }\n            }\n       \
    \ }\n        return count;\n    }\n}", "in \n{\n    assert(string.length >= substring.length);\n\
    }\nbody \n{\n    long count = 0L;\n    auto stringRange = string.byChunks(substring.length);\n\
    \    foreach (i, chunk; stringRange)\n    {\n        if (chunk == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    if (substring.length == 0)\n        return 0;\n    if (string.length == 0)\n\
    \        return 0;\n    if (string.length < substring.length)\n        return\
    \ 0;\n    long counter = 0;\n    if (string.find(substring, 0) != -1)\n      \
    \  counter++;\n    for (long i = 0; i < string.length; i++)\n    {\n        long\
    \ index = string.find(substring, i);\n        if (index == -1)\n            break;\n\
    \        else\n        {\n            counter++;\n            i = index;\n   \
    \     }\n    }\n    return counter;\n}", "{\n    static assert(substring.length\
    \ <= string.length);\n    long count = 0;\n    auto string_it = string.front;\n\
    \    while ((string_it = find(string_it, string.back, substring.front)) != string.back)\n\
    \    {\n        auto substring_it = substring.front;\n        while (substring_it\
    \ != substring.back && string_it != string.back && *substring_it == *string_it)\n\
    \        {\n            ++substring_it;\n            ++string_it;\n        }\n\
    \        if (substring_it == substring.back)\n        {\n            ++count;\n\
    \        }\n    }\n    return count;\n}\n \n/*\n    >>> flatten_tuple((1,), (2,),\
    \ (3,))\n    (1, 2, 3)\n    >>> flatten_tuple((1,), (2,), ())\n    (1, 2)\n  \
    \  >>> flatten_tuple((), (2,), (3,))\n    (2, 3)\n    >>> flatten_tuple((1, (2,),\
    \ (3,)),)\n    (1, 2, 3)\n    >>> flatten_tuple(((1,), (2,), (3,)),)\n    (1,\
    \ 2, 3)\n    >>> flatten_tuple(((1, 2),), ((3, 4),))\n    ((1, 2), (3, 4))\n \
    \   >>> flatten_tuple(((1, 2),), ((3, 4),), ((5, 6),))\n    ((1, 2), (3, 4), (5,\
    \ 6))\n    >>> flatten_tuple(((1,), (2,), (3,)), ((4,), (5,), (6,)))\n    (1,\
    \ 2, 3, 4, 5, 6)\n*/\nauto flatten_tuple(auto args...)\n{\n    auto result = tuple();\n\
    \    foreach (arg; args)\n    {\n        result ~= arg;\n    }\n    return result;\n\
    }", "{\n\tlong count = 0;\n\tlong index = 0;\n\tlong length = string.length;\n\
    \t\n\twhile (index < length)\n\t{\n\t\tif (string[index .. $] == substring)\n\t\
    \t{\n\t\t\tcount++;\n\t\t\tindex += substring.length;\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t\tindex++;\n\t\t}\n\t}\n\t\n\treturn count;\n}\n/*\n Determine if a string\
    \ starts with another string.\n    >>> is_starts_with(\"Hello, world!\", \"Hello\"\
    )\n    true\n    >>> is_starts_with(\"Hello, world!\", \"Hello,\")\n    true\n\
    \    >>> is_starts_with(\"Hello, world!\", \".\")\n    false\n    >>> is_starts_with(\"\
    Hello, world!\", \"\")\n    true\n*/", "{\n  long counter = 0;\n  long index =\
    \ 0;\n  int len = length(substring);\n  //1. Find the index for the given substring\n\
    \  //2. When the index is not -1, increase the counter and get the index from\
    \ the next index of the found index\n  //3. Repeat.\n  while(true)\n  {\n    index\
    \ = indexOf(string, substring, index);\n    if(index == -1)\n      break;\n  \
    \  counter++;\n    index += len;\n  }\n  return counter;\n}", "{\n    return count(string.countUntil(substring));\n\
    }\n```", "{\n    long count = 0;\n    while(search(string, substring))\n    {\n\
    \        count += 1;\n        string = string[substring.length .. $];\n    }\n\
    \    return count;\n}", "{\n    if (string.empty || substring.empty) \n    {\n\
    \        return 0L;\n    }\n    long result = 0L;\n    long i = 0L;\n    long\
    \ slen = string.length;\n    long sublen = substring.length;\n    while (i < slen)\
    \ \n    {\n        if (string[i..$] == substring) \n        {\n            result\
    \ += 1L;\n            i += sublen;\n        }\n        else \n        {\n    \
    \        i += 1L;\n        }\n    }\n    return result;\n}\n/*\n Find the position\
    \ of the first occurrence of a substring in a string.\n    >>> find_index(\"abcdefg\"\
    , \"cd\")\n    2L\n    >>> find_index(\"abcdefg\", \"cde\")\n    2L\n    >>> find_index(\"\
    abcdefg\", \"c\")\n    2L\n    >>> find_index(\"abcdefg\", \"d\")\n    3L\n  \
    \  >>> find_index(\"abcdefg\", \"fg\")\n    5L\n    >>> find_index(\"abcdefg\"\
    , \"a\")\n    0L\n    >>> find_index(\"abcdefg\", \"\")\n    0L\n    >>> find_index(\"\
    abcdefg\", \"g\")\n    6L\n    >>> find_index(\"abcdefg\", \"h\")\n    -1L\n*/\n\
    long find_index(string string, string substring) \n{\n    if (string.empty ||\
    \ substring.empty) \n    {\n        return 0L;\n    }\n    long i = 0L;\n    long\
    \ slen = string.length;\n    long sublen = substring.length;\n    while (i < slen)\
    \ \n    {\n        if (string[i..$] == substring) \n        {\n            return\
    \ i;\n        }\n        else \n        {\n            i += 1L;\n        }\n \
    \   }\n    return -1L;\n}\n/*\n Returns a slice of the given string starting after\
    \ the first occurrence of the given pattern.\n    >>> skip_prefix(\"abcdefg\"\
    , \"cd\")\n    \"efg\"\n    >>> skip_prefix(\"abcdefg", "{\n    long len = string.length;\n\
    \    long sublen = substring.length;\n    long i = 0;\n    long count = 0;\n \
    \   while (i + sublen <= len)\n    {\n        if (substring == string[i..sublen])\n\
    \        {\n            count++;\n        }\n        i++;\n    }\n    return count;\n\
    }", "{\n    auto n = 0L;\n    auto ind = -1L;\n    while ((ind = string.find(substring,\
    \ ind + 1)) != -1L) \n    {\n        n++;\n    }\n    return n;\n}", "{\n    long\
    \ occurrences = 0;\n    size_t found_at = 0;\n    size_t next_pos = 0;\n    foreach(string;\
    \ find(string, substring, next_pos))\n    {\n        occurrences++;\n        found_at\
    \ = next_pos;\n        next_pos = found_at + 1;\n    }\n    return occurrences;\n\
    }", "{\n  long count = 0;\n  foreach(int start, string str; find(string, substring))\n\
    \  {\n    count++;\n  }\n  return count;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
