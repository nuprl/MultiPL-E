name: HumanEval_18_how_many_times
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
  \ substring can be found in the original string. Count overlaping cases.\n    >>>\
  \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
  \    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
  \ string, string substring) \n"
tests: "unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
  \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
  cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n\
  }\nvoid main(){}"
completions: ["{\n\tconst auto length_of_string = string.length;\n\tconst auto length_of_substring\
    \ = substring.length;\n\t\n\tlong count = 0;\n\t\n\tif(!length_of_string || !length_of_substring)\n\
    \t\treturn count;\n\t\t\n\tfor(long i = 0; i <= length_of_string - length_of_substring;\
    \ i++)\n\t{\n\t\tif(string[i .. i + length_of_substring] == substring)\n\t\t\t\
    count++;\n\t}\n\t\n\treturn count;\n}", "{\n    long count = 0;\n    for (int\
    \ i = 0; i < string.length - substring.length; i++) \n    {\n        if (string[i\
    \ .. i + substring.length] == substring) \n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find the number of times a given\
    \ substring can be found in the original string.\n >>> count_substrings(\"This\
    \ is a test string\", \"is\")\n 2L\n    >>> count_substrings(\"babababa\", \"\
    baba\")\n 3L\n    >>> count_substrings(\"Python is an awesome language to program\
    \ in!\", \"o\")\n 4L\n    >>> count_substrings(\"We have nothing in common!\"\
    , \"really?\")\n 0L\n    >>> count_substrings(\"This is this and that is this\"\
    , \"this\")\n 2L", "{\n    long string_length = string.length;\n    long substring_length\
    \ = substring.length;\n    if (substring_length > string_length) \n    {\n   \
    \     return 0L;\n    }\n    long[] string_substring_table = build_substring_table(substring);\n\
    \    return count_substring_matches(string, substring, string_substring_table);\n\
    }", "in{\n    assert(substring.length <= string.length);\n}\nout(count) {\n  \
    \  assert(count <= string.length - substring.length + 1);\n} body {\n    long\
    \ count = 0;\n    size_t sublen = substring.length;\n    if (sublen == 0)\n  \
    \      return 0;\n    for (size_t i = 0; i < string.length - sublen + 1; i++)\
    \ {\n        //printf(\"i: %i\\n\", i);\n        if (string[i..i+sublen] == substring)\
    \ {\n            count++;\n        }\n    }\n    return count;\n}", "{\n    long\
    \ count = 0;\n    foreach(immutable k; 0 .. string.length)\n    {\n        if(string[k\
    \ .. k + substring.length - 1] == substring)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find the position of the first occurence\
    \ of the given substring. Return (size_t)-1 if not found. Count overlaping cases.\n\
    \    >>> find_first_pos(\"\", \"a\")\n    -1L\n    >>> find_first_pos(\"aaa\"\
    , \"a\")\n    0L\n    >>> find_first_pos(\"aaab\", \"ab\")\n    2L\n    \n*/\n\
    long find_first_pos(string string, string substring) \n{\n    foreach(immutable\
    \ k; 0 .. string.length)\n    {\n        if(string[k .. k + substring.length -\
    \ 1] == substring)\n        {\n            return k;\n        }\n    }\n    return\
    \ -1;\n}\n/*\n Find the position of the last occurence of the given substring.\
    \ Return (size_t)-1 if not found. Count overlaping cases.\n    >>> find_last_pos(\"\
    \", \"a\")\n    -1L\n    >>> find_last_pos(\"aaa\", \"a\")\n    2L\n    >>> find_last_pos(\"\
    aaab\", \"ab\")\n    2L\n    \n*/\nlong find_last_pos(string string, string substring)\
    \ \n{\n    immutable r = -1;\n    foreach(immutable k; 0 .. string.length)\n \
    \   {\n        if(string[k .. k + substring.length - 1] == substring)\n      \
    \  {\n            r = k;\n        }\n    }\n    return r;\n}\n/*\n Check if the\
    \ given string ends with the given substring.\n    >>> ends_with(\"\", \"a\")\n\
    \    false\n    >>> ends_with(\"aaa\", \"a\")\n    true\n    >>> ends_with(\"\
    aaa\", \"aaaa\")\n    false\n    \n*/", "{\n    long result = 0;\n    for (long\
    \ i = 0; i < string.length; i++) \n    {\n        if (string[i .. i + substring.length]\
    \ == substring) \n        {\n            result++;\n        }\n    }\n    return\
    \ result;\n}", "    pure \n{\n    long ret = 0;\n    size_t pos = 0;\n    while\
    \ ((pos = string.find(substring, pos)) != string.npos) \n    {\n        ret++;\n\
    \        pos += 2;\n    }\n    return ret;\n}", "{\n    long count = 0;\n    if\
    \ (empty(substring)) \n    {\n        return count;\n    }\n    else \n    {\n\
    \        for (long i = 0; i < len(string); i++) \n        {\n            for (long\
    \ j = 0; j < len(substring); j++) \n            {\n                if (string[i\
    \ + j] != substring[j]) \n                {\n                    break;\n    \
    \            }\n                if (j == len(substring) - 1) \n              \
    \  {\n                    count++;\n                }\n            }\n       \
    \ }\n        return count;\n    }\n}", "in \n{\n    assert(string.length >= substring.length);\n\
    }\nbody \n{\n    long count = 0L;\n    auto stringRange = string.byChunks(substring.length);\n\
    \    foreach (i, chunk; stringRange)\n    {\n        if (chunk == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    if (substring.length == 0)\n        return 0;\n    if (string.length == 0)\n\
    \        return 0;\n    if (string.length < substring.length)\n        return\
    \ 0;\n    long counter = 0;\n    if (string.find(substring, 0) != -1)\n      \
    \  counter++;\n    for (long i = 0; i < string.length; i++)\n    {\n        long\
    \ index = string.find(substring, i);\n        if (index == -1)\n            break;\n\
    \        else\n        {\n            counter++;\n            i = index;\n   \
    \     }\n    }\n    return counter;\n}", "{\n    static assert(substring.length\
    \ <= string.length);\n    long count = 0;\n    auto string_it = string.front;\n\
    \    while ((string_it = find(string_it, string.back, substring.front)) != string.back)\n\
    \    {\n        auto substring_it = substring.front;\n        while (substring_it\
    \ != substring.back && string_it != string.back && *substring_it == *string_it)\n\
    \        {\n            ++substring_it;\n            ++string_it;\n        }\n\
    \        if (substring_it == substring.back)\n        {\n            ++count;\n\
    \        }\n    }\n    return count;\n}\n \n/*\n    >>> flatten_tuple((1,), (2,),\
    \ (3,))\n    (1, 2, 3)\n    >>> flatten_tuple((1,), (2,), ())\n    (1, 2)\n  \
    \  >>> flatten_tuple((), (2,), (3,))\n    (2, 3)\n    >>> flatten_tuple((1, (2,),\
    \ (3,)),)\n    (1, 2, 3)\n    >>> flatten_tuple(((1,), (2,), (3,)),)\n    (1,\
    \ 2, 3)\n    >>> flatten_tuple(((1, 2),), ((3, 4),))\n    ((1, 2), (3, 4))\n \
    \   >>> flatten_tuple(((1, 2),), ((3, 4),), ((5, 6),))\n    ((1, 2), (3, 4), (5,\
    \ 6))\n    >>> flatten_tuple(((1,), (2,), (3,)), ((4,), (5,), (6,)))\n    (1,\
    \ 2, 3, 4, 5, 6)\n*/\nauto flatten_tuple(auto args...)\n{\n    auto result = tuple();\n\
    \    foreach (arg; args)\n    {\n        result ~= arg;\n    }\n    return result;\n\
    }", "{\n\tlong count = 0;\n\tlong index = 0;\n\tlong length = string.length;\n\
    \t\n\twhile (index < length)\n\t{\n\t\tif (string[index .. $] == substring)\n\t\
    \t{\n\t\t\tcount++;\n\t\t\tindex += substring.length;\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t\tindex++;\n\t\t}\n\t}\n\t\n\treturn count;\n}\n/*\n Determine if a string\
    \ starts with another string.\n    >>> is_starts_with(\"Hello, world!\", \"Hello\"\
    )\n    true\n    >>> is_starts_with(\"Hello, world!\", \"Hello,\")\n    true\n\
    \    >>> is_starts_with(\"Hello, world!\", \".\")\n    false\n    >>> is_starts_with(\"\
    Hello, world!\", \"\")\n    true\n*/", "{\n  long counter = 0;\n  long index =\
    \ 0;\n  int len = length(substring);\n  //1. Find the index for the given substring\n\
    \  //2. When the index is not -1, increase the counter and get the index from\
    \ the next index of the found index\n  //3. Repeat.\n  while(true)\n  {\n    index\
    \ = indexOf(string, substring, index);\n    if(index == -1)\n      break;\n  \
    \  counter++;\n    index += len;\n  }\n  return counter;\n}", "{\n    return count(string.countUntil(substring));\n\
    }\n```", "{\n    long count = 0;\n    while(search(string, substring))\n    {\n\
    \        count += 1;\n        string = string[substring.length .. $];\n    }\n\
    \    return count;\n}", "{\n    if (string.empty || substring.empty) \n    {\n\
    \        return 0L;\n    }\n    long result = 0L;\n    long i = 0L;\n    long\
    \ slen = string.length;\n    long sublen = substring.length;\n    while (i < slen)\
    \ \n    {\n        if (string[i..$] == substring) \n        {\n            result\
    \ += 1L;\n            i += sublen;\n        }\n        else \n        {\n    \
    \        i += 1L;\n        }\n    }\n    return result;\n}\n/*\n Find the position\
    \ of the first occurrence of a substring in a string.\n    >>> find_index(\"abcdefg\"\
    , \"cd\")\n    2L\n    >>> find_index(\"abcdefg\", \"cde\")\n    2L\n    >>> find_index(\"\
    abcdefg\", \"c\")\n    2L\n    >>> find_index(\"abcdefg\", \"d\")\n    3L\n  \
    \  >>> find_index(\"abcdefg\", \"fg\")\n    5L\n    >>> find_index(\"abcdefg\"\
    , \"a\")\n    0L\n    >>> find_index(\"abcdefg\", \"\")\n    0L\n    >>> find_index(\"\
    abcdefg\", \"g\")\n    6L\n    >>> find_index(\"abcdefg\", \"h\")\n    -1L\n*/\n\
    long find_index(string string, string substring) \n{\n    if (string.empty ||\
    \ substring.empty) \n    {\n        return 0L;\n    }\n    long i = 0L;\n    long\
    \ slen = string.length;\n    long sublen = substring.length;\n    while (i < slen)\
    \ \n    {\n        if (string[i..$] == substring) \n        {\n            return\
    \ i;\n        }\n        else \n        {\n            i += 1L;\n        }\n \
    \   }\n    return -1L;\n}\n/*\n Returns a slice of the given string starting after\
    \ the first occurrence of the given pattern.\n    >>> skip_prefix(\"abcdefg\"\
    , \"cd\")\n    \"efg\"\n    >>> skip_prefix(\"abcdefg", "{\n    long len = string.length;\n\
    \    long sublen = substring.length;\n    long i = 0;\n    long count = 0;\n \
    \   while (i + sublen <= len)\n    {\n        if (substring == string[i..sublen])\n\
    \        {\n            count++;\n        }\n        i++;\n    }\n    return count;\n\
    }", "{\n    auto n = 0L;\n    auto ind = -1L;\n    while ((ind = string.find(substring,\
    \ ind + 1)) != -1L) \n    {\n        n++;\n    }\n    return n;\n}", "{\n    long\
    \ occurrences = 0;\n    size_t found_at = 0;\n    size_t next_pos = 0;\n    foreach(string;\
    \ find(string, substring, next_pos))\n    {\n        occurrences++;\n        found_at\
    \ = next_pos;\n        next_pos = found_at + 1;\n    }\n    return occurrences;\n\
    }", "{\n  long count = 0;\n  foreach(int start, string str; find(string, substring))\n\
    \  {\n    count++;\n  }\n  return count;\n}", "in{\n    assert(string.length >=\
    \ substring.length);\n}\nout(result) {\n    assert(result <= (string.length -\
    \ substring.length + 1));\n}\n{\n    if (substring.length == 0) {\n        return\
    \ 0;\n    }\n    long result = 0;\n    foreach (index; 0 .. string.length - substring.length\
    \ + 1) {\n        if (string[index .. index + substring.length] == substring)\
    \ {\n            result++;\n        }\n    }\n    return result;\n}\n/*\n Find\
    \ the longest palindrome in a given string.\n    >>> longest_palindrome(\"a\"\
    )\n    \"a\"\n    >>> longest_palindrome(\"aba\")\n    \"aba\"\n    >>> longest_palindrome(\"\
    aa\")\n    \"aa\"\n    >>> longest_palindrome(\"baa\")\n    \"aa\"\n    >>> longest_palindrome(\"\
    aab\")\n    \"aa\"\n    >>> longest_palindrome(\"baabcd\")\n    \"baab\"\n   \
    \ >>> longest_palindrome(\"baablkj12345432133d\")\n    \"123454321\"\n*/\nstring\
    \ longest_palindrome(string string) \nin{\n    assert(string.length > 0);\n}\n\
    out(result) {\n    assert(result.length <= string.length);\n}\n{\n    // Note:\
    \ string[i .. j] will return \"\" if i > j.\n    foreach (start; 0 .. string.length)\
    \ {\n        foreach (end; start .. string.length) {\n            string substring\
    \ = string[start .. end];\n            if (is_palindrome(substring)) {\n     \
    \           return substring;\n            }\n        }\n    }\n    // empty string\n\
    \    return \"\";\n}", "{\n    long counter = 0;\n    int max_index = string.length\
    \ - substring.length;\n    for (int i = 0; i <= max_index; i++) \n    {\n    \
    \    if (string[i .. i + substring.length] == substring) \n        {\n       \
    \     counter++;\n        }\n    }\n    return counter;\n}", "{\n    long ret\
    \ = 0;\n    foreach(i; 0 .. string.length - substring.length + 1) \n    {\n  \
    \      if(string[i .. i + substring.length - 1] == substring)\n            ret++;\n\
    \    }\n    return ret;\n}\n/*\n Test how many times all substrings can be found\
    \ in a given string.\n    >>> test_how_many_times_all_substrings(\"aaaa\")\n \
    \   true\n*/", "{\n    long pos = 0L;\n    long count = 0L;\n    while ((pos =\
    \ string.find(substring, pos)) != string.npos) {\n        count++;\n        pos\
    \ += substring.length();\n    }\n    return count;\n}", "{\n\tint counter = 0;\n\
    \tint index = 0;\n\t\n\twhile (true)\n\t{\n\t\tindex = string.find(substring,\
    \ index);\n\t\tif (index != -1)\n\t\t{\n\t\t\tcounter++;\n\t\t\tindex += substring.length;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn counter;\n}", "{\n\
    \    long result = 0;\n    size_t start = 0;\n    size_t length = substring.length;\n\
    \    while ((start = string.find(substring, start)) != string.npos) {\n      \
    \  ++result;\n        start += length;\n    }\n    return result;\n}\n/*\n   \
    \ >>> k_th_occurrence_of_char_in_string('a', 2, \"aaaa\")\n    1L\n    >>> k_th_occurrence_of_char_in_string('a',\
    \ 1, \"aaaa\")\n    0L\n    >>> k_th_occurrence_of_char_in_string('a', 4, \"aaaa\"\
    )\n    3L\n    >>> k_th_occurrence_of_char_in_string('a', 1, \"aaba\")\n    0L\n\
    \    >>> k_th_occurrence_of_char_in_string('a', 2, \"aaba\")\n    2L\n    >>>\
    \ k_th_occurrence_of_char_in_string('b', 1, \"aaba\")\n    3L\n    >>> k_th_occurrence_of_char_in_string('a',\
    \ 1, \"cbabac\")\n    3L\n    >>> k_th_occurrence_of_char_in_string('a', 2, \"\
    cbabac\")\n    5L\n*/\nlong k_th_occurrence_of_char_in_string(in char c, in long\
    \ k, in string string) \n{\n    size_t start = 0;\n    size_t length = 1;\n  \
    \  for (long i = 0; i < k; ++i) {\n        start = string.find(c, start + length);\n\
    \        if (start == string.npos) {\n            return -1;\n        }\n    }\n\
    \    return start;\n}\n/*\n    >>> words_from_string(\"a string\")\n    [\"a\"\
    , \"string\"]\n    >>> words_from_string(\"a string with   spaces\")\n    [\"\
    a\", \"string\", \"with\", \"spaces\"]\n    >>> words_from_string(\"   a   string\
    \   with   spaces   \")\n    [\"a\", \"string\", \"with\", \"", "{\n\tlong ret\
    \ = 0;\n\tlong j = 0;\n\tfor (long i = 0; i < string.length; ++i)\n\t{\n\t\tif\
    \ (string[i] == substring[j])\n\t\t{\n\t\t\t++j;\n\t\t\tif (j == substring.length)\n\
    \t\t\t{\n\t\t\t\t++ret;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\
    \tj = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n/*\n    >>> decode_morse(\".... . -.--\
    \   .--- ..- -.. .\")\n    \"HEY JUDE\"\n    >>> decode_morse(\"...---...\")\n\
    \    \"SOS\"\n    >>> decode_morse(\"   .   . \")\n    \"E E\"\n    >>> decode_morse(\"\
    -.-.--\")\n    \"!@\"\n*/\nstring decode_morse(string encoded)\n{\n\timport std.algorithm;\n\
    \timport std.array;\n\timport std.range;\n\timport std.typecons;\n\timport std.typecons;\n\
    \timport std.stdio;\n\timport std.conv;\n\t\n\tstring[] morse_alphabet = [\n\t\
    \t\"-----\", \".----\", \"..---\", \"...--\", \"....-\", \".....\",\n\t\t\"-....\"\
    , \"--...\", \"---..\", \"----.\", \".-.-.-\", \"--..--\", \"..--..\",\n\t\t\"\
    .-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\"\
    ,\n\t\t\".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\"\
    , \".-.\",\n\t\t\"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\"\
    , \"--..\", \"|\"\n\t];\n\t\n\tstring[] morse_alphabet_letters = [\n\t\t\"A\"\
    , \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\"\
    , \"M", "{\n    long count = 0;\n    size_t start = 0;\n    size_t end = string.find_first_of(substring);\n\
    \    while (end != -1)\n    {\n        count++;\n        start = end + 1;\n  \
    \      end = string.find_first_of(substring, start);\n    }\n    return count;\n\
    }", "in {\n    assert(!string.empty);\n    assert(!substring.empty);\n}\nout (result)\
    \ {\n    assert(result >= 0);\n}\nbody {\n    long count = 0;\n    for (size_t\
    \ i = 0; i <= string.length - substring.length; i++) {\n        if (string[i ..\
    \ i + substring.length] == substring) {\n            count++;\n        }\n   \
    \ }\n    return count;\n}", "{\n\tlong count = 0;\n\tfor (auto i = 0; i <= string.length\
    \ - substring.length; ++i)\n\t{\n\t\tauto string_piece = string[i .. i + substring.length];\n\
    \t\tif (string_piece == substring)\n\t\t{\n\t\t\t++count;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n    long count = 0;\n    long pos = 0;\n    while ((pos = string.find(substring,\
    \ pos)) != -1) \n    {\n        count++;\n        pos++;\n    }\n    return count;\n\
    }", "nothrow @safe pure \n{\n    static assert(isInputRange!string);\n    static\
    \ assert(isInputRange!substring);\n    if(substring.length < 1) return 0;\n  \
    \  long counter = 0;\n    size_t start = 0;\n    size_t found;\n    while ((found\
    \ = string.findAt(substring, start)) != string.length)\n    {\n        counter++;\n\
    \        start = found + 1;\n    }\n    return counter;\n}", "{\n    long result\
    \ = 0;\n    foreach(immutable i; 0 .. string.length - substring.length + 1) \n\
    \    {\n        auto n = string.canFind(substring, i);\n        if(n) \n     \
    \   {\n            result++;\n        }\n    }\n    return result;\n}\n/*\n Find\
    \ the length of a given string without using built-in string functions.\n    >>>\
    \ length(\"\")\n    0L\n    >>> length(\"abcd\")\n    4L\n    >>> length(\"CamelCase\"\
    )\n    9L\n*/\nlong length(string s) \n{\n    long result = 0;\n    foreach(immutable\
    \ ch; s) \n    {\n        result++;\n    }\n    return result;\n}\n/*\n Find the\
    \ longest common prefix string amongst an array of strings.\n    >>> longest_common_prefix([\"\
    ab\", \"abc\", \"abcd\"])\n    \"ab\"\n    >>> longest_common_prefix([\"a\", \"\
    a\", \"ab\"])\n    \"a\"\n    >>> longest_common_prefix([\"a\", \"a\", \"b\"])\n\
    \    \"\"\n*/\nstring longest_common_prefix(string[] strings) \n{\n    if(strings.length\
    \ == 0) \n    {\n        return \"\";\n    }\n    immutable min_length = min(strings.map!(s\
    \ => s.length));\n    auto result = \"\";\n    foreach(immutable i; 0 .. min_length)\
    \ \n    {\n        if(all!(s => s[i] == strings[0][i])(strings)) \n        {\n\
    \            result ~= strings[0][i];\n        }\n        else \n        {\n \
    \           break;\n        }\n    }\n    return result;\n}\n/*\n Given an array\
    \ of strings, group anagrams together.\n    >>> group_anagrams([\"eat\", \"tea\"\
    , \"tan\", \"ate\", \"nat\", \"bat\"])\n    [[\"eat\", \"tea\", \"ate\"], [\"\
    tan\", \"nat\"], [\"bat\"]]\n*/\nstring[][] group_anagrams(string[] strs) \n{\n\
    \    auto dict = []string[][string", "{\n    /*\n    if (len(substring) == 0)\n\
    \    {\n        return 1;\n    }\n    long count = 0;\n    long position = 0;\n\
    \    while(position + len(substring) <= len(string))\n    {\n        if (string[position..]\
    \ == substring)\n        {\n            count++;\n            position += len(substring);\n\
    \        }\n        else\n        {\n            position++;\n        }\n    }\n\
    \    return count;\n    */\n    if (substring.length == 0)\n    {\n        return\
    \ 1;\n    }\n    long count = 0;\n    long position = 0;\n    while(position +\
    \ substring.length <= string.length)\n    {\n        if (string.substr(position,substring.length)\
    \ == substring)\n        {\n            count++;\n            position += substring.length;\n\
    \        }\n        else\n        {\n            position++;\n        }\n    }\n\
    \    return count;\n}\n/*\n>>> odd_even_number_of_steps(4, 4, (1, 2))\n\"D\"\n\
    >>> odd_even_number_of_steps(3, 4, (1, 2))\n\"DR\"\n>>> odd_even_number_of_steps(4,\
    \ 4, (1, 2, 3))\n\"DRD\"\n>>> odd_even_number_of_steps(2, 2, (1, 2))\n\"DR\"\n\
    >>> odd_even_number_of_steps(6, 6, (1, 2, 3))\n\"DRUDL\"\n>>> odd_even_number_of_steps(5,\
    \ 5, (1, 2, 3))\n\"DRUDL\"\n*/\nstring odd_even_number_of_steps(long n, long m,\
    \ inout dlong[] coordinates)\n{\n    //long n = n;\n    //long m = m;\n    //dlong[]\
    \ coordinates = coordinates;\n    // D : 1,0\n    // R : 0,1\n    // U : -1,0\n\
    \    // L : 0,-1\n    //string result = \"\";\n    dlong target = dlong(n-1,m-1);\n\
    \    string", "{\n    return distance(\n                find(string, substring),\n\
    \                find(string, substring).length == substring.length ?\n      \
    \                  string.length : string.length + 1);\n}", "{\n\tlong result\
    \ = 0;\n\tlong pos = 0;\n\t\n\t// \"\u0418\u0433\u043D\u043E\u0440\u0438\u0440\
    \u0443\u0435\u043C \u043F\u0443\u0441\u0442\u044B\u0435 \u0441\u0442\u0440\u043E\
    \u043A\u0438\n\tif (substring.length == 0 || string.length == 0) return 0;\n\t\
    \n\twhile(string.find(substring, pos) != -1)\n\t{\n\t\tresult++;\n\t\t// \u0421\
    \u043C\u0435\u0449\u0430\u0435\u043C\u0441\u044F \u043D\u0430 \u0434\u043B\u0438\
    \u043D\u0443 \u043F\u043E\u0434\u0441\u0442\u0440\u043E\u043A\u0438 \u0441\u043E\
    \ \u0441\u0434\u0432\u0438\u0433\u043E\u043C \u043D\u0430 \u043E\u0434\u0438\u043D\
    \ \u0441\u0438\u043C\u0432\u043E\u043B\n\t\tpos = string.find(substring, pos)\
    \ + substring.length;\n\t}\n\t\n\treturn result;\n}", "{\n    if(substring.length\
    \ > string.length) \n        return 0L;\n    else \n    {\n        long times\
    \ = 0L;\n        for(int i = 0; i < string.length - substring.length + 1; i++)\
    \ \n        {\n            string substr = string[i..i + substring.length];\n\
    \            if(substr == substring) \n                times++;\n        }\n \
    \       return times;\n    }\n}", "{\n\tlong count = 0;\n\tauto pos = 0;\n\twhile\
    \ (true)\n\t{\n\t\tpos = string.find(substring, pos);\n\t\tif (pos == string.npos)\
    \ break;\n\t\tcount++;\n\t\tpos++;\n\t}\n\treturn count;\n}\n/*\n    >>> generate_pattern(\"\
    a\")\n    [['a']]\n    >>> generate_pattern(\"ab\")\n    [['a', 'b'], ['b', 'a']]\n\
    \    >>> generate_pattern(\"abc\")\n    [['a', 'b', 'c'], ['a', 'c', 'b'], ['b',\
    \ 'a', 'c'], ['b', 'c', 'a'], ['c', 'a', 'b'], ['c', 'b', 'a']]\n    >>> generate_pattern(\"\
    abcd\")\n    [['a', 'b', 'c', 'd'], ['a', 'b', 'd', 'c'], ['a', 'c', 'b', 'd'],\
    \ ['a', 'c', 'd', 'b'], ['a', 'd', 'b', 'c'], ['a', 'd', 'c', 'b'], ['b', 'a',\
    \ 'c', 'd'], ['b', 'a', 'd', 'c'], ['b', 'c', 'a', 'd'], ['b', 'c', 'd', 'a'],\
    \ ['b', 'd', 'a', 'c'], ['b', 'd', 'c', 'a'], ['c', 'a', 'b', 'd'], ['c', 'a',\
    \ 'd', 'b'], ['c', 'b', 'a', 'd'], ['c', 'b', 'd', 'a'], ['c', 'd', 'a', 'b'],\
    \ ['c', 'd', 'b', 'a'], ['d', 'a', 'b', 'c'], ['d', 'a', 'c', 'b'], ['d', 'b',\
    \ 'a', 'c'], ['d', 'b', 'c', 'a'], ['d', 'c', 'a', 'b'], ['d', 'c', 'b', 'a",
  "{\n    long count;\n    long position;\n    position = string.find(substring);\n\
    \    count = 0;\n    while (position != -1) \n    {\n        ++count;\n      \
    \  position = string.find(substring, position + 1);\n    }\n    return count;\n\
    }", "{\n\t//return string.count(substring);\n\tlong count = 0;\n\tlong index =\
    \ 0;\n\twhile(index < string.length)\n\t{\n\t\tindex = string.find(substring,\
    \ index);\n\t\tif(index == -1) break;\n\t\tindex += substring.length;\n\t\tcount++;\n\
    \t}\n\treturn count;\n}", "{\n  long result = 0;\n  size_t index = 0;\n  //get\
    \ first occurence of the substring\n  auto firstOccurence = string.find(substring);\n\
    \  //check if the substring exists\n  if (firstOccurence != string.npos) \n  {\n\
    \    result++;\n    index = firstOccurence + 1;\n    //while next occurence of\
    \ the substring is found increment result and move the index\n    while ((firstOccurence\
    \ = string.find(substring, index)) != string.npos) \n    {\n      result++;\n\
    \      index = firstOccurence + 1;\n    }\n  }\n  return result;\n}", "{\n   \
    \ long count = 0;\n    while(true)\n    {\n        auto m = indexOf(string, substring);\n\
    \        if(m == -1)\n            break;\n        count++;\n        string = string[$\
    \ + m + 1 .. $];\n    }\n    return count;\n}", "{\n    long times = 0;\n    foreach(immutable(index),\
    \ immutable(value); string)\n    {\n        if(value == substring[0])\n      \
    \  {\n            immutable found_index = index;\n            foreach(immutable(index2),\
    \ immutable(value2); substring)\n            {\n                if(value2 != string[found_index])\n\
    \                {\n                    break;\n                }\n          \
    \      else\n                {\n                    found_index++;\n         \
    \       }\n                if(index2 == substring.length - 1)\n              \
    \  {\n                    times++;\n                }\n            }\n       \
    \ }\n    }\n    return times;\n}", "{\n    long counter = 0;\n    long pos = 0;\n\
    \    while(true)\n    {\n        pos = string.find(substring, pos);\n        if(pos\
    \ == -1)\n            break;\n        counter++;\n        pos++;\n    }\n    return\
    \ counter;\n}", "{\n    // Version 1\n    /*\n    long count = 0;\n    long index;\n\
    \    if (substring.length == 0)\n        return 0;\n    if (string.length < substring.length)\n\
    \        return 0;\n    while (index != -1)\n    {\n        index = string.find(substring);\n\
    \        if (index != -1)\n        {\n            string = string[index + substring.length\
    \ .. $];\n            count++;\n        }\n    }\n    return count;\n    */\n\
    \    // Version 2\n    long count = 0;\n    if (substring.length == 0)\n     \
    \   return 0;\n    if (string.length < substring.length)\n        return 0;\n\
    \    for (long i = 0; i < string.length - substring.length + 1; i++)\n    {\n\
    \        if (string[i .. i + substring.length] == substring)\n            count++;\n\
    \    }\n    return count;\n}\n/*\n    >>> capitalise_letter(\"a\")\n    'A'\n\
    \    >>> capitalise_letter(\"aB\")\n    'Ab'\n    >>> capitalise_letter(\"abc\"\
    )\n    'Abc'\n*/\nchar capitalise_letter(string string)\n{\n    return toUpper(string[0])\
    \ ~ string[1 .. $];\n}\n/*\n    >>> capitalise_first_letter(\"a\")\n    'A'\n\
    \    >>> capitalise_first_letter(\"aB\")\n    'AB'\n    >>> capitalise_first_letter(\"\
    abc\")\n    'Abc'\n*/\nstring capitalise_first_letter(string string)\n{\n    return\
    \ toUpper(string[0]) ~ string[1 .. $];\n}\n/*\n    >>> capitalise_first_letter_of_each_word(\"\
    a\")\n    'A'\n    >>> capitalise_first_letter_of_each_word(\"a b\")\n    'A B'\n\
    \    >>> capitalise_first_letter_of_each_word(\"a b c\")\n    'A B C'\n    >>>\
    \ capitalise_first_letter_of_each_word(\"a  b  c\")\n    'A  B  C'", "{\n    long\
    \ counter = 0;\n    long s = string.length;\n    long t = substring.length;\n\
    \    if (s == 0) return 0;\n    else if (t == 0) return 0;\n    else if (t > s)\
    \ return 0;\n    for (auto i = 0; i <= s - t; i++) \n    {\n        if (string[i\
    \ .. i + t] == substring) counter++;\n    }\n    return counter;\n}\n/*\n Take\
    \ a string and swap the case of each letter.\n    >>> swap_case(\"Hello World\"\
    )\n    \"hELLO wORLD\"\n*/\nstring swap_case(string input) \n{\n    string s =\
    \ \"\";\n    for (auto c : input) \n    {\n        if (c.isUpperCase) s ~= c.toLower;\n\
    \        else if (c.isLowerCase) s ~= c.toUpper;\n        else s ~= c;\n    }\n\
    \    return s;\n}\n/*\n Take a string and return the case folded string (all lowercase).\n\
    \    >>> casefold(\"Hello World\")\n    \"hello world\"\n*/\nstring casefold(string\
    \ input) \n{\n    string s = \"\";\n    for (auto c : input) s ~= c.toLower;\n\
    \    return s;\n}\n/*\n Take a string and return the string where each character\
    \ is repeated once.\n    >>> repeat_chars(\"Hello World\")\n    \"HHeelllloo \
    \ WWoorrlldd\"\n*/\nstring repeat_chars(string input) \n{\n    string s = \"\"\
    ;\n    for (auto c : input) s ~= c ~ c;\n    return s;\n}\n/*\n Take a string\
    \ and return the string in reverse order.\n    >>> reverse(\"Hello World\")\n\
    \    \"dlroW olleH\"\n*/\nstring reverse(string input) \n{\n    return input.dup.reverse;\n\
    }\n/*\n Take a string and return the string with every word reversed in place.\n\
    \    >>> reverse_words(\"Hello World\")\n    \"olleH dlroW\"\n*/\nstring reverse_words(string\
    \ input) \n{\n    string", "{\n    int counter = 0;\n    int size_of_substring\
    \ = substring.length;\n    int size_of_string = string.length;\n    int iterator\
    \ = 0;\n    while(iterator < size_of_string) \n    {\n        if(string[iterator..iterator+size_of_substring]\
    \ == substring)\n        {\n            counter += 1;\n            iterator +=\
    \ size_of_substring;\n        }\n        else\n        {\n            iterator\
    \ += 1;\n        }\n    }\n    return counter;\n}\n/*\n Given a list of numbers\
    \ and a positive integer k, reverse the elements of the list, k items at a time.\
    \ If the number of elements is not a multiple of k, then the remaining items in\
    \ the end should be left as is.\n    >>> reverse(typeof([]), 0)\n    []\n    >>>\
    \ reverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10]\n    >>> reverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n    [3, 2, 1, 6, 5,\
    \ 4, 9, 8, 7, 10]\n    >>> reverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5)\n    [5,\
    \ 4, 3, 2, 1, 10, 9, 8, 7, 6]\n    \n*/\nauto reverse(A)(A list, size_t k) if\
    \ (isArray!A)\n{\n    bool reveresed = false;\n    size_t length = list.length;\n\
    \    size_t j = 0;\n    if(k == 0)\n    {\n        return list;\n    }\n    for(size_t\
    \ i = 0; i < length/k; i++)\n    {\n        if(!reveresed)\n        {\n      \
    \      list[i..j+k] = list[j..k].reversed;\n            j += k;\n            reveresed\
    \ = true;\n        }\n        else\n        {\n            list[i..j+k] = list[",
  "{\n    long count = 0;\n    auto search_pos = string.find(substring);\n    while\
    \ (search_pos != string.npos)\n    {\n        ++count;\n        search_pos = string.find(substring,\
    \ search_pos + 1);\n    }\n    return count;\n}", "{\n    size_t current_pos =\
    \ 0L;\n    size_t found_count = 0L;\n    while (true) \n    {\n        auto found_at\
    \ = string.find(substring, current_pos);\n        if (found_at == string.npos)\
    \ \n        {\n            break;\n        }\n        found_count += 1L;\n   \
    \     current_pos = found_at + 1L;\n    }\n    return found_count;\n}\n/*\n  >>>\
    \ remove_shorter_substrings(\"test\", 1)\n  'test'\n  >>> remove_shorter_substrings(\"\
    test\", 2)\n  'est'\n  >>> remove_shorter_substrings(\"test\", 3)\n  'st'\n  >>>\
    \ remove_shorter_substrings(\"test\", 4)\n  ''\n  >>> remove_shorter_substrings(\"\
    test\", 5)\n  ''\n*/\nstring remove_shorter_substrings(string string, size_t min_length)\
    \ \n{\n    string result = \"\";\n    for (; min_length > 0L; min_length -= 1L)\
    \ \n    {\n        auto substring = string.substr(min_length - 1L, string.length\
    \ - min_length + 1L);\n        result += substring;\n    }\n    return result;\n\
    }\n/*\n    >>> remove_shorter_substrings_naive(\"test\", 1)\n    'test'\n    >>>\
    \ remove_shorter_substrings_naive(\"test\", 2)\n    'est'\n    >>> remove_shorter_substrings_naive(\"\
    test\", 3)\n    'st'\n    >>> remove_shorter_substrings_naive(\"test\", 4)\n \
    \   ''\n    >>> remove_shorter_substrings_naive(\"test\", 5)\n    ''\n*/\nstring\
    \ remove_shorter_substrings_naive(string string, size_t min_length) \n{\n    string\
    \ result = \"\";\n    for (size_t i = 0L; i < string.length; i += 1L) \n    {\n\
    \        for (size_t j = min_length; j <= string.length - i; j += 1L)", "{\n \
    \   return ctPopCnt(string.find(substring));\n}\n// Compile with -version=ctPopCnt",
  "{\n\tint n = 0;\n\tint p = 0;\n\tint n_substring = substring.length;\n\tint n_string\
    \ = string.length;\n\tint j = 0;\n\tif (n_substring == 0)\n\t\treturn 0;\n\twhile\
    \ (j < n_string)\n\t{\n\t\tint i = 0;\n\t\twhile (i < n_substring && j + i < n_string\
    \ && string[j + i] == substring[i])\n\t\t\ti++;\n\t\tif (i == n_substring)\n\t\
    \t{\n\t\t\tn++;\n\t\t\tj += n_substring;\n\t\t}\n\t\telse\n\t\t\tj++;\n\t}\n\t\
    return n;\n}", "{\n    long count = 0;\n    auto index = 0;\n    auto size_string\
    \ = string.length;\n    auto size_substring = substring.length;\n    auto temp\
    \ = 0;\n    foreach(i; 0..string.length)\n    {\n        if(string[i..i+1] ==\
    \ substring[0..1])\n        {\n            temp = i;\n            foreach(j; 0..substring.length)\n\
    \            {\n                if(string[temp] == substring[j])\n           \
    \     {\n                    index++;\n                    temp++;\n         \
    \       }\n                else\n                {\n                    index\
    \ = 0;\n                    break;\n                }\n            }\n       \
    \     if(index == substring.length)\n            {\n                count++;\n\
    \                index = 0;\n            }\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    string s = string;\n    while (s.length > 0)\
    \ \n    {\n        if (s.length >= substring.length) \n        {\n           \
    \ if (s.startsWith(substring)) \n            {\n                count++;\n   \
    \             s = s[substring.length..$];\n            } \n            else \n\
    \            {\n                s = s[1..$];\n            }\n        } \n    \
    \    else \n        {\n            break;\n        }\n    }\n    return count;\n\
    }", "{\n    long occurrence = 0;\n    long size = string.length;\n    long size_sub\
    \ = substring.length;\n    for (long i = 0; i < size - size_sub + 1; i++)\n  \
    \  {\n        if (string[i..i + size_sub] == substring)\n        {\n         \
    \   occurrence++;\n        }\n    }\n    return occurrence;\n}", "{\n    long\
    \ n = string.length;\n    long m = substring.length;\n    long result = 0;\n \
    \   foreach (int i, char letter; string)\n    {\n        result += (letter ==\
    \ substring[0]) ? \n            (m <= n - i) ?\n                std.algorithm.count(string[i..n-m+1],\
    \ substring)\n            : \n                0\n        :\n            0;\n \
    \   }\n    return result;\n}\n/*\n    >>> how_many_times_overlapping(\"\", \"\
    a\")\n    0L\n    >>> how_many_times_overlapping(\"aaa\", \"a\")\n    3L\n   \
    \ >>> how_many_times_overlapping(\"aaaa\", \"aa\")\n    4L\n*/\nlong how_many_times_overlapping(string\
    \ string, string substring) \n{\n    long n = string.length;\n    long m = substring.length;\n\
    \    long result = 0;\n    foreach (int i, char letter; string)\n    {\n     \
    \   result += (letter == substring[0]) ? \n            (m <= n - i) ?\n      \
    \          std.algorithm.count(string[i..n], substring)\n            : \n    \
    \            0\n        :\n            0;\n    }\n    return result;\n}", "{\n\
    \    long occur_times = 0;\n    for (long i = 0; i < string.length - substring.length\
    \ + 1; i++)\n    {\n        if (string[i .. i + substring.length] == substring)\n\
    \        {\n            occur_times++;\n        }\n    }\n    return occur_times;\n\
    }", "{\n    long occurences;\n    // Erase all occurences of \"substring\" from\
    \ \"string\" until no more occurences\n    // are found. Keep count of how many\
    \ times this was done.\n    while ((occurences = in(substring, string)) != 0)\
    \ \n    {\n        string = erase(string, substring);\n    }\n    return string.length\
    \ - substring.length + 1;\n}\n//Funktion die alle IDs aus einem String extrahiert\
    \ und in ein Tupel packt.\n//Das Tupel enth\xE4lt als erstes Element die Anzahl\
    \ der vorkommenden IDS\nauto getIDs(string id_string)\n{\n\tuint anzahl = how_many_times(id_string,\
    \ \",\");\n\ttuple!(uint, uint[]) result;\n\tresult[0] = anzahl;\n\tstring tmp;\n\
    \tif(anzahl == 0)\n\t{\n\t\tresult[1] = tuple(1, [to!uint(id_string)]);\n\t}\n\
    \telse\n\t{\n\t\tresult[1] = tuple(anzahl+1, [0]*(anzahl+1));\n\t\tuint j = 0;\n\
    \t\tfor(uint i = 0; i < id_string.length; i++)\n\t\t{\n\t\t\tif(id_string[i] !=\
    \ ',')\n\t\t\t{\n\t\t\t\ttmp ~= id_string[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\
    \t\t\tresult[1][j] = to!uint(tmp);\n\t\t\t\ttmp = \"\";\n\t\t\t\tj++;\n\t\t\t\
    }\n\t\t}\n\t\tresult[1][j] = to!uint(tmp);\n\t}\n\treturn result;\n}", "{\n  \
    \  size_t last_pos = 0;\n    long count = 0;\n    while (true) {\n        auto\
    \ pos = string.find(substring, last_pos);\n        if (pos == string.npos) {\n\
    \            break;\n        }\n        ++count;\n        last_pos = pos + 1;\n\
    \    }\n    return count;\n}", "{\n    long i = 0;\n    long j = 0;\n    long\
    \ times = 0;\n    while(i<string.length)\n    {\n        if(string[i] == substring[j])\n\
    \        {\n            j++;\n            if(j == substring.length)\n        \
    \    {\n                times++;\n                j = 0;\n            }\n    \
    \    }\n        else\n        {\n            i = i - j;\n            j = 0;\n\
    \        }\n        i++;\n    }\n    return times;\n}", "{\n    long result =\
    \ 0;\n    auto end = string.length - substring.length;\n    for (long i = 0; i\
    \ <= end; i++)\n    {\n        auto slice = string[i .. i + substring.length];\n\
    \        if (slice == substring)\n        {\n            result++;\n        }\n\
    \    }\n    return result;\n}\n \n/*\nPairs:\nWrite a program that reads a string\
    \ and a word. The program should output the count of pairs that have the given\
    \ word as a value.\n    >>> count_pairs(\"a b c b\", \"b\")\n    2L\n*/\nlong\
    \ count_pairs(string input, string word)\n{\n    auto list = input.split;\n  \
    \  return list.count(&(x){x == word});\n}\n \n/*\nReverse a string using slice\
    \ assignment.\n    >>> reverse(\"\")\n    \"\"\n    >>> reverse(\"a\")\n    \"\
    a\"\n    >>> reverse(\"ab\")\n    \"ba\"\n    >>> reverse(\"abc\")\n    \"cba\"\
    \n    >>> reverse(\"abcde\")\n    \"edcba\"\n*/\nstring reverse(string s)\n{\n\
    \    string result;\n    result.length = s.length;\n    auto end = s.length -\
    \ 1;\n    for (long i = 0; i < s.length; i++)\n    {\n        result[i] = s[end\
    \ - i];\n    }\n    return result;\n}\n \n/*\nReverse a string using swap function.\n\
    \    >>> reverse_with_swap(\"\")\n    \"\"\n    >>> reverse_with_swap(\"a\")\n\
    \    \"a\"\n    >>> reverse_with_swap(\"ab\")\n    \"ba\"\n    >>> reverse_with_swap(\"\
    abc\")\n    \"cba\"\n    >>> reverse_with_swap(\"abcde\")\n    \"edcba\"\n*/\n\
    string reverse_with_swap(string s)\n{\n    for (long i = 0; i < s.length / 2;\
    \ i++)\n    {\n        auto temp = s[i];\n        s[i] = s[s.length - 1 - i];\n\
    \        s[s.length -", "{\n    // string.count(substring)\n    return 42;\n}",
  "{\n    long count = 0;\n    string sub = substring.idup;\n    size_t slen = sub.length;\n\
    \    size_t sz = string.length;\n    while(string.length >= slen)\n    {\n   \
    \     size_t find = string.find(sub);\n        if(find == string.npos)\n     \
    \       break;\n        string = string[find+slen..$];\n        count += 1;\n\
    \    }\n    return count;\n}", "{\n    long result = 0;\n    foreach(ref e; match(string,\
    \ substring)) {\n        result++;\n    }\n    return result;\n}", "{\n    if\
    \ (substring.length == 0) \n    {\n        return 0;\n    }\n    long count =\
    \ 0;\n    long i = 0;\n    while (i < string.length) \n    {\n        auto p =\
    \ string.find(substring, i);\n        if (p == string.npos) \n        {\n    \
    \        break;\n        }\n        count++;\n        i = p + 1;\n    }\n    return\
    \ count;\n}", "{\n    enum string_length = string.length();\n    enum substring_length\
    \ = substring.length();\n    enum count = (string_length - substring_length +\
    \ 1);\n    long iterations = 0;\n    for (size_t i = 0; i < count; i += 1)\n \
    \   {\n        if (std.algorithm.startsWith(string[i..], substring))\n       \
    \ {\n            iterations += 1;\n        }\n    }\n    return iterations;\n}",
  "{\n    auto n = string.length;\n    auto m = substring.length;\n    if (n < m)\
    \ return 0;\n    auto l = n - m + 1;\n    return count(0, l, i => string[i ..\
    \ i + m] == substring);\n}\n/*", "{\n\tlong result = 0;\n\tforeach(index, i; findAll(string,\
    \ substring)) \n\t{\n\t\tresult += i;\n\t}\n\treturn result;\n}\n/*\n Transform\
    \ a string into a number, if possible, the other way around too.\n    >>> to_number(\"\
    5\");\n    5L\n    >>> to_number(\"-5\");\n    -5L\n    >>> to_number(\"-5.0\"\
    );\n    -5.0\n    >>> to_number(\"5.0\");\n    5.0\n    >>> to_number(\"5a\");\n\
    \    0L\n*/\nauto to_number(string string) \n{\n\tlong result;\n\tif(sscanf(string,\
    \ \"%d\", &result) == 1)\n\t{\n\t\treturn result;\n\t}\n\tdouble result_double;\n\
    \tif(sscanf(string, \"%f\", &result_double) == 1)\n\t{\n\t\treturn result_double;\n\
    \t}\n\treturn 0;\n}\nstring to_string(auto x) \n{\n\tauto s = to!string(x);\n\t\
    return s;\n}", "{\n    long result;\n    size_t pos = 0;\n    auto it = string.indexOf(substring,\
    \ pos);\n    while (it != std.string.npos) \n    {\n        pos = it + 1;\n  \
    \      it = string.indexOf(substring, pos);\n        result++;\n    }\n    return\
    \ result;\n}", "{\n    return 0;\n}", "{\n    long count = 0;\n    foreach(i;\
    \ 0 .. string.length) \n    {\n        if(string[i .. i + substring.length - 1]\
    \ == substring)\n            count++;\n    }\n    return count;\n}", "{\n    if\
    \ (substring.length == 0)\n        return 0;\n    if (string.length == 0)\n  \
    \      return 0;\n    auto result = 0;\n    // auto index = string.indexOf(substring);\n\
    \    auto index = string.find(substring);\n    if (index == -1)\n        return\
    \ 0;\n    result += 1;\n    auto partial_string = string.slice(index + 1);\n \
    \   result += how_many_times(partial_string, substring);\n    return result;\n\
    }\n/*\n Flatten an array recursively.\n    >>> flatten_recursive([[1, [2, 3]],\
    \ 4])\n    [1, 2, 3, 4]\n*/", "{\n    return (string.count!(substring) - string.count!(substring\
    \ ~ substring)) >> 1;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> find_substrings(\"\"\
    , \"a\")\n    []\n    >>> find_substrings(\"aaaa\", \"aa\")\n    [0, 1, 2]\n \
    \   >>> find_substrings(\"aacaaaacaa\", \"aa\")\n    [0, 1, 4, 7]\n*/\nauto find_substrings(string\
    \ haystack, string needle)\n{\n    return haystack.indices.filter!(i => haystack[i\
    \ .. i + needle.length] == needle).array;\n}", "{\n    long res = 0;\n    auto\
    \ pos = string.length;\n    while ((pos = string.rfind(substring, pos - 1)) !=\
    \ -1) \n    {\n        res++;\n    }\n    return res;\n}", "{\n    long count\
    \ = 0;\n    foreach(int pos; findall(string, substring))\n    {\n        count++;\n\
    \    }\n    return count;\n}", "{\n    long count = 0;\n    foreach(i;0..string.length)\n\
    \    {\n        if(string[i..$].startsWith(substring))\n        {\n          \
    \  count++;\n        }\n    }\n    return count;\n}", "{\n\treturn how_many_times(string,\
    \ substring, 0L);\n}", "{\n    immutable (long, long)[] locs = string.findSubstrings(substring);\n\
    \    return locs.length;\n}", "{\n    import std.algorithm;\n    return count(iota(string.length\
    \ - substring.length + 1), i => string[i .. i + substring.length] == substring);\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Do not count overlaping cases.\n    >>> how_many_times_not_overlaping(\"\",\
    \ \"a\")\n    0L\n    >>> how_many_times_not_overlaping(\"aaa\", \"a\")\n    1L\n\
    \    >>> how_many_times_not_overlaping(\"aaaa\", \"aa\")\n    1L\n    \n*/\nlong\
    \ how_many_times_not_overlaping(string string, string substring) \n{\n    import\
    \ std.algorithm;\n    return count(iota(string.length - substring.length + 1),\
    \ i => string[i .. i + substring.length] == substring, 1);\n}\n/*\n    >>> count_subsequences(\"\
    \", \"a\")\n    0L\n    >>> count_subsequences(\"aaa\", \"a\")\n    3L\n    >>>\
    \ count_subsequences(\"aa\", \"a\")\n    3L\n    >>> count_subsequences(\"aaaa\"\
    , \"aa\")\n    6L\n*/\nlong count_subsequences(string string, string substring)\
    \ \n{\n    import std.algorithm;\n    auto indexes = map!(iota(string.length -\
    \ substring.length + 1), i => string[i .. i + substring.length] == substring);\n\
    \    import std.math;\n    return count(indexes, i => i);\n}\n/*\n    >>> count_subsequences_not_overlaping(\"\
    \", \"a\")\n    0L\n    >>> count_subsequences_not_overlaping(\"aaa\", \"a\")\n\
    \    1L\n    >>> count_subsequences_not_overlaping(\"aa\", \"a\")\n    2L\n  \
    \  >>> count_subsequences_not_overlaping(\"aaaa\", \"aa\")\n    2L\n*/\nlong count_subsequences_not_overlaping(string\
    \ string, string substring) \n{\n    import std.algorithm", "{\n    long x = 0;\n\
    \    if(string.length == 0)\n    {\n        return 0;\n    }\n    else if(substring.length\
    \ == 0)\n    {\n        return 0;\n    }\n    else if(string.length < substring.length)\n\
    \    {\n        return 0;\n    }\n    else\n    {\n        for(int i = 0; i <=\
    \ string.length - substring.length; i++)\n        {\n            if(string[i..$]\
    \ == substring)\n            {\n                x += 1;\n            }\n     \
    \   }\n        return x;\n    }\n}", "{\n  return how_many_times(string,substring,0L);\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    import std.algorithm;\n    import std.range;\n    return\
    \ count(string.split(substring).front.byOne.skip(start));\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, size_t start) \n{\n \
    \   import std.algorithm;\n    import std.range;\n    return count(string.split(substring).front.byOne.drop(start));\n\
    }", "{\n  long howManyTimes = 0;\n  long stringLength = string.length;\n  long\
    \ substringLength = substring.length;\n  for (long i = 0; i < stringLength; i++)\n\
    \  {\n    if (i + substringLength <= stringLength)\n    {\n      auto compSub\
    \ = string[i..i + substringLength];\n      if (compSub == substring) howManyTimes++;\n\
    \    }\n  }\n  return howManyTimes;\n}", "{\n\tlong count = 0;\n\tfor (size_t\
    \ i = 0; i < string.length; ++i)\n\t{\n\t\tif (string[i..$] == substring)\n\t\t\
    {\n\t\t\t++count;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long result = 0;\n\
    \    auto pos = string.find(substring);\n    while (pos != string.npos) \n   \
    \ {\n        result++;\n        pos = string.find(substring, pos + 1);\n    }\n\
    \    return result;\n}\n/*\n For example, if we want to calculate the Fibonacci\
    \ number of position 10, we can write a recursive solution:\n    >>> fibonacci(10)\n\
    \    55L\n    >>> fibonacci(35)\n    9227465L\n*/\nlong fibonacci(int n) \n{\n\
    \    return n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n}\n/*\n It is not\
    \ a very efficient solution, but it works.\n    >>> fibonacci_fast(10)\n    55L\n\
    \    >>> fibonacci_fast(35)\n    9227465L\n    >>> fibonacci_fast(170)\n    788657867364790503552363213932185062295135977687173263294742533244359449963403342920304284011984623904177212138919638830257642790242637105061926624952829931113462857270763317237396988943922445621451664240254033291864131227428294853277524242407573903240321257405579568660226031904170324062351700858796178922222789623703897374720000000000000000000000000000000000000000000000000L\n\
    */\nlong fibonacci_fast(int n) \n{\n    long[int] cache;\n    return fibonacci_fast(n,\
    \ cache);\n}\nlong fibonacci_fast(int n, long[int] cache) \n{\n    if (n <= 1)\
    \ \n    {\n        return n;\n    }\n    else if (cache.count(n)) \n    {\n  \
    \      return cache[n];\n    }\n    else \n    {\n        long value = fibonacci_fast(n\
    \ - 1, cache) + fibonacci_fast(n -", "{\n    long result = 0;\n    long subLength\
    \ = substring.length;\n    if (subLength == 0)\n        return result;\n    long\
    \ length = string.length;\n    long maxLen = length - subLength;\n    foreach\
    \ (i; 0..maxLen)\n    {\n        if (equal(string[i..i+subLength], substring))\n\
    \            result++;\n    }\n    return result;\n}\n/*\n    >>> has_duplicates([1,\
    \ 2, 3, 4, 5])\n    false\n    >>> has_duplicates([1, 2, 3, 4, 4])\n    true\n\
    */", "{\n    size_t count = 0;\n    for (size_t i = 0; i < string.length - substring.length\
    \ + 1; i++)\n    {\n        if (string[i .. i + substring.length] == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \tint n = string.length;\n\tint m = substring.length;\n\tif (m > n) \n\t{\n\t\t\
    return 0;\n\t}\n\telse if (m == n) \n\t{\n\t\treturn string == substring ? 1 :\
    \ 0;\n\t}\n\telse \n\t{\n\t\t// Substring shorter than string:\n\t\tlong cnt =\
    \ 0;\n\t\tforeach (i; 0 .. n - m + 1) \n\t\t{\n\t\t\tif (string[i .. i + m - 1]\
    \ == substring) \n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t\
    }\n}", "{\n    long count = 0;\n    long sub_len = substring.length;\n    long\
    \ string_len = string.length;\n    if (sub_len == 0)\n        return 0;\n    for\
    \ (long i = 0; i < string_len - sub_len + 1; i++)\n    {\n        if (string[i..i\
    \ + sub_len] == substring)\n            count++;\n    }\n    return count;\n}\n\
    /*\nFind the maximum and the minimum values in a list of integers.\n    >>> find_max_min([0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    (9, 0)\n*/\nTuple!(long, long) find_max_min(long[]\
    \ array) \n{\n    long max = array[0];\n    long min = array[0];\n    foreach\
    \ (elem; array)\n    {\n        if (elem > max)\n            max = elem;\n   \
    \     if (elem < min)\n            min = elem;\n    }\n    return tuple(max, min);\n\
    }\n/*\nFind the mean value of a list of integers.\n    >>> find_mean([0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9])\n    4.5\n*/\ndouble find_mean(long[] array) \n{\n   \
    \ long sum = 0;\n    foreach (elem; array)\n        sum += elem;\n    return sum\
    \ / array.length;\n}\n/*\nFind the median value of a list of integers.\n    >>>\
    \ find_median([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    4.5\n    >>> find_median([0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    5\n*/\ndouble find_median(long[] array)\
    \ \n{\n    long[] sorted_array = sort(array);\n    long n = sorted_array.length;\n\
    \    if (n % 2 == 0)\n        return (sorted_array[n / 2 - 1] + sorted_array[n\
    \ / 2]) / 2.0;\n   ", "{\n    \n}", "{\n    long count = 0;\n    long index =\
    \ 0;\n    while ((index = find(string, substring, index)) != -1) \n    {\n   \
    \     count++;\n        index++;\n    }\n    return count;\n}\n/*\n    Create\
    \ a function that takes a string and returns a list with all the positions of\
    \ a given character.\n    >>> get_all_positions(\"abracadabra\", 'a')\n    [0L,\
    \ 2L, 4L, 6L, 8L, 10L]\n    >>> get_all_positions(\"abracadabra\", 'c')\n    [5L]\n\
    */\nimmutable(int)[] get_all_positions(string string, char character) \n{\n  \
    \  immutable(int)[] positions = [];\n    foreach (index, char x; string) \n  \
    \  {\n        if (x == character) \n        {\n            positions ~= index;\n\
    \        }\n    }\n    return positions;\n}\n/*\n    Create a function that takes\
    \ a list of strings and returns all strings that start with the letter \"a\".\n\
    \    >>> find_a_words([\"apple\", \"bag\", \"cat\", \"applepie\"])\n    [\"apple\"\
    , \"applepie\"]\n*/\nstring[] find_a_words(string[] strings) \n{\n    string[]\
    \ found = [];\n    foreach (string s; strings) \n    {\n        if (s[0] == 'a')\
    \ \n        {\n            found ~= s;\n        }\n    }\n    return found;\n\
    }\n/*\n    Create a function that takes a list of strings and returns only the\
    \ strings with an even length.\n    >>> get_even_length_strings([\"one\", \"two\"\
    , \"three\", \"four\", \"five\", \"six\"])\n    [\"four\", \"six\"]\n*/\nstring[]\
    \ get_even_length_strings(string[] strings) \n{\n    string[] even_length = [];\n\
    \    foreach (string s; strings) \n    {\n        if (s.length % 2 == 0) \n  \
    \      {\n            even_length ~= s;\n        }\n    }\n    return even_length;\n\
    }\n/*\n    Create a function", "{\n    long res;\n    if (substring.length > string.length)\n\
    \        return 0;\n    for (long i = 0; i < string.length; i++)\n    {\n    \
    \    if (string[i..i + substring.length] == substring)\n            res++;\n \
    \   }\n    return res;\n}", "{\n    return(string.countOverlapping(substring));\n\
    }", "{\n    long result = 0;\n    string temp;\n    if (string.length < substring.length)\n\
    \        return result;\n    for (int i = 0; i < string.length; i++)\n    {\n\
    \        temp = string[i..$];\n        if (temp.startsWith(substring))\n     \
    \       result++;\n    }\n    return result;\n}\n ", "{\n    long int total =\
    \ 0;\n    size_t pos = 0;\n    size_t found = 0;\n    long int offset = 0;\n \
    \   //TODO: refactor this iteration\n    for (; pos < string.length; ++pos)\n\
    \    {\n        found = string.find(substring, pos);\n        if (found == string.npos)\n\
    \        {\n            break;\n        }\n        pos = found;\n        total\
    \ += 1;\n    }\n    return total;\n}\n \n/*\n    Find the number of positions\
    \ in the original string where a substring of the given size can be found\n  \
    \  >>> number_of_alignments(\"\", 0)\n    0L\n    >>> number_of_alignments(\"\
    aa\", 1)\n    2L\n    >>> number_of_alignments(\"aba\", 1)\n    3L\n    >>> number_of_alignments(\"\
    aba\", 2)\n    2L\n    >>> number_of_alignments(\"abab\", 2)\n    4L\n    >>>\
    \ number_of_alignments(\"abab\", 3)\n    2L\n*/\nlong number_of_alignments(string\
    \ string, size_t substring_size) \n{\n    return string.length - substring_size\
    \ + 1;\n}\n \n/*\nGiven two strings s and t, find all locations where t appears\
    \ as a substring of s.\n    >>> find_all_alignments(\"\", \"\")\n    []\n    >>>\
    \ find_all_alignments(\"\", \"a\")\n    []\n    >>> find_all_alignments(\"a\"\
    , \"\")\n    [0L]\n    >>> find_all_alignments(\"ab\", \"a\")\n    [0L]\n    >>>\
    \ find_all_alignments(\"ab\", \"b\")\n    [1L]\n    >>> find_all_alignments(\"\
    aba\", \"a\")\n    [0L, 2L]\n    >>> find_all_alignments(\"aba\", \"b\")\n   \
    \ [1L]\n    >>> find_all_alignments(\"aba\", \"ab\")\n    [0L]\n    >>> find_all_alignments(\"\
    aba\", \"ba\")\n    [1L]\n    >>> find_all_alignments", "    in (string.length\
    \ >= substring.length)\n{\n    long count = 0;\n    long position = 0;\n    while\
    \ ((position = string.find(substring, position)) != -1) {\n        count++;\n\
    \        position++;\n    }\n    return count;\n}\n/*\n Given a string, find the\
    \ number of pairs of substrings of the string that are anagrams of each other.\n\
    \    >>> anagram_pairs(\"xyyx\")\n    2L\n    >>> anagram_pairs(\"xyz\")\n   \
    \ 0L\n    >>> anagram_pairs(\"abba\")\n    4L\n    >>> anagram_pairs(\"abcd\"\
    )\n    0L\n    >>> anagram_pairs(\"ifailuhkqq\")\n    3L\n    >>> anagram_pairs(\"\
    hucpoltgty\")\n    2L\n    >>> anagram_pairs(\"ovarjsnrbf\")\n    2L\n    >>>\
    \ anagram_pairs(\"pvmupwjjjf\")\n    6L\n    >>> anagram_pairs(\"iwwhrlkpek\"\
    )\n    3L\n*/\nlong anagram_pairs(string string) \n    in (string.length >= 1)\
    \ \n    out (result >= 0)\n{\n    long count = 0;\n    for (long i = 0; i < string.length;\
    \ i++) {\n        for (long j = i + 1; j < string.length; j++) {\n           \
    \ string a = string[i..j];\n            if (i > 0) {\n                a = string[0..i-1]\
    \ ~ a;\n            }\n            if (j < string.length - 1) {\n            \
    \    a = a ~ string[j+1..$];\n            }\n            if (a.length % 2 == 0)\
    \ {\n                string left = a[0..a.length/2];\n                string right\
    \ = a[a.length/2..$];\n                long left_count = how_many_times(left,\
    \ string[i..j]);\n                long right_count = how_many_times(right, string[i..j]);\n\
    \                if (left_count > 0 && right_count > 0) {\n                  \
    \  count += fact", "{\n    ulong size = std.typecons.Tuple(substring, string).min.length;\n\
    \    long count = 0;\n    foreach (u ; 0..string.length - size + 1)\n    {\n \
    \       if (substring == string[u..u + size])\n            count++;\n    }\n \
    \   return count;\n}", "{\n  import std.range;\n  import std.algorithm;\n  return\
    \ string.count(substring);\n}\n/*\n Check whether a given string is a palindrome.\n\
    \    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"a\")\n    true\n\
    \    >>> is_palindrome(\"aa\")\n    true\n    >>> is_palindrome(\"bbb\")\n   \
    \ true\n    >>> is_palindrome(\"aba\")\n    true\n    >>> is_palindrome(\"ab\"\
    )\n    false\n*/", "{\n    long start = 0L;\n    long counter = 0L;\n    long\
    \ n = string.length;\n    long m = substring.length;\n    while (start < n - m\
    \ + 1L) \n    {\n        string slice = string[start..start + m];\n        if\
    \ (slice == substring)\n        {\n            counter++;\n            start +=\
    \ m;\n        }\n        else\n        {\n            start++;\n        }\n  \
    \  }\n    return counter;\n}", "    in(string, substring) \n{\n    size_t pos\
    \ = 0;\n    size_t cnt = 0;\n    size_t size = substring.length;\n    while(true)\
    \ {\n        pos = string.find(substring, pos);\n        if(pos == string.npos)\n\
    \            break;\n        pos += size;\n        cnt++;\n    }\n    return cnt;\n\
    }", "{\n    long count = 0;\n    long stringLength = string.length;\n    long\
    \ substringLength = substring.length;\n    foreach(i; 0 .. stringLength - substringLength\
    \ + 1)\n    {\n        if(string[i .. i + substringLength - 1] == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \    >>> edit_distance(\"algorithm\", \"altruistic\")\n    4L\n    >>> edit_distance(\"\
    \", \"\")\n    0L\n    >>> edit_distance(\"\", \"a\")\n    1L\n    >>> edit_distance(\"\
    a\", \"\")\n    1L\n    >>> edit_distance(\"foo\", \"foobar\")\n    3L\n*/\nlong\
    \ edit_distance(string s1, string s2)\n{\n    long m = s1.length;\n    long n\
    \ = s2.length;\n    long dp[][] = new long[m + 1][n + 1];\n    for(long i = 0;\
    \ i <= m; i++)\n    {\n        for(long j = 0; j <= n; j++)\n        {\n     \
    \       if(i == 0)\n            {\n                dp[i][j] = j;\n           \
    \ }\n            else if(j == 0)\n            {\n                dp[i][j] = i;\n\
    \            }\n            else if(s1[i - 1] == s2[j - 1])\n            {\n \
    \               dp[i][j] = dp[i - 1][j - 1];\n            }\n            else\n\
    \            {\n                dp[i][j] = 1 + min(dp[i][j - 1], min(dp[i - 1][j],\
    \ dp[i - 1][j - 1]));\n            }\n        }\n    }\n    return dp[m][n];\n\
    }\n/*\n      >>> longest_subsequence(\"ABCDAF\", \"ACBCF\")\n      'ABCF'\n  \
    \    >>> longest_subsequence(\"ACA\", \"ABC\")\n      'AC'\n      >>> longest_subsequence(\"\
    A\", \"B\")\n      ''\n      >>> longest_subsequence(\"\", \"\")\n      ''", "{\n\
    \tsize_t pos = 0;\n\tlong count = 0;\n\twhile ((pos = string.find(substring, pos))\
    \ != string.npos) \n\t{\n\t\t++count;\n\t\tpos += substring.length();\n\t}\n\t\
    return count;\n}", "in\n{\n    assert(string.length >= substring.length);\n}\n\
    out(result)\n{\n    assert(result >= 0L);\n}\n{\n    long n = string.length -\
    \ substring.length + 1L;\n    if (n <= 0L) return 0L;\n    long result = 0L;\n\
    \    for (long index = 0L; index < n; index += 1L) \n    {\n        bool is_match\
    \ = true;\n        for (long i = 0L; i < substring.length; i += 1L) \n       \
    \ {\n            if (string[index + i] != substring[i]) \n            {\n    \
    \            is_match = false;\n                break;\n            }\n      \
    \  }\n        if (is_match) result += 1L;\n    }\n    return result;\n}\n/*\n\
    \ Find the nth occurrence of a given substring. Return index.\n    >>> find_nth_occurrence(\"\
    \", \"a\", 1L)\n    -1L\n    >>> find_nth_occurrence(\"a\", \"a\", 1L)\n    0L\n\
    \    >>> find_nth_occurrence(\"aa\", \"a\", 1L)\n    0L\n    >>> find_nth_occurrence(\"\
    aa\", \"a\", 2L)\n    1L\n    >>> find_nth_occurrence(\"aaaa\", \"aa\", 1L)\n\
    \    0L\n    >>> find_nth_occurrence(\"aaaa\", \"aa\", 2L)\n    1L\n    >>> find_nth_occurrence(\"\
    aaaa\", \"aa\", 3L)\n    2L\n    >>> find_nth_occurrence(\"aaaa\", \"aa\", 4L)\n\
    \    -1L\n*/\nlong find_nth_occurrence(string string, string substring, long n)\
    \ \nin\n{\n    assert(string.length >= substring.length);\n    assert(n >= 1L);\n\
    }\nout(result)\n{\n    assert(result >= -1L);\n}\n{\n    long index = 0L;\n  \
    \  long count = 0L;\n    while (index + substring.length <= string.length) \n\
    \    {\n        bool is_match =", "{\n    auto length = string.length;\n    auto\
    \ subLength = substring.length;\n    long count = 0;\n    while (length >= subLength)\
    \ \n    {\n        if (string[0 .. subLength] == substring)\n        {\n     \
    \       count++;\n            length -= subLength;\n            string = string[subLength\
    \ .. $];\n        }\n        else\n        {\n            string = string[1 ..\
    \ $];\n            length--;\n        }\n    }\n    return count;\n}\n/*\n\tReturn\
    \ pair of strings (left, right) with length \n\tof the first string at least 2,\
    \ and length of the second \n\tstring at least 1, and sum of these two string\
    \ equal to the \n\tinitial string. If there is no string that satisfy that\n\t\
    condition return None.\n\t    >>> split_in_two(\"\")\n\t    None\n\t    >>> split_in_two(\"\
    ab\")\n\t    tuple(\"a\", \"b\")\n\t    >>> split_in_two(\"abc\")\n\t    tuple(\"\
    ab\", \"c\")\n\t    >>> split_in_two(\"bba\")\n\t    tuple(\"bb\", \"a\")\n\t\
    \    >>> split_in_two(\"bab\")\n\t    tuple(\"ba\", \"b\")\n\t    >>> split_in_two(\"\
    bbab\")\n\t    tuple(\"bba\", \"b\")\n\t    >>> split_in_two(\"bbbbb\")\n\t  \
    \  tuple(\"bbbb\", \"b\")\n\t    >>> split_in_two(\"abbbb\")\n\t    tuple(\"abbb\"\
    , \"b\")\n\t    >>> split_in_two(\"bbbab\")\n\t    tuple(\"bbba\", \"b\")\n\t\
    \    >>> split_in_two(\"aabbb\")\n\t    tuple(\"aabb\", \"b\")\n\t    >>> split_in_two(\"\
    abbbbb\")\n\t    tuple(\"abbbb\", \"b\")\n\t    >>> split_in_two(\"abbbbbb\")\n\
    \t    tuple(\"abbbbb\", \"b\")\n\t    >>> split_in_two(\"aaaabb\")\n\t    tuple(\"\
    aaaa\", \"bb\")\n\t    >>> split_in_two(\"aaabb\")\n\t    tuple(\"aaa\", \"bb\"\
    )", "{\n\treturn (long)std.algorithm.count(std.range.iota(string.length).map!((i)\
    \ => string[i..$])\n\t                                                       \
    \         .filter!((s) => s.length >= substring.length)\n\t                  \
    \                                              .filter!((s) => s.startsWith(substring)));\n\
    }", "{\n    return size_t(count(string, substring));\n}\n/*\nFind if a string\
    \ can be found in another string.\n    >>> is_substr(\"\", \"a\")\n    false\n\
    \    >>> is_substr(\"a\", \"\")\n    true\n    >>> is_substr(\"aaa\", \"a\")\n\
    \    true\n    >>> is_substr(\"aaa\", \"aa\")\n    true\n    >>> is_substr(\"\
    aaa\", \"aaa\")\n    true\n    >>> is_substr(\"aaa\", \"aaaa\")\n    false\n \
    \   >>> is_substr(\"abc\", \"a\")\n    true\n    >>> is_substr(\"abc\", \"b\"\
    )\n    true\n    >>> is_substr(\"abc\", \"c\")\n    true\n    >>> is_substr(\"\
    abc\", \"ab\")\n    true\n    >>> is_substr(\"abc\", \"bc\")\n    true\n    >>>\
    \ is_substr(\"abc\", \"abc\")\n    true\n    >>> is_substr(\"abc\", \"aa\")\n\
    \    false\n    >>> is_substr(\"abc\", \"bb\")\n    false\n    >>> is_substr(\"\
    abc\", \"cc\")\n    false\n*/", "{\n    long sum = 0;\n    size_t i = 0;\n   \
    \ while(i != string.length)\n    {\n        if(string[i..i+substring.length] ==\
    \ substring)\n        {\n            sum++;\n            i += substring.length;\n\
    \        }\n        else\n        {\n            i++;\n        }\n    }\n    return\
    \ sum;\n}", "{\n    return how_many_times(cast(char[])string, cast(char[])substring);\n\
    }", "{\n    long result = 0;\n    foreach(int k; 0 .. string.length) \n    {\n\
    \        if(string[k .. $].startsWith(substring)) \n        {\n            result++;\n\
    \        }\n    }\n    return result;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\
    \ \n{\n    long result = 0;\n    foreach(int k; 0 .. string.length) \n    {\n\
    \        if(string[k .. $].startsWith(substring)) \n        {\n            result++;\n\
    \        }\n    }\n    return result;\n}\n/*\n A function named first_name that\
    \ takes in an input string name, returns the first name in that string. The function\
    \ will stop looking for the first name once it finds a space.\n    >>> first_name(\"\
    \")\n    \"\"\n    >>> first_name(\"Python\")\n    \"Python\"\n    >>> first_name(\"\
    Python \")\n    \"Python\"\n    >>> first_name(\"Python 3\")\n    \"Python\"\n\
    \    >>> first_name(\"Your first name is Python\")\n    \"Your\"\n    \n*/\nstring\
    \ first_name(string name) \n{\n    return name.find(\" \") == -1 ? name : name[0\
    \ .. name.find(\" \")];\n}\n/*\n A function named first_name that takes in an\
    \ input string name, returns the first name in that string. The function will\
    \ stop looking for the first name once it finds a space.\n    >>> first_name(\"\
    \")\n    \"\"\n    >>> first_name(\"Python\")\n    \"Python\"\n    >>> first_name(\"\
    Python \")\n    \"Python\"\n    >>> first_name(\"Python 3\")\n    \"Python\"\n\
    \    >>> first_name(\"Your first name is Python\")\n    \"Your\"\n    \n*/\nstring\
    \ first_name(string name) \n", "{\n    if (substring.length == 0)\n        return\
    \ 0;\n    if (string.length == 0)\n        return 0;\n    if (string.length <\
    \ substring.length)\n        return 0;\n    long count = 0;\n    int index = 0;\n\
    \    while (index < string.length)\n    {\n        int index_substr = 0;\n   \
    \     bool find_substr = true;\n        for (index_substr = 0; index_substr <\
    \ substring.length; index_substr++)\n        {\n            if (index + index_substr\
    \ >= string.length)\n            {\n                find_substr = false;\n   \
    \             break;\n            }\n            if (string[index + index_substr]\
    \ != substring[index_substr])\n            {\n                find_substr = false;\n\
    \                break;\n            }\n        }\n        if (find_substr)\n\
    \        {\n            count++;\n            index += index_substr;\n       \
    \ }\n        else\n        {\n            index++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find longest palindrome in a given string and return the length.\n\
    \    >>> longest_palindrome(\"abbaba\")\n    5L\n    >>> longest_palindrome(\"\
    cbbd\")\n    2L\n    \n*/\nlong longest_palindrome(string input) \n{\n    if (input.length\
    \ == 0)\n        return 0;\n    if (input.length == 1)\n        return 1;\n  \
    \  long longest = 1;\n    for (int i = 0; i < input.length; i++)\n    {\n    \
    \    for (int j = i + 1; j < input.length; j++)\n        {\n            bool is_palindrome\
    \ = true;\n            for (int k = 0; k < (j - i + 1) / 2; k++)\n           \
    \ {\n                if (input[i + k] != input[j - k])\n                {\n  \
    \                  is_palindrome = false;\n                    break;\n      \
    \          }\n            }\n            if (is_palindrome)\n            {\n \
    \               longest = max(longest, j - i + 1);\n            }\n", "    if\
    \ (is(typeof(strstr(string, substring)))) {\n    long count = 0;\n    long pos\
    \ = 0;\n    while ((pos = strstr(string, substring, pos)) != -1) {\n        ++count;\n\
    \        ++pos;\n    }\n    return count;\n} else {\n    assert(0);\n}\n/*\n \n\
    \ \n \n*/", "{\n    int result = 0;\n    if (substring.length == 0)\n        return\
    \ result;\n    size_t pos = string.indexOf(substring);\n    while (pos != string.npos)\n\
    \    {\n        result++;\n        pos = string.indexOf(substring, pos + 1);\n\
    \    }\n    return result;\n}", "{\n    long times = 0;\n    for (size_t i = 0;\
    \ i < string.length - substring.length + 1; i++) \n    {\n        if (string[i\
    \ .. i + substring.length] == substring) \n        {\n            times++;\n \
    \       }\n    }\n    return times;\n}\n// count all pairs from vector of pairs\n\
    long count_all_pairs(T...)(T vector_of_pairs) \n{\n    long res = 0;\n    foreach\
    \ (pair; vector_of_pairs) \n    {\n        res += pair[1];\n    }\n    return\
    \ res;\n}\n/*\n Find how many time each substring can be found in the original\
    \ string.\n    >>> find_substring_frequencies(\"\", [\"a\"])\n    [\"a\": 0L]\n\
    \    >>> find_substring_frequencies(\"aaa\", [\"a\", \"aa\"])\n    [\"a\": 3L,\
    \ \"aa\": 1L]\n    >>> find_substring_frequencies(\"aaaa\", [\"aa\", \"aaa\"])\n\
    \    [\"aa\": 3L, \"aaa\": 2L]\n*/\nTuple!(string, long)[string] find_substring_frequencies(string\
    \ string, string[] substring_vector) \n{\n    auto res = (Tuple!(string, long)[string])null;\n\
    \    foreach (substring; substring_vector) \n    {\n        if (how_many_times(string,\
    \ substring) != 0) \n        {\n            res[substring] = how_many_times(string,\
    \ substring);\n        }\n    }\n    return res;\n}\n/*\n Return permutations\
    \ of a given vector\n    >>> permutations([])\n    [[]]\n    >>> permutations([1])\n\
    \    [[1]]\n    >>> permutations([1, 2])\n    [[1, 2], [2, 1]]\n    >>> permutations([1,\
    \ 2, 3])\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\
    */", "    in(substring) //substring can be longer than string\n{\n    long count\
    \ = 0;\n    long index = 0;\n    while(true)\n    {\n        index = string.find(substring,\
    \ index);\n        if(index == string.npos) break;\n        count++;\n       \
    \ index++;\n    }\n    return count;\n}\n/*\n Find the longest substring of given\
    \ string that can be built from the concatenation of two other ones, each appearing\
    \ at least once.\n    >>> find_substring(\"abcdxyz\")\n    [\"z\"]\n    >>> find_substring(\"\
    xyzabcd\")\n    [\"xyz\", \"zab\", \"abcd\"]\n    >>> find_substring(\"aabcdxyz\"\
    )\n    [\"abcd\", \"cdxy\", \"dxyz\"]\n    >>> find_substring(\"aabcdxyza\")\n\
    \    [\"abcdxyz\", \"bcdxyza\"]\n    >>> find_substring(\"aabcdxyzaa\")\n    [\"\
    abcdxyzaa\", \"bcdxyzaa\"]\n    >>> find_substring(\"aabcdxyzaaa\")\n    [\"abcdxyzaaa\"\
    , \"bcdxyzaaa\"]\n    >>> find_substring(\"abbcdxyzaa\")\n    [\"bbcdxyz\", \"\
    bcdxyza\", \"cdxyzaa\"]\n    >>> find_substring(\"abc\")\n    [\"bc\"]\n    >>>\
    \ find_substring(\"aaaaaa\")\n    [\"aaaaaa\"]\n    >>> find_substring(\"a\")\n\
    \    []\n    >>> find_substring(\"\")\n    []\n*/\ndstring[] find_substring(string\
    \ string)\n{\n    if(string.empty) return dstring[].init;\n    dstring result;\n\
    \    dstring temp;\n    foreach(i, l; string)\n    {\n        temp = string[i..$];\n\
    \        foreach(j, l; temp)\n        {\n            if(how_many_times(temp, temp[0..j])\
    \ >= 2)\n            {\n                if(result.length < temp[0..j].length)\n\
    \                {\n                    result = temp[0..j];\n               \
    \ }\n            }\n       ", "{\n    //return count(string.rfind(substring),\
    \ string.length, substring.length);\n    long count = 0;\n    long index = 0;\n\
    \    while(index < string.length)\n    {\n        auto pos = string.find(substring,\
    \ index);\n        if(pos == -1)\n            break;\n        index = pos + substring.length;\n\
    \        count++;\n    }\n    return count;\n}", "{\n    long how_many = 0;\n\
    \    size_t offset = 0;\n    while (true)\n    {\n        size_t cur_pos = string.find(substring,\
    \ offset);\n        if (cur_pos == string.npos) \n            break;\n       \
    \ else\n        {\n            how_many++;\n            offset = cur_pos + 1;\n\
    \        }\n    }\n    return how_many;\n}\n/*\n Given a list and a number, find\
    \ if the number is present in the list and the number of times.\n    >>> how_many_times([1,\
    \ 2, 2, 3, 2, 3, 2, 3, 2, 1], 2)\n    5L\n    >>> how_many_times([1, 2, 2, 3,\
    \ 2, 3, 2, 3, 2, 1], 3)\n    3L\n    >>> how_many_times([1, 2, 2, 3, 2, 3, 2,\
    \ 3, 2, 1], 1)\n    2L\n    >>> how_many_times([1, 2, 2, 3, 2, 3, 2, 3, 2, 1],\
    \ 0)\n    0L\n    >>> how_many_times([1, 2, 2, 3, 2, 3, 2, 3, 2, 1], 20)\n   \
    \ 0L\n*/\nlong how_many_times(long[] numbers, long number) \n{\n    long how_many\
    \ = 0;\n    foreach (n; numbers) \n    {\n        if (n == number) \n        \
    \    how_many++;\n    }\n    return how_many;\n}\n/*\n Given a list of lists and\
    \ a number, find if the number is present in any list of the list and the number\
    \ of times.\n    >>> how_many_times([[1, 2, 2, 3, 2, 3, 2, 3, 2, 1], [1, 2, 3,\
    \ 4]], 2)\n    5L\n    >>> how_many_times([[1, 2, 2, 3, 2, 3, 2, 3, 2, 1], [1,\
    \ 2, 3, 4]], 3)\n    3L\n    >>> how_many_times([[1, 2, 2, 3, 2", "{\n    long\
    \ result = 0;\n    size_t index = 0;\n    while (index <= string.length - substring.length)\
    \ \n    {\n        index = string.find(substring, index);\n        if (index ==\
    \ string.npos) \n        {\n            break;\n        }\n        result++;\n\
    \        index++;\n    }\n    return result;\n}", "{\n\t\n\tlong num = 0;\n\t\
    long count = 0;\n\tforeach(i; 0 .. string.length) \n\t{\n\t\tif(string[i..i+substring.length-1]\
    \ == substring)\n\t\t{\n\t\t\t++num;\n\t\t\t++count;\n\t\t\ti = i + substring.length\
    \ - 1;\n\t\t}\n\t}\n\treturn num;\n}", "{\n    long result = 0;\n    foreach(size_t\
    \ i; 0 .. string.length)\n    {\n        if(i+substring.length <= string.length)\n\
    \        {\n            if(string[i .. i+substring.length] == substring)\n   \
    \         {\n                result += 1;\n            }\n        }\n    }\n \
    \   return result;\n}", "{\n    // TODO: your code here\n    return 0L;\n}\n/*\n\
    \ Count how many times there is a space in the string. Count only spaces, not\
    \ tabs.\n    >>> count_spaces(\"a\\tb\")\n    0L\n    >>> count_spaces(\"a b\"\
    )\n    1L\n    >>> count_spaces(\"  a  b\")\n    3L\n    >>> count_spaces(\" a\"\
    )\n    1L\n    >>> count_spaces(\"a \")\n    1L\n*/\nlong count_spaces(string\
    \ string) \n{\n    // TODO: your code here\n    return 0L;\n}\n/*\n Get first\
    \ matching substring.\n    >>> get_first_matching_substring(\"abcabcabc\", \"\
    c\")\n    \"c\"\n    >>> get_first_matching_substring(\"abcabcabc\", \"d\")\n\
    \    \"\"\n    >>> get_first_matching_substring(\"abcabcabc\", \"c\", 1)\n   \
    \ \"c\"\n    >>> get_first_matching_substring(\"abcabcabc\", \"c\", 2)\n    \"\
    c\"\n    >>> get_first_matching_substring(\"abcabcabc\", \"c\", 3)\n    \"\"\n\
    \    >>> get_first_matching_substring(\"abcabcabc\", \"c\", 5)\n    \"\"\n*/\n\
    string get_first_matching_substring(string string, string substring, size_t min_start_offset\
    \ = 0) \n{\n    // TODO: your code here\n    return \"\";\n}\n/*\n Get the number\
    \ of occurences of substring in string\n    >>> count_occurences(\"aabaabaa\"\
    , \"a\")\n    6L\n    >>> count_occurences(\"aabaabaa\", \"b\")\n    2L\n    >>>\
    \ count_occurences(\"abababab\", \"a\")\n    4L\n    >>> count_occurences(\"abababab\"\
    , \"b\")\n    4L\n    >>> count_occurences(\"\", \"a\")\n    0L\n    >>> count_occurences(\"\
    aabaabaa\", \"\")\n    0L\n*/\nlong count_occurences(string string,", "{\n   \
    \ /*\n    long k=0;\n    if(substring.length<=0)\n        return k;\n    for(int\
    \ i=0;i<string.length;i++)\n    {\n        if(string[i]==substring[0])\n     \
    \   {\n            int j;\n            for(j=0;j<substring.length;j++)\n     \
    \       {\n                if(string[i+j]!=substring[j])\n                   \
    \ break;\n            }\n            if(j==substring.length)\n            {\n\
    \                k++;\n                i+=j-1;\n            }\n        }\n   \
    \ }\n    return k;\n    */\n    return count!(string.count(substring)).count;\n\
    }", "{\n    long counter = 0;\n    string temp = string;\n    while(temp.indexOf(substring)\
    \ != -1)\n    {\n        counter++;\n        temp = temp.substring(temp.indexOf(substring)\
    \ + 1);\n    }\n    return counter;\n}", "{\n\tint m = string.length;\n\tint n\
    \ = substring.length;\n\tlong count = 0;\n\tlong i = 0;\n\tlong k = 0;\n\tfor\
    \ (i = 0; i <= (m - n); i++) {\n\t\tfor (k = 0; k < n; k++) {\n\t\t\tif (string[i\
    \ + k] != substring[k]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (k == n) {\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    if (string.empty || substring.empty)\
    \ \n    {\n        return 0L;\n    }", "{\n\treturn split(string, substring).length\
    \ - 1;\n}", "{\n    long count = 0;\n    long i = 0;\n    while(true) \n    {\n\
    \        auto pos = string.find(substring, i);\n        if(pos < 0)\n        \
    \    break;\n        count++;\n        i = pos + 1;\n    }\n    return count;\n\
    }\n \n/*\n Find how many times the second string can be found in the first string\
    \ using the KMP algorithm.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n*/\nlong how_many_times2(string string, string substring) \n{\n\
    \    auto prefix = kmpPrefix(substring);\n    long count = 0;\n    long j = 0;\n\
    \    foreach(long i, char c; string) \n    {\n        while(j > 0 && substring[j]\
    \ != c)\n            j = prefix[j - 1];\n        if(substring[j] == c)\n     \
    \       j++;\n        if(j == substring.length) \n        {\n            count++;\n\
    \            j = prefix[j - 1];\n        }\n    }\n    return count;\n}\n/*\n\
    \ Generate the KMP prefix function for a given string.\n    >>> kmpPrefix(\"abcdabd\"\
    )\n    [0L, 0L, 0L, 0L, 1L, 2L, 0L]\n*/\nlong[] kmpPrefix(string s) \n{\n    long[]\
    \ prefix = new long[s.length];\n    long j = 0;\n    foreach(long i, char c; s)\
    \ \n    {\n        while(j > 0 && s[j] != c)\n            j = prefix[j - 1];\n\
    \        if(s[j] == c)\n            j++;\n        prefix[i] = j;\n    }\n    return\
    \ prefix;\n}", "{\n    long index = 0;\n    long cnt = 0;\n    while(true) \n\
    \    {\n        index = string.find(substring, index);\n        if(index == string.npos)\
    \ break;\n        index += 1;\n        cnt += 1;\n    }\n    return cnt;\n}\n\
    long[] get_indices(string string, string substring)\n{\n    long index = 0;\n\
    \    long[] indices = null;\n    while(true) \n    {\n        index = string.find(substring,\
    \ index);\n        if(index == string.npos) break;\n        indices ~= index;\n\
    \        index += 1;\n    }\n    return indices;\n}", "{\n    long count = 0;\n\
    \    for (size_t index = 0; index < string.length; index++) \n    {\n        if\
    \ (string[index .. index + substring.length] == substring) \n        {\n     \
    \       count++;\n        }\n    }\n    return count;\n}\n/*\n Write a program\
    \ which uses a while loop to find the largest integer n such that n3 is less than\
    \ 12,000.\n    >>> cube_smaller_than_12000()\n    22L\n*/\nlong cube_smaller_than_12000()\
    \ \n{\n    long number = 1;\n    while (pow(number, 3) < 12000) \n    {\n    \
    \    number++;\n    }\n    return number - 1;\n}\n/*\n Prompt the user to enter\
    \ a positive integer. What happens when you enter a negative number?\n*/", "{\n\
    \    auto count = 0L;\n    auto index = 0L;\n    auto temp_index = 0L;\n    while\
    \ (index < string.length)\n    {\n        temp_index = string.find(substring,\
    \ index);\n        if (temp_index < 0)\n            break;\n        else\n   \
    \     {\n            count += 1;\n            index = temp_index + 1;\n      \
    \  }\n    }\n    return count;\n}", "{\n    return how_many_times(string, substring);\n\
    }\n/*\n Given two strings, write a function that returns true if one string is\
    \ one edit away from the other.\n    >>> one_away(\"abc\", \"abc\")\n    true\n\
    \    >>> one_away(\"abc\", \"abcd\")\n    true\n    >>> one_away(\"ab\", \"abc\"\
    )\n    true\n    >>> one_away(\"abcde\", \"ab\")\n    false\n    >>> one_away(\"\
    ab\", \"abcd\")\n    false\n*/", "{\n    long result = 0;\n    long length = string.length;\n\
    \    long sublength = substring.length;\n    long last_step = length - sublength;\n\
    \    if(sublength == 0) return 0;\n    foreach(i; 0 .. last_step + 1)\n    {\n\
    \        if(string[i .. i + sublength - 1] == substring)\n        {\n        \
    \    result++;\n        }\n    }\n    return result;\n}", "{\n\treturn (string.length\
    \ - string.replace(substring, \"\").length) / substring.length;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring) \n{\n\tlong result =\
    \ 0;\n\tforeach(i; 0 .. string.length - substring.length + 1)\n\t{\n\t\tif(string[i\
    \ .. i + substring.length - 1] == substring)\n\t\t{\n\t\t\tresult += 1;\n\t\t\
    }\n\t}\n\treturn result;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\
    \ \n{\n\tlong result = 0;\n\tlong index = 0;\n\twhile(index < string.length)\n\
    \t{\n\t\tlong index_found = string.indexOf(substring, index);\n\t\tif(index_found\
    \ != -1)\n\t\t{\n\t\t\tresult += 1;\n\t\t\tindex = index_found + 1;\n\t\t}\n\t\
    \telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Return a new\
    \ string with all the repetitions of a given substring replaced by the given text.\n\
    \    >>> replace_repetitions(\"ababababa\", \"ab\", \"x\")\n    \"xxxa\"\n   \
    \ >>> replace_repetitions(\"a\", \"a\", \"x\")\n    \"x\"\n    >>> replace_repetitions(\"\
    \", \"\", \"x\")\n    \"\"\n    >>> replace_", "{\n    long result = 0;\n    auto\
    \ range = string.length;\n    while (true) \n    {\n        auto current = string.indexOf(substring,\
    \ 0, range);\n        if (current == string.length)\n            break;\n    \
    \    result++;\n        range = current + 1;\n    }\n    return result;\n}\n/*\n\
    \ Find all indexes of a given substring in the original string. Count overlaping\
    \ cases.\n    >>> find_all_indexes(\"\", \"a\")\n    []\n    >>> find_all_indexes(\"\
    aaa\", \"a\")\n    [0L, 1L, 2L]\n    >>> find_all_indexes(\"aaaa\", \"aa\")\n\
    \    [0L, 1L, 2L]\n*/\nTuple!(long[], long[]) find_all_indexes(string string,\
    \ string substring)\n{\n    long[] result;\n    long[] lenghts;\n    auto range\
    \ = string.length;\n    while (true) \n    {\n        auto current = string.indexOf(substring,\
    \ 0, range);\n        if (current == string.length)\n            break;\n    \
    \    result ~= current;\n        lenghts ~= substring.length;\n        range =\
    \ current + 1;\n    }\n    return tuple(result, lenghts);\n}", "{\n    auto result\
    \ = 0L;\n    auto sub_length = substring.length;\n    for (auto i = 0; i <= string.length\
    \ - sub_length; i++)\n    {\n        if (string[i .. i + sub_length] == substring)\n\
    \        {\n            result++;\n        }\n    }\n    return result;\n}", "{\n\
    \    ulong long how_many = 0;\n    foreach(index, string_index; iterate(string))\
    \ \n    {\n        if(compare(string[index .. $], substring) == 0)\n        {\n\
    \            how_many++;\n        }\n    }\n    return how_many;\n}\n/*\n    Find\
    \ all the possible ways the slots can be filled.\n    >>> run_permutations(\"\"\
    , \"\")\n    []\n    >>> run_permutations(\"a\", \"aaa\")\n    [\"aaa\"]\n   \
    \ >>> run_permutations(\"abc\", \"abc\")\n    [\"abc\"]\n    >>> run_permutations(\"\
    ab\", \"aabb\")\n    [\"aabb\", \"abba\"]\n    >>> run_permutations(\"aa\", \"\
    aabb\")\n    [\"aabb\", \"abba\"]\n    >>> run_permutations(\"aab\", \"aabb\"\
    )\n    [\"aabb\", \"abba\"]\n    >>> run_permutations(\"abab\", \"aabb\")\n  \
    \  [\"aabb\", \"abba\"]\n    >>> run_permutations(\"aba\", \"aabb\")\n    [\"\
    aabb\", \"abba\"]\n    >>> run_permutations(\"abb\", \"aabb\")\n    [\"aabb\"\
    , \"abba\"]\n*/\nstring[] run_permutations(string pattern, string string) \n{\n\
    \    import std.algorithm;\n    import std.stdio;\n    import std.range;\n   \
    \ if(compare(pattern, string) == 0) \n    {\n        return [string];\n    }\n\
    \    string[] permutations = [];\n    int permutation_size = pattern.length;\n\
    \    int index = 0;\n    while(index < string.length) \n    {\n        string\
    \ permutation = string[index .. index + permutation_size];\n        permutations\
    \ ~= permutation;\n        index += permutation_size;\n    }\n    return permutations;\n\
    }\n/*\n    Find all the possible ways the slots can be filled.\n    >>> run_word_permutations(\"\
    \", \"\")\n    []\n    >>> run_word_permutations(\"a\", \"aaa\")\n    [\"aaa\"\
    ]\n    >>> run_word_permutations(\"abc\", \"abc\")\n    [\"abc\"]\n    >>> run",
  "{\n    long res = 0;\n    long index = 0;\n    int len = substring.length;\n  \
    \  while ((index = string.find(substring, index)) != -1) \n    {\n        res++;\n\
    \        index++;\n    }\n    return res;\n}", "{\n    // 1. find all occurences\
    \ in string and count.\n    long count = 0;\n    for (size_t i = 0; i < string.length;\
    \ ++i)\n    {\n        if (string[i .. i + substring.length] == substring)\n \
    \       {\n            ++count;\n        }\n    }\n    return count;\n}\n/*\n\
    \    You are given a string consisting of only the characters 'R', 'G', and 'B'.\n\
    \    Write a function which returns a string containing all of the possible two-character\
    \ \n    combinations of the original string, in alphabetical order.\n    >>> two_character_combinations(\"\
    RB\")\n    [\"BR\", \"GB\", \"GR\"]\n    >>> two_character_combinations(\"RRGGBB\"\
    )\n    [\"BBGG\", \"BBGR\", \"BBRG\", \"BGBG\", \"BGBR\", \"BGRG\", \"BRBG\",\
    \ \"BRGR\", \"GBBG\", \"GBBR\", \"GBRG\", \"GBRR\", \"GRBG\", \"GRBR\", \"GRGB\"\
    , \"GRGR\", \"RBGG\", \"RBGR\", \"RBRG\", \"RGBG\", \"RGBR\", \"RGRG\", \"RRBG\"\
    , \"RRBR\", \"RRGB\", \"RRGR\"]\n    >>> two_character_combinations(\"\")\n  \
    \  []\n    >>> two_character_combinations(\"B\")\n    []\n*/\nstring[] two_character_combinations(string\
    \ string)\n{\n    // 1. generate all possible combinations of two-character combinations\
    \ of the original string, in alphabetical order.\n    // use distinct array to\
    \ remove duplicates.\n    static string[] gen_combinations(size_t size, string\
    \ string)\n    {\n        static int[] gen_indexes(size_t size, size_t string_size)\n\
    \        {\n            return size < 1 ? typeof(return).init : \n           \
    \     filter!(idx => idx < string_size)(chain(iota(0, string_size), 0, gen_indexes(size\
    \ - 1, string_size)));\n        }\n        return map!(chrs => iota(0, chrs.length).map!(idx\
    \ => string[chrs[idx]]", "{\n    long count;\n    size_t len = string.length;\n\
    \    size_t sublen = substring.length;\n    if (len < sublen)\n        return\
    \ 0;\n    if (len == sublen)\n        return string == substring ? 1 : 0;\n  \
    \  while (string.length >= sublen) \n    {\n        if (string.startsWith(substring))\
    \ \n        {\n            count++;\n            string = string[sublen..$];\n\
    \        }\n        else\n            string = string[1..$];\n    }\n    return\
    \ count;\n}\n/*\n    Find how many times a given substring can be found in the\
    \ original string.", "{\n    long result = 0;\n    long len_substring = substring.length;\n\
    \    long len_string = string.length;\n    long len_substring_minus_one = len_substring\
    \ - 1;\n    for (long i = 0; i < len_string; i++) \n    {\n        if (string[i\
    \ .. $] == substring) \n        {\n            result++;\n            i += len_substring_minus_one;\n\
    \        }\n    }\n    return result;\n}", "{\n    long i = 0L;\n    long substring_length\
    \ = substring.length;\n    foreach(index, character; string)\n    {\n        if(character\
    \ == substring[0])\n        {\n            if(string[index..index + substring_length]\
    \ == substring)\n            {\n                i++;\n            }\n        }\n\
    \    }\n    return i;\n}\n/*\n    Find second occurence of given substring in\
    \ the original string. It\u2019s ok if the first occurence is overlapping.\n \
    \   >>> second_occurence(\"a\", \"a\")\n    1L\n    >>> second_occurence(\"aaaa\"\
    , \"aa\")\n    2L\n    >>> second_occurence(\"aaa\", \"aa\")\n    1L\n    >>>\
    \ second_occurence(\"bananablaa\", \"na\")\n    5L\n*/\nlong second_occurence(string\
    \ string, string substring) \n{\n    long i = 0L;\n    long substring_length =\
    \ substring.length;\n    foreach(index, character; string)\n    {\n        if(character\
    \ == substring[0])\n        {\n            if(string[index..index + substring_length]\
    \ == substring)\n            {\n                i++;\n            }\n        }\n\
    \        if(i == 2)\n        {\n            return index;\n        }\n    }\n\
    \    return -1L;\n}", "{\n    long found = 0;\n    for (size_t i = 0; i < string.length;)\
    \ \n    {\n        size_t index = string.find(substring, i);\n        if (index\
    \ == string.npos) \n        {\n            break;\n        }\n        i = index\
    \ + 1;\n        found++;\n    }\n    return found;\n}", "{\n    long n = 0;\n\
    \    size_t j = 0;\n    foreach (i, const ch; string) \n    {\n        if (ch\
    \ == substring[j]) \n        {\n            if (++j == substring.length) \n  \
    \          {\n                ++n;\n                j = 0;\n            }\n  \
    \      } \n        else \n        {\n            j = 0;\n        }\n    }\n  \
    \  return n;\n}\n/*\n    Check if a string is a palindrome.\n    >>> is_palindrome(\"\
    abba\")\n    true\n    >>> is_palindrome(\"abc\")\n    false\n    >>> is_palindrome(\"\
    toot\")\n    true\n*/", "{\n    size_t last_idx = 0;\n    size_t substring_size\
    \ = substring.length;\n    long count = 0;\n    while(true) \n    {\n        size_t\
    \ idx = string.find(substring, last_idx);\n        if(idx == string.npos)\n  \
    \          break;\n        count++;\n        last_idx = idx + substring_size;\n\
    \    }\n    return count;\n}", "{\n    long begin = 0L;\n    long number_of_times\
    \ = 0L;\n    while (true)\n    {\n        auto pos = string.find(substring, begin);\n\
    \        if (pos == string.npos)\n            break;\n        begin = pos + 1L;\n\
    \        number_of_times += 1L;\n    }\n    return number_of_times;\n}", "{\n\
    \    long count = 0;\n    long pos = 0;\n    while ((pos = string.find(substring,\
    \ pos)) != string.npos) \n    {\n        count++;\n        pos += substring.length();\n\
    \    }\n    return count;\n}\n/*\nThis function should return all permutations\
    \ of the string given to it. The returned list should be sorted.\n    >>> sorted(permutations(\"\
    a\"))\n    [\"a\"]\n    >>> sorted(permutations(\"ab\"))\n    [\"ab\", \"ba\"\
    ]\n    >>> sorted(permutations(\"abc\"))\n    [\"abc\", \"acb\", \"bac\", \"bca\"\
    , \"cab\", \"cba\"]\n*/\nstring[] permutations(string s) \n{\n    if (s.length\
    \ == 1) \n    {\n        return [s];\n    }\n    string[] result = [];\n    foreach\
    \ (char c; s) \n    {\n        string r = s;\n        r.remove(c);\n        foreach\
    \ (string perm; permutations(r)) \n        {\n            result ~= c ~ perm;\n\
    \        }\n    }\n    return result;\n}\n/*\nGiven a string, return the string\
    \ in reverse.\n    >>> reverse(\"a\")\n    \"a\"\n    >>> reverse(\"aa\")\n  \
    \  \"aa\"\n    >>> reverse(\"aaa\")\n    \"aaa\"\n    >>> reverse(\"ab\")\n  \
    \  \"ba\"\n    >>> reverse(\"aabb\")\n    \"bbaa\"\n    >>> reverse(\"aabbcc\"\
    )\n    \"ccbbaa\"\n*/\nstring reverse(string s) \n{\n    if (s.length == 1) \n\
    \    {\n        return s;\n    }\n    return reverse(s[1..$]) ~ s[0..0];\n}\n\
    /*\nThis function should return a string that is the concatenation of all the\
    \ strings given to it. But if any of the strings are None, they should be ignored.\n\
    \    >>> join_with_none(\"a\", None, \"b\")\n    \"ab\"\n    >>> join_with_none(\"\
    a\", \"b\", None)\n    \"ab\"\n    >>> join_with_none(\"a\", None, \"b\", None)",
  "{\n    long result = 0;\n    size_t position = 0;\n    while(true)\n    {\n   \
    \     position = string.find(substring, position);\n        if(position == string.npos)\n\
    \            break;\n        else \n        {\n            ++result;\n       \
    \     ++position;\n        }\n    }\n    return result;\n}", "{\n    if (string.length\
    \ < substring.length)\n        return 0L;\n    long counter = 0L;\n    for (size_t\
    \ s = 0; s < string.length; ++s) \n    {\n        if (string[s .. $] == substring)\n\
    \            ++counter;\n    }\n    return counter;\n}\n/*\n Returns how many\
    \ times a given substring is appearing in the original string. No overlap.\n \
    \   >>> how_many_times_non_overlapping(\"\", \"a\")\n    0L\n    >>> how_many_times_non_overlapping(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times_non_overlapping(\"aaaa\", \"aa\"\
    )\n    2L\n*/\nlong how_many_times_non_overlapping(string string, string substring)\
    \ \n{\n    if (string.length < substring.length)\n        return 0L;\n    long\
    \ counter = 0L;\n    for (size_t s = 0; s < string.length; ++s) \n    {\n    \
    \    if (string[s .. $] == substring)\n        {\n            ++counter;\n   \
    \         s += substring.length - 1;\n        }\n    }\n    return counter;\n\
    }\n/*\n Return how many times substring appears in string. Overlapping is allowed.\n\
    \    >>> how_many_times_v2(\"\", \"a\")\n    0L\n    >>> how_many_times_v2(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times_v2(\"aaaa\", \"aa\")\n    3L\n \
    \   \n    >>> how_many_times_v2(\"asdfghasdfgh\", \"as\")\n    2L\n*/\nlong how_many_times_v2(string\
    \ string, string substring) \n{\n    if (string.length < substring.length)\n \
    \       return 0L;\n    long counter = 0L;\n    for (size_t s = 0; s < string.length;\
    \ ++s) \n    {\n        if (string[s .. $].startsWith(substring))\n          \
    \  ++counter;\n    }\n    return counter;\n}", "{\n\tlong result = 0;\n\tlong\
    \ length = string.length;\n\tlong substring_length = substring.length;\n\tlong\
    \ substring_to_check_length = substring_length;\n\tif (substring_length == 0)\n\
    \t{\n\t\treturn result;\n\t}\n\telse if (length < substring_length)\n\t{\n\t\t\
    return result;\n\t}\n\telse\n\t{\n\t\twhile (substring_to_check_length <= length)\n\
    \t\t{\n\t\t\tif (string[substring_to_check_length - substring_length .. substring_to_check_length]\
    \ == substring)\n\t\t\t{\n\t\t\t\tresult++;\n\t\t\t}\n\t\t\tsubstring_to_check_length++;\n\
    \t\t}\n\t\treturn result;\n\t}\n}", "{\n\t//cout << \"how_many_times: \" << string\
    \ << \", \" << substring << endl;\n\tauto pos = 0L;\n\tauto count = 0L;\n\twhile(true)\n\
    \t{\n\t\t//cout << \"pos:\" << pos << endl;\n\t\tpos = string.find(substring,\
    \ pos);\n\t\tif(pos == -1)\n\t\t\tbreak;\n\t\t++count;\n\t\tpos += substring.length;\n\
    \t}\n\t//cout << \"how_many_times: \" << count << endl;\n\treturn count;\n}",
  "{\n    long count = 0;\n    auto pos = 0;\n    while (true) \n    {\n        pos\
    \ = string.find(substring, pos);\n        if (pos == string.npos) break;\n   \
    \     pos++;\n        count++;\n    }\n    return count;\n}", "{\n    if (substring.length\
    \ == 0) \n    {\n        return 0;\n    }", "{\n\tlong count = 0;\n\tint index\
    \ = 0;\n\tint prevIndex = 0;\n\tauto str = typeof(string)(string);\n\tauto substr\
    \ = typeof(string)(substring);\n\t\n\twhile (index = str.find(substr, prevIndex))\n\
    \t{\n\t\t++count;\n\t\tprevIndex = index + 1;\n\t}\n\treturn count;\n}\n/*\n \
    \   >>> how_many_times(\"\", \"\")\n    0L\n    >>> how_many_times(\"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc",
  "{\n    auto sz = string.length;\n    auto ssz = substring.length;\n    if (ssz\
    \ > sz) return 0;\n    long cnt = 0;\n    for (size_t i = 0; i < sz - ssz + 1;\
    \ i++)\n    {\n        if (string[i..ssz + i] == substring) cnt++;\n    }\n  \
    \  return cnt;\n}", "{\n    return string.count(substring);\n}", "{\n    if (string.empty)\
    \ return 0;\n    long n = 0;\n    foreach (i; 0 .. string.length - substring.length\
    \ + 1) \n    {\n        if (string[i .. i + substring.length - 1] == substring)\n\
    \            n++;\n    }\n    return n;\n}", "{\n\tlong count = 0;\n\tforeach(a;iota(string.length-substring.length+1))\n\
    \t{\n\t\tstring tstr = string[a..$];\n\t\tif(tstr.startsWith(substring))\n\t\t\
    \tcount++;\n\t}\n\treturn count;\n}", "{\n    auto count = 0L;\n    auto pos =\
    \ find(string, substring);\n    while (pos != -1) \n    {\n        count++;\n\
    \        pos = find(string[pos+1..$], substring);\n    }\n    return count;\n}",
  "{\n\timport std.range;\n\timport std.array;\n\t\n\tint[string] table = substring.indexOf.sliced;\n\
    \t\n\treturn string.indexOf.sliced\n\t.scan!(a => a + table.get(string[a], string.length))\n\
    \t.array.filter!(a => a < string.length)\n\t.length;\n}", "{\n    long times =\
    \ 0;\n    foreach(i;0..(string.length - substring.length + 1))\n    {\n      \
    \  if(string[i..i+substring.length-1] == substring)\n        {\n            times++;\n\
    \        }\n    }\n    return times;\n}", "{\n\tlong l, r;\n\tl = r = 0;\n\tlong\
    \ cnt = 0;\n\twhile (l < string.length) \n\t{\n\t\tr = find(string, substring,\
    \ l, l);\n\t\tif (r < 0) break;\n\t\tcnt++;\n\t\tl = r + 1;\n\t}\n\treturn cnt;\n\
    }", "{\n    return countOverlappingOccurrences(string, substring);\n}", "in {\n\
    \    assert(substring.length != 0);\n}\nout (size_t result) {\n    assert(result\
    \ <= string.length);\n}\nbody {\n    return size_t(count(string.findall(substring)));\n\
    }", "{\n    long counter = 0;\n    long substring_size = substring.length;\n \
    \   long string_size = string.length;\n    long k = 0;\n    // If substring is\
    \ bigger than string then we stop\n    if (substring_size > string_size) \n  \
    \  {\n        return 0;\n    }\n    for (long i = 0; i < string_size; i++) \n\
    \    {\n        // If we have found the substring in the current location\n  \
    \      if (substring[k] == string[i]) \n        {\n            k++;\n        \
    \    // If we have checked every letter of the substring\n            if (k ==\
    \ substring_size) \n            {\n                counter++;\n              \
    \  k = 0;\n            }\n        }\n        else \n        {\n            k =\
    \ 0;\n        }\n    }\n    return counter;\n}\n/*\nYou are given a string. You\
    \ need to check if the string is a palindrome or not. You need to ignore punctuation\
    \ marks while checking the same.\n    >>> palindrome_check(\"\")\n    true\n \
    \   >>> palindrome_check(\"a\")\n    true\n    >>> palindrome_check(\"aa\")\n\
    \    true\n    >>> palindrome_check(\"a.\")\n    true\n    >>> palindrome_check(\"\
    ab\")\n    false\n    >>> palindrome_check(\"aba\")\n    true\n    >>> palindrome_check(\"\
    aba.\")\n    true\n    >>> palindrome_check(\"aba!\")\n    true\n    >>> palindrome_check(\"\
    aba!!!\")\n    true\n*/", "{\n\tlong n = 0;\n\tauto pos = string.find(substring);\n\
    \tif (pos == string.length)\n\t\treturn n;\n\t\t\n\tn++;\n\twhile (pos < string.length)\n\
    \t{\n\t\tauto pos2 = string.find(substring, pos + 1);\n\t\tif (pos2 == string.length)\n\
    \t\t\tbreak;\n\t\tn++;\n\t\tpos = pos2;\n\t}\n\treturn n;\n}", "{\n\t\n\tlong\
    \ times = 0;\n\t\n\tif(string.length >= substring.length)\n\t{\n\t\t\n\t\tauto\
    \ max = string.length - substring.length;\n\t\t\n\t\tfor(long i = 0; i <= max;\
    \ i++)\n\t\t{\n\t\t\t\n\t\t\tif(string[i .. i + substring.length] == substring)\n\
    \t\t\t{\n\t\t\t\t\n\t\t\t\ttimes++;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\
    }\n\t\n\treturn times;\n\t\n}", "{\n    long cnt = 0;\n    long max = string.length\
    \ - substring.length;\n    foreach (i; 0..max)\n    {\n        if (string[i..i+substring.length]\
    \ == substring)\n            cnt++;\n    }\n    return cnt;\n}\n/*\nSum the values\
    \ in the input string, assume that the input string has only digits. If the input\
    \ is \"\", assume its value to be 0.\n    >>> sum_digits(\"\")\n    0L\n    >>>\
    \ sum_digits(\"a\")\n    0L\n    >>> sum_digits(\"123456789\")\n    45L\n*/\n\
    long sum_digits(string string) \n{\n    long sum = 0;\n    foreach (i; 0..string.length)\n\
    \    {\n        if (isDigit(string[i]))\n            sum += to!long(string[i]);\n\
    \    }\n    return sum;\n}\n/*\n    Write a function that returns the longest\
    \ substring that is a palindrome.\n        >>> longest_palindrome(\"aaa\")\n \
    \       \"aaa\"\n        >>> longest_palindrome(\"aba\")\n        \"aba\"\n  \
    \      >>> longest_palindrome(\"aabbaad\")\n        \"aabbaa\"\n*/\nstring longest_palindrome(string\
    \ string) \n{\n    // TODO: Your code here\n    return \"\";\n}", "{\n    long\
    \ count = 0;\n    int pos = 0;\n    while (pos < string.length) \n    {\n    \
    \    pos = string.find(substring, pos);\n        if (pos == -1) \n        {\n\
    \            break;\n        }\n        count += 1;\n        pos += 1;\n    }\n\
    \    return count;\n}", "{\n    long n = 0;\n    for (long i = 0; i < string.length;\
    \ i++)\n    {\n        size_t found = string.find(substring, i);\n        if (found\
    \ != string.npos)\n        {\n            n++;\n            i = found;\n     \
    \   }\n        else\n        {\n            break;\n        }\n    }\n    return\
    \ n;\n}\n/*\nGiven a list of numbers, return a list where\nall adjacent == elements\
    \ have been reduced to a single element,\nso [1, 2, 2, 3] returns [1, 2, 3]. You\
    \ may create a new list or\nmodify the passed in list.\n    >>> remove_adjacent([1,\
    \ 2, 2, 3])\n    [1, 2, 3]\n    >>> remove_adjacent([2, 2, 3, 3, 3])\n    [2,\
    \ 3]\n    >>> remove_adjacent([])\n    []\n*/", "{\n    return count(reduce!((a,\
    \ x) => a.opCat(x))(map!(c => to!string(c))(iota(0L, string.length - substring.length\
    \ + 1L))));\n}", "nothrow \npure \nin {\n    assert(string.length > 0);\n    assert(substring.length\
    \ > 0);\n}\nout (result) {\n    assert(result >= 0);\n}\nbody {\n    long result\
    \ = 0;\n    foreach (index; 0 .. string.length) {\n        if (string[index ..\
    \ $].startsWith(substring))\n            result++;\n    }\n    return result;\n\
    }\n@safe unittest {\n    assert(how_many_times(\"\", \"a\") == 0);\n    assert(how_many_times(\"\
    aaa\", \"a\") == 3);\n    assert(how_many_times(\"aaaa\", \"aa\") == 3);\n}\n\
    /*\n Find the number of occurrences of a given substring inside a string.\n  \
    \  >>> string_occurrences(\"\", \"abc\")\n    0L\n    >>> string_occurrences(\"\
    abc\", \"\")\n    0L\n    >>> string_occurrences(\"\", \"\")\n    0L\n    >>>\
    \ string_occurrences(\"abc\", \"abc\")\n    1L\n    >>> string_occurrences(\"\
    aabc\", \"abc\")\n    1L\n    >>> string_occurrences(\"aabcabc\", \"abc\")\n \
    \   2L\n    >>> string_occurrences(\"ababab\", \"aba\")\n    2L\n    >>> string_occurrences(\"\
    bababa\", \"aba\")\n    2L\n    >>> string_occurrences(\"bababa\", \"abab\")\n\
    \    0L\n    >>> string_occurrences(\"bababa\", \"ab\")\n    3L\n*/\nlong string_occurrences(string\
    \ string, string substring) \nnothrow \npure \nin {\n    assert(string.length\
    \ > 0);\n    assert(substring.length > 0);\n}\nout (result) {\n    assert(result\
    \ >= 0);\n}\nbody {\n    long result = 0;\n    foreach (index; 0 .. string.length)\
    \ {\n        if (string[index .. $].startsWith(substring))\n            result++;\n\
    \    }\n    return result;\n}\n@safe unittest {\n    assert(string_occurrences(\"",
  "{\n\t\tif (substring.length == 0)\n\t\t\treturn 0;\n\t\tlong result = 0;\n\t\t\
    size_t pos = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tpos = string.find(substring, pos);\n\
    \t\t\tif (pos == string.npos)\n\t\t\t\tbreak;\n\t\t\tresult++;\n\t\t\tpos++;\n\
    \t\t}\n\t\treturn result;\n}", "in \n{\n    assert(!is(typeof(substring) == ubyte[]));\n\
    \    assert(!is(typeof(substring) == dchar[]));\n    assert(!is(typeof(substring)\
    \ == wchar[]));\n    assert(!is(typeof(substring) == char[]));\n    assert(!is(typeof(substring)\
    \ == void[]));\n    assert(!is(typeof(substring) == bool[]));\n    assert(!is(typeof(substring)\
    \ == float[]));\n    assert(!is(typeof(substring) == double[]));\n    assert(!is(typeof(substring)\
    \ == real[]));\n    assert(!is(typeof(substring) == ifloat[]));\n    assert(!is(typeof(substring)\
    \ == idouble[]));\n    assert(!is(typeof(substring) == ireal[]));\n    assert(!is(typeof(substring)\
    \ == cfloat[]));\n    assert(!is(typeof(substring) == cdouble[]));\n    assert(!is(typeof(substring)\
    \ == creal[]));\n    assert(!is(typeof(substring) == short[]));\n    assert(!is(typeof(substring)\
    \ == ushort[]));\n    assert(!is(typeof(substring) == int[]));\n    assert(!is(typeof(substring)\
    \ == uint[]));\n    assert(!is(typeof(substring) == long[]));\n    assert(!is(typeof(substring)\
    \ == ulong[]));\n    assert(!is(typeof(substring) == cent[]));\n    assert(!is(typeof(substring)\
    \ == ucent[]));\n    assert(!is(typeof(substring) == bool[]));\n    assert(!is(typeof(substring)\
    \ == byte[]));\n    assert(!is(typeof(substring) == size_t[]));\n    assert(!is(typeof(substring)\
    \ == dchar[]));\n    assert(", "{\n    long n=0L;\n    long size = string.length;\n\
    \    long size_substring = substring.length;\n    for(long i=0L; i<size; i++)\n\
    \    {\n        if(string[i..i+size_substring] == substring)\n        {\n    \
    \        n+=1L;\n        }\n    }\n    return n;\n}", "{\n    long ret = 0;\n\
    \    size_t p = 0;\n    while (p < string.length)\n    {\n        if (string[p..$].startsWith(substring))\n\
    \        {\n            ++ret;\n            p += substring.length;\n        }\n\
    \        else\n        {\n            ++p;\n        }\n    }\n    return ret;\n\
    }\n/*\nImplement the Caesar cipher.", "{\n    long found = 0;\n    size_t len\
    \ = string.length;\n    size_t sublen = substring.length;\n    if (len < sublen)\
    \ \n    {\n        return 0;\n    }\n    size_t j = 0;\n    size_t k = 0;\n  \
    \  while (j < len) \n    {\n        if (string[j] == substring[k]) \n        {\n\
    \            j++;\n            k++;\n            if (k == sublen) \n         \
    \   {\n                found++;\n                k = 0;\n            }\n     \
    \   } \n        else \n        {\n            j = j - k + 1;\n            k =\
    \ 0;\n        }\n    }\n    return found;\n}", "{\n    long count = 0;\n    for\
    \ (size_t pos = 0; pos < string.length; pos++) \n    {\n        if (string[pos\
    \ .. $] < substring) \n        {\n            break;\n        }\n        else\
    \ if (string[pos .. $].startsWith(substring)) \n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times2(string string, string\
    \ substring) \n{\n    long count = 0;\n    size_t pos = 0;\n    while (pos !=\
    \ string.length) \n    {\n        if (string[pos .. $] < substring) \n       \
    \ {\n            break;\n        }\n        else if (string[pos .. $].startsWith(substring))\
    \ \n        {\n            count++;\n            pos += substring.length;\n  \
    \      }\n        else \n        {\n            pos++;\n        }\n    }\n   \
    \ return count;\n}", "{\n\tif(substring.length == 0)\n\t\treturn 0;\n\tlong ret\
    \ = 0;\n\tsize_t pos = 0;\n\twhile(true)\n\t{\n\t\tpos = string.find(substring,\
    \ pos);\n\t\tif(pos == string.npos)\n\t\t\tbreak;\n\t\t++ret;\n\t\t++pos;\n\t\
    }\n\treturn ret;\n}", "{\n    string haystack = string;\n    string needle = substring;\n\
    \    long k = 0;\n    for (int i = 0; i <= haystack.length-needle.length; ++i)\n\
    \    {\n        if (haystack[i..i+needle.length] == needle)\n        {\n     \
    \       k++;\n        }\n    }\n    return k;\n}", "{\n    return string.count(substring);\n\
    }", "{\n    string remaining_string = string;\n    long num_times = 0L;\n    while\
    \ (remaining_string != \"\") \n    {\n        immutable index = remaining_string.find(substring);\n\
    \        if (index == -1) \n        {\n            break;\n        }\n       \
    \ num_times += 1L;\n        immutable substring_length = substring.length;\n \
    \       remaining_string = remaining_string[index + substring_length .. $];\n\
    \    }\n    return num_times;\n}", "{\n    long count = 0;\n    long pos = 0;\n\
    \    long substring_len = substring.length;\n    long string_len = string.length;\n\
    \    long string_len_minus_substring_len = string_len - substring_len;\n    while\
    \ (pos <= string_len_minus_substring_len) \n    {\n        if (string[pos..pos\
    \ + substring_len] == substring) \n        {\n            count += 1;\n      \
    \      pos += substring_len;\n        } \n        else \n        {\n         \
    \   pos += 1;\n        }\n    }\n    return count;\n}\n/*\n    >>> dedup(\"aaabbc\"\
    )\n    \"abc\"\n    >>> dedup(\"aaab\")\n    \"ab\"\n    >>> dedup(\"aabc\")\n\
    \    \"abc\"\n*/\nstring dedup(string string)\n{\n    string res = \"\";\n   \
    \ long pos = 0;\n    while (pos < string.length) \n    {\n        long next_pos\
    \ = pos + 1;\n        while (next_pos < string.length && string[pos] == string[next_pos])\
    \ \n        {\n            next_pos += 1;\n        }\n        res ~= string[pos];\n\
    \        pos = next_pos;\n    }\n    return res;\n}\n/*\n    >>> is_isogram(\"\
    Dermatoglyphics\")\n    true\n    >>> is_isogram(\"aba\")\n    false\n    >>>\
    \ is_isogram(\"moOse\")\n    false\n*/", "    in (string.length > 0 && substring.length\
    \ > 0) \n{\n    return cast(long)std.algorithm.count(string.chunks(substring.length),\
    \ string.chunks(substring.length).length, s => s == substring);\n}", "{\n    long\
    \ ret = 0;\n    for (size_t i = 0; i < string.length; i++) \n    {\n        if\
    \ (string[i..i + substring.length] == substring)\n            ret++;\n    }\n\
    \    return ret;\n}", "{\n    auto end = string.length;\n    if(substring.length\
    \ > end) return 0;\n    long count = 0;\n    long index = 0;\n    while(index\
    \ < end)\n    {\n        auto pos = string.indexOf(substring, index);\n      \
    \  if(pos == -1) break;\n        count++;\n        index = pos + 1;\n    }\n \
    \   return count;\n}", "{\n    return size_t.popCount(string.countUntil(substring));\n\
    }", "{\n    long result = 0;\n    long last = string.length - substring.length;\n\
    \    foreach (i, __; i <= last; ++i) \n    {\n        if (string[i .. i + substring.length]\
    \ == substring)\n            ++result;\n    }\n    return result;\n}\n// how_many_times\n\
    \ \n/*\n Find the largest substring with the same number of \"0\" and \"1\" characters.\n\
    \    >>> largest_binary_substring(\"0011000101\")\n    \"0011\"\n    >>> largest_binary_substring(\"\
    00001101101\")\n    \"000011\"\n*/\nstring largest_binary_substring(string s)\
    \ \n{\n    string result = \"\";\n    long size = 0;\n    long len = s.length;\n\
    \    long last = len - 1;\n    foreach (left, right; right <= last; ++right) \n\
    \    {\n        if (s[right] == '0') \n        {\n            if (s[left] == '1')\
    \ \n            {\n                ++left;\n                if (left > right)\n\
    \                    continue;\n            }\n        } \n        else \n   \
    \     {\n            if (s[left] == '0') \n            {\n                ++left;\n\
    \                if (left > right)\n                    continue;\n          \
    \  }\n        }\n        long cnt = how_many_times(s[left .. right], \"00\");\n\
    \        cnt += how_many_times(s[left .. right], \"11\");\n        long new_size\
    \ = right - left + 1 - 2 * cnt;\n        if (new_size > size) \n        {\n  \
    \          size = new_size;\n            result = s[left .. right];\n        }\n\
    \    }\n    return result;\n}\n// largest_binary_substring\n \n/*\n Provide the\
    \ Boggle class which will allow other people to write code like the following:\n\
    \    >>> import std.stdio;\n    >>> import std.range;\n    >>> import std.algorithm;\n\
    \    >>> import std.file;\n    >>> import std.typecons;\n    >>> \n    >>> auto\
    \ board = Boggle([\n", "{\n    return split(string, substring).length;\n}", "{\n\
    \    //LUCIUS: return count(filter!(a => a == substring)(iota(0, string.length\
    \ - substring.length + 1)\n\t// .map!(a => string[a .. a + substring.length -\
    \ 1])));\n\tlong count = 0;\n\tfor(size_t i = 0; i < string.length - substring.length\
    \ + 1; i++)\n\t{\n\t\tif(string[i .. i + substring.length - 1] == substring)\n\
    \t\t\tcount++;\n\t}\n\treturn count;\n}", "{\n    int sub_length = substring.length;\n\
    \    int length = string.length;\n    auto string_begin = string.toUTF8z.save;\n\
    \    auto string_end = string_begin + length;\n    auto sub_begin = substring.toUTF8z.save;\n\
    \    auto sub_end = sub_begin + sub_length;\n    int count = 0;\n    while(string_begin\
    \ != string_end)\n    {\n        auto it = search(string_begin, string_end, sub_begin,\
    \ sub_end);\n        if(it == string_end)\n            break;\n        count++;\n\
    \        string_begin = it + sub_length;\n    }\n    return count;\n}\n/*\n  \
    \  Flip a binary tree upside down.\n    >>> auto t = Node(1, Node(2, Node(3, Node(4,\
    \ Node(5, Node(6, Node(7, null, null), null), null), null), null), null), null);\n\
    \    >>> auto t2 = flipTree(t);\n    >>> map!(x => x.value)(t2.children)\n   \
    \ [6, 7]\n    >>> map!(x => x.value)(t2.children[0].children)\n    [5]\n    >>>\
    \ map!(x => x.value)(t2.children[0].children[0].children)\n    [4]\n    >>> map!(x\
    \ => x.value)(t2.children[0].children[0].children[0].children)\n    [3]\n    >>>\
    \ map!(x => x.value)(t2.children[0].children[0].children[0].children[0].children)\n\
    \    [2]\n    >>> map!(x => x.value)(t2.children[0].children[0].children[0].children[0].children[0].children)\n\
    \    [1]\n*/\nstruct Node {\n    int value;\n    Node* left;\n    Node* right;\n\
    \    Node(int value, Node* left, Node* right)\n    {\n        this.value = value;\n\
    \        this.left = left;\n        this.right = right;\n    }\n}", "    pure\
    \ nothrow @safe @nogc\n{\n    long count = 0;\n    foreach(i; 0 .. string.length\
    \ - substring.length + 1) \n    {\n        if(string[i .. i + substring.length\
    \ - 1] == substring) \n        {\n            count++;\n        }\n    }\n   \
    \ return count;\n}\n \n/*\n    >>> egyptian_fraction(2, 3)\n    [\"1/2\", \"1/6\"\
    ]\n    >>> egyptian_fraction(8, 11)\n    [\"1/2\", \"1/7\", \"1/59\", \"1/5163\"\
    , \"1/53307975\"]\n    >>> egyptian_fraction(3, 5)\n    [\"1/2\", \"1/3\"]\n \
    \   >>> egyptian_fraction(10, 6)\n    [\"1/2\", \"1/3\"]\n    >>> egyptian_fraction(10,\
    \ 3)\n    [\"1/3\", \"1/6\", \"1/12\", \"1/24\", \"1/480\", \"1/9600\", \"1/1920000\"\
    , \"1/384000000\", \"1/76800000000\", \"1/15360000000000\", \"1/3072000000000000\"\
    , \"1/614400000312475200\", \"1/12288000062495001600\", \"1/24576000012999000320000\"\
    , \"1/4915200002599800064000000\", \"1/983040000519920012800000\", \"1/19660800001039840256000000\"\
    , \"1/39321600002079680512000000\", \"1/78643200004159361025000000\", \"1/1572864000083187222000000\"\
    , \"1/314572800016637444300000\", \"1/629145605933140564800000\", \"1/125829121186628113000000\"\
    , \"1/251658242371356226000000\", \"1/50331648474213524600000\", \"1/10066329694832705000000\"\
    , \"1/2013265938966540000000\", \"1/4026531877933080000000\", \"", "{\n    long\
    \ occurences = 0;\n    long start = 0;\n    while(1) \n    {\n        start =\
    \ find(string, substring, start);\n        if(start == -1)\n            break;\n\
    \        occurences++;\n        start++;\n    }\n    return occurences;\n}", "{\n\
    \    long n = 0;\n    long pos = 0;\n    while(true)\n    {\n        long found\
    \ = string.find(substring, pos);\n        if(found == string.npos) break;\n  \
    \      n++;\n        pos = found + 1;\n    }\n    return n;\n}", "{\n    long\
    \ res = 0;\n    size_t idx = 0;\n    while ( (idx = string.find(substring, idx))\
    \ != string.npos )\n    {\n        res++;\n        idx += substring.length();\n\
    \    }\n    return res;\n}", "{\n    long count;\n    for (auto pos = 0; pos <\
    \ string.length;) \n    {\n        auto found = string.find(substring, pos);\n\
    \        if (found == -1)\n            break;\n        count++;\n        pos =\
    \ found + 1;\n    }\n    return count;\n}\nlong how_many_times(string string,\
    \ string substring) \n{\n    long count;\n    for (auto pos = 0; pos < string.length;)\
    \ \n    {\n        auto found = string.find(substring, pos);\n        if (found\
    \ == -1)\n            break;\n        count++;\n        pos = found + 1;\n   \
    \ }\n    return count;\n}\nlong how_many_times(string string, string substring)\
    \ \n{\n    long count;\n    for (auto pos = 0; pos < string.length;) \n    {\n\
    \        auto found = string.find(substring, pos);\n        if (found == -1)\n\
    \            break;\n        count++;\n        pos = found + 1;\n    }\n    return\
    \ count;\n}\nlong how_many_times(string string, string substring) \n{\n    long\
    \ count;\n    for (auto pos = 0; pos < string.length;) \n    {\n        auto found\
    \ = string.find(substring, pos);\n        if (found == -1)\n            break;\n\
    \        count++;\n        pos = found + 1;\n    }\n    return count;\n}\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count;\n    for\
    \ (auto pos = 0; pos < string.length;) \n    {\n        auto found = string.find(substring,\
    \ pos);\n        if (found == -1)\n            break;\n        count++;\n    \
    \    pos = found + 1;\n    }\n    return count;\n}\nlong how_many_times(string\
    \ string, string substring) \n{\n    long count;\n    for (auto pos = 0; pos <\
    \ string.length;) \n    {\n        auto found = string.find(substring, pos);\n\
    \        if (found == -1)\n           ", "{\n    long count = 0;\n    long index\
    \ = 0;\n    while (true) \n    {\n        index = string.find(substring, index);\n\
    \        if (index == string.npos) \n        {\n            break;\n        }\n\
    \        ++count;\n        ++index;\n    }\n    return count;\n}", "{\n    long\
    \ overlaps = 0;\n    long i = 0;\n    auto pos = string.find(substring);\n   \
    \ while (pos != string.npos) \n    {\n        overlaps += 1;\n        i = pos\
    \ + 1;\n        pos = string.find(substring, i);\n    }\n    return overlaps;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Do not count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    1L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    2L\n    >>> how_many_times(\"ababab\", \"aba\")\n    2L\n    \n\
    */\nlong how_many_times(string string, string substring) \n{\n    long overlaps\
    \ = 0;\n    long i = 0;\n    auto pos = string.find(substring);\n    while (pos\
    \ != string.npos) \n    {\n        overlaps += 1;\n        i = pos + substring.length;\n\
    \        pos = string.find(substring, i);\n    }\n    return overlaps;\n}\n//\
    \ Substitute the first occurrence of a substring with another substring.\nstring\
    \ substitute(string string, string substring, string new_substring) \n{\n    auto\
    \ pos = string.find(substring);\n    if (pos != string.npos)\n        return string.substr(0,\
    \ pos) + new_substring + string.substr(pos + substring.length);\n    return string;\n\
    }\n/*\n Substitute all occurrences of a substring with another substring.\n  \
    \  >>> substitute(\"aba\", \"a\", \"\")\n    \"b\"\n    >>> substitute(\"aba\"\
    , \"a\", \"A\")\n    \"AbA\"\n    >>> substitute(\"ababa\", \"aba\", \"\")\n \
    \   \"\"\n    >>> substitute(\"ababa\", \"aba\", \"A\")\n    \"AA\"\n    >>> substitute(\"\
    abcabcabc\", \"abc\", \"\")\n    \"\"\n    >>> substitute(\"abcabcabc\", \"abc\"\
    , \"A\")\n    \"AAA\"\n    >>> substitute", "    in(string, substring) out(string,\
    \ substring)\n{\n    long count = 0;\n    string searchString = string;\n    while\
    \ (searchString.length)\n    {\n        if (searchString.startsWith(substring))\n\
    \        {\n            count++;\n            searchString = searchString[substring.length..$];\n\
    \        }\n        else \n        {\n            searchString = searchString[1..$];\n\
    \        }\n    }\n    return count;\n}", "{\n    return count(string.chunks(substring.length));\n\
    }", "{\n    long result = 0;\n    auto find_index = 0;\n    auto substr_len =\
    \ substring.length;\n    while (find_index != -1) \n    {\n        find_index\
    \ = string.find(substring, find_index);\n        if (find_index != -1) \n    \
    \    {\n            result += 1;\n            find_index += substr_len;\n    \
    \    }\n    }\n    return result;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times_2(string string, string\
    \ substring) \n{\n    long result = 0;\n    int position = 0;\n    while (true)\
    \ \n    {\n        position = string.find(substring, position);\n        if (position\
    \ != -1) \n        {\n            result += 1;\n            position += substring.length;\n\
    \        }\n        else \n        {\n            break;\n        }\n    }\n \
    \   return result;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times_3(string string, string\
    \ substring) \n{\n    int start_pos = 0;\n    int next_index = string.indexOf(substring,\
    \ start_pos);\n    if (next_index == -1) \n    {\n        return 0;\n    }\n \
    \   return 1 + how_many_times_3(string[start_pos .. $].replaceFirst(substring,\
    \ \"\"), substring);\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>>", "{\n    immutable\
    \ n = string.length;\n    immutable m = substring.length;\n    long matches =\
    \ 0;\n    if (n < m) return 0;\n    for (int i = 0; i < n - m + 1; i++) \n   \
    \ {\n        if (string[i .. i + m] == substring)\n            matches++;\n  \
    \  }\n    return matches;\n}\n/*\n Check if a given substring can be found in\
    \ the original string.\n    >>> is_in(\"\", \"a\")\n    false\n    >>> is_in(\"\
    a\", \"a\")\n    true\n    >>> is_in(\"aaa\", \"a\")\n    true\n*/", "{\n    long\
    \ count = 0;\n    long _substring = substring.length;\n    long index = 0;\n \
    \   while(index < string.length)\n    {\n        if(string[index .. index + _substring]\
    \ == substring)\n        {\n            count++;\n            index += _substring;\n\
    \        }\n        else\n        {\n            index++;\n        }\n    }\n\
    \    return count;\n}", "{\n    if (string.empty) return 0;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
