name: HumanEval_61_correct_bracketing
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"(\"\
  \ and \")\".\n    return true if every opening bracket has a corresponding closing\
  \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    false\n    >>> correct_bracketing(\"\
  ()\")\n    true\n    >>> correct_bracketing(\"(()())\")\n    true\n    >>> correct_bracketing(\"\
  )(()\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n"
tests: "unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
  ()\") == true);\n    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"\
  ()()(()())()\") == true);\n    assert(candidate(\"()()((()()())())(()()(()))\")\
  \ == true);\n    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\"\
  )(()\") == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
  ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
  (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n    assert(candidate(\"\
  ()()(()())()))()\") == false);\n}\nvoid main(){}"
completions: ["{\n    int balance = 0;\n    foreach(char c; brackets) {\n        if\
    \ (c == '(') balance++;\n        else if (c == ')') balance--;\n        if (balance\
    \ < 0) return false;\n    }\n    return balance == 0;\n}\n/*\n    Write a function\
    \ that will take a string of brackets (\"(\" and \")\") and return\n    the number\
    \ of missing brackets.\n   \n    >>> num_missing_brackets(\"(\")\n    1\n    >>>\
    \ num_missing_brackets(\"()\")\n    0\n    >>> num_missing_brackets(\"(()())\"\
    )\n    0\n    >>> num_missing_brackets(\")(()\")\n    2\n*/", "{\n\tint count=0;\n\
    \tforeach(ch;brackets)\n\t{\n\t\tif(ch=='(')\n\t\t\tcount++;\n\t\telse if(ch==')')\n\
    \t\t\tcount--;\n\t\tif(count<0)\n\t\t\treturn false;\n\t}\n\treturn count==0;\n\
    }", "{\n    uint count = 0;\n    foreach(char c; brackets)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\n/*\n    return true if every opening bracket has a corresponding closing\
    \ bracket.", "{\n    int counter = 0;\n    foreach(char c; brackets)\n    {\n\
    \        if(c == '(')\n            counter++;\n        else if(c == ')')\n   \
    \         counter--;\n        if(counter < 0)\n            return false;\n   \
    \ }\n    return counter == 0;\n}\n/*\n  take a list of numbers and return a tuple\
    \ of two lists where the first list\n  contains all the even numbers and the second\
    \ list contains all the odd numbers.", "{\n    int l = 0;\n    foreach(c; brackets)\n\
    \    {\n        if (c == '(')\n            l++;\n        else\n            l--;\n\
    \        if (l < 0)\n            return false;\n    }\n    return l == 0;\n}",
  "{\n    auto stack = new Stack!int();\n    foreach(c; brackets)\n    {\n       \
    \ switch(c)\n        {\n            case '(':\n                stack.push(1);\n\
    \                break;\n            case ')':\n                if(stack.empty)\
    \ return false;\n                stack.pop();\n                break;\n      \
    \  }\n    }\n    return stack.empty;\n}", "{\n    auto left_count=0, right_count=0;\n\
    \    foreach(bracket; brackets) {\n        if(bracket == '(')\n            left_count++;\n\
    \        else\n            right_count++;\n        if(right_count > left_count)\n\
    \            return false;\n    }\n    return right_count == left_count;\n}",
  "{\n    if(brackets.length == 0)\n    {\n        return true;\n    }\n    if(brackets.length\
    \ == 1)\n    {\n        return false;\n    }\n    int n_left = 0;\n    int n_right\
    \ = 0;\n    foreach(char s; brackets)\n    {\n        if(s == \"(\")\n       \
    \ {\n            n_left++;\n        }\n        else if(s == \")\")\n        {\n\
    \            n_right++;\n        }\n        if(n_right > n_left)\n        {\n\
    \            return false;\n        }\n    }\n    if(n_left != n_right)\n    {\n\
    \        return false;\n    }\n    return true;\n}\n/*\n If a string matches a\
    \ pattern of the form \"***\\***\", return true.\n    Otherwise, return false.",
  "{\n    int balance = 0;\n    int i = 0;\n    foreach(char bracket; brackets)\n\
    \    {\n        if(bracket == '(') balance++;\n        else if(bracket == ')')\
    \ balance--;\n        else throw new Exception(\"brackets contains non-bracket\
    \ characters\");\n        \n        if(balance < 0) return false;\n        i++;\n\
    \    }\n    return balance == 0;\n}\n// test\nunittest\n{\n    assert(correct_bracketing(\"\
    ()\"));\n    assert(correct_bracketing(\"(()())\"));\n    assert(!correct_bracketing(\"\
    (\"));\n    assert(!correct_bracketing(\")(()\"));\n}", "{ \n    int balance =\
    \ 0; \n    for (immutable char c : brackets) { \n        if (c == '(') \n    \
    \        balance++; \n        else if (c == ')') \n            balance--; \n \
    \       if (balance < 0) \n            return false; \n    } \n    return balance\
    \ == 0; \n} ", "{\n    scope(exit) writeln(\"!\");\n    int cnt = 0;\n    for\
    \ (immutable char c : brackets)\n    {\n        if (c == '(')\n            cnt++;\n\
    \        else if (c == ')')\n            cnt--;\n        if (cnt < 0)\n      \
    \      return false;\n    }\n    return cnt == 0;\n}", "{\n    int num = 0;\n\
    \    foreach(char c; brackets)\n    {\n        if(c == '(')\n            num++;\n\
    \        else if(c == ')')\n            num--;\n        if(num < 0)\n        \
    \    return false;\n    }\n    return num == 0;\n}", "{\n    int count = 0;\n\
    \    foreach(ch; brackets) \n    {\n        if (ch == '(') \n        {\n     \
    \       count++;\n        } \n        else if (ch == ')') \n        {\n      \
    \      count--;\n        }\n        if (count < 0) \n        {\n            return\
    \ false;\n        }\n    }\n    return count == 0;\n}", "{\n    int n = brackets.length;\n\
    \    int count = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (brackets[i]\
    \ == '(')\n        {\n            count++;\n        }\n        else\n        {\n\
    \            count--;\n        }\n        if (count < 0)\n        {\n        \
    \    return false;\n        }\n    }\n    return count == 0;\n}", "{\n    int\
    \ count = 0;\n    foreach(c; brackets)\n    {\n        if(c == '(')\n        \
    \    count++;\n        else if(c == ')')\n            count--;\n        if(count\
    \ < 0)\n            return false;\n    }\n    return count == 0;\n}\n/*\n Reorder\
    \ the elements of the array such that they are in the order of their parities.",
  "{\n    int length = brackets.length;\n    int count = 0;\n    for (int i = 0; i\
    \ < length; i++)\n    {\n        if (brackets[i] == '(')\n        {\n        \
    \    count += 1;\n        }\n        else\n        {\n            count -= 1;\n\
    \        }\n        if (count < 0) return false;\n    }\n    return count == 0;\n\
    }\n// /*\n//    rnd_select takes an array and a number of elements.\n//    It\
    \ returns a new array that contains elements chosen\n//    randomly from the original\
    \ array.\n//    */", "{\n    return brackets.count('(') == brackets.count(')');\n\
    }", "{\n    return true;\n}", "{\n    int count = 0;\n    int size = brackets.length;\n\
    \    foreach(i; 0..size)\n    {\n        if(brackets[i] == '(')\n        {\n \
    \           count++;\n        }\n        else if(brackets[i] == ')')\n       \
    \ {\n            count--;\n        }\n    }\n    return count == 0;\n}", "{\n\
    \    //*\n    int i;\n    int sum = 0;\n    foreach(ch;brackets)\n    {\n    \
    \    i++;\n        if(ch == '(')\n            sum++;\n        else if(ch == ')')\n\
    \            sum--;\n        if(sum < 0)\n            return false;\n    }\n \
    \   if(sum != 0)\n        return false;\n    return true;\n    //*/\n    //return\
    \ ((brackets.count('(') == brackets.count(')')) \n    //        && (brackets.count('(')\
    \ == brackets.count(')') + brackets.count('(') ));\n}\n/*\n    return true if\
    \ parentheses are correctly balanced in the string."]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
