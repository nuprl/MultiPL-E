name: HumanEval_14_all_prefixes
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Return array of all prefixes\
  \ from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n\
  \    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string) \n"
tests: "unittest\n{\n    alias candidate = all_prefixes;\n\n    assert(candidate(\"\
  \") == []);\n    assert(candidate(\"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\"\
  , \"asdfg\", \"asdfgh\"]);\n    assert(candidate(\"WWW\") == [\"W\", \"WW\", \"\
  WWW\"]);\n}\nvoid main(){}"
completions: ["{\n    import std.algorithm : map;\n    import std.range      : putBack;\n\
    \    import std.string     : chunk;\n    import std.conv       : to;\n    return\
    \ string.chunk(1).putBack(string).map!(a => a.to!string);\n}", "{\n    string[]\
    \ result;\n    foreach (i; 0 .. string.length)\n    {\n        result ~= string[0\
    \ .. i];\n    }\n    return result;\n}", "{\n    assert(!string.empty);\n    int\
    \ len = string.length;\n    return iota(1, len).map!(i => string[0..i])();\n}",
  "{\n    return map!(take(string))(iota(string.length + 1)).array;\n}", "{\n    auto\
    \ retval = [];\n    for (size_t i = 0; i < string.length; i++)\n    {\n      \
    \  retval ~= string[0..i];\n    }\n    return retval;\n}", "{\n    string[] result;\n\
    \    int length = string.length;\n    foreach (string substr; 0 .. length)\n \
    \   {\n        result ~= substr;\n    }\n    return result;\n}\n/*\nReturn all\
    \ suffixes of the input string\n    >>> all_suffixes(\"abc\")\n    [\"bc\", \"\
    c\", \"\"]\n*/\nstring[] all_suffixes(string string) \n{\n    return all_prefixes(string.dup.reverse);\n\
    }\n/*\nReturn the longest common prefix of the two input strings\n    >>> lcp(\"\
    abcdef\", \"abc\")\n    \"abc\"\n    >>> lcp(\"abcdef\", \"abd\")\n    \"ab\"\n\
    \    >>> lcp(\"abcdef\", \"def\")\n    \"\"\n*/\nstring lcp(string string1, string\
    \ string2) \n{\n    foreach (string1_prefix; all_prefixes(string1))\n    {\n \
    \       foreach (string2_prefix; all_prefixes(string2))\n        {\n         \
    \   if (string1_prefix == string2_prefix)\n            {\n                return\
    \ string1_prefix;\n            }\n        }\n    }\n    return \"\";\n}\n/*\n\
    Return the longest common suffix of the two input strings\n    >>> lcs(\"abcdef\"\
    , \"def\")\n    \"def\"\n    >>> lcs(\"abcdef\", \"abc\")\n    \"\"\n    >>> lcs(\"\
    abcdef\", \"cde\")\n    \"de\"\n*/\nstring lcs(string string1, string string2)\
    \ \n{\n    return lcp(string1.dup.reverse, string2.dup.reverse);\n}\n/*\nReturn\
    \ the longest common subsequence of the two input strings.\n    >>> lcs(\"abcdef\"\
    , \"abc\")\n    \"abc\"\n    >>> lcs(\"abcdef\", \"acf\")\n    \"acf\"\n    >>>\
    \ lcs(\"132535365\", \"123456789\")\n    \"12356\"\n*/\nstring lcs(string string1,\
    \ string string2) \n{\n    string[] lcs_array;\n    foreach (string1_prefix; all_prefixes(string1))\n\
    \    {\n        foreach (string", "{\n    string[] prefixes;\n    foreach (int\
    \ i; 0 .. string.length) \n    {\n        prefixes ~= string[0 .. i];\n    }\n\
    \    return prefixes;\n}", "{\n    static struct Prefix\n    {\n        size_t\
    \ length;\n        string prefix;\n    }\n    string[] ret = [];\n    foreach(auto\
    \ cur; iota(0, string.length + 1)) \n    {\n        ret ~= Prefix(length=cur,\
    \ prefix=string[0..cur]).prefix;\n    }\n    return ret;\n}\n/*\n  Find the longest\
    \ common prefix of n strings\n    >>> longest_common_prefix(\"abc\", \"abcd\"\
    , \"abdc\")\n    \"ab\"\n*/\nstring longest_common_prefix(R...)(R strings)\n{\n\
    \    if(strings.length == 0) return \"\";\n    string[] all_prefixes_array = all_prefixes(strings[0]);\n\
    \    string[] prefixes = all_prefixes_array[0..$];\n    foreach(auto p; all_prefixes_array)\n\
    \    {\n        foreach(auto s; strings[1..$])\n        {\n            if(!p.startsWith(s[0..p.length]))\n\
    \            {\n                prefixes[p.length] = \"\";\n            }\n  \
    \      }\n    }\n    return prefixes.join(\"\\n\").retro.retro.retro.retro.retro.split(\"\
    \\n\").retro.find!\"a\"!.retro;\n}\n//unittest\n{\n    import std.range;\n   \
    \ import std.algorithm;\n    string[] test1 = [\"abc\", \"abcd\", \"abdc\"];\n\
    \    string[] test2 = [\"abc\", \"abcd\", \"abdce\"];\n    string[] test3 = [\"\
    abc\", \"abcd\", \"abdce\", \"abde\"];\n    assert(test1.sort().equal([\"abc\"\
    , \"abcd\", \"abdc\"]));\n    assert(test2.sort().equal([\"abc\", \"abcd\", \"\
    abdce\"]));\n    assert(test3.sort().equal([\"abc\", \"abcd\", \"abdce\", \"abde\"\
    ]));\n    assert(longest_common_prefix(test1) == \"ab\");\n    assert(longest_common_prefix(test2)\
    \ == \"abc\");", "{\n  if (string.length == 0)\n    return [];\n  string[] res\
    \ = new string[string.length];\n  foreach (i, c; string[0 .. $])\n    res[i] =\
    \ string[0 .. i];\n  return res;\n}", "{\n    string[] result;\n    foreach (size_t\
    \ i; 0 .. string.length) \n    {\n        result ~= string[0 .. i];\n    }\n \
    \   return result;\n}\n/*\n * \n * Returns a reversed copy of the input string.\n\
    \ * \n * For example:\n *     >>> reverse(\"abc\")\n *     \"cba\"\n *     >>>\
    \ reverse(\"abc defg\")\n *     \"gfed cba\"\n *     \n */\nstring reverse(string\
    \ input) \n{\n    string result;\n    foreach (i; 0 .. input.length) \n    {\n\
    \        result ~= input[$ - i];\n    }\n    return result;\n}\n/*\n * \n * Returns\
    \ a lower-case copy of the input string.\n * \n * For example:\n *     >>> lower(\"\
    abC\")\n *     \"abc\"\n *     >>> lower(\"aBc dEfG\")\n *     \"abc defg\"\n\
    \ *     \n */\nstring lower(string input) \n{\n    string result;\n    foreach\
    \ (c; input) \n    {\n        result ~= toLower(c);\n    }\n    return result;\n\
    }\n/*\n * \n * Returns an upper-case copy of the input string.\n * \n * For example:\n\
    \ *     >>> upper(\"abC\")\n *     \"ABC\"\n *     >>> upper(\"aBc dEfG\")\n *\
    \     \"ABC DEFG\"\n *     \n */\nstring upper(string input) \n{\n    string result;\n\
    \    foreach (c; input) \n    {\n        result ~= toUpper(c);\n    }\n    return\
    \ result;\n}\n/*\n * \n * Returns a strip of the input string.\n * \n * For example:\n\
    \ *     >>> strip(\"  abc  \")\n *     \"abc\"\n *     >>> strip(\"aBc dEfG  \"\
    )\n *     \"aBc dEfG\"\n *     >>> strip(\"  aBc dEfG\")\n *     \"aBc dEfG\"\n\
    \ *     >>> strip(\"  aBc dEfG  \")\n", "{\n    string[] all_prefixes = new string[$];\n\
    \    int i = 0;\n    foreach (prefix; all(string))\n    {\n        all_prefixes[i]\
    \ = prefix;\n        i++;\n    }\n    return all_prefixes;\n}", "{\n    static\
    \ assert(is(typeof({string.init}) == typeof(char[])));\n    auto ret = new string[];\n\
    \    foreach(i; 0 .. string.length) \n    {\n        ret ~= string[0 .. i];\n\
    \    }\n    return ret;\n}\n// Helper to shift a tuple right\nTuple!(T...) rotateRight(T)(Tuple!(T...)\
    \ t) \n{\n    static assert(t.length > 0);\n    return t[t.length - 1] ~ t[0 ..\
    \ $ - 1];\n}\n/*\n    >>> sum([[1, 2], [3, 4]], 0)\n    [4, 6]\n    >>> sum([[1,\
    \ 2], [3, 4]], 1)\n    [5, 7]\n*/\nTuple!(T...) sum(T)(Tuple!(Tuple!(T...)) tuples,\
    \ uint dim) \n{\n    return tuples.front.length == 1\n        ? reduce!((a, b)\
    \ => a + b)(tuples)\n        : sum(map!(t => t[dim .. $]).array(tuples), dim -\
    \ 1)\n        ~ sum(map!(t => t[0 .. dim]).array(tuples), dim - 1);\n}\n// For\
    \ example, if you have the tuples [0,1] and [1,2] then you will get the\n// tuples\
    \ [0,1] and [0,2] when you reduce by columns.\nTuple!(Tuple!(T...)...) reduceByCol(T)(Tuple!(Tuple!(T...))\
    \ tuples) \n{\n    return tuples.tupleof[0 .. $ - 1].reduce!((a, b) => a ~ b.map!(t\
    \ => t));\n}\n/*\n    >>> shift([[1, 2], [3, 4]], 0)\n    [[1, 2], [0, 0]]\n \
    \   >>> shift([[1, 2], [3, 4]], 1)\n    [[1, 2], [0, 0]]\n    >>> shift([[1, 2],\
    \ [3, 4]], 2)\n    [[0, 0], [1", "{\n    immutable size = string.length;\n   \
    \ return iota(size).map!(i => string[0..i]);\n}", "{\n    string[] prefixes;\n\
    \    foreach (index, ch; string)\n    {\n        prefixes ~= string[0..index];\n\
    \    }\n    return prefixes;\n}", "{\n    string[] prefs;\n    foreach(size_t\
    \ i; 0 .. string.length)\n    {\n        prefs ~= string[0 .. i];\n    }\n   \
    \ return prefs;\n}", "{\n\tauto length = string.length;\n\tstring[] result;\n\t\
    result.length = length;\n\tfor (size_t i = 0; i < length; i++)\n\t{\n\t\tresult[i]\
    \ = string[0..i];\n\t}\n\treturn result;\n}", "{\n\tsize_t n = string.length;\n\
    \tstring[] result;\n\tforeach( i ; 0 .. n )\n\t{\n\t\tresult ~= string[0 .. i];\n\
    \t}\n\treturn result;\n}", "{\n    string[] result;\n    for (size_t i = 0; i\
    \ < string.length; i++) \n    {\n        result ~= string[0..i];\n    }\n    return\
    \ result;\n}", "{\n    int n = string.length;\n    string[] result = new string[];\n\
    \    foreach (i; 0 .. n) \n    {\n        result ~= string[0 .. i];\n    }\n \
    \   return result;\n}\n/*\n Return array of all suffixes from shortest to longest\
    \ of the input string\n    >>> all_suffixes(\"abc\")\n    [\"c\", \"bc\", \"abc\"\
    ]\n*/\nstring[] all_suffixes(string string) \n{\n    int n = string.length;\n\
    \    string[] result = new string[];\n    foreach (i; 0 .. n) \n    {\n      \
    \  result ~= string[i .. $];\n    }\n    return result;\n}\n/*\nReturn array of\
    \ all substrings from shortest to longest of the input string\n   >>> all_substrings(\"\
    abc\")\n   [\"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\"]\n*/\nstring[] all_substrings(string\
    \ string) \n{\n    int n = string.length;\n    string[] result = new string[];\n\
    \    foreach (i; 0 .. n) \n    {\n        foreach (j; i .. n) \n        {\n  \
    \          result ~= string[i .. j];\n        }\n    }\n    return result;\n}\n\
    /*\nGiven a string and a pattern (list of substrings), return true if any of the\
    \ strings in the pattern are a substring of the string\n    >>> substring_match(\"\
    abcdef\", [\"bc\"])\n    true\n*/", "{\n    string[] res;\n    while(string.length\
    \ > 0) \n    {\n        res ~= string;\n        string = string[0..$-1];\n   \
    \ }\n    return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
