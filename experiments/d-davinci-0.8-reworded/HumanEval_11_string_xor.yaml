name: HumanEval_11_string_xor
language: d
prompt: "import std.math;\n/*\n Input are two strings a and b consisting only of 1s\
  \ and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n\
  \    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring string_xor(string\
  \ a, string b) \n"
tests: "unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
  111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
  0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
completions: ["{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n       \
    \ if (i >= b.length)\n            break;\n        else\n            result ~=\
    \ (a[i] == b[i]) ? \"0\" : \"1\";\n    }\n    return result;\n}", "{\n  string\
    \ result = \"\";\n  foreach(immutable idx, immutable x; a)\n  {\n    result ~=\
    \ \"0\"[a[idx] == b[idx]];\n  }\n  return result;\n}", "{\n\tstring res;\n\tauto\
    \ len = a.length;\n\tforeach(i; 0 .. len)\n\t{\n\t\tint aa = a[i];\n\t\tint bb\
    \ = b[i];\n\t\tif(aa == bb)\n\t\t{\n\t\t\tres ~= \"0\";\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t\tres ~= \"1\";\n\t\t}\n\t}\n\treturn res;\n}", "{\n    string c = new\
    \ string;\n    assert(a.length == b.length);\n    foreach(i, cch; c)\n    {\n\
    \        if(a[i] == b[i])\n            c ~= \"0\";\n        else\n           \
    \ c ~= \"1\";\n    }\n    return c;\n}", "{\n    string ret = \"\";\n    foreach(int\
    \ i, int c; a)\n    {\n        if(a[i] == b[i]) ret ~= \"0\";\n        else ret\
    \ ~= \"1\";\n    }\n    return ret;\n}\nstring toBitString(int value, uint width\
    \ = 8)\n{\n    string ret = \"\";\n    for(int i = 0; i < width; i++)\n    {\n\
    \        ret = to!string(value & 1) ~ ret;\n        value = value >> 1;\n    }\n\
    \    return ret;\n}", "{\n    string output;\n    foreach(uint i, immutable c;\
    \ a)\n    {\n        output ~= (c ^ b[i]).to!string;\n    }\n    return output;\n\
    }", "{\n    string res = \"\";\n    if(a.length != b.length)\n        return res;\n\
    \    foreach(idx, c; a) {\n        if(c == b[idx])\n            res ~= \"0\";\n\
    \        else\n            res ~= \"1\";\n    }\n    return res;\n}", "{\n   \
    \ // enter code here\n    immutable lenA = a.length;\n    immutable lenB = b.length;\n\
    \    immutable maxLen = max(lenA, lenB);\n    string result = \"\";\n    foreach(immutable\
    \ i; 0 .. maxLen)\n    {\n        if(i >= lenA)\n        {\n            result\
    \ ~= b[i];\n        }\n        else if(i >= lenB)\n        {\n            result\
    \ ~= a[i];\n        }\n        else\n        {\n            if(a[i] == b[i])\n\
    \            {\n                result ~= \"0\";\n            }\n            else\n\
    \            {\n                result ~= \"1\";\n            }\n        }\n \
    \   }\n    return result;\n}", "{\n    string ret = \"\";\n    for (int i = 0;\
    \ i < a.length; i++) \n    {\n        ret += (a[i] != b[i]) ? \"1\" : \"0\";\n\
    \    }\n    return ret;\n}", "{\n    string res = \"\";\n    assert(a.length ==\
    \ b.length);\n    foreach(i, c; a)\n    {\n        res ~= (c == b[i]) ? '0' :\
    \ '1';\n    }\n    return res;\n}", "{\n    string result = \"\";\n    foreach(int\
    \ i; 0 .. a.length) \n    {\n        int n = int.parse(a[i].to!string) ^ int.parse(b[i].to!string);\n\
    \        result ~= n.to!string;\n    }\n    return result;\n}", "{\n    string\
    \ res = \"\";\n    for (int i = 0; i < max(a.length, b.length); i++)\n    {\n\
    \        res += (a[i] ^ b[i]) ? \"1\" : \"0\";\n    }\n    return res;\n}", "{\n\
    \  return format( \"%0{}b\", binaryXor( a.to!int, b.to!int ) );\n}", "{\n  string\
    \ ret = \"\";\n  for (int i = 0; i < a.length; i++) \n  {\n    ret += a[i] !=\
    \ b[i] ? \"1\" : \"0\";\n  }\n  return ret;\n}", "{\n    string ret = \"\";\n\
    \    for (int i = 0; i < min(a.length, b.length); i++) \n    {\n        ret +=\
    \ to!string(int(a[i]) ^ int(b[i]));\n    }\n    return ret;\n}", "{\n    string\
    \ result = \"\";\n    foreach(i,c;a)\n    {\n        result ~= ((a[i] ^ b[i])?\"\
    1\":\"0\");\n    }\n    return result;\n}", "{\n    string res = \"\";\n    for\
    \ (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n         \
    \   res += \"0\";\n        else\n            res += \"1\";\n    }\n    return\
    \ res;\n}", "{\n\tstring res = \"\";\n\t\n\tif(a.length < b.length)\n\t{\n\t\t\
    while(a.length < b.length)\n\t\t{\n\t\t\ta = \"0\" ~ a;\n\t\t}\n\t}\n\telse if(a.length\
    \ > b.length)\n\t{\n\t\twhile(a.length > b.length)\n\t\t{\n\t\t\tb = \"0\" ~ b;\n\
    \t\t}\n\t}\n\t\n\tforeach(i, bit; a)\n\t{\n\t\tres ~= ((to!int(bit) + to!int(b[i]))\
    \ % 2).to!string;\n\t}\n\t\n\treturn res;\n}", "{\n\tauto result = \"\";\n\tfor\
    \ (int i = 0; i < a.length; i++) \n\t{\n\t\tif (a[i] == b[i])\n\t\t\tresult ~=\
    \ \"0\";\n\t\telse\n\t\t\tresult ~= \"1\";\n\t}\n\treturn result;\n}", "{\n  \
    \  auto aLen = a.length;\n    auto bLen = b.length;\n    auto maxLen = max(aLen,\
    \ bLen);\n    auto diff = abs(aLen - bLen);\n    if (aLen > bLen) {\n        b\
    \ = \"0\" ~ b;\n    } else if (bLen > aLen) {\n        a = \"0\" ~ a;\n    }\n\
    \    string r;\n    foreach (i, c; a) {\n        auto res = c ^ b[i];\n      \
    \  r ~= res;\n    }\n    return r;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
