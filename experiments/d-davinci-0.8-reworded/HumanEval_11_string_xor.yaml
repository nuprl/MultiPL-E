name: HumanEval_11_string_xor
language: d
prompt: "import std.math;\n/*\n Input are two strings a and b consisting only of 1s\
  \ and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n\
  \    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \n*/\nstring string_xor(string\
  \ a, string b) \n"
tests: "unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
  111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
  0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
completions: ["{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n       \
    \ if (i >= b.length)\n            break;\n        else\n            result ~=\
    \ (a[i] == b[i]) ? \"0\" : \"1\";\n    }\n    return result;\n}", "{\n  string\
    \ result = \"\";\n  foreach(immutable idx, immutable x; a)\n  {\n    result ~=\
    \ \"0\"[a[idx] == b[idx]];\n  }\n  return result;\n}", "{\n\tstring res;\n\tauto\
    \ len = a.length;\n\tforeach(i; 0 .. len)\n\t{\n\t\tint aa = a[i];\n\t\tint bb\
    \ = b[i];\n\t\tif(aa == bb)\n\t\t{\n\t\t\tres ~= \"0\";\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t\tres ~= \"1\";\n\t\t}\n\t}\n\treturn res;\n}", "{\n    string c = new\
    \ string;\n    assert(a.length == b.length);\n    foreach(i, cch; c)\n    {\n\
    \        if(a[i] == b[i])\n            c ~= \"0\";\n        else\n           \
    \ c ~= \"1\";\n    }\n    return c;\n}", "{\n    string ret = \"\";\n    foreach(int\
    \ i, int c; a)\n    {\n        if(a[i] == b[i]) ret ~= \"0\";\n        else ret\
    \ ~= \"1\";\n    }\n    return ret;\n}\nstring toBitString(int value, uint width\
    \ = 8)\n{\n    string ret = \"\";\n    for(int i = 0; i < width; i++)\n    {\n\
    \        ret = to!string(value & 1) ~ ret;\n        value = value >> 1;\n    }\n\
    \    return ret;\n}", "{\n    string output;\n    foreach(uint i, immutable c;\
    \ a)\n    {\n        output ~= (c ^ b[i]).to!string;\n    }\n    return output;\n\
    }", "{\n    string res = \"\";\n    if(a.length != b.length)\n        return res;\n\
    \    foreach(idx, c; a) {\n        if(c == b[idx])\n            res ~= \"0\";\n\
    \        else\n            res ~= \"1\";\n    }\n    return res;\n}", "{\n   \
    \ // enter code here\n    immutable lenA = a.length;\n    immutable lenB = b.length;\n\
    \    immutable maxLen = max(lenA, lenB);\n    string result = \"\";\n    foreach(immutable\
    \ i; 0 .. maxLen)\n    {\n        if(i >= lenA)\n        {\n            result\
    \ ~= b[i];\n        }\n        else if(i >= lenB)\n        {\n            result\
    \ ~= a[i];\n        }\n        else\n        {\n            if(a[i] == b[i])\n\
    \            {\n                result ~= \"0\";\n            }\n            else\n\
    \            {\n                result ~= \"1\";\n            }\n        }\n \
    \   }\n    return result;\n}", "{\n    string ret = \"\";\n    for (int i = 0;\
    \ i < a.length; i++) \n    {\n        ret += (a[i] != b[i]) ? \"1\" : \"0\";\n\
    \    }\n    return ret;\n}", "{\n    string res = \"\";\n    assert(a.length ==\
    \ b.length);\n    foreach(i, c; a)\n    {\n        res ~= (c == b[i]) ? '0' :\
    \ '1';\n    }\n    return res;\n}", "{\n    string result = \"\";\n    foreach(int\
    \ i; 0 .. a.length) \n    {\n        int n = int.parse(a[i].to!string) ^ int.parse(b[i].to!string);\n\
    \        result ~= n.to!string;\n    }\n    return result;\n}", "{\n    string\
    \ res = \"\";\n    for (int i = 0; i < max(a.length, b.length); i++)\n    {\n\
    \        res += (a[i] ^ b[i]) ? \"1\" : \"0\";\n    }\n    return res;\n}", "{\n\
    \  return format( \"%0{}b\", binaryXor( a.to!int, b.to!int ) );\n}", "{\n  string\
    \ ret = \"\";\n  for (int i = 0; i < a.length; i++) \n  {\n    ret += a[i] !=\
    \ b[i] ? \"1\" : \"0\";\n  }\n  return ret;\n}", "{\n    string ret = \"\";\n\
    \    for (int i = 0; i < min(a.length, b.length); i++) \n    {\n        ret +=\
    \ to!string(int(a[i]) ^ int(b[i]));\n    }\n    return ret;\n}", "{\n    string\
    \ result = \"\";\n    foreach(i,c;a)\n    {\n        result ~= ((a[i] ^ b[i])?\"\
    1\":\"0\");\n    }\n    return result;\n}", "{\n    string res = \"\";\n    for\
    \ (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n         \
    \   res += \"0\";\n        else\n            res += \"1\";\n    }\n    return\
    \ res;\n}", "{\n\tstring res = \"\";\n\t\n\tif(a.length < b.length)\n\t{\n\t\t\
    while(a.length < b.length)\n\t\t{\n\t\t\ta = \"0\" ~ a;\n\t\t}\n\t}\n\telse if(a.length\
    \ > b.length)\n\t{\n\t\twhile(a.length > b.length)\n\t\t{\n\t\t\tb = \"0\" ~ b;\n\
    \t\t}\n\t}\n\t\n\tforeach(i, bit; a)\n\t{\n\t\tres ~= ((to!int(bit) + to!int(b[i]))\
    \ % 2).to!string;\n\t}\n\t\n\treturn res;\n}", "{\n\tauto result = \"\";\n\tfor\
    \ (int i = 0; i < a.length; i++) \n\t{\n\t\tif (a[i] == b[i])\n\t\t\tresult ~=\
    \ \"0\";\n\t\telse\n\t\t\tresult ~= \"1\";\n\t}\n\treturn result;\n}", "{\n  \
    \  auto aLen = a.length;\n    auto bLen = b.length;\n    auto maxLen = max(aLen,\
    \ bLen);\n    auto diff = abs(aLen - bLen);\n    if (aLen > bLen) {\n        b\
    \ = \"0\" ~ b;\n    } else if (bLen > aLen) {\n        a = \"0\" ~ a;\n    }\n\
    \    string r;\n    foreach (i, c; a) {\n        auto res = c ^ b[i];\n      \
    \  r ~= res;\n    }\n    return r;\n}", "{\n    string result;\n    for (int i\
    \ = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n   \
    \         result ~= \"0\";\n        }\n        else \n        {\n            result\
    \ ~= \"1\";\n        }\n    }\n    return result;\n}\n/*\n    rotors[rotorNumber][letter]\
    \ = substitute letter\n    rotors are numbered right to left\n*/\nstring rotors[8][26]\
    \ = {\n    {\n        \"EKMFLGDQVZNTOWYHXUSPAIBRCJ\",\n        \"AJDKSIRUXBLHWTMCQGZNPYFVOE\"\
    ,\n        \"BDFHJLCPRTXVZNYEIWGAKMUSQO\",\n        \"ESOVPZJAYQUIRHXLNFTGKDCMWB\"\
    ,\n        \"VZBRGITYUPSDNHLXAWMJQOFECK\"\n    },\n    {\n        \"UWYGADFPVZBECKMTHXSLRINQOJ\"\
    ,\n        \"AJPCZWRLFBDKOTYUQGENHXMIVS\",\n        \"TAGBPCSDQEUFVNZHYIXJWLRKOM\"\
    ,\n        \"HZWVARTNLGUPXQCEJMBSKDYOIF\",\n        \"QCYLXWENFTZOSMVJUDKGIARPHB\"\
    \n    },\n    {\n        \"AJDKSIRUXBLHWTMCQGZNPYFVOE\",\n        \"EKMFLGDQVZNTOWYHXUSPAIBRCJ\"\
    ,\n        \"VZBRGITYUPSDNHLXAWMJQOFECK\",\n        \"JPGVOUMFYQBENHZRDKASXLICTW\"\
    ,\n        \"NZJHGRCXMYSWBOUFAIVLPEKQDT\"\n    },\n    {\n        \"QCYLXWENFTZOSMVJUDKGIARPHB\"\
    ,\n        \"TAGBPCSDQEUFVNZHYIXJWLRKOM\",\n        \"QMGYVPEDRCWT", "{\n    int\
    \ i = 0;\n    string result = \"\";\n    while (i < a.length)\n    {\n       \
    \ if (a[i] == b[i])\n        {\n            result = result ~ \"0\";\n       \
    \ }\n        else\n        {\n            result = result ~ \"1\";\n        }\n\
    \        i++;\n    }\n    return result;\n}", "{\n    string result = \"\";\n\
    \    int aLen = a.length;\n    int bLen = b.length;\n    if (aLen != bLen)\n \
    \   {\n        return result;\n    }\n    foreach(i; 0 .. aLen)\n    {\n     \
    \   if (a[i] == b[i])\n        {\n            result ~= \"0\";\n        }\n  \
    \      else\n        {\n            result ~= \"1\";\n        }\n    }\n    return\
    \ result;\n}", "{\n    string res = \"\";\n    for (int i = 0; i < a.length; i++)\
    \ \n    {\n        res += a[i] == b[i] ? '0' : '1';\n    }\n    return res;\n}",
  "{\n\tstring result = \"\";\n\tfor (int i = 0; i < a.length; i++)\n\t{\n\t\tresult\
    \ ~= (a[i] ^ b[i]).to!string;\n\t}\n\treturn result;\n}\n/*\n>>> s = \"aabbcc\"\
    \n>>> hexxor(s, s)\n'00000000'\n>>> hexxor(\"abcdef\", \"abcdef\")\n'00000000'\n\
    */\nstring hexxor(string a, string b)\n{\n\tubyte[] buf_a = cast(ubyte[])a;\n\t\
    ubyte[] buf_b = cast(ubyte[])b;\n\tubyte[] buf_r = new ubyte[min(buf_a.length,\
    \ buf_b.length)];\n\tforeach (int i, ref ubyte val; buf_r)\n\t{\n\t\tval = buf_a[i]\
    \ ^ buf_b[i];\n\t}\n\treturn cast(string)buf_r;\n}", "{\n\tstring ret;\n\tforeach(index,\
    \ char; a)\n\t{\n\t\tret ~= (char ^ b[index]);\n\t}\n\treturn ret;\n}", "{\n \
    \   string res;\n    foreach(i, char ai; a)\n    {\n        foreach(j, char bj;\
    \ b)\n        {\n            res ~= (ai ^ bj);\n        }\n    }\n    return res;\n\
    }", "{\n\tauto length = max(a.length, b.length);\n\tauto result = new string(\"\
    \", length);\n\t\n\tfor (int i = 0; i < length; i++) \n\t{\n\t\tint x = i < a.length\
    \ ? a[i] : '0';\n\t\tint y = i < b.length ? b[i] : '0';\n\t\tresult ~= (x == y)\
    \ ? '0' : '1';\n\t}\n\t\n\treturn result;\n}", "{\n\tstring c = \"\";\n\tforeach(i,ch;a)\n\
    \t{\n\t\tc ~= (ch ^ b[i]) == 1 ? \"1\" : \"0\";\n\t}\n\treturn c;\n}", "{\n  \
    \  string ret;\n    if(a.length == b.length)\n    {\n        foreach(c; a)\n \
    \       {\n            ret ~= ((to!ubyte(c)) ^ (to!ubyte(b[c]))) ? \"1\" : \"\
    0\";\n        }\n    }\n    return ret;\n}", "{\n    string result = \"\";\n \
    \   foreach(uint i, char c1; a) \n    {\n        char c2 = b[i];\n        int\
    \ x = c1-'0';\n        int y = c2-'0';\n        int z = x^y;\n        result ~=\
    \ z.to!string;\n    }\n    return result;\n}\n/*\n    Get the 16 bit subkey from\
    \ the 48 bit key.\n    >>> get_subkey(0x05F34A32, 0, 0)\n    0x0A\n*/\nuint get_subkey(uint\
    \ key, uint round, uint position) \n{\n    uint six_bit_mask = 0xFC000000;\n \
    \   uint right_six_bit_mask = 0x03F00000;\n    uint four_bit_mask = 0x000F0000;\n\
    \    uint left_six_bit_mask = 0x0000FC00;\n    uint six_bit_offset = 26;\n   \
    \ uint four_bit_offset = 16;\n    uint subkey = key;\n    for(uint i = 0; i <=\
    \ round; i++) \n    {\n        uint right_six_bit = (subkey & right_six_bit_mask)\
    \ >> six_bit_offset;\n        uint left_six_bit = (subkey & left_six_bit_mask)\
    \ >> four_bit_offset;\n        uint four_bit = (subkey & four_bit_mask) >> four_bit_offset;\n\
    \        subkey = (subkey << 2) | ((right_six_bit >> 4) & 0x03);\n        subkey\
    \ &= 0xFFFFFF;\n        uint shift_count = (left_six_bit & 0x01) + ((left_six_bit\
    \ & 0x20) >> 4) + ((left_six_bit & 0x10) >> 3) +\n                           \
    \ ((left_six_bit & 0x08) >> 2) + ((left_six_bit & 0x04) >> 1) + (left_six_bit\
    \ & 0x02);\n        for(uint j = 0; j < shift_count; j++) \n        {\n      \
    \      four_bit = ((four_bit & 0x08) >> 3) |", "{\n    string result = \"\";\n\
    \    for (int i = 0; i < a.length; i++)\n    {\n        result ~= (a[i] == b[i])\
    \ ? \"0\" : \"1\";\n    }\n    return result;\n}", "{\n    assert(a.length ==\
    \ b.length);\n    string res = new string;\n    res.length = a.length;\n    foreach(size_t\
    \ i; 0 .. a.length)\n    {\n        res[i] = a[i] ^ b[i];\n    }\n    return res;\n\
    }\n/*\n  Input is a string a consisting only of 1s and 0s.\n  Input is a single\
    \ bit b. \n  Perform binary left shift on a. \n  If b is a 1, then an extra 0\
    \ is appended to the end. \n  If b is a 0, then an extra 1 is appended to the\
    \ end.\n  >>> left_shift(\"101\", 1)\n  \"1010\"\n  >>> left_shift(\"101\", 0)\n\
    \  \"1011\"\n*/\nstring left_shift(string a, ubyte b) \n{\n    string res = new\
    \ string;\n    res.length = a.length + 1;\n    foreach(size_t i; 0 .. a.length)\n\
    \    {\n        res[i] = a[i];\n    }\n    res[a.length] = ~b;\n    return res;\n\
    }\n/*\n  Input is a string a consisting only of 1s and 0s.\n  Input is a single\
    \ bit b. \n  Perform binary right shift on a. \n  If b is a 1, then an extra 1\
    \ is prepended to the beginning. \n  If b is a 0, then an extra 0 is prepended\
    \ to the beginning.\n  >>> right_shift(\"1010\", 1)\n  \"1101\"\n  >>> right_shift(\"\
    1010\", 0)\n  \"0101\"\n*/\nstring right_shift(string a, ubyte b) \n{\n    string\
    \ res = new string;\n    res.length = a.length + 1;\n    res[0] = ~b;\n    foreach(size_t\
    \ i; 1 .. a.length + 1)\n    {\n        res[i] = a[i - 1];\n    }\n    return\
    \ res;\n}\n/*\n  Input is a string a consisting only of 1s and 0s.\n  Input is\
    \ an integer x. \n ", "{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result = result\
    \ ~ \"0\";\n        }\n        else\n        {\n            result = result ~\
    \ \"1\";\n        }\n    }\n    return result;\n}", "{\n    int n = a.length;\n\
    \    assert(n == b.length);\n    string res;\n    res.length = n;\n    foreach\
    \ (i, c; a)\n    {\n        assert(c == '0' || c == '1');\n        int ai = (c\
    \ == '0') ? 0 : 1;\n        assert(b[i] == '0' || b[i] == '1');\n        int bi\
    \ = (b[i] == '0') ? 0 : 1;\n        res[i] = (ai ^ bi) ? '1' : '0';\n    }\n \
    \   return res;\n}", "{\n  string ret = \"\";\n  foreach(i, c; a) {\n    ret ~=\
    \ (c ^ b[i]) == '0' ? '0' : '1';\n  }\n  return ret;\n}", "{\n    string ret =\
    \ \"\";\n    for (int i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i])\
    \ ret += \"0\";\n        else ret += \"1\";\n    }\n    return ret;\n}", "{\n\
    \    // start from the first character\n    int i = 0;\n    // if both strings\
    \ are equal, then they are different\n    // characters, so they are different\n\
    \    while (i < a.length && i < b.length) \n    {\n        // if the character\
    \ is equal, then we have \n        // the same character, so we will return \n\
    \        // the same character\n        if (a[i] == b[i]) \n        {\n      \
    \      a[i] = '0';\n        }\n        else \n        {\n            a[i] = '1';\n\
    \        }\n        i++;\n    }\n    // if the first string is larger, then we\
    \ must \n    // use the characters from the second string to \n    // get the\
    \ characters from the first string\n    while (i < a.length) \n    {\n       \
    \ a[i] = '1';\n        i++;\n    }\n    // if the second string is larger, then\
    \ we must \n    // use the characters from the first string to \n    // get the\
    \ characters from the second string\n    while (i < b.length) \n    {\n      \
    \  a[i] = '1';\n        i++;\n    }\n    return a;\n}", "{\n    string res = new\
    \ string();\n    if (a.length != b.length)\n        return null;\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            res\
    \ ~= \"0\";\n        else\n            res ~= \"1\";\n    }\n    return res;\n\
    }", "{\n    /* TODO: Check the length of a and b, find the longer string,\n  \
    \   * and use the length of that string to make the result. */\n    uint len =\
    \ 0;\n    if (a.length > b.length) \n    {\n        len = a.length;\n    }\n \
    \   else \n    {\n        len = b.length;\n    }\n    string result = \"\";\n\
    \    ubyte carry = 0;\n    for (uint i = 0; i < len; i++) \n    {\n        /*\
    \ TODO: Convert the character at a[i] to an integer */\n        ubyte ai = cast(ubyte)\
    \ a[i];\n        /* TODO: Convert the character at b[i] to an integer */\n   \
    \     ubyte bi = cast(ubyte) b[i];\n        /* TODO: Use integer addition to compute\
    \ the sum. */\n        ubyte sum = ai + bi + carry;\n        if (sum == 0) \n\
    \        {\n            result ~= \"0\";\n            carry = 0;\n        }\n\
    \        else if (sum == 1) \n        {\n            result ~= \"1\";\n      \
    \      carry = 0;\n        }\n        else if (sum == 2) \n        {\n       \
    \     result ~= \"0\";\n            carry = 1;\n        }\n        else if (sum\
    \ == 3) \n        {\n            result ~= \"1\";\n            carry = 1;\n  \
    \      }\n    }\n    return result;\n}\n ", "{\n    auto result = \"\";\n    foreach(immutable\
    \ i, immutable c; a) \n    {\n        ubyte value = c ^ b[i];\n        if (value\
    \ > 0) \n        {\n            result ~= value.to!string;\n        }\n      \
    \  else \n        {\n            result ~= \"0\";\n        }\n    }\n    return\
    \ result;\n}\n \nstring xor64(string key, string message) \n{\n    // Repeats\
    \ the key to fit the length of the message\n    auto max_length = message.length;\n\
    \    key = key.repeat(max_length / key.length + 1);\n    key = key[0 .. max_length];\n\
    \    return string_xor(key, message);\n}", "{\n    string z = \"\";\n    foreach(i,\
    \ e; a)\n    {\n        z ~= ((i + 1) % 2 == 0 ? \"1\" : \"0\");\n    }\n    return\
    \ z;\n}", "{\n  string res = \"\";\n  size_t i = 0;\n  for (; i < a.length &&\
    \ i < b.length; i++)\n    res += ((a[i] - '0') ^ (b[i] - '0')) + '0';\n  for (;\
    \ i < a.length; i++)\n    res += a[i];\n  for (; i < b.length; i++)\n    res +=\
    \ b[i];\n  return res;\n}", "{\n    string result;\n    if (a.length != b.length)\n\
    \        return \"\";\n    else\n    {\n        result = new string[a.length];\n\
    \        foreach (immutable int i, immutable char ac; a)\n        {\n        \
    \    immutable char bc = b[i];\n            immutable int ic = cast(int)ac;\n\
    \            immutable int icb = cast(int)bc;\n            immutable int xor =\
    \ ic ^ icb;\n            if (xor == 0)\n                result[i] = '0';\n   \
    \         else\n                result[i] = '1';\n        }\n    }\n    return\
    \ result;\n}\n/*\nTest cases are from codewars.\n*/", "{\n    string result;\n\
    \    foreach(char c1, char c2; zip(a, b))\n    {\n        char r;\n        if(c1\
    \ == c2)\n            r = '0';\n        else\n            r = '1';\n        result\
    \ ~= r;\n    }\n    return result;\n}", "{\n    string sb;\n    for (size_t i\
    \ = 0; i < min(a.length, b.length); i++)\n    {\n        if (a[i] == b[i]) sb\
    \ ~= \"0\";\n        else sb ~= \"1\";\n    }\n    return sb;\n}", "{\n   string\
    \ res;\n   for (int i = 0; i < a.length; i++)\n        if (a[i] != b[i]) res +=\
    \ \"1\";\n        else res += \"0\";\n   return res;\n}", "{\n    immutable len\
    \ = a.length;\n    string res = \"\";\n    foreach(immutable i; 0 .. len)\n  \
    \  {\n        if(a[i] != b[i])\n            res ~= \"1\";\n        else\n    \
    \        res ~= \"0\";\n    }\n    return res;\n}", "{\n\tint i,j;\n\tstring s=\"\
    \";\n\tforeach(i, a)\n\t{\n\t\ts~=XOR(a[i],b[i]);\n\t}\n\treturn s;\n}", "{\n\
    \    string result;\n    for (int i = 0; i < a.length; i++)\n    {\n        int\
    \ a_i = stoi(a[i]);\n        int b_i = stoi(b[i]);\n        result ~= ((a_i^b_i)\
    \ % 2).to!string;\n    }\n    return result;\n}", "{\n    string s;\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        s ~= ((cast(int)a[i] - 48) ^ (cast(int)b[i]\
    \ - 48));\n    }\n    return s;\n}\n// test cases", "{\n    string result = \"\
    \";\n    auto len = max(a.length, b.length);\n    for (int i = 0; i < len; i++)\n\
    \    {\n        char ac = i < a.length ? a[i] : '0';\n        char bc = i < b.length\
    \ ? b[i] : '0';\n        if (ac == bc)\n            result ~= '0';\n        else\n\
    \            result ~= '1';\n    }\n    return result;\n}", "{\n    auto s = zip(a,\
    \ b);\n    string res;\n    foreach(bit; s)\n    {\n        if(bit[0] == bit[1])\n\
    \            res ~= \"0\";\n        else\n            res ~= \"1\";\n    }\n \
    \   return res;\n}", "{\n  string retval;\n  foreach(i,v;a) {\n    retval ~= (v^b[i]);\n\
    \  }\n  return retval;\n}\n/*\n    Take a string composed of 1s and 0s, and return\
    \ an integer of the\n    value represented in that string.\n    >>> binary_to_decimal(\"\
    01010\")\n    10\n    >>> binary_to_decimal(\"01110\")\n    14\n    \n*/", "{\n\
    \  string res = \"\";\n  foreach( i, e ; a )\n  {\n    res ~= (to!int(e) ^ to!int(b[i]));\n\
    \  }\n  return res;\n}", "{\n    int size;\n    string res;\n    if(a.length >=\
    \ b.length)\n    {\n        size = a.length;\n        res = a;\n    }\n    else\n\
    \    {\n        size = b.length;\n        res = b;\n    }\n    for(int i = 0;\
    \ i < size; i++)\n    {\n        if(i < a.length && i < b.length)\n        {\n\
    \            if(a[i] == b[i])\n            {\n                res[i] = '0';\n\
    \            }\n            else\n            {\n                res[i] = '1';\n\
    \            }\n        }\n        else\n        {\n            if(i < a.length)\n\
    \            {\n                res[i] = a[i];\n            }\n            else\n\
    \            {\n                res[i] = b[i];\n            }\n        }\n   \
    \ }\n    return res;\n}\nstring string_xor_sol(string a, string b)\n{\n    string\
    \ s = \"\";\n    for (int i = 0; i < a.length; i++)\n    {\n        s += (a[i]\
    \ != b[i]) ? \"1\" : \"0\";\n    }\n    return s;\n}", "{\n    string ret;\n \
    \   size_t sz = max(a.length(), b.length());\n    for (size_t i = 0; i < sz; i++)\n\
    \    {\n        if (a[i] == b[i]) ret += '0';\n        else ret += '1';\n    }\n\
    \    return ret;\n}\n//Some examples\nunittest\n{\n    assert(string_xor(\"010\"\
    , \"110\") == \"100\");\n    assert(string_xor(\"00100\", \"111\") == \"11001\"\
    );\n    assert(string_xor(\"01101\", \"10101\") == \"11000\");\n}", "{\n\tstring\
    \ ret = a;\n\tfor (int i = 0; i < a.length; i++)\n\t{\n\t\tret[i] = (a[i] == b[i])\
    \ ? '0' : '1';\n\t}\n\treturn ret;\n}", "{\n  int size = a.length > b.length ?\
    \ a.length : b.length;\n  int aNum = 0;\n  int bNum = 0;\n  int result = 0;\n\
    \  string res = \"\";\n  foreach(char c, int i; a)\n  {\n    aNum = cast(int)c;\n\
    \    if(i >= b.length)\n      bNum = 0;\n    else\n      bNum = cast(int)b[i];\n\
    \    result = aNum ^ bNum;\n    res ~= result.to!string;\n  }\n  if(a.length <\
    \ b.length)\n  {\n    foreach(char c, int i; b)\n    {\n      if(i < a.length)\n\
    \        continue;\n      bNum = cast(int)c;\n      if(i >= a.length)\n      \
    \  aNum = 0;\n      else\n        aNum = cast(int)a[i];\n      result = aNum ^\
    \ bNum;\n      res ~= result.to!string;\n    }\n  }\n  return res;\n}", "{\n \
    \   string res = \"\";\n    int n = a.length;\n    foreach(c; a)\n    {\n    \
    \    int ia = cast(int)c;\n        int ib = cast(int)b[i];\n        res ~= cast(char)(ia\
    \ ^ ib);\n    }\n    return res;\n}", "{\n    string ret = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        int c = int(a[i]) ^ int(b[i]);\n \
    \       ret ~= c;\n    }\n    return ret;\n}", "{\n    string r = \"\";\n    foreach(int\
    \ i; 0 .. min(a.length, b.length))\n        r ~= (a[i] == b[i]) ? \"0\" : \"1\"\
    ;\n    return r;\n}", "{\n    //Your code here\n    string res = \"\";\n    for(int\
    \ i = 0; i < a.length; i++)\n    {\n      if(a[i] == b[i])\n      {\n        res\
    \ += \"0\";\n      }\n      else\n      {\n        res += \"1\";\n      }\n  \
    \  }\n    return res;\n}", "{\n    int len = std.min(a.length, b.length);\n  \
    \  string res = \"\";\n    for (int i = 0; i < len; i++) {\n        res ~= ((a[i]\
    \ == '1') ^ (b[i] == '1')) ? \"1\" : \"0\";\n    }\n    return res;\n}", "{\n\
    \    string res = \"\";\n    foreach(i, c; a)\n    {\n        res ~= (c ^ b[i]);\n\
    \    }\n    return res;\n}", "{\n    int i;\n    // your code here\n    string\
    \ ret = \"\";\n    foreach(i, a) {\n        ret += ('0' ^ (a[i] ^ b[i]));\n  \
    \  }\n    return ret;\n}", "{\n  string res;\n  if(a.length != b.length)\n  {\n\
    \    foreach(i;0..max(a.length,b.length))\n    {\n      if(i >= a.length)\n  \
    \    {\n        res ~= b[i];\n      }\n      else if(i >= b.length)\n      {\n\
    \        res ~= a[i];\n      }\n      else if(a[i] == b[i])\n      {\n       \
    \ res ~= \"0\";\n      }\n      else\n      {\n        res ~= \"1\";\n      }\n\
    \    }\n  }\n  else\n  {\n    foreach(i;0..a.length)\n    {\n      if(a[i] ==\
    \ b[i])\n      {\n        res ~= \"0\";\n      }\n      else\n      {\n      \
    \  res ~= \"1\";\n      }\n    }\n  }\n  return res;\n}\n// Solution 2 :\n// string\
    \ string_xor(string a, string b)\n// {\n//   int max_index = max(a.length, b.length);\n\
    //   string res = new string[max_index];\n//   foreach(i;0..max_index)\n//   {\n\
    //     if(i >= a.length)\n//     {\n//       res[i] = b[i];\n//     }\n//    \
    \ else if(i >= b.length)\n//     {\n//       res[i] = a[i];\n//     }\n//    \
    \ else if(a[i] == b[i])\n//     {\n//       res[i] = \"0\";\n//     }\n//    \
    \ else\n//     {\n//       res[i] = \"1\";\n//     }\n//   }\n//   return res;\n\
    // }", "{\n    string xored_string = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            xored_string\
    \ ~= \"0\";\n        }\n        else \n        {\n            xored_string ~=\
    \ \"1\";\n        }\n    }\n    return xored_string;\n}", "{\n  string c;\n  int\
    \ i, n;\n  foreach(char d; a)\n  {\n    n = d - '0';\n    c ~= dchar(n ^ (b[$]\
    \ - '0') + '0');\n  }\n  return c;\n}\n/*\n    >>> string_xor(\"1001011\", \"\
    0110011\")\n    \"1101000\"\n*/", "{\n    // int valueA = stoi(a, null, 2);\n\
    \    // int valueB = stoi(b, null, 2);\n    // int result = valueA ^ valueB;\n\
    \    // return toBinaryString(result);\n    int length = a.length;\n    string\
    \ result = \"\";\n    for (int i = 0; i < length; i++)\n    {\n        if (a[i]\
    \ == b[i])\n        {\n            result += \"0\";\n        }\n        else\n\
    \        {\n            result += \"1\";\n        }\n    }\n    return result;\n\
    }\n/*\n  <p>\n  Given a string a, return the text corresponding to the result\
    \ of doing\n  binary XOR between the ASCII values of the characters in a.\n  For\
    \ example, if the input is \"cyber\", the output would be \"1'1\"1\".\n  </p>\n\
    \  <p>\n  Expected output: \"1'1\"1\"\n  </p>\n  <p>\n  Important: You must not\
    \ use the toBinaryString functions provided in Java\n  to solve this problem.\n\
    \  </p>\n*/\nstring char_xor(string a)\n{\n    int length = a.length;\n    int[]\
    \ ascii = a.dup.map!(\"c => cast(int)c\").array;\n    string result = \"\";\n\
    \    for (int i = 0; i < length - 1; i++)\n    {\n        int value = ascii[i]\
    \ ^ ascii[i + 1];\n        result += toBinaryString(value);\n    }\n    return\
    \ result;\n}\n/*\n  <p>\n  Given a string a, return the text corresponding to\
    \ the result of doing\n  binary XOR between the ASCII values of the characters\
    \ in a and the next\n  character in the string.\n  For example, if the input is\
    \ \"cyber\", the output would be \"1'1\"1\".\n  </p>\n  <p>\n  Expected output:\
    \ \"1'1\"1\"\n  </p>\n  <p>\n  Important: You must not use the toBinaryString\
    \ functions provided in Java\n  to solve this problem.", "{\n    string ret =\
    \ \"\";\n    foreach(int i, const char c; a)\n    {\n        if (c == '0')\n \
    \       {\n            if (b[i] == '0')\n                ret ~= '0';\n       \
    \     else\n                ret ~= '1';\n        }\n        else if (c == '1')\n\
    \        {\n            if (b[i] == '0')\n                ret ~= '1';\n      \
    \      else\n                ret ~= '0';\n        }\n    }\n    return ret;\n}",
  "{\n    return (a + b).rfind('1') < 0 ? \"0\" : \"1\";\n}", "{\n  string result;\n\
    \  for (uint i = 0; i < a.length; i++) \n  {\n    int ai = parseInt(a[i]);\n \
    \   int bi = parseInt(b[i]);\n    result ~= to!string(ai ^ bi);\n  }\n  return\
    \ result;\n}", "{\n    string r = \"\";\n    foreach(i, e; a)\n    {\n       \
    \ if(e == b[i])\n            r ~= \"0\";\n        else\n            r ~= \"1\"\
    ;\n    }\n    return r;\n}", "{\n    return format(\"%b\", to!uint(a) ^ to!uint(b));\n\
    }", "{\n\t//TODO use string.opXor(string)\n\tstring result = \"\";\n\t\n\tforeach(char\
    \ c; a)\n\t{\n\t\tif (c == '0')\n\t\t{\n\t\t\tif (b[$-1] == '0')\n\t\t\t\tresult\
    \ ~= '0';\n\t\t\telse\n\t\t\t\tresult ~= '1';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    if (b[$-1] == '0')\n\t\t\t\tresult ~= '1';\n\t\t\telse\n\t\t\t\tresult ~= '0';\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if ( a[i] == b[i] ) result += \"0\"\
    ;\n        else result += \"1\";\n    }\n    return result;\n}", "{\n    string\
    \ result = \"\";\n    if (a.length != b.length) {\n        return result;\n  \
    \  }\n    foreach (i, ai; a) {\n        int bi = b[i] - '0';\n        result ~=\
    \ to!string(ai ^ bi);\n    }\n    return result;\n}", "{\n    string res = \"\"\
    ;\n    foreach(i, ch; a)\n    {\n        auto x = ch == '1';\n        auto y =\
    \ b[i] == '1';\n        res ~= (x ^ y) ? '1' : '0';\n    }\n    return res;\n\
    }\n/*\n You are given a string consisting of the characters \"0\" and \"1\". You\
    \ can repeat the operation\n  you performed on the previous character any number\
    \ of times. \n  For example, if you start with \"0\", you can change it to \"\
    00\" or \"01\" or \"10\".\n      1. If you start with \"10\", you can change it\
    \ to \"100\" or \"110\" or \"101\" or \"111\".\n      2. If you start with \"\
    010\", you can change it to \"0100\" or \"0110\" or \"0101\" or \"0111\".\n  \
    \  Given an integer n and a string s consisting of \"0\" and \"1\", \n    find\
    \ the minimal number of operations needed to obtain a string of length n consisting\
    \ only of the character \"1\".\n    >>> minimal_steps(\"0101010\")\n    2\n  \
    \  >>> minimal_steps(\"10010001\")\n    3\n*/", "{\n    string result = \"\";\n\
    \    for (int i = 0; i < a.length; i++)\n    {\n        result += cast(char)(cast(int)(a[i])\
    \ ^ cast(int)(b[i]));\n    }\n    return result;\n}\n/*\n    Implement a stream\
    \ cipher encryption/decryption.\n    Inputs are plaintext, key and a mode which\
    \ is either \n    \"encrypt\" or \"decrypt\". \n    Output is ciphertext.\n  \
    \  >>> xor_crypt(\"hello world\", \"key\")\n    \"^V\\x8f\\xdd\\x98\\x03\\x01\\\
    x00G\"\n    >>> xor_crypt(\"^V\\x8f\\xdd\\x98\\x03\\x01\\x00G\", \"key\", \"decrypt\"\
    )\n    \"hello world\"\n*/\nstring xor_crypt(string text, string key, string mode\
    \ = \"encrypt\")\n{\n    // create repeating key\n    string key_str = \"\";\n\
    \    for (int i = 0; i < text.length; i++)\n    {\n        key_str += key[i %\
    \ key.length];\n    }\n    string crypted = string_xor(text, key_str);\n    if\
    \ (mode == \"decrypt\")\n    {\n        crypted = string_xor(crypted, key_str);\n\
    \    }\n    return crypted;\n}\n/*\n    Calculate Levenshtein distance of two\
    \ strings.\n    Strings are not case sensitive.\n    >>> levenshtein(\"Elvis\"\
    , \"Lives\")\n    2\n    >>> levenshtein(\"kitten\", \"sitting\")\n    3\n   \
    \ >>> levenshtein(\"Saturday\", \"Sunday\")\n    3\n*/", "{\n  string result =\
    \ \"\";\n  if (a.length != b.length) return result;\n  for (int i = 0; i < a.length;\
    \ i++) \n  {\n    result += ((a[i] ^ b[i]) == 1 ? \"1\" : \"0\");\n  }\n  return\
    \ result;\n}", "{\n  string res;\n  int i, len;\n  len = min(a.length, b.length);\n\
    \  for (i = 0; i < len; i++)\n    res ~= (a[i] ^ b[i]) + '0';\n  return res;\n\
    }", "{\n    string result = \"\";\n    auto size = min(a.length, b.length);\n\
    \    for (auto i = 0; i < size; i++) \n    {\n        result ~= xor(a[i], b[i]);\n\
    \    }\n    return result;\n}", "{\n    string result = \"\";\n    foreach(int\
    \ i, int ai; a)\n    {\n        result ~= (ai ^ cast(int)b[i]) ? '1' : '0';\n\
    \    }\n    return result;\n}", "{\n    size_t len = min(a.length, b.length);\n\
    \    string result;\n    for (size_t i = 0; i < len; i++)\n    {\n        result\
    \ ~= (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}", "{\n    string\
    \ result = \"\";\n    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i]\
    \ == b[i])\n        {\n            result += \"0\";\n        }\n        else\n\
    \        {\n            result += \"1\";\n        }\n    }\n    return result;\n\
    }", "{\n  string res = \"\";\n  foreach(int i; 0 .. a.length)\n    res ~= (a[i]\
    \ == b[i]) ? '0' : '1';\n  return res;\n}", "{\n    string result = \"\";\n  \
    \  for (int i = 0; i < a.length; i++) \n    {\n        result ~= a[i] ^ b[i];\n\
    \    }\n    return result;\n}", "{\n    string ret = \"\";\n    int size = min(a.length,\
    \ b.length);\n    for (int i = 0; i < size; i++)\n    {\n        if (a[i] == b[i])\n\
    \            ret += \"0\";\n        else\n            ret += \"1\";\n    }\n \
    \   return ret;\n}", "{\n    string result;\n    foreach(immutable i, immutable\
    \ aChar; a)\n    {\n        auto bChar = b[i];\n        result ~= aChar ^ bChar;\n\
    \    }\n    return result;\n}", "{\n  string out=\"\";\n  int len=a.length;\n\
    \  for(int i=0;i<len;i++)\n    out+=(a[i]!=b[i])?'1':'0';\n  return out;\n}",
  "{\n    if (a.length() != b.length()) \n    {\n        throw new IllegalArgumentException(\"\
    Strings must be same length\");\n    }\n    string result = \"\";\n    for (int\
    \ i = 0; i < a.length(); i++) \n    {\n        if (a[i] == b[i])\n        {\n\
    \            result ~= \"0\";\n        }\n        else\n        {\n          \
    \  result ~= \"1\";\n        }\n    }\n    return result;\n}", "{\n    // Get\
    \ the width of the largest operand\n    ulong width = max(a.length, b.length);\n\
    \    \n    // Extract the bits of the operands into an array\n    ubyte[] aBits\
    \ = a.length > width ? a.assumeUnshared.dup[0 .. width] : a.dup;\n    ubyte[]\
    \ bBits = b.length > width ? b.assumeUnshared.dup[0 .. width] : b.dup;\n    \n\
    \    // Convert the strings to bit arrays.\n    foreach (index, ref bit; aBits)\n\
    \        bit = bit == '1' ? 1 : 0;\n    foreach (index, ref bit; bBits)\n    \
    \    bit = bit == '1' ? 1 : 0;\n    \n    // Perform the XOR operation on the\
    \ bits\n    foreach (index, ref bit; aBits)\n        bit ^= bBits[index];\n  \
    \  \n    // Convert the array back to a string\n    aBits.map!((bit) => bit ?\
    \ '1' : '0').array;\n    \n    return aBits.join;\n}", "{\n    int a_length =\
    \ a.length;\n    int b_length = b.length;\n    int len = max(a_length, b_length);\n\
    \    int diff = abs(a_length - b_length);\n    string c = \"\";\n    for (int\
    \ i = 0; i < diff; i++)\n    {\n        c += \"0\";\n    }\n    if (a_length >\
    \ b_length)\n    {\n        b = c + b;\n    }\n    else\n    {\n        a = c\
    \ + a;\n    }\n    string result = \"\";\n    foreach (int i, char ch; a)\n  \
    \  {\n        if (ch == b[i])\n        {\n            result += \"0\";\n     \
    \   }\n        else\n        {\n            result += \"1\";\n        }\n    }\n\
    \    return result;\n}", "{\n    string res = \"\";\n    foreach(i, val; a)\n\
    \    {\n        if(a[i] == b[i])\n            res ~= \"0\";\n        else\n  \
    \          res ~= \"1\";\n    }\n    return res;\n}", "{\n    string result =\
    \ \"\";\n    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n\
    \        {\n            result += \"0\";\n        }\n        else\n        {\n\
    \            result += \"1\";\n        }\n    }\n    return result;\n}", "{\n\
    \    string c;\n    c.length = a.length;\n    foreach(int i, cchr; c)\n    {\n\
    \        cchr = a[i] ^ b[i];\n        c[i] = cchr;\n    }\n    return c;\n}",
  "{\n    string result;\n    int n = min(a.length, b.length);\n    foreach(i; 0 ..\
    \ n)\n    {\n        if(a[i] != b[i])\n            result ~= \"1\";\n        else\n\
    \            result ~= \"0\";\n    }\n    return result;\n}\n/*\n    Given an\
    \ array of integers and a number x, find the smallest subarray with sum greater\
    \ than the given value.\n    >>> smallest_subarray_with_given_sum([1, 4, 45, 6,\
    \ 0, 19], 51)\n    [4, 45, 6, 0, 19]\n    >>> smallest_subarray_with_given_sum([1,\
    \ 10, 5, 2, 7], 9)\n    [10, 5, 2]\n    >>> smallest_subarray_with_given_sum([1,\
    \ 11, 100, 1, 0, 200, 3, 2, 1, 250], 280)\n    [100, 1, 0, 200]\n    >>> smallest_subarray_with_given_sum([1,\
    \ 2, 4], 8)\n    []\n*/", "{\n    string result = new string();\n    int i = 0;\n\
    \    foreach(aCh; a)\n    {\n        int aVal = cast(int)aCh - 48;\n        int\
    \ bVal = cast(int)b[i] - 48;\n        int tmp = aVal ^ bVal;\n        result ~=\
    \ std.string.format(\"%s\", tmp);\n        i++;\n    }\n    return result;\n}",
  "{\n    /*\n        Note that a and b are NOT necessarily same length!\n       \
    \ So we start by padding the shorter one with extra 0s on the left.\n    */\n\
    \    if (a.length() < b.length()) {\n        a = new string('0', b.length() -\
    \ a.length()) ~ a;\n    } else if (b.length() < a.length()) {\n        b = new\
    \ string('0', a.length() - b.length()) ~ b;\n    }\n    return map!(xor)(a, b);\n\
    }", "{\n    int n = max(a.length, b.length);\n    string s = \"\";\n    for (int\
    \ i = 0; i < n; i++) {\n        if (a[i % a.length] == b[i % b.length]) s += \"\
    0\";\n        else s += \"1\";\n    }\n    return s;\n}", "{\n    string temp;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    foreach(char c; a)\n    {\n\
    \        if(c == '1')\n            x++;\n    }\n    foreach(char c; b)\n    {\n\
    \        if(c == '1')\n            y++;\n    }\n    temp = a.length > b.length\
    \ ? a : b;\n    foreach(char c; temp)\n    {\n        if(c == '1')\n         \
    \   z++;\n    }\n    return format(\"%s\", z == x + y ? \"1\" : \"0\");\n}", "{\n\
    \    string result = \"\";\n    const size_t length = a.length();\n    if (length\
    \ != b.length())\n        return result;\n    for (size_t i = 0; i < length; ++i)\n\
    \        result += (a[i] == b[i]) ? '0' : '1';\n    return result;\n}\n/*\n Kata.Groups(new[]\
    \ {\"aldo\", \"beat\", \"carla\", \"david\", \"evi\", \"flip\", \"gary\", \"hugo\"\
    , \"ida\"}) \n => new[] {new[] {\"aldo\", \"beat\"}, new[] {\"carla\", \"david\"\
    , \"evi\"}, new[] {\"flip\", \"gary\", \"hugo\", \"ida\"}}\n */\nstring[][] Groups(string[]\
    \ names)\n{\n    int n = names.length;\n    int count = (int)sqrt(n);\n    int\
    \ len = n / count;\n    string[][] ret = new string[count][];\n    for (int i\
    \ = 0; i < count; i++)\n    {\n        string[] arr = new string[len];\n     \
    \   for (int j = 0; j < len; j++)\n        {\n            arr[j] = names[i * len\
    \ + j];\n        }\n        ret[i] = arr;\n    }\n    return ret;\n}\n/*\n Kata.BackwardsRead(12345)\
    \ => \"54321\"\n*/\nulong BackwardsRead(ulong n)\n{\n    ulong k = n;\n    ulong\
    \ m = 0;\n    while (k != 0)\n    {\n        m = m * 10 + k % 10;\n        k /=\
    \ 10;\n    }\n    return m;\n}\n/*\n Kata.MaxTriSum(new[] {3, 2, 6, 8, 2, 3})\
    \ => 17\n*/", "{\n    int len = min(a.length, b.length);\n    string ret;\n  \
    \  ret.length = len;\n    foreach(int i; 0 .. len)\n    {\n        ret[i] = (a[i]\
    \ ^ b[i]) + '0';\n    }\n    return ret;\n}", "{\n    string result = \"\";\n\
    \    bool a_is_bigger = a.length > b.length;\n    int diff = a_is_bigger ? a.length\
    \ - b.length : b.length - a.length;\n    string bigger = a_is_bigger ? a : b;\n\
    \    string smaller = a_is_bigger ? b : a;\n    for (int i = 0; i < diff; i++)\
    \ \n    {\n        smaller = \"0\" + smaller;\n    }\n    for (int i = 0; i <\
    \ smaller.length; i++) \n    {\n        result += (smaller[i] == bigger[i]) ?\
    \ \"0\" : \"1\";\n    }\n    return result;\n}", "{\n  int maxLen = max(a.length,\
    \ b.length);\n  string result;\n  foreach(int i; 0 .. maxLen)\n  {\n    result\
    \ ~= ((a[i] == b[i]) ? \"0\" : \"1\");\n  }\n  return result;\n}\n// Test cases\n\
    unittest \n{\n  // Test 1\n  assert(string_xor(\"010\", \"110\") == \"100\");\n\
    \  // Test 2\n  assert(string_xor(\"111\", \"111\") == \"000\");\n  // Test 3\n\
    \  assert(string_xor(\"000\", \"000\") == \"000\");\n  // Test 4\n  assert(string_xor(\"\
    001\", \"101\") == \"100\");\n  // Test 5\n  assert(string_xor(\"101101110101101111101010011101011110100101111010\"\
    , \"101101110101101111101010011101011110100101111010\") == \"00000000000000000000000000000000000000000000000000\"\
    );\n  // Test 6\n  assert(string_xor(\"110101111001101011111010110010010001111111100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100",
  "{\n    string result = \"\";\n    for (size_t i = 0; i < a.length; i++) \n    {\n\
    \        result += a[i] == b[i] ? '0' : '1';\n    }\n    return result;\n}", "{\n\
    \    return std.toString(int.parse(a, 2) ^ int.parse(b, 2), 2);\n}\n```", "{\n\
    \    string result = \"\";\n    foreach(char ch; zip(a, b))\n    {\n        result\
    \ ~= (((ch[0] ^ ch[1]) == 0) ? '0' : '1');\n    }\n    return result;\n}", "{\n\
    \    string result = \"\";\n    for (int i = 0; i < a.length; i++) \n    {\n \
    \       if (a[i] == b[i])\n            result += \"0\";\n        else\n      \
    \      result += \"1\";\n    }\n    return result;\n}", "{\n    string c = \"\"\
    ;\n    foreach(i, s; a) \n    {\n        c ~= ((a[i] == b[i]) ? \"0\" : \"1\"\
    );\n    }\n    return c;\n}\n \n/*\n * Convert a hexadecimal string to a binary\
    \ string\n */\nstring hex_to_bin(string hex_str) \n{\n    string bin_str = \"\"\
    ;\n    foreach(i, c; hex_str) \n    {\n        auto n = to!int(c);\n        string\
    \ hex_nibble;\n        while(n != 0) \n        {\n            auto rem = n % 2;\n\
    \            hex_nibble ~= (rem ? \"1\" : \"0\");\n            n /= 2;\n     \
    \   }\n        while(hex_nibble.length() < 4) \n        {\n            hex_nibble\
    \ ~= \"0\";\n        }\n        bin_str ~= hex_nibble[$-4..$];\n    }\n    return\
    \ bin_str;\n}\n \n/*\n * Convert a binary string to a hexadecimal string\n */\n\
    string bin_to_hex(string bin_str) \n{\n    string hex_str = \"\";\n    for(uint\
    \ start = 0; start < bin_str.length(); start += 4) \n    {\n        auto bin_nibble\
    \ = bin_str[start..start+3];\n        while(bin_nibble.length() < 4) \n      \
    \  {\n            bin_nibble ~= \"0\";\n        }\n        int n = 0;\n      \
    \  int i = 0;\n        foreach(c; bin_nibble) \n        {\n            n += (c\
    \ == \"1\" ? 1 : 0) * pow(2, i);\n            i++;\n        }\n        hex_str\
    \ ~= format(\"%x\", n);\n    }\n    return hex_str;\n}\n \n/*\n * Convert a number\
    \ to a hexadecimal string\n */\nstring num_to_hex(int num) \n{\n    return format(\"\
    %x\", num);\n}\n \n/*\n * Convert a hexadecimal string to a number", "{\n    string\
    \ res = \"\";\n    int asize = a.length();\n    int bsize = b.length();\n    if\
    \ (asize >= bsize)\n    {\n        for (int i = bsize - 1; i >= 0; i--)\n    \
    \    {\n            res = to!string(a[i] ^ b[i]) ~ res;\n        }\n        for\
    \ (int i = asize - bsize - 1; i >= 0; i--)\n        {\n            res = to!string(a[i])\
    \ ~ res;\n        }\n    }\n    else\n    {\n        for (int i = asize - 1; i\
    \ >= 0; i--)\n        {\n            res = to!string(a[i] ^ b[i]) ~ res;\n   \
    \     }\n        for (int i = bsize - asize - 1; i >= 0; i--)\n        {\n   \
    \         res = to!string(b[i]) ~ res;\n        }\n    }\n    return res;\n}",
  "{\n    string result = \"\";\n    for (int i = 0; i < a.length; i++) \n    {\n\
    \        int n = (a[i]-'0') ^ (b[i]-'0');\n        result += to!string(n);\n \
    \   }\n    return result;\n}", "{\n    string result = \"\";\n    foreach(int\
    \ i; 0 .. a.length) \n    {\n        result ~= (a[i] == b[i]) ? \"0\" : \"1\"\
    ;\n    }\n    return result;\n}\n \n \n//void main()\n//{\n//    auto y = string_xor(\"\
    010\", \"110\");\n//    writefln(\"%s\", y);\n//}", "{\n    // Make sure each\
    \ string has the same length\n    assert(a.length == b.length);\n    string result\
    \ = \"\";\n    foreach(char c; zip(a, b))\n    {\n        result ~= (c[0] == c[1])\
    \ ? '0' : '1';\n    }\n    return result;\n}", "{\n    string res;\n    if(a.length\
    \ != b.length)\n    {\n        return \"\";\n    }\n    res.length = a.length;\n\
    \    foreach(i, ref c; res)\n    {\n        if(a[i] == b[i])\n        {\n    \
    \        c = '0';\n        }\n        else\n        {\n            c = '1';\n\
    \        }\n    }\n    return res;\n}", "{\n    string result;\n    for (int i\
    \ = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n            result\
    \ ~= \"0\";\n        else\n            result ~= \"1\";\n    }\n    return result;\n\
    }", "{\n    if (a.length != b.length)\n        return null;\n    string s = \"\
    \";\n    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i])\n\
    \            s += \"0\";\n        else\n            s += \"1\";\n    }\n    return\
    \ s;\n}", "{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= c ^ b[i];\n    }\n    return result;\n}", "{\n    // xor\n    string r;\n\
    \    r.length = a.length;\n    for (uint i = 0; i < a.length; i++) \n    {\n \
    \       r[i] = a[i] ^ b[i];\n    }\n    return r;\n}", "{\n    // Assuming a and\
    \ b are of equal length and consist only of 1s and 0s\n    string result = \"\"\
    ;\n    for (int i = 0; i < a.length; i++)\n    {\n        result += (a[i] ^ b[i]);\n\
    \    }\n    return result;\n}", "{\n    string res = \"\";\n    for (int i = 0;\
    \ i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n        \
    \    res += \"0\";\n        } \n        else \n        {\n            res += \"\
    1\";\n        }\n    }\n    return res;\n}", "{\n    // Generating the result\
    \ string from XOR'ing each corresponding character in a and b\n    string result\
    \ = \"\";\n    foreach(i, c; a)\n    {\n        result ~= c ^ b[i];\n    }\n \
    \   return result;\n}", "{\n    string result = \"\";\n    for (int i = 0; i <\
    \ a.length; i++)\n    {\n        if (a[i] == b[i])\n        {\n            result\
    \ += \"0\";\n        }\n        else\n        {\n            result += \"1\";\n\
    \        }\n    }\n    return result;\n}\n/*\n    XOR strings in array together\
    \ with previous strings\n    \"001\" ^ \"110\" = \"111\"\n    \"111\" ^ \"010\"\
    \ = \"101\"\n    \"101\" ^ \"101\" = \"000\"\n*/\nstring string_xor_prev(string\
    \ s)\n{\n    string result = \"\";\n    string prev = \"000\";\n    foreach (i;\
    \ 0 .. s.length)\n    {\n        result = string_xor(prev, s[i]);\n        prev\
    \ = result;\n    }\n    return result;\n}", "{\n    string res = \"\";\n    foreach(int\
    \ i; 0 .. a.length) \n    {\n        res ~= a[i] ^ b[i];\n    }\n    return res;\n\
    }", "{\n  string res;\n  foreach(immutable char, i, immutable j; a, b)\n  {\n\
    \    res ~= j ^ i;\n  }\n  return res;\n}", "{\n    string result;\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result ~= (a[i] ^ b[i]);\n    }\n\
    \    return result;\n}", "{\n    string x = \"\";\n    if(a.length != b.length)\n\
    \    {\n        writeln(\"Error: inputs are not the same length!\");\n       \
    \ return x;\n    }\n    foreach(i, c; a)\n    {\n        if(c != b[i])\n     \
    \   {\n            x = x ~ \"1\";\n        }\n        else\n        {\n      \
    \      x = x ~ \"0\";\n        }\n    }\n    return x;\n}", "{\n    auto n = a.length;\n\
    \    assert(b.length == n);\n    string result;\n    result.length = n;\n    auto\
    \ resultPtr = &result[0];\n    auto aPtr = &a[0];\n    auto bPtr = &b[0];\n  \
    \  for (auto i = 0; i < n; i++)\n    {\n        resultPtr[i] = aPtr[i] ^ bPtr[i];\n\
    \    }\n    return result;\n}", "{\n    int i;\n    int len = min(a.length, b.length);\n\
    \    string result;\n    for (i = 0; i < len; i++)\n    {\n        if (a[i] ==\
    \ b[i])\n            result ~= \"0\";\n        else\n            result ~= \"\
    1\";\n    }\n    return result;\n}", "{\n    int a_length = a.length;\n    int\
    \ b_length = b.length;\n    string answer = \"\";\n    foreach(i; 0 .. min(a_length,\
    \ b_length)) \n    {\n        bool add_one = a[i] == '1' && b[i] == '1';\n   \
    \     bool either_one = a[i] == '1' || b[i] == '1';\n        answer ~= (add_one\
    \ || !either_one) ? '0' : '1';\n    }\n    return answer;\n}", "{\n    string\
    \ res = \"\";\n    foreach(char i, char j; zip(a, b))\n    {\n        res ~= i\
    \ ^ j;\n    }\n    return res;\n}", "{\n    int l = min(a.length, b.length);\n\
    \    string result = \"\";\n    for (int i = 0; i < l; i++)\n    {\n        if\
    \ (a[i] == b[i])\n            result ~= \"0\";\n        else\n            result\
    \ ~= \"1\";\n    }\n    return result;\n}", "{\n    int size = a.length;\n   \
    \ string ret;\n    for (int i = 0; i < size; i++) {\n        if (a[i] == b[i])\
    \ ret ~= \"0\";\n        else ret ~= \"1\";\n    }\n    return ret;\n}", "{\n\
    \    // Converts char to int\n    int s1 = to!int(a);\n    int s2 = to!int(b);\n\
    \    // Converts int to string binary\n    string s3 = format(\"%b\", s1 ^ s2);\n\
    \    return s3;\n}", "{\n    enum flag = 0;\n    foreach(immutable char a; a){\n\
    \        foreach(immutable char b; b){\n            if(a[0] == b[0])\n       \
    \         flag = 1;\n            else\n                flag = 0;\n        }\n\
    \    }\n    return flag.to!string;\n}", "{\n    string result = \"\";\n    for\
    \ (size_t i = 0; i < a.length; i++)\n    {\n        result += cast(char)('0' +\
    \ (a[i] ^ b[i]));\n    }\n    return result;\n}", "{\n    char[] res = new char[a.length];\n\
    \    for (int i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i])\n \
    \           res[i] = '0';\n        else\n            res[i] = '1';\n    }\n  \
    \  return to!string(res);\n}", "{\n    string result = \"\";\n    foreach(i, ch;\
    \ a) \n    {\n        result ~= a[i] != b[i] ? '1' : '0';\n    }\n    return result;\n\
    }\n// Example implementation of RC4 stream cypher. \n// Does not include key scheduling",
  "{\n    static string res;\n    static string zeros = \"\";\n    static string ones\
    \ = \"\";\n    static int len;\n    static uint i;\n    //Make strings same length\n\
    \    if (a.length < b.length)\n    {\n        foreach(i;0..b.length-a.length)\n\
    \            zeros ~= \"0\";\n        a = zeros ~ a;\n    }\n    else if (a.length\
    \ > b.length)\n    {\n        foreach(i;0..a.length-b.length)\n            zeros\
    \ ~= \"0\";\n        b = zeros ~ b;\n    }\n    //XOR strings\n    foreach(i;0..a.length)\n\
    \    {\n        if (a[i] == b[i])\n            res ~= \"0\";\n        else\n \
    \           res ~= \"1\";\n    }\n    return res;\n}\n ", "{\n    string result\
    \ = \"\";\n    const size_t min = min(a.length, b.length);\n    for (uint i =\
    \ 0; i < min; i++) \n    {\n        char l = a[i];\n        char r = b[i];\n \
    \       if ((l == '0' && r == '0') || (l == '1' && r == '1'))\n            result\
    \ ~= '0';\n        else\n            result ~= '1';\n    }\n    return result;\n\
    }\n/*\nstring a, b;\nunittest \n{\n    a = \"010\";\n    b = \"110\";\n    assert(string_xor(a,\
    \ b) == \"100\");\n}\n*/", "{\n    int len = min(a.length, b.length);\n    string\
    \ res = \"\";\n    for (int i = 0; i < len; i++)\n    {\n        if (a[i] == b[i])\n\
    \            res += \"0\";\n        else\n            res += \"1\";\n    }\n \
    \   return res;\n}", "{\n    return format(\"%0*x\", max(a.length, b.length),\
    \ to!(long)(a, 2) ^ to!(long)(b, 2));\n}\n/*\nYou are given two arrays of equal\
    \ length.\nEach array contains only 0s and 1s.\nYour task is to determine the\
    \ number of positions in which the digits are the same.\nFor example:\n    Input:\
    \ [1, 0, 1, 0, 1, 1], [0, 1, 1, 1, 0, 1]\n    Output: 3\n*/", "{\n\tstring result\
    \ = \"\";\n\t\n\tforeach(int x; a)\n\t{\n\t\tif (x == int.init)\n\t\t\tthrow new\
    \ Exception(\"string_xor: a contains non binary characters.\");\n\t}\n\t\n\tforeach(int\
    \ x; b)\n\t{\n\t\tif (x == int.init)\n\t\t\tthrow new Exception(\"string_xor:\
    \ b contains non binary characters.\");\n\t}\n\t\n\tif (a.length != b.length)\n\
    \t\tthrow new Exception(\"string_xor: a and b have different lengths.\");\n\t\n\
    \tforeach(int x; a)\n\t{\n\t\tresult ~= cast(string) (x ^ b[$]);\n\t}\n\t\n\t\
    return result;\n}", "{\n    string result = \"\";\n    foreach(immutable char\
    \ ca, immutable char cb; a, b)\n    {\n        if (ca == cb)\n            result\
    \ ~= \"0\";\n        else\n            result ~= \"1\";\n    }\n    return result;\n\
    }", "{\n    int len = 0;\n    if(a.length>b.length)\n    {\n        len = a.length;\n\
    \    }\n    else\n    {\n        len = b.length;\n    }\n    string s = \"\";\n\
    \    for(int i=0;i<len;i++)\n    {\n        s = s + \"0\";\n    }\n    char c[]\
    \ = toStringz(s);\n    return c;\n}", "{\n    string output = new string;\n  \
    \  int len = min(a.length, b.length);\n    foreach(int i; 0 .. len)\n    {\n \
    \       if(a[i] == b[i])\n            output ~= \"0\";\n        else\n       \
    \     output ~= \"1\";\n    }\n    return output;\n}", "{\n  string result;\n\
    \  int N = a.length;\n  for (int i = 0; i < N; i++)\n  {\n    result ~= a[i] ^\
    \ b[i];\n  }\n  return result;\n}", "{\n    string result = \"\";\n    for (size_t\
    \ i = 0; i < max(a.length, b.length); i++)\n    {\n        int aa = 0;\n     \
    \   int bb = 0;\n        if (i < a.length)\n            aa = a[i] == '1' ? 1 :\
    \ 0;\n        if (i < b.length)\n            bb = b[i] == '1' ? 1 : 0;\n     \
    \   result += (aa ^ bb) == 1 ? \"1\" : \"0\";\n    }\n    return result;\n}",
  "{\n    string result;\n    for (int i = 0; i < a.length; i++) \n    {\n       \
    \ if (a[i] == b[i]) \n        {\n            result += \"0\";\n        } \n  \
    \      else \n        {\n            result += \"1\";\n        }\n    }\n    return\
    \ result;\n}", "{\n  string c = \"\";\n  foreach(int i; 0 .. b.length)\n  {\n\
    \    char temp = a[i]^b[i];\n    c ~= (temp < 10 ? ('0' + temp) : ('A' + temp\
    \ - 10));\n  }\n  return c;\n}", "{\n    // TODO: Implement string_xor()\n   \
    \ string result = \"\";\n    foreach(i,char; a)\n    {\n        result ~= (i <\
    \ b.length ? to!string(to!int(a[i]) ^ to!int(b[i])) : a[i]);\n    }\n    return\
    \ result;\n}", "{\n    assert(a.length == b.length);\n    string result = \"\"\
    ;\n    foreach(i, v; a)\n    {\n        result ~= (v == b[i]) ? '0' : '1';\n \
    \   }\n    return result;\n}", "{\n\tstring result = \"\";\n\tforeach(int i; 0\
    \ .. a.length)\n\t{\n\t\tresult ~= (a[i] != b[i])? \"1\" : \"0\";\n\t}\n\treturn\
    \ result;\n}", "{\n  auto res = new string;\n  auto len = min(a.length, b.length);\n\
    \  for (size_t i = 0; i < len; i++) \n  {\n    if (a[i] != b[i])\n      res ~=\
    \ \"1\";\n    else\n      res ~= \"0\";\n  }\n  if (a.length > len)\n    res ~=\
    \ a[len..$];\n  else if (b.length > len)\n    res ~= b[len..$];\n  return res;\n\
    }", "{\n  //convert input strings to ulongs\n  auto ai = to!ulong(a, 2);\n  auto\
    \ bi = to!ulong(b, 2);\n  //perform the XOR\n  auto result = ai ^ bi;\n  //convert\
    \ result back to a string and return it\n  return to!string(result, 2);\n}\n```",
  "{\n    string ret = \"\";\n    foreach(i, item; a)\n    {\n        ret ~= ((item\
    \ - '0') ^ (b[i] - '0')) + '0';\n    }\n    return ret;\n}", "{\n    string result\
    \ = \"\";\n    foreach(immutable idx, immutable elem; a)\n    {\n        result\
    \ ~= (a[idx] ^ b[idx]).to!string;\n    }\n    return result;\n}", "{\n   string\
    \ result = \"\";\n   foreach(i, c; a) \n   {\n      result ~= c ^ b[i];\n   }\n\
    \   return result;\n}", "{\n    assert(a.length == b.length);\n    char result[a.length];\n\
    \    foreach(i, ref aa; a) {\n        result[i] = '0' + (aa - '0') ^ (b[i] - '0');\n\
    \    }\n    return result.dup;\n}", "{\n    int len = min(a.length, b.length);\n\
    \    string result;\n    for (int i = 0; i < len; i++)\n    {\n        // If one\
    \ has 1 and other is 0, result is 1\n        if ((a[i] == '1' && b[i] == '0')\
    \ || (a[i] == '0' && b[i] == '1'))\n            result.append(\"1\");\n      \
    \  else\n            result.append(\"0\");\n    }\n    return result;\n}", "{\n\
    \    string result;\n    int i;\n    int length = a.length;\n    for (i = 0; i\
    \ < length; i++) {\n        if (a[i] == b[i]) {\n            result += \"0\";\n\
    \        } else {\n            result += \"1\";\n        }\n    }\n    return\
    \ result;\n}", "{\n    string ret = \"\";\n    foreach(immutable i, immutable\
    \ c1; a)\n    {\n        const char c2 = b[i];\n        if((c1 == '0' && c2 ==\
    \ '0') || (c1 == '1' && c2 == '1'))\n            ret ~= '0';\n        else\n \
    \           ret ~= '1';\n    }\n    return ret;\n}", "{\n    string c;\n    int\
    \ length = min(a.length, b.length);\n    foreach(i; 0 .. length)\n    {\n    \
    \    if(a[i] == b[i])\n            c ~= '0';\n        else\n            c ~= '1';\n\
    \    }\n    return c;\n}", "{\n    string result;\n    foreach(int i, char ca,\
    \ a)\n    {\n        result ~= (ca ^ b[i]);\n    }\n    return result;\n}", "{\n\
    \    string c;\n    foreach(int i; 0 .. a.length)\n    {\n        if(a[i] == b[i])\n\
    \            c ~= \"0\";\n        else\n            c ~= \"1\";\n    }\n    return\
    \ c;\n}", "{\n    assert(a.length == b.length);\n    string res = \"\";\n    foreach(immutable\
    \ x; a)\n    {\n        // Mixin(\"res~=cast(string)((x^b[x]));\");\n        res\
    \ ~= cast(string)((x^b[x]));\n    }\n    return res;\n}", "{\n    string c = \"\
    \";\n    int len = a.length > b.length ? a.length : b.length;\n    foreach(int\
    \ i; 0 .. len)\n    {\n        char a_ = a.length <= i ? '0' : a[i];\n       \
    \ char b_ = b.length <= i ? '0' : b[i];\n        c ~= (a_ ^ b_).to!string;\n \
    \   }\n    return c;\n}\n/*\n    >>> count_overlap(\"abcdef\", \"abc\")\n    1\n\
    \    >>> count_overlap(\"abcdef\", \"abcd\")\n    0\n    >>> count_overlap(\"\
    abcdef\", \"abcde\")\n    1\n    >>> count_overlap(\"abcdef\", \"abcdef\")\n \
    \   0\n    >>> count_overlap(\"abcdef\", \"\")\n    0\n    >>> count_overlap(\"\
    \", \"\")\n    0\n*/", "{\n    return ((a^b).to!string);\n}", "{\n    // Your\
    \ code here\n    int n = a.length;\n    string res = \"\";\n    foreach(ch; zip(a,\
    \ b))\n        res ~= to!string(ch[0] ^ ch[1]);\n    return res;\n}", "{\n   \
    \ if (a.length != b.length) \n    {\n        return \"\";\n    }\n    string result;\n\
    \    foreach (x; 0 .. a.length) \n    {\n        result ~= (a[x] ^ b[x]).to!string;\n\
    \    }\n    return result;\n}", "{\n  int n = min(a.length, b.length);\n  string\
    \ result;\n  for (int i = 0; i < n; i++)\n    result ~= (a[i] == b[i]) ? '0' :\
    \ '1';\n  return result;\n}", "{\n    string res = \"\";\n    if(a.length != b.length)\
    \ return res;\n    foreach(int i, char c; a) {\n        if(a[i] == b[i])\n   \
    \         res ~= \"0\";\n        else\n            res ~= \"1\";\n    }\n    return\
    \ res;\n}", "{\n    string res = \"\";\n    for (int i = 0; i < min(a.length,\
    \ b.length); i++) \n    {\n        if (a[i] == b[i]) \n        {\n           \
    \ res += \"0\";\n        }\n        else \n        {\n            res += \"1\"\
    ;\n        }\n    }\n    return res;\n}", "{\n    import std.algorithm.iteration\
    \ : map;\n    import std.range : zip;\n    import std.conv : to;\n    import std.string\
    \ : toString;\n    return a.zip(b).map!(t => (to!int(t[0]) ^ to!int(t[1])).toString()).joiner;\n\
    }", "{\n    string result;\n    int i = 0;\n    while(i < a.length)\n    {\n \
    \       result ~= (a[i] ^ b[i]);\n        i++;\n    }\n    return result;\n}",
  "{\n    size_t n = max(a.length, b.length);\n    string s;\n    s.length = n;\n\
    \    for (size_t i = 0; i < n; i++) \n    {\n        int ai = 0;\n        if (i\
    \ < a.length) \n        {\n            ai = a[i] - '0';\n        }\n        int\
    \ bi = 0;\n        if (i < b.length) \n        {\n            bi = b[i] - '0';\n\
    \        }\n        int si = ai ^ bi;\n        s[i] = si + '0';\n    }\n    return\
    \ s;\n}", "{\n  int size = cast(int)a.length;\n  string result = \"\";\n  for\
    \ (int i = 0; i < size; i++)\n  {\n    if (a[i] == b[i])\n      result ~= \"0\"\
    ;\n    else\n      result ~= \"1\";\n  }\n  return result;\n}", "{\n  string xor\
    \ = \"\";\n  for (int i = 0; i < a.length; i++) \n  {\n    xor ~= ((a[i] + b[i])\
    \ % 2).to!string;\n  }\n  return xor;\n}", "{\n  int result = 0;\n  foreach(i,\
    \ aa; a) \n  {\n    int bb = b[i] - '0';\n    result = (aa ^ bb) + 2 * result;\n\
    \  }\n  return to!string(result);\n}", "{\n    return mixin(\"\\\"\" ~ b[a.length]\
    \ ~ \"\\\"\");\n}", "{\n    int alen = a.length;\n    int blen = b.length;\n \
    \   int len = min(alen, blen);\n    string res = new string[len];\n    for (int\
    \ i = 0; i < len; i++)\n    {\n        int a_i = a[i] - '0';\n        int b_i\
    \ = b[i] - '0';\n        res[i] = to!string(a_i ^ b_i);\n    }\n    return res.join(\"\
    \");\n}", "{\n    string result = \"\";\n    if (a.length != b.length)\n     \
    \   return result;\n    for (int i = 0; i < a.length; i++)\n    {\n        result\
    \ += a[i] == b[i] ? '0' : '1';\n    }\n    return result;\n}\nstring string_xor2(string\
    \ a, string b) \n{\n    string result = \"\";\n    if (a.length != b.length)\n\
    \        return result;\n    for (int i = 0; i < a.length; i++)\n    {\n     \
    \   result ~= (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}", "{\n\
    \    string ans = \"\";\n    for (int i = 0; i < a.length; i++)\n    {\n     \
    \   if (a[i] == b[i])\n            ans += \"0\";\n        else\n            ans\
    \ += \"1\";\n    }\n    return ans;\n}\n/*\n Input are two strings a and b consisting\
    \ only of 1s and 0s.\n    Perform binary OR on these inputs and return result\
    \ also as a string.\n    >>> string_or(\"010\", \"110\")\n    \"110\"\n*/\nstring\
    \ string_or(string a, string b) \n{\n    string ans = \"\";\n    for (int i =\
    \ 0; i < a.length; i++)\n    {\n        if (a[i] == \"1\" || b[i] == \"1\")\n\
    \            ans += \"1\";\n        else\n            ans += \"0\";\n    }\n \
    \   return ans;\n}\n/*\n Input are two strings a and b consisting only of 1s and\
    \ 0s.\n    Perform binary AND on these inputs and return result also as a string.\n\
    \    >>> string_and(\"010\", \"110\")\n    \"010\"\n*/\nstring string_and(string\
    \ a, string b) \n{\n    string ans = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == \"1\" && b[i] == \"1\")\n            ans +=\
    \ \"1\";\n        else\n            ans += \"0\";\n    }\n    return ans;\n}\n\
    /*\n Input is a string consisting only of 1s and 0s.\n    Perform binary NOT on\
    \ this input and return result also as a string.\n    >>> string_not(\"010\")\n\
    \    \"101\"\n*/\nstring string_not(string a) \n{\n    string ans = \"\";\n  \
    \  for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == \"1\")\n   \
    \         ans += \"0\";\n        else\n            ans += \"1\";\n    }\n    return\
    \ ans;\n}\n/*\n Input is a string consisting only of 1s and 0s.\n    Shift left\
    \ binary input by one and return result also as", "{\n  string result;\n  foreach(i,\
    \ c; a)\n    result ~= (a[i] != b[i] ? '1' : '0');\n  return result;\n}", "{\n\
    \t// Generate random salt and convert to string for result.\n\tstring strSalt\
    \ = \"\";\n\tfor (int i = 0; i < a.length; i++)\n\t{\n\t\tstrSalt += a[i] ^ b[i];\n\
    \t}\n\treturn strSalt;\n}\n/*\nReturn a new string that concatenates all the characters\
    \ in a\n    and b.\n    >>> combine(\"abc\", \"def\")\n    \"abcdef\"\n*/\nstring\
    \ combine(string a, string b)\n{\n\tstring concat;\n\tconcat = a ~ b;\n\treturn\
    \ concat;\n}\n/*\n    Return a new string with the leading and trailing space\n\
    \    characters removed from a.\n    >>> remove_leading_and_trailing_spaces(\"\
    \ abc \")\n    \"abc\"\n*/\nstring remove_leading_and_trailing_spaces(string a)\n\
    {\n\tauto temp = a.strip();\n\tstring removed;\n\tremoved = temp.idup;\n\treturn\
    \ removed;\n}\n/*\n    Return a new string with the leading and trailing\n   \
    \ space characters removed from a and all\n    contiguous space characters compressed\
    \ to a single space.\n    >>> remove_leading_and_trailing_spaces(\" a  b  c \"\
    )\n    \"a b c\"\n*/\nstring remove_leading_and_trailing_spaces_and_compress(string\
    \ a)\n{\n\tauto temp = a.strip();\n\tstring removed;\n\tremoved = temp.replace(\"\
    \  \", \" \");\n\treturn removed;\n}\n/*\n    Return a new string in which a is\
    \ converted to upper case.\n    >>> string_upper(\"abc\")\n    \"ABC\"\n*/\nstring\
    \ string_upper(string a)\n{\n\tstring upper;\n\tupper = a.toUpper;\n\treturn upper;\n\
    }\n/*\n    Return a new string in which a is converted to lower case.\n    >>>\
    \ string_lower(\"ABC\")\n    \"abc\"\n*/\nstring string_lower(string a)\n{\n\t\
    string lower;\n\tlower = a.toLower;\n\treturn lower;\n}\n/*\n    Return a new\
    \ string that is a reversed copy of a.\n", "{\n    string s = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (a[i] == b[i]) \n        {\n \
    \           s += \"0\";\n        } \n        else \n        {\n            s +=\
    \ \"1\";\n        }\n    }\n    return s;\n}", "{\n  string res;\n  foreach(char\
    \ ca, a)\n  {\n    foreach(char cb, b)\n    {\n      res ~= ca ^ cb;\n    }\n\
    \  }\n  return res;\n}", "{\n    immutable n = a.length;\n    if (n != b.length)\
    \ return \"\";\n    auto result = a.dup;\n    foreach (immutable i, ref e; result)\n\
    \    {\n        if (a[i] == b[i])\n            e = '0';\n        else\n      \
    \      e = '1';\n    }\n    return result;\n}", "{\n    string res = \"\";\n \
    \   for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == b[i]) res +=\
    \ \"0\";\n        else res += \"1\";\n    }\n    return res;\n}", "{\n  if (a.length\
    \ < b.length)\n  {\n    string tmp = a;\n    a = b;\n    b = tmp;\n  }\n  // a\
    \ is now the longer string and b the shorter one\n  string result = \"\";\n  int\
    \ carry = 0;\n  for (int i = 1; i <= a.length; i++)\n  {\n    int a_digit = int(a[$\
    \ - i]) - 48;\n    int b_digit = 0;\n    if (i <= b.length)\n      b_digit = int(b[$\
    \ - i]) - 48;\n    int sum = a_digit ^ b_digit ^ carry;\n    result = (string)sum\
    \ + result;\n    carry = (a_digit & b_digit) | (b_digit & carry) | (a_digit &\
    \ carry);\n  }\n  if (carry)\n    result = \"1\" + result;\n  return result;\n\
    }", "{\n    // your code here\n    string res = \"\";\n    int i = 0;\n    foreach(ch1,ch2;\
    \ zip(a,b))\n    {\n      res ~= (ch1 ^ ch2) ? \"1\" : \"0\";\n    }\n    return\
    \ res;\n}", "{\n    string r = \"\";\n    foreach(int i; 0 .. a.length)\n    {\n\
    \        r ~= (a[i] == b[i]) ? \"0\" : \"1\";\n    }\n    return r;\n}", "{\n\
    \  string ret = \"\";\n  for (int i = 0; i < a.length; i++)\n  {\n    ret ~= ((a[i]\
    \ == '1') ^ (b[i] == '1')) ? '1' : '0';\n  }\n  return ret;\n}\n/*\n  Returns\
    \ the digits of the positive integer n\n    >>> split(1234)\n    [1, 2, 3, 4]\n\
    \    >>> split(12)\n    [1, 2]\n    >>> split(1234567890)\n    [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 0]\n*/", "{\n    int a_len = a.length();\n    int b_len = b.length();\n\
    \    string result = \"\";\n    if (a_len != b_len)\n    {\n        if (a_len\
    \ > b_len)\n        {\n            b = b.rep(a_len);\n        }\n        else\n\
    \        {\n            a = a.rep(b_len);\n        }\n    }\n    for (int i =\
    \ 0; i < a.length(); i++)\n    {\n        if (a[i] == b[i])\n        {\n     \
    \       result ~= \"0\";\n        }\n        else\n        {\n            result\
    \ ~= \"1\";\n        }\n    }\n    return result;\n}\n \n \n \n \n/*\nInput is\
    \ a string a consisting only of 1s and 0s.\n    Perform binary NOT on input and\
    \ return result also as a string.\n    >>> string_not(\"010\")\n    \"101\"\n\
    \    \n*/\nstring string_not(string a) \n{\n    string result = \"\";\n    for\
    \ (int i = 0; i < a.length(); i++)\n    {\n        if (a[i] == '0')\n        {\n\
    \            result ~= \"1\";\n        }\n        else\n        {\n          \
    \  result ~= \"0\";\n        }\n    }\n    return result;\n}\n \n \n \n \n/*\n\
    Input is two strings a and b consisting only of 1s and 0s.\n    Perform binary\
    \ AND on these inputs and return result also as a string.\n    >>> string_and(\"\
    110\", \"101\")\n    \"100\"\n    \n*/\nstring string_and(string a, string b)\
    \ \n{\n    int a_len = a.length();\n    int b_len = b.length();\n    string result\
    \ = \"\";\n    if (a_len != b_len)\n    {\n        if (a_len > b_len)\n      \
    \  {\n            b = b.rep(a_len);\n        }\n        else\n        {\n    \
    \        a = a.rep(b_len);\n        }\n    }\n    for (int i = 0; i <", "{\n \
    \ string result = \"\";\n  foreach(i, x; a)\n    result ~= x ^ b[i];\n  return\
    \ result;\n}", "{\n    string res = \"\";\n    for (int i = 0; i < a.length; i++)\n\
    \    {\n      if (a[i] == b[i])\n        res += \"0\";\n      else\n        res\
    \ += \"1\";\n    }\n    return res;\n}", "{\n  string result;\n  int n = min(a.length,\
    \ b.length);\n  foreach (int i; 0 .. n) \n  {\n    if (a[i] == b[i])\n      result\
    \ ~= \"0\";\n    else\n      result ~= \"1\";\n  }\n  return result;\n}", "{\n\
    \tint la = a.length;\n\tint lb = b.length;\n\tint size = (la > lb) ? la : lb;\n\
    \tstring ret = \"\";\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tbool l = (i <\
    \ la) ? (a[la - i - 1] == '1') : false;\n\t\tbool r = (i < lb) ? (b[lb - i - 1]\
    \ == '1') : false;\n\t\tret += (l ^ r) ? \"1\" : \"0\";\n\t}\n\treturn ret.reverse;\n\
    }\n/*\n This is used to convert a negative int to binary string.\n We generate\
    \ a binary string of the same length as the number\n and place the negative sign\
    \ at the beginning.\n*/\nstring negate(int a) \n{\n\tstring ret = \"\";\n\tfor\
    \ (int i = 0; i < int.sizeof * 8; i++)\n\t{\n\t\tret += '0';\n\t}\n\tfor (int\
    \ i = 0; i < int.sizeof * 8; i++)\n\t{\n\t\tif (a & (1 << i))\n\t\t{\n\t\t\tret[i]\
    \ = '1';\n\t\t}\n\t}\n\treturn \"-\" ~ ret;\n}", "{\n    string ret=\"\";\n  \
    \  for(uint i=0;i<a.length;i++)\n    {\n        if(a[i]==b[i]) ret+=\"0\";\n \
    \       else ret+=\"1\";\n    }\n    return ret;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
