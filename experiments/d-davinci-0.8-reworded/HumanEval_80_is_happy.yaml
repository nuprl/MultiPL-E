name: HumanEval_80_is_happy
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYou are given a string s.\n \
  \   Your task is to check if the string is hapd or not.\n    A string is hapd if\
  \ its length is at least 3 and every 3 consecutive letters are distinct\n    For\
  \ example:\n    >>> is_happy(a)\n    false\n    >>> is_happy(aa)\n    false\n  \
  \  >>> is_happy(abcd)\n    true\n    >>> is_happy(aabb)\n    false\n    >>> is_happy(adb)\n\
  \    true\n    >>> is_happy(xyy)\n    false\n    \n*/\nbool is_happy(string s) \n"
tests: "unittest\n{\n    alias candidate = is_happy;\n\n    assert(candidate(\"a\"\
  ) == false);\n    assert(candidate(\"aa\") == false);\n    assert(candidate(\"abcd\"\
  ) == true);\n    assert(candidate(\"aabb\") == false);\n    assert(candidate(\"\
  adb\") == true);\n    assert(candidate(\"xyy\") == false);\n    assert(candidate(\"\
  iopaxpoi\") == true);\n    assert(candidate(\"iopaxioi\") == false);\n}\nvoid main(){}"
completions: ["{\n    if (s.length < 3) \n        return false;\n    for (int i =\
    \ 0; i < s.length - 2; i++) \n    {\n        if (s[i] == s[i + 1] || s[i] == s[i\
    \ + 2] || s[i + 1] == s[i + 2]) \n            return false;\n    }\n    return\
    \ true;\n}", "{\n    bool isHappy = true;\n    for (int i = 0; i < s.length()\
    \ - 2; i++)\n    {\n        string t = s[i..$];\n        if (s[i] == s[i + 1]\
    \ || s[i] == s[i + 2] || s[i + 1] == s[i + 2])\n        {\n            isHappy\
    \ = false;\n            break;\n        }\n    }\n    return isHappy;\n}", "{\n\
    \    if (s.length < 3)\n        return false;\n    else\n    {\n        auto temp\
    \ = s[0..$-2];\n        bool found = false;\n        for (size_t i = 0; i < temp.length;\
    \ i++)\n        {\n            if (s[i] == s[i+1] && s[i+1] == s[i+2])\n     \
    \       {\n                found = true;\n                break;\n           \
    \ }\n        }\n        return !found;\n    }\n}", "{\n    static assert(isInputRange!string);\n\
    \    static assert(hasLength!string);\n    static assert(isForwardRange!string);\n\
    \    static assert(hasAssignableElements!string);\n    static assert(is(typeof(s[0])\
    \ == dchar));\n    static assert(isSomeChar!(ElementType!string));\n    static\
    \ assert(!hasElaborateDestructor!(ElementType!string));\n    static assert(is(ElementType!string\
    \ == dchar));\n    static assert(isIntegral!(ElementType!string));\n    static\
    \ assert(isNarrowString!string);\n    static assert(isNarrowString!(ElementType!string));\n\
    \    static assert(is(typeof({ s[0] = 'a'; }) == dchar));\n    static assert(is(typeof({\
    \ s[0] = s[0]; }) == dchar));\n    static assert(is(typeof({ \"a\"c; }) == char));\n\
    \    static assert(is(typeof({ char[1] a; }) == string));\n    static assert(is(typeof({\
    \ char[] a; }) == string));\n    static assert(is(typeof({ string a; }) == string));\n\
    \    static assert(is(typeof({ wchar[] a; }) == wstring));\n    static assert(is(typeof({\
    \ wstring a; }) == wstring));\n    static assert(is(typeof({ dchar[] a; }) ==\
    \ dstring));\n    static assert(is(typeof({ dstring a; }) == dstring));\n    static\
    \ assert(is(typeof({ 'a'c == 'a'c; }) == bool));\n    static assert(is(typeof({\
    \ \"a\"c; }) == char));\n    static assert(is(typeof({ 'a'; }) == dchar));\n \
    \   static assert(is(typeof({ \"a\"; }) == dchar[]));\n    static assert(is(typeof({\
    \ \"a\"c; }) == char));\n    static assert(is(typeof({ L\"a\"; }) == wchar[]));\n\
    \    static assert(is(typeof({ L\"a\"c; }) == wchar));\n    static assert(is(typeof({\
    \ 12345", "{\n    return s.length >= 3 && all!(ch => s[2 .. $].count(ch) == 0)(s[0\
    \ .. 2]);\n}\n/*\nYou are given an integer n.\n    Your task is to find the integer\
    \ nearest to sqrt(n). \n    For example:\n    >>> nearest_sqrt(10)\n    3\n  \
    \  >>> nearest_sqrt(3)\n    2\n    >>> nearest_sqrt(7)\n    2\n    >>> nearest_sqrt(27)\n\
    \    5\n    >>> nearest_sqrt(0)\n    0\n    >>> nearest_sqrt(1)\n    1\n*/", "{\n\
    \    int length = s.length;\n    if (length < 3) return false;\n    string h;\n\
    \    int k = 0;\n    while (k < length - 2)\n    {\n        char c1 = s[k];\n\
    \        char c2 = s[k + 1];\n        char c3 = s[k + 2];\n        if (c1 == c2\
    \ || c1 == c3 || c2 == c3)\n        {\n            return false;\n        }\n\
    \        k++;\n    }\n    return true;\n}\n/*\n    Problem Statement\n    You\
    \ are given a string s.\n    Your task is to check if the string is palindrome\
    \ or not.\n    A string is palindrome if its reversed form is equal to the same\
    \ string.\n    For example:\n    >>> is_palindrome(a)\n    true\n    >>> is_palindrome(aa)\n\
    \    true\n    >>> is_palindrome(aba)\n    true\n    >>> is_palindrome(ab)\n \
    \   false\n    >>> is_palindrome(abba)\n    true\n    >>> is_palindrome(cac)\n\
    \    false\n*/", "{\n    return s.length >= 3 && s.walkLength(3).all!(x => x[0]\
    \ != x[1] && x[1] != x[2] && x[0] != x[2]);\n}", "{\n    // checking that the\
    \ string is of length at least 3, and\n    // that the next 3 consecutive letters\
    \ are distinct.\n    auto substr = s[0..3];\n    if(s.length > 2 && substr[0]\
    \ != substr[1] && substr[0] != substr[2] && substr[1] != substr[2])\n    {\n \
    \       return true;\n    }\n    return false;\n}", "{\n    int len = s.length;\n\
    \    if (len < 3) \n    {\n        return false;\n    }\n    else \n    {\n  \
    \      int i = 0;\n        while (i < len-2) \n        {\n            if (s[i]\
    \ == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) \n            {\n         \
    \       return false;\n            }\n            i++;\n        }\n        return\
    \ true;\n    }\n}", "{\n    if (s.length < 3)\n        return false;\n    for\
    \ (int i = 0; i < s.length - 2; i++) \n    {\n        if (s[i] == s[i + 1] ||\
    \ s[i] == s[i + 2] || s[i + 1] == s[i + 2])\n            return false;\n    }\n\
    \    return true;\n}\n/*\n     For example:\n    >>> is_happy(a)\n    false\n\
    \    >>> is_happy(aa)\n    false\n    >>> is_happy(abcd)\n    true\n    >>> is_happy(aabb)\n\
    \    false\n    >>> is_happy(adb)\n    true\n    >>> is_happy(xyy)\n    false\n\
    */\nunittest \n{\n    writeln(is_happy(\"a\"));\n    writeln(is_happy(\"aa\"));\n\
    \    writeln(is_happy(\"abcd\"));\n    writeln(is_happy(\"aabb\"));\n    writeln(is_happy(\"\
    adb\"));\n    writeln(is_happy(\"xyy\"));\n}", "{\n    int i = 0;\n    int len\
    \ = s.length;\n    if (len >= 3)\n    {\n        int smt = 0;\n        char[]\
    \ arr = new char[3];\n        foreach(c; s)\n        {\n            int temp =\
    \ 0;\n            //check if the 3 consecutive letters are unique\n          \
    \  for (i = 0; i < 3; i++)\n            {\n                //when you reach the\
    \ end of the string, you should stop\n                if (smt + i >= len)\n  \
    \              {\n                    return true;\n                }\n      \
    \          arr[i] = s[smt + i];\n                if (s[smt + i] == c)\n      \
    \          {\n                    temp++;\n                }\n            }\n\
    \            //if there is a duplicate character, it is not happy\n          \
    \  if (temp >= 2)\n            {\n                return false;\n            }\n\
    \            smt++;\n        }\n    }\n    else\n    {\n        return false;\n\
    \    }\n    return true;\n}\n/*\nDefine a function that takes a string s and returns\
    \ a new string that is the reverse of s.", "{\n    auto r = s.length();\n    if\
    \ (r < 3) return false;\n    return s.front != s[1] && s.front != s.back && s[1]\
    \ != s.back;\n}", "{\n    assert(s.length >= 3);\n    auto itr = s.length - 2;\n\
    \    for (; itr >= 0; --itr) {\n        if (s[itr] == s[itr + 1] || s[itr] ==\
    \ s[itr + 2] || s[itr + 1] == s[itr + 2]) {\n            return false;\n     \
    \   }\n    }\n    return true;\n}", "{\n    if (s.length < 3) return false;\n\
    \    for (int i = 0; i < s.length - 2; i++)\n    {\n        if (s[i] == s[i +\
    \ 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2])\n            return false;\n\
    \    }\n    return true;\n}", "{\n    if (s.length < 3) return false;\n    foreach\
    \ (i; 0 .. s.length - 2)\n    {\n        if (s[i] == s[i + 1] || s[i] == s[i +\
    \ 2] || s[i + 1] == s[i + 2]) return false;\n    }\n    return true;\n}", "{\n\
    \    return s.length < 3 ? false : isHappy(s);\n}", "{\n    if (s.length < 3)\n\
    \        return false;\n    return !s.canFind(3, 0, (string str, size_t indx)\
    \ { return str[indx] == str[indx + 1] && str[indx] == str[indx + 2]; });\n}\n ",
  "{\n    // Your code here\n    if(s.length < 3)\n        return false;\n    else\n\
    \    {\n        int i = 0;\n        int j = i + 1;\n        int k = j + 1;\n \
    \       if(s[i] != s[j] && s[j] != s[k] && s[i] != s[k])\n            return true;\n\
    \        else\n            return false;\n    }\n}", "{\n    int h = 0;\n    char\
    \ prev;\n    for (size_t i = 0; i < s.length(); i++)\n    {\n        if (i ==\
    \ 0) \n        {\n            h = (int)s[i];\n            prev = s[i];\n     \
    \   }\n        else\n        {\n            // Check if the next character is\
    \ the same as the previous character\n            if (prev == s[i])\n        \
    \    {\n                return false;\n            }\n            else \n    \
    \        {\n                // XOR the hash value with the current character\n\
    \                h = h ^ (int)s[i];\n                // Check if the hash value\
    \ is 0\n                if (h == 0)\n                {\n                    return\
    \ false;\n                }\n                // Move the previous character over\n\
    \                prev = s[i];\n            }\n        }\n    }\n    return true;\n\
    }\n//unittest {\n//    assert(is_happy(\"abc\"));\n//    assert(is_happy(\"aabb\"\
    ) == false);\n//    assert(is_happy(\"xyy\") == false);\n//    assert(is_happy(\"\
    adb\"));\n//    assert(is_happy(\"xx\") == false);\n//    assert(is_happy(\"y\"\
    ) == false);\n//    assert(is_happy(\"xyz\"));\n//    assert(is_happy(\"ababab\"\
    ) == false);\n//    assert(is_happy(\"abcabcabc\"));\n//    assert(is_happy(\"\
    zxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzxzx",
  "{\n    import std.stdio;\n    import std.algorithm;\n    import std.range;\n  \
    \  import std.typecons;\n    import std.typetuple;\n    import std.meta;\n   \
    \ import std.functional;\n    import std.array;\n    import std.conv;\n    import\
    \ std.traits;\n    string[] array1;\n    if(s.length < 3){\n        writeln(\"\
    Length is less than 3\");\n        return false;\n    }\n    else{\n        foreach(typeof(array1.init),\
    \ i;TypeTuple!(array1)){\n            const numberOfConsecutiveCharacters = 3;\n\
    \            int charCount = 0;\n            char prevChar = ' ';\n          \
    \  string temp = \"\";\n            for(int j = 0; j < s.length; j++){\n     \
    \           if(charCount < numberOfConsecutiveCharacters){\n                 \
    \   if(s[j] != prevChar){\n                        temp = temp ~ s[j];\n     \
    \                   prevChar = s[j];\n                        charCount++;\n \
    \                   }\n                    else{\n                        break;\n\
    \                    }\n                }\n                else{\n           \
    \         break;\n                }\n            }\n            i = temp;\n  \
    \      }\n    }\n    auto result = true;\n    foreach(str;array1){\n        if(str.length\
    \ != 3){\n            result = false;\n            break;\n        }\n    }\n\
    \    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
