language: d
name: HumanEval_41_car_race_collision
results:
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long ret = 0;\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwvdswrn4.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d45]

    ??:? void tmpwvdswrn4.__unittest_L20_C1() [0x427a30]

    ??:? void tmpwvdswrn4.__modtest() [0x427ac8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8fe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff40]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8d5]

    ??:? runModuleUnitTests [0x42b841]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428194]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    long index1\
    \ = 0;\n    long index2 = n-1;\n    long count = 0;\n    while (index1 <= index2)\
    \ {\n        while (index1 <= index2 && ((index1 + index2) % 2 == 0)) {\n    \
    \        index1++;\n        }\n        while (index1 <= index2 && ((index1 + index2)\
    \ % 2 == 1)) {\n            index2--;\n        }\n        count++;\n    }\n  \
    \  return count;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmoqmqa4b.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmpmoqmqa4b.__unittest_L31_C1() [0x427ab8]

    ??:? void tmpmoqmqa4b.__modtest() [0x427b50]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result;\n\
    \    static if (n <= 0) {\n        result = 0;\n    } else {\n        result =\
    \ n * (n - 1) / 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe1_93w69.d(18): Error: variable `n` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe1_93w69.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: -1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    //* Test cases\n\
    \    assert(car_race_collision(1) == 0);\n    assert(car_race_collision(2) ==\
    \ 1);\n    assert(car_race_collision(4) == 4);\n    assert(car_race_collision(10)\
    \ == 45);\n    assert(car_race_collision(100) == 4950);\n    return (n * (n -\
    \ 1)) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660160821
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return (n*(n-1))/2;\n\
    }\n/*\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj90dv8ci.d(19): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj90dv8ci.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpugqec3_u.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpugqec3_u.__unittest_L19_C1() [0x427a44]

    ??:? void tmpugqec3_u.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160754
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long[] car1\
    \ = new long[n];\n    long[] car2 = new long[n];\n    long[] buffer = new long[n];\n\
    \    long[] buffer2 = new long[n];\n    long res;\n    long i, j, k;\n    long\
    \ index, index2;\n    long min, min_index;\n    for (i = 0; i < n; i++) {\n  \
    \      car1[i] = random();\n        car2[i] = random();\n    }\n    for (i = 0;\
    \ i < log(n) + 1; i++) {\n        for (j = 0; j < n; j++) {\n            buffer[j]\
    \ = j;\n        }\n        for (j = 0; j < n; j++) {\n            min = car1[j];\n\
    \            min_index = j;\n            for (k = j; k < n; k++) {\n         \
    \       if (car1[k] < min) {\n                    min = car1[k];\n           \
    \         min_index = k;\n                }\n            }\n            car1[min_index]\
    \ = car1[j];\n            car1[j] = min;\n            buffer2[j] = buffer[min_index];\n\
    \            buffer[min_index] = buffer[j];\n            buffer[j] = buffer2[j];\n\
    \        }\n        for (j = 0; j < n; j++) {\n            min = car2[j];\n  \
    \          min_index = j;\n            for (k = j; k < n; k++) {\n           \
    \     if (car2[k] < min) {\n                    min = car2[k];\n             \
    \       min_index = k;\n                }\n            }\n            car2[min_index]\
    \ = car2[j];\n            car2[j] = min;\n            buffer2[j] = buffer[min_index];\n\
    \            buffer[min_index] = buffer[j];\n            buffer[j] = buffer2[j];\n\
    \        }\n        index = 0;\n        index2 = 0;\n        while (index < n\
    \ && index2 < n) {\n            if (car1[index] < car2[index2]) {\n          \
    \      index\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpekjvwe9v.d(68): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpekjvwe9v.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpekjvwe9v.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpekjvwe9v.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpekjvwe9v.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpekjvwe9v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n < 1) return\
    \ 0;\n    auto f = new real[n];\n    for (long i = 0; i < n; i++) f[i] = i;\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiv5gbezd.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiv5gbezd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    uint nb_collisions\
    \ = 0;\n    if (n < 1) \n        return nb_collisions;\n    long rl_time = 0;\
    \  // time when the right to left car hit the starting point\n    long lr_time\
    \ = 2*n;  // time when the left to right car hit the end point\n    long* rl_speed\
    \ = new long[n];  // speed of the right to left cars\n    long* lr_speed = new\
    \ long[n];  // speed of the left to right cars\n    long* rl_pos   = new long[n];\
    \  // position of the right to left cars\n    long* lr_pos   = new long[n];  //\
    \ position of the left to right cars\n    for (uint i = 0; i < n; ++i) \n    {\n\
    \        rl_speed[i] = n-i;  // all right to left cars move at different speeds\n\
    \        lr_speed[i] = n-i;  // all left to right cars move at different speeds\n\
    \        rl_pos[i] = -(n-i);  // right to left cars start at different positions\n\
    \        lr_pos[i] = n-i;  // left to right cars start at different positions\n\
    \    }\n    // this is the time when the right to left and left to right cars\
    \ will hit each other\n    long collide_time = 2*n - sqrt(n);  \n    for (uint\
    \ i = 0; i < n; ++i) \n    {\n        long speed_rl = rl_speed[i];\n        long\
    \ speed_lr = lr_speed[i];\n        // this is the time when the right to left\
    \ car hit the starting point\n        rl_time = -rl_pos[i]/speed_rl;  \n     \
    \   // this is the time when the left to right car hit the end point\n       \
    \ lr_time = 2*n-lr_pos[i]/speed_lr;  \n        // if the left to right car hit\
    \ the end point before the right to left car\n        // hit the starting point,\
    \ it means that the collision has happened;\n        // we increment the number\
    \ of collisions\n        if (lr_time < r\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp40wvymu6.d(47): Error: found `unittest` when expecting `)`

    /tmp/tmp40wvymu6.d(57): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp40wvymu6.d(57): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp40wvymu6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    int i;\n   \
    \ int j;\n    int collisions = 0;\n    for (i = 0; i < n; i++)\n    {\n      \
    \  for (j = i + 1; j < n; j++)\n        {\n            collisions++;\n       \
    \ }\n    }\n    return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdqmzhkam.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmpdqmzhkam.__unittest_L29_C1() [0x427a7c]

    ??:? void tmpdqmzhkam.__modtest() [0x427b14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collision_count\
    \ = 0;\n    collision_count = sqrt(n*n);\n    return collision_count;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1faa91n1.d(18): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1faa91n1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /* no cars =\
    \ no collisions */\n    if (n == 0) return 0;\n    \n    /*\n        so we can\
    \ think of it as having a set of n left-to-right cars and a set of n right-to-left\
    \ cars.\n        - the left-to-right cars have [1..n] indices, and the right-to-left\
    \ cars have [-n..-1] indices.\n        - we only have to care about the left-to-right\
    \ cars, since by symmetry the number of collisions is the same.\n        - every\
    \ left-to-right car is going to collide with at most one right-to-left car.\n\
    \        - the left-to-right car with index i will collide with the right-to-left\
    \ car with index -i if and only if\n            the right-to-left car with index\
    \ -i is in the range [i-a..i], where a is some positive constant.\n        - thus,\
    \ the number of collisions is equal to the number of indices i in [1..n] such\
    \ that the left-to-right car\n            with index i will collide with the right-to-left\
    \ car with index -i.\n        - now, to find out how many indices i in [1..n]\
    \ there are such that the right-to-left car with index -i is in the\n        \
    \    range [i-a..i], we can partition the set of those indices into two parts:\n\
    \            - the set of indices j in [1..n] such that the right-to-left car\
    \ with index -j is in the range [j-a..j].\n            - the set of indices j\
    \ in [1..n] such that the right-to-left car with index -j is not in the range\
    \ [j-a..j], but\n                the right-to-left car with index -(j+1) is in\
    \ the range [(j+1)-a..(j+1)].\n        - now, the number of collisions is equal\
    \ to the union of the two sets of indices.\n        - the number of collisions\
    \ is clearly not larger than the first set of indices.\n        - the number of\
    \ collisions is also not larger than the second set of indices.\n        - since\
    \ the number of collisions is clearly not larger than the first set of indices,\
    \ the number of collisions is\n\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpof1fu9_q.d(20): Error: unterminated /* */ comment

    /tmp/tmpof1fu9_q.d(49): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpof1fu9_q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    auto left =\
    \ range(0, n);\n    auto right = array(left[n - 1 - i] for i in 0 .. n);\n   \
    \ auto left_pos = array(n - i - 1 for i in 0 .. n);\n    auto right_pos = array(i\
    \ for i in 0 .. n);\n    long collisions = 0;\n    for (; ; ) \n    {\n      \
    \  auto min_left = min(left_pos);\n        auto min_right = min(right_pos);\n\
    \        if (min_left >= min_right)\n            break;\n        collisions +=\
    \ n - max(left_pos);\n        left_pos[left_pos.find(min_left)] += 1;\n      \
    \  right_pos[right_pos.find(min_right)] += 1;\n    }\n    return collisions;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqbcoqm4j.d(18): Error: found `for` when expecting `,`

    /tmp/tmpqbcoqm4j.d(18): Error: found `..` when expecting `,`

    /tmp/tmpqbcoqm4j.d(19): Error: found `for` when expecting `,`

    /tmp/tmpqbcoqm4j.d(19): Error: found `..` when expecting `,`

    /tmp/tmpqbcoqm4j.d(20): Error: found `for` when expecting `,`

    /tmp/tmpqbcoqm4j.d(20): Error: found `..` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqbcoqm4j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /*\n    But\
    \ how do you find the number of collisions?\n    Lets say the cars on the left\
    \ and the cars on the right start\n    out in a certain order.  That is, we can\
    \ say that the starting position\n    for the cars is \n    Left:    A, B, C,\
    \ D\n    Right:   E, F, G, H\n    This is one possible starting arrangement. \
    \ There are 4! = 24 possible arrangements.\n    Now, lets say we have a collision.\
    \  This means that in the end:\n    Left:    A, C, D, B\n    Right:   E, G, H,\
    \ F\n    This is another possible starting arrangement.  There are 4! = 24 possible\
    \ arrangements.\n    So if we could enumerate all possible arrangements, then\
    \ we could just find the number of\n    arrangements that have at least one collision.\
    \  This is equivalent to finding the total number\n    of arrangements minus the\
    \ number of arrangements that do not have any collisions.\n    */\n    long num_collisions\
    \ = 0;\n    long all_arrangements = 0;\n    /*\n    Lets iterate over all of the\
    \ possible arrangements.  One way to do this is to use a recursive\n    algorithm.\
    \  One possible algorithm is as follows:\n    1.  We start with the cars on the\
    \ left and the cars on the right all in order.  E.g.,\n    Left:    A, B, C, D\n\
    \    Right:   E, F, G, H\n    2.  Then, we find the minimum position number p\
    \ such that either the car in position p on the left\n    or the car in position\
    \ p on the right is greater than the corresponding car on the other side.  E.g.,\n\
    \    Left:    A, B, C, D\n    Right:   E, F, G, H\n    Here, p = 2.  The car in\
    \ position 2 on the left is C, which is greater than the car in position 2 on\
    \ the right, which is F.\n    (The car in position 2 on the right is F, which\
    \ is smaller than the car in position 2 on the left, which is C.)\n    3.  Then,\
    \ we swap the cars at positions p on the left and p on the right, as well as all\
    \ of the cars in positions greater than p\nunittest\n{\n    alias candidate =\
    \ car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp94a1m8k1.d(35): Error: unterminated /* */ comment

    /tmp/tmp94a1m8k1.d(58): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp94a1m8k1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    int[] c1 = new\
    \ int[n];\n    int[] c2 = new int[n];\n    for (int i = 0; i < n; i++) \n    {\n\
    \        c1[i] = (int)rand(1, n*2);\n        c2[i] = (int)rand(1, n*2);\n    }\n\
    \    sort(c1);\n    sort(c2);\n    int j = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < n; i++) \n    {\n        if (c1[i] < c2[j]) \n        {\n       \
    \     count++;\n        }\n        else \n        {\n            j++;\n      \
    \  }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyogsspne.d(21): Error: C style cast illegal, use `cast(int)rand(1,
    n * 2)`

    /tmp/tmpyogsspne.d(22): Error: C style cast illegal, use `cast(int)rand(1, n *
    2)`

    /tmp/tmpyogsspne.d(41): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyogsspne.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long sum = 0;\n\
    \    foreach (i; 0 .. n) {\n        sum += i;\n    }\n    return sum;\n}\n/*\n\
    \    Imagine a road that's a perfectly straight infinitely long line.\n    n cars\
    \ are driving left to right;  simultaneously, a different set of n cars\n    are\
    \ driving right to left.   The two sets of cars start out being very far from\n\
    \    each other.  All cars move in the same speed.  Two cars are said to collide\n\
    \    when a car that's moving left to right hits a car that's moving right to\
    \ left.\n    However, the cars are infinitely sturdy and strong; as a result,\
    \ they continue moving\n    in their trajectory as if they did not collide.\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgqslm30w.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgqslm30w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpugqec3_u.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpugqec3_u.__unittest_L19_C1() [0x427a44]

    ??:? void tmpugqec3_u.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160754
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    import std.math;\n\
    \    const long infinity = 46340;\n    const int steps = 100;\n    int carsLeft[infinity];\n\
    \    int carsRight[infinity];\n    for (int i = 0; i < infinity; i++) {\n    \
    \    carsLeft[i] = 0;\n        carsRight[i] = 0;\n    }\n    foreach (i; 0 ..\
    \ n) {\n        carsLeft[i] = infinity/n * i;\n        carsRight[i] = infinity\
    \ - infinity/n * i;\n    }\n    int collisions = 0;\n    for (int i = 0; i < steps;\
    \ i++) {\n        foreach (j; 0 .. n) {\n            if (carsLeft[j] == infinity)\n\
    \                continue;\n            if (carsLeft[j] > infinity - infinity/n\
    \ * i)\n                carsLeft[j] -= infinity/n;\n            else if (carsLeft[j]\
    \ < infinity/n * i)\n                carsLeft[j] += infinity/n;\n            else\
    \ {\n                foreach (k; 0 .. n) {\n                    if (carsRight[k]\
    \ == infinity)\n                        continue;\n                    if (carsRight[k]\
    \ > infinity - infinity/n * i)\n                        carsRight[k] -= infinity/n;\n\
    \                    else if (carsRight[k] < infinity/n * i)\n               \
    \         carsRight[k] += infinity/n;\n                    else {\n          \
    \              if (carsLeft[j] == carsRight[k]) {\n                          \
    \  collisions++;\n                            carsLeft[j] = infinity;\n      \
    \                      carsRight[k] = infinity;\n                        }\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: '/tmp/tmp29tu_iga.d(20): Deprecation: instead of C-style syntax, use D-style
    syntax `int[infinity] carsLeft`

    /tmp/tmp29tu_iga.d(21): Deprecation: instead of C-style syntax, use D-style syntax
    `int[infinity] carsRight`

    /tmp/tmp29tu_iga.d(20): Deprecation: instead of C-style syntax, use D-style syntax
    `int[infinity] carsLeft`

    /tmp/tmp29tu_iga.d(21): Deprecation: instead of C-style syntax, use D-style syntax
    `int[infinity] carsRight`

    core.exception.AssertError@/tmp/tmp29tu_iga.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282bd]

    ??:? void tmp29tu_iga.__unittest_L60_C1() [0x427fa8]

    ??:? void tmp29tu_iga.__modtest() [0x428040]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c057]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aeea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43007d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43052c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aec1]

    ??:? runModuleUnitTests [0x42be2d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428780]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i;\n  \
    \  long total = 0;\n    long left_to_right[n];\n    long right_to_left[n];\n \
    \   for (i = 0; i < n; i++) \n    {\n        left_to_right[i] = i;\n        right_to_left[i]\
    \ = -(i + 1);\n    }\n    for (i = 0; i < n; i++) \n    {\n        total += left_to_right[i]\
    \ + right_to_left[i];\n    }\n    return total;\n}\n/*\n    What is the time complexity\
    \ of this algorithm?\n    The first loop will run n times.\n    The second loop\
    \ will run n times.\n    No other operations other than adding.\n    Therefore,\
    \ this is an O(n) algorithm.\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjqu56nxu.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n] left_to_right`

    /tmp/tmpjqu56nxu.d(20): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n] right_to_left`

    /tmp/tmpjqu56nxu.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjqu56nxu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    //assert(n >\
    \ 0);\n    long *arr = new long[n];\n    for (long i = 0; i < n; i++)\n      \
    \  arr[i] = i;\n    shuffle(arr, arr + n);\n    long count = 0;\n    for (long\
    \ i = 0; i < n; i++)\n        for (long j = i + 1; j < n; j++)\n            if\
    \ (arr[i] > arr[j])\n                count++;\n    return count;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2dzi_by8.d(18): Error: cannot implicitly convert expression `new
    long[](cast(ulong)n)` of type `long[]` to `long*`

    /tmp/tmp2dzi_by8.d(21): Error: undefined identifier `shuffle`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2dzi_by8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long num_left_to_right_cars\
    \ = n;\n    long num_right_to_left_cars = n;\n    long num_collisions = 0;\n \
    \   while (num_left_to_right_cars > 0 && num_right_to_left_cars > 0) \n    {\n\
    \        if (num_left_to_right_cars % 2 == 1) \n        {\n            num_collisions\
    \ += num_right_to_left_cars / 2;\n        }\n        num_left_to_right_cars /=\
    \ 2;\n        num_right_to_left_cars /= 2;\n    }\n    return num_collisions;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaocpybwm.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmpaocpybwm.__unittest_L31_C1() [0x427aa0]

    ??:? void tmpaocpybwm.__modtest() [0x427b38]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n*(n-1)/2;\n\
    }\n/*\n    Given the number of cars n, this function outputs the number of collisions.\n\
    */\nlong car_race_collision_1(long n) \n{\n    long collision = 0;\n    foreach(i;\
    \ 0 .. n-1)\n    {\n        foreach(j; i+1 .. n)\n        {\n            collision++;\n\
    \        }\n    }\n    return collision;\n}\n/*\n    The method above actually\
    \ runs in O(n^2) time.  \n    Using a divide and conquer algorithm, we can reduce\
    \ the running time to O(n lg n).\n    Because the algorithm is divide and conquer,\
    \ it will run in O(n) space.\n*/\nlong car_race_collision_2(long n) \n{\n    auto\
    \ car_collisions = (a, b)\n    {\n        return (b-a-1)*(b-a)/2;\n    };\n  \
    \  long collisions = 0;\n    long high = n;\n    long low = 0;\n    long mid =\
    \ (high+low)/2;\n    long total_collisions = car_collisions(low, high);\n    collisions\
    \ += total_collisions;\n    while(high != mid && low != mid)\n    {\n        total_collisions\
    \ = car_collisions(low, mid) + car_collisions(mid, high);\n        collisions\
    \ += total_collisions;\n        high = mid;\n        mid = (high+low)/2;\n   \
    \ }\n    return collisions;\n}\n/*\n    Another method is to use a bit manipulations.\n\
    \    I create a binary representation of n. \n    Then, I count the number of\
    \ 1's in the binary representation.\n    For example, n = 13, 13 in binary is\
    \ 1101.  There are 3 1's in 1101.\n    And using the formula above, we get 3*(3-1)/2\
    \ = 3.\n    We can do this in O(n) time, where n is the number of bits in the\
    \ binary representation.\n*/\nlong car_race_collision_3(long n) \n{\n    long\
    \ collision = 0;\n    while(n > 0)\n   \nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyeu73tqg.d(73): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyeu73tqg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long num_collisions;\n\
    \    float * left_to_right_x_positions = new float[n];\n    float * right_to_left_x_positions\
    \ = new float[n];\n    num_collisions = 0;\n    for (long left_to_right_car_number\
    \ = 0; left_to_right_car_number < n; left_to_right_car_number++) \n    {\n   \
    \     for (long right_to_left_car_number = 0; right_to_left_car_number < n; right_to_left_car_number++)\
    \ \n        {\n            if (right_to_left_x_positions[right_to_left_car_number]\
    \ - left_to_right_x_positions[left_to_right_car_number] <= 0) \n            {\n\
    \                num_collisions++;\n            }\n        }\n    }\n    return\
    \ num_collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2nytwqtz.d(18): Error: cannot implicitly convert expression `new
    float[](cast(ulong)n)` of type `float[]` to `float*`

    /tmp/tmp2nytwqtz.d(19): Error: cannot implicitly convert expression `new float[](cast(ulong)n)`
    of type `float[]` to `float*`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2nytwqtz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    return n*(n-1);\
    \ \n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5fq3hw9h.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d55]

    ??:? void tmp5fq3hw9h.__unittest_L19_C1() [0x427a3c]

    ??:? void tmp5fq3hw9h.__modtest() [0x427ad4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a90e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff50]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8e5]

    ??:? runModuleUnitTests [0x42b851]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long x;\n  \
    \  for (x = 0; x < n; x++) \n    {\n        x += 1;\n    }\n    return x;\n}\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd3xkuo6t.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpd3xkuo6t.__unittest_L24_C1() [0x427a58]

    ??:? void tmpd3xkuo6t.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long n1=n; //\
    \ n1 cars are going from left to right\n    long n2=n; // n2 cars are going from\
    \ right to left\n    long number_of_collisions=0;\n    long a1[n1]; // positions\
    \ of the n1 cars going from left to right\n    long a2[n2]; // positions of the\
    \ n2 cars going from right to left\n    /*\n        For this sample problem, we\
    \ assume that the positions of the\n        cars are 0, 1, 2, 3, 4, 5, ..., n-1.\n\
    \    */\n    long i=0;\n    while(i<n1) {\n        a1[i]=i;\n        i=i+1;\n\
    \    }\n    i=0;\n    while(i<n2) {\n        a2[i]=n-1-i;\n        i=i+1;\n  \
    \  }\n    /*\n        Now, we check whether there are any cars that both have\
    \ the same\n        position, which means there has been a collision.\n    */\n\
    \    i=0;\n    while(i<n1) {\n        long j=0;\n        while(j<n2) {\n     \
    \       if(a1[i]==a2[j]) {\n                number_of_collisions=number_of_collisions+1;\n\
    \            }\n            j=j+1;\n        }\n        i=i+1;\n    }\n    return\
    \ number_of_collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3kwytck6.d(20): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n1] a1`

    /tmp/tmp3kwytck6.d(21): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n2] a2`

    /tmp/tmp3kwytck6.d(20): Error: variable `n1` cannot be read at compile time

    /tmp/tmp3kwytck6.d(21): Error: variable `n2` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3kwytck6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, collisions\
    \ = 0;\n    float[] leftcars = new float[n];\n    float[] rightcars = new float[n];\n\
    \    float x;\n    foreach (i; 0 .. n) {\n\tx = uniform(0, 100);\n\tleftcars[i]\
    \ = x;\n\trightcars[i] = x;\n    }\n    foreach (i; 0 .. n) {\n\tforeach (j; 0\
    \ .. n) {\n\t    if (leftcars[i] < rightcars[j])\n\t\tcollisions++;\n\t}\n   \
    \ }\n    return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8wrdu1gc.d(21): Error: variable `i` is shadowing variable `tmp8wrdu1gc.car_race_collision.i`

    /tmp/tmp8wrdu1gc.d(22): Error: undefined identifier `uniform`

    /tmp/tmp8wrdu1gc.d(26): Error: variable `i` is shadowing variable `tmp8wrdu1gc.car_race_collision.i`

    /tmp/tmp8wrdu1gc.d(27): Error: variable `j` is shadowing variable `tmp8wrdu1gc.car_race_collision.j`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wrdu1gc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long car_x_to_right[],\
    \ car_x_to_left[];\n    long time = 0;\n    long collision_count = 0;\n    long\
    \ i, j;\n    long temp;\n    \n    for (i = 0; i < n; i++) {\n        car_x_to_right.length\
    \ = i + 1;\n        car_x_to_right[i] = i;\n        car_x_to_left.length = i +\
    \ 1;\n        car_x_to_left[i] = -i;\n    }\n    \n    while (1) {\n        time++;\n\
    \        collision_count = 0;\n        temp = car_x_to_right[0];\n        for\
    \ (i = 0; i < n; i++) {\n            if (i < n - 1) {\n                car_x_to_right[i]\
    \ = car_x_to_right[i + 1];\n            }\n            if (i > 0) {\n        \
    \        car_x_to_left[i] = car_x_to_left[i - 1];\n            }\n        }\n\
    \        car_x_to_right[n - 1] = temp + 1;\n        car_x_to_left[0] = -car_x_to_left[0]\
    \ - 1;\n        \n        for (i = 0; i < n; i++) {\n            for (j = 0; j\
    \ < n; j++) {\n                if (abs(car_x_to_right[i] - car_x_to_left[j]) ==\
    \ 1) {\n                    collision_count++;\n                }\n          \
    \  }\n        }\n        if (collision_count == 0) {\n            break;\n   \
    \     }\n    }\n    return time;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6xnxthxv.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] car_x_to_right`

    /tmp/tmp6xnxthxv.d(17): Error: multiple declarations must have the same type,
    not `long[]` and `long[]`

    /tmp/tmp6xnxthxv.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] car_x_to_left`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6xnxthxv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 0
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long num_left_to_right,\
    \ num_right_to_left;\n    long i, cur_position;\n    long num_collisions = 0;\n\
    \    num_left_to_right = n;\n    num_right_to_left = n;\n    i = 0;\n    while(num_left_to_right\
    \ > 0 && num_right_to_left > 0) {\n        // count how many left to right cars\
    \ are entering the left-side\n        while(i < n && num_left_to_right > 0) {\n\
    \            num_left_to_right--;\n            i++;\n        }\n        // count\
    \ how many right to left cars are entering the right-side\n        cur_position\
    \ = i;\n        while(cur_position < 2*n && num_right_to_left > 0) {\n       \
    \     num_right_to_left--;\n            cur_position++;\n        }\n        //\
    \ now, i cars are left to right;  cur_position - i are right to left\n       \
    \ // now, i cars are left to right;  cur_position - i are right to left\n    \
    \    // count how many collisions will occur\n        num_collisions += (i * (cur_position\
    \ - i));\n        // now, there are a total of cur_position cars in the road\n\
    \        i = cur_position;\n    }\n    return num_collisions;\n}\nunittest\n{\n\
    \    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long x=0;\n\
    \    int i;\n    int j;\n    //int z;\n    //int y;\n    int tempx=0;\n    int\
    \ tempy=0;\n    int n1=n;\n    int n2=n;\n    int tempx=0;\n    int tempy=0;\n\
    \    int z;\n    int y;\n    int data[];\n    int data2[];\n    int a=0;\n   \
    \ int b=0;\n    int c=0;\n    int d=0;\n    int e=0;\n    for(i=0;i<n;i++)\n \
    \   {\n        data[i]=i+1;\n        data2[i]=i+1;\n    }\n    for(i=0;i<n;i++)\n\
    \    {\n        a=data[i];\n        if(data[i]!=tempx)\n        {\n          \
    \  if(data[i]!=tempy)\n            {\n                if(data[i]>data2[i])\n \
    \               {\n                    x++;\n                    tempx=data[i];\n\
    \                    tempy=data2[i];\n                }\n            }\n     \
    \   }\n    }\n    return x;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb6hmfbyf.d(30): Deprecation: instead of C-style syntax, use D-style
    syntax `int[] data`

    /tmp/tmpb6hmfbyf.d(31): Deprecation: instead of C-style syntax, use D-style syntax
    `int[] data2`

    /tmp/tmpb6hmfbyf.d(24): Error: cannot implicitly convert expression `n` of type
    `long` to `int`

    /tmp/tmpb6hmfbyf.d(25): Error: cannot implicitly convert expression `n` of type
    `long` to `int`

    /tmp/tmpb6hmfbyf.d(26): Error: declaration `tmpb6hmfbyf.car_race_collision.tempx`
    is already defined

    /tmp/tmpb6hmfbyf.d(27): Error: declaration `tmpb6hmfbyf.car_race_collision.tempy`
    is already defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb6hmfbyf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    bool[] is_r_to_l\
    \ = new bool[n];\n    long[] cars = new long[n];\n    bool[][] collided = new\
    \ bool[n][n];\n    long num_collisions = 0;\n    long i,j;\n    long num_r_to_l\
    \ = n;\n    long num_l_to_r = n;\n    long r_to_l_pos = 0;\n    long l_to_r_pos\
    \ = 0;\n    long pos;\n    long cars_left_to_place = n;\n    long collision_distance\
    \ = 0;\n    bool l_to_r_flipped = false;\n    bool r_to_l_flipped = false;\n \
    \   bool collision_happened = false;\n    long t = 0;\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbrh8ex3m.d(33): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbrh8ex3m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    static assert(n\
    \ > 0, \"0 or negative cars is undefined\");\n    long res;\n    long a[];\n \
    \   a.length = n;\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = uniform(0,n);\n\
    \    }\n    std.algorithm.sort(a);\n    res = 0;\n    for (int i = 0; i < n; i++)\n\
    \    {\n        res += abs(a[i] - i);\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvtdzes6r.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] a`

    /tmp/tmpvtdzes6r.d(17): Error: variable `n` cannot be read at compile time

    /tmp/tmpvtdzes6r.d(17):        while evaluating: `static assert(n > 0L)`

    /tmp/tmpvtdzes6r.d(23): Error: undefined identifier `uniform`

    /tmp/tmpvtdzes6r.d(25): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvtdzes6r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return (n *\
    \ (n - 1)) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeucec2ys.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpeucec2ys.__unittest_L19_C1() [0x427a44]

    ??:? void tmpeucec2ys.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long count =\
    \ 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i+1; j < n; j++)\
    \ {\n            long diff = j - i;\n            count += 1 + (diff - 1) * diff\
    \ / 2;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqmu8c3o4.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmpqmu8c3o4.__unittest_L26_C1() [0x427a9c]

    ??:? void tmpqmu8c3o4.__modtest() [0x427b34]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long left[n];\n\
    \    long right[n];\n    long i = 0, coll = 0;\n    foreach(item; left) item =\
    \ uniform(0, 1000000);\n    foreach(item; right) item = uniform(0, 1000000);\n\
    \    left = sort(left);\n    right = sort(right);\n    while(i < n) \n    {\n\
    \        if(left[i] > right[i]) \n        {\n            i++;\n            coll++;\n\
    \        }\n        else i++;\n    }\n    return coll;\n}\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5zu3s422.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n] left`

    /tmp/tmp5zu3s422.d(18): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n] right`

    /tmp/tmp5zu3s422.d(17): Error: variable `n` cannot be read at compile time

    /tmp/tmp5zu3s422.d(18): Error: variable `n` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5zu3s422.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  long v1[], v2[];\n\
    \  foreach(i; 0 .. n)\n  {\n    v1[i] = uniform(0.0, 3.0);\n    v2[i] = uniform(0.0,\
    \ 3.0);\n  }\n  sort(v1);\n  sort(v2);\n  long result = 0;\n  foreach(i; 0 ..\
    \ n)\n  {\n    if (v1[i] <= v2[i]) {\n      result += (n - i);\n    }\n  }\n \
    \ return result;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptaamgcqb.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] v1`

    /tmp/tmptaamgcqb.d(17): Error: multiple declarations must have the same type,
    not `long[]` and `long[]`

    /tmp/tmptaamgcqb.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] v2`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptaamgcqb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    n = n + 1;\n\
    \    return (n*(n+1))/2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk8ax5qzg.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpk8ax5qzg.__unittest_L20_C1() [0x427a44]

    ??:? void tmpk8ax5qzg.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  return (n-1)*n/2;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8_bsp0xq.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp8_bsp0xq.__unittest_L19_C1() [0x427a44]

    ??:? void tmp8_bsp0xq.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n <= 0)\n\
    \        return 0;\n    \n    return n * (n - 1) / 2;\n}\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_9hc8lsz.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmp_9hc8lsz.__unittest_L22_C1() [0x427a50]

    ??:? void tmp_9hc8lsz.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    return 2*n-1;\n\
    } \n \nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0jjq72_f.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d4d]

    ??:? void tmp0jjq72_f.__unittest_L20_C1() [0x427a38]

    ??:? void tmp0jjq72_f.__modtest() [0x427ad0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a906]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff48]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8dd]

    ??:? runModuleUnitTests [0x42b849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42819c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return 0;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyu2y3hpc.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d45]

    ??:? void tmpyu2y3hpc.__unittest_L19_C1() [0x427a30]

    ??:? void tmpyu2y3hpc.__modtest() [0x427ac8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8fe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff40]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8d5]

    ??:? runModuleUnitTests [0x42b841]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428194]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /*\n       \
    \ Given the coordinates of each car moving left to right, as well as a list of\
    \ the speeds \n        each such car is driving at, as well as the coordinates\
    \ of each car moving right to left, \n        as well as a list of the speeds\
    \ each such car is driving at, output the number of collisions\n        that take\
    \ place among the n cars, given that the cars are infinitely strong and sturdy\n\
    \        so they don't move out of their trajectories.\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl216p01r.d(17): Error: unterminated /* */ comment

    /tmp/tmpl216p01r.d(33): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl216p01r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    assert(n>=1);\n\
    \    return (n*(n-1))/2;\n}\n/*\n    This function determines the number of people\
    \ who will be saved by the lifeboats\n    at a ship that's sinking.  In an emergency\
    \ situation, lifeboats can only be \n    assigned to people in a way that the\
    \ total weight of people in a lifeboat is \n    smaller than or equal to the maximum\
    \ weight the lifeboat can support.  However, \n    lifeboats should be assigned\
    \ to people in a way that minimizes the number of\n    people who will not be\
    \ assigned to a lifeboat.  This function calculates that number.\nunittest\n{\n\
    \    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpft9s83b6.d(20): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpft9s83b6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long ans = 0;\n\
    \    long index = 0;\n    while (index < n) {\n        long k = n-index;\n   \
    \     ans += k;\n        index++;\n    }\n    return ans;\n}\nunittest\n{\n  \
    \  alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzruca_72.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpzruca_72.__unittest_L26_C1() [0x427a60]

    ??:? void tmpzruca_72.__modtest() [0x427af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return ((n-1)*n)/2;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo9todr9k.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpo9todr9k.__unittest_L19_C1() [0x427a44]

    ??:? void tmpo9todr9k.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    \n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9kaqyqh0.d(15): Error: function `tmp9kaqyqh0.car_race_collision`
    has no `return` statement, but is expected to return a value of type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9kaqyqh0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 0
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    n = n * n;\n\
    \    return n;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  /*\n   if n =\
    \ 8, then the left to right cars are:  1,2,3,4,5,6,7,8\n   and the right to left\
    \ cars are:             8,7,6,5,4,3,2,1\n   and the collisions are           \
    \          1,2,3,4,5,6,7,8\n  */\n  return n;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp93y0hc69.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d4d]

    ??:? void tmp93y0hc69.__unittest_L24_C1() [0x427a34]

    ??:? void tmp93y0hc69.__modtest() [0x427acc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a906]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff48]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8dd]

    ??:? runModuleUnitTests [0x42b849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42819c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n < 2) return\
    \ 0;\n    long count = 0;\n    for (long i = 0; i < n; i++)\n    {\n        for\
    \ (long j = 0; j < n; j++)\n        {\n            if (i < j) count++;\n     \
    \   }\n    }\n    return count;\n}\n/*\n    The car_race_collision function above\
    \ has an order of growth of \n    0(n2).\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx_y5ujn5.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_y5ujn5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  /*\n      Your\
    \ code here\n  */\n  return 1;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp24ww9lmt.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d4d]

    ??:? void tmp24ww9lmt.__unittest_L22_C1() [0x427a34]

    ??:? void tmp24ww9lmt.__modtest() [0x427acc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a906]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff48]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8dd]

    ??:? runModuleUnitTests [0x42b849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42819c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n == 0)\n\
    \        return 0;\n    \n    if (n == 1)\n        return 1;\n    \n    long ret\
    \ = 0;\n    long next = 1;\n    for (long i = 1; i < n; i++) {\n        next =\
    \ next + i;\n        ret = ret + next;\n    }\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_18eamsn.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmp_18eamsn.__unittest_L31_C1() [0x427aa0]

    ??:? void tmp_18eamsn.__modtest() [0x427b38]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n\tauto cars = [];\n\
    \tfor (; n > 0; n--)\n\t{\n\t\tcars ~= std.random.random(1, 1000);\n\t}\n\t\n\t\
    int res = 0;\n\tfor (int i = 0; i < cars.length; i++)\n\t{\n\t\tfor (int j = 0;\
    \ j < cars.length; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tres += abs(cars[i]\
    \ - cars[j]) <= 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcusnbafu.d(20): Error: undefined identifier `random` in package
    `std`

    /tmp/tmpcusnbafu.d(30): Error: void has no value

    /tmp/tmpcusnbafu.d(30): Error: void has no value

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcusnbafu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result\
    \ = 0;\n    /*\n      Once you have a working solution, you can compare the time\
    \ taken\n      by your program against the time taken by solutions written by\n\
    \      other students.  To do this, change the value 'true' to 'false'.\n    \
    \  As you work on the assignment, you should change the value back\n      to 'true'\
    \ and re-run the program frequently.  If you change the\n      value to 'false'\
    \ and run the program, it will run indefinitely\n      and not exit.\n    */\n\
    \    if (true) {\n        int i = 0;\n        int j = 0;\n        while (i < n\
    \ && j < n)\n        {\n            float xi = float(i) / float(n);\n        \
    \    float xj = float(j) / float(n);\n            if (xi > xj)\n            {\n\
    \                ++j;\n            }\n            else if (xi < xj)\n        \
    \    {\n                ++i;\n            }\n            else\n            {\n\
    \                ++result;\n                ++i;\n                ++j;\n     \
    \       }\n        }\n    }\n    else\n    {\n        // This loop is intentionally\
    \ not very efficient\n        for (int i = 0; i < n; ++i)\n        {\n       \
    \     for (int j = 0; j < n; ++j)\n            {\n                float xi = float(i)\
    \ / float(n);\n                float xj = float(j) / float(n);\n             \
    \   if (xi == xj)\n                {\n                    ++result;\n        \
    \        }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqm848jk1.d(72): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmpqm848jk1.__unittest_L68_C1() [0x427ad4]

    ??:? void tmpqm848jk1.__modtest() [0x427b6c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n\tif (n < 1) \n\t\
    \treturn 0;\n\tlong max = 1;\n\tlong min = max * 2;\n\tlong count = 0;\n\tlong\
    \ temp;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\ttemp = max;\n\t\tmax = min;\n\
    \t\tmin = temp * 2 + 1;\n\t\tcount += min;\n\t}\n\treturn count;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptmgpzdab.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmptmgpzdab.__unittest_L32_C1() [0x427a9c]

    ??:? void tmptmgpzdab.__modtest() [0x427b34]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n\tlong i, j, k;\n\
    \tlong count = 0;\n\tlong[] x = new long[n];\n\tlong[] y = new long[n];\n\t\n\t\
    for (i = 0; i < n; i = i + 1) {\n\t\tj = (long)random(n) + 1;\n\t\tfor (k = 0;\
    \ k < i; k = k + 1) {\n\t\t\tif (x[k] == j) {\n\t\t\t\ti = i - 1;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tif (k == i) {\n\t\t\tx[i] = j;\n\t\t}\n\t}\n\t\n\tfor (i =\
    \ 0; i < n; i = i + 1) {\n\t\tj = (long)random(n) + 1;\n\t\tfor (k = 0; k < i;\
    \ k = k + 1) {\n\t\t\tif (y[k] == j) {\n\t\t\t\ti = i - 1;\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t\tif (k == i) {\n\t\t\ty[i] = j;\n\t\t}\n\t}\n\t\n\tfor (i = 0;\
    \ i < n; i = i + 1) {\n\t\tfor (j = 0; j < n; j = j + 1) {\n\t\t\tif (x[i] ==\
    \ y[j]) {\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjtxparsl.d(23): Error: C style cast illegal, use `cast(long)random(n)`

    /tmp/tmpjtxparsl.d(36): Error: C style cast illegal, use `cast(long)random(n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjtxparsl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result\
    \ = 0;\n    long[] left = new long[n];\n    long[] right = new long[n];\n    foreach\
    \ (i; 0 .. n) {\n        left[i] = i + 1;\n        right[i] = n - i;\n    }\n\
    \    foreach (i; 0 .. n) {\n        foreach (j; 0 .. n) {\n            if (left[i]\
    \ == right[j]) {\n                ++result;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbp8ypkoq.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428185]

    ??:? void tmpbp8ypkoq.__unittest_L33_C1() [0x427e6c]

    ??:? void tmpbp8ypkoq.__modtest() [0x427f04]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c183]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b016]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4302a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430750]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43022d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42afed]

    ??:? runModuleUnitTests [0x42bf59]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428648]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    double i;\n\
    \    long collision = 0;\n    for (i = 0; i < n; i = i + 1) {\n        if ((i+1)\
    \ <= n) {\n            collision = collision + 1;\n        }\n    }\n    return\
    \ collision;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n  \
    \  assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppgkhqeem.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmppgkhqeem.__unittest_L26_C1() [0x427acc]

    ??:? void tmppgkhqeem.__modtest() [0x427b64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1);\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo_86y03k.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d55]

    ??:? void tmpo_86y03k.__unittest_L19_C1() [0x427a3c]

    ??:? void tmpo_86y03k.__modtest() [0x427ad4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a90e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff50]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8e5]

    ??:? runModuleUnitTests [0x42b851]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // start to\
    \ write your code here\n    long cnt = 0;\n    for (long i = 0; i < n; i++)\n\
    \    {\n        for (long j = i + 1; j < n; j++)\n        {\n            if (fabs(i\
    \ - j) == n - 1)\n            {\n                cnt++;\n            }\n     \
    \   }\n    }\n    return cnt;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplh47thvl.d(23): Error: `std.math.fabs` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(4126):     `std.math.fabs(real
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(4132):     `std.math.fabs(float
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplh47thvl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long x = 0;\n\
    \    return x;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7juxmhyf.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d45]

    ??:? void tmp7juxmhyf.__unittest_L20_C1() [0x427a30]

    ??:? void tmp7juxmhyf.__modtest() [0x427ac8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8fe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff40]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8d5]

    ??:? runModuleUnitTests [0x42b841]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428194]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, result\
    \ = 0;\n    long x[n], v[n];\n    float time;\n    for (i = 0; i < n; i++) {\n\
    \        x[i] = (n - i - 1) * 2;\n        v[i] = 1;\n    }\n    for (i = 0; i\
    \ < n; i++) {\n        for (j = 0; j < n; j++) {\n            if (v[i] > 0 &&\
    \ v[j] < 0) {\n                if (x[i] < x[j]) {\n                    time =\
    \ -(x[i] - x[j]) / (v[i] - v[j]);\n                    if (time > 0 && time <\
    \ 1) {\n                        result++;\n                    }\n           \
    \     }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprmersf7i.d(18): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n] x`

    /tmp/tmprmersf7i.d(18): Error: multiple declarations must have the same type,
    not `long[n]` and `long[n]`

    /tmp/tmprmersf7i.d(18): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n] v`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprmersf7i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  long coll = 0;\n\
    \  // find collisions\n  for (long i = 0; i < n; i++)\n    for (long j = i+1;\
    \ j < n; j++)\n      if (abs(i-j) == abs(n+1-i-j)) coll++;\n  return coll;\n}\n\
    /*\n    There are n + 1 dots on a long straight line.  The first n dots are\n\
    \    labeled 0 through n-1, and the n-th dot is labeled n.\n    A domino is a\
    \ rectangle.  Its sides are parallel to the line,\n    and its sides have the\
    \ same length.\n    Each domino is positioned such that it covers two consecutive\
    \ dots, i.e.,\n    the domino's right side is on dot i and its left side is on\
    \ dot i+1 for some i.\n    Each domino covers exactly two dots.  The length of\
    \ the domino is the distance\n    between the two dots it covers.  Two dominos\
    \ are considered to be different\n    if they are not in the same position or\
    \ the same orientation.\n    The dominos are not allowed to overlap;  that is,\
    \ if a dot is covered by\n    domino i, it cannot be covered by domino j for i\
    \ != j.\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl_mxbog1.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_mxbog1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // Your code\
    \ here\n    long res = 0;\n    for (long i = 0; i < n; i++)\n    {\n        for\
    \ (long j = 0; j < n; j++)\n        {\n            if (i < j)\n            {\n\
    \                res++;\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuhm8llpb.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d9d]

    ??:? void tmpuhm8llpb.__unittest_L31_C1() [0x427a84]

    ??:? void tmpuhm8llpb.__modtest() [0x427b1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff98]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa75]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a92d]

    ??:? runModuleUnitTests [0x42b899]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // the total\
    \ number of the collisions\n    long output = 0;\n    int[] left_to_right = new\
    \ int[n]; // the positions of the cars from left to right\n    int[] right_to_left\
    \ = new int[n]; // the positions of the cars from right to left\n    int[] delta\
    \ = new int[n]; // the difference between the positions of the cars in the same\
    \ index \n    int num = 0; // the number of the cars that have not collided\n\
    \    int pos = 0; // the index of the target car\n    int prev_pos = 0; // the\
    \ index of the car to compare with\n    for (int i = 0; i < n; i++) \n    {\n\
    \        // randomly generate the positions of the cars from left to right\n \
    \       left_to_right[i] = rand() % 10000;\n        // randomly generate the positions\
    \ of the cars from right to left\n        right_to_left[i] = rand() % 10000;\n\
    \        // initialize the delta array\n        delta[i] = left_to_right[i] -\
    \ right_to_left[i];\n    }\n    // sort the cars in the order of their positions\n\
    \    delta = delta.sort();\n    // while there are cars that haven't collided\n\
    \    while (num < n) \n    {\n        // find the car in the delta array whose\
    \ difference is negative\n        for (int i = 0; i < n; i++) \n        {\n  \
    \          if (delta[i] < 0) \n            {\n                pos = i;\n     \
    \           break;\n            }\n        }\n        // if no car has collided\n\
    \        if (pos == 0) \n        {\n            // we are done\n            break;\n\
    \        }\n        // find the car in the delta array that has the smallest difference\
    \ with the target car\n        // this will be the car that will collide with\
    \ the target car\n        for (int i = pos - 1; i >= 0; i--) \n        {\n   \
    \         if (delta[i] == delta[pos]) \n            {\n                prev_pos\
    \ = i;\n                break;\n            }\n        }\n        // add 1 to\
    \ the total number of collisions\n        output += (pos - prev_pos);\n      \
    \ \nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe1ovikkb.d(67): Error: found `unittest` instead of statement

    /tmp/tmpe1ovikkb.d(77): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe1ovikkb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // This can\
    \ be computed using geometry.  \n    // The result is n*(n-1)\n    // We are not\
    \ interested in the formula.\n    // We are only interested in experimenting with\
    \ the number of collisions\n    // as the number of cars grows.\n    return n*(n-1);\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprzdbxckf.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d55]

    ??:? void tmprzdbxckf.__unittest_L24_C1() [0x427a3c]

    ??:? void tmprzdbxckf.__modtest() [0x427ad4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a90e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff50]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8e5]

    ??:? runModuleUnitTests [0x42b851]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long x[],y[];\
    \ \n    long i,j,k;\n    long count=0;\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk0b5sx1n.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] x`

    /tmp/tmpk0b5sx1n.d(17): Error: multiple declarations must have the same type,
    not `long[]` and `long[]`

    /tmp/tmpk0b5sx1n.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] y`

    /tmp/tmpk0b5sx1n.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk0b5sx1n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  long x;\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphwz4bwqs.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphwz4bwqs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return (long)\
    \ ceil(n/2.0);\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0n27veez.d(17): Error: C style cast illegal, use `cast(long)ceil(n
    / 2.00000)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0n27veez.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long arr1[],\
    \ arr2[];\n    int i, j;\n    bool flag;\n    float left, right;\n    for (i =\
    \ 0; i < n; i++)\n    {\n        arr1[i] = i + 1;\n        arr2[i] = -i - 1;\n\
    \    }\n    for (i = 0; i < n; i++)\n    {\n        if (arr1[i] < 0)\n       \
    \     left = -arr1[i];\n        else\n            left = arr1[i];\n        if\
    \ (arr2[i] < 0)\n            right = -arr2[i];\n        else\n            right\
    \ = arr2[i];\n        if (left == right)\n        {\n            flag = true;\n\
    \            break;\n        }\n    }\n    if (flag)\n        return arr1[i];\n\
    \    else\n        return 0;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8sdk7ii4.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] arr1`

    /tmp/tmp8sdk7ii4.d(17): Error: multiple declarations must have the same type,
    not `long[]` and `long[]`

    /tmp/tmp8sdk7ii4.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] arr2`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8sdk7ii4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long counter\
    \ = 0;\n    float[] a = new float[];\n    float[] b = new float[];\n    for (size_t\
    \ i = 0; i < n; i++) \n    {\n        a[i] = cos(0.0001 * uniform(0, 1, 1));\n\
    \        b[i] = cos(0.0001 * uniform(0, 1, 1));\n    }\n    for (size_t i = 0;\
    \ i < n; i++) \n    {\n        for (size_t j = 0; j < n; j++) \n        {\n  \
    \          if (a[i] - b[j] < 0.0001) \n            {\n                counter++;\n\
    \            }\n        }\n    }\n    return counter;\n}\n/*\n    Imagine you\
    \ have n jars of jelly beans.  Each jar has a differing number of jelly beans.\n\
    \    You do not know what the distribution is.  You take a random sample of k\
    \ jelly beans\n    (out of the n jars) and you count how many there are.  This\
    \ is repeated m times.\n    The function outputs the average number of jelly beans\
    \ per jar.\n*/\nfloat average_jelly_beans(long n, long k, long m) \n{\n    long\
    \ sum = 0;\n    for (size_t i = 0; i < m; i++) \n    {\n        long[] a = new\
    \ long[];\n        for (size_t j = 0; j < n; j++) \n        {\n            a[j]\
    \ = uniform(0, 10000000, 1);\n        }\n        for (size_t j = 0; j < k; j++)\
    \ \n        {\n            sum += a[uniform(0, n, 1)];\n        }\n    }\n   \
    \ return sum / m;\n}\n/*\n    You have a set of n coins and an integer k.  This\
    \ function outputs the number of\n    ways that you can arrange the coins in k\
    \ rows such that every row has the same\n    number of coins.\n*/\nlong coin_row_permutation(long\
    \ n, long k) \n{\n    if (n < k) \n    {\n        return 0;\n    }\n    if (n\
    \ == k) \nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpin3zkh3s.d(72): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpin3zkh3s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 0
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long count =\
    \ 0;\n    long i, j;\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0;\
    \ j < n; j++)\n        {\n            count += 1;\n        }\n    }\n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long sum = 0;\n\
    \    auto ind = sequence!long(0, n);\n    foreach(i, ref a; ind) {\n        foreach(j,\
    \ ref b; ind) {\n            if(a < b) \n                sum += n - a;\n     \
    \       else \n                sum += n - b;\n        }\n    }\n    return sum;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5v9aau1c.d(18): Error: template instance `sequence!long` template
    `sequence` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5v9aau1c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long count =\
    \ 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++)\
    \ {\n            if (i < j) {\n                count++;\n            }\n     \
    \   }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8we392wm.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d9d]

    ??:? void tmp8we392wm.__unittest_L27_C1() [0x427a84]

    ??:? void tmp8we392wm.__modtest() [0x427b1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff98]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa75]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a92d]

    ??:? runModuleUnitTests [0x42b899]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160755
- exit_code: -1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    \n    /*@\n\
    \    loop invariant 0 <= i <= n;\n    loop invariant 0 <= j <= n;\n    loop invariant\
    \ i*j == (i*(i-1))/2 + (j*(j-1))/2;\n    loop assigns i, j;\n    loop variant\
    \ n - i;\n    */\n    for (long i = 1; i <= n; i++)\n    {\n        for (long\
    \ j = 1; j <= n; j++)\n        {\n            if (i > j)\n            {\n    \
    \            i = i + j;\n                j = i - j;\n                i = i - j;\n\
    \            }\n        }\n    }\n    return (n*(n-1))/2;\n}\nunittest\n{\n  \
    \  alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660160822
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /*\n       \
    \ a[i] = the position of the ith left-to-right moving car\n        b[i] = the\
    \ position of the ith right-to-left moving car\n        We want to know how many\
    \ collisions will happen. \n        Two cars collide if and only if a[i] > b[j]\
    \ and i < j.\n        We can sort both arrays, and this is a solution to the problem.\n\
    \    */\n    long[] a = new long[n];\n    long[] b = new long[n];\n    long r\
    \ = 0;\n    foreach (i; 0 .. n) {\n        a[i] = to!long(random(float.max)) *\
    \ (random(2) ? 1 : -1);\n        b[i] = to!long(random(float.max)) * (random(2)\
    \ ? 1 : -1);\n    }\n    std.algorithm.sort(a);\n    std.algorithm.sort(b);\n\
    \    auto const max = a.length;\n    foreach (i; 0 .. max) {\n        foreach\
    \ (j; 0 .. max) {\n            if (a[i] > b[j] && i < j) {\n                r\
    \ += 1;\n            }\n        }\n    }\n    return r;\n}\n/*\n    For example,\
    \ if a[i] = 1 and b[j] = -1, then car 1 and car -1 have collided.\n    However,\
    \ since there is no car number -1, this collision doesn't count.\n    If a[i]\
    \ = -1 and b[j] = -1, then car -1 and car -1 have collided;\n    however, there\
    \ is no such car, so this collision doesn't count.\n    If a[i] = 1 and b[j] =\
    \ 0, then car 1 and car 0 have collided.\n    Since we are assuming that there\
    \ are infinitely many cars, car 0 must exist.\n    Therefore, this collision counts.\n\
    */\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpusfzgd6j.d(28): Error: template instance `to!long` template `to`
    is not defined

    /tmp/tmpusfzgd6j.d(28): Error: undefined identifier `random`

    /tmp/tmpusfzgd6j.d(29): Error: template instance `to!long` template `to` is not
    defined

    /tmp/tmpusfzgd6j.d(29): Error: undefined identifier `random`

    /tmp/tmpusfzgd6j.d(31): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmpusfzgd6j.d(32): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpusfzgd6j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i,j,k;\n\
    \    real x[];\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps3b8n585.d(18): Deprecation: instead of C-style syntax, use D-style
    syntax `real[] x`

    /tmp/tmps3b8n585.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps3b8n585.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n\tlong collisions\
    \ = 0;\n\tlong[] pos = new long[n];\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\t\
    pos[i] = i;\n\t}\n\t\n\tforeach (i; 0 .. n) \n\t{\n\t\tforeach (j; 0 .. n) \n\t\
    \t{\n\t\t\tif (pos[i] > pos[j]) \n\t\t\t{\n\t\t\t\tcollisions++;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpicuwvo0c.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428115]

    ??:? void tmpicuwvo0c.__unittest_L36_C1() [0x427e00]

    ??:? void tmpicuwvo0c.__modtest() [0x427e98]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c113]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42afa6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430231]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4306e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4301bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42af7d]

    ??:? runModuleUnitTests [0x42bee9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4285d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long first_starting_positions_right\
    \ = n*(n+1)/2;\n    long first_starting_positions_left = -first_starting_positions_right;\n\
    \    long second_starting_positions_right = -first_starting_positions_left;\n\
    \    long second_starting_positions_left = -second_starting_positions_right;\n\
    \    long num_collisions = 0;\n    for (long i = first_starting_positions_right;\
    \ i > second_starting_positions_left; i--) {\n        num_collisions += i*(i-1)/2;\n\
    \    }\n    for (long i = second_starting_positions_left; i > first_starting_positions_right;\
    \ i--) {\n        num_collisions += i*(i-1)/2;\n    }\n    return num_collisions;\n\
    }\n \n/*\n    You are given a function that takes a string and returns a vector\
    \ of\n    strings (the way words in the input string are partitioned);\n    the\
    \ vector of strings is sorted in the alphabetical order;\n    here are some examples\
    \ of how the string is partitioned:\n    \"uusnus\" -> [\"u\", \"us\", \"nus\"\
    , \"u\", \"s\"]\n    \"1020\" -> [\"10\", \"20\"]\n    \"10\" -> [\"10\"]\n  \
    \  \"\" -> []\n    \n    This function outputs the original string.  If the original\
    \ string\n    cannot be uniquely recovered from the input vector of strings,\n\
    \    the function outputs the empty string.\n*/\nstring to_string(std::vector<string>\
    \ words) \n{\n    string result = \"\";\n    long i = 0;\n    while (i < words.size())\
    \ {\n        result += words[i];\n        while (i < words.size() && words[i].size()\
    \ < result.size()) {\n            ++i;\n        }\n        if (i < words.size()\
    \ && words[i].size() == result.size()) {\n            ++i;\n        }\n    }\n\
    \    return result;\n}\n \n/*\n    Given an array of integers, the function finds\
    \ the maximum number of\n    consecutive integers that are the\nunittest\n{\n\
    \    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4qjgozwc.d(45): Error: found `:` when expecting `)`

    /tmp/tmp4qjgozwc.d(45): Error: semicolon expected following function declaration

    /tmp/tmp4qjgozwc.d(45): Error: declaration expected, not `:`

    /tmp/tmp4qjgozwc.d(49): Error: declaration expected, not `while`

    /tmp/tmp4qjgozwc.d(51): Error: declaration expected, not `while`

    /tmp/tmp4qjgozwc.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4qjgozwc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return 0;\n\
    }\n/*\n    Given an array of integers, find the most frequent integer in it. \
    \ If there are\n    multiple integers that are frequent, return the smallest one.\n\
    \    \n    This function outputs two values: the most frequent integer and its\
    \ number of occurences.\n*/\nlong find_most_frequent(long* a, long n)\n{\n   \
    \ return 0;\n}\n/*\n    Given an integer n>0, find the largest positive integer\
    \ m whose square is less than or equal to n.\n    This function outputs two values:\
    \ the largest integer m and its squared value.\n*/\nlong largest_square(long n)\n\
    {\n    return 0;\n}\n/*\n    This function outputs the cost of a given algorithm\
    \ when the input size is a number.\n    The cost of an algorithm is the amount\
    \ of computation it does.  For example,\n    when the input size is 1, the cost\
    \ is 1; when the input size is 2, the cost is 2;\n    when the input size is 3,\
    \ the cost is 3; etc.\n*/\nlong cost(long n)\n{\n    return 0;\n}\n/*\n    This\
    \ function outputs the first integer in a sequence of n numbers that is less than\
    \ or equal to a given number m.\n    For example, if n=3 and m=2, then the function\
    \ outputs 1.\n*/\nlong find_first_less_than_or_equal(long n, long m)\n{\n    return\
    \ 0;\n}\n/*\n    This function outputs the largest integer in a sequence of n\
    \ numbers that is less than or equal to a given number m.\n    For example, if\
    \ n=3 and m=2, then the function outputs 2.\n*/\nlong find_last_less_than_or_equal(long\
    \ n, long m)\n{\n    return 0;\n}\n/*\n    This function outputs the number of\
    \ distinct values in a sequence of n numbers.\n    For example, if n=3 and the\
    \ sequence is 1, 2, 1, then the function outputs 2.\n*/\nlong count_distinct(long\
    \ n)\n{\n    return 0;\n}\n/*\n    This function outputs the product of the values\
    \ in a sequence of n numbers.\n    For example, if n=3 and the sequence is\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_5cxcmvu.d(71): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_5cxcmvu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    auto x = new\
    \ int[n];\n    auto y = new int[n];\n    foreach (i; 0 .. n)\n    {\n        x[i]\
    \ = uniform(1L, 1000000000L);\n        y[i] = uniform(1L, 1000000000L);\n    }\n\
    \    auto collisions = 0L;\n    auto j = 0L;\n    foreach (i; 0 .. n)\n    {\n\
    \        while (y[j] < x[i])\n        {\n            j++;\n        }\n       \
    \ collisions += j;\n    }\n    return collisions;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq9thpyth.d(21): Error: undefined identifier `uniform`

    /tmp/tmpq9thpyth.d(22): Error: undefined identifier `uniform`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq9thpyth.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i = 0;\n\
    \    while (i < n) {\n        long j = 0;\n        while (j < n) {\n         \
    \   if (abs(i - j) < n) {\n                __VERIFIER_assert(0);\n           \
    \ }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n    return\
    \ 0;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4cval1ck.d(22): Error: undefined identifier `__VERIFIER_assert`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4cval1ck.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long num_of_collisions\
    \ = 0;\n    num_of_collisions = sqrt(2*n);\n    return num_of_collisions;\n}\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprjbacicj.d(18): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjbacicj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /* writedown\
    \ here */\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8gbhmu2t.d(15): Error: function `tmp8gbhmu2t.car_race_collision`
    has no `return` statement, but is expected to return a value of type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gbhmu2t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    //     The position\
    \ of the first n cars driving left to right\n    long a[n];\n    //     The position\
    \ of the second n cars driving right to left\n    long b[n];\n    //     Read\
    \ the data\n    for (long i = 0; i < n; i++) {\n        scanf(\"%ld %ld\", &a[i],\
    \ &b[i]);\n    }\n    //     Sort the cars driving left to right\n    sort(a);\n\
    \    //     Sort the cars driving right to left\n    sort(b);\n    //     The\
    \ number of collisions that occur\n    long collision = 0;\n    //     The two\
    \ pointers that point to the current cars being compared\n    long a_pointer =\
    \ 0;\n    long b_pointer = 0;\n    //     Compare the cars and count the number\
    \ of collisions\n    while (a_pointer < n && b_pointer < n) {\n        if (a[a_pointer]\
    \ <= b[b_pointer]) {\n            collision += a_pointer;\n            a_pointer++;\n\
    \        } else {\n            b_pointer++;\n        }\n    }\n    //     Return\
    \ the result\n    return collision;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvziv67je.d(18): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n] a`

    /tmp/tmpvziv67je.d(20): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n] b`

    /tmp/tmpvziv67je.d(18): Error: variable `n` cannot be read at compile time

    /tmp/tmpvziv67je.d(20): Error: variable `n` cannot be read at compile time

    /tmp/tmpvziv67je.d(23): Error: undefined identifier `scanf`

    /tmp/tmpvziv67je.d(26): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpvziv67je.d(28): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvziv67je.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // Only one\
    \ car on the road, no collision.\n    if (n < 2)\n        return 0;\n    \n  \
    \  long no_of_collisions = (n * (n - 1)) / 2;\n    return no_of_collisions;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn7tgqhum.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpn7tgqhum.__unittest_L24_C1() [0x427a54]

    ??:? void tmpn7tgqhum.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long[] left_to_right;\n\
    \    long[] right_to_left;\n    long num_of_collisions = 0;\n    left_to_right.length\
    \ = n;\n    right_to_left.length = n;\n    for (long i = 0; i < n; i++) \n   \
    \ {\n        left_to_right[i] = i + 1;\n        right_to_left[i] = n - i;\n  \
    \  }\n    while (left_to_right.length > 0 && right_to_left.length > 0) \n    {\n\
    \        if (left_to_right[0] == right_to_left[0]) \n        {\n            num_of_collisions\
    \ += 1;\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        }\n        else if (left_to_right[0] < right_to_left[0]) \n        {\n\
    \            left_to_right.remove(0);\n        }\n        else \n        {\n \
    \           right_to_left.remove(0);\n        }\n    }\n    return num_of_collisions;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h9de3cx.d(32): Error: no property `remove` for type `long[]`

    /tmp/tmp6h9de3cx.d(33): Error: no property `remove` for type `long[]`

    /tmp/tmp6h9de3cx.d(37): Error: no property `remove` for type `long[]`

    /tmp/tmp6h9de3cx.d(41): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h9de3cx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return (n *\
    \ (n-1)) / 2;\n}\n \nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdw2bvru9.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpdw2bvru9.__unittest_L20_C1() [0x427a44]

    ??:? void tmpdw2bvru9.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  long[] a = new\
    \ long[n];\n  long[] b = new long[n];\n  long[][] sorted = new long[2][n];\n \
    \ for (long i = 0; i < n; i++) \n  {\n    a[i] = cast(long) round(random * n);\n\
    \    b[i] = cast(long) round(random * n);\n  }\n  sorted[0] = a.dup.sort;\n  sorted[1]\
    \ = b.dup.sort;\n  long c = 0;\n  for (long i = 0; i < n; i++) \n  {\n    auto\
    \ index = sorted[0].dup.index(a[i]);\n    if (index == i) \n    {\n      c +=\
    \ sorted[1].dup.index(b[i]);\n    }\n    else \n    {\n      c += n - 1 - sorted[1].dup.index(b[i]);\n\
    \    }\n  }\n  return c;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2o5yczme.d(19): Error: cannot implicitly convert expression `new
    long[2][](cast(ulong)n)` of type `long[2][]` to `long[][]`

    /tmp/tmp2o5yczme.d(22): Error: undefined identifier `random`

    /tmp/tmp2o5yczme.d(23): Error: undefined identifier `random`

    /tmp/tmp2o5yczme.d(25): Error: no property `sort` for type `long[]`

    /tmp/tmp2o5yczme.d(26): Error: no property `sort` for type `long[]`

    /tmp/tmp2o5yczme.d(30): Error: no property `index` for type `long[]`

    /tmp/tmp2o5yczme.d(33): Error: no property `index` for type `long[]`

    /tmp/tmp2o5yczme.d(37): Error: no property `index` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2o5yczme.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // The function\
    \ implements the idea that\n    // the car at index n is the first and the last\
    \ car to collide.\n    // For example, if n is 12, then we know that the car at\
    \ index 12 is the\n    // first car to collide and the car at index 12 is the\
    \ last car to collide.\n    // The first car to collide will necessarily collide\
    \ with the first car\n    // that moves right to left.\n    // For example, if\
    \ n is 12, the car at index 12 will collide with\n    // the car at index -12.\n\
    \    // Similarly, the last car to collide will necessarily collide with the last\n\
    \    // car that moves right to left.\n    // For example, if n is 12, the car\
    \ at index 12 will collide with\n    // the car at index -12.\n    //\n    //\
    \ As a result, this function will first iterate through the cars that move\n \
    \   // left to right and find the car at index n.  It will then iterate\n    //\
    \ through the cars that move right to left and find the car at index -n.\n   \
    \ // It will repeat this process for the cars at index n-1, n-2, n-3, ..., 1.\n\
    \    //\n    // For example, consider the following situation\n    // Car Index:\
    \                                 0    1   2   3   4   5   6\n    //         \
    \                                   7    8   9   10  11  12  13\n    //      \
    \                                      14   15  16  17  18  19  20\n    //   \
    \                                         21   22  23  24  25  26  27\n    //\
    \                                            28   29  30  31  32  33  34\n   \
    \ //                                            35   36  37  38  39  40  41\n\
    \    //                                            42   43  44  45  46  47  48\n\
    \    //                                            49   50  51  52  53  54  55\n\
    \    //                                            56   57  58  59  60  61  62\n\
    \    //                                            63   64  65  66  67  68  69\n\
    \    //                                            70   71  72  73  74  75  76\n\
    \    //                                            77   78  79  80  81  82  83\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsdo_iid5.d(48): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsdo_iid5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    double tmp\
    \ = sqrt(2.0);\n    return (long)(n * (n - 1) / tmp);\n}\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp64upei2c.d(18): Error: C style cast illegal, use `cast(long)(n
    * (n - 1) / tmp)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp64upei2c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // {{{\n   \
    \ //    version 1\n    //long k=0;\n    //long j=0;\n    //\n    //while (k<n)\
    \ {\n    //    j=0;\n    //    while (j<n) {\n    //        if ((k>j)&&(k-j)<n)\
    \ {\n    //            n--;\n    //        }\n    //        else if ((k<j)&&(j-k)<n)\
    \ {\n    //            n--;\n    //        }\n    //        j++;\n    //    }\n\
    \    //    k++;\n    //}\n    //return n;\n    // }}}\n    // {{{\n    //    version\
    \ 2\n    //    this version is better than the previous one, because it uses fewer\
    \ looping variables.\n    //long i=0;\n    //long j=0;\n    //\n    //while (i<n)\
    \ {\n    //    j=0;\n    //    while (j<n) {\n    //        if (abs(i-j)<n) {\n\
    \    //            n--;\n    //        }\n    //        j++;\n    //    }\n  \
    \  //    i++;\n    //}\n    //return n;\n    // }}}\n    // {{{\n    //    version\
    \ 3\n    //    this version is better than the previous one, because it uses a\
    \ single loop.\n    //long i=0;\n    //long j=0;\n    //\n    //while (i<n) {\n\
    \    //    if (abs(i-j)<n) {\n    //        n--;\n    //    }\n    //    j++;\n\
    \    //    if (j==n) {\n    //        i++;\n    //        j=0;\n    //    }\n\
    \    //}\n    //return n;\n    // }}}\n    // {{{\n    //    version 4\n    //\
    \    this version is better than the previous one, because it calculates the answer\
    \ directly.\n    //    n cars moving left to right is equivalent to n cars moving\
    \ right to left;\n    //    the collisions between these cars is the same as the\
    \ collisions of 2 cars moving\n    //    left\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpchn8eghz.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchn8eghz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n == 0)\
    \ \n    {\n        return 0;\n    }\n    if (n == 1) \n    {\n        return 1;\n\
    \    }\n    return (n * (n - 1)) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmmg14w_q.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d85]

    ??:? void tmpmmg14w_q.__unittest_L27_C1() [0x427a6c]

    ??:? void tmpmmg14w_q.__modtest() [0x427b04]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a93e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa5d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a915]

    ??:? runModuleUnitTests [0x42b881]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281d4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collisions\
    \ = 0;\n    long i, j;\n    long car_pos[n];\n    long car_pos_opp[n];\n    for\
    \ (i = 0; i < n; i++) {\n        car_pos[i] = i;\n        car_pos_opp[i] = -i;\n\
    \    }\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n   \
    \         if (car_pos[i] == car_pos_opp[j]) {\n                collisions++;\n\
    \            }\n        }\n    }\n    return collisions;\n}\nunittest\n{\n   \
    \ alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmbrm6f_7.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n] car_pos`

    /tmp/tmpmbrm6f_7.d(20): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n] car_pos_opp`

    /tmp/tmpmbrm6f_7.d(19): Error: variable `n` cannot be read at compile time

    /tmp/tmpmbrm6f_7.d(20): Error: variable `n` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmbrm6f_7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result\
    \ = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n;\
    \ j++) {\n            if (i < j) {\n                result += 1;\n           \
    \ }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqn4i14v4.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d9d]

    ??:? void tmpqn4i14v4.__unittest_L27_C1() [0x427a88]

    ??:? void tmpqn4i14v4.__modtest() [0x427b20]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff98]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa75]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a92d]

    ??:? runModuleUnitTests [0x42b899]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1);\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo_86y03k.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d55]

    ??:? void tmpo_86y03k.__unittest_L19_C1() [0x427a3c]

    ??:? void tmpo_86y03k.__modtest() [0x427ad4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a90e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff50]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8e5]

    ??:? runModuleUnitTests [0x42b851]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    if (n == 0\
    \ || n == 1) \n        return 0; \n  \n    long result = 0; \n    long arr_left[n],\
    \ arr_right[n]; \n    long i, j; \n  \n    for (i = 0; i < n; i++) \n        arr_left[i]\
    \ = i + 1; \n  \n    for (i = 0; i < n; i++) \n        arr_right[i] = n - i; \n\
    \  \n    for (i = 0; i < n; i++) \n        for (j = 0; j < n; j++) \n        \
    \    if (arr_left[i] == arr_right[j]) \n                result++; \n  \n    return\
    \ result; \n} \nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzqg7vx80.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n] arr_left`

    /tmp/tmpzqg7vx80.d(21): Error: multiple declarations must have the same type,
    not `long[n]` and `long[n]`

    /tmp/tmpzqg7vx80.d(21): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n] arr_right`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzqg7vx80.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    n = n+1;\n \
    \   return (n*(n-1))/2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpot1ezw0x.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpot1ezw0x.__unittest_L20_C1() [0x427a48]

    ??:? void tmpot1ezw0x.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result\
    \ = 0;\n    foreach (immutable i; 0 .. n)\n    {\n        foreach (immutable j;\
    \ i+1 .. n)\n        {\n            result += 1;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp10zbgw4h.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dad]

    ??:? void tmp10zbgw4h.__unittest_L27_C1() [0x427a94]

    ??:? void tmp10zbgw4h.__modtest() [0x427b2c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bad3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a966]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faf9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffa8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa85]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a93d]

    ??:? runModuleUnitTests [0x42b8a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i;\n  \
    \  long j;\n    long collision_count;\n    collision_count = 0;\n    for (i =\
    \ 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            if (i > j)\
    \ {\n                collision_count = collision_count + 1;\n            }\n \
    \       }\n    }\n    return collision_count;\n}\nlong main(void) \n{\n    printf(\"\
    %ld\\n\", car_race_collision(2));\n    printf(\"%ld\\n\", car_race_collision(1));\n\
    \    printf(\"%ld\\n\", car_race_collision(0));\n    printf(\"%ld\\n\", car_race_collision(3));\n\
    \    printf(\"%ld\\n\", car_race_collision(10));\n    printf(\"%ld\\n\", car_race_collision(100));\n\
    \    printf(\"%ld\\n\", car_race_collision(1000));\n    printf(\"%ld\\n\", car_race_collision(10000));\n\
    \    printf(\"%ld\\n\", car_race_collision(4));\n    printf(\"%ld\\n\", car_race_collision(20));\n\
    \    printf(\"%ld\\n\", car_race_collision(100));\n    printf(\"%ld\\n\", car_race_collision(1000));\n\
    \    printf(\"%ld\\n\", car_race_collision(2000));\n    printf(\"%ld\\n\", car_race_collision(3000));\n\
    \    printf(\"%ld\\n\", car_race_collision(4000));\n    printf(\"%ld\\n\", car_race_collision(5000));\n\
    \    printf(\"%ld\\n\", car_race_collision(6000));\n    printf(\"%ld\\n\", car_race_collision(7000));\n\
    \    printf(\"%ld\\n\", car_race_collision(8000));\n    printf(\"%ld\\n\", car_race_collision(9000));\n\
    \    printf(\"%ld\\n\", car_race_collision(10000));\n    printf(\"%ld\\n\", car_race_collision(10000));\n\
    \    printf(\"%ld\\n\",\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8qlr1ay0.d(55): Error: expression expected, not `unittest`

    /tmp/tmp8qlr1ay0.d(56): Error: found `{` when expecting `,`

    /tmp/tmp8qlr1ay0.d(57): Error: expression expected, not `alias`

    /tmp/tmp8qlr1ay0.d(57): Error: found `candidate` when expecting `,`

    /tmp/tmp8qlr1ay0.d(57): Error: expression expected, not `=`

    /tmp/tmp8qlr1ay0.d(57): Error: found `car_race_collision` when expecting `,`

    /tmp/tmp8qlr1ay0.d(57): Error: expression expected, not `;`

    /tmp/tmp8qlr1ay0.d(59): Error: found `assert` when expecting `,`

    /tmp/tmp8qlr1ay0.d(59): Error: found `;` when expecting `,`

    /tmp/tmp8qlr1ay0.d(60): Error: found `;` when expecting `,`

    /tmp/tmp8qlr1ay0.d(61): Error: found `;` when expecting `,`

    /tmp/tmp8qlr1ay0.d(62): Error: found `;` when expecting `,`

    /tmp/tmp8qlr1ay0.d(63): Error: found `;` when expecting `,`

    /tmp/tmp8qlr1ay0.d(64): Error: expression expected, not `}`

    /tmp/tmp8qlr1ay0.d(65): Error: found `void` when expecting `,`

    /tmp/tmp8qlr1ay0.d(65): Error: found `{` when expecting `,`

    /tmp/tmp8qlr1ay0.d(6'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long n_col =\
    \ 1;\n    long* cur_max = new long[n];\n    std.fill(cur_max, 0, n, 0);\n    long*\
    \ next_max = new long[n];\n    std.fill(next_max, 0, n, 0);\n    long* cur_avg\
    \ = new long[n];\n    std.fill(cur_avg, 0, n, 0);\n    long* next_avg = new long[n];\n\
    \    std.fill(next_avg, 0, n, 0);\n    for (long i = 0; i < n; i++) \n    {\n\
    \        for (long j = 0; j < n; j++) \n        {\n            if (next_max[j]\
    \ < cur_max[i] + 1) \n            {\n                next_max[j] = cur_max[i]\
    \ + 1;\n                next_avg[j] = cur_avg[i] + i + 1;\n            }\n   \
    \         else if (next_max[j] == cur_max[i] + 1) \n            {\n          \
    \      next_avg[j] = min(next_avg[j], cur_avg[i] + i + 1);\n            }\n  \
    \      }\n        n_col += next_max[i];\n        std.swap(cur_max, next_max);\n\
    \        std.swap(cur_avg, next_avg);\n        std.fill(next_max, 0, n, 0);\n\
    \        std.fill(next_avg, 0, n, 0);\n    }\n    return n_col;\n}\n \n/*\n  \
    \  Now, imagine the road becomes a circle of diameter d.\n    The cars that drive\
    \ left to right now drive counterclockwise;\n    the cars that drive right to\
    \ left now drive clockwise.\n    Each car is 1 unit long and moves 1 unit per\
    \ second.\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2rc__r9m.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2rc__r9m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long[] left_to_right_car_position\
    \ = new long[n];\n    long[] right_to_left_car_position = new long[n];\n    for\
    \ (long i = 0; i < n; i++) \n    {\n        left_to_right_car_position[i] = i\
    \ + 1;\n        right_to_left_car_position[i] = 1000000000 - i;\n    }\n    long\
    \ left_to_right_car_min_position = min(left_to_right_car_position);\n    long\
    \ right_to_left_car_max_position = max(right_to_left_car_position);\n    long\
    \ time = 0;\n    long collision_number = 0;\n    while (left_to_right_car_min_position\
    \ < right_to_left_car_max_position) \n    {\n        for (long i = 0; i < n; i++)\
    \ \n        {\n            left_to_right_car_position[i] += (time + 1);\n    \
    \        right_to_left_car_position[i] -= (time + 1);\n        }\n        left_to_right_car_min_position\
    \ = min(left_to_right_car_position);\n        right_to_left_car_max_position =\
    \ max(right_to_left_car_position);\n        collision_number += n;\n        time++;\n\
    \    }\n    return collision_number;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7spfitau.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp7spfitau.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp7spfitau.d(35): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp7spfitau.d(36): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7spfitau.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1);\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo_86y03k.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d55]

    ??:? void tmpo_86y03k.__unittest_L19_C1() [0x427a3c]

    ??:? void tmpo_86y03k.__modtest() [0x427ad4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a90e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff50]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8e5]

    ??:? runModuleUnitTests [0x42b851]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n\tlong i = 1;\n\t\
    long collision = 0;\n\twhile (i <= n)\n\t{\n\t\tcollision += i;\n\t\ti++;\n\t\
    }\n\treturn collision;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwpdu4xvs.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d7d]

    ??:? void tmpwpdu4xvs.__unittest_L26_C1() [0x427a64]

    ??:? void tmpwpdu4xvs.__modtest() [0x427afc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baa3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a936]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa55]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a90d]

    ??:? runModuleUnitTests [0x42b879]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281cc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long c = 0;\n\
    \    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n\
    \            if (i >= j) {\n                continue;\n            }\n       \
    \     double t1 = double(j)/n;\n            double t2 = double(i)/n;\n       \
    \     double d = abs(t1 - t2);\n            if (d < 0.5) {\n                c\
    \ += 1;\n            }\n        }\n    }\n    return c;\n}\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpl2jpzou3.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmpl2jpzou3.__unittest_L33_C1() [0x427b6c]

    ??:? void tmpl2jpzou3.__modtest() [0x427c10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbd3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa66]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbf9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300a8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb85]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa3d]

    ??:? runModuleUnitTests [0x42b9a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  //  You've been\
    \ given an array of n numbers. Each number represents a car's starting\n  // \
    \ point.  The car starts out driving left to right.  So, if the array is [1, 5,\
    \ 9],\n  //  car 0 starts at position 1, car 1 starts at position 5, and car 2\
    \ starts at position 9.\n  //  This function computes the number of collisions.\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7dszmwnr.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7dszmwnr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  //@ assert n>=0;\n\
    \  long c=0;\n  while(n--)\n  {\n    c += n;\n  }\n  return c;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnxg72q0z.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpnxg72q0z.__unittest_L25_C1() [0x427a5c]

    ??:? void tmpnxg72q0z.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collissions\
    \ = 0;\n    long* leftToRightPositions = new long[n];\n    long* rightToLeftPositions\
    \ = new long[n];\n    for (long i = 0; i < n; i++)\n    {\n        leftToRightPositions[i]\
    \ = i;\n        rightToLeftPositions[i] = -(i + 1);\n    }\n    long rightToLeftIndex\
    \ = 0;\n    long leftToRightIndex = 0;\n    while(rightToLeftIndex < n && leftToRightIndex\
    \ < n)\n    {\n        if(leftToRightPositions[leftToRightIndex] > rightToLeftPositions[rightToLeftIndex])\n\
    \        {\n            collissions++;\n            rightToLeftIndex++;\n    \
    \    }\n        else\n        {\n            leftToRightIndex++;\n        }\n\
    \    }\n    return collissions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9fvftp4n.d(18): Error: cannot implicitly convert expression `new
    long[](cast(ulong)n)` of type `long[]` to `long*`

    /tmp/tmp9fvftp4n.d(19): Error: cannot implicitly convert expression `new long[](cast(ulong)n)`
    of type `long[]` to `long*`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9fvftp4n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long *[] result;\n\
    \    result = malloc(2 * n * sizeof(long *));\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjo2z2uqo.d(18): Error: found `*` when expecting `.` following long

    /tmp/tmpjo2z2uqo.d(18): Error: found `)` when expecting identifier following `long`.

    /tmp/tmpjo2z2uqo.d(18): Error: found `;` when expecting `,`

    /tmp/tmpjo2z2uqo.d(19): Error: expression expected, not `unittest`

    /tmp/tmpjo2z2uqo.d(20): Error: found `{` when expecting `,`

    /tmp/tmpjo2z2uqo.d(21): Error: expression expected, not `alias`

    /tmp/tmpjo2z2uqo.d(21): Error: found `candidate` when expecting `,`

    /tmp/tmpjo2z2uqo.d(21): Error: expression expected, not `=`

    /tmp/tmpjo2z2uqo.d(21): Error: found `car_race_collision` when expecting `,`

    /tmp/tmpjo2z2uqo.d(21): Error: expression expected, not `;`

    /tmp/tmpjo2z2uqo.d(23): Error: found `assert` when expecting `,`

    /tmp/tmpjo2z2uqo.d(23): Error: found `;` when expecting `,`

    /tmp/tmpjo2z2uqo.d(24): Error: found `;` when expecting `,`

    /tmp/tmpjo2z2uqo.d(25): Error: found `;` when expecting `,`

    /tmp/tmpjo2z2uqo.d(26): Error: found `;` when expecting `,`

    /tmp/tmpjo2z2uqo.d(27): Error: found `;` wh'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    int i = 0;\n\
    \    int j = 0;\n    long result = 0;\n    for (i = 0; i < n; i++) {\n       \
    \ for (j = 0; j < n; j++) {\n            if (i <= j) {\n                result++;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk_e0qbag.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d9d]

    ??:? void tmpk_e0qbag.__unittest_L29_C1() [0x427a84]

    ??:? void tmpk_e0qbag.__modtest() [0x427b1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff98]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa75]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a92d]

    ??:? runModuleUnitTests [0x42b899]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result\
    \ = 0;\n    foreach (i; 0 .. n)\n    {\n        result += i * (n - i);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpev7u1jxs.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d8d]

    ??:? void tmpev7u1jxs.__unittest_L24_C1() [0x427a74]

    ??:? void tmpev7u1jxs.__modtest() [0x427b0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a946]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff88]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a91d]

    ??:? runModuleUnitTests [0x42b889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collisions\
    \ = 0;\n    double[] A = new double[n];\n    double[] B = new double[n];\n   \
    \ double[] C = new double[n];\n    double[] D = new double[n];\n    foreach (i,\
    \ ref a; A) {\n        a = i;\n    }\n    foreach (i, ref a; B) {\n        a =\
    \ i;\n    }\n    foreach (i, ref a; C) {\n        a = i;\n    }\n    foreach (i,\
    \ ref a; D) {\n        a = i;\n    }\n    //The speed of each car is the same\n\
    \    double v = 10;\n    foreach (i, ref a; A) {\n        //speed for A is positive\n\
    \        a += v;\n    }\n    foreach (i, ref a; B) {\n        //speed for B is\
    \ negative\n        a -= v;\n    }\n    //these are the time intervals\n    foreach\
    \ (i, ref a; C) {\n        //the equation is x = v * t, where t is the time interval\n\
    \        a = abs(a);\n    }\n    foreach (i, ref a; D) {\n        //the equation\
    \ is x = v * t, where t is the time interval\n        a = abs(a);\n    }\n   \
    \ //This is the location of the cars\n    foreach (i, ref a; A) {\n        a +=\
    \ C[i];\n    }\n    foreach (i, ref a; B) {\n        a += D[i];\n    }\n    //This\
    \ is the collision\n    foreach (i, j; A) {\n        if (abs(A[i] - B[j]) <= 1)\
    \ {\n            collisions++;\n        }\n    }\n    return collisions;\n}\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx5ox_ntc.d(62): Error: cannot implicitly convert expression `j`
    of type `double` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx5ox_ntc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    auto car_positions\
    \ = new real[n];\nunittest\n{\n    alias candidate = car_race_collision;\n\n \
    \   assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt2t1pmvk.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt2t1pmvk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n <= 1)\
    \ return 0;\n    long[] left(n);\n    long[] right(n);\n    for (size_t i = 0;\
    \ i < n; i++) \n    {\n        left[i] = n-i;\n        right[i] = i+1;\n    }\n\
    \    sort(left);\n    sort(right);\n    long collisions = 0;\n    long left_index\
    \ = 0;\n    long right_index = 0;\n    while (left_index < n && right_index <\
    \ n) \n    {\n        if (left[left_index] > right[right_index]) \n        {\n\
    \            collisions += (n - left_index);\n            right_index++;\n   \
    \     } \n        else \n        {\n            left_index++;\n        }\n   \
    \ }\n    return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvfdwqpu9.d(18): Error: `n` is used as a type

    /tmp/tmpvfdwqpu9.d(19): Error: `n` is used as a type

    /tmp/tmpvfdwqpu9.d(25): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpvfdwqpu9.d(26): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvfdwqpu9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvscmtrvs.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d4d]

    ??:? void tmpvscmtrvs.__unittest_L19_C1() [0x427a34]

    ??:? void tmpvscmtrvs.__modtest() [0x427acc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a906]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff48]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8dd]

    ??:? runModuleUnitTests [0x42b849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42819c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    if (n == 0)\
    \ \n    {\n        return 0;\n    } \n    else \n    {\n        long r = rand;\n\
    \        return car_race_collision(n-1) + r;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjerheyns.d(23): Error: undefined identifier `rand`, did you mean
    function `round`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjerheyns.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    long count\
    \ = 0;\n    while (n) \n    {\n        count += n-1;\n        n--;\n    }\n  \
    \  return count;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdh31_hro.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpdh31_hro.__unittest_L25_C1() [0x427a5c]

    ??:? void tmpdh31_hro.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    assert(n >=\
    \ 1);\n    return n * (n - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv9ys6bg3.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e49]

    ??:? void tmpv9ys6bg3.__unittest_L20_C1() [0x427a7c]

    ??:? void tmpv9ys6bg3.__modtest() [0x427b14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb6f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa02]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb95]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430044]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb21]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9d9]

    ??:? runModuleUnitTests [0x42b945]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428298]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return cast(long)\
    \ trunc(n * (n - 1) / 2);\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp28o3k8f2.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e35]

    ??:? void tmp28o3k8f2.__unittest_L19_C1() [0x427b20]

    ??:? void tmp28o3k8f2.__modtest() [0x427bb8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430048]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9dd]

    ??:? runModuleUnitTests [0x42b949]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428284]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long count =\
    \ 0;\n    while (n > 0) {\n        count += n - 1;\n        n -= 1;\n    }\n \
    \   return count;\n}\n \n/*\n  Suppose you have a function f that takes n integers\
    \ as input, and outputs true or false.\n  You are given a list of n triples, (a,b,c).\n\
    \  You have to output the number of triples in the list that satisfy the following\
    \ condition:\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp85v9tkkl.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp85v9tkkl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n <= 1)\n\
    \        return 0;\n    else if (n <= 3)\n        return n - 1;\n    else if (n\
    \ % 2 == 0)\n        return n * (n - 2) / 4;\n    else if (n % 4 == 1)\n     \
    \   return (n - 1) * (n - 3) / 4;\n    else\n        return (n - 1) * (n - 3)\
    \ / 4 + 1;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7gx8vgc1.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmp7gx8vgc1.__unittest_L28_C1() [0x427ae4]

    ??:? void tmp7gx8vgc1.__modtest() [0x427b7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n == 0)\n\
    \        return 0;\n    \n    long[] cars = new long[n];\n    long[] distances\
    \ = new long[n];\n    long collisions = 0;\n    \n    /*\n    On a long road,\
    \ there can be more than one car at a point.  So, for each of the\n    positions\
    \ on the road, we need to maintain an array of indices that tell us the\n    index\
    \ of the cars that are at that position.  The cars array has n entries.\n    The\
    \ ith entry is the position of the ith car.\n    */\n    foreach (i; 0 .. n)\n\
    \    {\n        cars[i] = 2 * i;\n    }\n    \n    /*\n    The distances array\
    \ has n entries.  We will initialize it to contain\n    the distances between\
    \ car pairs.  The distance between car i and j is the\n    absolute value of the\
    \ difference between their initial positions.\n    */\n    foreach (i; 0 .. n)\n\
    \    {\n        foreach (j; 0 .. n)\n        {\n            distances[i * n +\
    \ j] = abs(cars[i] - cars[j]);\n        }\n    }\n    \n    /*\n    There are\
    \ n^2 car pairs.  The distances array has n^2 entries, and so does the\n    indices\
    \ array.  Each ith entry of the indices array is the index of the car pair\n \
    \   with the minimum initial distance.\n    */\n    long[] indices = new long[n\
    \ * n];\n    foreach (i; 0 .. n * n)\n    {\n        indices[i] = i;\n    }\n\
    \    \n    /*\n    Sort the indices array.  We are sorting the distances.  As\
    \ a result, we want to \n    sort the indices array by the distances.  But we\
    \ want to do this in increasing order\n    of distances.  So, we need to construct\
    \ a comparison function that tells us whether\n    two indices a and b should\
    \ be swapped.  One of the indices may be the minimum, the\n    other may not.\
    \  A is the index of a distance.  B is the index of another distance.\n    If\
    \ a < b, then the distance at index a is less than the distance at index b.\n\
    \    If a\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpctj0ircs.d(59): Error: unterminated /* */ comment

    /tmp/tmpctj0ircs.d(77): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpctj0ircs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long num_collisions\
    \ = 0;\n    float[long] car_positions;\n    float[long] car_velocities;\n    foreach(i=0;\
    \ i<n; i++) {\n        car_positions[i] = 0;\n        car_velocities[i] = 1;\n\
    \    }\n    foreach(i=0; i<n; i++) {\n        car_positions[i] = 0;\n        car_velocities[i]\
    \ = -1;\n    }\n    /*\n        Now, we have a set of cars all moving in the same\
    \ direction,\n        and a set of cars all moving in the other direction.\n \
    \       However, each car is traveling at a different speed.\n    */\n    foreach(i=0;\
    \ i<n; i++) {\n        foreach(j=0; j<n; j++) {\n            car_positions[i]\
    \ += car_velocities[i];\n            car_positions[j] += car_velocities[j];\n\
    \            if( car_positions[i] > car_positions[j] ) {\n                num_collisions++;\n\
    \            }\n        }\n    }\n    return num_collisions;\n}\nunittest\n{\n\
    \    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9za2fqxt.d(20): Error: no identifier for declarator `i`

    /tmp/tmp9za2fqxt.d(20): Error: found `=` when expecting `;`

    /tmp/tmp9za2fqxt.d(20): Error: found `;` when expecting `)`

    /tmp/tmp9za2fqxt.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp9za2fqxt.d(24): Error: no identifier for declarator `i`

    /tmp/tmp9za2fqxt.d(24): Error: found `=` when expecting `;`

    /tmp/tmp9za2fqxt.d(24): Error: found `;` when expecting `)`

    /tmp/tmp9za2fqxt.d(24): Error: found `)` when expecting `;` following statement

    /tmp/tmp9za2fqxt.d(33): Error: no identifier for declarator `i`

    /tmp/tmp9za2fqxt.d(33): Error: found `=` when expecting `;`

    /tmp/tmp9za2fqxt.d(33): Error: found `;` when expecting `)`

    /tmp/tmp9za2fqxt.d(33): Error: found `)` when expecting `;` following statement

    /tmp/tmp9za2fqxt.d(34): Error: no identifier for declarator `j`

    /tmp/tmp9za2fqxt.d(34): Error: found `=` when expecting `;`

    /tmp/tmp9za2fqxt.d(34): Error: found `;` when expecting `)`

    /tmp/tmp9za2fqxt.d(34): Error: found `)` when ex'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /*\n       \
    \ PSEUDOCODE\n        This is a classic example of a problem that can be solved\n\
    \        by a sweep line approach.\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1fgw7c9p.d(17): Error: unterminated /* */ comment

    /tmp/tmp1fgw7c9p.d(31): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1fgw7c9p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n < 1) return\
    \ 0;\n    return n*(n-1)/2;\n}\n//Tests\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn8ae75m6.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpn8ae75m6.__unittest_L21_C1() [0x427a54]

    ??:? void tmpn8ae75m6.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result\
    \ = 0;\n    long A[n];\n    long B[n];\n    srand(time(0));\n    foreach(i; 0\
    \ .. n) { \n        A[i] = (1 - 2 * (i % 2)) * (i + 1);\n        B[i] = (1 - 2\
    \ * (i % 2)) * (i + 1);\n    }\n    long i = 0;\n    long j = 0;\n    for(i =\
    \ 0; i < n; i++) {\n        for(j = 0; j < n; j++) {\n            if(A[i] * B[j]\
    \ < 0) {\n                result++;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4m5rautl.d(18): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n] A`

    /tmp/tmp4m5rautl.d(19): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n] B`

    /tmp/tmp4m5rautl.d(18): Error: variable `n` cannot be read at compile time

    /tmp/tmp4m5rautl.d(19): Error: variable `n` cannot be read at compile time

    /tmp/tmp4m5rautl.d(20): Error: undefined identifier `srand`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4m5rautl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return (n*(n-1))/2;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkciueyfn.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpkciueyfn.__unittest_L19_C1() [0x427a44]

    ??:? void tmpkciueyfn.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long *right\
    \ = new long[n];\n    long *left = new long[n];\n    long collisions = 0;\n  \
    \  for (long i = 0; i < n; i++) \n    {\n        right[i] = i;\n        left[i]\
    \ = n - i - 1;\n    }\n    for (long i = 0; i < n; i++) \n    {\n        for (long\
    \ j = 0; j < n; j++) \n        {\n            if (right[i] == left[j]) \n    \
    \        {\n                collisions++;\n            }\n        }\n    }\n \
    \   return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpglsi0t9y.d(17): Error: cannot implicitly convert expression `new
    long[](cast(ulong)n)` of type `long[]` to `long*`

    /tmp/tmpglsi0t9y.d(18): Error: cannot implicitly convert expression `new long[](cast(ulong)n)`
    of type `long[]` to `long*`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpglsi0t9y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    long result\
    \ = 0;\n    foreach (left_car; 0 .. n) {\n        foreach (right_car; 0 .. n)\
    \ {\n            if (left_car * right_car * left_car * right_car % n == 0)\n \
    \               result += 1;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4fl0qbkv.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmp4fl0qbkv.__unittest_L26_C1() [0x427ab4]

    ??:? void tmp4fl0qbkv.__modtest() [0x427b4c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // Write your\
    \ solution here\n    return n * (n - 1) / 2;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmn033lz5.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpmn033lz5.__unittest_L20_C1() [0x427a44]

    ??:? void tmpmn033lz5.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    auto G = new\
    \ Graph(2 * n);\n    for (long i = 0; i < n; i++) \n    {\n        G.addEdge(i,\
    \ i + n);\n    }\n    return G.longestPath();\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9z2mihcr.d(17): Error: undefined identifier `Graph`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9z2mihcr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long j;\n  \
    \  long collisions = 0;\n    long car_x[];\n    long car_y[];\n    long car_v[];\n\
    \    long left_cars = n;\n    long right_cars = n;\n    long car;\n    long time;\n\
    \    long num_collisions;\n    long closest_left;\n    long closest_right;\n \
    \   long i;\n    long dist;\n    j = 0;\n    for (car = 0; car < n; car = car\
    \ + 1) {\n        car_x[j] = car * 64;\n        car_y[j] = 0;\n        car_v[j]\
    \ = 8;\n        j = j + 1;\n    }\n    while (true) {\n        time = time + 1;\n\
    \        num_collisions = 0;\n        closest_left = (car_x[0] + car_v[0] * time);\n\
    \        closest_right = -(car_x[n - 1] + car_v[n - 1] * time);\n        for (i\
    \ = 1; i < n; i = i + 1) {\n            dist = (car_x[i] + car_v[i] * time);\n\
    \            if (dist < closest_left) {\n                closest_left = dist;\n\
    \            }\n        }\n        for (i = n - 2; i >= 0; i = i - 1) {\n    \
    \        dist = -(car_x[i] + car_v[i] * time);\n            if (dist < closest_right)\
    \ {\n                closest_right = dist;\n            }\n        }\n       \
    \ if (closest_left >= closest_right) {\n            break;\n        }\n      \
    \  for (i = 1; i < n; i = i + 1) {\n            dist = (car_x[i] + car_v[i] *\
    \ time);\n            if (dist == closest_left) {\n                num_collisions\
    \ = num_collisions + 1;\n            }\n        }\n        collisions = collisions\
    \ + num_collisions * right_cars;\n        right_cars = right_cars - num_collisions;\n\
    \        num_collisions = 0;\n        for\nunittest\n{\n    alias candidate =\
    \ car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpop15p7uq.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] car_x`

    /tmp/tmpop15p7uq.d(20): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] car_y`

    /tmp/tmpop15p7uq.d(21): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] car_v`

    /tmp/tmpop15p7uq.d(68): Error: found `unittest` when expecting `(`

    /tmp/tmpop15p7uq.d(78): Error: found `main` when expecting `.` following void

    /tmp/tmpop15p7uq.d(78): Error: found `(` when expecting identifier following `void`.

    /tmp/tmpop15p7uq.d(78): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmpop15p7uq.d(78): Error: found `End of File` when expecting `)`

    /tmp/tmpop15p7uq.d(78): Error: found `End of File` instead of statement

    /tmp/tmpop15p7uq.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpop15p7uq.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpop15p7uq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpugqec3_u.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpugqec3_u.__unittest_L19_C1() [0x427a44]

    ??:? void tmpugqec3_u.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160754
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long count =\
    \ 0;\n    auto A = new double[];\n    auto B = new double[];\n    foreach (i;\
    \ 0 .. n)\n    {\n        A[i] = -n + 2 * i;\n        B[i] = n - 2 * i;\n    }\n\
    \    foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n    \
    \        count += (A[i] > B[j]) ? 1 : 0;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp05jb9f56.d(18): Error: new can only create structs, dynamic arrays
    or class objects, not `double[]`''s

    /tmp/tmp05jb9f56.d(19): Error: new can only create structs, dynamic arrays or
    class objects, not `double[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp05jb9f56.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 0
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long number_of_collisions\
    \ = 0;\n    int i = 0;\n    while (i < n)\n    {\n        int j = 0;\n       \
    \ while (j < n)\n        {\n            number_of_collisions = number_of_collisions\
    \ + 1;\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n    return\
    \ number_of_collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collisions;\n\
    \    collisions = 0;\n    long i;\n    i = 0;\n    while (i < n) {\n        long\
    \ j;\n        j = 0;\n        while (j < n) {\n            long k;\n         \
    \   k = 0;\n            while (k < n) {\n                long l;\n           \
    \     l = 0;\n                while (l < n) {\n                    long m;\n \
    \                   m = 0;\n                    while (m < n) {\n            \
    \            long o;\n                        o = 0;\n                       \
    \ while (o < n) {\n                            long p;\n                     \
    \       p = 0;\n                            while (p < n) {\n                \
    \                long q;\n                                q = 0;\n           \
    \                     while (q < n) {\n                                    long\
    \ r;\n                                    r = 0;\n                           \
    \         while (r < n) {\n                                        long s;\n \
    \                                       s = 0;\n                             \
    \           while (s < n) {\n                                            long\
    \ t;\n                                            t = 0;\n                   \
    \                         while (t < n) {\n                                  \
    \              long u;\n                                                u = 0;\n\
    \                                                while (u < n) {\n           \
    \                                         long v;\n                          \
    \                          v = 0;\n                                          \
    \          while (v < n) {\n                                                 \
    \       long w;\n                                                        w = 0;\n\
    \                                                        while (w < n) {\n   \
    \                                                         long x;\n          \
    \                                                  x = 0;\n                  \
    \                                          while (x < n) {\n                 \
    \                                               long y;\n                    \
    \                                            y = 0;\n                        \
    \                                        while (y < n) {\n                   \
    \                                                 long z;\n                  \
    \                                                  z = 0;\n                  \
    \                                                  while (z < n) {\n         \
    \                                                               collisions = collisions\
    \ + 1;\n                                                                     \
    \   z = z + 1;\n                                                             \
    \       }\n                                                                  \
    \  y = y + 1;\n                                                              \
    \  }\n                                                                x = x +\
    \ 1;\n                                                            }\n        \
    \                                                    w = w + 1;\n            \
    \                                            }\n                             \
    \                           v = v + 1;\n                                     \
    \               }\n                                \nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4qstic22.d(82): Error: found `unittest` instead of statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp4qstic22.d(92): Error: found `End of File` when expectin'
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long numCollisions\
    \ = 0;\n    long count = n;\n    double leftSide = 0.0;\n    double rightSide\
    \ = 0.0;\n    bool isLeftIncreasing = true;\n    bool isRightIncreasing = false;\n\
    \    while (count > 0)\n    {\n        if (isLeftIncreasing && leftSide >= 0)\n\
    \        {\n            isLeftIncreasing = false;\n            isRightIncreasing\
    \ = true;\n            count--;\n        }\n        else if (isRightIncreasing\
    \ && rightSide <= 0)\n        {\n            isRightIncreasing = false;\n    \
    \        isLeftIncreasing = true;\n            count--;\n        }\n        else\
    \ if (isLeftIncreasing)\n        {\n            leftSide += 0.01;\n        }\n\
    \        else if (isRightIncreasing)\n        {\n            rightSide -= 0.01;\n\
    \        }\n        else\n        {\n            if (abs(leftSide) == abs(rightSide))\n\
    \            {\n                numCollisions++;\n            }\n            leftSide\
    \ -= 0.01;\n            rightSide += 0.01;\n        }\n    }\n    return numCollisions;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfofd7ma6.d(61): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f2d]

    ??:? void tmpfofd7ma6.__unittest_L57_C1() [0x427c08]

    ??:? void tmpfofd7ma6.__modtest() [0x427cac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430148]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aadd]

    ??:? runModuleUnitTests [0x42ba49]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42837c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collisions\
    \ = 0;\n    int i;\n    for (i = 0; i < n; i++)\n    {\n        double position_left_i;\n\
    \        double position_right_i;\n        double speed_left_i;\n        double\
    \ speed_right_i;\n        double time_to_collision_i;\n        int j;\n      \
    \  for (j = 0; j < n; j++)\n        {\n            double position_left_j;\n \
    \           double position_right_j;\n            double speed_left_j;\n     \
    \       double speed_right_j;\n            double time_to_collision_j;\n     \
    \       if (i != j)\n            {\n                if (speed_left_i < speed_right_j)\n\
    \                {\n                    time_to_collision_i = (position_right_j\
    \ - position_left_i) / (speed_left_i - speed_right_j);\n                    if\
    \ (time_to_collision_i < 0)\n                    {\n                        collisions++;\n\
    \                    }\n                }\n                if (speed_right_i >\
    \ speed_left_j)\n                {\n                    time_to_collision_j =\
    \ (position_left_j - position_right_i) / (speed_right_i - speed_left_j);\n   \
    \                 if (time_to_collision_j < 0)\n                    {\n      \
    \                  collisions++;\n                    }\n                }\n \
    \           }\n        }\n    }\n    return collisions;\n}\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwarsx4pr.d(61): unittest failure

    ----------------

    ??:? _d_unittestp [0x427eed]

    ??:? void tmpwarsx4pr.__unittest_L57_C1() [0x427bd4]

    ??:? void tmpwarsx4pr.__modtest() [0x427c6c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aaa6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300e8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbc5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa7d]

    ??:? runModuleUnitTests [0x42b9e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42833c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    assert(n >=\
    \ 0);\n    if (n == 0)\n    {\n        return 0;\n    }\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuwlevajf.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwlevajf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n==0)\n\
    \    {\n        return 0;\n    }\n    else\n    {\n        return n-1;\n    }\n\
    \    \n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjm003c5a.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpjm003c5a.__unittest_L27_C1() [0x427a48]

    ??:? void tmpjm003c5a.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvscmtrvs.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d4d]

    ??:? void tmpvscmtrvs.__unittest_L19_C1() [0x427a34]

    ??:? void tmpvscmtrvs.__modtest() [0x427acc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a906]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff48]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8dd]

    ??:? runModuleUnitTests [0x42b849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42819c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n <= 1)\
    \ \n        return 0;\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz8uru4i6.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz8uru4i6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long double\
    \ [] rl_array = new long double[n]; // right to left\n    long double [] lr_array\
    \ = new long double[n]; // left to right\n    long double max_lr_to_rl = 0.0;\n\
    \    long double max_rl_to_lr = 0.0;\n    long double max_lr_to_lr = 0.0;\n  \
    \  long double max_rl_to_rl = 0.0;\n    long i = 0;\n    long j = 0;\n    long\
    \ count = 0;\n    for (i = 0; i < n; i++) {\n        rl_array[i] = i;\n      \
    \  lr_array[i] = i;\n    }\n    for (i = 0; i < n; i++) {\n        max_lr_to_rl\
    \ = max(max_lr_to_rl, rl_array[i] - lr_array[i]);\n        max_rl_to_lr = max(max_rl_to_lr,\
    \ lr_array[i] - rl_array[i]);\n        max_lr_to_lr = max(max_lr_to_lr, lr_array[i]\
    \ - lr_array[i]);\n        max_rl_to_rl = max(max_rl_to_rl, rl_array[i] - rl_array[i]);\n\
    \    }\n    for (i = 0; i < n; i++) {\n        lr_array[i] = lr_array[i] + max_lr_to_rl;\n\
    \        rl_array[i] = rl_array[i] + max_rl_to_lr;\n    }\n    for (i = 0; i <\
    \ n; i++) {\n        for (j = 0; j < n; j++) {\n            if (lr_array[i] -\
    \ rl_array[j] == 0) {\n                count = count + 1;\n            }\n   \
    \     }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb1sru_if.d(17): Error: use `real` instead of `long double`

    /tmp/tmpb1sru_if.d(17): Error: use `real` instead of `long double`

    /tmp/tmpb1sru_if.d(18): Error: use `real` instead of `long double`

    /tmp/tmpb1sru_if.d(18): Error: use `real` instead of `long double`

    /tmp/tmpb1sru_if.d(19): Error: use `real` instead of `long double`

    /tmp/tmpb1sru_if.d(20): Error: use `real` instead of `long double`

    /tmp/tmpb1sru_if.d(21): Error: use `real` instead of `long double`

    /tmp/tmpb1sru_if.d(22): Error: use `real` instead of `long double`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb1sru_if.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160807
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n == 0 ||\
    \ n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n    long i;\n\
    \    long n1 = n;\n    long n2 = n;\n    long result = 0;\n    long current;\n\
    \    long remaining;\n    for (i = 1; i <= n1; i++) \n    {\n        current =\
    \ i;\n        remaining = n1 - i;\n        result += min(current, remaining);\n\
    \    }\n    for (i = 1; i <= n2; i++) \n    {\n        current = i;\n        remaining\
    \ = n2 - i;\n        result += min(current, remaining);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1fyptlmu.d(31): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp1fyptlmu.d(37): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1fyptlmu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long iter =\
    \ 0;\n    foreach (i; 0 .. n) \n    {\n        iter += (n - i);\n    }\n    return\
    \ iter;\n}\n \nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpx6tjhro7.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d85]

    ??:? void tmpx6tjhro7.__unittest_L25_C1() [0x427a70]

    ??:? void tmpx6tjhro7.__modtest() [0x427b08]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a93e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa5d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a915]

    ??:? runModuleUnitTests [0x42b881]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281d4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoi7rsomr.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpoi7rsomr.__unittest_L19_C1() [0x427a44]

    ??:? void tmpoi7rsomr.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result;\n\
    \    long[] car1 = new long[n];\n    long[] car2 = new long[n];\n    long offset\
    \ = 10000000;\n    long collision_count = 0;\n    long i;\n    long j;\n    long\
    \ temp;\n    long first_car_index;\n    long second_car_index;\n    for (i = 0;\
    \ i < n; i++) {\n        car1[i] = i * offset;\n        car2[i] = -1 * (i * offset);\n\
    \    }\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n - 1; j++) {\n\
    \            if (car1[j] > car1[j + 1]) {\n                temp = car1[j];\n \
    \               car1[j] = car1[j + 1];\n                car1[j + 1] = temp;\n\
    \            }\n            if (car2[j] > car2[j + 1]) {\n                temp\
    \ = car2[j];\n                car2[j] = car2[j + 1];\n                car2[j +\
    \ 1] = temp;\n            }\n        }\n    }\n    first_car_index = 0;\n    second_car_index\
    \ = 0;\n    collision_count = 0;\n    while (first_car_index < n && second_car_index\
    \ < n) {\n        if (car1[first_car_index] <= car2[second_car_index]) {\n   \
    \         collision_count += second_car_index;\n            first_car_index++;\n\
    \        } else {\n            second_car_index++;\n        }\n    }\n    result\
    \ = collision_count;\n    return result;\n}\nlong main()\n{\n    long i;\n   \
    \ i = car_race_collision(1);\n    print_text(\"for 1 car, collision is \");\n\
    \    print_long(i);\n    print_text(\"\\n\");\n    i = car_race_collision(2);\n\
    \    print_text(\"for 2 cars, collision is \");\n    print_long(i);\n    print_text(\"\
    \\n\");\n    i = car_race\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi4jmz5u1.d(71): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpi4jmz5u1.d(81): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi4jmz5u1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n == 0)\
    \ return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n    long sum\
    \ = 0;\n    for (long i = 0; i < n; i++)\n    {\n        sum += n - i - 1;\n \
    \   }\n    return sum;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz6kccadi.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmpz6kccadi.__unittest_L27_C1() [0x427a9c]

    ??:? void tmpz6kccadi.__modtest() [0x427b34]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    constexpr long\
    \ MAX_SPEED = 100'000'000;\n    constexpr long MAX_TIME = 1000'000'000;\n    constexpr\
    \ long MAX_CARS = 100'000;\n    long num_pos[MAX_CARS+1]; // the initial positions\
    \ of the cars moving left to right\n    long num_speed[MAX_CARS+1]; // the speeds\
    \ of the cars moving left to right\n    long num_pos_neg[MAX_CARS+1]; // the initial\
    \ positions of the cars moving right to left\n    long num_speed_neg[MAX_CARS+1];\
    \ // the speeds of the cars moving right to left\n    long num_collisions = 0;\n\
    \    for (long i = 1; i <= n; i++) \n    {\n        num_pos[i] = (long) (uniform01()\
    \ * MAX_TIME);\n        num_speed[i] = (long) (uniform01() * MAX_SPEED) + 1;\n\
    \        num_pos_neg[i] = (long) (uniform01() * MAX_TIME);\n        num_speed_neg[i]\
    \ = (long) (uniform01() * MAX_SPEED) + 1;\n    }\n    sort(num_pos + 1, num_pos\
    \ + n + 1);\n    sort(num_pos_neg + 1, num_pos_neg + n + 1);\n    // Invariant:\
    \ cars 1..k-1 are already placed in the array.\n    for (long k = 1; k <= n; k++)\
    \ \n    {\n        num_pos[k] += k * num_speed[k];\n        num_pos_neg[k] -=\
    \ k * num_speed_neg[k];\n        num_collisions += (num_pos[k] <= num_pos_neg[k])\
    \ ? 1 : 0;\n    }\n    return num_collisions;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw9pz5kbj.d(17): Error: found `long` when expecting `;` following
    statement

    /tmp/tmpw9pz5kbj.d(17): Error: unterminated character constant

    /tmp/tmpw9pz5kbj.d(17): Error: found `63U` when expecting `;` following statement

    /tmp/tmpw9pz5kbj.d(17): Error: unterminated character constant

    /tmp/tmpw9pz5kbj.d(17): Error: found `63U` when expecting `;` following statement

    /tmp/tmpw9pz5kbj.d(18): Error: found `long` when expecting `;` following statement

    /tmp/tmpw9pz5kbj.d(18): Error: unterminated character constant

    /tmp/tmpw9pz5kbj.d(18): Error: found `63U` when expecting `;` following statement

    /tmp/tmpw9pz5kbj.d(18): Error: unterminated character constant

    /tmp/tmpw9pz5kbj.d(18): Error: found `63U` when expecting `;` following statement

    /tmp/tmpw9pz5kbj.d(19): Error: found `long` when expecting `;` following statement

    /tmp/tmpw9pz5kbj.d(19): Error: unterminated character constant

    /tmp/tmpw9pz5kbj.d(19): Error: found `63U` when expecting `;` following statement

    /tmp/tmpw9pz5kbj.d(20): Deprecation: instead of C-'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n*(n-1)/2;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbevt8cgy.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpbevt8cgy.__unittest_L19_C1() [0x427a44]

    ??:? void tmpbevt8cgy.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160755
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    auto i = 0L;\n\
    \    auto j = n-1L;\n    auto count = 0L;\n    while (i < n && j >= 0) {\n   \
    \     if (i == j) \n            ++count;\n        else \n            count +=\
    \ 2;\n        ++i;\n        --j;\n    }\n    return count;\n}\nunittest\n{\n \
    \   alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9riljqp5.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmp9riljqp5.__unittest_L30_C1() [0x427a9d]

    ??:? void tmp9riljqp5.__modtest() [0x427b14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n*(n-1)/2;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbevt8cgy.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpbevt8cgy.__unittest_L19_C1() [0x427a44]

    ??:? void tmpbevt8cgy.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160755
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    //     null\
    \     0     1     2     3     4     5     6     7     8     9\n    // left_cars\
    \  0     0     1     2     3     4     5     6     7     8\n    // right_cars\
    \ 0     9     8     7     6     5     4     3     2     1\n    //            \
    \ \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /\n    //\
    \              2     1     0     0     1     2     3     4     5     6\n    return\
    \ n * (n-1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvqg21qof.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpvqg21qof.__unittest_L24_C1() [0x427a44]

    ??:? void tmpvqg21qof.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long left =\
    \ n;\n    long right = n;\n    long collide = 0;\n    while (left > 0 && right\
    \ > 0) \n    {\n        if (left > right) \n        {\n            collide +=\
    \ right;\n            left -= right;\n            right = 0;\n        } \n   \
    \     else if (left < right) \n        {\n            collide += left;\n     \
    \       right -= left;\n            left = 0;\n        } \n        else // left\
    \ == right\n        {\n            collide += left;\n            left = 0;\n \
    \           right = 0;\n        }\n    }\n    return collide;\n}\nunittest\n{\n\
    \    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpif7r2bw0.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dbd]

    ??:? void tmpif7r2bw0.__unittest_L43_C1() [0x427aa8]

    ??:? void tmpif7r2bw0.__modtest() [0x427b40]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bae3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a976]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb09]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa95]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a94d]

    ??:? runModuleUnitTests [0x42b8b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42820c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    double[long]\
    \ right_cars; //1D array with n elements\n    double[long] left_cars; //1D array\
    \ with n elements\n    long right_cars_count=0;\n    long left_cars_count=0;\n\
    \    long num_collisions=0;\n    long temp_right_count=0;\n    long temp_left_count=0;\n\
    \    int i;\n    int j;\n    /*\n        Initialize the two arrays by assigning\
    \ each element to a distinct number.\n        For example, if n = 3, then the\
    \ array of right cars must be 0, 1, 2, and the\n        array of left cars must\
    \ be 0, 1, 2.\n    */\n    for(i=0;i<n;i++) {\n        right_cars[i]=i;\n    \
    \    left_cars[i]=i;\n    }\n    for(i=0;i<n;i++) {\n        temp_right_count\
    \ = right_cars_count;\n        temp_left_count = left_cars_count;\n        right_cars_count\
    \ = right_cars_count + right_cars[i];\n        left_cars_count = left_cars_count\
    \ + left_cars[i];\n        num_collisions = num_collisions + temp_right_count\
    \ * temp_left_count;\n    }\n    /*\n        These values must be returned.\n\
    \    */\n    return num_collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm2vrbzof.d(38): Error: cannot implicitly convert expression `cast(double)right_cars_count
    + right_cars[cast(long)i]` of type `double` to `long`

    /tmp/tmpm2vrbzof.d(39): Error: cannot implicitly convert expression `cast(double)left_cars_count
    + left_cars[cast(long)i]` of type `double` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm2vrbzof.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n<=1) return\
    \ 0;\n    return n*(n-1)/2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcj0e535v.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpcj0e535v.__unittest_L20_C1() [0x427a54]

    ??:? void tmpcj0e535v.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long cnt = 0;\n\
    \    int cur_dir = 1;\n    long pos = 0;\n    int* car_pos = new int[n];\n   \
    \ // pos is the current position of the car.  Cars start at the same position\n\
    \    // with the same distance to each other.\n    for (int i = 0; i < n; i++)\
    \ {\n        car_pos[i] = i * 2;\n    }\n    while (true) {\n        // move the\
    \ car to the next position\n        if (cur_dir == 1) {\n            pos++;\n\
    \        } else {\n            pos--;\n        }\n        // iterate through all\
    \ the cars to see whether a collision happened.\n        for (int i = 0; i < n;\
    \ i++) {\n            if (car_pos[i] == pos) {\n                // a collision\
    \ happened\n                cnt++;\n                cur_dir = -cur_dir;\n    \
    \            break;\n            }\n        }\n        // check if all the cars\
    \ have passed by each other.\n        if (cur_dir == 1) {\n            if (pos\
    \ > n * 2) {\n                break;\n            }\n        } else {\n      \
    \      if (pos < 0) {\n                break;\n            }\n        }\n    }\n\
    \    return cnt;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp02g_gur4.d(20): Error: cannot implicitly convert expression `new
    int[](cast(ulong)n)` of type `int[]` to `int*`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp02g_gur4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long car[n];\n\
    \    long car2[n];\n    long c=0;\n    for(long i=0;i<n;i++)\n    {\n        car[i]=0;\n\
    \        car2[i]=0;\n    }\n    for(long i=0;i<n;i++)\n    {\n        car[i]=i+1;\n\
    \        car2[i]=n-i;\n    }\n    for(long i=0;i<n;i++)\n    {\n        for(long\
    \ j=0;j<n;j++)\n        {\n            if(car[i]==car2[j])\n            {\n  \
    \              c++;\n            }\n        }\n    }\n    return c;\n}\n/*\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmz1x43dk.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n] car`

    /tmp/tmpmz1x43dk.d(18): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n] car2`

    /tmp/tmpmz1x43dk.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmz1x43dk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpugqec3_u.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpugqec3_u.__unittest_L19_C1() [0x427a44]

    ??:? void tmpugqec3_u.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160754
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    double num_collisions\
    \ = 0;\n    /*\n        The second loop is the more important loop. \n       \
    \ Think of all the cars that are moving from left to right as fixed.\n       \
    \ Now, take one of the cars that's moving from right to left. \n        This car\
    \ will collide with all the cars that are moving from left to right,\n       \
    \ and so the number of collisions that this car is involved in is n,\n       \
    \ and so the total number of collisions is n * n = n^2.\n        \n        We\
    \ could have written a second loop, but there is no need, as all we have to do\
    \ is\n        to multiply the number of cars that are moving from left to right\
    \ by the number\n        of cars that are moving from right to left.\n    */\n\
    \    return (long) ceil(n * n);\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ffu20to.d(30): Error: C style cast illegal, use `cast(long)ceil(n
    * n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ffu20to.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i;\n  \
    \  long collision = 0;\n    int[] cars;\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppsk22nku.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppsk22nku.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // long[] left\
    \ = new long[n];\n    // long[] right = new long[n];\n    // long answer = 0;\n\
    \    // long i, j;\n    // for (i = 0; i < n; i++) {\n    //     left[i] = i;\n\
    \    //     right[i] = n - i - 1;\n    // }\n    // for (i = 0; i < n; i++) {\n\
    \    //     for (j = 0; j < n; j++) {\n    //         if (left[i] < right[j])\
    \ {\n    //             answer++;\n    //         }\n    //     }\n    // }\n\
    \    // return answer;\n    return n * (n - 1) / 2;\n}\n/*\n    This is a sorted\
    \ list of numbers.  A painter chooses a number, and deletes it.\n    However,\
    \ in the process of deleting, it also deletes the number to the right of\n   \
    \ the chosen number.  For example, if the painter chooses the number 6, it deletes\n\
    \    the number 6 and the number 7.\n    This function outputs the number of different\
    \ number-deletion sequences that\n    lead to the deletion of all numbers from\
    \ the list.\n*/\nlong list_painter(long n) \n{\n    return n;\n}\n/*\n    You\
    \ are given an array of length n, with integer elements between 0 and n-1.\n \
    \   In this array, there are some number of cycles.  For example, consider the\
    \ array\n    {1, 2, 0, 3}.  0->1->2->0 is a cycle, and 3 is a cycle of length\
    \ 1.\n    This function outputs the number of such cycles.\n*/\nlong number_of_cycles(int[]\
    \ array) \n{\n    long n = array.length;\n    bool[] visited = new bool[n];\n\
    \    long answer = 0;\n    long i;\n    for (i = 0; i < n; i++) {\n        visited[i]\
    \ = false;\n    }\n    for (i = 0; i < n; i++) {\n        if (!visited[i]) {\n\
    \            visited[i] = true;\n            long j = array[i];\n           \n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp412ibfl0.d(67): Error: found `unittest` instead of statement

    /tmp/tmp412ibfl0.d(77): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp412ibfl0.d(77): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp412ibfl0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n <= 0)\
    \ return 0;\n    long half = (n - 1) / 2;\n    return half * (half + 1);\n}\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsdtnnzn9.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpsdtnnzn9.__unittest_L21_C1() [0x427a50]

    ??:? void tmpsdtnnzn9.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  auto l = new real[n];\n\
    \  auto r = new real[n];\n  for (long i = 0; i < n; i++)\n  {\n    l[i] = real(i+1);\n\
    \    r[i] = real(n - i);\n  }\n  sort(l);\n  sort(r);\n  lsort!((a, b) => a.y\
    \ < b.y)(r);\n  long r_last = 0;\n  long collisions = 0;\n  for (long i = 0; i\
    \ < n; i++)\n  {\n    while (r_last < n && r[r_last].y < l[i].y) \n    {\n   \
    \   r_last++;\n    }\n    collisions += r_last - i;\n  }\n  return collisions;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpklqoispx.d(24): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpklqoispx.d(25): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpklqoispx.d(26): Error: template instance `lsort!((a, b) => a.y < b.y)`
    template `lsort` is not defined

    /tmp/tmpklqoispx.d(31): Error: no property `y` for type `real`

    /tmp/tmpklqoispx.d(31): Error: no property `y` for type `real`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpklqoispx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // your code\
    \ goes here\n    return n * (n - 1) / 2;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp44msl3k1.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp44msl3k1.__unittest_L20_C1() [0x427a44]

    ??:? void tmp44msl3k1.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /*\n       \
    \ To find the number of collisions, we sort each set of cars.\n        We'll call\
    \ the set of cars moving left to right A, the set of cars moving right to left\
    \ B.\n        We keep a running sum of the number of collisions.  We go through\
    \ each car in A from back to front.\n        For each car in A, we look for the\
    \ first car in B that's farther to the right than the current car in A.\n    \
    \    When we find such a car, we know that the current car in A will collide with\
    \ it.\n        In addition, it will collide with all cars in B that precede it.\
    \  So, we add the number of preceding cars to the running sum.\n        We then\
    \ increment the pointer that points to B by 1.\n        We then move on to the\
    \ next car in A.  When we reach the end of A, we return the running sum.\n   \
    \ */\n    long[] A = new long[n];\n    long[] B = new long[n];\n    for (long\
    \ i = 0; i < n; i++) \n    {\n        A[i] = n - i;\n        B[i] = n - i;\n \
    \   }\n    std.sort(A);\n    std.sort(B);\n    long sum = 0;\n    long j = 0;\n\
    \    for (long i = 0; i < n; i++) \n    {\n        while (j < n && B[j] < A[i])\
    \ \n        {\n            j++;\n        }\n        sum += j;\n    }\n    return\
    \ sum;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqvol0to2.d(34): Error: undefined identifier `sort` in package `std`

    /tmp/tmpqvol0to2.d(35): Error: undefined identifier `sort` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqvol0to2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long c = 0;\n\
    \    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++)\
    \ {\n            c += 1;\n        }\n    }\n    return c;\n}\nunittest\n{\n  \
    \  alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwib8apl1.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmpwib8apl1.__unittest_L25_C1() [0x427a7c]

    ??:? void tmpwib8apl1.__modtest() [0x427b14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return (n*(n-1))/2;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkciueyfn.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpkciueyfn.__unittest_L19_C1() [0x427a44]

    ??:? void tmpkciueyfn.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    size_t r = n;\n\
    \    size_t l = n;\n    size_t result = 0;\n    while (l > 0) \n    {\n      \
    \  result += r;\n        l--;\n        r--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpilbpcsjl.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpilbpcsjl.__unittest_L28_C1() [0x427a60]

    ??:? void tmpilbpcsjl.__modtest() [0x427af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // Write your\
    \ code here\n    // To debug: std.error.writeln(\"Debug messages...\");\n    long\
    \ left[];\n    for (int i = 0; i < n; i++)\n    {\n        left.push_back(n -\
    \ i);\n    }\n    long right[];\n    for (int i = 0; i < n; i++)\n    {\n    \
    \    right.push_back(i + 1);\n    }\n    sort(left);\n    sort(right);\n    long\
    \ answer = 0;\n    int l = 0;\n    int r = 0;\n    while (l < n && r < n)\n  \
    \  {\n        if (left[l] < right[r])\n        {\n            l++;\n        }\n\
    \        else if (left[l] > right[r])\n        {\n            r++;\n        }\n\
    \        else\n        {\n            answer++;\n            l++;\n          \
    \  r++;\n        }\n    }\n    return answer;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxiamxbt2.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] left`

    /tmp/tmpxiamxbt2.d(24): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] right`

    /tmp/tmpxiamxbt2.d(22): Error: no property `push_back` for type `long[]`

    /tmp/tmpxiamxbt2.d(27): Error: no property `push_back` for type `long[]`

    /tmp/tmpxiamxbt2.d(29): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpxiamxbt2.d(30): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxiamxbt2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    static assert(n\
    \ >= 0);\n    return n * (n - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4jinf4ar.d(17): Error: variable `n` cannot be read at compile time

    /tmp/tmp4jinf4ar.d(17):        while evaluating: `static assert(n >= 0L)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4jinf4ar.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long car_count\
    \ = 0;\n    long[] left_to_right_cars = new long[n];\n    long[] right_to_left_cars\
    \ = new long[n];\n    for (long i = 0; i < n; i++) \n    {\n        left_to_right_cars[i]\
    \ = i + 1;\n        right_to_left_cars[i] = n - i;\n    }\n    for (long i = 0;\
    \ i < n; i++) \n    {\n        for (long j = 0; j < n; j++) \n        {\n    \
    \        if (left_to_right_cars[i] == right_to_left_cars[j]) \n            {\n\
    \                car_count++;\n            }\n        }\n    }\n    return car_count;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnk2ogiql.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x42814d]

    ??:? void tmpnk2ogiql.__unittest_L37_C1() [0x427e34]

    ??:? void tmpnk2ogiql.__modtest() [0x427ecc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c14b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42afde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430718]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4301f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42afb5]

    ??:? runModuleUnitTests [0x42bf21]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428610]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long cnt = 0;\n\
    \    n *= 2;\n    for (long i = 0; i < n; i++) \n    {\n        double speed;\n\
    \        speed = randf();\n        for (long j = i+1; j < n; j++) \n        {\n\
    \            if (speed > randf()) \n            {\n                cnt++;\n  \
    \          }\n        }\n    }\n    return cnt;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyl3ky4um.d(22): Error: undefined identifier `randf`

    /tmp/tmpyl3ky4um.d(25): Error: undefined identifier `randf`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyl3ky4um.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long leftToRight[n];\n\
    \    long rightToLeft[n];\n    long i = 0, j = 0, k = 0;\n    long leftToRightCount\
    \ = 0, rightToLeftCount = 0;\n    while (n-- > 0) {\n        cin >> leftToRight[i];\n\
    \        i++;\n    }\n    n = i;\n    i = 0;\n    while (n-- > 0) {\n        cin\
    \ >> rightToLeft[i];\n        i++;\n    }\n    n = i;\n    i = 0;\n    qsort(leftToRight,\
    \ 0, n - 1);\n    qsort(rightToLeft, 0, n - 1);\n    while (i < n && j < n) {\n\
    \        if (leftToRight[i] <= rightToLeft[j]) {\n            leftToRightCount++;\n\
    \            i++;\n        } else {\n            rightToLeftCount++;\n       \
    \     j++;\n        }\n    }\n    if (i == n)\n        rightToLeftCount += n -\
    \ j;\n    else\n        leftToRightCount += n - i;\n    k = leftToRightCount *\
    \ rightToLeftCount;\n    return k;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2j5jqq6h.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[n] leftToRight`

    /tmp/tmp2j5jqq6h.d(18): Deprecation: instead of C-style syntax, use D-style syntax
    `long[n] rightToLeft`

    /tmp/tmp2j5jqq6h.d(17): Error: variable `n` cannot be read at compile time

    /tmp/tmp2j5jqq6h.d(18): Error: variable `n` cannot be read at compile time

    /tmp/tmp2j5jqq6h.d(22): Error: undefined identifier `cin`, did you mean function
    `sin`?

    /tmp/tmp2j5jqq6h.d(28): Error: undefined identifier `cin`, did you mean function
    `sin`?

    /tmp/tmp2j5jqq6h.d(33): Error: undefined identifier `qsort`

    /tmp/tmp2j5jqq6h.d(34): Error: undefined identifier `qsort`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2j5jqq6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n*(n-1)/2;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbevt8cgy.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpbevt8cgy.__unittest_L19_C1() [0x427a44]

    ??:? void tmpbevt8cgy.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160755
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n\treturn ( n * (n\
    \ - 1) / 2 );\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n \
    \   assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwmf0fmae.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpwmf0fmae.__unittest_L19_C1() [0x427a44]

    ??:? void tmpwmf0fmae.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // Write your\
    \ code here\n    // To debug: write to stderr, e.g. cerr << \"Debug messages...\"\
    \ << endl;\n    long num_collisions = 0;\n    long left_car_index = 0;\n    long\
    \ right_car_index = n - 1;\n    while (left_car_index < n && right_car_index >=\
    \ 0) {\n        if (left_car_index == right_car_index) {\n            break;\n\
    \        }\n        if (left_car_index < right_car_index) {\n            left_car_index++;\n\
    \            num_collisions++;\n        } else {\n            right_car_index--;\n\
    \            num_collisions++;\n        }\n    }\n    return num_collisions;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj1a9u_wz.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmpj1a9u_wz.__unittest_L36_C1() [0x427a80]

    ??:? void tmpj1a9u_wz.__modtest() [0x427b18]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long[long] \
    \ nd;\n    long        num_collisions = 0;\n    long        idx;\n    long   \
    \     i;\n    long        j;\n    long        v;\n    long        num_already_registered\
    \ = 0;\n    long        prev_value = -1;\n    // invariant:  each element in 'nd'\
    \ is a tuple of the form {v,j}\n    // where 'v' is the position of the car and\
    \ 'j' is the index\n    // the car is the j-th car in its lane.\n    nd.rehash(\
    \ n );\n    foreach(i; 0 .. n) {\n        idx = (i * n) / (n+1);\n        nd[idx]\
    \ = {i,j};\n    }\n    // now we must print the cars starting in order of\n  \
    \  // position.\n    foreach(idx; nd.keys()) {\n        v = nd[idx][0];\n    \
    \    j = nd[idx][1];\n        if (prev_value != -1) {\n            num_collisions\
    \ += abs(prev_value - v);\n        }\n        if (prev_value != -1 && num_already_registered\
    \ < n) {\n            num_collisions += num_already_registered;\n        }\n \
    \       prev_value = v;\n        num_already_registered++;\n    }\n    return\
    \ num_collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpie2bnrjn.d(31): Error: found `}` when expecting `;` following statement

    /tmp/tmpie2bnrjn.d(31): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpie2bnrjn.d(35): Error: found `foreach` when expecting `;` following statement

    /tmp/tmpie2bnrjn.d(35): Error: found `;` when expecting `)`

    /tmp/tmpie2bnrjn.d(35): Error: found `nd` when expecting `;` following statement

    /tmp/tmpie2bnrjn.d(35): Error: found `)` when expecting `;` following statement

    /tmp/tmpie2bnrjn.d(49): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpie2bnrjn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    auto i=0, j=0,\
    \ count=0;\n    long left[], right[];\n    auto leftSize=0, rightSize=0;\n   \
    \ while(i<n)\n    {\n        auto dir=readInt();\n        auto speed=readInt();\n\
    \        if(dir==1)\n        {\n            left[leftSize++]=speed;\n        }\n\
    \        else\n        {\n            right[rightSize++]=speed;\n        }\n \
    \       i++;\n    }\n    sort(left);\n    sort(right);\n    i=0;\n    j=0;\n \
    \   while(i<leftSize && j<rightSize)\n    {\n        if(left[i]<right[j])\n  \
    \      {\n            count++;\n            i++;\n        }\n        else\n  \
    \      {\n            j++;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpghkcdl75.d(18): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] left`

    /tmp/tmpghkcdl75.d(18): Error: multiple declarations must have the same type,
    not `long[]` and `long[]`

    /tmp/tmpghkcdl75.d(18): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] right`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpghkcdl75.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  // First, we have\
    \ to have the two sets of car, one driving left and one driving right\n  // In\
    \ this function, the one driving left are called \"first\", and the one driving\
    \ right are called \"second\"\n  // As the name implies, \"first\" starts before\
    \ \"second\"\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmd0hl9j2.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmd0hl9j2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long ans = 0;\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkrkzrtro.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkrkzrtro.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  long i = 0;\n\
    \  long j = 0;\n  long coll = 0;\n  while (i < n && j < n) {\n    if (i == j)\
    \ {\n      coll += n-j;\n      i++;\n    } else if (i < j) {\n      i++;\n   \
    \ } else {\n      j++;\n    }\n  }\n  return coll;\n}\n/*\n    Now imagine an\
    \ arbitrary curve instead of a straight line.\n    The cars are still moving in\
    \ the same speed; all cars start\n    at the same time and location.  However,\
    \ the cars are not\n    infinitely long; they have a size.  As a result, the cars\n\
    \    will collide if the cars on a different direction touch\n    or interleave.\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7kb_5drf.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7kb_5drf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    // n == 0\n\
    \    // n == 1;\n    // n == 2;\n    // n == 3;\n    // ...\n    // n == 8;\n\
    \    // n == 9;\n    // n == 10;\n    // n == 11;\n    // n == 12;\n    // n ==\
    \ 13;\n    // n == 14;\n    // n == 15;\n    // ...\n    // n == 31;\n    // n\
    \ == 32;\n    // n == 33;\n    // n == 34;\n    // n == 35;\n    // n == 36;\n\
    \    // n == 37;\n    // n == 38;\n    // n == 39;\n    // n == 40;\n    // n\
    \ == 41;\n    // n == 42;\n    // n == 43;\n    // n == 44;\n    // n == 45;\n\
    \    // n == 46;\n    // n == 47;\n    // n == 48;\n    // n == 49;\n    // n\
    \ == 50;\n    // n == 51;\n    // n == 52;\n    // n == 53;\n    // n == 54;\n\
    \    // n == 55;\n    // n == 56;\n    // n == 57;\n    // n == 58;\n    // n\
    \ == 59;\n    // n == 60;\n    // n == 61;\n    // n == 62;\n    // n == 63;\n\
    \    // n == 64;\n    // n == 65;\n    // n == 66;\n    // n == 67;\n    // n\
    \ == 68;\n    // n == 69;\n    // n == 70;\n    // n == 71;\n    // n == 72;\n\
    \    // n == 73;\n    // n == 74;\n    // n == 75;\n    // n == 76;\n    // n\
    \ == 77;\n    // n == 78;\n    // n == 79;\n    // n == 80;\n    // n == 81;\n\
    \    // n == 82;\n    // n == 83;\n    // n == 84;\n    // n == 85;\n    // n\
    \ == 86;\n    // n == 87;\n    // n == 88;\n    // n == 89;\n    // n ==\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppihefwry.d(91): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppihefwry.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    \n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9kaqyqh0.d(15): Error: function `tmp9kaqyqh0.car_race_collision`
    has no `return` statement, but is expected to return a value of type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9kaqyqh0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160806
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    auto left_to_right\
    \ = new double[n];\n    auto right_to_left = new double[n];\n    foreach (i, ref\
    \ x; left_to_right)\n        x = (i + 1) * 10000000;\n    foreach (i, ref x; right_to_left)\n\
    \        x = n * 10000000 - (i + 1) * 10000000;\n    auto count = 0;\n    for\
    \ (auto i = 0; i < n; i++) \n    {\n        for (auto j = 0; j < n; j++) \n  \
    \      {\n            if (abs(left_to_right[i] - right_to_left[j]) < 1)\n    \
    \            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n \
    \   alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbdn_grl6.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x42881d]

    ??:? void tmpbdn_grl6.__unittest_L34_C1() [0x4284fc]

    ??:? void tmpbdn_grl6.__modtest() [0x4285a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b86a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430af5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fa4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430a81]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b841]

    ??:? runModuleUnitTests [0x42c7ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ce0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /*\n       \
    \ Your code goes here.\n    */\n    return (long)sqrt(n);\n}\nunittest\n{\n  \
    \  alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeibt92t3.d(20): Error: C style cast illegal, use `cast(long)sqrt(n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeibt92t3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result\
    \ = 0;\n    long a = 0;\n    while (a < n) {\n        long b = n;\n        while\
    \ (b > 0) {\n            if (a == b) {\n                ++result;\n          \
    \  }\n            b -= 1;\n        }\n        a += 1;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbpgnqj_l.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmpbpgnqj_l.__unittest_L31_C1() [0x427a80]

    ??:? void tmpbpgnqj_l.__modtest() [0x427b18]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n < 1)\n\
    \    {\n        return 0;\n    }\n    auto b1 = array(1 .. n);\n    auto b2 =\
    \ array(1 .. n);\n    for (int i = 0; i < n; i += 1)\n    {\n        b1[i] = i\
    \ + 1;\n        b2[i] = n - i;\n    }\n    long collisions = 0;\n    for (int\
    \ i = 0; i < n; i += 1)\n    {\n        for (int j = 0; j < n; j += 1)\n     \
    \   {\n            if (b1[i] == b2[j])\n            {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    return collisions;\n}\n/*\n    Suppose\
    \ that you're given a list of integers, where each integer represents an ID number.\n\
    \    Each ID number belongs to a particular person.  However, some of the given\
    \ integers are\n    duplicates, meaning they're ID numbers of the same person.\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1lmnq7y6.d(21): Error: found `..` when expecting `,`

    /tmp/tmp1lmnq7y6.d(22): Error: found `..` when expecting `,`

    /tmp/tmp1lmnq7y6.d(41): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1lmnq7y6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n     if (n < 2)\n\
    \        return 0;\n    else \n        return (n * (n - 1)) / 2;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyk7fiqsk.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpyk7fiqsk.__unittest_L22_C1() [0x427a54]

    ??:? void tmpyk7fiqsk.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long number_of_collisions;\n\
    \    /*\n        When cars collide, then their speeds are moving in the same direction\
    \ and\n        the car with the faster speed is going to reach the car with the\
    \ slower speed\n        exactly at the same time.\n        \n        (1) The time\
    \ it takes a car to reach the car in front is given by:\n            \n      \
    \      distance / speed\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxl0n1g8v.d(18): Error: unterminated /* */ comment

    /tmp/tmpxl0n1g8v.d(36): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxl0n1g8v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long res = 0;\n\
    \    for (long i = 0; i < n; i += 1) \n    {\n        for (long j = 0; j < n;\
    \ j += 1) \n        {\n            res += (i - j) < 0;\n        }\n    }\n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n \
    \   assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplqzjk9e9.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d9d]

    ??:? void tmplqzjk9e9.__unittest_L27_C1() [0x427a84]

    ??:? void tmplqzjk9e9.__modtest() [0x427b1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff98]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa75]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a92d]

    ??:? runModuleUnitTests [0x42b899]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpugqec3_u.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpugqec3_u.__unittest_L19_C1() [0x427a44]

    ??:? void tmpugqec3_u.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160754
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n == 0)\n\
    \        return 0;\n    else if (n == 1)\n        return 0;\n    else if (n ==\
    \ 2)\n        return 1;\n    else\n        return n + car_race_collision(n - 1);\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw6dbva2x.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d8d]

    ??:? void tmpw6dbva2x.__unittest_L26_C1() [0x427a78]

    ??:? void tmpw6dbva2x.__modtest() [0x427b10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a946]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff88]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a91d]

    ??:? runModuleUnitTests [0x42b889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i;\n  \
    \  long result = 0;\n    for (i = 0; i < n; i = i + 1) \n    {\n        result\
    \ = result + n - i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaocm6qnz.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d8d]

    ??:? void tmpaocm6qnz.__unittest_L25_C1() [0x427a78]

    ??:? void tmpaocm6qnz.__modtest() [0x427b10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a946]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff88]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a91d]

    ??:? runModuleUnitTests [0x42b889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    assert(n>=0);\n\
    \    long i;\n    long count = 0;\n    long j = 0;\n    for (i = 0; i < n; i++)\
    \ \n    {\n        long k = sqrt(i * i + j * j);\n        if (k >= i && k <= n\
    \ && k > j) \n        {\n            count++;\n        }\n        j++;\n    }\n\
    \    return count;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqp8p3bg7.d(23): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqp8p3bg7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    assert(n >=\
    \ 0);\n    return n*(n-1)/2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1rno6gvi.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e49]

    ??:? void tmp1rno6gvi.__unittest_L20_C1() [0x427a7c]

    ??:? void tmp1rno6gvi.__modtest() [0x427b14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb6f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa02]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb95]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430044]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb21]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9d9]

    ??:? runModuleUnitTests [0x42b945]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428298]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpugqec3_u.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpugqec3_u.__unittest_L19_C1() [0x427a44]

    ??:? void tmpugqec3_u.__modtest() [0x427adc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160754
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result\
    \ = 0;\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpylmsec_i.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpylmsec_i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long count =\
    \ 0;\n    foreach (i, car1; n) {\n        count += n - i - 1;\n    }\n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg4ejryni.d(18): Error: invalid `foreach` aggregate `n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg4ejryni.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    assert(n > 0);\n\
    \    return n*(n-1)/2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp62xqcz59.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e49]

    ??:? void tmp62xqcz59.__unittest_L20_C1() [0x427a7c]

    ??:? void tmp62xqcz59.__modtest() [0x427b14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb6f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa02]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb95]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430044]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb21]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9d9]

    ??:? runModuleUnitTests [0x42b945]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428298]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660160809
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n <= 0)\n\
    \        return 0;\n    long res = 0;\n    long[] left = new long[n];\n    long[]\
    \ right = new long[n];\n    long i = 0;\n    while (i < n) \n    {\n        left[i]\
    \ = i * (n - i);\n        right[i] = left[i];\n        ++i;\n    }\n    i = 0;\n\
    \    while (i < n) \n    {\n        res += left[i] * right[i];\n        ++i;\n\
    \    }\n    return res;\n}\nstatic assert(car_race_collision(0) == 0);\nstatic\
    \ assert(car_race_collision(1) == 0);\nstatic assert(car_race_collision(2) ==\
    \ 1);\nstatic assert(car_race_collision(3) == 5);\nstatic assert(car_race_collision(4)\
    \ == 14);\nstatic assert(car_race_collision(5) == 30);\nstatic assert(car_race_collision(6)\
    \ == 55);\nstatic assert(car_race_collision(7) == 91);\nstatic assert(car_race_collision(8)\
    \ == 140);\nstatic assert(car_race_collision(9) == 204);\nstatic assert(car_race_collision(10)\
    \ == 285);\nstatic assert(car_race_collision(11) == 385);\nstatic assert(car_race_collision(12)\
    \ == 506);\nstatic assert(car_race_collision(13) == 650);\nstatic assert(car_race_collision(14)\
    \ == 819);\nstatic assert(car_race_collision(15) == 1015);\nstatic assert(car_race_collision(16)\
    \ == 1240);\nstatic assert(car_race_collision(17) == 1496);\nstatic assert(car_race_collision(18)\
    \ == 1785);\nstatic assert(car_race_collision(19) == 2109);\nstatic assert(car_race_collision(20)\
    \ == 2470);\nstatic assert(car_race_collision(21) == 2870);\nstatic assert(car_race_coll\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8jrl5gs9.d(60): Error: found `unittest` when expecting `)`

    /tmp/tmp8jrl5gs9.d(61): Error: found `{` when expecting `;`

    /tmp/tmp8jrl5gs9.d(64): Error: declaration expected, not `assert`

    /tmp/tmp8jrl5gs9.d(65): Error: declaration expected, not `assert`

    /tmp/tmp8jrl5gs9.d(66): Error: declaration expected, not `assert`

    /tmp/tmp8jrl5gs9.d(67): Error: declaration expected, not `assert`

    /tmp/tmp8jrl5gs9.d(68): Error: declaration expected, not `assert`

    /tmp/tmp8jrl5gs9.d(69): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8jrl5gs9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660160808
