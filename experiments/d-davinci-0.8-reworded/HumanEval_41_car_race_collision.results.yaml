name: HumanEval_41_car_race_collision
language: d
results:
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long ret = 0;\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpapsi141c.d(24): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d45]\\n??:? void tmpapsi141c.__unittest_L20_C1()\
    \ [0x427a30]\\n??:? void tmpapsi141c.__modtest() [0x427ac8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba6b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a8fe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fa91]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff40]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa1d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8d5]\\n??:? runModuleUnitTests [0x42b841]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428194]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42811b]\\n??:? _d_run_main [0x428086]\\n??:? main [0x427adb]\\\
    n??:? __libc_start_main [0xfe744554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    long index1\
    \ = 0;\n    long index2 = n-1;\n    long count = 0;\n    while (index1 <= index2)\
    \ {\n        while (index1 <= index2 && ((index1 + index2) % 2 == 0)) {\n    \
    \        index1++;\n        }\n        while (index1 <= index2 && ((index1 + index2)\
    \ % 2 == 1)) {\n            index2--;\n        }\n        count++;\n    }\n  \
    \  return count;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp88rpa_ow.d(35): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dcd]\\n??:? void tmp88rpa_ow.__unittest_L31_C1()\
    \ [0x427ab8]\\n??:? void tmp88rpa_ow.__modtest() [0x427b50]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42baf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a986]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb19]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffc8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faa5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a95d]\\n??:? runModuleUnitTests [0x42b8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42821c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281a3]\\n??:? _d_run_main [0x42810e]\\n??:? main [0x427b63]\\\
    n??:? __libc_start_main [0xbd417554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result;\n\
    \    static if (n <= 0) {\n        result = 0;\n    } else {\n        result =\
    \ n * (n - 1) / 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9b3clh5m.d(18): Error: variable `n` cannot be read at compile\
    \ time\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9b3clh5m.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    //* Test cases\n\
    \    assert(car_race_collision(1) == 0);\n    assert(car_race_collision(2) ==\
    \ 1);\n    assert(car_race_collision(4) == 4);\n    assert(car_race_collision(10)\
    \ == 45);\n    assert(car_race_collision(100) == 4950);\n    return (n * (n -\
    \ 1)) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return (n*(n-1))/2;\n\
    }\n/*\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp460uwdym.d(19): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp460uwdym.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf1l3ilvl.d(23): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d5d]\\n??:? void tmpf1l3ilvl.__unittest_L19_C1()\
    \ [0x427a44]\\n??:? void tmpf1l3ilvl.__modtest() [0x427adc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a916]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faa9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8ed]\\n??:? runModuleUnitTests [0x42b859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428133]\\n??:? _d_run_main [0x42809e]\\n??:? main [0x427aef]\\\
    n??:? __libc_start_main [0x43f62554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long[] car1\
    \ = new long[n];\n    long[] car2 = new long[n];\n    long[] buffer = new long[n];\n\
    \    long[] buffer2 = new long[n];\n    long res;\n    long i, j, k;\n    long\
    \ index, index2;\n    long min, min_index;\n    for (i = 0; i < n; i++) {\n  \
    \      car1[i] = random();\n        car2[i] = random();\n    }\n    for (i = 0;\
    \ i < log(n) + 1; i++) {\n        for (j = 0; j < n; j++) {\n            buffer[j]\
    \ = j;\n        }\n        for (j = 0; j < n; j++) {\n            min = car1[j];\n\
    \            min_index = j;\n            for (k = j; k < n; k++) {\n         \
    \       if (car1[k] < min) {\n                    min = car1[k];\n           \
    \         min_index = k;\n                }\n            }\n            car1[min_index]\
    \ = car1[j];\n            car1[j] = min;\n            buffer2[j] = buffer[min_index];\n\
    \            buffer[min_index] = buffer[j];\n            buffer[j] = buffer2[j];\n\
    \        }\n        for (j = 0; j < n; j++) {\n            min = car2[j];\n  \
    \          min_index = j;\n            for (k = j; k < n; k++) {\n           \
    \     if (car2[k] < min) {\n                    min = car2[k];\n             \
    \       min_index = k;\n                }\n            }\n            car2[min_index]\
    \ = car2[j];\n            car2[j] = min;\n            buffer2[j] = buffer[min_index];\n\
    \            buffer[min_index] = buffer[j];\n            buffer[j] = buffer2[j];\n\
    \        }\n        index = 0;\n        index2 = 0;\n        while (index < n\
    \ && index2 < n) {\n            if (car1[index] < car2[index2]) {\n          \
    \      index\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprxfi1xsr.d(68): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmprxfi1xsr.d(78): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmprxfi1xsr.d(78): Error: found `End\
    \ of File` when expecting `}` following compound statement\\n/tmp/tmprxfi1xsr.d(78):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmprxfi1xsr.d(78): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprxfi1xsr.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n < 1) return\
    \ 0;\n    auto f = new real[n];\n    for (long i = 0; i < n; i++) f[i] = i;\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph3ctxnke.d(20): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph3ctxnke.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    uint nb_collisions\
    \ = 0;\n    if (n < 1) \n        return nb_collisions;\n    long rl_time = 0;\
    \  // time when the right to left car hit the starting point\n    long lr_time\
    \ = 2*n;  // time when the left to right car hit the end point\n    long* rl_speed\
    \ = new long[n];  // speed of the right to left cars\n    long* lr_speed = new\
    \ long[n];  // speed of the left to right cars\n    long* rl_pos   = new long[n];\
    \  // position of the right to left cars\n    long* lr_pos   = new long[n];  //\
    \ position of the left to right cars\n    for (uint i = 0; i < n; ++i) \n    {\n\
    \        rl_speed[i] = n-i;  // all right to left cars move at different speeds\n\
    \        lr_speed[i] = n-i;  // all left to right cars move at different speeds\n\
    \        rl_pos[i] = -(n-i);  // right to left cars start at different positions\n\
    \        lr_pos[i] = n-i;  // left to right cars start at different positions\n\
    \    }\n    // this is the time when the right to left and left to right cars\
    \ will hit each other\n    long collide_time = 2*n - sqrt(n);  \n    for (uint\
    \ i = 0; i < n; ++i) \n    {\n        long speed_rl = rl_speed[i];\n        long\
    \ speed_lr = lr_speed[i];\n        // this is the time when the right to left\
    \ car hit the starting point\n        rl_time = -rl_pos[i]/speed_rl;  \n     \
    \   // this is the time when the left to right car hit the end point\n       \
    \ lr_time = 2*n-lr_pos[i]/speed_lr;  \n        // if the left to right car hit\
    \ the end point before the right to left car\n        // hit the starting point,\
    \ it means that the collision has happened;\n        // we increment the number\
    \ of collisions\n        if (lr_time < r\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa2l3k_pd.d(47): Error: found `unittest` when expecting `)`\\\
    n/tmp/tmpa2l3k_pd.d(57): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpa2l3k_pd.d(57): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpa2l3k_pd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    int i;\n   \
    \ int j;\n    int collisions = 0;\n    for (i = 0; i < n; i++)\n    {\n      \
    \  for (j = i + 1; j < n; j++)\n        {\n            collisions++;\n       \
    \ }\n    }\n    return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpiusoth5t.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d95]\\n??:? void tmpiusoth5t.__unittest_L29_C1()\
    \ [0x427a7c]\\n??:? void tmpiusoth5t.__modtest() [0x427b14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42babb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a94e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fae1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff90]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa6d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a925]\\n??:? runModuleUnitTests [0x42b891]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281e4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42816b]\\n??:? _d_run_main [0x4280d6]\\n??:? main [0x427b27]\\\
    n??:? __libc_start_main [0xd2544554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collision_count\
    \ = 0;\n    collision_count = sqrt(n*n);\n    return collision_count;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwl111qcj.d(18): Error: `std.math.sqrt` called with argument types\
    \ `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(1848):\
    \     `std.math.sqrt(float x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(1854):\
    \     `std.math.sqrt(real x)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpwl111qcj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /* no cars =\
    \ no collisions */\n    if (n == 0) return 0;\n    \n    /*\n        so we can\
    \ think of it as having a set of n left-to-right cars and a set of n right-to-left\
    \ cars.\n        - the left-to-right cars have [1..n] indices, and the right-to-left\
    \ cars have [-n..-1] indices.\n        - we only have to care about the left-to-right\
    \ cars, since by symmetry the number of collisions is the same.\n        - every\
    \ left-to-right car is going to collide with at most one right-to-left car.\n\
    \        - the left-to-right car with index i will collide with the right-to-left\
    \ car with index -i if and only if\n            the right-to-left car with index\
    \ -i is in the range [i-a..i], where a is some positive constant.\n        - thus,\
    \ the number of collisions is equal to the number of indices i in [1..n] such\
    \ that the left-to-right car\n            with index i will collide with the right-to-left\
    \ car with index -i.\n        - now, to find out how many indices i in [1..n]\
    \ there are such that the right-to-left car with index -i is in the\n        \
    \    range [i-a..i], we can partition the set of those indices into two parts:\n\
    \            - the set of indices j in [1..n] such that the right-to-left car\
    \ with index -j is in the range [j-a..j].\n            - the set of indices j\
    \ in [1..n] such that the right-to-left car with index -j is not in the range\
    \ [j-a..j], but\n                the right-to-left car with index -(j+1) is in\
    \ the range [(j+1)-a..(j+1)].\n        - now, the number of collisions is equal\
    \ to the union of the two sets of indices.\n        - the number of collisions\
    \ is clearly not larger than the first set of indices.\n        - the number of\
    \ collisions is also not larger than the second set of indices.\n        - since\
    \ the number of collisions is clearly not larger than the first set of indices,\
    \ the number of collisions is\n\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqiofoh4f.d(20): Error: unterminated /* */ comment\\n/tmp/tmpqiofoh4f.d(49):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqiofoh4f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    auto left =\
    \ range(0, n);\n    auto right = array(left[n - 1 - i] for i in 0 .. n);\n   \
    \ auto left_pos = array(n - i - 1 for i in 0 .. n);\n    auto right_pos = array(i\
    \ for i in 0 .. n);\n    long collisions = 0;\n    for (; ; ) \n    {\n      \
    \  auto min_left = min(left_pos);\n        auto min_right = min(right_pos);\n\
    \        if (min_left >= min_right)\n            break;\n        collisions +=\
    \ n - max(left_pos);\n        left_pos[left_pos.find(min_left)] += 1;\n      \
    \  right_pos[right_pos.find(min_right)] += 1;\n    }\n    return collisions;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9gz69ans.d(18): Error: found `for` when expecting `,`\\n/tmp/tmp9gz69ans.d(18):\
    \ Error: found `..` when expecting `,`\\n/tmp/tmp9gz69ans.d(19): Error: found\
    \ `for` when expecting `,`\\n/tmp/tmp9gz69ans.d(19): Error: found `..` when expecting\
    \ `,`\\n/tmp/tmp9gz69ans.d(20): Error: found `for` when expecting `,`\\n/tmp/tmp9gz69ans.d(20):\
    \ Error: found `..` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp9gz69ans.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    /*\n    But\
    \ how do you find the number of collisions?\n    Lets say the cars on the left\
    \ and the cars on the right start\n    out in a certain order.  That is, we can\
    \ say that the starting position\n    for the cars is \n    Left:    A, B, C,\
    \ D\n    Right:   E, F, G, H\n    This is one possible starting arrangement. \
    \ There are 4! = 24 possible arrangements.\n    Now, lets say we have a collision.\
    \  This means that in the end:\n    Left:    A, C, D, B\n    Right:   E, G, H,\
    \ F\n    This is another possible starting arrangement.  There are 4! = 24 possible\
    \ arrangements.\n    So if we could enumerate all possible arrangements, then\
    \ we could just find the number of\n    arrangements that have at least one collision.\
    \  This is equivalent to finding the total number\n    of arrangements minus the\
    \ number of arrangements that do not have any collisions.\n    */\n    long num_collisions\
    \ = 0;\n    long all_arrangements = 0;\n    /*\n    Lets iterate over all of the\
    \ possible arrangements.  One way to do this is to use a recursive\n    algorithm.\
    \  One possible algorithm is as follows:\n    1.  We start with the cars on the\
    \ left and the cars on the right all in order.  E.g.,\n    Left:    A, B, C, D\n\
    \    Right:   E, F, G, H\n    2.  Then, we find the minimum position number p\
    \ such that either the car in position p on the left\n    or the car in position\
    \ p on the right is greater than the corresponding car on the other side.  E.g.,\n\
    \    Left:    A, B, C, D\n    Right:   E, F, G, H\n    Here, p = 2.  The car in\
    \ position 2 on the left is C, which is greater than the car in position 2 on\
    \ the right, which is F.\n    (The car in position 2 on the right is F, which\
    \ is smaller than the car in position 2 on the left, which is C.)\n    3.  Then,\
    \ we swap the cars at positions p on the left and p on the right, as well as all\
    \ of the cars in positions greater than p\nunittest\n{\n    alias candidate =\
    \ car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphshfu5mx.d(35): Error: unterminated /* */ comment\\n/tmp/tmphshfu5mx.d(58):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphshfu5mx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    int[] c1 = new\
    \ int[n];\n    int[] c2 = new int[n];\n    for (int i = 0; i < n; i++) \n    {\n\
    \        c1[i] = (int)rand(1, n*2);\n        c2[i] = (int)rand(1, n*2);\n    }\n\
    \    sort(c1);\n    sort(c2);\n    int j = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < n; i++) \n    {\n        if (c1[i] < c2[j]) \n        {\n       \
    \     count++;\n        }\n        else \n        {\n            j++;\n      \
    \  }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkda0jn4c.d(21): Error: C style cast illegal, use `cast(int)rand(1,\
    \ n * 2)`\\n/tmp/tmpkda0jn4c.d(22): Error: C style cast illegal, use `cast(int)rand(1,\
    \ n * 2)`\\n/tmp/tmpkda0jn4c.d(41): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkda0jn4c.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long sum = 0;\n\
    \    foreach (i; 0 .. n) {\n        sum += i;\n    }\n    return sum;\n}\n/*\n\
    \    Imagine a road that's a perfectly straight infinitely long line.\n    n cars\
    \ are driving left to right;  simultaneously, a different set of n cars\n    are\
    \ driving right to left.   The two sets of cars start out being very far from\n\
    \    each other.  All cars move in the same speed.  Two cars are said to collide\n\
    \    when a car that's moving left to right hits a car that's moving right to\
    \ left.\n    However, the cars are infinitely sturdy and strong; as a result,\
    \ they continue moving\n    in their trajectory as if they did not collide.\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5udhsz9m.d(23): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5udhsz9m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxbq_um6t.d(23): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d5d]\\n??:? void tmpxbq_um6t.__unittest_L19_C1()\
    \ [0x427a44]\\n??:? void tmpxbq_um6t.__modtest() [0x427adc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a916]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faa9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8ed]\\n??:? runModuleUnitTests [0x42b859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428133]\\n??:? _d_run_main [0x42809e]\\n??:? main [0x427aef]\\\
    n??:? __libc_start_main [0xa231e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    import std.math;\n\
    \    const long infinity = 46340;\n    const int steps = 100;\n    int carsLeft[infinity];\n\
    \    int carsRight[infinity];\n    for (int i = 0; i < infinity; i++) {\n    \
    \    carsLeft[i] = 0;\n        carsRight[i] = 0;\n    }\n    foreach (i; 0 ..\
    \ n) {\n        carsLeft[i] = infinity/n * i;\n        carsRight[i] = infinity\
    \ - infinity/n * i;\n    }\n    int collisions = 0;\n    for (int i = 0; i < steps;\
    \ i++) {\n        foreach (j; 0 .. n) {\n            if (carsLeft[j] == infinity)\n\
    \                continue;\n            if (carsLeft[j] > infinity - infinity/n\
    \ * i)\n                carsLeft[j] -= infinity/n;\n            else if (carsLeft[j]\
    \ < infinity/n * i)\n                carsLeft[j] += infinity/n;\n            else\
    \ {\n                foreach (k; 0 .. n) {\n                    if (carsRight[k]\
    \ == infinity)\n                        continue;\n                    if (carsRight[k]\
    \ > infinity - infinity/n * i)\n                        carsRight[k] -= infinity/n;\n\
    \                    else if (carsRight[k] < infinity/n * i)\n               \
    \         carsRight[k] += infinity/n;\n                    else {\n          \
    \              if (carsLeft[j] == carsRight[k]) {\n                          \
    \  collisions++;\n                            carsLeft[j] = infinity;\n      \
    \                      carsRight[k] = infinity;\n                        }\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8q6_8il6.d(20): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `int[infinity] carsLeft`\\n/tmp/tmp8q6_8il6.d(21): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `int[infinity] carsRight`\\n/tmp/tmp8q6_8il6.d(20):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `int[infinity] carsLeft`\\\
    n/tmp/tmp8q6_8il6.d(21): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `int[infinity] carsRight`\\ncore.exception.AssertError@/tmp/tmp8q6_8il6.d(64):\
    \ unittest failure\\n----------------\\n??:? _d_unittestp [0x4282bd]\\n??:? void\
    \ tmp8q6_8il6.__unittest_L60_C1() [0x427fa8]\\n??:? void tmp8q6_8il6.__modtest()\
    \ [0x428040]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c057]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aeea]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43007d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43052c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430009]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aec1]\\n??:? runModuleUnitTests [0x42be2d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428780]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428707]\\n??:? _d_run_main [0x428672]\\n??:? main [0x428053]\\\
    n??:? __libc_start_main [0x7e80d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i;\n  \
    \  long total = 0;\n    long left_to_right[n];\n    long right_to_left[n];\n \
    \   for (i = 0; i < n; i++) \n    {\n        left_to_right[i] = i;\n        right_to_left[i]\
    \ = -(i + 1);\n    }\n    for (i = 0; i < n; i++) \n    {\n        total += left_to_right[i]\
    \ + right_to_left[i];\n    }\n    return total;\n}\n/*\n    What is the time complexity\
    \ of this algorithm?\n    The first loop will run n times.\n    The second loop\
    \ will run n times.\n    No other operations other than adding.\n    Therefore,\
    \ this is an O(n) algorithm.\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6iqke301.d(19): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[n] left_to_right`\\n/tmp/tmp6iqke301.d(20): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[n] right_to_left`\\n/tmp/tmp6iqke301.d(32):\
    \ Error: unterminated /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp6iqke301.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    //assert(n >\
    \ 0);\n    long *arr = new long[n];\n    for (long i = 0; i < n; i++)\n      \
    \  arr[i] = i;\n    shuffle(arr, arr + n);\n    long count = 0;\n    for (long\
    \ i = 0; i < n; i++)\n        for (long j = i + 1; j < n; j++)\n            if\
    \ (arr[i] > arr[j])\n                count++;\n    return count;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn5fd5t89.d(18): Error: cannot implicitly convert expression `new\
    \ long[](cast(ulong)n)` of type `long[]` to `long*`\\n/tmp/tmpn5fd5t89.d(21):\
    \ Error: undefined identifier `shuffle`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpn5fd5t89.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
