name: HumanEval_111_histogram
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nGiven a string representing a\
  \ space separated lowercase letters, return an associative array\n    of the letter\
  \ with the most repetition and containing the corresponding count.\n    If several\
  \ letters have the same occurrence, return all of them.\n    \n    Example:\n  \
  \  >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n  \
  \  >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
  a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\"\
  )\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___\n\n  \
  \  \n*/\nNullable!(long[string]) histogram(string test) \n"
tests: "unittest\n{\n    alias candidate = histogram;\n\n{\n        auto result =\
  \ candidate(\"a b b a\");\n        assert(!result.isNull && result.get == [\"a\"\
  : 2L, \"b\": 2L]);\n}\n\n{\n        auto result = candidate(\"a b c a b\");\n  \
  \      assert(!result.isNull && result.get == [\"a\": 2L, \"b\": 2L]);\n}\n\n{\n\
  \        auto result = candidate(\"a b c d g\");\n        assert(!result.isNull\
  \ && result.get == [\"a\": 1L, \"b\": 1L, \"c\": 1L, \"d\": 1L, \"g\": 1L]);\n}\n\
  \n{\n        auto result = candidate(\"r t g\");\n        assert(!result.isNull\
  \ && result.get == [\"r\": 1L, \"t\": 1L, \"g\": 1L]);\n}\n\n{\n        auto result\
  \ = candidate(\"b b b b a\");\n        assert(!result.isNull && result.get == [\"\
  b\": 4L]);\n}\n\n{\n        auto result = candidate(\"r t g\");\n        assert(!result.isNull\
  \ && result.get == [\"r\": 1L, \"t\": 1L, \"g\": 1L]);\n}\n\n{\n        auto result\
  \ = candidate(\"\");\n        assert(result.isNull);\n}\n\n{\n        auto result\
  \ = candidate(\"a\");\n        assert(!result.isNull && result.get == [\"a\": 1L]);\n\
  }\n\n}\nvoid main(){}"
completions: ["{\n    // check length of string\n    if (test.length < 1) \n    {\n\
    \        return null;\n    }\n    // store the letters and their count in an associative\
    \ array\n    auto dict = test.split(\" \").assocArray;\n    // store the letters\
    \ with highest count\n    auto highest_letters = new Nullable!(string[])(null);\n\
    \    // store the highest count\n    auto highest_count = 0L;\n    foreach (word;\
    \ dict) \n    {\n        // if count is greater than highest update highest\n\
    \        if (word.value > highest_count) \n        {\n            highest_count\
    \ = word.value;\n            highest_letters = new Nullable!(string[])([word.key]);\n\
    \        }\n        // if count is equal to highest add to highest\n        else\
    \ if (word.value == highest_count) \n        {\n            highest_letters.value\
    \ ~= word.key;\n        }\n    }\n    // create a return dict\n    auto return_dict\
    \ = new Nullable!(long[string])(null);\n    // if highest_letters is null return\
    \ null\n    if (highest_letters is null) \n    {\n        return return_dict;\n\
    \    }\n    // copy the highest_letters into return_dict\n    foreach (letter;\
    \ highest_letters.value) \n    {\n        return_dict.value[letter] = highest_count;\n\
    \    }\n    return return_dict;\n}", "{\n\tauto words = test.split();\n\tlong[string]\
    \ counter;\n\tforeach(word; words) {\n\t\t++counter[word];\n\t}\n\tlong max =\
    \ -1;\n\tforeach(key, value; counter) {\n\t\tif(value > max) max = value;\n\t\
    }\n\tlong[string] result;\n\tforeach(key, value; counter) {\n\t\tif(value == max)\
    \ result[key] = value;\n\t}\n\tif(result.empty) {\n\t\treturn null;\n\t}\n\treturn\
    \ result;\n}", "{\n    Nullable!(long[string]) result;\n    /*\n    1)\n    //\
    \ way too much work\n    //std.regex.split(test, \"\\\\s\") - splits by any whitespace\
    \ character, as mentioned in the end of the doc page:\n    //\"For example, if\
    \ the whitespace characters in the input string are a tab character, followed\
    \ by a newline character, followed by the letter 'c', the array returned by the\
    \ Split method contains three elements: two empty strings, and the letter 'c'.\"\
    \n    // thus the order of the elements in the result array will be the same as\
    \ the order in which they were extracted from the input string\n    // this way\
    \ we can map the position in the array with the letter\n    if (test == \"\")\n\
    \    {\n        result = ___null_dict___;\n    } else\n    {\n        auto splitted\
    \ = std.regex.split(test, \"\\\\s\");\n        // result = std.array.count(splitted);\n\
    \        // auto aaa = to!(string[])(splitted);\n        // auto idx = std.array.position(splitted,\
    \ \"a\");\n        // auto aaa = to!(string[])splitted;\n        // auto idx =\
    \ std.array.position(splitted, \"a\");\n        // auto test = std.algorithm.find(splitted,\
    \ \"a\");\n        // writeln(test.current);\n        // auto test = std.array.find(splitted,\
    \ \"a\");\n        // writeln(test);\n        // auto test = std.array.find(splitted,\
    \ \"b\");\n        // writeln(test);\n        // auto test = std.array.find(splitted,\
    \ \"c\");\n        // writeln(test);\n        // TODO: sort the resulting array\
    \ so the most repeating letter comes first\n        // TODO: extract the letter\
    \ with the most repetitions\n        // TODO: count the number of times the letter\
    \ occurs in the original string\n        // TODO: return the resulting associative\
    \ array\n    }\n    */\n    /*\n    2)\n    // must be in a loop\n    if (test\
    \ == \"\")\n    {\n        result = ___null_dict___;\n    } else\n    {\n", "{\n\
    \    enum letters = test.split(' ');\n    if (letters.length == 0) \n    {\n \
    \       return ___null_dict___;\n    }", "    pure \n{\n    import std.algorithm.comparison\
    \ : max;\n    auto res = test.split(' ');\n    auto len = res.length;\n    if\
    \ (len == 0) return null;\n    long[string] ret;\n    for (auto i = 0; i < len;\
    \ i++)\n    {\n        if (ret.find(res[i]) != null) ret[res[i]]++;\n        else\
    \ ret[res[i]] = 1;\n    }\n    auto max = ret.values.max;\n    auto key = ret.keys.filter!(t\
    \ => ret[t] == max);\n    ret = ret.retain!(k => key.canFind(k));\n    return\
    \ ret;\n}\n/*\ngiven an array of strings and an integer, determine the difference\
    \ between \nthe maximum and minimum length of the strings.", "{\n    import std.algorithm;\n\
    \    import std.conv;\n    import std.exception;\n    Nullable!(long[string])\
    \ ret;\n    if(!test.length)\n        return ret;\n    long[string] arr;\n   \
    \ foreach(i,v;test.split(\" \"))\n    {\n        if(arr.count(v)==0)\n       \
    \     arr[v]=1;\n        else\n            arr[v]++;\n    }\n    long max=arr.maxElement!((a,b)=>a>b).value;\n\
    \    ret=new long[string];\n    foreach(i,v;arr)\n    {\n        if(v.value==max)\n\
    \            ret.get.insert(v.key,v.value);\n    }\n    return ret;\n}\n/*\nGiven\
    \ a string representing a space separated lowercase letters, return an associative\
    \ array\n    of the letter with the most repetition and containing the corresponding\
    \ count.\n    If several letters have the same occurrence, return all of them.\n\
    \    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L,\
    \ \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\":\
    \ 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n\
    \    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\
    \")\n    ___null_dict___", "{\n    auto testTot = test.length;\n    if (testTot\
    \ == 0) return null;\n    auto words = test.split(\" \");\n    auto wordsTot =\
    \ words.length;\n    int[] ocurr = new int[](wordsTot);\n    int most = 0;\n \
    \   foreach (i, word; words) \n    {\n        if (word !in ocurr) \n        {\n\
    \            ocurr[word] = words.count(word);\n            if (ocurr[word] > most)\
    \ \n            {\n                most = ocurr[word];\n            }\n      \
    \  }\n    }\n    auto ret = new Nullable!(long[string])();\n    auto ret2 = new\
    \ long[string]();\n    foreach (word, n; ocurr) \n    {\n        if (n == most)\
    \ \n        {\n            ret2[word] = n;\n        }\n    }\n    ret.data = ret2;\n\
    \    return ret;\n}\n/*\nThe previous function, even if is working, can be improved\
    \ by not adding a new key in the associative array\n    if it already exists.\n\
    \    If a key is not in the associative array, you can add a new key and its value\
    \ with `[] = value`.\n    If a key is already in the associative array, you can\
    \ update its value with `[] = newValue`.\n    You can also get the value of a\
    \ key, with `[]`.\n    You can have a look at the following example to get the\
    \ idea:\n    \n    >>> auto a = [\"a\": 0L, \"b\": 1L];\n    >>> a[\"a\"] = 10L;\n\
    \    >>> a[\"b\"] = 20L;\n    >>> a[\"c\"] = 30L;\n    >>> a\n    [\"a\": 10L,\
    \ \"b\": 20L, \"c\": 30L]\n    >>> a[\"d\"] = 40L;\n    >>> a\n    [\"a\": 10L,\
    \ \"b\": 20L, \"c\": 30L, \"d\": 40L]\n    >>> a[\"d\"]\n    40L\n    >>> a[\"\
    e\"]\n    ___null_dict___\n    >>> a[\"e\"] = 50L", "{\n    import std.algorithm.iteration\
    \ : maxElement;\n    return test.words\n        .groupBy!((a) => a)\n        .map!((a)\
    \ => tuple(a[0], a[1].length))\n        .tupleof\n        .maxElement!((a, b)\
    \ => a[1] < b[1])\n        .filter!((a) => a[1] == maxElement!((a, b) => a[1]\
    \ < b[1]).tupleof[1])\n        .assocArray\n        .nullable;\n}", "{\n    import\
    \ std.algorithm : max;\n    import std.algorithm : fill;\n    import std.algorithm\
    \ : copy;\n    import std.algorithm : count;\n    import std.range : map;\n  \
    \  import std.array : array;\n    import std.string : split;\n    import std.range\
    \ : isEmpty;\n    long[] histo = new long[test.length];\n    histo.fill(0);\n\
    \    test.split(\" \").each!(s => \n    {\n        histo[s[0]]++;\n    });\n \
    \   long max = histo.max();\n    if (max == 0)\n    {\n        return null;\n\
    \    }\n    auto result = new long[char]().init;\n    foreach (i, c; histo)\n\
    \    {\n        if (c == max)\n        {\n            result[char(i)] = c;\n \
    \       }\n    }\n    return result;\n}", "{\n    //see if there are any letters\n\
    \    if(test.length == 0)\n    {\n        return null;\n    }\n    //tokenize\
    \ the string\n    auto tokens = test.split;\n    //get an array of the set of\
    \ letters\n    auto set_tokens = tokens.unique;\n    //initialize a dictionary\n\
    \    auto map = typeof(return)();\n    //iterate over the set of letters\n   \
    \ foreach(letter; set_tokens)\n    {\n        //set the dictionary value\n   \
    \     map[letter] = tokens.count(letter);\n    }\n    //get the maximum value\
    \ for this dictionary\n    auto max = map.values.max;\n    //get the keys that\
    \ have that value\n    auto keys = map.keys.filter!(l => map[l] == max);\n   \
    \ //declare return variable\n    Nullable!(long[string]) result;\n    //get the\
    \ resulting dictionary\n    foreach(key; keys)\n    {\n        result[key] = map[key];\n\
    \    }\n    //return\n    return result;\n}\n/*\n    >>> histogram(\"a b c\")\n\
    \    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b b a\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\")\n   \
    \ [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n    [\"b\"\
    : 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___\n*/", "{\n    if\
    \ (test.empty) \n    {\n        return null;\n    }\n    //split the string\n\
    \    string[] splitArray = test.split(\" \");\n    long[string] full = [splitArray[0]:\
    \ 1L];", "{\n    import std.array;\n    import std.conv;\n    import std.range;\n\
    \    import std.string;\n    import std.traits;\n    import std.typecons;\n  \
    \  import std.algorithm;\n    import std.math;\n    import std.typecons;\n   \
    \ import std.stdio;\n    import std.algorithm : max;\n    Nullable!(long[string])\
    \ histo(string test) \n    {\n        return test.split.groupBy.values.max;\n\
    \    }\n    if (test.empty) \n    {\n        return ___null_dict___;\n    }\n\
    \    else \n    {\n        return histo(test);\n    }\n}\n/*\nReturn the average\
    \ of a given slice of numbers.\n    If the slice is empty, return a Nullable!T\n\
    \    where T is the type of the elements in the array.\n    \n    Example:\n \
    \   >>> mean([1, 2, 3])\n    2.0\n    >>> mean([])\n    ___null___\n    \n*/",
  "{\n    Nullable!(long[string]) result;\n    if (test.length) \n    {\n        auto\
    \ test_array = test.split(\" \");\n        result = new long[string];\n      \
    \  foreach (char; test_array)\n        {\n            if (!result.isNull)\n  \
    \          {\n                result[char]++;\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    auto parts = test.split;\n    if (parts.length\
    \ == 0)\n        return null;\n    auto ret = to(long[string]).init;\n    foreach\
    \ (t; parts)\n    {\n        if (t !in ret)\n            ret[t] = 1;\n       \
    \ else\n            ret[t] += 1;\n    }\n    //get the max element\n    int max\
    \ = ret.values.max;\n    ret.removeIf!(k, v => v != max);\n    return ret;\n}\n\
    static assert(histogram(\"a b c\") == [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable);\n\
    static assert(histogram(\"a b b a\") == [\"a\": 2L, \"b\": 2L].nullable);\nstatic\
    \ assert(histogram(\"a b c a b\") == [\"a\": 2L, \"b\": 2L].nullable);\nstatic\
    \ assert(histogram(\"b b b b a\") == [\"b\": 4L].nullable);\nstatic assert(histogram(\"\
    \") == null);\nstatic assert(histogram(\"a a b b b\") == [\"b\": 3L].nullable);\n\
    \ \n \n \n /*\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    ", "{\n    import std.traits;\n    import std.algorithm;\n    import\
    \ std.algorithm.comparison;\n    import std.array;\n    import std.conv;\n   \
    \ import std.range;\n    import std.stdio;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.container;\n    import std.math;\n    import std.algorithm.iteration;\n\
    \    import std.format;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.bigint;\n    import std.bigint;\n  \
    \  import std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import\
    \ std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n\
    \    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import\
    \ std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n\
    \    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import\
    \ std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n\
    \    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import\
    \ std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n\
    \    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import\
    \ std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n\
    \    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import\
    \ std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n\
    \    import std.bigint;\n    import std.bigint;\n    import std.bigint;\n    import\
    \ std.big", "{\n    long[string] result = to!(long[string])(null);\n    string[]\
    \ list = test.split(\" \");\n    if (list.length == 0) return null;\n    foreach\
    \ (element; list)\n    {\n        if (result.contains(element)) result[element]\
    \ += 1;\n        else result[element] = 1;\n    }\n    long max = maxElement(result.values);\n\
    \    foreach (key, value; result)\n    {\n        if (value != max) result.remove(key);\n\
    \    }\n    return result;\n}", "{\n    // TODO: implement this function", "{\n\
    \tif (test.empty) \n\t{\n\t\treturn null;\n\t}\n\timmutable charSeparator = '\
    \ ';\n\tauto words = test.split(charSeparator);\n\tassert(words.length > 0);\n\
    \tauto strHistogram = new long[string];\n\tauto wordCounter = new long[string];\n\
    \t\n\tforeach(w; words)\n\t{\n\t\tauto i = wordCounter[w];\n\t\twordCounter[w]\
    \ = i + 1;\n\t\tstrHistogram[w] = i + 1;\n\t}\n\t\n\tauto max = wordCounter.values.max;\n\
    \tauto ret = new long[string];\n\t\n\tforeach(k,v; strHistogram)\n\t{\n\t\tif\
    \ (v == max)\n\t\t{\n\t\t\tret[k] = v;\n\t\t}\n\t}\n\t\n\tif (ret.length == 0)\n\
    \t{\n\t\treturn null;\n\t}\n\t\n\treturn ret;\n}", "{\n    size_t letterCount\
    \ = test.length;\n    Nullable!(long[string])letters = Nullable!(long[string])();\n\
    \    Nullable!(long[string])results = Nullable!(long[string])();\n    if (letterCount\
    \ > 0) \n    {\n        long[string] letters = new long[string](min(letterCount,\
    \ 256L));\n        foreach (index, letter; test) \n        {\n            ++letters[letter];\n\
    \        }\n        size_t maxValue = 0;\n        foreach (index, letter; test)\
    \ \n        {\n            if (letters[letter] > maxValue) \n            {\n \
    \               maxValue = letters[letter];\n            }\n        }\n      \
    \  foreach (index, letter; test) \n        {\n            if (letters[letter]\
    \ == maxValue) \n            {\n                results[letter] = maxValue;\n\
    \            }\n        }\n    }\n    return results;\n}", "{\n    Nullable!(long[string])\
    \ res = [].assumeUnique;\n    long max_num = 0;\n    foreach(i, c; test) \n  \
    \  {\n        ++res[c];\n        if(res[c] > max_num) \n        {\n          \
    \  max_num = res[c];\n        }\n    }\n    return filter!(x => x.value == max_num)(res).map!(x\
    \ => x.key).nullable;\n}", "in\n{\n    assert( test.all!\"a in 'a'..'z'\" );\n\
    }\nbody\n{\n    Nullable!(long[string]) r = null;\n    long max = 0;\n    immutable\
    \ long[string] hist = test.split(' ').histogram;\n    foreach( v; hist.values\
    \ )\n    {\n        max = max(v, max);\n    }\n    return hist.retrieve(max);\n\
    }", "{\n    struct histo\n    {\n        string[] keys;\n        size_t[] counts;\n\
    \    }\n    histo h;\n    if(test.length == 0)\n        return null;\n    size_t\
    \ l = test.length;\n    auto splits = test.split(\" \");\n    foreach(j, k; splits)\n\
    \    {\n        bool not_found = true;\n        foreach(i, ch; h.keys)\n     \
    \   {\n            if(ch == k)\n            {\n                not_found = false;\n\
    \                h.counts[i]++;\n            }\n        }\n        if(not_found)\n\
    \        {\n            h.keys ~= k;\n            h.counts ~= 1;\n        }\n\
    \    }\n    size_t max_index = 0;\n    size_t max_count = 0;\n    foreach(i, ch;\
    \ h.keys)\n    {\n        if(h.counts[i] > max_count)\n        {\n           \
    \ max_count = h.counts[i];\n            max_index = i;\n        }\n    }\n   \
    \ long[string] ret;\n    foreach(i, ch; h.keys)\n    {\n        if(h.counts[i]\
    \ == max_count)\n            ret[ch] = max_count;\n    }\n    return ret;\n}",
  "{\n\tlong[string] result = null;\n\tif(test.empty)\n\t{\n\t\treturn result;\n\t\
    }\n\t\n\tresult = new long[string];\n\tauto s = test.split(\" \");\n\tfor(size_t\
    \ i = 0; i < s.length; i++)\n\t{\n\t\tresult[s[i]]++;\n\t}\n\t\n\tlong max = 0;\n\
    \tfor(auto key = result.byKey(); !key.empty; key.popFront())\n\t{\n\t\tmax = max(max,\
    \ key.front.value);\n\t}\n\t\n\tfor(auto key = result.byKey(); !key.empty; key.popFront())\n\
    \t{\n\t\tif(key.front.value != max)\n\t\t{\n\t\t\tresult.remove(key.front.key);\n\
    \t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    long[string] result;\n    long maxCount\
    \ = 0;\n    string[] keys;\n    foreach(c; test.split)\n    {\n        if(result.contains(c))\n\
    \        {\n            result[c] += 1;\n        }\n        else\n        {\n\
    \            result[c] = 1;\n        }\n        if(result[c] > maxCount)\n   \
    \     {\n            maxCount = result[c];\n            keys = [c];\n        }\n\
    \        else if(result[c] == maxCount)\n        {\n            keys ~= c;\n \
    \       }\n    }\n    if(keys.length == 0)\n    {\n        return null;\n    }\n\
    \    long[string] output;\n    foreach(k; keys)\n    {\n        output[k] = result[k];\n\
    \    }\n    return output;\n}", "{\n    Nullable!(long[string]) result = typeof(result).init;\n\
    \    if (test.length == 0) return result;\n    string[] letters = test.split();\n\
    \    long[] counts = new long[letters.length];\n    for (int i = 0; i < letters.length;\
    \ i++)\n    {\n        for (int j = 0; j < letters.length; j++)\n        {\n \
    \           if (letters[i] == letters[j])\n            {\n                counts[i]++;\n\
    \            }\n        }\n    }\n    long max = maxElement(counts);\n    result.assign(maxElement,\
    \ counts);\n    return result;\n}", "{\n    \n    import std.algorithm;\n    import\
    \ std.algorithm.comparison;\n    import std.conv;\n    import std.range;\n   \
    \ import std.typecons;\n    import std.container;\n    import std.string;\n  \
    \  import std.array;\n    import std.bigint;\n    import std.math;\n    import\
    \ std.meta;\n    import std.bitmanip;\n    import std.range;\n    import std.conv;\n\
    \    import std.exception;\n    import std.traits;\n    import std.stdio;\n  \
    \  import std.math;\n    import std.typecons;\n    Nullable!(long[string]) hi\
    \ = Nullable!(long[string]).init;\n    if(test.length == 0) \n    {\n        return\
    \ hi;\n    }\n    auto splitted = test.split();\n    auto to_set = splitted.sort();\n\
    \    auto set = to_set.uniq;\n    auto max = to_set.maxElement;\n    size_t counter\
    \ = 0;\n    auto count_fn = (string s)\n    {\n        counter = 0;\n        foreach(i;\
    \ splitted)\n        {\n            if(i == s) \n            {\n             \
    \   counter++;\n            }\n        }\n        return counter;\n    };\n  \
    \  long[string] result;\n    foreach(i; set)\n    {\n        if(i == max) \n \
    \       {\n            result[i] = count_fn(i);\n        }\n    }\n    hi.__nullable_obj\
    \ = result;\n    return hi;\n}", "{ \n    Nullable!(long[string]) ret;\n    if\
    \ (test.length == 0)\n        return ret;\n    auto m = test.split();\n    if\
    \ (m.length == 0)\n        return ret;\n    auto h = m.length.iota.map!(i => m[i]).groupBy!(i\
    \ => i);\n    h.values.each!(v => v[0] = v.length);\n    ret = h.values.map!(v\
    \ => v[0]).maxBy!(v => v);\n    return h.filter!(kv => kv.value[0] == ret).map!(kv\
    \ => kv.key => kv.value[0]).array;\n}", "{\n    // Need to store a count of each\
    \ letter and the maximum count\n    long[string] counts;\n    long maxCount =\
    \ 0;\n    // Loop through every letter, count it and increment the maxCount\n\
    \    foreach(letter; test.split()) \n    {\n        counts[letter]++;\n      \
    \  maxCount = max(maxCount, counts[letter]);\n    }\n    // Return an associative\
    \ array of letters with the maximum count\n    if(maxCount == 0) \n    {\n   \
    \     return __null_dict__;\n    }\n    else \n    {\n        long[string] result;\n\
    \        foreach(letter; counts.keys) \n        {\n            if(counts[letter]\
    \ == maxCount) \n            {\n                result[letter] = maxCount;\n \
    \           }\n        }\n        return result;\n    }\n}", "{\n    if (test.empty)\
    \ \n    {\n        return ___null_dict___;\n    }\n    long[string] result;\n\
    \    foreach (str; test.split()) \n    {\n        if (str in result) \n      \
    \  {\n            result[str] += 1L;\n        } \n        else \n        {\n \
    \           result[str] = 1L;\n        }\n    }\n    /*auto maxKey = test[0];\n\
    \    foreach (key; test.keys)\n    {\n        if (test[key] > test[maxKey])\n\
    \        {\n            maxKey = key;\n        }\n    }*/\n    long maxVal = 0L;\n\
    \    foreach (value; result.values) \n    {\n        if (value > maxVal) \n  \
    \      {\n            maxVal = value;\n        }\n    }\n    auto maxKeys = test.keys.filter!(a\
    \ => test[a] == maxVal);\n    Nullable!(long[string]) nullableResult;\n    auto\
    \ newValue = new long[string](maxKeys.length);\n    size_t i = 0;\n    foreach\
    \ (key; maxKeys) \n    {\n        newValue[i] = result[key];\n        i++;\n \
    \   }\n    nullableResult.nullable = newValue;\n    return nullableResult;\n}\n\
    //\nunittest \n{\n    auto hist = histogram(\"a b c\");\n    assert(hist.nullable.get[\"\
    a\"] == 1L);\n    assert(hist.nullable.get[\"b\"] == 1L);\n    assert(hist.nullable.get[\"\
    c\"] == 1L);\n    assert(hist.nullable.length == 3);\n    hist = histogram(\"\
    a b b a\");\n    assert(hist.nullable.get[\"a\"] == 2L);\n    assert(hist.nullable.get[\"\
    b\"] == 2L);\n    assert(hist.nullable.length == 2);\n    hist = histogram(\"\
    a b c a b\");\n    assert(hist.nullable.get[\"a\"] == 2L);\n    assert(hist.nullable.get[\"\
    b\"] == 2L);\n", "{\n    if (test.empty)\n        return typeof(return).init;\n\
    \    auto words = test.split;\n    Nullable!(long[string]) result = typeof(return).init;\n\
    \    long[] histo = new long[words.length];\n    for (int i = 0; i < words.length;\
    \ i++)\n    {\n        foreach (word; words)\n        {\n            if (word\
    \ == words[i])\n                histo[i]++;\n        }\n    }\n    auto tmp =\
    \ zip(words, histo);\n    foreach (key, val; tmp)\n    {\n        if (val == max(histo))\n\
    \            result[key] = val;\n    }\n    return result;\n}", "{\n    long[]\
    \ res;\n    if (test.empty) \n    {\n        res = null;\n    } \n    else \n\
    \    {\n        res = [test.split()\n                    .map!(x => test.countUntil(x,\
    \ test.indexOf(x)))(0)\n                    .max()];\n        res ~= test.split()\n\
    \                 .map!(x => test.countUntil(x, test.indexOf(x)))(0)\n       \
    \          .filter!(x => x >= res[0]);\n    }\n    return res;\n}", "{\n    auto\
    \ test = test.split;\n    test.sort;\n    long maxval = 0;\n    long[] res = long[string]();\n\
    \    long[string] test2 = long[string]();\n    foreach(t; test)\n    {\n     \
    \   if(t !in test2)\n        {\n            test2[t] = 1;\n        }\n       \
    \ else\n        {\n            test2[t] += 1;\n        }\n    }\n    foreach(t;\
    \ test2)\n    {\n        if(t.value > maxval)\n        {\n            maxval =\
    \ t.value;\n        }\n    }\n    if(maxval == 0)\n    {\n        return Nullable!(long[string]).init;\n\
    \    }\n    foreach(t; test2)\n    {\n        if(t.value == maxval)\n        {\n\
    \            res[t.key] = t.value;\n        }\n    }\n    return res.nullable;\n\
    }\n/*\nWrite a function that takes a non-negative integer and returns an array\
    \ of bits\nfor the integer.", "{\n    if (test.empty)\n        return null;\n\
    \    auto tst = test.splitter.noempty.array;\n    auto rst = tst.map!(a => a ~\
    \ \": \" ~ std.string.to!string(tst.count(a)));\n    if (rst.length == 1)\n  \
    \      return null;\n    auto keys = tst.filter!(a => rst.count(a ~ \": \" ~ std.string.to!string(tst.count(a)))\
    \ == 1).array;\n    auto max = tst.max!(a => tst.count(a));\n    return keys.array.map!(a\
    \ => a ~ \": \" ~ std.string.to!string(tst.count(a))).filter!(a => a[$-1 .. $]\
    \ == std.string.to!string(max));\n}", "{\n    long[] letters_count;\n    long\
    \ temp;\n    foreach(c; test) \n    {\n        if(std.uni.isAlpha(c)) \n     \
    \   {\n            temp = letters_count[c.toLower()];\n            letters_count[c.toLower()]\
    \ = temp + 1;\n        }\n    }\n    long[] high;\n    long high_value = 0;\n\
    \    foreach(k, v; letters_count) \n    {\n        if(v > high_value) \n     \
    \   {\n            high = [k];\n            high_value = v;\n        }\n     \
    \   else if(v == high_value) \n        {\n            high ~= k;\n        }\n\
    \    }\n    return [high : high_value].nullable;\n}", "{\n    import std.algorithm\
    \ : max;\n    if (test.empty)\n        return null;\n    string[] arr = test.split;\n\
    \    long[string] result = [arr[0]: 1L];\n    foreach (s; arr[1..$])\n    {\n\
    \        if (result.contains(s))\n            result[s]++;\n        else\n   \
    \         result[s] = 1L;\n    }\n    auto max = result.values.max;\n    return\
    \ result.filter!(v => v.value == max);\n}", "{\n\tauto result = test.map!(c =>\
    \ c.to!string()).arrayof.groupBy.values.map!(a => a.length).max;\n\tif (result\
    \ is null) \n\t{\n\t\treturn null;\n\t}\n\telse \n\t{\n\t\treturn test.map!(c\
    \ => c.to!string()).arrayof.groupBy.filter!(a => a.value.length == result).map!(a\
    \ => a.value[0] ~ a.value.length).dict;\n\t}\n}", "{\n    /*\n    if(test.length\
    \ == 0)\n        return null;\n    */\n    Nullable!(long[string]) dict;\n   \
    \ dict.init;\n    string[] split = test.split(\" \");\n    long[] times;\n   \
    \ times.length = split.length;\n    for(long i = 0; i < split.length; i++)\n \
    \   {\n        dict[split[i]]++;\n        times[i] = dict[split[i]];\n    }\n\
    \    long max = times[0];\n    long maxIndex = 0;\n    foreach(idx, value; times)\n\
    \    {\n        if(max < value)\n        {\n            max = value;\n       \
    \     maxIndex = idx;\n        }\n    }\n    if(max == 1)\n        return null;\n\
    \    string[] keys = dict.keys();\n    dict.reset;\n    foreach(key; keys)\n \
    \   {\n        if(dict[key] == max)\n            dict[key] = max;\n    }\n   \
    \ return dict;\n}", "{\n    Nullable!(long[string]) result;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.functional;\n    import std.range;\n  \
    \  import std.math;\n    import std.typecons;\n    /*\n    Given a string representing\
    \ a space separated lowercase letters, return an associative array\n        of\
    \ the letter with the most repetition and containing the corresponding count.\n\
    \        If several letters have the same occurrence, return all of them.\n  \
    \      \n        Example:\n        >>> histogram(\"a b c\")\n        [\"a\": 1L,\
    \ \"b\": 1L, \"c\": 1L].nullable\n        >>> histogram(\"a b b a\")\n       \
    \ [\"a\": 2L, \"b\": 2L].nullable\n        >>> histogram(\"a b c a b\")\n    \
    \    [\"a\": 2L, \"b\": 2L].nullable\n        >>> histogram(\"b b b b a\")\n \
    \       [\"b\": 4L].nullable\n        >>> histogram(\"\")\n        ___null_dict___\n\
    \    \n        \n    */\n    Nullable!(long[string]) histogram(string test)\n\
    \    {\n        Nullable!(long[string]) result;\n        import std.algorithm;\n\
    \        import std.array;\n        import std.functional;\n        import std.range;\n\
    \        import std.math;\n        import std.typecons;\n        /*\n        Given\
    \ a string representing a space separated lowercase letters, return an associative\
    \ array\n            of the letter with the most repetition and containing the\
    \ corresponding count.\n            If several letters have the same occurrence,\
    \ return all of them.\n            \n            Example:\n            >>> histogram(\"\
    a b c\")\n            [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n           \
    \ >>> histogram(\"a b b a\")\n            [\"a\": 2L, \"b\": 2L].nullable\n  \
    \          >>> histogram(\"a b c a b\")\n            [\"a\": 2L, \"b\": 2L].nullable\n\
    \            >>> histogram(\"b b b b a\")\n            [\"b\": 4L].nullable\n\
    \            >>> histogram(\"\")\n            ___null_dict___\n        \n    \
    \        \n        */\n        Nullable!", "{\n    //1. Create an associative\
    \ array\n    long[string] alist;\n    //2. for each letter in the test string\n\
    \    foreach(letter; test.split())\n    {\n        //3. increment the count for\
    \ that letter by 1\n        alist[letter]++;\n    }\n    //4. Create nullable\
    \ variables for the maximum count and the letter with that count\n    Nullable!long\
    \ maxCount = ___null_long___;\n    Nullable!string maxLetter = ___null_string___;\n\
    \    foreach(item; alist)\n    {\n        //5. if the current letter has a count\
    \ larger than the max count\n        if(item.value > maxCount)\n        {\n  \
    \          //6. update the maxcount to equal the current count\n            maxCount\
    \ = item.value;\n            //7. update the letter to equal the current letter\n\
    \            maxLetter = item.key;\n        }\n        //8. else if the current\
    \ letter has a count equal to the max count\n        else if(item.value == maxCount)\n\
    \        {\n            //9. update the letter to be a tuple of the old letter\
    \ and the current letter\n            maxLetter = maxLetter ~ item.key;\n    \
    \    }\n    }\n    //10. return the nullable tuple\n    return cast(Nullable!(long[string]))maxLetter.map!((string\
    \ x) => alist[x]);\n}", "{\n    import std.array : array;\n    import std.algorithm\
    \ : sort, uniq, count;\n    import std.range : iota;\n    import std.typecons\
    \ : tuple;\n    import std.conv : to;\n    Nullable!(long[string]) output;\n \
    \   if (test.length > 0)\n    {\n        long[] histo;\n        size_t[] freq;\n\
    \        // We convert the string in a range, then in an array of tuple to be\
    \ able to\n        // sort and uniq the characters. Then we create a dictionary\
    \ and return it.\n        histo = test.split()\n            .iota\n          \
    \  .array\n            .sort\n            .uniq\n            .map!(a => tuple(a,\
    \ a))\n            .array;\n        freq = test.split()\n            .iota\n \
    \           .map!(a => count(test.split, a))\n            .array;\n        output\
    \ = histo.map!(a => a[0] => freq[a[1]]).assocArray.nullable;\n    }\n    return\
    \ output;\n}", "{\n    int[char] charMap;\n    foreach(char c; test) \n    {\n\
    \        ++charMap[c];\n    }\n    long[string] max_ = [ \"\": 0L ];\n    foreach(key,\
    \ value; charMap) \n    {\n        if(value > max_[\"\"]) \n        {\n      \
    \      max_ = [ key: value ];\n        } \n        else if(value == max_[\"\"\
    ]) \n        {\n            max_[key] = value;\n        }\n    }\n    return max_\
    \ == [ \"\": 0L ] ? null : max_;\n}", "{\n    \n    import std.algorithm;\n  \
    \  import std.range;\n    import std.array;\n    import std.conv;\n    import\
    \ std.traits;\n    import std.datetime;\n    import std.range;\n    import std.typecons;\n\
    \    import std.math;\n    import std.string;\n    import std.format;\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.datetime;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.conv;\n    import std.range;\n    import std.container;\n    import std.bitmanip;\n\
    \    import std.exception;\n    import std.array;\n    import std.range;\n   \
    \ import std.stdio;\n    import std.string;\n    import std.algorithm;\n    import\
    \ std.conv;\n    import std.format;\n    import std.range;\n    import std.traits;\n\
    \    import std.typecons;\n    import std.math;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.bitmanip;\n    import std.exception;\n    import\
    \ std.datetime;\n    import std.stdio;\n    import std.string;\n    import std.algorithm;\n\
    \    import std.conv;\n    import std.format;\n    import std.range;\n    import\
    \ std.traits;\n    import std.typecons;\n    import std.math;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.bitmanip;\n    import std.exception;\n\
    \    import std.datetime;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.traits;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.traits;\n    import std.typecons;", "{\n    if (test.empty)\n        return\
    \ Nullable!(long[string]).init;\n    Nullable!(long[string]) result;\n    int[]\
    \ count;\n    foreach (c; test.split(\" \")) \n    {\n        if (result.isNull)\
    \ \n        {\n            count = [0L];\n            result = Nullable!(long[string]).init;\n\
    \            result.assign(c, count);\n        }\n        else \n        {\n \
    \           if (result.get(c)) \n            {\n                count = result.get(c);\n\
    \                count[0] += 1L;\n            }\n            else \n         \
    \   {\n                count = [1L];\n                result.assign(c, count);\n\
    \            }\n        }\n    }\n    if (result.isNull)\n        return Nullable!(long[string]).init;\n\
    \    auto max = result.get(result.byKeyValue!((\"a\", 0L))[0][0]);\n    foreach\
    \ (c; result.byKeyValue!((\"a\", 0L))[0]) \n    {\n        if (result.get(c) >\
    \ max)\n            max = result.get(c);\n    }\n    Nullable!(long[string]) res;\n\
    \    foreach (c; result.byKeyValue!((\"a\", 0L))[0]) \n    {\n        if (result.get(c)\
    \ == max) \n        {\n            if (res.isNull) \n            {\n         \
    \       res = Nullable!(long[string]).init;\n                res.assign(c, max);\n\
    \            }\n            else \n            {\n                res.assign(c,\
    \ max);\n            }\n        }\n    }\n    return res;\n}", "{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.range;\n    import std.typecons;\n\
    \    import std.traits;\n    import std.uni;\n    import std.math;\n    import\
    \ std.stdio;\n    import std.conv;\n    import std.range;\n    import std.traits;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.string;\n  \
    \  import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.type", "{\n\
    \    Nullable!(long[string]) res = typeof(res)();\n    if (test.length == 0) return\
    \ res;\n    int test_length = test.length;\n    int[string] counts = test.idup.split().map!(a\
    \ => a[0]).reduce!q{a[b] += 1; return a;}();\n    //Test all letters of the alphabet\n\
    \    foreach(key; \"abcdefghijklmnopqrstuvwxyz\".dup.idup.split())\n    {\n  \
    \      if (key in counts)\n        {\n            if (res is null)\n         \
    \   {\n                res = typeof(res)();\n                res.value = [key:\
    \ counts[key]];\n            }\n            else if (counts[key] == max(res.value.values))\n\
    \            {\n                res.value[key] = counts[key];\n            }\n\
    \            else if (counts[key] > max(res.value.values))\n            {\n  \
    \              res.value = [key: counts[key]];\n            }\n        }\n   \
    \ }\n    return res;\n}", "{\n\tlong[string] result;\n\tforeach(chr; test.splitter())\
    \ \n\t{\n\t\tresult[chr]++;\n\t}\n\treturn result;\n}\n/*\nReturn the amount of\
    \ times a char appears in a string.\n    Example:\n    >>> count('a', \"a b c\"\
    )\n    1L\n    >>> count('b', \"a b c\")\n    1L\n    >>> count('c', \"a b c\"\
    )\n    1L\n    >>> count('a', \"a b b a\")\n    2L\n    >>> count('b', \"a b b\
    \ a\")\n    2L\n    >>> count('a', \"a b c a b\")\n    2L\n    >>> count('b',\
    \ \"a b c a b\")\n    2L\n    >>> count('b', \"b b b b a\")\n    4L\n    >>> count('b',\
    \ \"\")\n    0L\n*/\nlong count(string chr, string test) \n{\n\tlong res = 0;\n\
    \tforeach(c; test.splitter()) \n\t{\n\t\tif(c == chr) \n\t\t{\n\t\t\tres++;\n\t\
    \t}\n\t}\n\treturn res;\n}\n/*\nGiven a string representing a space separated\
    \ lowercase letters, return an associative array\n    of the letter with the most\
    \ repetition and containing the corresponding count.\n    If several letters have\
    \ the same occurrence, return all of them.\n    Example:\n    >>> histogram(\"\
    a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"\
    a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___\n*/\nNullable!(long[string])\
    \ histogram(string test) \n{\n\tlong[string] result;\n\tforeach(chr; test.splitter())\
    \ \n\t{\n\t\t", "{\n\tlong[] letter_counts = new long[test.length];\n\tforeach(index,\
    \ char a; test) \n\t{\n\t\tforeach(other_index, char b; test) \n\t\t{\n\t\t\t\
    if(a == b) \n\t\t\t{\n\t\t\t\tletter_counts[index] += 1L;\n\t\t\t}\n\t\t}\n\t\
    }\n\tlong max = max(letter_counts);\n\tlong[] most_often = new long[test.length];\n\
    \tforeach(i, char a; test) \n\t{\n\t\tif(letter_counts[i] == max) \n\t\t{\n\t\t\
    \tmost_often[i] = max;\n\t\t}\n\t}\n\tstring[] letters = test.split(\" \");\n\t\
    return zip(letters, most_often);\n}\n/*\nTest cases:\n*/\nstatic assert(histogram(\"\
    a b c\") == [[\"a\": 1L, \"b\": 1L, \"c\": 1L]].nullable);\nstatic assert(histogram(\"\
    a b b a\") == [[\"a\": 2L, \"b\": 2L]].nullable);\nstatic assert(histogram(\"\
    a b c a b\") == [[\"a\": 2L, \"b\": 2L]].nullable);\nstatic assert(histogram(\"\
    b b b b a\") == [[\"b\": 4L]].nullable);\nstatic assert(histogram(\"\") == ___null_dict___);\n\
    static assert(histogram(\"a b c a b\") == [[\"a\": 2L, \"b\": 2L]].nullable);\n\
    static assert(histogram(\"a b b c c b a c a\") == [[\"a\": 3L, \"b\": 3L, \"c\"\
    : 3L]].nullable);\nstatic assert(histogram(\"i h i\") == [[\"i\": 2L, \"h\": 1L]].nullable);\n\
    static assert(histogram(\"a\") == [[\"a\": 1L]].nullable);\nstatic assert(histogram(\"\
    a b\") == [[\"a\": 1L, \"b\": 1L]].nullable);\nstatic assert(histogram(\"a b c\"\
    ) ==", "{\n    string[] splitted = test.split();\n    if (splitted.length == 0)\n\
    \        return null;\n    long[] result = new long[0];\n    long[] counter =\
    \ new long[splitted.length];\n    foreach (index, item; splitted)\n    {\n   \
    \     int c = 0;\n        foreach (i, j; splitted)\n        {\n            if\
    \ (item == j)\n                c++;\n        }\n        counter[index] = c;\n\
    \    }\n    long max = counter[0];\n    foreach (i, j; counter)\n    {\n     \
    \   if (j > max)\n            max = j;\n    }\n    foreach (index, item; splitted)\n\
    \    {\n        if (counter[index] == max)\n            result ~= item;\n    }\n\
    \    return result;\n}", "{\n    long[string] counts;\n    string[] words = test.split(\"\
    \ \");\n    foreach(w; words)\n    {\n        counts[w]++;\n    }\n    long max\
    \ = counts.values.max;\n    if(max == 0)\n    {\n        return null;\n    }\n\
    \    Nullable!(long[string]) res;\n    res.init;\n    foreach(w; counts.keys)\n\
    \    {\n        if(counts[w] == max)\n        {\n            res.value[w] = max;\n\
    \        }\n    }\n    return res;\n}", "{\n    Nullable!(long[string]) nres;\n\
    \    import std.array : array;\n    //    nres.assign(array);\n    if (test.length\
    \ > 0) \n    {\n        string[] list = test.split(' ');\n        immutable string[]\
    \ a = list.array;\n        long[] result = new long[a.length];\n        foreach\
    \ (item; a) \n        {\n            //            immutable string b = item;\n\
    \            immutable size_t c = a.count(item);\n            immutable long d\
    \ = c;\n            result[a.indexOf(item)] = d;\n        }\n        long max\
    \ = result.max;\n        long[] maxarray = result.filter!((i) => (i == max)).array;\n\
    \        import std.typecons : tuple;\n        auto xy = tuple(maxarray, a);\n\
    \        import std.container : Array;\n        Array!(string[]) res = Array!(string[])\
    \ (xy);\n        //        res.each!((x) {\n        //            writeln(x[0],\
    \ \": \", x[1]);\n        //        });\n        //        writeln(res.length);\n\
    \        long[string] res1 = new long[res.length];\n        foreach (i; 0 .. res.length)\
    \ \n        {\n            string[2] key = res[i];\n            //           \
    \ writeln(key[0]);\n            string newkey = key[1];\n            long newval\
    \ = key[0].to!long;\n            res1[newkey] = newval;\n        }\n        import\
    \ std.traits : Unqual;\n        auto result1 = new Unqual!(typeof(res1))(res1);\n\
    \        nres.assign(result1);\n    }\n    return nres;\n}", "{\n    Nullable!(long[string])\
    \ res = null;\n    long max = 0;\n    foreach(i, c; test) \n    {\n        auto\
    \ s = test[i..i + 1];\n        if (s.length != 1)\n            continue;\n   \
    \     auto r = test.count(s);\n        if (r > max) \n        {\n            max\
    \ = r;\n            res = new Nullable!(long[string])([s: r].nullable);\n    \
    \    } \n        else if (r == max) \n        {\n            if (res.isNull)\n\
    \                res = new Nullable!(long[string])([s: r].nullable);\n       \
    \     else\n                res.get.put(s, r);\n        }\n    }\n    return res;\n\
    }", "{\n    Nullable!(long[string]) max_value = null;\n    int max_count = 0;\n\
    \    long[string] my_map;\n    foreach(str; test.split) \n    {\n        auto\
    \ it = my_map.find(str);\n        if(it !is null)\n        {\n            it.value++;\n\
    \        }\n        else\n        {\n            my_map[str] = 1;\n        }\n\
    \    }\n    foreach(k, v; my_map)\n    {\n        if(v == max_count)\n       \
    \ {\n            if(max_value !is null)\n            {\n                max_value[k]\
    \ = v;\n            }\n            else\n            {\n                max_value\
    \ = [k: v];\n            }\n        }\n        else if(v > max_count)\n      \
    \  {\n            max_value = [k: v];\n            max_count = v;\n        }\n\
    \    }\n    return max_value;\n}", "{\n    /*\n    const char[] stringToCharArray(in\
    \ string myString)\n    {\n        import std.array;\n        char[] ret = new\
    \ char[myString.length];\n        ret[] = myString[];\n        return ret;\n \
    \   }\n    */\n    Nullable!(long[string]) ret = null;\n    long max = 0;\n  \
    \  long[string] temp;\n    foreach(i; 0 .. test.length)\n    {\n        if(test[i]\
    \ is in ('a' .. 'z'))\n        {\n            auto idx = temp.indexOf(test[i]);\n\
    \            if(idx is null)\n            {\n                temp.insert(test[i],\
    \ 1);\n            }\n            else\n            {\n                temp[idx]\
    \ = temp[idx] + 1;\n            }\n        }\n    }\n    foreach(idx, val; temp)\n\
    \    {\n        if(val > max)\n        {\n            max = val;\n        }\n\
    \    }\n    foreach(idx, val; temp)\n    {\n        if(val == max)\n        {\n\
    \            ret.insert(idx, val);\n        }\n    }\n    return ret;\n}", "{\
    \ \n    auto r = new long[string];\n    foreach(i,t; test.lowercase.split(\" \"\
    ))\n    {\n        r[t]++;\n    }\n    return r;\n}\n/*\nCreate a program that\
    \ loops indefinitely and asks the user if they want to enter a string\n    to\
    \ be analysed.\n    If the user says yes, get the input and print the result of\
    \ histogram.\n    If the user says no, print \"Bye\" and terminate the program.\n\
    \    If the user inputs something else, print \"Bad input\" and ask again.\n \
    \   \n    Example:\n    >>> \n    >>> do you want to enter a string? \n    >>>\
    \ Yes\n    >>> Enter a string:\n    >>> a a b c\n    >>> \n    >>> a: 2\n    >>>\
    \ b: 1\n    >>> c: 1\n    >>> \n    >>> do you want to enter a string? \n    >>>\
    \ yes\n    >>> Enter a string:\n    >>> a b c\n    >>> \n    >>> a: 1\n    >>>\
    \ b: 1\n    >>> c: 1\n    >>> \n    >>> do you want to enter a string? \n    >>>\
    \ no\n    >>> Bye\n*/", "{\n    if (test.empty) \n    {\n        return null;\n\
    \    }\n    long[string] result;\n    foreach (a; test.split) \n    {\n      \
    \  if (a in result) \n        {\n            result[a] += 1;\n        } \n   \
    \     else \n        {\n            result[a] = 1;\n        }\n    }\n    return\
    \ result;\n}", "{\n    auto a = test.split(\" \");\n    if (a.length == 0) return\
    \ Nullable!(long[string])();\n    auto counter = a.dup;\n    counter.sort;\n \
    \   auto result = counter.reduce!\"a + (test[0] == test[1] ? 1 : 0)\";\n    if\
    \ (result.length == 1) return Nullable!(long[string])(result[0]);\n    if (result.length\
    \ == 2) return Nullable!(long[string])(result[0]);\n    if (result.length != 3)\
    \ return Nullable!(long[string])(result[0]);\n    if (result[0].value == result[1].value)\n\
    \    {\n        auto key = [result[0].key, result[1].key];\n        return Nullable!(long[string])([key:\
    \ result[0].value]);\n    }\n    return Nullable!(long[string])(result[0]);\n}",
  "{\n    long[] histogram;\n    for (c; test)\n    {\n        if (c == ' ')\n   \
    \         continue;\n        if (histogram.length == 0)\n            histogram[c]\
    \ = 1;\n        else\n            histogram[c] = histogram[c] + 1;\n    }\n  \
    \  if (histogram.length == 0)\n        return null;\n    long max = 0;\n    foreach\
    \ (c, count; histogram)\n    {\n        if (count > max)\n            max = count;\n\
    \    }\n    long[string] result;\n    foreach (c, count; histogram)\n    {\n \
    \       if (count == max)\n            result[c] = count;\n    }\n    return result;\n\
    }", "{\n    long[string] a;\n    long[long] countMap;\n    foreach(t; test.split())\
    \ \n    {\n        if (a.count(t) == 0) \n        {\n            a[t] = 1;\n \
    \       } \n        else \n        {\n            a[t] += 1;\n        }\n    \
    \    countMap[a[t]] = 1;\n    }\n    long max = max(countMap.keys());\n    long[string]\
    \ res;\n    foreach(k, v; a) \n    {\n        if (v == max) \n        {\n    \
    \        res[k] = v;\n        }\n    }\n    return res.length == 0 ? Nullable!(long[string]).init\
    \ : res;\n}", "{\n    long[string] allLetters=null;\n    int[long] histLetters=null;\n\
    \    char[] splited=test.split;\n    foreach(ch;splited)\n    {\n        string\
    \ letters=ch.idup;\n        if(letters.length==1)\n        {\n            if(allLetters[letters]\
    \ is null)\n            {\n                allLetters[letters]=1;\n          \
    \  }\n            else\n            {\n                allLetters[letters]++;\n\
    \            }\n            if(histLetters[allLetters[letters]] is null)\n   \
    \         {\n                histLetters[allLetters[letters]]=1;\n           \
    \ }\n            else\n            {\n                histLetters[allLetters[letters]]++;\n\
    \            }\n        }\n    }\n    long[string] finalLetters=null;\n    int\
    \ max=histLetters.length;\n    int index=0;\n    long maxValue=0;\n    while(index<max)\n\
    \    {\n        if(histLetters[index] is null)\n        {\n            index++;\n\
    \        }\n        else\n        {\n            maxValue=index;\n           \
    \ break;\n        }\n    }\n    if(maxValue!=0)\n    {\n        foreach(k,v;allLetters)\n\
    \        {\n            if(v==maxValue)\n            {\n                finalLetters[k]=v;\n\
    \            }\n        }\n    }\n    return finalLetters.nullable;\n}", "{ \n\
    \    alias D = long[string];\n    D storage;\n    foreach(i, e; test.split)\n\
    \    {\n        storage[e] = storage.getOrInit(e, 0) + 1;\n    }\n    long max\
    \ = storage.max();\n    D res;\n    foreach(e; storage)\n    {\n        if(e.value\
    \ == max)\n        {\n            res[e.key] = e.value;\n        }\n    }\n  \
    \  return res.empty ? null : res;\n}", "{\n    immutable countMap = test.split.countMap;\n\
    \    immutable maxCount = countMap.values.max;\n    if (maxCount == -1)\n    \
    \    return null;\n    return makeUniqueKeys(countMap.assocArray, maxCount);\n\
    }", "in {\n    assert(test.length > 0);\n}\nout (result) {\n    invariant(result.length\
    \ > 0);\n}\n{\n    long[string] counts;\n    string[] elems = test.split(' ');\n\
    \    foreach(elem; elems)\n    {\n        if (elem.length > 0)\n        {\n  \
    \          auto[exists, count] = counts.insert(elem, 1L);\n            if (!exists)\
    \ \n            {\n                ++counts[elem];\n            }\n        }\n\
    \    }\n    return counts;\n}", "{ \n    import std.algorithm;\n    Nullable!(long[string])\
    \ result;\n    auto letters = test.split(' ');\n    auto uniqueLetters = letters.sort().uniq;\n\
    \    long[] counts;\n    foreach(index, letter; uniqueLetters)\n    {\n      \
    \  counts ~= letters.count(letter);\n    }\n    long maxCount = counts.max;\n\
    \    if(maxCount == 0)\n    {\n        return result;\n    }\n    auto maxIndexes\
    \ = counts.indicesOf(maxCount);\n    auto maxLetters = uniqueLetters[maxIndexes];\n\
    \    result = maxLetters.zip(maxCount.dup);\n    return result;\n}", "{\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.container;\n    import\
    \ std.traits;\n    import std.array;\n    import std.typecons;\n    import std.stdio;\n\
    \    import std.string;\n    import std.conv;\n    import std.math;\n    import\
    \ std.typecons;\n    if (test.empty)\n    {\n        return null;\n    }\n   \
    \ long[] counts = new long[256];\n    foreach (c; test)\n    {\n        counts[c]++;\n\
    \    }\n    long max = reduce!((a, b) => max(a, b))(counts);\n    string[long]\
    \ reverse = new string[long];\n    foreach (c; test)\n    {\n        if (counts[c]\
    \ == max)\n        {\n            reverse[max] ~= cast(string)c;\n        }\n\
    \    }\n    return  reverse[max].assocArray.nullable;\n}", "in\n{\n    assert(test);\n\
    }\nbody\n{\n    Nullable!(long[string]) res = null;\n    long maxCount = 0;\n\
    \    foreach(i, c; test)\n    {\n        string s = c.to!string;\n        if(res.isNull)\n\
    \        {\n            res = [s: 1L];\n            maxCount = 1;\n        }\n\
    \        else if(res.count is 1 && res.contains(s))\n        {\n            if(res[s]\
    \ is maxCount)\n            {\n                long[string] tmp = [s: maxCount\
    \ + 1];\n                tmp[s] = res[s] + 1;\n                res = tmp;\n  \
    \              maxCount++;\n            }\n            else if(res[s] is maxCount\
    \ - 1)\n            {\n                res[s] = res[s] + 1;\n                maxCount++;\n\
    \            }\n            else\n            {\n                res[s] = res[s]\
    \ + 1;\n            }\n        }\n        else if(res.count is 1 && !res.contains(s))\n\
    \        {\n            if(res.byValue.value is maxCount)\n            {\n   \
    \             long[string] tmp = [s: 1L];\n                res = tmp;\n      \
    \      }\n            else\n            {\n                res[s] = 1L;\n    \
    \        }\n        }\n        else if(res.count > 1)\n        {\n           \
    \ if(res.contains(s))\n            {\n                if(res[s] is maxCount)\n\
    \                {\n                    res[s] = res[s] + 1;\n               \
    \     maxCount++;\n                }\n                else if(res[s] is maxCount\
    \ - 1)\n                {\n                    res[s] = res[s] + 1;\n        \
    \            maxCount++;\n                }\n                else\n          \
    \      {\n                    res[s] = res[s] + 1;\n                }\n      \
    \      }\n            else\n            {\n                if(res.byValue.value\
    \ is maxCount)\n                {\n                    res[s] = 1L;\n        \
    \        }\n                else\n                {\n                    long[string]\
    \ tmp = [s: 1L];", "{\n    long[string] histo;\n    int len = test.length;\n \
    \   bool[int] hits;\n    int matches;\n    int index;\n    int i;\n    int endIndex;\n\
    \    int k;\n    int matchCount;\n    Nullable!(long[string]) result;\n    string\
    \ key;\n    if (len > 0) {\n        hits = true.repeat(len);\n        matches\
    \ = 0;\n        index = 0;\n        i = 0;\n        while (i < len) {\n      \
    \      while (i < len && hits[i]) {\n                i += 1;\n            }\n\
    \            if (i < len) {\n                endIndex = i;\n                k\
    \ = i + 1;\n                while (k < len) {\n                    if (test[i]\
    \ == test[k]) {\n                        hits[k] = false;\n                  \
    \      matches += 1;\n                        endIndex = k;\n                \
    \    }\n                    k += 1;\n                }\n                key =\
    \ test[i .. endIndex + 1];\n                if (histo.count(key) == 0) {\n   \
    \                 histo[key] = 1L;\n                } else {\n               \
    \     histo[key] += 1L;\n                }\n                index += 1;\n    \
    \        }\n            i += 1;\n        }\n        if (matches > 0) {\n     \
    \       long max = histo.values.max;\n            long[string] temp;\n       \
    \     foreach (pair; histo) {\n                if (pair.value == max) {\n    \
    \                temp[pair.key] = pair.value;\n                }\n           \
    \ }\n            result = temp;\n        } else {\n            result = null;\n\
    \        }\n    } else {\n        result = null;\n    }\n    return result;\n}",
  "{\n    import std.algorithm : max, min, reduce;\n    import std.typecons : Nullable;\n\
    \    import std.array : array;\n    import std.algorithm.comparison : max, min;\n\
    \    import std.algorithm.iteration : maxElement,minElement;\n    import std.typecons\
    \ : Nullable;\n    import std.traits : isIntegral;\n    import std.conv : to;\n\
    \    import std.range : max, min;\n    import std.algorithm.iteration : maxElement,minElement;\n\
    \    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import\
    \ std.traits : isIntegral;\n    import std.range : max, min;\n    import std.range\
    \ : max, min;\n    import std.range : max, min;\n    import std.algorithm.searching\
    \ : count;\n    import std.array : array;\n    import std.typecons : Nullable;\n\
    \    import std.array : array;\n    import std.algorithm.comparison : max, min;\n\
    \    import std.algorithm.iteration : maxElement,minElement;\n    import std.typecons\
    \ : Nullable;\n    import std.traits : isIntegral;\n    import std.conv : to;\n\
    \    import std.range : max, min;\n    import std.algorithm.iteration : maxElement,minElement;\n\
    \    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import\
    \ std.traits : isIntegral;\n    import std.range : max, min;\n    import std.range\
    \ : max, min;\n    import std.range : max, min;\n    import std.algorithm.searching\
    \ : count;\n    import std.array : array;\n    import std.typecons : Nullable;\n\
    \    import std.array : array;\n    import std.algorithm.comparison : max, min;\n\
    \    import std.algorithm.iteration : maxElement,minElement;\n    import std.typecons\
    \ : Nullable;\n    import std.traits : isIntegral;\n    import std.conv : to;\n\
    \    import", "{\n    enum vowels = \"aoeui\";\n    int[char] count;\n    foreach(i,\
    \ c; test)\n    {\n        if (c !in vowels)\n            continue;\n        count[c]++;\n\
    \    }\n    return count;\n}", "{\n    Nullable!(long[string]) letters;\n    import\
    \ std.algorithm : max;\n    import std.array : split;\n    import std.conv : to;\n\
    \    import std.functional : compose;\n    import std.map : filter, count;\n \
    \   import std.range : iota;\n    import std.range : take;\n    import std.range\
    \ : sort;\n    import std.string : strip;\n    import std.typecons : tuple;\n\
    \    letters = test.strip.split.count.sort.map!(tuple(to!string, (_) => 1L)).count.filter!(\n\
    \        (_) => _.second == test.strip.split.count.sort.map!(tuple(to!string,\
    \ (_) => 1L)).count.max!(compose!(\n            (_) => _[1])).second).map!(tuple(tuple(compose!((_)\
    \ => _[0]), (_) => _[1]))).take(1);\n    return letters;\n}", "{\n    if (test.empty)\n\
    \        return null;\n    auto tmp = split(test);\n    long[string] arr;\n  \
    \  foreach (index, value; tmp)\n    {\n        arr[value]++;\n    }\n    long\
    \ max = max(arr.values);\n    long[string] tmp2;\n    foreach (index, value; arr)\n\
    \    {\n        if (value == max)\n            tmp2[index] = value;\n    }\n \
    \   return tmp2;\n}", "{\n    immutable max_char = 26;\n    // List!(char)[] arr\
    \ = new List!(char)[](max_char); \n    long[char] arr = new long[char](max_char);\n\
    \    // dict!(char, int) dict = new dict!(char, int);\n    Nullable!(long[string])\
    \ dict;\n    foreach(c; test)\n    {\n        static if(!is(typeof(arr[c]))\n\
    \            assert(0, \"Wrong char\");\n        arr[c]++;\n    }\n    long max\
    \ = 0;\n    string keys = \"\";\n    foreach(i, value; arr)\n    {\n        static\
    \ if(!is(typeof(i)))\n            assert(0, \"Wrong char\");\n        // dict[i]\
    \ = value;\n        if(value > max)\n        {\n            max = value;\n   \
    \         keys = format(\"%s\", i);\n        }\n        else if(value == max)\n\
    \        {\n            keys ~= format(\"%s\", i);\n        }\n    }\n    if(max\
    \ > 0)\n    {\n        dict = keys.assumeArray.dup.sorted().assumeUnique().map!((x){return\
    \ [x : max]; }.array).array.reduce!((a, b){ return a ~ b; }.array).array;\n  \
    \  }\n    return dict;\n}", "{\n    static struct rec(T)\n    {\n        size_t\
    \ cnt;\n        T val;\n    }\n    auto max_ = null;\n    auto recs = new rec!(string)[100];\n\
    \    size_t recs_cnt = 0;\n    foreach(token; test.split)\n    {\n        bool\
    \ found = false;\n        for(auto rec = recs[0 .. recs_cnt]; rec)\n        {\n\
    \            if(rec.val == token)\n            {\n                ++rec.cnt;\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        if(!found)\n        {\n            recs[recs_cnt] = rec!(string)(0,\
    \ token);\n            ++recs_cnt;\n        }\n    }\n    foreach(rec; recs[0\
    \ .. recs_cnt])\n    {\n        if(!max_)\n        {\n            max_ = rec;\n\
    \        }\n        else if(max_.cnt == rec.cnt)\n        {\n            max_\
    \ = null;\n            break;\n        }\n        else if(max_.cnt < rec.cnt)\n\
    \        {\n            max_ = rec;\n        }\n    }\n    auto res = new long[string]();\n\
    \    if(max_)\n    {\n        res[max_.val] = max_.cnt;\n    }\n    return res;\n\
    }", "{ \n    import std.array; \n    import std.algorithm; \n    import std.conv;\
    \ \n    Nullable!(long[string]) result = null; \n    long[string] arr; \n    long\
    \ value; \n    if(test.length) \n    { \n        value = 1; \n        foreach(index,\
    \ char c; test) \n        { \n            if(index && c == test[index - 1]) \n\
    \            { \n                value++; \n            } \n            else \n\
    \            { \n                if(index) \n                { \n            \
    \        arr[test[index - 1 .. index - 1]] = value; \n                } \n   \
    \             value = 1; \n            } \n        } \n        arr[test[$ - 1\
    \ .. $ - 1]] = value; \n        value = max(arr.values); \n        auto keys =\
    \ arr.keys.filter!(a => arr[a] == value); \n        result = to!(Nullable!(long[string]))(keys.map!(a\
    \ => [a: value]).array); \n    } \n    return result; \n} \n/*\n    Notes:\n \
    \   * Might not be the most efficient solution as there are loops within loops\n\
    \    * For the last value to be added to the associative array, I had to add a\
    \ check to see if \n    the index != 0 (see line 23), if not, the last value would\
    \ not be added\n    * I used the $ to get the last character of the string\n*/",
  "{\n    auto str_array = test.split(\" \");\n    long[string] result;\n    foreach(str;\
    \ str_array) \n    {\n        result[str] += 1L;\n    }\n    long max_val = max(result.values);\n\
    \    if(max_val == 0L)\n    {\n        return null;\n    }\n    result.removeIf!(a\
    \ => a[1] != max_val);\n    return result;\n}", "{\n    // Make a histogram of\
    \ each letter in the string and the count\n    auto hist = test.histogram();\n\
    \    // Sort the histogram by value\n    // https://forum.dlang.org/post/dk3zqjd2fs.fsf@fungible.pink\n\
    \    struct Comp(alias map) {\n        static bool opCmp(typeof(map.pairs[0])\
    \ a, typeof(map.pairs[0]) b) {\n            return a.value > b.value;\n      \
    \  }\n    }\n    hist.pairs[] = sort!(Comp!(typeof(hist)))(hist.pairs);\n    //\
    \ If the first item's value is the same as the second item's value\n    // then\
    \ we have a tie and should return null.\n    if (hist.pairs[0].value == hist.pairs[1].value)\n\
    \        return ___null_dict___;\n    // Otherwise return an array of the first\
    \ pair's key and value.\n    return long[string](hist.pairs[0].key, hist.pairs[0].value);\n\
    }\n \n ", "    pure nothrow @nogc {\n    long[string] result;\n    static assert(test.length\
    \ == 0 || test[test.length - 1] != ' ');\n    foreach(index, letter; test.split(\"\
    \ \"))\n        result[letter]++;\n    if(result.length == 0)\n        return\
    \ null;\n    long max = result.values.max;\n    foreach(key, value; result) {\n\
    \        if(value < max)\n            result.remove(key);\n    }\n    return result;\n\
    }\nstring[] test_histogram(bool verbose = false) {\n    long[string] test1 = [\"\
    a\": 1L, \"b\": 1L, \"c\": 1L];\n    long[string] test2 = [\"a\": 2L, \"b\": 2L];\n\
    \    long[string] test3 = [\"b\": 4L];\n    string[] tests = [\"a b c\", \"a b\
    \ b a\", \"a b c a b\", \"b b b b a\", \"\"];\n    string[] results = [\"a b c\"\
    , \"a b\", \"a b\", \"b\", \"\"];\n    string[] ret = [];\n    foreach(i, test;\
    \ tests) {\n        auto result = histogram(test);\n        if(verbose) {\n  \
    \          writeln(test, \": \", result);\n        }\n        if(results[i] ==\
    \ \"\" ? (result is null) : result.keys.join(\" \") == results[i]) {\n       \
    \     ret ~= \"true\";\n        } else {\n            ret ~= \"false\";\n    \
    \    }\n    }\n    return ret;\n}", "{ \n    Nullable!(long[string]) histogram;\n\
    \    string[] tokens = test.split(\" \");\n    long[string] histo;\n    long max\
    \ = 0;\n    foreach(token; tokens)\n    {\n        histo[token] += 1;\n      \
    \  if(histo[token] > max)\n        {\n            max = histo[token];\n      \
    \  }\n    }\n    foreach(token; tokens)\n    {\n        if(histo[token] == max)\n\
    \        {\n            histogram.insert(token, histo[token]);\n        }\n  \
    \  }\n    return histogram;\n}", "{ \n    // the input string is a list of space\
    \ separated words\n    string[] wordList = test.split(\" \");\n    // we want\
    \ to count the number of times each word appears in the array\n    // to do this\
    \ we create a variable called `counts` which is a dictionary\n    // which uses\
    \ the word as a key, and the value is the number of times the word occurs.\n \
    \   // Note: since this is a dictionary, the order in which things are added is\
    \ not important\n    //  the dictionary uses a hashing function to find the value\
    \ associated with a key.\n    long[string] counts;\n    foreach(word; wordList)\
    \ \n    {\n        // counts is a dictionary, so we need to use `[]` to get the\
    \ value associated with a key\n        // we use the `getOrUpdate` function because\
    \ it automatically initializes the entry to \n        // 0L for us if the word\
    \ does not exist in the dictionary.\n        long count = counts.getOrUpdate(word,\
    \ 0L);\n        // we have now retrieved the value associated with the key `word`\
    \ from the dictionary `counts`\n        // we can now increment the value as if\
    \ it were a variable.\n        ++count;\n        // and then store the value back\
    \ into the dictionary using the same `[]` accessor.\n        counts[word] = count;\n\
    \    }\n    // we now have a dictionary of word -> count, but we only want the\
    \ words with the most count.\n    // so we need to find the maximum count\n  \
    \  // we start with the maximum value being 0.\n    long maxCount = 0L;\n    //\
    \ and then iterate over all the counts, and update the maximum count\n    foreach(wordCount;\
    \ counts)\n    {\n        maxCount = max(maxCount, wordCount.value);\n    }\n\
    \    // now that we have the maximum count, we can create a dictionary that contains\
    \ only the values\n    // from the original dictionary that have the maximum count.\n\
    \    // we use the `[]` accessor and `=` to initialize the new dictionary\n  \
    \  long[string] maxCountWords;\n    foreach(wordCount; counts)\n    {\n      \
    \  if(wordCount.value == maxCount)\n        {\n            maxCountWords[wordCount.key]",
  "{\n    return test.split().reduce!((a,b) => a[b]++, nullable!(long[string])().init.get).get;\n\
    }", "{\n    long[string] count;\n    foreach(item; test.split)\n    {\n      \
    \  if(count.count(item) == 0)\n        {\n            count[item] = 1;\n     \
    \   }\n        else\n        {\n            count[item]++;\n        }\n    }\n\
    \    int max = 0;\n    long[string] result;\n    foreach(item; count)\n    {\n\
    \        if(max < item.value)\n        {\n            max = item.value;\n    \
    \    }\n    }\n    foreach(item; count)\n    {\n        if(item.value == max)\n\
    \        {\n            result[item.key] = item.value;\n        }\n    }\n   \
    \ if(result.length == 0)\n    {\n        return null;\n    }\n    return result;\n\
    }", "{\n  Nullable!(long[string]) result = Nullable!(long[string]).init;\n  long[string]\
    \ value = [:] ;\n  foreach(s; test.split(\" \"))\n  {\n    value[s]++;\n  }\n\
    \  foreach(k,v; value)\n  {\n    if(!result.isValid || result.get.values.max >\
    \ v)\n    {\n      value = [k:v];\n      result = value;\n    }\n    else if(result.get.values.max\
    \ == v)\n    {\n      result.get[k] = v;\n    }\n  }\n  return result;\n}", "{\n\
    \    auto letters = test.split();\n    auto letter_counts = typeof(return)();\n\
    \    foreach(letter; letters) \n    {\n        if(letter_counts.contains(letter))\
    \ \n        {\n            letter_counts[letter] += 1L;\n        }\n        else\
    \ \n        {\n            letter_counts[letter] = 1L;\n        }\n    }\n   \
    \ long max_count = max(letter_counts.values);\n    auto histogram = typeof(return)();\n\
    \    foreach(k, v; letter_counts) \n    {\n        if(v == max_count) \n     \
    \   {\n            histogram[k] = v;\n        }\n    }\n    return histogram;\n\
    }", "{\n    import std.algorithm;\n    auto testArr = test.split();\n    long[string]\
    \ res;\n    long max = 0;\n    for(string s; s = testArr.front)\n    {\n     \
    \   long count = testArr.count(s);\n        max = max(max, count);\n        res[s]\
    \ = count;\n        testArr.remove(s);\n    }\n    import std.algorithm.searching\
    \ : all;\n    if(res.all!(key, value => value == max))\n    {\n        import\
    \ std.array;\n        res = res.filter!(kvp => kvp.value == max).array;\n    }\n\
    \    import std.meta : AliasSeq;\n    return typeof(res) == AliasSeq!(string,\
    \ long) ? res : null;\n}", "{ \n    Nullable!(long[string]) result = null;\n \
    \   long[string] temp = [_: 0L];\n    foreach(ch; test.assumeUnique())\n    {\n\
    \        temp[ch]++;\n    }\n    long max = maxElement(temp.values);\n    foreach(k,\
    \ v; temp)\n    {\n        if(v == max)\n        {\n            if(result.isNull)\n\
    \            {\n                result = [k: v];\n            } else {\n     \
    \           result[k] = v;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    long[string] result;\n    long[long] counter;\n    foreach(letter;\
    \ test.splitter)\n    {\n        if(!letter.empty)\n        {\n            result[letter]\
    \ += 1L;\n            counter[result[letter]] += 1L;\n        }\n    }\n    return\
    \ !result.empty ? result.byPair.filter!(pair => pair.value == counter.max).array.assocArray\
    \ : null;\n}", "{ \n    Nullable!(long[string]) histogram;\n    foreach(char;\
    \ test.byValue.split(cast(dchar)\" \")) \n    {\n        if(histogram.isNull)\n\
    \        {\n            histogram = [char: 1L];\n        }\n        else\n   \
    \     {\n            histogram[char]++;\n        }\n    }\n    return histogram;\n\
    }", "{\n    Nullable!(long[string]) n = Nullable!(long[string])(false, [string.init],\
    \ [long.init]);\n    foreach(letter; test.split(\" \"))\n    {\n        if(n.isNull)\n\
    \        {\n            n.value.insert(letter, 0L);\n        }\n        if(n.value.find(letter)\
    \ is null)\n        {\n            n.value.insert(letter, 0L);\n        }\n  \
    \      n.value[letter] += 1L;\n    }\n    auto longest = max(n.value.values);\n\
    \    Nullable!(long[string]) longest_letters = null;\n    foreach(i; n.value.byKeyValue)\n\
    \    {\n        if(i.value == longest)\n        {\n            if(longest_letters.isNull)\n\
    \            {\n                longest_letters = Nullable!(long[string])(false,\
    \ [string.init], [long.init]);\n            }\n            longest_letters.value.insert(i.key,\
    \ i.value);\n        }\n    }\n    return longest_letters;\n}", "{\n    return\
    \ \"unimplemented\";\n}", "{\n    Nullable!(long[string]) result;\n    if(test.length\
    \ != 0)\n    {\n        long[string] res;\n        int[string] a;\n        string[]\
    \ words = test.split(\" \");\n        foreach(ref word; words)\n        {\n  \
    \          a[word]++;\n        }\n        long max = a.values.max;\n        foreach(ref\
    \ key; a.keys)\n        {\n            if(a[key] == max)\n            {\n    \
    \            res[key] = max;\n            }\n        }\n        result = res;\n\
    \    }\n    return result;\n}", "{\n    import std.algorithm;\n    import std.array;\n\
    \    import std.conv;\n    import std.string;\n    import std.range;\n    import\
    \ std.typecons;\n    import std.traits;\n    import std.math;\n    import std.ascii;\n\
    \    import std.stdio;\n    import std.exception;\n    import std.format;\n  \
    \  import std.datetime;\n    import std.algorithm;\n    import std.array;\n  \
    \  import std.typecons;\n    import std.math;\n    import std.range;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.type", "{\n    long[string] result;\n    if (test.empty)\n\
    \        return typeof(result).init;\n    foreach (ch; test.toLower().split())\n\
    \    {\n        result[ch]++;\n    }\n    long max = result.values.max();\n  \
    \  if (max == 0)\n        return result.init;\n    foreach (elem; result.keys)\n\
    \    {\n        if (result[elem] < max)\n            result.remove(elem);\n  \
    \  }\n    return result;\n}", "{ \n    Nullable!(long[string]) nullableDict =\
    \ null;\n    long[string] tmpDict;\n    long count;\n    foreach(key; test.split(\"\
    \ \"))\n    {\n        if(key !in tmpDict)\n        {\n            tmpDict[key]\
    \ = 1L;\n        }\n        else\n        {\n            tmpDict[key] += 1L;\n\
    \        }\n        count = tmpDict[key];\n    }\n    if(!tmpDict.empty)\n   \
    \ {\n        count = max(tmpDict.values);\n        foreach(key; tmpDict.keys)\n\
    \        {\n            if(tmpDict[key] == count)\n            {\n           \
    \     nullableDict[key] = count;\n            }\n        }\n    }\n    return\
    \ nullableDict;\n}", "{\n    if (test.empty) \n    {\n        return null;\n \
    \   }\n    auto a = test.split();\n    auto hist = to!(dchar[])[\"\"].assoc;\n\
    \    foreach (c; a)\n    {\n        if (c !in hist)\n        {\n            hist[c]\
    \ = 1;\n        }\n        else\n        {\n            hist[c]++;\n        }\n\
    \    }\n    alias entry = typeof(hist[a[0]]);\n    entry max = maxElement(hist);\n\
    \    long[string] res;\n    foreach (c; hist)\n    {\n        if (c.value == max)\n\
    \        {\n            res[c.key] = c.value;\n        }\n    }\n    return res;\n\
    }", "{\n    Nullable!(long[string]) ret = null;\n    alias MC = MaxCount;\n  \
    \  int[MC] letterCounts;\n    foreach(char c; test)\n    {\n        if(!letterCounts.contains(MC(c,\
    \ 0)))\n        {\n            letterCounts[MC(c, 0)] = 1;\n        }\n      \
    \  else\n        {\n            ++letterCounts[MC(c, 0)];\n        }\n    }\n\
    \    long maxCount = letterCounts.values.max;\n    foreach(MC k, int v; letterCounts)\n\
    \    {\n        if(v == maxCount)\n        {\n            if(ret.isNull)\n   \
    \         {\n                ret = [k.letter: maxCount];\n            }\n    \
    \        else\n            {\n                ret[k.letter] = maxCount;\n    \
    \        }\n        }\n    }\n    return ret;\n}", "{\n    Nullable!(long[string])\
    \ result = Nullable!(long[string]).init;\n    auto chars = test.split();\n   \
    \ foreach(ch; chars)\n    {\n        if(result.isNull)\n        {\n          \
    \  result.assign(long[string](1.max, ch: 1L));\n        }\n        else\n    \
    \    {\n            auto it = result.get.byKey(ch);\n            if(it.find !\
    \ is null)\n            {\n                it.find.value++;\n            }\n \
    \           else\n            {\n                result.get[ch] = 1L;\n      \
    \      }\n        }\n    }\n    return result;\n}", "in \n{\n\tassert(test.length\
    \ == 0L || test.strip().equals(test));\n}\nbody \n{\n    return\n        test.strip().split().\n\
    \        reduce!((string lhs, string rhs) \n        {\n            if (lhs.strip.length\
    \ == 0)\n                return rhs;\n            else\n                return\
    \ lhs;\n        }).\n        frequency.\n        filter!((Tuple!(size_t, \"a\"\
    ) p) \n        {\n            return p[1].count == test.strip().split().length;\n\
    \        }).\n        map!((Tuple!(size_t, \"a\") p) \n        {\n           \
    \ return tuple(p[1].value, p[0]);\n        }).\n        array.\n        nullable;\n\
    }", "{\n    if (test.empty) return ___null_dict___;\n    auto str = test.split();\n\
    \    long[string] letterCounts;\n    foreach (chr; str) {\n        if (letterCounts.byKey.contains(chr))\
    \ letterCounts[chr]++;\n        else letterCounts[chr] = 1;\n    }\n    long max\
    \ = maxElement(letterCounts.values);\n    return array(filter!(l =&gt; l.value\
    \ == max)(letterCounts.byKey)).nullable;\n}", "{\n    long[string] dict = new\
    \ long[string];\n    if(test == \"\") \n    {\n        return ___null_dict___;\n\
    \    }\n    foreach(t; test.split(\" \")) \n    {\n        dict[t] += 1L;\n  \
    \  }\n    int highest = 0;\n    string[] keys = [];\n    foreach(t; dict) \n \
    \   {\n        if(t.value > highest) \n        {\n            highest = t.value;\n\
    \            keys = [t.key];\n        }\n        else if(t.value == highest) \n\
    \        {\n            keys ~= t.key;\n        }\n    }\n    //keys are now all\
    \ the keys with the highest number of occurrence\n    long[string] res = new long[string];\n\
    \    foreach(t; keys) \n    {\n        res[t] = dict[t];\n    }\n    return res;\n\
    }", "{\n    import std.algorithm;\n    import std.array;\n    import std.conv;\n\
    \    import std.range;\n    import std.string;\n    import std.typecons;\n   \
    \ import std.uni;\n    import std.utf;\n    // Type checked.\n    // Sometimes\
    \ you may have to specifiy the return type.\n    Nullable!(long[string]) ret =\
    \ Nullable!(long[string])().init;\n    test = strip(test);\n    if (test.length\
    \ == 0) \n    {\n        return ret;\n    }\n    ulong[] occurences = new ulong[test.length];\n\
    \    long[] counts = new long[test.length];\n    long max = 0;\n    long maxCount\
    \ = 0;\n    long i = 0;\n    foreach (char c; test) \n    {\n        ulong o =\
    \ c.isLower;\n        occurences[i] = o;\n        if (o != 0) \n        {\n  \
    \          counts[o] += 1;\n            if (counts[o] > maxCount) \n         \
    \   {\n                maxCount = counts[o];\n                max = o;\n     \
    \       }\n        }\n        i += 1;\n    }\n    // ditto\n    if (maxCount ==\
    \ 0) \n    {\n        return ret;\n    }\n    ret.get().length = 2;\n    // We\
    \ cannot initialize just like this, because\n    // you cannot initialize an associative\
    \ array.\n    // foreach (c; occurences)\n    // {\n    //     if (c == max)\n\
    \    //     {\n    //         ret.get()[c] = counts[c];\n    //     }\n    //\
    \ }\n    // So we have to do it step by step\n    foreach (c; occurences) \n \
    \   {\n        if (c == max) \n        {\n            ret.get()[c] = counts[c];\n\
    \        }\n    }\n    // if you want to initialize on the fly,\n    // use the\
    \ following constructor\n    // ret.get() = [max: counts[max]];\n    return ret;\n\
    }", "{\n    import std.array : array;\n    import std.algorithm : max, equal;\n\
    \    import std.range : iota;\n    import std.stdio;\n    import std.string :\
    \ split;\n    import std.typecons : Nullable;\n    Nullable!(long[string]) nd;\n\
    \    string[] words = test.split;\n    long[] cnt;\n    foreach(i, word; words)\n\
    \    {\n        cnt[word]++;\n    }\n    long max = cnt.max;\n    auto index =\
    \ iota(cnt.length).filter!(i => cnt[i] == max);\n    if(index.length == 1)\n \
    \   {\n        nd = Nullable!(long[string])(cnt[index[0]]);\n    } else\n    {\n\
    \        nd = Nullable!(long[string])(index.map!(i => cnt[i]).array);\n    }\n\
    \    return nd;\n}", "{\n    Nullable!(long[string]) reval = null;\n    long[string]\
    \ histogram_dict = new long[string];\n    string[] letters = test.split(\" \"\
    );\n    for (size_t i = 0; i < letters.length; i++)\n    {\n        if (histogram_dict.count(letters[i])\
    \ != 0)\n        {\n            histogram_dict[letters[i]] += 1;\n        } else\
    \ {\n            histogram_dict[letters[i]] = 1;\n        }\n    }\n    if (histogram_dict.length\
    \ == 0)\n    {\n        return reval;\n    }\n    long max_count = histogram_dict.values[0];\n\
    \    foreach (val; histogram_dict.values)\n    {\n        if (val > max_count)\n\
    \        {\n            max_count = val;\n        }\n    }\n    long[string] max_count_dict\
    \ = new long[string];\n    foreach (key, val; histogram_dict)\n    {\n       \
    \ if (val == max_count)\n        {\n            max_count_dict[key] = val;\n \
    \       }\n    }\n    return max_count_dict;\n}", "{\n    import std.array;\n\
    \    import std.algorithm;\n    import std.range;\n    import std.conv;\n    import\
    \ std.string;\n    import std.stdio;\n    import std.array;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.math;\n    import std.conv;\n    import\
    \ std.typecons;\n    import std.exception;\n    Nullable!(long[string]) max_hist_key_dict(in\
    \ Nullable!(long[string]) mhd) \n    {\n        static if (is (typeof(mhd.ptr)))\
    \ \n        {\n            auto map_it = mhd.ptr;\n            if (map_it.length\
    \ > 0) \n            {\n                //std.algorithm.sort!\"a.value > b.value\"\
    (map_it);\n                long max_count = map_it[0].value;\n               \
    \ return map_it.filter!\"a.value == max_count\".idup;\n            }\n       \
    \ }\n        return ___null_dict___;\n    }\n    Nullable!(long[string]) curr_hist_key_dict(in\
    \ Nullable!(long[string]) chd, string key) \n    {\n        if (chd.isNull) \n\
    \        {\n            return null;\n        }\n        auto map_it = chd.ptr;\n\
    \        if (map_it.length > 0) \n        {\n            if (map_it.canFind(key))\
    \ \n            {\n                map_it[key]++;\n            }\n           \
    \ else \n            {\n                map_it[key] = 1L;\n            }\n   \
    \     }\n        return map_it;\n    }\n    Nullable!(long[string]) curr_hist_key_dict_null(in\
    \ Nullable!(long[string]) chd, string key) \n    {\n        if (chd.isNull) \n\
    \        {\n            auto map_it = new long[string];\n            map_it[key]\
    \ = 1L;\n            return map_it;\n        }\n        return curr_hist_key_dict(chd,\
    \ key);\n", "{\n    long[string] ret;\n    long len = test.length;\n    long max\
    \ = 0;\n    long[string] max_keys;\n    if (len > 0)\n    {\n        foreach (key;\
    \ test.split())\n        {\n            if (ret.contains(key))\n            {\n\
    \                ret[key]++;\n            }\n            else\n            {\n\
    \                ret[key] = 1;\n            }\n            if (ret[key] > max)\n\
    \            {\n                max = ret[key];\n                max_keys = [];\n\
    \                max_keys[key] = max;\n            }\n            else if (ret[key]\
    \ == max)\n            {\n                max_keys[key] = max;\n            }\n\
    \        }\n    }\n    return max_keys.nullable;\n}", "{\n    auto v = test.split;\n\
    \    return v.walkLength \n        ? v.walkLength.reduce!((a,b) => a.count > b.count\
    \ ? a : b)\n        : null;\n}", "{\n    long[] a;\n    foreach(c; test.split())\n\
    \    {\n        a[c]++;\n    }\n    long max = 0;\n    long[] b;\n    foreach(c;\
    \ a.keys)\n    {\n        if(a[c] > max)\n        {\n            max = a[c];\n\
    \            b = new long[string][];\n            b[c] = a[c];\n        }\n  \
    \      else if(a[c] == max)\n        {\n            b[c] = a[c];\n        }\n\
    \    }\n    return b;\n}", "{\n    string [] words = test.split(cast(string[])[\"\
    \ \"]);\n    long[string] histo = new long[string];\n    foreach(word; words)\n\
    \    {\n        histo[word] += 1L;\n    }\n    long maxValue = 0L;\n    foreach(key,\
    \ value; histo)\n    {\n        if(value > maxValue)\n        {\n            maxValue\
    \ = value;\n        }\n    }\n    string[] maxKeys = new string[];\n    foreach(key,\
    \ value; histo)\n    {\n        if(value == maxValue)\n        {\n           \
    \ maxKeys ~= key;\n        }\n    }\n    if(maxKeys.length == 0)\n    {\n    \
    \    return ___null_dict___;\n    }\n    long[string] result = new long[string];\n\
    \    foreach(key; maxKeys)\n    {\n        result[key] = maxValue;\n    }\n  \
    \  return result;\n}", "{\n    Nullable!(long[string]) retValue = Nullable!(long[string])(true);\n\
    \    int i = 0;\n    int len = test.length;\n    int j = 0;\n    string[] letters\
    \ = new string[len];\n    letters = test.split(\" \");\n    bool found = false;\n\
    \    if (letters.length == 0)\n    {\n        return ___null_dict___;\n    }\n\
    \    for (int k = 0; k < letters.length; k++)\n    {\n        for (i = 0; i <\
    \ len; i++)\n        {\n            for (j = i + 1; j < len; j++)\n          \
    \  {\n                if (letters[i] == letters[j])\n                {\n     \
    \               if (!retValue.containsKey(letters[i]))\n                    {\n\
    \                        retValue[letters[i]] = 0;\n                    }\n  \
    \                  retValue[letters[i]]++;\n                    found = true;\n\
    \                }\n            }\n        }\n    }\n    return retValue;\n}",
  "{\n    if (test.empty)\n        return ___null_dict___;\n    long[string] max;\n\
    \    long[string] count;\n    foreach (elem; test.split(\" \"))\n    {\n     \
    \   if (!count.contains(elem))\n            count[elem] = 1;\n        else\n \
    \           count[elem]++;\n    }\n    long maxValue = 0;\n    foreach (elem;\
    \ count)\n    {\n        if (elem.value == maxValue)\n            max[elem.key]\
    \ = elem.value;\n        else if (elem.value > maxValue)\n        {\n        \
    \    maxValue = elem.value;\n            max = [ elem.key : elem.value ];\n  \
    \      }\n    }\n    return Nullable!(long[string])(max);\n}", "{\n    // return\
    \ histogram(test.split(\" \"));\n    auto words = test.split(\" \");\n    if (words.length\
    \ == 0)\n        return null;\n    auto result = new long[string];\n    foreach\
    \ (word; words)\n    {\n        long count = 0;\n        foreach (w; words)\n\
    \        {\n            if (w == word)\n                count++;\n        }\n\
    \        result[word] = count;\n    }\n    return result;\n}", "{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.range;\n    import std.stdio;\n\
    \    import std.string;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n",
  "pure nothrow \n{\n    return test.split(' ').frequency.filter!((k,v) => v == test.split('\
    \ ').frequency.values.max).nullable;\n}", "{\n    // read the characters into\
    \ an array\n    import std.algorithm;\n    import std.array;\n    import std.range;\n\
    \    // count the number of characters\n    // char[] temp = test.dup;\n    //\
    \ auto s = temp.dedup;\n    // auto result = s.map!(a => test.countUntil(a)).array;\n\
    \    // return result.assocArray.nullable;\n    auto temp = test.split(\" \");\n\
    \    auto result = temp.enumerate.map!(a => a.value.countUntil(a.index.to!string));\n\
    \    return result.assocArray.nullable;\n}", "{\n    import std.algorithm : reduce,\
    \ max, equal;\n    import std.array : iota;\n    import std.range : zip;\n   \
    \ import std.typecons : tuple;\n    import std.conv : to;\n    import std.typecons\
    \ : Nullable;\n    string[] split_test = test.split;\n    long[string] tally;\n\
    \    foreach(str; split_test)\n    {\n        tally[str]++;\n    }\n    long max\
    \ = tally.values.max;\n    string[] keys = (tally.keys.length == 0) ? \"\": tally.keys[iota(tally.keys.length)];\n\
    \    long[] values = (tally.values.length == 0) ? 0L : tally.values[iota(tally.values.length)];\n\
    \    Nullable!(long[string]) the_return;\n    foreach(t; zip(keys, values))\n\
    \    {\n        if(t[1] == max)\n        {\n            the_return[t[0]] = t[1];\n\
    \        }\n    }\n    return the_return;\n}", "{\n    return test.split.histogram;\n\
    }\npublic static void main(string[] args) \n{\n    assert (histogram(\"a b c\"\
    ) == [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable);\n    assert (histogram(\"a b\
    \ b a\") == [\"a\": 2L, \"b\": 2L].nullable);\n    assert (histogram(\"a b c a\
    \ b\") == [\"a\": 2L, \"b\": 2L].nullable);\n    assert (histogram(\"b b b b a\"\
    ) == [\"b\": 4L].nullable);\n    assert (histogram(\"\") == ___null_dict___);\n\
    }", "{\n    Nullable!(long[string]) result = typeof(result)();\n    if(test.length\
    \ == 0)\n        return result;\n    bool[string] alphabet = typeof(alphabet)();\n\
    \    int[string] dict = typeof(dict)();\n    foreach(const character; test.split)\n\
    \    {\n        if(!alphabet.contains(character))\n        {\n            alphabet[character]\
    \ = true;\n            dict[character] = 1;\n        }\n        else\n       \
    \     dict[character] += 1;\n    }\n    int maxOccurence = 0;\n    foreach(const\
    \ key, const value; dict)\n    {\n        if(value == maxOccurence)\n        \
    \    result.get.insert(key, value);\n        else if(value > maxOccurence)\n \
    \       {\n            maxOccurence = value;\n            result = typeof(result)();\n\
    \            result.get.insert(key, value);\n        }\n    }\n    return result;\n\
    }", "{\n    /*\n        This function uses the associative array to count the\
    \ number of repetitions\n        I have used a Nullable type in case the input\
    \ is an empty string\n    */\n    Nullable!(long[string]) dict = Nullable!(long[string]).init;\n\
    \    foreach(letter; test.splitter(\" \"))\n    {\n        if(letter == \"\")\
    \ continue;\n        if(auto d = dict.get)\n        {\n            if(d.get.keyExists(letter))\
    \ \n            {\n                dict.get.set(letter, d.get[letter] + 1);\n\
    \            }\n            else\n            {\n                dict.get.set(letter,\
    \ 1);\n            }\n        }\n        else\n        {\n            dict.set\
    \ = long[string]().init;\n            dict.get.set(letter, 1);\n        }\n  \
    \  }\n    if(auto d = dict.get)\n    {\n        return dict;\n    }\n    else\n\
    \    {\n        return ___null_dict___;\n    }\n}", "{\n    auto result = [[\"\
    b\", 0], [\"a\", 0], [\"c\", 0]];\n    string[] chars = test.split(\" \");\n \
    \   foreach(c; chars)\n    {\n        result[c]++;\n    }\n    long max = max(result.values);\n\
    \    return filter!(key => result[key] == max)(result).keys.nullable;\n}", "{\n\
    \    long[string] letter_counts;\n    foreach(ch; test.split())\n    {\n     \
    \   letter_counts[ch]++;\n    }\n    if(letter_counts.empty) return null;\n  \
    \  long max_count = max(letter_counts.values);\n    return filter!(item => item.value\
    \ == max_count)(letter_counts).assumeUnique;\n}", "{\n    int[string] count_list;\n\
    \    foreach(x; test.split()) \n    {\n        if(count_list.count(x) == 0) \n\
    \        {\n            count_list[x] = 1;\n        } \n        else \n      \
    \  {\n            count_list[x] += 1;\n        }\n    }\n    count_list = count_list.filter!(a\
    \ => a.value > 1);\n    if(count_list.length == 0) \n    {\n        return null;\n\
    \    }\n    return count_list;\n}", "{\n    //\"b b b b a b b\"\n    //[\"b\"\
    \ : [0,2,4,6,8,10]]\n    //[\"a\" : [5]]\n    //if (auto result = in_array(\"\
    a\", test.split(\" \"))[0]);\n    Nullable!(long[string]) nullableDict;\n    auto\
    \ words = test.split(\" \");\n    bool[string] found;\n    bool[string] max;\n\
    \    int[string]count;\n    bool first = true;\n    long maxCount = 0;\n    foreach(i,\
    \ word; words)\n    {\n        if (count.count(word))\n        {\n           \
    \ count[word]++;\n        }\n        else\n        {\n            count[word]\
    \ = 1;\n        }\n        if (first)\n        {\n            max[word] = true;\n\
    \            first = false;\n            maxCount = count[word];\n        }\n\
    \        else\n        {\n            if (count[word] == maxCount)\n         \
    \   {\n                max[word] = true;\n            }\n            else if (count[word]\
    \ > maxCount)\n            {\n                max.clear();\n                max[word]\
    \ = true;\n                maxCount = count[word];\n            }\n        }\n\
    \        found[word] = true;\n    }\n    if (max.count != 0)\n    {\n        nullableDict\
    \ = Nullable!(long[string])(maxCount);\n        foreach(word; max)\n        {\n\
    \            nullableDict.data[word] = maxCount;\n        }\n    }\n    return\
    \ nullableDict;\n}\n/*\nA simple and somewhat naive hashing function which adds\
    \ the square of each character value in a string.", "{\n    enum numberToLookFor\
    \ = test.split().map!(a => a.length).max;\n    return test.split().filter!(a =>\
    \ a.length == numberToLookFor).map!(a => a.length).assocArray.nullable;\n}", "{\n\
    \    Nullable!(long[string]) ret = null;\n    long[] hist =  new long[string];\n\
    \    size_t testLen = test.length;\n    size_t counter;\n    if (testLen == 0)\
    \ \n    {\n        return ret;\n    }\n    test.length = testLen - 1;\n    for\
    \ (counter = 0; counter < testLen; counter++) \n    {\n        char letter = test[counter];\n\
    \        if (letter >= 'a' && letter <= 'z') \n        {\n            letter =\
    \ letter - 'a';\n            if (letter in hist) \n            {\n           \
    \     hist[letter]++;\n            }\n            else \n            {\n     \
    \           hist[letter] = 1;\n            }\n        }\n    }\n    auto highest\
    \ = hist.values.max();\n    foreach (key, value; hist) \n    {\n        if (value\
    \ == highest) \n        {\n            ret.insert(key, value);\n        }\n  \
    \  }\n    return ret;\n}\n// void main(string[] args) \n// {\n//     Nullable!(long[string])\
    \ result = histogram(\"b b b b a\");\n//     writeln(result);\n// }", "{\n   \
    \ Nullable!(long[string]) array = Nullable!(long[string])(null);\n    if (test\
    \ == \"\")\n    {\n        return array;\n    }\n    string[] letters = test.split(\"\
    \ \");\n    array = Nullable!(long[string])(long[string]());\n    array.get!(long[string])().[]\
    \ = 0L;\n    for (i, letter; i < letters.length; i++)\n    {\n        //DLog.format(\"\
    i = {}, letter = {}\", i, letter);\n        if (array.get!(long[string])().keyExists(letter))\n\
    \        {\n            array.get!(long[string])().set(letter, array.get!(long[string])().get(letter)\
    \ + 1L);\n        }\n        else\n        {\n            array.get!(long[string])().set(letter,\
    \ 1L);\n        }\n    }\n    //DLog.format(\"array = {}\", array);\n    long\
    \ greatest = long.min;\n    foreach (a; array.get!(long[string])().keys)\n   \
    \ {\n        if (array.get!(long[string])().get(a) > greatest)\n        {\n  \
    \          greatest = array.get!(long[string])().get(a);\n        }\n    }\n \
    \   //DLog.format(\"greatest = {}\", greatest);\n    string[] keys = array.get!(long[string])().keys;\n\
    \    long[] values = array.get!(long[string])().values;\n    for (i, key; i <\
    \ keys.length; i++)\n    {\n        if (values[i] != greatest)\n        {\n  \
    \          array.get!(long[string])().remove(key);\n        }\n    }\n    //DLog.format(\"\
    histogram = {}\", array);\n    return array;\n}", "{\n    if (test.empty)\n  \
    \      return ___null_dict___;\n    immutable string[] letters = test.split(isAlpha);\n\
    \    long[string] counts;\n    foreach (l; letters)\n    {\n        auto count\
    \ = counts[l];\n        counts[l] = count.defined ? count + 1 : 1;\n    }\n  \
    \  alias letters = keys(counts);\n    long max = maxElement(counts.values);\n\
    \    Nullable!(long[string]) result = Nullable!(long[string]).init;\n    foreach\
    \ (l; letters)\n    {\n        if (counts[l] == max)\n            result.associate(l,\
    \ counts[l]);\n    }\n    return result;\n}\n/*\nGiven a string representing a\
    \ space separated lowercase letters, return an associative array\n    of the letter\
    \ with the most repetition and containing the corresponding count.\n    If several\
    \ letters have the same occurrence, return all of them.\n    \n    Example:\n\
    \    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "{ \n    Nullable!(long[string]) result = null;\n    if (test.length == 0) return\
    \ null;\n    long[] counters = new long[test.length];\n    int i = 0;\n    long[string]\
    \ letters = new long[string]();\n    foreach (ch; test) \n    {\n        auto\
    \ letter = ch.toString();\n        if (letters.contains(letter)) \n        {\n\
    \            auto count = letters[letter];\n            ++count;\n           \
    \ letters[letter] = count;\n        }\n        else\n        {\n            letters[letter]\
    \ = 1L;\n        }\n        counters[i] = letters[letter];\n        ++i;\n   \
    \ }\n    long maxValue = counters[0];\n    int j = 0;\n    foreach (value; counters)\
    \ \n    {\n        if (value > maxValue) maxValue = value;\n        ++j;\n   \
    \ }\n    foreach (key, value; letters) \n    {\n        if (value == maxValue)\
    \ result[key] = value;\n    }\n    return result;\n}", "{\n    import std.range\
    \ : filter, maxElement, take, takeExactly;\n    import std.algorithm : map, split,\
    \ to;\n    import std.container : SortedRange;\n    import std.array : sorted;\n\
    \    import std.stdio : writeln;\n    import std.typecons : nullable;\n    import\
    \ std.range : count;\n    import std.algorithm : iota;\n    import std.internal.math.xmath\
    \ : ipow;\n    auto dict = test.split.groupBy!((a) => a).map!((a) => [a[0]: a.length]).array;\n\
    \    auto max = dict.maxElement!((a, b) => a[1] > b[1]).map!((a) => a[1]).front.nullable;\n\
    \    auto filtered = dict.filter!((a) => a[1] == max);\n    writeln(dict);\n \
    \   writeln(max);\n    writeln(filtered);\n    if (filtered.length > 1)\n    {\n\
    \        auto x = filtered.take(filtered.length).map!((a) => tuple(a[0], a[1])).filter!((a)\
    \ => a[1] == max).map!((a) => a[0]).iota(filtered.length);\n        writeln(x);\n\
    \        return x.array.sorted;\n    }\n    else if (filtered.length == 1)\n \
    \   {\n        return filtered.take(1).map!((a) => a[0]).array.sorted;\n    }\n\
    \    else \n    {\n        return null;\n    }\n}", "{\n    if (test.empty) return\
    \ null;\n    Nullable!(long[string]) ret = new long[string];\n    Nullable!long\
    \ max = null;\n    string[] ltest = test.split(\" \");\n    foreach (key; ltest)\
    \ \n    {\n        if (ret.contains(key)) \n        {\n            ret[key]++;\n\
    \        } \n        else \n        {\n            ret[key] = 1;\n        }\n\
    \        if (max.isNull || ret[key] > max) \n        {\n            max = ret[key];\n\
    \        }\n    }\n    Nullable!(long[string]) ret2 = new long[string];\n    foreach\
    \ (key; ret.keys) \n    {\n        if (ret[key] == max) \n        {\n        \
    \    ret2[key] = ret[key];\n        }\n    }\n    return ret2;\n}", "{\n    auto\
    \ foo = test.split(\" \");\n    long temp = 0;\n    long max;\n    long[string]\
    \ bar;\n    long[string] bar2;\n    string[] maxx;\n    long[] to_sort;\n    foreach(letter;\
    \ foo)\n    {\n        if(bar.count(letter) == 0)\n        {\n            bar[letter]\
    \ = 1;\n        }\n        else\n        {\n            bar[letter]++;\n     \
    \   }\n    }\n    foreach(value; bar.values)\n    {\n        to_sort ~= value;\n\
    \    }\n    to_sort.sort();\n    to_sort.reverse;\n    max = to_sort[0];\n   \
    \ foreach(key, value; bar)\n    {\n        if(value == max)\n        {\n     \
    \       maxx ~= key;\n        }\n    }\n    maxx.sort;\n    foreach(item; maxx)\n\
    \    {\n        bar2[item] = max;\n    }\n    return bar2.nullable;\n}", "{\n\
    \    if (test.empty) return ___null_dict___;\n    long[string] d = [\"a\":1L];\n\
    \    d.test = 1L;\n    return d;\n}", "{\n    Nullable!(long[string]) null_dict;\n\
    \    if (test.empty) \n    {\n        return null_dict;\n    }\n    long[string]\
    \ result = ['a': 0L, 'b': 0L, 'c': 0L, 'd': 0L, 'e': 0L, 'f': 0L, 'g': 0L, 'h':\
    \ 0L, 'i': 0L, 'j': 0L, 'k': 0L, 'l': 0L, 'm': 0L, 'n': 0L, 'o': 0L, 'p': 0L,\
    \ 'q': 0L, 'r': 0L, 's': 0L, 't': 0L, 'u': 0L, 'v': 0L, 'w': 0L, 'x': 0L, 'y':\
    \ 0L, 'z': 0L];\n    immutable letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z'];\n    foreach (char; test) \n    {\n        if (char in letters) \n\
    \        {\n            result[char]++;\n        }\n    }\n    long max = result[test[0]];\n\
    \    foreach (key, value; result) \n    {\n        if (value > max) \n       \
    \ {\n            max = value;\n        }\n    }\n    Nullable!(long[string]) res\
    \ = Nullable!(long[string])(['a': 0L, 'b': 0L, 'c': 0L, 'd': 0L, 'e': 0L, 'f':\
    \ 0L, 'g': 0L, 'h': 0L, 'i': 0L, 'j': 0L, 'k': 0L, 'l': 0L, 'm': 0L, 'n': 0L,\
    \ 'o': 0L, 'p': 0L, 'q': 0L, 'r': 0L, 's': 0L, 't", "{\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.range;\n    import std.algorithm;\n    import std.ascii;\n\
    \    import std.datetime;\n    import std.stdio;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.math;\n    import std.typecons;\n    import std.algorithm;\n\
    \    import std.ascii;\n    import std.range;\n    import std.math;\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.math;\n    import std.algorithm;\n    import std.math;\n    import std.typecons;\n\
    \    // first we create a list of unique letters\n    string[] res;\n    auto\
    \ words = test.split(\" \");\n    // res.put(\"a\", 1);\n    // res.put(\"b\"\
    , 1);\n    foreach(i, w; words)\n    {\n        //std.datetime.stopWatch sw;\n\
    \        // sw.start();\n        bool found = false;\n        foreach(j, r; res)\n\
    \        {\n            if(w == r)\n            {\n                // sw.stop();\n\
    \                // sw.reset();\n                found = true;\n             \
    \   break;\n            }\n        }\n        if(!found)\n        {\n        \
    \    // sw.stop();\n            // sw.reset();\n            res ~= w;\n      \
    \  }\n        //std.stdio.writeln(to!string(sw.peek()));\n    }\n    // then we\
    \ create a dictionary of these letters and their corresponding counts\n    auto\
    \ occs = res.map!(r => [r: words.count(r)]).array;\n    // finally we look at\
    \ the maximum count and return the correponding letters\n    auto maxOcc = reduce!max(occs.map!(o\
    \ => o.values[0]));\n    return res.filter!(r => words.count(r) == maxOcc).nullable;\n\
    }", "{ \n    import std.array;\n    long[string] ret = null;\n    if (test.empty)\
    \ return ret;\n    string[] letters = test.split(\" \");\n    int[] cnt = new\
    \ int[letters.length];\n    cnt[] = 0;\n    foreach ( i, letter; letters)\n  \
    \  {\n        foreach (j, ltr; letters)\n        {\n            if (ltr == letter)\
    \ cnt[i]++;\n        }\n    }\n    int max = cnt[0];\n    foreach (i, c; cnt)\n\
    \    {\n        if (c > max) max = c;\n    }\n    ret = new long[string];\n  \
    \  foreach (i, c; cnt)\n    {\n        if (c == max)\n        {\n            ret[letters[i]]\
    \ = c;\n        }\n    }\n    return ret;\n}", "{\n    auto result = Nullable!(long[string]).init;\n\
    \    if (test.length) \n    {\n        import std.algorithm.comparison : max;\n\
    \        auto split = test.split(\" \");\n        auto group = split.group;\n\
    \        auto maxSize = group.max!\"a.length\"().length;\n        foreach (k,\
    \ v; group) \n        {\n            if (maxSize == v.length)\n              \
    \  result.assign(k, v.length);\n        }\n    }\n    return result;\n}", "{\n\
    \    auto counter = test.split;\n    auto result = counter.group().select!((e)\
    \ => e.length > 1).array();\n    if (result.length) \n    {\n        auto max\
    \ = result.max!((e) => e.length);\n        auto ids = result.filter!((e) => e.length\
    \ == max.length).map!((e) => e[0]);\n        return ids.array().assocArray.nullable;\n\
    \    }\n    return ___null_dict___;\n}", "{\n    long[string] data;\n    foreach(elem;\
    \ test.split)\n    {\n        if(elem.length == 0)\n            continue;\n  \
    \      if(data.keyExists(elem))\n            data[elem]++;\n        else\n   \
    \         data[elem] = 1;\n    }\n    if(data.empty)\n        return Nullable!(long[string])();\n\
    \    long max_value = data.values.max;\n    long[string] max_dict;\n    foreach(key,value;\
    \ data)\n    {\n        if(value == max_value)\n            max_dict[key] = value;\n\
    \    }\n    return Nullable!(long[string])(max_dict);\n}", "{\n    Nullable!(long[string])\
    \ nullable_result;\n    long[string] histogram_map;\n    // split the input string\
    \ into it's separate elements\n    string[] words = test.split;\n    int len =\
    \ words.length;\n    string curr_word;\n    long count;\n    int i;\n    int j;\n\
    \    int max_count = 0;\n    string max_word;\n    int max_index;\n    // initialize\
    \ the histogram_map with null values for each word\n    for (i = 0; i < len; i++)\n\
    \    {\n        curr_word = words[i];\n        histogram_map[curr_word] = null;\n\
    \    }\n    // fill the histogram_map with values for each word\n    for (i =\
    \ 0; i < len; i++)\n    {\n        curr_word = words[i];\n        count = 0;\n\
    \        for (j = 0; j < len; j++)\n        {\n            if (words[j] == curr_word)\n\
    \            {\n                count++;\n            }\n        }\n        histogram_map[curr_word]\
    \ = count;\n    }\n    // initialize the max_word to be used in the search for\
    \ the max_count\n    for (string key = histogram_map.keys[0]; !key.empty; key\
    \ = histogram_map.keys[key.indexOf(key) + 1])\n    {\n        max_word = key;\n\
    \        break;\n    }\n    // find the max_count and the max_word\n    for (string\
    \ key = histogram_map.keys[0]; !key.empty; key = histogram_map.keys[key.indexOf(key)\
    \ + 1])\n    {\n        max_index = max_word.indexOf(max_word);\n        max_count\
    \ = histogram_map[max_word];\n        if (histogram_map[key] > max_count)\n  \
    \      {\n            max_word = key;\n            max_count = histogram_map[key];\n\
    \        }\n    }\n    // fill the nullable_result with the max_word and max_count\n\
    \    for (string key =", "{\n    long[string] hist;\n    foreach( ch; test.split)\
    \ {\n        if (ch != \"\") {\n            if (hist.containsKey(ch))\n      \
    \          hist[ch]++;\n            else\n                hist[ch] = 1;\n    \
    \    }\n    }\n    return hist.empty ? null : typeof(return).init;\n}", "{\n \
    \   if (test.empty) \n    {\n        return typeof(return)();\n    }\n    string[]\
    \ letters = test.split();\n    long[string] counts;\n    foreach (letter; letters)\
    \ \n    {\n        if (counts.count(letter) != 0) \n        {\n            counts[letter]\
    \ += 1;\n        } \n        else \n        {\n            counts[letter] = 1;\n\
    \        }\n    }\n    long maxCount = max(counts.values);\n    long[string] maxCounts;\n\
    \    foreach (count; counts) \n    {\n        if (count[1] == maxCount) \n   \
    \     {\n            maxCounts[count[0]] = count[1];\n        }\n    }\n    return\
    \ typeof(return)(maxCounts);\n}\n/*\nA small frog wants to get to the other side\
    \ of a river. The frog is initially located on one bank of the river (position\
    \ 0) and wants to get to the opposite bank (position X+1). Leaves fall from a\
    \ tree onto the surface of the river.", "{\n    long[string] count;\n    long\
    \ highest = 0;\n    string[] keys;\n    foreach(ele; test.split(' '))\n    {\n\
    \        count[ele]++;\n        if(count[ele] >= highest)\n        {\n       \
    \     highest = count[ele];\n        }\n    }\n    foreach(ele; test.split(' '))\n\
    \    {\n        if(count[ele] == highest)\n        {\n            keys ~= ele;\n\
    \        }\n    }\n    if(keys.length == 0)\n    {\n        return null;\n   \
    \ }\n    return keys;\n}\n/*\n    >>> histogram([\"a\", \"b\", \"c\"])\n    [\"\
    a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram([\"a\", \"b\", \"b\"\
    , \"a\"])\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram([\"a\", \"b\"\
    , \"c\", \"a\", \"b\"])\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram([\"\
    b\", \"b\", \"b\", \"b\", \"a\"])\n    [\"b\": 4L].nullable\n    >>> histogram([])\n\
    \    ___null_dict___\n*/\nNullable!(long[string]) histogram(string[] test) \n\
    {\n    long[string] count;\n    long highest = 0;\n    string[] keys;\n    foreach(ele;\
    \ test)\n    {\n        count[ele]++;\n        if(count[ele] >= highest)\n   \
    \     {\n            highest = count[ele];\n        }\n    }\n    foreach(ele;\
    \ test)\n    {\n        if(count[ele] == highest)\n        {\n            keys\
    \ ~= ele;\n        }\n    }\n    if(keys.length == 0)\n    {\n        return null;\n\
    \    }\n    return keys;\n}\n/*\n    Take two string arrays, return a tuple of\
    \ two long arrays, where array one contains\n    the count of each element of\
    \ array one in array two, and array two contains the count\n    of each element\
    \ of array two in array one", "{\n    long max = 0;\n    Nullable!(long[string])\
    \ r = null;\n    long[string] occurrences;\n    foreach(char c; test)\n    {\n\
    \        if(occurrences.count(c) == 0)\n        {\n            occurrences[c]\
    \ = 1;\n        }\n        else\n        {\n            occurrences[c]++;\n  \
    \      }\n        if(occurrences[c] > max)\n        {\n            max = occurrences[c];\n\
    \        }\n    }\n    foreach(string s; occurrences.keys)\n    {\n        if(occurrences[s]\
    \ == max)\n        {\n            if(r is null)\n            {\n             \
    \   r = occurrences;\n            }\n            else\n            {\n       \
    \         r[s] = occurrences[s];\n            }\n        }\n    }\n    return\
    \ r;\n}", "{\n    if (test.empty) return null;\n    Nullable!(long[string]) hist\
    \ = null;\n    long v;\n    long max = 0;\n    char[] tmp = test.toLower().split(\"\
    \\\\s+\");\n    string[] tmp2 = tmp.idup;\n    hist = new long[string];\n    foreach\
    \ (char c; tmp) {\n        v = ++hist[c];\n        if (v > max) {\n          \
    \  max = v;\n        }\n    }\n    return to(hist.byKeyValue.filter!(x => x.value\
    \ == max).keys);\n}\n/*\nNow rewrite the function, so that it can return the letters\
    \ by their order of appearance.\nIf the same letter appears several times in a\
    \ row, include in the count only one occurrence.\n    \n    >>> histogram(\"a\
    \ b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"\
    a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"b ba bb\")\n    [\"b\": 3L, \"a\"\
    : 1L, \"b\": 1L].nullable\n    >>> histogram(\"b b b\")\n    [\"b\": 1L].nullable\n\
    \    >>> histogram(\"\")\n    ___null_dict___\n*/\nNullable!(long[string]) histogram2(string\
    \ test) \n{\n    if (test.empty) return null;\n    Nullable!(long[string]) hist\
    \ = null;\n    long v;\n    long max = 0;\n    char[] tmp = test.toLower().split(\"\
    \\\\s+\");\n    string[] tmp2 = tmp.idup;\n    hist = new long[string];\n    char\
    \ last = tmp[0];\n    foreach (char c; tmp) {\n        if (c != last) {\n    \
    \        v = ++hist[c];\n            if (v > max) {\n                max = v;",
  "{\n    long[string] result;", "{\n    return null;\n}", "{ \n    if (test.empty)\
    \ \n        return null;\n    long[string] occurrences;\n    foreach (letter;\
    \ test.split)\n    {\n        occurrences[letter]++;\n    }\n    long[string]\
    \ results;\n    long max = 0;\n    foreach (letter, count; occurrences)\n    {\n\
    \        if (count > max)\n        {\n            max = count;\n            results.clear;\n\
    \        }\n        if (count == max)\n        {\n            results[letter]\
    \ = count;\n        }\n    }\n    return results;\n}", "{\n    auto hist = new\
    \ long[string];\n    foreach(letter; test.split)\n    {\n        auto key = letter;\n\
    \        hist[key]++;\n    }\n    long max = 0;\n    auto max_value = new long[string];\n\
    \    foreach(key, value; hist)\n    {\n        if(value > max)\n        {\n  \
    \          max = value;\n            max_value.clear;\n            max_value[key]\
    \ = value;\n        }\n        else if(value == max)\n        {\n            max_value[key]\
    \ = value;\n        }\n    }\n    return max_value.nullable;\n}", "in\n{\n   \
    \ assert(test.length > 0);\n}\nbody\n{\n    immutable aa = test.split;\n    immutable\
    \ bb = aa.join(\" \");\n    immutable cc = \" \".join(aa);\n    const d = new\
    \ SortedSet!string(aa);\n    return [\"\" : 1L].init;\n}", "{\n    import std.algorithm.iteration\
    \ : filter, maxElement, sort;\n    import std.array : splitter;\n    import std.conv\
    \ : to;\n    import std.range : map, retro;\n    import std.range.primitives :\
    \ isForwardRange;\n    import std.typecons : Tuple;\n    import std.typecons :\
    \ tuple;\n    import std.algorithm.comparison : equal;\n    import std.typecons\
    \ : Nullable;\n    import std.functional : unaryFun;\n    Nullable!(long[string])\
    \ dict ;\n    dict.writable = true;\n    dict.writable = null;\n    if (test ==\
    \ \"\" || test.length == 0) \n    {\n        dict.writable = null;\n        return\
    \ dict;\n    }\n    string[] letterCount = test.splitter(\" \").filter!(\"a\"\
    \ != \"b\").array;\n    long[] count = new long[letterCount.length];\n    foreach\
    \ (index, item; letterCount) \n    {\n        foreach (index2, item2; letterCount)\
    \ \n        {\n            if (item == item2) \n            {\n              \
    \  count[index]++;\n            }\n        }\n    }\n    Tuple!(long, string)[]\
    \ counts = new Tuple!(long, string)[count.length];\n    foreach (index, item;\
    \ counts) \n    {\n        counts[index] = tuple(count[index], letterCount[index]);\n\
    \    }\n    auto maxElement2 = maxElement!q{a[0] < b[0]}(counts);\n    Tuple!(long,\
    \ string)[] final = new Tuple!(long, string)[counts.length];\n    int index =\
    \ 0;\n    foreach (item; counts) \n    {\n        if (maxElement2[0] == item[0])\
    \ \n        {\n            final[index] = item;\n            index++;\n      \
    \  }\n    }\n    dict.writable = new long[][string](final.length);\n    foreach\
    \ (index, item; final) \n    {\n        dict.writable[index] = [item[1], item[0]];",
  "{\n    \n    long[string] occurrences;\n    long[string] occurrences_top;\n   \
    \ long max_occurrences = 0;\n    int index = 0;\n    string current_letter;\n\
    \    bool first_letter = true;\n    bool multiple_letters = false;\n    // If\
    \ there is no string input, return a null dictionary\n    if (test.length == 0)\n\
    \    {\n        return ___null_dict___;\n    }\n    // Iterate through each letter\
    \ in the string\n    foreach (i, letter; test)\n    {\n        current_letter\
    \ = test[i];\n        // On the first letter, initialize occurrences with a count\
    \ of 1 for that letter\n        if (first_letter)\n        {\n            occurrences[current_letter]\
    \ = 1;\n            first_letter = false;\n        }\n        // On subsequent\
    \ letters, if the letter has already been seen, add 1 to the count\n        else\
    \ if (occurrences.count(current_letter) > 0)\n        {\n            occurrences[current_letter]++;\n\
    \        }\n        // If the letter hasn't been seen, initialize the count to\
    \ 1\n        else\n        {\n            occurrences[current_letter] = 1;\n \
    \       }\n        // If the current letter has reached the maximum number of\
    \ occurrences, then record it\n        if (occurrences[current_letter] == max_occurrences)\n\
    \        {\n            occurrences_top[current_letter] = occurrences[current_letter];\n\
    \            multiple_letters = true;\n        }\n        // If the current letter\
    \ has exceeded the maximum number of occurrences, then reset the \n        //\
    \ top occurrences list to only contain the current letter, and update the max\
    \ occurrence\n        else if (occurrences[current_letter] > max_occurrences)\n\
    \        {\n            max_occurrences = occurrences[current_letter];\n     \
    \       occurrences_top.clear();\n            occurrences_top[current_letter]\
    \ = occurrences[current_letter];\n            multiple_letters = false;\n    \
    \    }\n        // Move to the next letter\n        index++;\n    }\n    // If\
    \ there are several letters with the maximum number of occurrences, return them\
    \ all,\n    // otherwise, return the single max occurrence\n    if (multiple_letters)\n\
    \    {", "{\n    return sort(test.split(\" \").array()).groupBy!((string a) =>\
    \ a).values.map!((string[] b) => b.length).max();\n}", "{\n    long[string] result\
    \ = null;\n    long[string] dict = long[string].init;\n    foreach(character;\
    \ test.toLower()) \n    {\n        if (character != ' ')\n        {\n        \
    \    dict[character]++;\n        }\n    }\n    long maxval = dict.values.max;\n\
    \    if (maxval == 0) \n    {\n        return null;\n    }\n    foreach(character;\
    \ dict.keys) \n    {\n        if (dict[character] == maxval) \n        {\n   \
    \         result[character] = maxval;\n        }\n    }\n    return result;\n\
    }\n/*\nDetermine whether a string is a palindrome or not.\n    Example:\n    >>>\
    \ isPalindrome(\"aa\")\n    true\n    >>> isPalindrome(\"aaabbb\")\n    false\n\
    \    >>> isPalindrome(\"abac\")\n    false\n    >>> isPalindrome(\"a\")\n    true\n\
    \    >>> isPalindrome(\"\")\n    true\n    >>> isPalindrome(\"abcbabcb\")\n  \
    \  true\n    >>> isPalindrome(\"abcba\")\n    true\n    >>> isPalindrome(\"abcbaabcba\"\
    )\n    true\n    >>> isPalindrome(\"a a\")\n    true\n    >>> isPalindrome(\"\
    ab cba\")\n    true\n*/", "{\n    import std.algorithm : max, min, maxElement,\
    \ minElement;\n    import std.array : array;\n    import std.range : map, iota,\
    \ filter, zip, unzip;\n    import std.conv : to;\n    import std.typecons : tuple;\n\
    \    Nullable!(long[string]) map;\n    static if(test.length)\n    {\n       \
    \ auto words = test.split();\n        string max = words[0];\n        words =\
    \ test.split();\n        auto wordsCount = words.map!(a => a.length).array;\n\
    \        auto maxCount = wordsCount[0];\n        foreach(i, a;words)\n       \
    \ {\n            map[a]++;\n        }\n        auto mapCount = map.values.array;\n\
    \        static if(mapCount.length > 1)\n        {\n            static if(mapCount.max\
    \ == mapCount.min)\n            {\n                return maxElements(map.byValue).map!(a\
    \ => a.key).array;\n            }\n            else\n            {\n         \
    \       return maxElements(map.byValue).map!(a => a.key).array[0..1];\n      \
    \      }\n        }\n        else\n        {\n            return mapCount[0];\n\
    \        }\n    }\n    else\n    {\n        return null;\n    }\n}\n ", "{\n \
    \   import std.algorithm;\n    import std.array;\n    import std.conv;\n    import\
    \ std.functional;\n    import std.range;\n    import std.unordered_map;\n    if\
    \ (test.empty) return ___null_dict___;\n    string[] test_arr = test.split;\n\
    \    unordered_map!(string, long) dict = test_arr.associate!(x => x, x => 0).array;\n\
    \    foreach (i; test_arr) \n    {\n        dict[i]++;\n    }\n    long max =\
    \ dict.values.max;\n    return dict.filter!(x => x.value == max).toArray.values;\n\
    }\n/*\nGiven a string representing a space separated lowercase letters, return\
    \ an associative array\n    of the letter with the most repetition and containing\
    \ the corresponding count.\n    If several letters have the same occurrence, return\
    \ all of them.\n    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"a\":\
    \ 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"\
    a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L,\
    \ \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n\
    \    >>> histogram(\"\")\n    ___null_dict___", "{\n    long[string] frequencies;\n\
    \    foreach(ch; test.split) \n    {\n        frequencies[ch]++;\n    }\n    long\
    \ maxFreq = frequencies.values.max;\n    if(maxFreq == 0)\n    {\n        return\
    \ ___null_dict___;\n    }\n    long[string] histo;\n    foreach(ch; frequencies.keys)\
    \ \n    {\n        if(frequencies[ch] == maxFreq) \n        {\n            histo[ch]\
    \ = maxFreq;\n        }\n    }\n    return histo.nullable;\n}", "{ \n    auto\
    \ counts = long[string](test.split);\n    auto reduced = counts.reduce!((a, b)\
    \ => a.length > b.length ? a : b);\n    if (reduced.length == 0) return null;\n\
    \    return reduced.reduce!((a, b) => a.value > b.value ? a : b).key.length;\n\
    }\n \n/*\n    sum function is defined in std.algorithm.iteration\n*/\nunittest\
    \ \n{\n    assert(histogram(\"a b c\") == 1);\n    assert(histogram(\"a b b a\"\
    ) == 2);\n    assert(histogram(\"a b c a b\") == 2);\n    assert(histogram(\"\
    b b b b a\") == 4);\n    assert(histogram(\"\") == null);\n}", "{\n    long[string]\
    \ m = new long[string]();\n    size_t len = test.length;\n    if(len != 0)\n \
    \   {\n        foreach(t; test.split)\n        {\n            m[t] += 1L;\n  \
    \      }\n    }\n    Nullable!(long[string]) res = Nullable!(long[string]).init;\n\
    \    long count = 0L;\n    foreach(t; m)\n    {\n        if(t.value > count)\n\
    \        {\n            count = t.value;\n            res.value = new long[string]();\n\
    \            res.value[t.key] = t.value;\n        }\n        else if(t.value ==\
    \ count)\n        {\n            res.value[t.key] = t.value;\n        }\n    }\n\
    \    return res;\n}", "{\n\tauto dict = TypeTuple!(string, long)[];\n\tforeach(unchecked\
    \ c; test) \n\t{\n\t\tbool found = false;\n\t\tforeach(unchecked int j, ref item;\
    \ dict) \n\t\t{\n\t\t\tif(item[0] == c) \n\t\t\t{\n\t\t\t\titem[1]++;\n\t\t\t\t\
    found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!found) \n\t\t{\n\t\t\t\
    append(dict, TypeTuple!(string, long)(c, 1L));\n\t\t}\n\t}\n\t\n\tauto max = TypeTuple!(string,\
    \ long)(\"\", 0L);\n\tforeach(unchecked item; dict) \n\t{\n\t\tif(item[1] > max[1])\
    \ \n\t\t{\n\t\t\tmax = item;\n\t\t}\n\t}\n\t\n\tNullable!(long[string]) nullableHistogram;\n\
    \tforeach(unchecked item; dict) \n\t{\n\t\tif(item[1] == max[1]) \n\t\t{\n\t\t\
    \tnullableHistogram.set(item[0], item[1]);\n\t\t}\n\t}\n\treturn nullableHistogram;\n\
    }", "{\n    if (test.empty) \n    {\n        return ___null_dict___;\n    }\n\
    \    import std.algorithm.iteration : map, maxElement;\n    import std.algorithm.comparison\
    \ : equal;\n    import std.range : takeExactly;\n    import std.typecons : Nullable;\n\
    \    import std.traits : ElementType;\n    import std.conv : to;\n    import std.stdio\
    \ : writeln;\n    //import std.meta : Filter;\n    auto testArray = test.split(\"\
    \ \");\n    enum firstLetter = testArray[0];\n    //auto testArray = test.split(\"\
    \ \").filter!(a => a.length == 1);\n    //writeln(testArray);\n    auto A = testArray.map!(a\
    \ => a.filter!(b => b == firstLetter).length).maxElement;\n    //writeln(A);\n\
    \    auto B = testArray.filter!(a => a.filter!(b => b == firstLetter).length ==\
    \ A);\n    //writeln(B);\n    auto C = testArray.filter!(a => a.filter!(b => b\
    \ == firstLetter).length != A);\n    //writeln(C);\n    auto D = B.map!(a => [a:\
    \ A]);\n    //writeln(D);\n    auto E = C.map!(a => a.filter!(b => b != firstLetter));\n\
    \    //writeln(E);\n    /*auto E = testArray.filter!(a => a.filter!(b => b !=\
    \ firstLetter))\n                .map!(a => a.filter!(b => b != firstLetter));*/\n\
    \    //writeln(E);\n    auto F = E.map!(a => a.takeExactly(a.length - 1));\n \
    \   //writeln(F);\n    auto G = F.map!(a => a.filter!(b => b == F[0]));\n    //writeln(G);\n\
    \    auto H = G.map!(a => a.length);\n    //writeln(H);\n    auto I = H.maxElement;\n\
    \    //writeln(I);\n    auto J = F.", "{\n    long[string] d = [:] ;\n    string[]\
    \ test = test.split ;\n    foreach(index, value; test)\n    {\n        if( value.length\
    \ > 0)\n        {\n            d[value]++ ;\n        }\n    }\n    Nullable!(long[string])\
    \ res ;\n    if(d.length > 0)\n    {\n        res = d ;\n    }\n    return res\
    \ ;\n}", "{\n    long[string] result;\n    foreach(char c; test)\n    {\n    \
    \    result[c] += 1L;\n    }\n    return result;\n}", "{\n    import std.algorithm\
    \ : max;\n    import std.array : max;\n    import std.range : iota;\n    import\
    \ std.range : empty;\n    import std.range : zip;\n    import std.range : map;\n\
    \    import std.range : filter;\n    import std.traits : isDynamicArray;\n   \
    \ import std.traits : isStaticArray;\n    import std.traits : isAssociativeArray;\n\
    \    import std.traits : isArray;\n    import std.traits : isInputRange;\n   \
    \ import std.traits : isOutputRange;\n    import std.traits : isForwardRange;\n\
    \    import std.traits : isBidirectionalRange;\n    import std.traits : isRandomAccessRange;\n\
    \    import std.traits : isInfinite;\n    import std.typecons : AliasSeq;\n  \
    \  import std.typecons : is;\n    import std.conv : to;\n    import std.array\
    \ : array;\n    import std.algorithm : max;\n    import std.algorithm : maxElement;\n\
    \    import std.algorithm : equal;\n    import std.algorithm : count;\n    import\
    \ std.algorithm : countUntil;\n    import std.algorithm : countUntil;\n    import\
    \ std.algorithm : countUntil;\n    import std.algorithm : replace;\n    import\
    \ std.algorithm : replaceUntil;\n    import std.algorithm : replaceInPlace;\n\
    \    import std.algorithm : replaceInPlaceUntil;\n    import std.algorithm : copy;\n\
    \    import std.algorithm : copyUntil;\n    import std.algorithm : fill;\n   \
    \ import std.algorithm : fillUntil;\n    import std.algorithm : move;\n    import\
    \ std.algorithm : moveUntil;\n    import std.algorithm : swap;\n    import std.algorithm\
    \ : generate;\n    import std.algorithm : generateUntil;\n    import std.algorithm\
    \ : formatValue;\n    import std.algorithm : find;\n    import std.algorithm :\
    \ findUntil;\n    import std.algorithm : findIn;\n    import std.algorithm : findInUntil;\n\
    \    import std.algorithm : findSplit", "{\n    if (test.empty)\n        return\
    \ ___null_dict___;\n    long[string] count;\n    foreach (c; test.split)\n   \
    \ {\n        count[c]++;\n    }\n    long max = maxElement(count.values);\n  \
    \  Nullable!(long[string]) result = typeof(result)();\n    foreach (c; count.keys)\n\
    \    {\n        if (count[c] == max)\n            result[c] = max;\n    }\n  \
    \  return result;\n}", "{\n    Nullable!(long[string]) _histo = Nullable!(long[string]).init;\n\
    \    _histo.isValid = true;\n    foreach(character; test)\n    {\n        if (character\
    \ != ' ')\n        {\n            if (_histo.data.count(character) == 0)\n   \
    \         {\n                _histo.data[character] = 1L;\n            }\n   \
    \         else\n            {\n                _histo.data[character] += 1L;\n\
    \            }\n        }\n    }\n    if (_histo.data.length == 0)\n    {\n  \
    \      _histo.isValid = false;\n    }\n    return _histo;\n}", "{\n    import\
    \ std.algorithm;\n    Nullable!(long[string]) nullable;\n    if (test.empty)\n\
    \    {\n        return nullable;\n    }\n    test = test.strip;\n    auto x =\
    \ test.split(\" \");\n    auto y = x.groupBy!((a) => a);\n    long temp1 = 0;\n\
    \    long[] temp2;\n    long[string] a;\n    foreach (item; y)\n    {\n      \
    \  auto temp = item.value.length;\n        if (temp > temp1)\n        {\n    \
    \        temp1 = temp;\n            temp2 = item.value;\n        }\n        if\
    \ (temp == temp1)\n        {\n            temp2 ~= item.value;\n        }\n  \
    \  }\n    temp2 = temp2.groupBy!((a) => a).values.expand.array;\n    foreach (item;\
    \ temp2)\n    {\n        a[item] = temp1;\n    }\n    nullable = a;\n    return\
    \ nullable;\n}", "{\n    if (test.empty) return Nullable!(long[string])();\n \
    \   Nullable!(long[string]) res = null;\n    long[string] hist = new long[string];\n\
    \    foreach (i, item; test.split())\n    {\n        hist[item]++;\n    }\n  \
    \  long max = -1;\n    foreach (k, v; hist)\n    {\n        if (v > max)\n   \
    \     {\n            max = v;\n            res = null;\n        }\n        if\
    \ (v == max)\n        {\n            if (res.isNull) res = new long[string];\n\
    \            res.get().insert(k, v);\n        }\n    }\n    return res;\n}", "{\n\
    \    immutable chars = test.strip().split;\n    immutable counts = chars.mangle\
    \ !((a, b) => (a == b, b));\n    immutable letter = counts.map !(a => a[1]).maxElement;\n\
    \    immutable group = counts.filter !(a => a[1] == letter);\n    return group.groupBy\
    \ !(a => a[1]).find(letter);\n}", "{\n    long[string] ret;\n    long[char] tmp;\n\
    \    long max = 0;\n    ret.length = test.length;\n    foreach(line; test.split(\"\
    \ \")) {\n        foreach(ch; line) {\n            tmp[ch]++;\n            if(tmp[ch]\
    \ > max) {\n                max = tmp[ch];\n            }\n        }\n    }\n\
    \    foreach(c; tmp.keys) {\n        if(tmp[c] == max) {\n            ret[c] =\
    \ max;\n        }\n    }\n    return ret.length == 0 ? null : ret;\n}", "{\n \
    \   /*\n    Should i use a hash table?\n    \n    If i use a hash table, it would\
    \ be easy to get the maximum value\n    also I would be able to return a Nullable!string[]\
    \ by using .tupleof\n    .tupleof returns a dynamic array which can be easily\
    \ converted to a dynamic array\n    of strings\n    \n    I will use a hash table.\n\
    \    */\n    HashTable!(string, long) letterCount = HashTable!(string, long)();\n\
    \    immutable(string)[] letters = test.split();\n    auto max = 0L;\n    for(immutable(string)\
    \ letter ; letters)\n    {\n        auto count = letterCount.insert(letter, 0L);\n\
    \        count.second = count.second + 1L;\n        if(count.second > max)\n \
    \       {\n            max = count.second;\n        }\n    }\n    /*\n    Now\
    \ that i know what is the largest number (max), i will iterate through the hash\
    \ table\n    and find all the keys which have the max value.\n    A hash table\
    \ has a struct property called .table which is an array of tuples\n    Each tuple\
    \ contains a tuple containing the key and value of a HashNode and the next pointer.\n\
    \    This means that to get all the values of the hash table i have to iterate\
    \ through the array\n    and look for tuples which don't have a null pointer.\n\
    \    */\n    immutable(string)[] mostCommon = immutable(string)[]().init;\n  \
    \  for(auto node : letterCount.table)\n    {\n        if(node.next !is null)\n\
    \        {\n            if(node.next.value.second == max)\n            {\n   \
    \             mostCommon ~= node.next.value.first;\n            }\n        }\n\
    \    }\n    /*\n    Now that i have all the values which are repeated the most,\n\
    \    i will return a nullable!string[] which contains these values\n    */\n \
    \   return to!(Nullable!(long[string]))(mostCommon);\n}", "{\n    Nullable!(long[string])\
    \ result;\n    // your code here\n    return result;\n}\n```", "{ \n    auto letters\
    \ = test.split; \n    long max = 0; \n    foreach(i, e; letters) { \n        if(letters[e]\
    \ is null) letters[e] = 1; \n        else letters[e] += 1; \n        if(letters[e]\
    \ > max) max = letters[e]; \n    } \n    Nullable!(long[string]) result = null;\
    \ \n    foreach(i, e; letters) { \n        if(letters[e] == max) { \n        \
    \    if(result is null) result = to!(Nullable!(long[string]))[e:max]; \n     \
    \       else result[e] = max; \n        } \n    } \n    return result; \n}", "{\n\
    \    typeof(return) result;\n    foreach(c; test.chunks(1)) \n    {\n        if(result.count.length\
    \ == 0)\n        {\n            result.count = [c[0]: 1L];\n        }\n      \
    \  else if(result.count.count(c[0]) == 0)\n        {\n            result.count[c[0]]\
    \ = 1L;\n        }\n        else\n        {\n            result.count[c[0]] +=\
    \ 1L;\n        }\n    }\n    if(result.count.length == 0) \n    {\n        return\
    \ ___null_dict___;\n    }\n    const int MAX = result.count.values.max;\n    foreach(key,\
    \ value; result.count) \n    {\n        if(value < MAX) \n        {\n        \
    \    result.count.remove(key);\n        }\n    }\n    return result;\n}", "{\n\
    \    Nullable!(long[string]) ret = ___null_dict___;\n    import std.algorithm;\n\
    \    auto split = test.split(\" \");\n    int max = 0;\n    foreach(i; split)\n\
    \    {\n        if(ret.contains(i))\n        {\n            ret[i]++;\n      \
    \  }\n        else\n        {\n            ret[i] = 1;\n        }\n        if(ret[i]\
    \ > max)\n        {\n            max = ret[i];\n        }\n    }\n    Nullable!(long[string])\
    \ ret2 = new long[string]();\n    foreach(i;ret)\n    {\n        if(i.value ==\
    \ max)\n        {\n            ret2[i.key] = i.value;\n        }\n    }\n    return\
    \ ret2;\n}", "{\n    auto lookup = test.splitter().frequencyMap();\n    auto max\
    \ = lookup.values.max();\n    auto result = new long[string];\n    foreach(k,v;\
    \ lookup)\n    {\n        if(v == max)\n        {\n            result[k] = v;\n\
    \        }\n    }\n    return result.nullable;\n}", "{\n    long[string] result;\n\
    \    long[long] freq;\n    for (auto it : test.split())\n    {\n        if (result.byKey(it)\
    \ == null)\n        {\n            result[it] = 1L;\n        }\n        else\n\
    \        {\n            ++result[it];\n        }\n        freq[result[it]] = result[it];\n\
    \    }\n    if (result.length == 0)\n    {\n        return null;\n    }\n    long\
    \ max = freq.byKey(freq.length-1);\n    long[string] output;\n    for (auto[key,\
    \ value] = result.front; !value.empty; value.popFront())\n    {\n        if (value.front\
    \ == max)\n        {\n            output[key] = value.front;\n        }\n    }\n\
    \    return output;\n}", "{\n    if (test.empty)\n        return null;\n    Nullable!(long[string])\
    \ letters = null;\n    string[] space_splitted = test.split(' ');\n    immutable(long[string])\
    \ tmp = [];\n    foreach(i, letter; space_splitted)\n    {\n        if (letter\
    \ in tmp)\n            tmp[letter]++;\n        else\n            tmp[letter] =\
    \ 1;\n    }\n    long max_value = tmp.values.max();\n    foreach(value; tmp.values)\n\
    \    {\n        if (value == max_value)\n            letters ~= (tmp.keys[value]\
    \ : value);\n    }\n    return letters;\n}", "{\n    long[string] result;\n  \
    \  long[string] temp;\n    long[string] max;\n    long[string] value;\n    long[string]\
    \ key;\n    long maxCount;\n    long currentCount;\n    long count;\n    long\
    \ index;\n    string[long] repeat;\n    foreach(index, letter; test.split) \n\
    \    {\n        repeat = result.byKey(letter);\n        if(repeat is null) \n\
    \        {\n            result[letter] = 1L;\n        } \n        else \n    \
    \    {\n            result[letter] = repeat + 1L;\n        }\n    }\n    value\
    \ = result.values();\n    key = result.keys();\n    count = 0L;\n    maxCount\
    \ = value[0L];\n    foreach(count, currentCount; value) \n    {\n        if(currentCount\
    \ == maxCount) \n        {\n            max[key[count]] = currentCount;\n    \
    \    } \n        else if(currentCount > maxCount) \n        {\n            maxCount\
    \ = currentCount;\n            max = typeof(max).init;\n            max[key[count]]\
    \ = currentCount;\n        }\n    }\n    return max;\n}\n/*\nAn O(n^2) algorithm\
    \ to decide if a string is an anagram of another.", "{\n    auto a = test.split(\"\
    \ \");\n    auto b = a.slicedup.array;\n    auto c = b.tupleof;\n    auto d =\
    \ a.countmap;\n    long maxValue = 0;\n    string maxKey = \"\";\n    foreach(k,\
    \ v; d)\n    {\n        if(v > maxValue)\n        {\n            maxValue = v;\n\
    \            maxKey = k;\n        }\n    }\n    if(maxValue == 0)\n    {\n   \
    \     return null;\n    }\n    else\n    {\n        return [maxKey: maxValue];\n\
    \    }\n}\n/*\nYou are given a string of lowercase letters, and an integer. \n\
    \    Write a function that iterates through the string, \n    builds a new string,\
    \ and returns it. \n    The new string should contain the characters in the original\
    \ string \n    and the integer number of occurrences of each character in the\
    \ new string. \n    For example:\n    >>> build(\"a\", 2)\n    \"a\"\n    >>>\
    \ build(\"a\", 3)\n    \"aaa\"\n    >>> build(\"aa\", 2)\n    \"aaaa\"\n    >>>\
    \ build(\"ab\", 3)\n    \"ababab\"\n    >>> build(\"abc\", 2)\n    \"aabbcc\"\n\
    \    >>> build(\"aaa\", 2)\n    \"aaaaaaa\"\n    >>> build(\"\", 3)\n    \"\"\n\
    */\nstring build(string s, int n) \n{\n    string result = \"\";\n    foreach(c;\
    \ s)\n    {\n        result ~= repeat(c, n);\n    }\n    return result;\n}\n/*\n\
    You are given a rectangular matrix of numbers. \n    Write a function that rotates\
    \ the matrix by 90 degrees clockwise and returns the result.\n    >>> rotate(\"\
    1,2,3;4,5,6;7,8,9\")\n    \"7,4,1;8,5,2;9,6,3\"\n    >>> rotate(\"0,0,0;0,0,0;0,0,0\"\
    )\n    \"0,0,0;0,0,0;0,0,0\"\n    >>> rotate(\"0", "{\n    import std.algorithm\
    \ : max, maxElement;\n    import std.container : SortedRange;\n    import std.conv\
    \ : to;\n    import std.range : zip;\n    import std.string : split;\n    if (test.empty)\n\
    \        return null;\n    string[] spl = test.split(\" \");\n    Nullable!(long[string])\
    \ result = long[string].init;\n    foreach (const element; spl)\n    {\n     \
    \   if (element in result)\n            result[element] += 1L;\n        else\n\
    \            result[element] = 1L;\n    }\n    auto maxIt = maxElement(result);\n\
    \    if (maxIt == null)\n        return null;\n    long maxV = *maxIt;\n    auto\
    \ resRange = zip(result.byPair.map!(a => a[1]))\n    .filter!(a => a[0] == maxV)\n\
    \    .map!(a => a[1].key);\n    SortedRange!(string) res = resRange.array;\n \
    \   return res;\n}\n/*\n    Given an array of numbers, apply the following rules,\
    \ until there are no numbers left in the array:\n    \n    - If there is an even\
    \ number of elements, take the first half and append it to the end of the array.\n\
    \    - If there is an odd number of elements, take the middle element and append\
    \ it to the end of the array.\n    - Return the array after all numbers have been\
    \ removed.\n    \n    Example:\n    >>> snake(0.0, 1.0, 2.0, 3.0, 4.0, 5.0)\n\
    \    [3.0, 4.0, 5.0, 0.0, 1.0, 2.0]\n    >>> snake(1.0, 2.0, 3.0, 4.0, 5.0)\n\
    \    [3.0, 4.0, 5.0, 1.0, 2.0]\n    >>> snake(1.0, 2.0, 3.0, 4.0)\n    [2.0, 3.0,\
    \ 4.0, 1.0]\n    >>> snake(1.0, 2.0, 3.", "{\n    // TODO: implement this", "{\n\
    \    Nullable!(long[string]) result;\n    if (test.length > 0) \n    {\n     \
    \   auto aa = test.split(\" \");\n        long[string] aCount;\n        foreach\
    \ (a; aa) \n        {\n            if (aCount.contains(a)) \n            {\n \
    \               aCount[a]++;\n            } \n            else \n            {\n\
    \                aCount[a] = 1;\n            }\n        }\n        long max =\
    \ aCount.values.max;\n        if (max > 0) \n        {\n            auto sMax\
    \ = aCount.values.max;\n            long[string] same;\n            foreach (a;\
    \ aCount) \n            {\n                if (a.value == sMax) \n           \
    \     {\n                    same[a.key] = a.value;\n                }\n     \
    \       }\n            result = same;\n        }\n    }\n    return result;\n}",
  "{\n    Nullable!(long[string]) ret = null;\n    long[string] histogram;\n    foreach(\
    \ char c; test)\n    {\n        if(c != ' ')\n        {\n            auto p =\
    \ histogram.get(cast(string)c);\n            if(p)\n            {\n          \
    \      *p.key++;\n            }\n            else\n            {\n           \
    \     histogram[cast(string)c] = 1L;\n            }\n        }\n    }\n    long\
    \ max = 0L;\n    foreach(key, value; histogram)\n    {\n        if(value > max)\n\
    \        {\n            max = value;\n        }\n    }\n    if(max > 0L)\n   \
    \ {\n        ret = new long[string];\n        foreach(key, value; histogram)\n\
    \        {\n            if(value == max)\n            {\n                ret.get!true[key]\
    \ = value;\n            }\n        }\n    }\n    return ret;\n}", "{\n    import\
    \ std.algorithm : max;\n    import std.string : join;\n    import std.array :\
    \ equal;\n    import std.conv : to;\n    import std.typecons : Tuple;\n    import\
    \ std.uni : isLetter;\n    import std.range : unique;\n    Nullable!(long[string])\
    \ result;\n    string[] histo;\n    if(test.length == 0)\n    {\n        return\
    \ null;\n    }\n    foreach(t; test.chunks(2))\n    {\n        if(t.length ==\
    \ 2)\n        {\n            if(isLetter(t[0]) && isLetter(t[1]))\n          \
    \  {\n                histo ~= t[0..1];\n            }\n            else if(isLetter(t[0]))\n\
    \            {\n                histo ~= t[0..1];\n            }\n        }\n\
    \        else if(t.length == 1)\n        {\n            if(isLetter(t[0]))\n \
    \           {\n                histo ~= t[0..1];\n            }\n        }\n \
    \   }\n    long max = 0;\n    long[] res;\n    foreach(t; histo.unique)\n    {\n\
    \        long count = histo.count!(x => equal(x, t));\n        if(count > max)\n\
    \        {\n            max = count;\n            res.length = 0;\n          \
    \  res ~= count;\n        }\n        else if(count == max)\n        {\n      \
    \      res ~= count;\n        }\n    }\n    if(res.length == 0)\n    {\n     \
    \   return null;\n    }\n    result = [].init;\n    foreach(res2; res)\n    {\n\
    \        foreach(t; histo.unique)\n        {\n            long count = histo.count!(x\
    \ => equal(x, t));\n            if(count == res2)\n            {\n           \
    \     result.assocUpdate(t, res2);\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    Nullable!(long[string]) nullableMap;\n    if (test.length\
    \ == 0)\n    {\n        return nullableMap;\n    }\n    else\n    {\n        long[string]\
    \ map = new long[string];\n        foreach (ch; test.split)\n        {\n     \
    \       if (map.count > 0)\n            {\n                map[ch]++;\n      \
    \      }\n            else\n            {\n                map[ch] = 1;\n    \
    \        }\n        }\n        long max = map.values.max;\n        return map.byValue(max);\n\
    \    }\n}", "{\n    long[] result = long[string]().init;\n    foreach(char letter;\
    \ test) \n    {\n        if(isAlpha(letter))\n        {\n            result[letter]++;\n\
    \        }\n    }\n    long max = 0;\n    foreach(value; result)\n    {\n    \
    \    if(value > max)\n        {\n            max = value;\n        }\n    }\n\
    \    return (result.filter!(v => v == max) & result).nullable;\n}", "in {\n  \
    \  assert(test.length >= 0);\n} \nbody {\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.conv;\n    import std.range;\n    import std.string;\n\
    \    import std.typecons;\n    import std.uni;\n    if (test.length == 0) return\
    \ Nullable!(long[string]).init;\n    auto split = test.split(\" \");\n    long[string]\
    \ result;\n    long maxCount = 0;\n    long count = 0;\n    foreach (i,s; split)\
    \ {\n        result[s] = result.getOrInit(s, 0) + 1;\n        if (result[s] >\
    \ maxCount) {\n            maxCount = result[s];\n        }\n    }\n    foreach\
    \ (i,s; split) {\n        if (result[s] == maxCount) {\n            count++;\n\
    \        }\n    }\n    if (count == 0) {\n        return Nullable!(long[string]).init;\n\
    \    }\n    long[string] histogram(count);\n    foreach (i,s; split) {\n     \
    \   if (result[s] == maxCount) {\n            histogram[s] = maxCount;\n     \
    \   }\n    }\n    return Nullable!(long[string])(histogram);\n}", "{\n    //It's\
    \ called a histogram, so the array will be the values and the string will be the\
    \ keys.\n    long[string] histogram;\n    string[] letters;\n    string letter;\n\
    \    long counter;\n    long maxCount;\n    //Break the string into an array of\
    \ strings.\n    letters = test.split;\n    //As we're looking for strings with\
    \ the most repetitions, \n    //    we'll want to keep track of the max count\
    \ of each letter.\n    maxCount = 0;\n    //We will start by iterating through\
    \ each letter.\n    foreach(letter; letters)\n    {\n        //We will start the\
    \ counter at 1 to count the current letter.\n        counter = 1;\n        //We\
    \ will iterate through all the letters again.\n        foreach(string s; letters)\n\
    \        {\n            //If the letter we are searching is the same as the current\
    \ letter,\n            //    we will increment the counter.\n            if(letter\
    \ == s)\n            {\n                counter++;\n            }\n        }\n\
    \        //Store the letter and the counter in the histogram.\n        histogram[letter]\
    \ = counter;\n        //If the counter is greater than the max count,\n      \
    \  //    the counter will become the new max count.\n        if(counter > maxCount)\n\
    \        {\n            maxCount = counter;\n        }\n    }\n    //Iterate through\
    \ each letter and count of the histogram.\n    foreach(string key; histogram.keys)\n\
    \    {\n        //If the count is not equal to the max count,\n        //    remove\
    \ the entry from the histogram.\n        if(histogram[key] != maxCount)\n    \
    \    {\n            histogram.remove(key);\n        }\n    }\n    //If the histogram\
    \ is empty, return null.\n    if(histogram.empty)\n    {\n        return Nullable!(long[string])(null);\n\
    \    }\n    //Else, return the histogram.\n    return Nullable!(long[string])(histogram);\n\
    }", "{\n    import std.algorithm;\n    import std.range;\n    import std.stdio;\n\
    \    import std.array;\n    import std.typecons;\n    import std.meta;\n    import\
    \ std.getopt;\n    import std.exception;\n    import std.math;\n    import std.typecons;\n\
    \    import std.uni;\n    import std.utf;\n    import std.conv;\n    import std.algorithm;\n\
    \    import std.string;\n    import std.utf;\n    import std.uni;\n    import\
    \ std.getopt;\n    import std.traits;\n    import std.array;\n    import std.range;\n\
    \    import std.typecons;\n    import std.meta;\n    import std.algorithm;\n \
    \   import std.range;\n    import std.math;\n    import std.typecons;\n    auto\
    \ tokenizer = test.split(\" \");\n    writeln(tokenizer);\n    auto counts = tokenizer.group.map!(t\
    \ => [t[0]: t.length]);\n    writeln(counts);\n    auto max = counts.max!((a,\
    \ b) => a[0].toString.length < b[0].toString.length)();\n    writeln(max);\n \
    \   auto max_count = max[0].toString.length;\n    writeln(max_count);\n    return\
    \ counts.find!(a => a[0].toString.length == max_count)\n    .map!(a => a[0]);\n\
    }", "{\n    if (test.empty) return Nullable!(long[string]).init;\n    /*\n   \
    \  * Split each element into a separate String and return the array of strings.\n\
    \     * The delimiters are searched for and returned as elements of the resulting\
    \ array.\n     * Note that if parameter `keepTerminators` is false, the delimiters\
    \ are not returned.\n     *\n     * Examples:\n     * \n     * >>> \"a b c\".split()\n\
    \     * [\"a\", \"b\", \"c\"]\n     * >>> \"a b c\".split(keepTerminators = false)\n\
    \     * [\"a\", \"b\", \"c\"]\n     * >>> \"abc\".split()\n     * [\"abc\"]\n\
    \     * >>> \"a b c\".split(' ')\n     * [\"a\", \" \", \"b\", \" \", \"c\"]\n\
    \     * >>> \"a b c\".split(' ', keepTerminators = false)\n     * [\"a\", \"b\"\
    , \"c\"]\n     * >>> \"a b c\".split(' ')\n     * [\"a\", \" \", \"b\", \" \"\
    , \"c\"]\n     * >>> \"a b c\".split(' ', keepTerminators = false)\n     * [\"\
    a\", \"b\", \"c\"]\n     * >>> \"a b c\".split(' ', keepTerminators = true)\n\
    \     * [\"a\", \" \", \"b\", \" \", \"c\"]\n     * >>> \" a b c \".split(' ',\
    \ keepTerminators = true)\n     * [\"\", \" \", \"a\", \" \", \"b\", \" \", \"\
    c\", \" \"]\n     * >>> \"a b\".split(' ', true)\n     * [\"a\", \" \", \"b\"\
    ]\n     * >>> \"a \".split(' ', true)\n     * [\"a\", \" \"]\n     * >>> \" a\"\
    .split(' ', true)\n     * [\"\", \" \", \"a\"]\n     * >>> \" \".split(' ', true)\n\
    \     * [\"\", \" \"]\n     * >>> \"\".split(' ', true)\n     * []\n     * >>>\
    \ \" \".split(' ', false)\n     * []\n     * >>> \"a\".split(' ', false)\n   \
    \  * [\"a\"]\n     * >>> \"\".split(' ', false)\n     * []\n     * >>> \" a b\
    \ c", "{\n    immutable string test_array[] = test.split();\n    return histogram(test_array);\n\
    }", "{\n    if (test.empty)\n        return ___null_dict___;\n    auto occurrences\
    \ = test.split.groupBy!(a => a);\n    return occurrences.retro(a => a.value.length).max.indices.map!(a\
    \ => tuple(a, occurrences[a].length)).array.nullable;\n}", "{\n    long[string]\
    \ dict;\n    if(test.length == 0) return ___null_dict___;\n    foreach(i,c;test)\n\
    \    {\n        if(!dict.count(c)) dict[c] = 1L;\n        else dict[c]++;\n  \
    \  }\n    auto max = dict.values.max;\n    long[string] result;\n    foreach(i,k;dict.keys)\n\
    \    {\n        if(dict[k] == max) result[k] = max;\n    }\n    return to!Nullable(result);\n\
    }", "{\n    import std.algorithm;\n    import std.typecons;\n    import std.string;\n\
    \    Nullable!(long[string]) res;\n    if(test.empty)\n        return ___null_dict___;\n\
    \    string[] words = test.split;\n    words.sort;\n    long maxcnt = -1;\n  \
    \  res = new long[string];\n    foreach(i, w; words)\n    {\n        if(i == 0\
    \ || words[i] != words[i-1])\n        {\n            if(res.get(words[i]))\n \
    \               res.get(words[i])++;\n            else\n                res.set(words[i],\
    \ 1L);\n        }\n        else\n            res.get(words[i])++;\n        if(res.get(words[i])\
    \ > maxcnt)\n            maxcnt = res.get(words[i]);\n    }\n    foreach(word;\
    \ res.keys)\n    {\n        if(res.get(word) != maxcnt)\n            res.remove(word);\n\
    \    }\n    return res;\n}\n/*\nGiven a string, representing a sequence of numbers\
    \ separated by spaces,\n    return the maximum difference between any pair of\
    \ consecutive numbers.\n    \n    Example:\n    >>> max_diff(\"7 1 2 8 4\")\n\
    \    7\n    >>> max_diff(\"-3 -3 -3 -3\")\n    0\n    >>> max_diff(\"2 5 3 2 3\"\
    )\n    3\n    >>> max_diff(\"\")\n    0\n*/\nlong max_diff(string numbers)\n{\n\
    \    import std.string;\n    import std.algorithm;\n    long res = 0;\n    if(numbers.empty)\n\
    \        return res;\n    int[] nums = numbers.split.map!(a => to!int(a)).array;\n\
    \    res = abs(nums[0] - nums[1]);\n    foreach(i, n; nums)\n    {\n        if(i\
    \ > 0)\n        {\n            long diff = abs(nums[i] - nums[i-1]);\n       \
    \     if(diff > res)\n                res = diff;\n       ", "{\n    long max\
    \ = 0;\n    auto ret;\n    auto tbl = count(split(test));\n    foreach(k, v; tbl)\n\
    \    {\n        if(v == max)\n        {\n            ret[k] = v;\n        }\n\
    \        else if(v > max)\n        {\n            max = v;\n            ret =\
    \ null;\n            ret[k] = v;\n        }\n    }\n    return ret;\n}", "{\n\
    \    long[string] letters;\n    foreach(letter; test.split()) \n    {\n      \
    \  if (letters.contains(letter))\n        {\n            letters[letter]++;\n\
    \        }\n        else\n        {\n            letters[letter] = 1;\n      \
    \  }\n    }\n    if (letters.empty)\n    {\n        return ___null_dict___;\n\
    \    }\n    else\n    {\n        long max = 0;\n        foreach(key, val; letters)\n\
    \        {\n            if (val > max)\n            {\n                max = val;\n\
    \            }\n        }\n        long[string] result;\n        foreach(key,\
    \ val; letters)\n        {\n            if (val == max)\n            {\n     \
    \           result[key] = val;\n            }\n        }\n        return result;\n\
    \    }\n}", "{\n    Nullable!(long[string]) result;\n    if (test.length == 0)\n\
    \    {\n        return result;\n    }\n    string[] words = test.split(\" \");\n\
    \    long[] counts = new long[words.length];\n    auto freqTable = new HashTable!(int,\
    \ long);\n    auto maxFreq = 0;\n    foreach (i, word; words)\n    {\n       \
    \ long value = counts[i] = to!long(freqTable.get(word, 0L)) + 1;\n        freqTable[word]\
    \ = value;\n        if (value > maxFreq)\n        {\n            maxFreq = value;\n\
    \        }\n    }\n    if (maxFreq != 0)\n    {\n        result = typeof(result)();\n\
    \        foreach (i, word; words)\n        {\n            if (counts[i] == maxFreq)\n\
    \            {\n                result[word] = maxFreq;\n            }\n     \
    \   }\n    }\n    return result;\n}", "{\n    if (test.empty) return typeof(return).init;\n\
    \    string[] splitTest = test.split();\n    int[] occurance = splitTest.occurance;\n\
    \    int maxVal = occurance.max;\n    string[] keys = splitTest.dup;\n    keys.removeDuplicates();\n\
    \    Nullable!(long[string]) output = typeof(return).init;\n    foreach(i, key;\
    \ keys)\n    {\n        if (occurance[i] == maxVal)\n        {\n            output[key]\
    \ = maxVal;\n        }\n    }\n    return output;\n}", "{\n    \n    Nullable!(long[string])\
    \ nullable_histogram;\n    long[string] histogram;\n    char[] test_char_arr =\
    \ test.to!char[];\n    int max_occurrences = 0;\n    for(int i = 0; i < test_char_arr.length;\
    \ i++) \n    {\n        if(test_char_arr[i] == ' ')\n            continue;\n \
    \       string current_letter = test_char_arr[i].to!string;\n        if(histogram.contains(current_letter))\n\
    \        {\n            histogram[current_letter]++;\n        }\n        else\n\
    \        {\n            histogram[current_letter] = 1;\n        }\n        if(histogram[current_letter]\
    \ > max_occurrences)\n        {\n            max_occurrences = histogram[current_letter];\n\
    \        }\n    }\n    nullable_histogram = new Nullable!(long[string])();\n \
    \   if(max_occurrences == 0)\n    {\n        nullable_histogram.nullify();\n \
    \   }\n    else\n    {\n        nullable_histogram.value = new long[string];\n\
    \        for(int i = 0; i < test_char_arr.length; i++) \n        {\n         \
    \   if(test_char_arr[i] == ' ')\n                continue;\n            string\
    \ current_letter = test_char_arr[i].to!string;\n            if(histogram[current_letter]\
    \ == max_occurrences)\n            {\n                nullable_histogram.value[current_letter]\
    \ = histogram[current_letter];\n            }\n        }\n    }\n    return nullable_histogram;\n\
    }\n/*\nGiven a nonempty array of integers, return the maximum sum that can be\
    \ obtained by\n    summing exactly 2 elements in the array.\n    Example:\n  \
    \  >>> maxSum([2, 4, 6, 2, 5])\n    11\n    >>> maxSum([5, 1, 1, 5])\n    10\n\
    \    >>> maxSum([0, 1, 0, 0, 1])\n    1\n    >>> maxSum([2, 3, 5,", "{\n    if\
    \ (test.empty)\n        return null;\n    // create a histogram\n    auto h =\
    \ [string: long]().init;\n    foreach (letter; test.split)\n    {\n        h[letter]++;\n\
    \    }\n    // find the max\n    long max = h.values.front;\n    foreach (val;\
    \ h.values[1..$])\n    {\n        if (val > max)\n            max = val;\n   \
    \ }\n    // return\n    return h.byValue.retro.retro[max].byKey.nullable;\n}",
  "{\n    static int[] _asciiTable = [char.init]()\n        .assumeUnique.save.dup(char.max);\n\
    \    int[] occurences = _asciiTable.dup;\n    foreach(c; test)\n    {\n      \
    \  occurences[c]++;\n    }\n    Nullable!(long[string]) result = Nullable.init;\n\
    \    long highestOccurence = 0;\n    foreach(c; occurences)\n    {\n        if(c\
    \ > highestOccurence)\n        {\n            highestOccurence = c;\n        }\n\
    \    }\n    if(highestOccurence != 0)\n    {\n        result = typeof(result).init;\n\
    \        foreach(i, c; occurences)\n        {\n            if(c == highestOccurence)\n\
    \            {\n                result.get!(string).put(cast(string)i, c);\n \
    \           }\n        }\n    }\n    return result;\n}", "{\n    Nullable!(long[string])\
    \ test_dict;", "{\n    import std.algorithm.searching : count;\n    import std.array\
    \ : array;\n    import std.typecons : Nullable;\n    import std.uni : isAlpha;\n\
    \    test = test.strip();\n    if(test.length==0)\n        return null;\n    long[]\
    \ result = test.split(new string(\" \")).filter!(s => s.length > 0).\n       \
    \ map!(s => s.filter!(c => c.isAlpha).length).array();\n    long max = result.max();\n\
    \    if(result.count(max) > 1)\n        return new typeof(result).init.idup;\n\
    \    return result.assocArray.retro;\n}\n/*\n    string test = test.strip();\n\
    \    if(test.length==0)\n        return ___null_dict___;\n    long[] result =\
    \ test.split(new string(\" \")).filter!(s => s.length > 0).\n        map!(s =>\
    \ s.filter!(c => c.isAlpha).length).array();\n    long max = result.max();\n \
    \   if(result.count(max) > 1)\n        return result.assocArray.retro;\n    return\
    \ result.assocArray.retro;\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
