name: HumanEval_157_right_angle_triangle
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given the lengths of the\
  \ three sides of a triangle. Return true if the three\n    sides form a right-angled\
  \ triangle, false otherwise.\n    A right-angled triangle is a triangle in which\
  \ one angle is right angle or \n    90 degree.\n    Example:\n    >>> right_angle_triangle(3L,\
  \ 4L)\n    true\n    >>> right_angle_triangle(1L, 2L)\n    false\n    \n*/\nbool\
  \ right_angle_triangle(long a, long b, long c) \n"
tests: "unittest\n{\n    alias candidate = right_angle_triangle;\n\n    assert(candidate(3L,\
  \ 4L, 5L) == true);\n    assert(candidate(1L, 2L, 3L) == false);\n    assert(candidate(10L,\
  \ 6L, 8L) == true);\n    assert(candidate(2L, 2L, 2L) == false);\n    assert(candidate(7L,\
  \ 24L, 25L) == true);\n    assert(candidate(10L, 5L, 7L) == false);\n    assert(candidate(5L,\
  \ 12L, 13L) == true);\n    assert(candidate(15L, 8L, 17L) == true);\n    assert(candidate(48L,\
  \ 55L, 73L) == true);\n    assert(candidate(1L, 1L, 1L) == false);\n    assert(candidate(2L,\
  \ 2L, 10L) == false);\n}\nvoid main(){}"
completions: ["{\n    if(a > 0 && b > 0 && c > 0)\n    {\n        int[] sides = tuple(a,\
    \ b, c).sort().array;\n        a = sides[0];\n        b = sides[1];\n        c\
    \ = sides[2];\n        return a * a + b * b == c * c;\n    }\n    return false;\n\
    }", "{\n    long[] s = [a, b, c];\n    sort(s);\n    return (s[0] * s[0] + s[1]\
    \ * s[1] == s[2] * s[2]);\n}", "{\n    return (a*a + b*b == c*c) || (a*a + c*c\
    \ == b*b) || (b*b + c*c == a*a);\n}", "{\n    // Given the lengths of the three\
    \ sides of a triangle. Return true if the three\n    // sides form a right-angled\
    \ triangle, false otherwise.\n    // A right-angled triangle is a triangle in\
    \ which one angle is right angle or \n    // 90 degree.\n    // Example:\n   \
    \ // >>> right_angle_triangle(3L, 4L)\n    // true\n    // >>> right_angle_triangle(1L,\
    \ 2L)\n    // false\n    bool doTriangles1 = c*c == a*a + b*b;\n    bool doTriangles2\
    \ = a*a == b*b + c*c;\n    bool doTriangles3 = b*b == a*a + c*c;\n    bool doTriangles\
    \ = doTriangles1 || doTriangles2 || doTriangles3;\n    return doTriangles;\n}",
  "{\n    long s = max(a, b, c); // this is hypotenuse\n    // long sum = a + b +\
    \ c;\n    long sum = 0;\n    if (a!=s)\n        sum += a;\n    if (b!=s)\n   \
    \     sum += b;\n    if (c!=s)\n        sum += c;\n    return pow(sum, 2) == pow(s,\
    \ 2);\n}", "{\n    const long sum = a*a + b*b;\n    const long sum2 = a*a + c*c;\n\
    \    const long sum3 = b*b + c*c;\n    return (sum == c*c) || (sum2 == b*b) ||\
    \ (sum3 == a*a);\n}\n/*\n    Given an array of randomly selected tickets, return\
    \ the winner ticket.\n    The winner ticket is the ticket that has the same starting\
    \ and ending number.\n    Example:\n    >>> lottery_ticket([\"0234\", \"1912\"\
    , \"1265\"])\n    \"1265\"\n    >>> lottery_ticket([\"1234\", \"1912\", \"1265\"\
    ])\n    \"1234\"\n*/\nstring lottery_ticket(string[] tickets) \n{\n    string[]\
    \ winners = tickets.filter!(a => a[0] == a[$-1]);\n    return (winners.length\
    \ == 0) ? \"No winner\" : winners[0];\n}\n/*\n    Return an array of numbers sorted\
    \ in descending order\n    Example:\n    >>> sort_array([3, 4, 2, 1])\n    [4,\
    \ 3, 2, 1]\n    >>> sort_array([3, 4, 2, 1])\n    [4, 3, 2, 1]\n*/\nlong[] sort_array(long[]\
    \ numbers) \n{\n    return numbers.sort.sort!(a => -a);\n}\n/*\n    Return true\
    \ if the given array is a palindrome\n    Example:\n    >>> is_palindrome([\"\
    a\", \"b\", \"c\", \"d\", \"c\", \"b\", \"a\"])\n    true\n    >>> is_palindrome([\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n    false\n*/", "{\n    auto\
    \ t = tuple(a, b, c);\n    sort(t);\n    return (t[0] * t[0] + t[1] * t[1] ==\
    \ t[2] * t[2]);\n}", "{\n    return pow(a, 2) + pow(b, 2) == pow(c, 2);\n}", "{\n\
    \    // I don't care about the order of the lengths\n    // Assume the longest\
    \ is c\n    long c_ = max(a,b);\n    long c__ = min(a,b);\n    // The longest\
    \ length is c. We just need to check if\n    // c^2 = a^2 + b^2\n    // because\
    \ of the pythagorean theorem\n    // c^2 = a^2 + b^2\n    return pow(c_,2) ==\
    \ pow(c__,2) + pow(c,2);\n}", "{\n    enum \n    {\n        L_0 = 0,\n       \
    \ L_1 = 1,\n        L_2 = 2,\n        COUNT = 3\n    } ;\n    typedef Tuple!(long,\
    \ long, long) Lengths;\n    auto lengths = Lengths(a, b, c);\n    lengths.sort(greater);\n\
    \    return lengths[L_0] * lengths[L_0] == lengths[L_1] * lengths[L_1] + lengths[L_2]\
    \ * lengths[L_2];\n}", "{\n    long m = a;\n    long n = b;\n    long p = c;\n\
    \    Tuple!(long, long, long) t;\n    if(p >= m && p >= n) {\n        t = tuple(n,\
    \ m, p);\n    } else if(n >= m && n >= p) {\n        t = tuple(m, p, n);\n   \
    \ } else {\n        t = tuple(p, n, m);\n    }\n    return (t[1] * t[1] + t[2]\
    \ * t[2]) == t[0] * t[0];\n}", "{\n    return a*a + b*b == c*c;\n}", "{\n    if\
    \ (a == 0 || b == 0 || c == 0)\n        return false;\n    long  m = max(a, max(b,\
    \ c));\n    long s = min(a, min(b, c));\n    long s2 = a + b + c - m - s;\n  \
    \  auto h = pow(m, 2);\n    auto k = pow(s, 2) + pow(s2, 2);\n    return h ==\
    \ k;\n}", "{\n    struct tuple c2 = make_tuple(a, b, c);\n    c2 = sort(c2);\n\
    \    a = c2[0];\n    b = c2[1];\n    c = c2[2];\n    return (a * a + b * b ==\
    \ c * c);\n}", "{\n    long s = 0;\n    long m = 0;\n    long l = 0;\n    if (a\
    \ > b && a > c)\n    {\n        l = a;\n        if (b > c)\n        {\n      \
    \      m = b;\n            s = c;\n        }\n        else\n        {\n      \
    \      m = c;\n            s = b;\n        }\n    }\n    else if (b > a && b >\
    \ c)\n    {\n        l = b;\n        if (a > c)\n        {\n            m = a;\n\
    \            s = c;\n        }\n        else\n        {\n            m = c;\n\
    \            s = a;\n        }\n    }\n    else\n    {\n        l = c;\n     \
    \   if (a > b)\n        {\n            m = a;\n            s = b;\n        }\n\
    \        else\n        {\n            m = b;\n            s = a;\n        }\n\
    \    }\n    if (m + s <= l)\n    {\n        return false;\n    }\n    long ms\
    \ = m * m + s * s;\n    long ls = l * l;\n    if (ms == ls)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }\n}", "{\n    //\
    \ TODO: implement\n    return true;\n}", "{\n    auto sl = tuple(a, b, c);\n \
    \   sort(sl);\n    auto aa = sl[0], bb = sl[1], cc = sl[2];\n    return (aa *\
    \ aa + bb * bb == cc * cc);\n}", "{\n    long s = a + b + c;\n    return (s *\
    \ s) == (2 * a * a + 2 * b * b + 2 * c * c);\n}\n/*", "{\n    if(a == 0 || b ==\
    \ 0 || c == 0)\n        return false;\n    long[long] m = [a : a, b : b, c : c];\n\
    \    double[long] n = [a : a, b : b, c : c];\n    double temp = 0;\n    foreach(i;\
    \ m)\n    {\n        if(i.value < temp)\n        {\n            temp = i.value;\n\
    \            n[i.key] = pow(i.value, 2);\n        }\n        else\n        {\n\
    \            n[i.key] = pow(i.value, 2);\n        }\n    }\n    double s = 0;\n\
    \    foreach(i; n)\n    {\n        s += i.value;\n    }\n    return (s == 2 *\
    \ pow(temp, 2));\n}", "{\n    long[int] ls = [-1L, a, b, c];\n    sort(ls);\n\
    \    long[int] sqrts = [0L, a * a, b * b, c * c];\n    return ls[3] * ls[3] ==\
    \ sqrts[2] + sqrts[1];\n}", "{\n    if (a <= 0 || b <= 0 || c <= 0) return false;\n\
    \    tuple(long, long, long) sides = tuple(a, b, c);\n    sort!(\"a > b\")(sides);\n\
    \    return sides[0] * sides[0] == sides[1] * sides[1] + sides[2] * sides[2];\n\
    }", "{\n    return pow(a, 2) + pow(b, 2) == pow(c, 2);\n}", "{\n    long[] triangle\
    \ = new long[3];\n    triangle[0] = a;\n    triangle[1] = b;\n    triangle[2]\
    \ = c;\n    // sort triangle\n    std.algorithm.sort(triangle);\n    /*\n    \
    \    if one angle is 90 degree then c^2 = a^2 + b^2\n        where, c - is the\
    \ hypotenuse and a and b are two sides\n    */\n    return pow(triangle[2], 2)\
    \ == pow(triangle[0], 2) + pow(triangle[1], 2);\n}", "{\n    auto sides = Tuple!long(a,\
    \ b, c);\n    auto biggest = max(sides);\n    auto smaller = max(sides.array.array.take(2));\n\
    \    return (biggest*biggest == smaller*smaller + sides.array.array.take(2).reduce!((a,\
    \ b) => a + b)(0));\n}\n/*\n    You are given a two-digit number a, consisting\
    \ of the digits a1 and a2. \n    You are also given a two-digit number b, consisting\
    \ of the digits b1 and b2. \n    You are asked to calculate the sum of a and b.",
  "{\n    // convert everything to doubles\n    // to avoid integer overflow\n   \
    \ double dA = cast(double)a;\n    double dB = cast(double)b;\n    double dC =\
    \ cast(double)c;\n    double max = dA > dB ? dA : dB;\n    max = max > dC ? max\
    \ : dC;\n    double sMax = dA + dB + dC - max;\n    return (sMax * sMax) == (max\
    \ * max);\n}", "{\n    bool result = false;\n    real A = real(a), B = real(b),\
    \ C = real(c);\n    real angleA = acos((B*B + C*C - A*A)/(2*B*C));\n    real angleB\
    \ = acos((A*A + C*C - B*B)/(2*A*C));\n    real angleC = acos((A*A + B*B - C*C)/(2*A*B));\n\
    \    if ((equal(angleA, 90) || equal(angleB, 90) || equal(angleC, 90)))\n    \
    \    result = true;\n    return result;\n}", "{\n    long[] sides = [a, b, c];\n\
    \    sort(sides);\n    if (sides[0] <= 0 || sides[1] <= 0 || sides[2] <= 0) {\n\
    \        return false;\n    }\n    else if (sides[0]*sides[0] + sides[1]*sides[1]\
    \ == sides[2]*sides[2]) {\n        return true;\n    }\n    else {\n        return\
    \ false;\n    }\n}", "{\n    // your code here\n    int arr[3];\n    arr[0] =\
    \ a;\n    arr[1] = b;\n    arr[2] = c;\n    sort(arr);\n    if(((arr[0] * arr[0])\
    \ + (arr[1] * arr[1])) == (arr[2] * arr[2]))\n        return true;\n    else\n\
    \        return false;\n}", "{\n    return (a * a + b * b == c * c) ? true : false;\n\
    }", "{\n    auto sorted = tuple(a, b, c).map!(abs).sort!(a, b, c => a < b);\n\
    \    return sorted[2] * sorted[2] == sorted[0] * sorted[0] + sorted[1] * sorted[1];\n\
    }", "{\n    long[] sides = [a, b, c];\n    sort(sides);\n    return sides[0]*sides[0]\
    \ + sides[1]*sides[1] == sides[2]*sides[2];\n}", "{\n    if(a>b && a>c){\n   \
    \     if(a*a == b*b + c*c){\n            return true;\n        }\n    }else if(b>a\
    \ && b>c){\n        if(b*b == a*a + c*c){\n            return true;\n        }\n\
    \    }else if(c>a && c>b){\n        if(c*c == a*a + b*b){\n            return\
    \ true;\n        }\n    }\n    return false;\n}\n/*\n    Given a string s and\
    \ an array of pairs of indices in the string \n    pair[i] = (i1, i2). Remove\
    \ the characters in s between indices \n    pair[i].first and pair[i].second (inclusive)\
    \ and replace them \n    with their reversed.\n    Example:\n    >>> remove_pairs_and_reverse(\"\
    aacecaaa\", [make_pair(0,2), make_pair(4,7)])\n    \"aaaceca\"\n    >>> remove_pairs_and_reverse(\"\
    abcdefg\", [make_pair(1,4), make_pair(5,6)])\n    \"abfedcg\"\n*/\nstring remove_pairs_and_reverse(string\
    \ s, pair[] p) \n{\n    int[] a = new int[s.length];\n    for(int i=0; i<s.length;\
    \ ++i){\n        a[i] = 1;\n    }\n    foreach(pair pp; p){\n        int t = pp.first;\n\
    \        while(t<=pp.second){\n            a[t] = 0;\n            ++t;\n     \
    \   }\n    }\n    string s1 = \"\";\n    foreach(int i; a){\n        if(i==1){\n\
    \            s1 ~= s[i];\n        }\n    }\n    int n = s1.length;\n    int t\
    \ = n/2;\n    for(int i=0; i<t; ++i){\n        string s2 = s1[i];\n        s1[i]\
    \ = s1[n-i-1];\n        s1[n-i-1]", "{\n    // int sum;\n    return a*a + b*b\
    \ == c*c;\n}", "{\n    long x = pow(a, 2);\n    long y = pow(b, 2);\n    long\
    \ z = pow(c, 2);\n    if (x + y == z || x + z == y || y + z == x)\n        return\
    \ true;\n    else\n        return false;\n}", "{\n    long hyp, cat1, cat2;\n\
    \    if(a > b && a > c)\n    {\n        hyp = a;\n        cat1 = b;\n        cat2\
    \ = c;\n    }\n    else if(b > a && b > c)\n    {\n        hyp = b;\n        cat1\
    \ = a;\n        cat2 = c;\n    }\n    else\n    {\n        hyp = c;\n        cat1\
    \ = a;\n        cat2 = b;\n    }\n    return ((cat1*cat1) + (cat2*cat2)) == (hyp*hyp);\n\
    }", "{\n    size_t largest = 0;\n    auto sides = tuple(a, b, c);\n    if(a ==\
    \ b && b == c) return false;\n    return pow(get!largest(sides), 2) == pow(get!(largest+1)(sides),\
    \ 2) + pow(get!(largest+2)(sides), 2);\n}", "{\n    // Given sides a, b, c, checks\
    \ if the triangle is right angled\n    // by comparing the length of the longest\
    \ side to the sum of the\n    // length of the other two sides.\n    long a_1,\
    \ b_1, c_1;\n    a_1 = a;\n    b_1 = b;\n    c_1 = c;\n    if(a > b)\n    {\n\
    \        if(a > c)\n        {\n            if(pow(a, 2) == pow(b, 2) + pow(c,\
    \ 2))\n            {\n                return true;\n            }\n          \
    \  else\n            {\n                return false;\n            }\n       \
    \ }\n        else\n        {\n            if(pow(c, 2) == pow(a, 2) + pow(b, 2))\n\
    \            {\n                return true;\n            }\n            else\n\
    \            {\n                return false;\n            }\n        }\n    }\n\
    \    else\n    {\n        if(b > c)\n        {\n            if(pow(b, 2) == pow(a,\
    \ 2) + pow(c, 2))\n            {\n                return true;\n            }\n\
    \            else\n            {\n                return false;\n            }\n\
    \        }\n        else\n        {\n            if(pow(c, 2) == pow(a, 2) + pow(b,\
    \ 2))\n            {\n                return true;\n            }\n          \
    \  else\n            {\n                return false;\n            }\n       \
    \ }\n    }\n}\n/*", "{\n    return (a * a + b * b == c * c) || (a * a + c * c\
    \ == b * b) || (b * b + c * c == a * a);\n}", "{\n    Tuple!(long, long, long)\
    \ t = tuple(a, b, c);\n    // Sort the values from small to large\n    sort(t);\n\
    \    // Pythagorean's Theorem:\n    // The sum of the squares of the two shorter\
    \ legs is equal to the square\n    // of the hypotenuse\n    return (t[0] * t[0]\
    \ + t[1] * t[1]) == (t[2] * t[2]);\n}", "{\n    auto lengths = typeof(return)([a,\
    \ b, c]);\n    sort(lengths);\n    return (lengths[0] ^^ 2) + (lengths[1] ^^ 2)\
    \ == (lengths[2] ^^ 2);\n}", "{\n    return a * a + b * b == c * c;\n}", "{\n\
    \    auto p = tuple(a, b, c);\n    // Make sure that a <= b <= c.\n    sort(p);\n\
    \    return pow(get!0(p), 2) + pow(get!1(p), 2) == pow(get!2(p), 2);\n}\n/*\n\
    \    Anagrams are words formed by rearranging the letters of another word.\n \
    \   Example:\n    >>> anagrams(\"dog\", \"God\")\n    true\n    >>> anagrams(\"\
    hello\", \"olleh\")\n    true\n    >>> anagrams(\"test\", \"tstt\")\n    false\n\
    */", "{\n    struct Triple(T)\n    {\n        T[3] arr;\n        size_t i;\n \
    \       @property size_t length() const pure nothrow \n        {\n           \
    \ return 3;\n        }\n        @property T opIndex(size_t n) const pure nothrow\
    \ \n        {\n            return arr[n];\n        }\n        @property T opIndexAssign(T\
    \ value, size_t n) pure nothrow \n        {\n            return arr[n] = value;\n\
    \        }\n        @property T front() const pure nothrow \n        {\n     \
    \       return arr[0];\n        }\n        @property T back() const pure nothrow\
    \ \n        {\n            return arr[2];\n        }\n        @property T popFront()\
    \ pure nothrow \n        {\n            return arr[i++];\n        }\n        @property\
    \ Triple opCat(Tuple!(T, T) t) const pure nothrow \n        {\n            auto\
    \ _arr = Triple!T(uninitialized);\n            _arr.arr = arr;\n            _arr.arr[i++]\
    \ = t[0];\n            _arr.arr[i++] = t[1];\n            return _arr;\n     \
    \   }\n    }\n    auto _max = max(a, b, c);\n    auto _min = min(a, b, c);\n \
    \   // if the length of the longest side is bigger than the sum of the other\n\
    \    // two sides\n    if (_max > _min + min(a, b, c))\n        return false;\n\
    \    auto _arr = Triple!long(uninitialized);\n    _arr[0] = a;\n    _arr[1] =\
    \ b;\n    _arr[2] = c;\n    sort!qsort(_arr);\n    if (_arr[0] * _arr[0] + _arr[1]\
    \ * _arr[1] == _arr[2] * _arr[2])\n        return true;\n    return false;\n}",
  "{\n    // make list of the 3 lengths\n    auto sideList = tuple(a, b, c);\n   \
    \ // sort the list in ascending order\n    sort(sideList);\n    // get the largest\
    \ number from sideList\n    auto max = sideList[$-1];\n    // get sum of first\
    \ two values from sideList\n    auto sum = sideList[0] + sideList[1];\n    //\
    \ if the max is the hypotenuse\n    if(max == sqrt(sum * sum))\n    {\n      \
    \  return true;\n    }\n    else\n    {\n        return false;\n    }\n}", "{\n\
    \    long[] array = [a, b, c];\n    sort(array);\n    long sum = 0;\n    foreach(array[],\
    \ (int i; long element) {\n        if (i != array.length - 1) {\n            sum\
    \ += element * element;\n        }\n    }\n    if (sum == array[array.length -\
    \ 1] * array[array.length - 1]) {\n        return true;\n    }\n    return false;\n\
    }", "{\n    return (a <= 0 || b <= 0 || c <= 0) ? false : \n        (abs(pow(a,\
    \ 2) + pow(b, 2) - pow(c, 2)) < 0.001 ||\n        abs(pow(a, 2) + pow(c, 2) -\
    \ pow(b, 2)) < 0.001 ||\n        abs(pow(b, 2) + pow(c, 2) - pow(a, 2)) < 0.001);\n\
    }", "{\n    auto sides = tuple(a, b, c);\n    auto sum_squares = sides[0]*sides[0]\
    \ + sides[1]*sides[1] + sides[2]*sides[2];\n    auto max_side = max(sides);\n\
    \    return sum_squares - max_side*max_side == max_side*max_side;\n}", "{\n  \
    \  bool answer = false;\n    long[] side = [a, b, c];\n    int index;\n    sort(side);\n\
    \    auto t = tuple(side[0], side[1], side[2]);\n    if(t[0] == t[1] && t[0] ==\
    \ t[2]) \n    {\n        answer = false;\n    }\n    else if(pow(t[0], 2) + pow(t[1],\
    \ 2) == pow(t[2], 2)) \n    {\n        answer = true;\n    }\n    return answer;\n\
    }", "{\n    if (a < 0 || b < 0 || c < 0) \n        return false;\n    \n    //\
    \ pythagorean theorem\n    if (is_identical(pow(a, 2) + pow(b, 2), pow(c, 2)))\
    \ \n        return true;\n    else if (is_identical(pow(b, 2) + pow(c, 2), pow(a,\
    \ 2))) \n        return true;\n    else if (is_identical(pow(a, 2) + pow(c, 2),\
    \ pow(b, 2))) \n        return true;\n    else \n        return false;\n}", "{\n\
    \tdouble max_side = max(a,max(b,c));\n\tdouble hyp = pow(max_side,2);\n\t\n\t\
    double remaining_side = pow(a,2) + pow(b,2) + pow(c,2) - hyp;\n\tif(remaining_side\
    \ == hyp)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "{\n    enum inner_type\
    \ = real;\n    auto largest = max(a, b, c);\n    auto hyp = largest.front;\n \
    \   auto other = a + b + c - hyp;\n    static if (hyp > 0 && other > 0)\n    {\n\
    \        enum inner_type = real;\n        return (hyp * hyp) == (other * other);\n\
    \    }\n    return false;\n}", "{\n    Tuple!(long, long, long) sides = tuple(a,\
    \ b, c);\n    sides.sort;\n    return sides[0] * sides[0] + sides[1] * sides[1]\
    \ == sides[2] * sides[2];\n}", "{\n    tuple(long, long, long) p = sort(tuple(a,\
    \ b, c));\n    long z = p[0], x = p[1], y = p[2];\n    if (z * z + x * x == y\
    \ * y) {\n        return true;\n    }\n    return false;\n}", "{\n    // Pythagorean\
    \ Theorem states that a2 + b2 = c2\n    // or c2 = a2 + b2\n    // so for a right-angled\
    \ triangle we can get the hypotenuse\n    // square root of c2 which is c\n  \
    \  if (c == sqrt(a*a + b*b))\n        return true;\n    else \n        return\
    \ false;\n}", "{\n    auto triangle = tuple(a, b, c);\n    // sort by descending\n\
    \    sort!((a, b) => b < a)(triangle);\n    //a^2 = b^2 + c^2\n    return pow(triangle[0],\
    \ 2) == pow(triangle[1], 2) + pow(triangle[2], 2);\n}", "{\n    // find the largest\
    \ value of the three\n    long largest = max(a, max(b, c));\n    // subtract the\
    \ largest from the sum of the other two\n    long theRest = a + b + c - largest;\n\
    \    // if the square of the largest is equal to the sum of the squares of the\
    \ other two\n    // then you have a right-angle triangle\n    return largest *\
    \ largest == theRest * theRest;\n}", "{\n    return a*a+b*b==c*c;\n}\n/*", "{\n\
    \    if (a > b && a > c)\n    {\n        if (pow(a, 2) == pow(b, 2) + pow(c, 2))\n\
    \            return true;\n    }\n    else if (b > a && b > c)\n    {\n      \
    \  if (pow(b, 2) == pow(a, 2) + pow(c, 2))\n            return true;\n    }\n\
    \    else if (c > a && c > b)\n    {\n        if (pow(c, 2) == pow(a, 2) + pow(b,\
    \ 2))\n            return true;\n    }\n    return false;\n}\n/*\n \n    Given\
    \ a non-negative integer n. Print the nth triangle number. The nth \n    triangle\
    \ number is defined as the sum of the first n natural numbers.\n    Example:\n\
    \    >>> triangle_num(0L)\n    0\n    >>> triangle_num(1L)\n    1\n    >>> triangle_num(4L)\n\
    \    10\n*/", "{\n    Tuple!(long, long, long) abc = tuple(a, b, c);\n    // find\
    \ largest side\n    long largest = 0;\n    foreach(side; abc)\n    {\n       \
    \ if(side > largest)\n        {\n            largest = side;\n        }\n    }\n\
    \    // append smallest to second\n    abc = abc.filter!(n => n != largest);\n\
    \    // square them, then add and compare with largest^2\n    auto a2 = abc[0]\
    \ * abc[0];\n    auto b2 = abc[1] * abc[1];\n    return a2 + b2 == largest * largest;\n\
    }", "{\n  if(a <= 0 || b <= 0 || c <= 0) return false;", "{\n    constant(double,\
    \ EPS = 1e-9);\n    const auto x = sqrt(a * a + b * b);\n    const auto z = abs(c\
    \ - x);\n    return z < EPS;\n}", "{\n    enum Angle = 90;\n    auto triangle\
    \ = tuple(a, b, c);\n    auto[max, min1, min2] = std.algorithm.maxElement(triangle);\n\
    \    auto[min, max1, max2] = std.algorithm.minElement(triangle);\n    auto angle\
    \ = cast(Angle)acos(dotProduct(tuple(min1, min2), tuple(max1, max2)) / (sqrt(min1\
    \ ^^ 2 + min2 ^^ 2) * sqrt(max1 ^^ 2 + max2 ^^ 2)));\n    return (angle == Angle.right)\
    \ ? true : false;\n}", "{\n    if(a >= b && a >= c)\n    {\n        return a *\
    \ a == b * b + c * c;\n    }\n    else if(b >= a && b >= c)\n    {\n        return\
    \ b * b == a * a + c * c;\n    }\n    else\n    {\n        return c * c == a *\
    \ a + b * b;\n    }\n}", "{\n    // let the longest leg of the triangle be the\
    \ one that is opposite\n    // the 90-degree angle. \n    //\n    // Let us know\
    \ label the sides of the triangle as follows:\n    //\n    //   90-degree angle\
    \ is at b\n    //\n    //     b\n    //    /|\n    //   / |\n    //  /  |\n  \
    \  // c---a\n    //\n    // Since we don't know a priori which side of the triangle\
    \ is the longest,\n    // we will first find the longest side and label that side\
    \ b.\n    //\n    // To determine if a given triangle is a right-angle triangle,\
    \ we will\n    // use the Pythagorean theorem, which states that the sum of the\
    \ squares of\n    // the two shorter sides of a right triangle is equal to the\
    \ square of the\n    // length of the longest side.\n    //\n    // The Pythagorean\
    \ theorem says that a^2 + b^2 = c^2\n    //\n    // Thus, we have:\n    //\n \
    \   // a^2 + b^2 = c^2\n    // a^2 + c^2 = b^2\n    // b^2 + c^2 = a^2\n    //\n\
    \    // Given that we have labeled the longest side as b, then if the triangle\n\
    \    // is a right-angle triangle, we should find that the sum of squares of\n\
    \    // the other two sides is equal to the square of the length of the longest\n\
    \    // side.\n    //\n    // i.e. b^2 = a^2 + c^2\n    //\n    // Then if a^2\
    \ + c^2 == b^2 then the triangle is a right-angle triangle.\n    //\n    auto\
    \ r = tuple(a, b, c);\n    sort(r);\n    // now b is the longest side\n    return\
    \ (r[0] * r[0] + r[1] * r[1]) == (r[2] * r[2]);\n}", "{\n    //...\n    tuple!(long,\
    \ long, long) sides = tuple(a, b, c);\n    sort(sides, cmp(n1, n2) {return n1\
    \ > n2;});\n    return pow(sides[0], 2) == pow(sides[1], 2) + pow(sides[2], 2);\n\
    }", "{\n    long[long] \n        ab = typeof(ab)(a, b),\n        bc = typeof(bc)(b,\
    \ c),\n        ca = typeof(ca)(c, a);\n    return \n        (a > 0 && b > 0 &&\
    \ c > 0) &&\n        ((a * a + b * b == c * c) || \n        (b * b + c * c ==\
    \ a * a) || \n        (c * c + a * a == b * b));\n}", "{\n    // Hypotenuse is\
    \ the longest side in right triangle.\n    // http://en.wikipedia.org/wiki/Pythagorean_theorem\n\
    \    if (a > b && a > c) {\n        return a*a == b*b + c*c;\n    } else if (b\
    \ > a && b > c) {\n        return b*b == a*a + c*c;\n    } else if (c > a && c\
    \ > b) {\n        return c*c == a*a + b*b;\n    }\n    return false;\n}", "{\n\
    \    return isRightAngleTriangle(a, b, c);\n}", "{\n    const int MIN_SIDE = 1;\n\
    \    const int MAX_SIDE = 1000000000;\n    // validate input\n    if (a <= MIN_SIDE\
    \ || a >= MAX_SIDE) return false;\n    if (b <= MIN_SIDE || b >= MAX_SIDE) return\
    \ false;\n    if (c <= MIN_SIDE || c >= MAX_SIDE) return false;\n    // now the\
    \ input is valid\n    long A = max(a,b);\n    long B = min(a,b);\n    long C =\
    \ c;\n    // validate sides\n    if (A > B + C) return false;\n    if (B > A +\
    \ C) return false;\n    if (C > A + B) return false;\n    // now the sides are\
    \ valid\n    if (abs(A*A - B*B - C*C) < 1e-6) return true;\n    return false;\n\
    }", "{\n    alias Tuple!(long, long, long) Tuple;\n    return a*a + b*b == c*c\
    \ ? true : false;\n}", "{\n    //Pythagorean theorem: \n    //a^2 + b^2 = c^2\n\
    \    //if a^2 + b^2 == c^2 => a triangle is right-angled\n    //if a^2 + b^2 >\
    \ c^2 => a triangle is obtuse\n    //if a^2 + b^2 < c^2 => a triangle is acute\n\
    \    //sum of squares of two cathetuses equals square of hypotenuse\n    return\
    \ (a * a + b * b == c * c);\n}\n/*", "{\n    auto lhs = hypot(a, b);\n    auto\
    \ rhs = c;\n    return lhs == rhs;\n}", "{\n    // parse error: the indexing operation\
    \ '[]' cannot be applied to type\n    long[3] sides = [a, b, c];\n    // TypeError:\
    \ unsupported types for __pow__: 'tuple' and 'int'\n    real [3] areas = [ sides[0]\
    \ * sides[0], sides[1] * sides[1], sides[2] * sides[2] ];\n    sort(areas);\n\
    \    real sum_two_smaller = areas[0] + areas[1];\n    real biggest = areas[2];\n\
    \    return sum_two_smaller == biggest;\n}", "{\n    double angleA = 0.0;\n  \
    \  double angleB = 0.0;\n    double angleC = 0.0;\n    if (a == 0 || b == 0 ||\
    \ c == 0)\n        return false;\n    if (a == b && b == c)\n        return false;\n\
    \    if (a > b && a > c)\n    {\n        angleA = 90.0;\n        angleB = degrees(acos((pow(b,\
    \ 2) + pow(c, 2) - pow(a, 2)) / (2 * b * c)));\n        angleC = degrees(acos((pow(a,\
    \ 2) + pow(c, 2) - pow(b, 2)) / (2 * a * c)));\n    }\n    else if (b > a && b\
    \ > c)\n    {\n        angleB = 90.0;\n        angleA = degrees(acos((pow(a, 2)\
    \ + pow(c, 2) - pow(b, 2)) / (2 * a * c)));\n        angleC = degrees(acos((pow(b,\
    \ 2) + pow(c, 2) - pow(a, 2)) / (2 * b * c)));\n    }\n    else if (c > a && c\
    \ > b)\n    {\n        angleC = 90.0;\n        angleA = degrees(acos((pow(a, 2)\
    \ + pow(b, 2) - pow(c, 2)) / (2 * a * b)));\n        angleB = degrees(acos((pow(b,\
    \ 2) + pow(c, 2) - pow(a, 2)) / (2 * b * c)));\n    }\n    return (angleA == 90.0\
    \ || angleB == 90.0 || angleC == 90.0);\n}", "{\n    if (a == 0 || b == 0 || c\
    \ == 0)\n        return false;\n    return a*a + b*b == c*c || b*b + c*c == a*a\
    \ || c*c + a*a == b*b;\n}", "{\n    // We need to check the Pythagorean theorem:\n\
    \    // a^2 + b^2 = c^2\n    // c^2 - a^2 - b^2 = 0\n    if (c*c - a*a - b*b ==\
    \ 0) return true;\n    else return false;\n}", "{\n    // your code goes here\n\
    \    if(a > 0 && b > 0 && c > 0)\n    {\n        // First - check special case,\
    \ in which one cathetus is equal to zero.\n        if(a == 0 || b == 0 || c ==\
    \ 0)\n        {\n            return false;\n        }\n        // Now - we can\
    \ do Pythagorean theorem  a^2 + b^2 = c^2\n        a = a*a;\n        b = b*b;\n\
    \        c = c*c;\n        return (a + b == c) || (a + c == b) || (b + c == a);\n\
    \    }\n    return false;\n}\n/* \n    Given integers a and b, find their greatest\
    \ common divisor.\n    Example:\n    >>> gcd(18, 35)\n    1\n    >>> gcd(14159572,\
    \ 63967072)\n    4\n*/\nlong gcd(long a, long b) \n{\n    // your code goes here\n\
    \    // I used Euclid's algorithm:\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    if(a == 0 || b == 0)\n    {\n        return 0;\n    }\n    if(a == b)\n \
    \   {\n        return a;\n    }\n    while(a != b)\n    {\n        if(a > b)\n\
    \        {\n            a = a - b;\n        }\n        else\n        {\n     \
    \       b = b - a;\n        }\n    }\n    return a;\n}\n/*\n    Let's define the\
    \ Fibonacci numbers using the following recurrence relation:\n    F(0) = 0, F(1)\
    \ = 1, F(n+2) = F(n+1) + F(n) for n\u22650.\n    Given an integer n, calculate\
    \ F(n).\n    Example:\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(8)\n   \
    \ 21\n*/\nlong fibonacci(long n) \n{\n    // your code goes here\n    if(n < 0)\n\
    \    {\n        return 0;\n    }\n    if(n", "{\n    //returns true if a squared\
    \ + b squared = c squared\n    if(a == 0 || b == 0 || c == 0)\n        return\
    \ false;\n    long a2 = a * a;\n    long b2 = b * b;\n    long c2 = c * c;\n \
    \   return (a2 + b2 == c2) || (b2 + c2 == a2) || (a2 + c2 == b2);\n}\n/*\n   \
    \ Given an integer, n, return the nth fibonacci number.\n    The nth Fibonacci\
    \ number is defined as: F(n) = F(n - 1) + F(n - 2),\n    where F(0) = 0 and F(1)\
    \ = 1.", "{\n    // a = 3, b = 4, c = 5\n    // gcd(a, b) = 1, gcd(b, c) = 1,\
    \ gcd(a, c) = 1\n    return gcd(a, b) == 1 && gcd(b, c) == 1 && gcd(a, c) == 1;\n\
    }", "{\n    long[long] sides;\n    sides[a] = a;\n    sides[b] = b;\n    sides[c]\
    \ = c;\n    auto maxSide = minElement(sides.byValue.sort).front;\n    auto remainSides\
    \ = sides.byValue.sort.retro.take(2);\n    auto rightAngleTriangle = (maxSide*maxSide)\
    \ == \n                              (remainSides[0]*remainSides[0] + \n     \
    \                          remainSides[1]*remainSides[1]);\n    return rightAngleTriangle;\n\
    }", "{\n    if(a > b && a > c)\n    {\n        return pow(a, 2) == pow(b, 2) +\
    \ pow(c, 2);\n    }\n    else if(b > a && b > c)\n    {\n        return pow(b,\
    \ 2) == pow(a, 2) + pow(c, 2);\n    }\n    else if(c > a && c > b)\n    {\n  \
    \      return pow(c, 2) == pow(a, 2) + pow(b, 2);\n    }\n    else return false;\n\
    }\n/*\n    An OrderedPair is given by two of its components, the x component and\
    \ the y component.\n    OrderedPair is a convenience type that allows accessing\
    \ the x component and y component\n    through the .x and .y members respectively.\n\
    \    The ordering of the x and y component for an OrderedPair is significant when\n\
    \    constructing an OrderedPair.\n    An OrderedPair is immutable.\n    You should\
    \ not use this type directly in your code. Instead, use the\n    std.algorithm.interval.orderedPair\
    \ function when constructing an\n    OrderedPair is necessary.\n    Parameters:\n\
    \    T = the type of the x and y components\n    Example:\n    >>> auto p = OrderedPair!int(3,\
    \ 4);\n    >>> p.x\n    3\n    >>> p.y\n    4\n    >>> OrderedPair!int(3, 4) ==\
    \ OrderedPair!int(3, 4)\n    true\n    >>> OrderedPair!int(3, 4) == OrderedPair!int(4,\
    \ 3)\n    false\n    >>> OrderedPair!int(3, 4) == p\n    true\n    >>> OrderedPair!int(4,\
    \ 3) == p\n    false\n    >>> OrderedPair!int(4, 4) == p\n    false\n*/\nstruct\
    \ OrderedPair(T)\n{\n    private T[2] values;\n    this(T x, T y) {\n        values\
    \ = [x, y];\n    }\n    @property T x() {\n        return values[0];\n    }\n\
    \    @property T y()", "{\n    long[] triangle_side_arr = to!(long[])([a, b, c]);\n\
    \    bubble_sort(triangle_side_arr);\n    return triangle_side_arr[0] * triangle_side_arr[0]\
    \ + triangle_side_arr[1] * triangle_side_arr[1] == triangle_side_arr[2] * triangle_side_arr[2];\n\
    }", "{\n    bool result = false;\n    if (a == 0L || b == 0L || c == 0L)\n   \
    \ {\n        result = false;\n    }\n    else\n    {\n        // sort the values\
    \ \n        tuple(long, long, long) input = tuple(a, b, c);\n        auto minmax\
    \ = minmaxElement(input);\n        tuple(long, long, long) sorted = tuple(minmax[0],\
    \ tuple_element!1(input), minmax[1]);\n        // get the max and min value\n\
    \        long min = tuple_element!0(sorted);\n        long max = tuple_element!2(sorted);\n\
    \        // check if the result is a right angle triangle\n        if (pow(max,\
    \ 2) == pow(min, 2) + pow(tuple_element!1(sorted), 2))\n        {\n          \
    \  result = true;\n        }\n    }\n    return result;\n}", "{\n    int tmp;\n\
    \    auto tmp1 = Tuple!(int, int, int)(a, b, c);\n    tmp1.sort();\n    a = tmp1[0];\n\
    \    b = tmp1[1];\n    c = tmp1[2];\n    auto p = (a*a) + (b*b);\n    auto q =\
    \ c*c;\n    if (p == q)\n        return true;\n    else\n        return false;\n\
    \    \n}", "{\n    if(!(a > 0 && b > 0 && c > 0)) return false;\n    auto sides\
    \ = Tuple!(long, long, long)(a, b, c);\n    sides = sides.sort();\n    return\
    \ pow(sides[0], 2) + pow(sides[1], 2) == pow(sides[2], 2);\n}", "{\n    long s[]\
    \ = [a, b, c];\n    sort(s);\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n\
    }", "{\n    long[] triangle = [a, b, c];\n    sort(triangle);\n    if (triangle[0]\
    \ * triangle[0] + triangle[1] * triangle[1] == triangle[2] * triangle[2])\n  \
    \      return true;\n    return false;\n}", "{\n    return abs(a * a + b * b -\
    \ c * c) < 1e-9;\n}", "{\n    bool result = false;\n    enum bool isRight = false;\n\
    \    bool isRightTriangle = false;\n    if (a == b)\n    {\n        if (c * c\
    \ == (a * a + b * b))\n        {\n            isRight = true;\n        }\n   \
    \ }\n    else if (a == c)\n    {\n        if (b * b == (a * a + c * c))\n    \
    \    {\n            isRight = true;\n        }\n    }\n    else if (b == c)\n\
    \    {\n        if (a * a == (b * b + c * c))\n        {\n            isRight\
    \ = true;\n        }\n    }\n    return isRight;\n}", "{\n    long[] triangle_sides\
    \ = [a, b, c];\n    long temp;\n    // sort the triangle sides by ascending order\n\
    \    // we only need to look at the biggest side\n    if (triangle_sides[0] >\
    \ triangle_sides[1])\n    {\n        temp = triangle_sides[0];\n        triangle_sides[0]\
    \ = triangle_sides[1];\n        triangle_sides[1] = temp;\n    }\n    if (triangle_sides[1]\
    \ > triangle_sides[2])\n    {\n        temp = triangle_sides[1];\n        triangle_sides[1]\
    \ = triangle_sides[2];\n        triangle_sides[2] = temp;\n    }\n    if (triangle_sides[0]\
    \ > triangle_sides[1])\n    {\n        temp = triangle_sides[0];\n        triangle_sides[0]\
    \ = triangle_sides[1];\n        triangle_sides[1] = temp;\n    }\n    return (triangle_sides[0]\
    \ + triangle_sides[1] == triangle_sides[2]);\n}", "{\n    // do not worry about\
    \ the positivity of the side lengths\n    Tuple!(long, long, long) sides = tuple(a,\
    \ b, c);\n    bool right_triangle = false;\n    long right_angle_side = 0;\n \
    \   long[] other_sides = [0, 0];\n    int side_counter = 0;\n    foreach(side;\
    \ sides)\n    {\n        if(side > 0)\n        {\n            if(side_counter\
    \ == 0)\n            {\n                right_angle_side = side;\n           \
    \ }\n            else\n            {\n                other_sides[side_counter\
    \ - 1] = side;\n            }\n            side_counter++;\n        }\n    }\n\
    \    if(side_counter == 3)\n    {\n        if(right_angle_side * right_angle_side\
    \ == \n            other_sides[0] * other_sides[0] + other_sides[1] * other_sides[1])\n\
    \        {\n            right_triangle = true;\n        }\n    }\n    return right_triangle;\n\
    }", "{\n    auto [x, y, z] = tuple(a, b, c).sort();\n    return x*x + y*y == z*z;\n\
    }", "{\n  /*\n      The Pythagorean theorem states that the sum of the squares\
    \ of the \n      lengths of the two shorter sides of a right triangle is equal\
    \ to the \n      square of the length of the hypotenuse.\n      If you want to\
    \ make sure you don't get floating point errors, you can \n      use the following\
    \ formula:\n      \n      Given a, b, c, we should have:\n      (a*a + b*b) ==\
    \ (c*c) OR\n      (a*a + c*c) == (b*b) OR\n      (b*b + c*c) == (a*a) \n  */\n\
    \  long aa = a*a;\n  long bb = b*b;\n  long cc = c*c;\n  return (aa + bb == cc)\
    \ || (aa + cc == bb) || (bb + cc == aa);\n}", "{\n    // your code goes here\n\
    \    long[] sides = [a, b, c];\n    sort(sides);\n    return sides[0] * sides[0]\
    \ + sides[1] * sides[1] == sides[2] * sides[2];\n}", "{\n    struct result(T1,\
    \ T2) {\n        T1 min_side;\n        T2 max_side;\n    }\n    auto hypotenuse\
    \ = [](long a, long b, long c) {\n        return result(a, b, max(c, max(a, b)));\n\
    \    };\n    auto cathetus = [](long a, long b, long c) {\n        return result(a,\
    \ b, min(a, b));\n    };\n    auto[min_side, max_side] = hypotenuse(a, b, c);\n\
    \    return pow(min_side, 2) + pow(max_side, 2) == pow(c, 2);\n}", "{\n    if\
    \ (a < 1 || b < 1 || c < 1)\n        return false;\n    if (a > b && a > c)\n\
    \        return pow(b, 2) + pow(c, 2) == pow(a, 2);\n    if (b > a && b > c)\n\
    \        return pow(a, 2) + pow(c, 2) == pow(b, 2);\n    if (c > a && c > b)\n\
    \        return pow(a, 2) + pow(b, 2) == pow(c, 2);\n    return false;\n}\n/*",
  "{\n    return ((a * a) + (b * b) == (c * c));\n}\n/*", "{\n    long[] arr = [a,\
    \ b, c];\n    sort(arr);\n    Tuple!(long, long, long) triangle = tuple(arr[0],\
    \ arr[1], arr[2]);\n    return triangle[0] * triangle[0] + triangle[1] * triangle[1]\
    \ == triangle[2] * triangle[2];\n}", "{\n    return abs(squared(a) + squared(b)\
    \ - squared(c)) <= 1e-6 ||\n        abs(squared(a) + squared(c) - squared(b))\
    \ <= 1e-6 ||\n        abs(squared(b) + squared(c) - squared(a)) <= 1e-6;\n}\n\
    // --------------------------------------------------------------------------\n\
    /*\n    You are given a string. Find out if the string is a palindrome or not.\n\
    \    A palindrome is a string that reads the same from both sides.\n    Example:\n\
    \    >>> is_palindrome(\"anna\")\n    true\n    >>> is_palindrome(\"walter\")\n\
    \    false\n*/", "{\n    auto p = tuple(a, b, c);\n    p = sort(p);\n    return\
    \ p[0] * p[0] + p[1] * p[1] == p[2] * p[2];\n}", "{\n    //Checks if a is the\
    \ hypotenuse\n    if ( pow(a, 2) == pow(b, 2) + pow(c, 2) )\n        return true;\n\
    \    //Checks if b is the hypotenuse\n    else if ( pow(b, 2) == pow(a, 2) + pow(c,\
    \ 2) )\n        return true;\n    //Checks if c is the hypotenuse\n    else if\
    \ ( pow(c, 2) == pow(a, 2) + pow(b, 2) )\n        return true;\n    else\n   \
    \     return false;\n}\n/*\n    Given two non-negative integers. Return true if\
    \ the two numbers have the \n    same last digit, false otherwise.\n    Example:\n\
    \    >>> same_last_digit(27, 57)\n    true\n    >>> same_last_digit(13, 53)\n\
    \    false\n    >>> same_last_digit(13, 133)\n    true\n*/", "{\n    if (a ==\
    \ 0 || b == 0 || c == 0) \n        return false;\n    if (a < 0 || b < 0 || c\
    \ < 0) \n        return false;\n    if ((a*a + b*b) == c*c) \n        return true;\n\
    \    if ((b*b + c*c) == a*a) \n        return true;\n    if ((a*a + c*c) == b*b)\
    \ \n        return true;\n    return false;\n}", "{\n    const long *max = std.typecons.maxOf(a,\
    \ b, c);\n    long sum = 0;\n    foreach(num; std.typecons.array(a, b, c))\n \
    \   {\n        if(num != *max)\n            sum += pow(num, 2);\n    }\n    return\
    \ sum == pow(*max, 2);\n}", "{\n    return (a > 0 && b > 0 && c > 0) && \n   \
    \     (a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b);\n}", "{\n  \
    \  // here type cons means type constructor https://tour.dlang.org/tour/en/gems/type-cons\n\
    \    if (a == 0 || b == 0 || c == 0)\n        return false;\n    // with typecons.Tuple\
    \ you can make an immutable tuple https://tour.dlang.org/tour/en/gems/type-cons-tuple\n\
    \    auto sides = typecons.Tuple!(long, long, long)(a, b, c);\n    // sort function\
    \ returns the given mutable array in sorted order https://tour.dlang.org/tour/en/gems/sorting\n\
    \    // it is only available in Phobos not in Tango\n    sides.sort();\n    //\
    \ toSquare returns the square of a number\n    return a.toSquare() + b.toSquare()\
    \ == c.toSquare();\n}", "{\n    enum Side { a, b, c } ;\n    auto t = tuple(a,\
    \ b, c);\n    auto hip = max(t);\n    auto diff = t - tuple(hip, hip, hip);\n\
    \    auto square = [](long a) -> long { return a * a; };\n    auto sum_square\
    \ = square(diff[a]) + square(diff[b]);\n    return square(hip) == sum_square;\n\
    }", "{\n    // assuming no null triangles\n    return a*a+b*b==c*c;\n}", "{\n\
    \    return (a > 0L && b > 0L && c > 0L) && is_almost_equal(pow(a, 2) + pow(b,\
    \ 2), pow(c, 2));\n}", "{\n    auto sides = tuple(a, b, c);\n    auto shortest_side\
    \ = min(a, b, c);\n    auto hypotenuse = max(a, b, c);\n    auto cathetus = sides[!(a\
    \ == shortest_side) && !(a == hypotenuse)];\n    return hypotenuse * hypotenuse\
    \ == shortest_side * shortest_side + cathetus * cathetus;\n}", "{\n    Tuple!(long,\
    \ long, long) triangle = tuple(a, b, c);\n    triangle = sort(triangle);", "{\n\
    \treal x = real(a);\n\treal y = real(b);\n\treal z = real(c);\n\t\n\treal a1 =\
    \ acos((y*y + z*z - x*x)/(2*y*z));\n\treal a2 = acos((x*x + z*z - y*y)/(2*x*z));\n\
    \treal a3 = acos((x*x + y*y - z*z)/(2*x*y));\n\t\n\treturn isApproxEqual(a1, pi/2)\
    \ || isApproxEqual(a2, pi/2) || isApproxEqual(a3, pi/2);\n}", "{\n    if(a ==\
    \ b && b == c)\n        return false;\n    if(a == 0 || b == 0 || c == 0)\n  \
    \      return false;\n    \n    if(a < b)\n        swap(a, b);\n    if(a < c)\n\
    \        swap(a, c);\n    if(b < c)\n        swap(b, c);\n    if(a > pow(b, 2)\
    \ + pow(c, 2))\n        return false;\n    if(a < pow(b, 2) + pow(c, 2))\n   \
    \     return true;\n    if(a == pow(b, 2) + pow(c, 2))\n        return true;\n\
    \    return false;\n}", "{\n    /*\n        The longest side of the triangle must\
    \ be shorter than the sum of the \n        other two sides.\n    */\n    long\
    \ max = max(a, b, c);\n    if(max == a) {\n        return b*b + c*c == a*a;\n\
    \    } else if(max == b) {\n        return a*a + c*c == b*b;\n    } else {\n \
    \       return a*a + b*b == c*c;\n    }\n}", "{\n    return a > 0 && b > 0 &&\
    \ c > 0 && a + b > c && a + c > b && b + c > a && \n           (pow(a, 2) + pow(b,\
    \ 2) == pow(c, 2) || pow(a, 2) + pow(c, 2) == pow(b, 2) || \n            pow(b,\
    \ 2) + pow(c, 2) == pow(a, 2));\n}", "{\n    Tuple!(long, long, long) sides =\
    \ tuple(a, b, c);\n    return (max(sides) == sqrt(pow(min(sides), 2) + pow(sides[3\
    \ - 1 - max(sides)], 2)));\n}", "{\n    if(a < 0 || b < 0 || c < 0)\n        return\
    \ false;\n    \n    const Triangle t = Tuple(a, b, c);\n    double x, y, z;\n\
    \    switch(t)\n    {\n        case Tuple(x, _, _):\n            // it is now\
    \ safe to dereference\n            y = t[1L];\n            z = t[2L];\n      \
    \      //x = t[0L]; // compile-time error\n            break;\n        case Tuple(_,\
    \ y, _):\n            // it is now safe to dereference\n            x = t[0L];\n\
    \            z = t[2L];\n            //y = t[1L]; // compile-time error\n    \
    \        break;\n        case Tuple(_, _, z):\n            // it is now safe to\
    \ dereference\n            x = t[0L];\n            y = t[1L];\n            //z\
    \ = t[2L]; // compile-time error\n            break;\n        default:\n     \
    \       assert(false);\n    }\n    \n    return x*x + y*y == z*z;\n}\n// Tuple!(long,\
    \ long, long) match\nstatic assert(is(typeof(triangle_type_tuple!(long, long,\
    \ long)) == Tuple!(long, long, long)));\n// Tuple!(int, int, int) match\nstatic\
    \ assert(is(typeof(triangle_type_tuple!(int, int, int)) == Tuple!(int, int, int)));\n\
    // Tuple!(int, long, long) match\nstatic assert(is(typeof(triangle_type_tuple!(int,\
    \ long, long)) == Tuple!(int, long, long)));\n// Tuple!(long, int, long) match\n\
    static assert(is(typeof(triangle_type_tuple!(long, int, long)) == Tuple!(long,\
    \ int, long)));\n// Tuple!(long, long, int) match\nstatic assert(is(typeof(triangle_type_tuple!(long,\
    \ long, int)) == Tuple!(long, long, int)));", "{\n    return (a * a + b * b ==\
    \ c * c) || (b * b + c * c == a * a) || (c * c + a * a == b * b);\n}\n// dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum, dum,\
    \ dum, dum, dum, dum, dum, dum, dum, dum, dum,", "{\n    long t_a = a * a;\n \
    \   long t_b = b * b;\n    long t_c = c * c;\n    return t_a + t_b == t_c || t_a\
    \ + t_c == t_b || t_b + t_c == t_a;\n}", "{\n    enum type {right, obtuse, acute};\n\
    \    const long max = max(a, max(b, c));\n    const long smax = (max == a ? max(b,\
    \ c) : (max == b ? max(a, c) : max(a, b)));\n    long min = min(a, min(b, c));\n\
    \    /*\n    Write a recursive template to calculate the factorial of a given\
    \ number.\n    Example:\n    >>> factorial!5\n    120\n    */\n    template factorial(n)\n\
    \    {\n        static if (n == 0)\n            const factorial = 1;\n       \
    \ else\n            const factorial = n * factorial!(n - 1);\n    }\n    if (max\
    \ * max == min * min + smax * smax)\n        return true;\n    else\n        return\
    \ false;\n}", "{\n    Tuple!(long, long, long) sides = tuple(a, b, c);\n    sort(sides);\n\
    \    return sides[0]*sides[0] + sides[1]*sides[1] == sides[2]*sides[2];\n}", "{\n\
    \    bool is_right_angle = false;\n    if(a <= 0 || b <= 0 || c <= 0)\n      \
    \  is_right_angle = false;\n    else {\n        if(pow(a, 2) + pow(b, 2) == pow(c,\
    \ 2))\n            is_right_angle = true;\n        else if(pow(b, 2) + pow(c,\
    \ 2) == pow(a, 2))\n            is_right_angle = true;\n        else if(pow(c,\
    \ 2) + pow(a, 2) == pow(b, 2))\n            is_right_angle = true;\n        else\n\
    \            is_right_angle = false;\n    }\n    return is_right_angle;\n}", "{\n\
    \    return a*a + b*b == c*c || b*b + c*c == a*a || c*c + a*a == b*b;\n}", "{\n\
    \  float x = a*a;\n  float y = b*b;\n  float z = c*c;\n  return (x+y == z) ||\
    \ (x+z == y) || (y+z == x);\n}", "{\n    typeof(a) longest;\n    typeof(a) shortest;\n\
    \    if(a > b && a > c)\n    {\n        longest = a;\n        if(b > c)\n    \
    \    {\n            shortest = c;\n        }\n        else\n        {\n      \
    \      shortest = b;\n        }\n    }\n    else if(b > a && b > c)\n    {\n \
    \       longest = b;\n        if(a > c)\n        {\n            shortest = c;\n\
    \        }\n        else\n        {\n            shortest = a;\n        }\n  \
    \  }\n    else\n    {\n        longest = c;\n        if(a > b)\n        {\n  \
    \          shortest = b;\n        }\n        else\n        {\n            shortest\
    \ = a;\n        }\n    }\n    return longest == shortest*shortest + longest*longest;\n\
    }", "{\n    bool result = false;\n    // write your code here\n    tuple!long\
    \ triangle = tuple(a, b, c);\n    sort(triangle);\n    if(triangle[0]*triangle[0]\
    \ + triangle[1]*triangle[1] == triangle[2]*triangle[2]){\n        result = true;\n\
    \    }\n    return result;\n}", "{\n    // Check if the given triangle is right\
    \ angle\n    return abs(pow(a, 2) + pow(b, 2) - pow(c, 2)) < 1e-9;\n}", "{\n \
    \   long m = min(a, min(b, c));\n    long M = max(a, max(b, c));\n    long m2\
    \ = a + b + c - m - M;\n    return M*M == m*m + m2*m2;\n}", "{\n    long t[] =\
    \ [a, b, c];\n    sort(t);\n    bool r = (t[0] * t[0] + t[1] * t[1]) == t[2] *\
    \ t[2];\n    return r;\n}", "{\n    Tuple!(long, long, long) t = tuple(a, b, c);\n\
    \    auto sorted = sort(t);\n    auto h = sorted[2];\n    auto p = sorted[0];\n\
    \    auto q = sorted[1];\n    return p*p + q*q == h*h;\n}", "{\n    // convert\
    \ longs to doubles\n    auto a_d = to!double(a);\n    auto b_d = to!double(b);\n\
    \    auto c_d = to!double(c);\n    \n    // calculate a^2, b^2, c^2\n    auto\
    \ a_squared = pow(a_d, 2);\n    auto b_squared = pow(b_d, 2);\n    auto c_squared\
    \ = pow(c_d, 2);\n    \n    // tuple return\n    // get the max of a and b, then\
    \ add them together, then compare\n    // with c^2\n    return tuple(a_squared,\
    \ b_squared).max + \n           tuple(a_squared, c_squared).max == \n        \
    \   tuple(b_squared, c_squared).max;\n}", "{\n    return a * a + b * b == c *\
    \ c || a * a + c * c == b * b || b * b + c * c == a * a;\n}", "{\n    typeof(a)\
    \ min_a, max_c;\n    float a2, b2, c2;\n    float sum_a2b2, dif_a2b2;\n    bool\
    \ test1, test2;\n    test1 = false;\n    test2 = false;\n    if(a <= 0 || b <=\
    \ 0 || c <= 0)\n        return false;\n    if(a == b && b == c)\n        return\
    \ false;\n    tuple(min_a, max_c) = minmax(a, c);\n    if(min_a == a)\n      \
    \  test1 = true;\n    if(max_c == c)\n        test2 = true;\n    if(!test1 ||\
    \ !test2)\n        return false;\n    a2 = a*a;\n    b2 = b*b;\n    c2 = c*c;\n\
    \    sum_a2b2 = a2 + b2;\n    dif_a2b2 = a2 - b2;\n    return (c2 == sum_a2b2\
    \ || c2 == dif_a2b2);\n}\n/*\n    Your task is to construct a building which will\
    \ be a pile of n cubes. \n    The cube at the bottom will have a volume of n^3,\
    \ the cube above will \n    have volume of (n-1)^3 and so on until the top which\
    \ will have a volume \n    of 1^3.\n    You are given the total volume m of the\
    \ building. Being given m can you \n    find the number n of cubes you will have\
    \ to build?\n    The parameter of the function findNb (find_nb, find-nb, findNb)\
    \ will be \n    an integer m and you have to return the integer n such as n^3\
    \ + (n-1)^3 \n    + ... + 1^3 = m if such a n exists or -1 if there is no such\
    \ n.\n    Examples:\n    >>> find_nb(1071225)\n    45\n    >>> find_nb(91716553919377)\n\
    \    -1\n*/", "{\n    if(a < b && a < c)\n    {\n        return (a*a) + (b*b)\
    \ == (c*c);\n    }\n    else if(b < a && b < c)\n    {\n        return (b*b) +\
    \ (a*a) == (c*c);\n    }\n    else if(c < a && c < b)\n    {\n        return (c*c)\
    \ + (a*a) == (b*b);\n    }\n    else\n    {\n        return false;\n    }\n}",
  "{\n    // a^2 + b^2 = c^2\n    // a^2 + b^2 - c^2 = 0\n    // (a^2 + b^2 - c^2)^2\
    \ = 0^2\n    // (a^2 + b^2 - c^2)^2 - 0^2 = 0\n    // (a^2 + b^2 - c^2)^2 - 0\
    \ = 0\n    // a^4 + 2a^2b^2 + b^4 - 2a^2c^2 - 2b^2c^2 + c^4 - 0 = 0\n    // a^4\
    \ + 2a^2b^2 + b^4 - 2a^2c^2 - 2b^2c^2 + c^4 = 0\n    // a^4 + 2a^2b^2 + b^4 -\
    \ 2a^2c^2 - 2b^2c^2 + c^4 - 0 = 0\n    // a^4 + 2a^2b^2 + b^4 - 2a^2c^2 - 2b^2c^2\
    \ + c^4 - 0 = 0\n    // a^4 + 2a^2b^2 + b^4 - 2a^2c^2 - 2b^2c^2 + c^4 - 0 = 0\n\
    \    long result = a^4 + 2a^2b^2 + b^4 - 2a^2c^2 - 2b^2c^2 + c^4 - 0;\n    if\
    \ (result == 0)\n        return true;\n    else\n        return false;\n}", "{\n\
    \    if(a <= 0 || b <= 0 || c <= 0) return false;\n    else if(a > b && a > c)\
    \ return a*a == b*b + c*c;\n    else if(b > a && b > c) return b*b == a*a + c*c;\n\
    \    else if(c > a && c > b) return c*c == a*a + b*b;\n    else return false;\n\
    }", "{\n    // Type variable is for compile time constraint.\n    auto va = Tuple!(long,\
    \ long, long)(a, b, c);\n    // Type variable is for compile time constraint.\n\
    \    auto va2 = va.tupleof;\n    // Note: max expects a variable number of arguments.\n\
    \    // The arguments are of type long, real, or imaginary.\n    auto side = max(va2);\n\
    \    // The remaining sides squared.\n    auto remaining = va.tupleof.map!((x)\
    \ => x*x).sum;\n    return side*side == remaining;\n}", "{\n    // a^2 + b^2 =\
    \ c^2\n    // a^2 + b^2 - c^2 = 0\n    // diff = a^2 + b^2 - c^2\n    long diff\
    \ = a * a + b * b - c * c;\n    //std.conv.to!string(diff);\n    //std.conv.to!string(a\
    \ * a + b * b);\n    return diff == 0;\n}", "{\n    real ab = real(a) * real(a);\n\
    \    real bc = real(b) * real(b);\n    real ca = real(c) * real(c);\n    real\
    \ ab_plus_bc = ab + bc;\n    real bc_plus_ca = bc + ca;\n    real ca_plus_ab =\
    \ ca + ab;\n    return ab_plus_bc == ca || bc_plus_ca == ab || ca_plus_ab == bc;\n\
    }\n/*", "{\n    auto sides = [a, b, c];\n    long s1 = min(sides);\n    long s2\
    \ = sides[1];\n    long s3 = max(sides);\n    return (s1 * s1 + s2 * s2 == s3\
    \ * s3);\n}", "{\n    auto sides = tuple(a, b, c);\n    auto p = sum(sides);\n\
    \    // Heron's formula\n    auto area = sqrt(p * (p - sides[0]) * (p - sides[1])\
    \ * (p - sides[2]));\n    auto s = area / p;\n    return s * 2 == sides[0] ||\
    \ s * 2 == sides[1] || s * 2 == sides[2];\n}", "{\n    auto sides = tuple(a, b,\
    \ c);\n    auto max_side = max(sides);\n    auto pythagoras = tuple(sides).filter!(s\
    \ => s != max_side);\n    return pow(max_side, 2) == reduce!(+)(map!(s => pow(s,\
    \ 2))(pythagoras));\n}\n/*\n    Given the length of side a and b of a right-angled\
    \ triangle. Return the length\n    of the hypotenuse c as int.\n    Example:\n\
    \    >>> hypotenuse(3L, 4L)\n    5\n    >>> hypotenuse(5L, 12L)\n    13\n*/",
  "{\n    // store the triangle's sides into a tuple\n    auto sides = tuple(a, b,\
    \ c);\n    // sort the triangle's sides\n    sort(sides);\n    // get the longest\
    \ side\n    auto longest = sides[2];\n    // sum the two smallest sides\n    auto\
    \ sum = sides[0] + sides[1];\n    // if the longest side is square of the sum\
    \ of the two smallest sides\n    // then it is a right angle triangle.\n    return\
    \ (pow(longest, 2) == pow(sum, 2));\n}", "{\n    if(!c || !b || !a) return false;\n\
    \    if(a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b) return true;\n\
    \    return false;\n}", "{\n    if (max(a, b, c) != c) return false;\n    long\
    \ sides[3] = {a, b, c};\n    auto sorted = sorted!((a, b) => a > b)(sides);\n\
    \    // ints in d are longer, but some compilers don't handle doubles well.\n\
    \    auto [a, b, c] = sorted;\n    long d = a * a + b * b;\n    return cast(long)c\
    \ * c == d;\n}", "{\n    enum angle = ulong.max;\n    auto sides = tuple(a, b,\
    \ c);\n    auto pythagorean = [&]() \n    {\n        foreach (i, x; sides) \n\
    \        {\n            foreach (j, y; sides) \n            {\n              \
    \  if (i != j) \n                {\n                    angle = x * x + y * y;\n\
    \                    return angle;\n                }\n            }\n       \
    \ }\n        return angle;\n    };\n    return c * c == pythagorean();\n}", "{\n\
    \    /*\n    Given the sides of a triangle as a tuple, return true if the three\
    \ sides\n    form a right-angled triangle, false otherwise.\n    A right-angled\
    \ triangle is a triangle in which one angle is right angle or \n    90 degree.\n\
    \    Example:\n    >>> right_angle_triangle(3L, 4L, 5L)\n    true\n    >>> right_angle_triangle(1L,\
    \ 2L, 3L)\n    false\n    */\n    long[] sides = [a, b, c];\n    long hyp = sides[0],\
    \ leg1 = sides[1], leg2 = sides[2];\n    // Check for a right triangle, by checking\
    \ whether the sum of the squares of\n    // the 2 shorter sides is equal to the\
    \ square of the longest side,\n    if (pow(leg1, 2) + pow(leg2, 2) == pow(hyp,\
    \ 2)) {\n        return true;\n    }\n    return false;\n}\n//@-leo", "{\n   \
    \ // TODO: Implement!\n    return false;\n}", "{\n    // your code here\n    if(c\
    \ > a && c > b)\n    {\n        return (pow(a, 2) + pow(b, 2)) == pow(c, 2);\n\
    \    }\n    else if(b > a && b > c)\n    {\n        return (pow(a, 2) + pow(c,\
    \ 2)) == pow(b, 2);\n    }\n    else if(a > b && a > c)\n    {\n        return\
    \ (pow(b, 2) + pow(c, 2)) == pow(a, 2);\n    }\n    else\n    {\n        return\
    \ false;\n    }\n}", "{\n    // a2 + b2 = c2\n    enum angle_right = -1;\n   \
    \ bool is_right_angle_triangle = false;\n    long angle_a_b, angle_b_c, angle_c_a;\n\
    \    if(a > b && a > c)\n    {\n        angle_a_b = a * a;\n        angle_b_c\
    \ = b * b;\n        angle_c_a = c * c;\n        is_right_angle_triangle = (angle_a_b\
    \ == angle_b_c + angle_c_a);\n    }\n    else if(b > a && b > c)\n    {\n    \
    \    angle_a_b = a * a;\n        angle_b_c = b * b;\n        angle_c_a = c * c;\n\
    \        is_right_angle_triangle = (angle_b_c == angle_a_b + angle_c_a);\n   \
    \ }\n    else if(c > a && c > b)\n    {\n        angle_a_b = a * a;\n        angle_b_c\
    \ = b * b;\n        angle_c_a = c * c;\n        is_right_angle_triangle = (angle_c_a\
    \ == angle_a_b + angle_b_c);\n    }\n    return is_right_angle_triangle;\n}\n\
    /*\n    The distance between two complex numbers z1 and z2, where z1 = x1 + y1i\
    \ \n    and z2 = x2 + y2i is given by the formula:\n    \n    square root of((x1\
    \ - x2)2 + (y1 - y2)2)\n    \n    Write a program that accepts two complex numbers\
    \ z1 and z2 and returns \n    their distance as output.\n    \n    Example:\n\
    \    >>> complex_distance((3.0, 2.0), (3.0, 2.0))\n    0.0\n    >>> complex_distance((3.0,\
    \ 2.0), (2.0, 3.0))\n    1.4142135623730951\n    >>> complex_distance((1.0, 2.0),\
    \ (3.0", "{\n    if (a == 0 || b == 0 || c == 0)\n        return false;\n    double\
    \ a1 = double(a);\n    double b1 = double(b);\n    double c1 = double(c);\n  \
    \  long max = max(a, max(b, c));\n    long min = min(a, min(b, c));\n    long\
    \ other = 0;\n    if (a != max && a != min)\n        other = a;\n    else if (b\
    \ != max && b != min)\n        other = b;\n    else\n        other = c;\n    double\
    \ max1 = double(max);\n    double min1 = double(min);\n    double other1 = double(other);\n\
    \    double min2 = min1 * min1;\n    double max2 = max1 * max1;\n    double other2\
    \ = other1 * other1;\n    if (max2 == (min2 + other2))\n        return true;\n\
    \    return false;\n}", "{\n    /*\n        Tuple(T...)(T[] args)\n        Constructs\
    \ a tuple from its arguments.\n    */\n    auto arr = tuple(a, b, c);\n    sort(arr);\n\
    \    long sum = tuple_reduce!(\"a + b\")(arr);\n    long sub = tuple_reduce!(\"\
    a - b\")(arr);\n    long mul = tuple_reduce!(\"a * b\")(arr);\n    if (pow(arr[0],\
    \ 2) + pow(arr[1], 2) == pow(arr[2], 2) && \n        sub == 0 && mul != 0) \n\
    \    {\n        return true;\n    }\n    return false;\n}", "{\n    Tuple!(long,\
    \ long, long) sides = tuple(a, b, c);\n    sort!((x, y) => x > y)(sides);\n  \
    \  double sinAlpha = double(sides[1]) / double(sides[0]);\n    return sinAlpha\
    \ < 1 && sinAlpha > 0 && sinAlpha == sqrt(1 - double(sides[2]) * double(sides[2])\
    \ / double(sides[0]) / double(sides[0]));\n}", "{\n    return a == 0 ? (b == 0\
    \ ? c == 0 : c == 0) : \n                    is(typeof(a + b + c)) == is(int)\
    \ ? (a*a + b*b == c*c) :\n                                                   \
    \    (a*a + b*b == c*c) || (b*b + c*c == a*a) || (c*c + a*a == b*b);\n}", "{\n\
    \    long result = max(a, max(b, c));\n    return isSquare(a * a + b * b + c *\
    \ c - 2 * result * result);\n}", "{\n    return a * a + b * b == c * c || b *\
    \ b + c * c == a * a || c * c + a * a == b * b;\n}", "{\n    /*\n        So, I\
    \ did a bit of math and found that a right angled triangle should\n        satisfy\
    \ the condition below.\n        Also, all the sides of a triangle must be greater\
    \ than 0.\n    */\n    return a > 0 && b > 0 && c > 0 && (pow(a, 2) + pow(b, 2)\
    \ == pow(c, 2));\n}", "{\n    if (a == 0 || b == 0 || c == 0) return false;\n\
    \    if (a < 0 || b < 0 || c < 0) return false;\n    //Check if it is the Pythagorean\
    \ triple.\n    if (a*a + b*b == c*c) return true;\n    if (b*b + c*c == a*a) return\
    \ true;\n    if (c*c + a*a == b*b) return true;\n    return false;\n}", "{\n \
    \   if(min(a, b, c) <= 0)\n        return false;\n    long max_side = max(a, b,\
    \ c);\n    long sum_of_other_sides = a + b + c - max_side;\n    return max_side\
    \ * max_side == sum_of_other_sides * sum_of_other_sides;\n}", "{\n    // given\n\
    \    typeof(a) aa = a * a;\n    typeof(b) bb = b * b;\n    typeof(c) cc = c *\
    \ c;\n    // test\n    return aa + bb == cc || aa + cc == bb || bb + cc == aa;\n\
    }\n/*\n    The following code tests right_angle_triangle\n*/", "{\n    auto l\
    \ = tuple(a, b, c);\n    return max(l) == sqrt(l[0] * l[0] + l[1] * l[1] + l[2]\
    \ * l[2] - max(l) * max(l));\n}\n//\n//", "{\n  return (a + b > c) && (a + c >\
    \ b) && (b + c > a) && (a * a + b * b == c * c) || (a * a + c * c == b * b) ||\
    \ (b * b + c * c == a * a);\n}", "{\n    // TODO: Write your code here\n    auto\
    \ x = tuple(a, b, c);\n    x = sort(x);\n    if (x[0] * x[0] + x[1] * x[1] ==\
    \ x[2] * x[2])\n        return true;\n    return false;\n}", "{\n    return (pow(a,\
    \ 2) + pow(b, 2) == pow(c, 2));\n}", "{\n    if (a < b) \n        return right_angle_triangle(b,\
    \ a, c);\n    if (b < c) \n        return right_angle_triangle(a, c, b);\n   \
    \ return pow(a, 2) == pow(b, 2) + pow(c, 2);\n}", "{\n    Tuple!(long, long, long)\
    \ t = tuple(a, b, c);\n    t = sort(t);\n    //for (auto i = t.tupleof.front;\
    \ i < t.tupleof.back; i++)\n    //    std.stdio.writeln(i);\n    return t[0]*t[0]\
    \ + t[1]*t[1] == t[2]*t[2];\n}", "{\n    /*\n    if a^2 + b^2 == c^2 the triangle\
    \ is right angled\n    */\n    auto p = tuple(a, b, c);\n    auto max = std.algorithm.maxElement(p);\n\
    \    auto sum = std.algorithm.reduce!q{a + b}(p);\n    if (pow(max, 2) == sum\
    \ - pow(max, 2))\n        return true;\n    return false;\n}\n/*\n    Given a\
    \ list of numbers, return the largest number in the list.\n    Example:\n    >>>\
    \ max_in_list([1, -2, 3])\n    3\n    >>> max_in_list([3, 4, 2, 5])\n    5\n*/",
  "{\n    if(b > a)\n        swap(a, b);\n    if(c > a)\n        swap(a, c);\n   \
    \ \n    // a^2 = b^2 + c^2\n    if(a * a == b * b + c * c)\n        return true;\n\
    \    return false;\n}", "{\n    return (a > 0 && b > 0 && c > 0) && \n       \
    \    abs(c*c-b*b-a*a) < 1e-6;\n}", "{\n    auto sides = tuple(a, b, c);\n    if\
    \ (max(sides) * max(sides) == min(sides) * min(sides) + rest(sides)[0] * rest(sides)[0])\n\
    \        return true;\n    return false;\n}", "{\n    return (a*a + b*b == c*c)\
    \ || (b*b + c*c == a*a) || (c*c + a*a == b*b);\n}", "{\n    Tuple!(long, long,\
    \ long) sides = tuple(a, b, c);\n    // Sort the sides of the triangle in ascending\
    \ order.\n    auto t = sides.sort!q{a > b};\n    long side_a = t[0];\n    long\
    \ side_b = t[1];\n    long side_c = t[2];\n    // If a squared plus b squared\
    \ equals c squared, the three sides\n    // form a right-angled triangle.\n  \
    \  return (side_a ^^ 2) + (side_b ^^ 2) == (side_c ^^ 2);\n}", "{\n    Tuple!(long,\
    \ long, long) myTuple = tuple(a, b, c);\n    real[] arr = [myTuple[0], myTuple[1],\
    \ myTuple[2]];\n    sort(arr);\n    return arr[0]*arr[0] + arr[1]*arr[1] == arr[2]*arr[2];\n\
    }", "{\n    // Call std.math.hypot to calculate hypotenuse\n    // return true\
    \ if ((a^2 + b^2) == c^2) || ((b^2 + c^2) == a^2) || ((a^2 + c^2) == b^2)\n  \
    \  return (hypot(a, b) == c) || (hypot(b, c) == a) || (hypot(a, c) == b);\n}\n\
    /*", "{\n    return a*a + b*b == c*c;\n}", "{\n    /* your code here */\n    auto\
    \ ab = Tuple!(long, long)(a, b);\n    auto bc = Tuple!(long, long)(b, c);\n  \
    \  auto ca = Tuple!(long, long)(c, a);\n    auto result = 90.0 == acos(dot(ab,\
    \ bc) / (norm(ab) * norm(bc))) * 180.0 / PI;\n    return result;\n}", "{\n   \
    \ //a^2+b^2 = c^2\n    return sqrt(pow(a,2)+pow(b,2)) == c || sqrt(pow(a,2)+pow(c,2))\
    \ == b || sqrt(pow(b,2)+pow(c,2)) == a;\n}", "{\n    /*\n        a ** 2 + b **\
    \ 2 == c ** 2\n    */\n    int c1 = a ** 2 + b ** 2;\n    int c2 = c ** 2;\n \
    \   return c1 == c2;\n}", "{\n    auto [min_s, mid_s, max_s] = tuple(a, b, c).sort();\n\
    \    return mid_s * mid_s + min_s * min_s == max_s * max_s;\n}", "{\n    /*\n\
    \        right angle triangle has hypotenuse = sqrt(a^2 + b^2)\n        therefore,\
    \ a^2 + b^2 = c^2\n    */\n    float aSqrd = a * a;\n    float bSqrd = b * b;\n\
    \    float cSqrd = c * c;\n    float abSqrd = aSqrd + bSqrd;\n    if (abSqrd ==\
    \ cSqrd)\n        return true;\n    else\n        return false;\n}\n/*\n    Given\
    \ the sides of a rectangle, return its area.\n    Example:\n    >>> find_area(3L,\
    \ 4L)\n    12\n    >>> find_area(1L, 2L)\n    2\n    >>> find_area(0L, 2L)\n \
    \   0\n*/", "{\n  return a > 0 && b > 0 && c > 0 && (a * a + b * b == c * c ||\n\
    \                                     a * a + c * c == b * b ||\n            \
    \                         b * b + c * c == a * a);\n}", "{\n    auto sides = tuple(a,\
    \ b, c);\n    auto M = max(sides);\n    return M == sides[0] ? pow(sides[1], 2)\
    \ + pow(sides[2], 2) == pow(M, 2) : \n           M == sides[1] ? pow(sides[0],\
    \ 2) + pow(sides[2], 2) == pow(M, 2) : \n           M == sides[2] ? pow(sides[0],\
    \ 2) + pow(sides[1], 2) == pow(M, 2) : \n           false;\n}", "{\n    auto is_right_angle\
    \ = [](long a, long b, long c)\n    {\n        if(a == 0 || b == 0 || c == 0)\
    \ return false;\n        auto a_squared = a * a;\n        auto b_squared = b *\
    \ b;\n        auto c_squared = c * c;\n        if(a_squared + b_squared == c_squared)\n\
    \            return true;\n        if(a_squared + c_squared == b_squared)\n  \
    \          return true;\n        if(b_squared + c_squared == a_squared)\n    \
    \        return true;\n        return false;\n    };\n    return is_right_angle(a,\
    \ b, c) || is_right_angle(b, c, a) || is_right_angle(c, a, b);\n}\n/*\n    Given\
    \ the lengths of the three sides of a triangle. Return its area.\n    Example:\n\
    \    >>> triangle_area(3L, 4L, 5L)\n    6.0\n    >>> triangle_area(1L, 1L, 1L)\n\
    \    0.4330127018922193\n*/\ndouble triangle_area(long a, long b, long c)\n{\n\
    \    // Heron's formula\n    auto half_perimeter = (a + b + c) / 2.0;\n    return\
    \ sqrt(half_perimeter * (half_perimeter - a) * (half_perimeter - b) * (half_perimeter\
    \ - c));\n}\n/*\n    Given the lengths of the three sides of a triangle. \n  \
    \  Return its perimeter.\n    Example:\n    >>> triangle_perimeter(3L, 4L, 5L)\n\
    \    12L\n    >>> triangle_perimeter(1L, 1L, 1L)\n    3L\n*/\nlong triangle_perimeter(long\
    \ a, long b, long c)\n{\n    return a + b + c;\n}\n/*\n    Given the lengths of\
    \ the three sides of a triangle. \n    Return its semi-perimeter.\n    Example:\n\
    \    >>> triangle_semiperimeter(3L, 4L, 5L)\n    6.0\n   ", "{\n  if (((a*a) +\
    \ (b*b)) == (c*c))\n    return true;\n  else\n    return false;\n}", "{\n    if\
    \ (a <= 0 || b <= 0 || c <= 0)\n        return false;\n    tuple!(long, long,\
    \ long) sortedTriangle = tuple(a, b, c).sort;\n    auto hypotenuse = sortedTriangle[2];\n\
    \    auto adjacentLeg = sortedTriangle[1];\n    auto oppositeLeg = sortedTriangle[0];\n\
    \    return hypotenuse * hypotenuse == adjacentLeg * adjacentLeg + oppositeLeg\
    \ * oppositeLeg;\n}", "{\n    Tuple!(long, long, long) t;\n    t = tuple(a, b,\
    \ c);\n    t.sort!(m => m);\n    return t[0] * t[0] + t[1] * t[1] == t[2] * t[2];\n\
    }", "{\n    // TODO: Write your implementation\n    return true;\n}\n/*", "{\n\
    \    static auto f = [](long x, long y) \n    {\n        return pow(x, 2L) + pow(y,\
    \ 2L);\n    };\n    if(a == 0L || b == 0L || c == 0L)\n        return false;\n\
    \    if(a < 0L || b < 0L || c < 0L)\n        return false;\n    if(a == b || b\
    \ == c || a == c)\n        return false;\n    long sum = f(a, b) + f(b, c) + f(a,\
    \ c);\n    return sum == 2L * max(f(a, b), f(b, c), f(a, c));\n}", "{\n    Tuple!(long,\
    \ long, long) t = tuple(a, b, c);\n    // sort in decending order\n    sort!((x,\
    \ y) => x > y)(t);\n    // then, test the triangle inequality\n    // a - b -\
    \ c < 0\n    return t[0] - t[1] - t[2] < 0;\n}", "{\n    return a * a + b * b\
    \ == c * c;\n}\n/*", "{\n    // Use Pythagorean theorem to calculate the hypotenuse\n\
    \    // for a right-angled triangle.\n    auto max = std.algorithm.max;\n    return\
    \ std.algorithm.find!((i) => i * i == max(a, b, c) * max(a, b, c) - (a * a + b\
    \ * b + c * c - max(a, b, c) * max(a, b, c)))\n    (iota(2L, max(a, b, c)));\n\
    }", "{\n    double a_root = sqrt(a);\n    double b_root = sqrt(b);\n    double\
    \ c_root = sqrt(c);\n    double result = a_root + b_root + c_root;\n    return\
    \ a_root + b_root == c_root || a_root + c_root == b_root || b_root + c_root ==\
    \ a_root;\n}", "{\n    auto abc = tuple(a, b, c);\n    if (abc[0] == 0 || abc[1]\
    \ == 0 || abc[2] == 0) return false;\n    auto angles = tuple(\n        acos(dot(abc[0],\
    \ abc[1]) / (mod(abc[0]) * mod(abc[1]))),\n        acos(dot(abc[1], abc[2]) /\
    \ (mod(abc[1]) * mod(abc[2]))),\n        acos(dot(abc[2], abc[0]) / (mod(abc[2])\
    \ * mod(abc[0])))\n    );\n    auto right = tuple(abs(90.0 - angles[0]), abs(90.0\
    \ - angles[1]), abs(90.0 - angles[2]));\n    return right[0] < 0.1 || right[1]\
    \ < 0.1 || right[2] < 0.1;\n}", "{\n    auto x = tuple(a, b, c);\n    sort(x);\n\
    \    return x[0] * x[0] + x[1] * x[1] == x[2] * x[2];\n}", "{\n    // return (a*a\
    \ + b*b == c*c);\n    // return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b\
    \ + c*c == a*a);\n    if (a*a + b*b == c*c) return true;\n    if (a*a + c*c ==\
    \ b*b) return true;\n    if (b*b + c*c == a*a) return true;\n    return false;\n\
    }", "{\n    if(a + b <= c) return false;\n    if(a + c <= b) return false;\n \
    \   if(b + c <= a) return false;\n    if(a * a + b * b == c * c) return true;\n\
    \    if(a * a + c * c == b * b) return true;\n    if(b * b + c * c == a * a) return\
    \ true;\n    return false;\n}\n/*\n    Divide one number by another, returning\
    \ the result as a floating point number.\n    Note that this function is a little\
    \ different from the / operator\n    The / operator performs a floor division\
    \ (rounds down)\n    Example:\n    >>> divide(1L, 3L)\n    0.3333333333333333\n\
    \    >>> divide(4L, 3L)\n    1.3333333333333333\n    >>> divide(6L, 3L)\n    2.0\n\
    */\ndouble divide(long a, long b) \n{\n    // write your code here\n    return\
    \ cast(double)a / b;\n}\n/*\n    Given a list of numbers, return the mean (average)\
    \ of the numbers.\n    Example:\n    >>> mean([1L, 2L, 3L])\n    2.0\n    >>>\
    \ mean([1L, 4L, 6L])\n    3.6666666666666665\n*/\ndouble mean(in int[] arr) \n\
    {\n    // write your code here\n    assert(arr.length > 0);\n    return arr.sum\
    \ / arr.length;\n}\n/*\n    Given a list of numbers, return the median (middle)\
    \ of the numbers.\n    For a list of n numbers,\n    if n is odd: the median is\
    \ the (n + 1) / 2 smallest number.\n    if n is even: the median is the mean of\
    \ the n / 2 smallest number and the n / 2 largest number.\n    Example:\n    >>>\
    \ median([1L, 2L, 3L])\n    2\n    >>> median([1L, 2L, 4L, 6L])\n    3.0\n*/\n\
    double median(in int[] arr) \n{\n    // write your code here\n    if(arr.length\
    \ == 0) return 0;\n    auto sorted", "{\n    long max = std.math.max(std.math.max(a,\
    \ b), c);\n    long min = std.math.min(std.math.min(a, b), c);\n    long med =\
    \ a + b + c - max - min;\n    return max * max == med * med + min * min;\n}",
  "{\n    if (c > b)\n        swap(b, c);\n    if (b > a)\n        swap(a, b);\n \
    \   if (c > b)\n        swap(b, c);\n    return c * c + b * b == a * a;\n}", "{\n\
    \    return a * a + b * b == c * c;\n}\n#endif", "{\n    long[] sides = {a, b,\
    \ c};\n    sort(sides);\n    return sides[0] * sides[0] + sides[1] * sides[1]\
    \ == sides[2] * sides[2];\n}", "{\n    return a != 0 \n    && b != 0 \n    &&\
    \ c != 0 \n    && max(a, max(b, c)) == pow(pow(a, 2) + pow(b, 2) + pow(c, 2),\
    \ 0.5);\n}\n/*\n    Given a positive integer of up to 16 digits, return a string\
    \ of its binary \n    value.\n    Example:\n    >>> binary(0)\n    '0'\n    >>>\
    \ binary(1)\n    '1'\n    >>> binary(10)\n    '1010'\n*/\nstring binary(long long\
    \ x) \n{\n    long long y = x;\n    long long z = x;\n    long long m = 0;\n \
    \   string temp = \"\";\n    string temp2 = \"\";\n    if (x == 0)\n    {\n  \
    \      return \"0\";\n    }\n    while (y != 0)\n    {\n        y = y / 2;\n \
    \       m++;\n    }\n    while (z != 0)\n    {\n        temp += to!string(z %\
    \ 2);\n        z = z / 2;\n    }\n    for (int i = 0; i < m; i++)\n    {\n   \
    \     temp2 += temp[m - i - 1];\n    }\n    return temp2;\n}\n/*\n    You're given\
    \ an array of up to four non-negative integers, each less than 256.\n    Your\
    \ task is to pack these integers into one number M in the following way:\n   \
    \ The first element of the array occupies the first 8 bits of M;\n    The second\
    \ element occupies next 8 bits, and so on.\n    Return the obtained integer M.\n\
    \    Note: the phrase \"first bits of M\" refers to the least significant bits\
    \ of M \n    - the right-most bits of an integer. For further clarification see\
    \ the following example.\n    Example:\n    >>> array_packing([24, 85, 0])\n \
    \   21784\n    24 = 11000 is 1|1000 in binary.\n    85 = 1010101 is 10|1010101\
    \ in binary.\n    0 = 0 is 0|00000 in binary.\n    After packing these into one\
    \ number we get 21784 which is 10101010|11000 in binary.\n"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
