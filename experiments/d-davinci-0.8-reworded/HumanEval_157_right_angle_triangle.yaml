name: HumanEval_157_right_angle_triangle
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given the lengths of the\
  \ three sides of a triangle. Return true if the three\n    sides form a right-angled\
  \ triangle, false otherwise.\n    A right-angled triangle is a triangle in which\
  \ one angle is right angle or \n    90 degree.\n    Example:\n    >>> right_angle_triangle(3L,\
  \ 4L)\n    true\n    >>> right_angle_triangle(1L, 2L)\n    false\n    \n*/\nbool\
  \ right_angle_triangle(long a, long b, long c) \n"
tests: "unittest\n{\n    alias candidate = right_angle_triangle;\n\n    assert(candidate(3L,\
  \ 4L, 5L) == true);\n    assert(candidate(1L, 2L, 3L) == false);\n    assert(candidate(10L,\
  \ 6L, 8L) == true);\n    assert(candidate(2L, 2L, 2L) == false);\n    assert(candidate(7L,\
  \ 24L, 25L) == true);\n    assert(candidate(10L, 5L, 7L) == false);\n    assert(candidate(5L,\
  \ 12L, 13L) == true);\n    assert(candidate(15L, 8L, 17L) == true);\n    assert(candidate(48L,\
  \ 55L, 73L) == true);\n    assert(candidate(1L, 1L, 1L) == false);\n    assert(candidate(2L,\
  \ 2L, 10L) == false);\n}\nvoid main(){}"
completions: ["{\n    if(a > 0 && b > 0 && c > 0)\n    {\n        int[] sides = tuple(a,\
    \ b, c).sort().array;\n        a = sides[0];\n        b = sides[1];\n        c\
    \ = sides[2];\n        return a * a + b * b == c * c;\n    }\n    return false;\n\
    }", "{\n    long[] s = [a, b, c];\n    sort(s);\n    return (s[0] * s[0] + s[1]\
    \ * s[1] == s[2] * s[2]);\n}", "{\n    return (a*a + b*b == c*c) || (a*a + c*c\
    \ == b*b) || (b*b + c*c == a*a);\n}", "{\n    // Given the lengths of the three\
    \ sides of a triangle. Return true if the three\n    // sides form a right-angled\
    \ triangle, false otherwise.\n    // A right-angled triangle is a triangle in\
    \ which one angle is right angle or \n    // 90 degree.\n    // Example:\n   \
    \ // >>> right_angle_triangle(3L, 4L)\n    // true\n    // >>> right_angle_triangle(1L,\
    \ 2L)\n    // false\n    bool doTriangles1 = c*c == a*a + b*b;\n    bool doTriangles2\
    \ = a*a == b*b + c*c;\n    bool doTriangles3 = b*b == a*a + c*c;\n    bool doTriangles\
    \ = doTriangles1 || doTriangles2 || doTriangles3;\n    return doTriangles;\n}",
  "{\n    long s = max(a, b, c); // this is hypotenuse\n    // long sum = a + b +\
    \ c;\n    long sum = 0;\n    if (a!=s)\n        sum += a;\n    if (b!=s)\n   \
    \     sum += b;\n    if (c!=s)\n        sum += c;\n    return pow(sum, 2) == pow(s,\
    \ 2);\n}", "{\n    const long sum = a*a + b*b;\n    const long sum2 = a*a + c*c;\n\
    \    const long sum3 = b*b + c*c;\n    return (sum == c*c) || (sum2 == b*b) ||\
    \ (sum3 == a*a);\n}\n/*\n    Given an array of randomly selected tickets, return\
    \ the winner ticket.\n    The winner ticket is the ticket that has the same starting\
    \ and ending number.\n    Example:\n    >>> lottery_ticket([\"0234\", \"1912\"\
    , \"1265\"])\n    \"1265\"\n    >>> lottery_ticket([\"1234\", \"1912\", \"1265\"\
    ])\n    \"1234\"\n*/\nstring lottery_ticket(string[] tickets) \n{\n    string[]\
    \ winners = tickets.filter!(a => a[0] == a[$-1]);\n    return (winners.length\
    \ == 0) ? \"No winner\" : winners[0];\n}\n/*\n    Return an array of numbers sorted\
    \ in descending order\n    Example:\n    >>> sort_array([3, 4, 2, 1])\n    [4,\
    \ 3, 2, 1]\n    >>> sort_array([3, 4, 2, 1])\n    [4, 3, 2, 1]\n*/\nlong[] sort_array(long[]\
    \ numbers) \n{\n    return numbers.sort.sort!(a => -a);\n}\n/*\n    Return true\
    \ if the given array is a palindrome\n    Example:\n    >>> is_palindrome([\"\
    a\", \"b\", \"c\", \"d\", \"c\", \"b\", \"a\"])\n    true\n    >>> is_palindrome([\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n    false\n*/", "{\n    auto\
    \ t = tuple(a, b, c);\n    sort(t);\n    return (t[0] * t[0] + t[1] * t[1] ==\
    \ t[2] * t[2]);\n}", "{\n    return pow(a, 2) + pow(b, 2) == pow(c, 2);\n}", "{\n\
    \    // I don't care about the order of the lengths\n    // Assume the longest\
    \ is c\n    long c_ = max(a,b);\n    long c__ = min(a,b);\n    // The longest\
    \ length is c. We just need to check if\n    // c^2 = a^2 + b^2\n    // because\
    \ of the pythagorean theorem\n    // c^2 = a^2 + b^2\n    return pow(c_,2) ==\
    \ pow(c__,2) + pow(c,2);\n}", "{\n    enum \n    {\n        L_0 = 0,\n       \
    \ L_1 = 1,\n        L_2 = 2,\n        COUNT = 3\n    } ;\n    typedef Tuple!(long,\
    \ long, long) Lengths;\n    auto lengths = Lengths(a, b, c);\n    lengths.sort(greater);\n\
    \    return lengths[L_0] * lengths[L_0] == lengths[L_1] * lengths[L_1] + lengths[L_2]\
    \ * lengths[L_2];\n}", "{\n    long m = a;\n    long n = b;\n    long p = c;\n\
    \    Tuple!(long, long, long) t;\n    if(p >= m && p >= n) {\n        t = tuple(n,\
    \ m, p);\n    } else if(n >= m && n >= p) {\n        t = tuple(m, p, n);\n   \
    \ } else {\n        t = tuple(p, n, m);\n    }\n    return (t[1] * t[1] + t[2]\
    \ * t[2]) == t[0] * t[0];\n}", "{\n    return a*a + b*b == c*c;\n}", "{\n    if\
    \ (a == 0 || b == 0 || c == 0)\n        return false;\n    long  m = max(a, max(b,\
    \ c));\n    long s = min(a, min(b, c));\n    long s2 = a + b + c - m - s;\n  \
    \  auto h = pow(m, 2);\n    auto k = pow(s, 2) + pow(s2, 2);\n    return h ==\
    \ k;\n}", "{\n    struct tuple c2 = make_tuple(a, b, c);\n    c2 = sort(c2);\n\
    \    a = c2[0];\n    b = c2[1];\n    c = c2[2];\n    return (a * a + b * b ==\
    \ c * c);\n}", "{\n    long s = 0;\n    long m = 0;\n    long l = 0;\n    if (a\
    \ > b && a > c)\n    {\n        l = a;\n        if (b > c)\n        {\n      \
    \      m = b;\n            s = c;\n        }\n        else\n        {\n      \
    \      m = c;\n            s = b;\n        }\n    }\n    else if (b > a && b >\
    \ c)\n    {\n        l = b;\n        if (a > c)\n        {\n            m = a;\n\
    \            s = c;\n        }\n        else\n        {\n            m = c;\n\
    \            s = a;\n        }\n    }\n    else\n    {\n        l = c;\n     \
    \   if (a > b)\n        {\n            m = a;\n            s = b;\n        }\n\
    \        else\n        {\n            m = b;\n            s = a;\n        }\n\
    \    }\n    if (m + s <= l)\n    {\n        return false;\n    }\n    long ms\
    \ = m * m + s * s;\n    long ls = l * l;\n    if (ms == ls)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }\n}", "{\n    //\
    \ TODO: implement\n    return true;\n}", "{\n    auto sl = tuple(a, b, c);\n \
    \   sort(sl);\n    auto aa = sl[0], bb = sl[1], cc = sl[2];\n    return (aa *\
    \ aa + bb * bb == cc * cc);\n}", "{\n    long s = a + b + c;\n    return (s *\
    \ s) == (2 * a * a + 2 * b * b + 2 * c * c);\n}\n/*", "{\n    if(a == 0 || b ==\
    \ 0 || c == 0)\n        return false;\n    long[long] m = [a : a, b : b, c : c];\n\
    \    double[long] n = [a : a, b : b, c : c];\n    double temp = 0;\n    foreach(i;\
    \ m)\n    {\n        if(i.value < temp)\n        {\n            temp = i.value;\n\
    \            n[i.key] = pow(i.value, 2);\n        }\n        else\n        {\n\
    \            n[i.key] = pow(i.value, 2);\n        }\n    }\n    double s = 0;\n\
    \    foreach(i; n)\n    {\n        s += i.value;\n    }\n    return (s == 2 *\
    \ pow(temp, 2));\n}", "{\n    long[int] ls = [-1L, a, b, c];\n    sort(ls);\n\
    \    long[int] sqrts = [0L, a * a, b * b, c * c];\n    return ls[3] * ls[3] ==\
    \ sqrts[2] + sqrts[1];\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
