name: HumanEval_9_rolling_max
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ res = new long[numbers.length];\n\tif (numbers.length > 0)\n\t{\n\t\tres[0]\
    \ = numbers[0];\n\t\tfor (int i = 1; i < numbers.length; i++)\n\t\t{\n\t\t\tres[i]\
    \ = max(res[i - 1], numbers[i]);\n\t\t}\n\t}\n\treturn res;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n\tlong[] res = new long[numbers.length];\n\tif (numbers.length\
    \ > 0)\n\t{\n\t\tres[0] = numbers[0];\n\t\tfor (int i = 1; i < numbers.length;\
    \ i++)\n\t\t{\n\t\t\tres[i] = min(res[i - 1], numbers[i]);\n\t\t}\n\t}\n\treturn\
    \ res;\n}\n/*\n  From a given array of integers, generate an array of rolling\
    \ sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n\tlong[] res = new long[numbers.length];\n\t\
    if (numbers.length > 0)\n\t{\n\t\tres[0] = numbers[0];\n\t\tfor (int i = 1; i\
    \ < numbers.length; i++)\n\t\t{\n\t\t\tres[i] = res[i - 1] + numbers[i];\n\t\t\
    }\n\t}\n\treturn res;\n}\n/*\n  From a given array of integers, generate an array\
    \ of rolling average of elements found until given moment\n\nunittest\n{\n   \
    \ alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppmqfpkxk.d(63): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppmqfpkxk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_until_now = numbers[0];\n    size_t n = numbers.length;\n    long[] result\
    \ = new long[n];\n    result[0] = max_until_now;\n    foreach (i,number; numbers[1..$])\n\
    \    {\n        if (number > max_until_now)\n        {\n            max_until_now\
    \ = number;\n        }\n        result[i] = max_until_now;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_average([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L, 3L, 3L]\n*/\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpbs7hm338.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x42858e]\\n??:? long[] tmpbs7hm338.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpbs7hm338.__unittest_L32_C1() [0x427f6e]\\n??:? void\
    \ tmpbs7hm338.__modtest() [0x42825c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b44e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306d9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b88]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430665]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b425]\\n??:? runModuleUnitTests [0x42c391]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289a0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428927]\\n??:? _d_run_main [0x428892]\\n??:? main [0x42826f]\\\
    n??:? __libc_start_main [0x7f8f6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    bool[]\
    \ current_max_indices = new bool[numbers.length];\n    long[] rolling_max = new\
    \ long[numbers.length];\n    for (long i = 0; i < numbers.length; i++) \n    {\n\
    \        current_max_indices[i] = true;\n        for (long j = 0; j < i; j++)\
    \ \n        {\n            if (numbers[j] >= numbers[i]) \n            {\n   \
    \             current_max_indices[i] = false;\n                break;\n      \
    \      }\n        }\n        if (current_max_indices[i]) \n        {\n       \
    \     rolling_max[i] = numbers[i];\n        } \n        else \n        {\n   \
    \         rolling_max[i] = rolling_max[i - 1];\n        }\n    }\n    return rolling_max;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif\
    \ (numbers.length == 0) return [];\n\tlong[] res = new long[numbers.length];\n\
    \tres[0] = numbers[0];\n\tfor (size_t i = 1; i < numbers.length; i++)\n\t\tres[i]\
    \ = max(res[i - 1], numbers[i]);\n\treturn res;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6tbk01ot.d(16): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6tbk01ot.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in \n\
    \    {\n        assert(numbers.length > 0);\n    }\n    out \n    (\n        result.length\
    \ == numbers.length\n    )\n{\n    // https://www.programiz.com/dsa/stack-in-cpp\n\
    \    import std.typecons;\n    import std.algorithm;\n    Stack!long stack = new\
    \ Stack!long();\n    stack.push(numbers[0]);\n    auto max_num = numbers[0];\n\
    \    foreach(i, number; numbers[1..$])\n    {\n        if (number > max_num)\n\
    \        {\n            max_num = number;\n        }\n        stack.push(max_num);\n\
    \    }\n    long[] result = stack.array();\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdcwd3vvq.d(17): Error: found `.` when expecting `)`\\n/tmp/tmpdcwd3vvq.d(17):\
    \ Error: statement expected to be `{ }`, not `length`\\n/tmp/tmpdcwd3vvq.d(18):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmpdcwd3vvq.d(19):\
    \ Error: missing `do { ... }` after `in` or `out`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpdcwd3vvq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (size_t\
    \ i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i -\
    \ 1], numbers[i]);\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph66c3d13.d(20): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph66c3d13.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    static\
    \ struct IndexedLong \n    {\n        size_t index;\n        long value;\n   \
    \ }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp35whp6gl.d(17): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp35whp6gl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //\
    \ Declaring a temporary buffer to keep track of the max found in the loop\n  \
    \  long buffer;\n    // Initalizing the buffer with the first element of the array.\n\
    \    buffer = numbers[0];\n    // Initializing the array to be returned with the\
    \ first element of the array.\n    long[] rolling_max = new long[1];\n    rolling_max[0]\
    \ = numbers[0];\n    // Looping over the numbers in the array, if the buffer is\
    \ less than the number, it is overwritten.\n    // This will be used to return\
    \ the maximum number found in the array so far.\n    for (long i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (buffer < numbers[i])\n        {\n            buffer\
    \ = numbers[i];\n        }\n        rolling_max ~= buffer;\n    }\n    return\
    \ rolling_max;\n}\n// This algorithm doesn't achieve the best possible score because\
    \ of the 'if' statement in the loop.\n// I will implement a solution that is O(n)\
    \ after reviewing the solution.\n// Solution from the book (O(n)):\n// In the\
    \ previous solution we needed to traverse the entire list to find the rolling\
    \ max for\n// each element. This is becase we were always comparing the previous\
    \ elements to find the max so far.\n// In this solution, we traverse the array\
    \ only once, and for each element we record the max element\n// so far, and the\
    \ current element. We then compare the two to determine which element is written\
    \ to the\n// array to be returned. This allows us to only loop over the array\
    \ once and also allows us to find the\n// rolling max for each element.\nlong[]\
    \ rolling_max_better(long[] numbers) \n{\n    // Initializing the array to be\
    \ returned with the first element of the array.\n    long[] rolling_max = new\
    \ long[1];\n    rolling_max[0] = numbers[0];\n    // Declaring the max element\
    \ found so far\n    long max_so_far = numbers[0];\n    // Looping over the array\
    \ and comparing each element to the max found so far\n    for (long i = 1; i <\
    \ numbers.length; i++)\n    {\n        // If the max so far is less than the current\
    \ element, set\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4d4945uk.d(51): Error: found `unittest` instead of statement\\\
    n/tmp/tmp4d4945uk.d(60): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4d4945uk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ N = numbers.length;\n    long[] output = new long[N];\n    output[0] = numbers[0];\n\
    \    for (auto index = 1; index < N; index++)\n    {\n        output[index] =\
    \ max(output[index - 1], numbers[index]);\n    }\n    return output;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling maximum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max_alt(long[]\
    \ numbers) \n{\n    auto N = numbers.length;\n    long[] output = new long[N];\n\
    \    auto m = numbers[0];\n    for (auto index = 0; index < N; index++)\n    {\n\
    \        m = max(m, numbers[index]);\n        output[index] = m;\n    }\n    return\
    \ output;\n}\n/*\n    From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    auto N = numbers.length;\n    long[] output\
    \ = new long[N];\n    output[0] = numbers[0];\n    for (auto index = 1; index\
    \ < N; index++)\n    {\n        output[index] = min(output[index - 1], numbers[index]);\n\
    \    }\n    return output;\n}\n/*\n    From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbds_ns6c.d(58): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbds_ns6c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ rollingMax;\n    long num = 0;\n    rollingMax.length = numbers.length;\n  \
    \  if (numbers.length) \n    {\n        rollingMax[0] = numbers[0];\n        for\
    \ (int i = 1; i < numbers.length; i++) \n        {\n            num = numbers[i];\n\
    \            if (num > rollingMax[i - 1]) \n            {\n                rollingMax[i]\
    \ = num;\n            }\n            else \n            {\n                rollingMax[i]\
    \ = rollingMax[i - 1];\n            }\n        }\n    }\n    return rollingMax;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    assert(numbers.length\
    \ > 0);\n    auto result = new long[numbers.length];\n    immutable long max_so_far\
    \ = 0;\n    foreach (index, number; numbers) {\n        if (number > max_so_far)\
    \ {\n            max_so_far = number;\n        }\n        result[index] = max_so_far;\n\
    \    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr7qfwwh3.d(23): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr7qfwwh3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ output = numbers.dup;\n    foreach (i, e; output)\n    {\n        if (i > 0)\n\
    \        {\n            output[i] = max(output[i], output[i - 1]);\n        }\n\
    \    }\n    return output;\n}\n/*\n Given an array of integers, how many of them\
    \ are unique?\n    >>> unique_elements([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    4L\n\
    \    \n*/\nsize_t unique_elements(long[] numbers) \n{\n    return set(numbers).length;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps_5jxqeg.d(17): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmps_5jxqeg.d(30): Error: undefined identifier `set`,\
    \ did you mean template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps_5jxqeg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    assert(numbers.length\
    \ >= 1);\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, _; 1 .. numbers.length)\n    {\n        result[i] = max(result[i\
    \ - 1], numbers[i]);\n    }\n    return result;\n}\n \n// From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    // in the sequence.\n// >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n// [1L,\
    \ 1L, 1L, 1L, 1L, 1L, 1L]\nlong[] rolling_min(long[] numbers) \n{\n    assert(numbers.length\
    \ >= 1);\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, _; 1 .. numbers.length)\n    {\n        result[i] = min(result[i\
    \ - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3jy1x8rn.d(15): Error: found `..` when expecting `)`\\n/tmp/tmp3jy1x8rn.d(15):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmp3jy1x8rn.d(31):\
    \ Error: found `..` when expecting `)`\\n/tmp/tmp3jy1x8rn.d(31): Error: found\
    \ `)` when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3jy1x8rn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ ret = new long[numbers.length];\n    long[] val = new long[numbers.length];\n\
    \    ret[0] = numbers[0];\n    val[0] = numbers[0];\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        ret[i] = numbers[i] > val[i - 1] ? numbers[i] : val[i -\
    \ 1];\n        val[i] = numbers[i];\n    }\n    return ret;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] ret = new long[numbers.length];\n    long[] val = new\
    \ long[numbers.length];\n    ret[0] = numbers[0];\n    val[0] = numbers[0];\n\
    \    for (int i = 1; i < numbers.length; i++)\n    {\n        ret[i] = numbers[i]\
    \ < val[i - 1] ? numbers[i] : val[i - 1];\n        val[i] = numbers[i];\n    }\n\
    \    return ret;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L,\
    \ 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] ret = new\
    \ long[numbers.length];\n    long[] val = new long[numbers.length];\n    ret[0]\
    \ = numbers[0];\n    val[0] = numbers[0];\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        ret\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9jhuxbt_.d(59): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmp9jhuxbt_.d(68): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmp9jhuxbt_.d(68): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9jhuxbt_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto\
    \ result = new long[](numbers.length);\n  auto current_max = numbers[0];\n  result[0]\
    \ = current_max;\n  foreach (i, n; numbers[1 .. $]) \n  {\n    if (n > current_max)\n\
    \      current_max = n;\n    result[i + 1] = current_max;\n  }\n  return result;\n\
    }\n/*\n    From a given array of integers, generate an array of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    */\nlong[] rolling_min(long[]\
    \ numbers) \n{\n  auto result = new long[](numbers.length);\n  auto current_min\
    \ = numbers[0];\n  result[0] = current_min;\n  foreach (i, n; numbers[1 .. $])\
    \ \n  {\n    if (n < current_min)\n      current_min = n;\n    result[i + 1] =\
    \ current_min;\n  }\n  return result;\n}\n/*\n    From a given array of integers,\
    \ generate an array of rolling sum of elements found until given moment\n    in\
    \ the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L,\
    \ 6L, 8L, 11L, 15L, 17L]\n    */\nlong[] rolling_sum(long[] numbers) \n{\n  auto\
    \ result = new long[](numbers.length);\n  auto current_sum = numbers[0];\n  result[0]\
    \ = current_sum;\n  foreach (i, n; numbers[1 .. $]) \n  {\n    current_sum +=\
    \ n;\n    result[i + 1] = current_sum;\n  }\n  return result;\n}\n/*\n    From\
    \ a given array of integers, generate an array of rolling mean value of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_mean([\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp50v9q7r9.d(60): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp50v9q7r9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ rmax = new long[numbers.length];\n    rmax[0] = numbers[0];\n    foreach (i,\
    \ v; numbers[1 .. $])\n    {\n        rmax[i + 1] = max(v, rmax[i]);\n    }\n\
    \    return rmax;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling maximum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_max_zip(long[] numbers) \n{\n    long[] rmax =\
    \ new long[numbers.length];\n    rmax[0] = numbers[0];\n    foreach (i, v; zip(numbers[1\
    \ .. $], rmax[0 .. $]))\n    {\n        rmax[i + 1] = max(v[0], v[1]);\n    }\n\
    \    return rmax;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling maximum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_max_foreach(long[] numbers) \n{\n    long[] rmax\
    \ = new long[numbers.length];\n    rmax[0] = numbers[0];\n    foreach (i, v; numbers[1\
    \ .. $])\n    {\n        rmax[i + 1] = max(v, rmax[i]);\n    }\n    return rmax;\n\
    }\n/*\n From a given array of integers, generate an array of rolling maximum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpij1wxt2v.d(54): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpij1wxt2v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ result = new long[];\n    foreach (index, x; numbers)\n    {\n        if (index\
    \ == 0)\n        {\n            result ~= x;\n        }\n        else \n     \
    \   {\n            result ~= max(x, result[$-1]);\n        }\n    }\n    return\
    \ result;\n}\n/*\n    Finds all of the possible rolling maximums of `numbers`\
    \ of size `window_size`\n    >>> rollings_max([1L, 2L, 3L, 2L, 3L, 4L, 2L], 2)\n\
    \    [[1L, 2L], [2L, 3L], [3L, 3L], [2L, 3L], [3L, 4L], [4L, 4L], [2L, 4L]]\n\
    */\nlong[][] rollings_max(long[] numbers, int window_size) \n{\n    assert(window_size\
    \ != 0);\n    if (window_size < 0)\n    {\n        numbers = numbers[0..window_size];\n\
    \        window_size = -window_size;\n    }\n    auto result = new long[][](numbers.length\
    \ - window_size + 1);\n    foreach (i; 0..numbers.length - window_size + 1)\n\
    \    {\n        result[i] = rolling_max(numbers[i..i + window_size]);\n    }\n\
    \    return result;\n}\n/*\n    Finds all of the possible rolling maximums of\
    \ `numbers` of size `window_size`\n    >>> rollings_max([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L], 2)\n    [[1L, 2L], [2L, 3L], [3L, 3L], [2L, 3L], [3L, 4L], [4L, 4L], [2L,\
    \ 4L]]\n*/\nlong[][] rollings_max_zip(long[] numbers, int window_size) \n{\n \
    \   assert(window_size != 0);\n    if (window_size < 0)\n    {\n        numbers\
    \ = numbers[0..window_size];\n        window_size = -\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx6u512t3.d(58): Error: expression expected, not `unittest`\\\
    n/tmp/tmpx6u512t3.d(59): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmpx6u512t3.d(67): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx6u512t3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if\
    \ (numbers.length < 1) return new long[0];\n    if (numbers.length == 1) return\
    \ numbers;\n    long[] result = new long[numbers.length];\n    auto max_so_far\
    \ = numbers[0];\n    result[0] = max_so_far;\n    foreach (n, i; numbers[1 ..\
    \ $])\n    {\n        if (n > max_so_far) max_so_far = n;\n        result[i] =\
    \ max_so_far;\n    }\n    return result;\n}\n/*\n Given a number of seconds, return\
    \ the time in minutes and seconds.\n    >>> minutes_and_seconds(3599)\n    Tuple!(int,\
    \ int)(59, 59)\n    >>> minutes_and_seconds(0)\n    Tuple!(int, int)(0, 0)\n \
    \   >>> minutes_and_seconds(60)\n    Tuple!(int, int)(1, 0)\n    >>> minutes_and_seconds(3660)\n\
    \    Tuple!(int, int)(61, 0)\n*/\nauto minutes_and_seconds(long seconds)\n{\n\
    \    auto mins = seconds / 60;\n    auto secs = seconds % 60;\n    return tuple(mins,\
    \ secs);\n}\n/*\n Given a phone number in international format, return the number\
    \ in local format with a leading zero.\n    >>> local_number(\"+48123456789\"\
    )\n    \"0048123456789\"\n    >>> local_number(\"123456789\")\n    \"00123456789\"\
    \n    >>> local_number(\"0048123456789\")\n    \"0048123456789\"\n*/\nstring local_number(string\
    \ phone_number)\n{\n    if (phone_number.length == 0) return \"\";\n    if (phone_number[0]\
    \ == '+') return \"00\" ~ phone_number[1 .. $];\n    if (phone_number[0 .. 1]\
    \ == \"00\") return phone_number;\n    if (phone_number[0] == '0') return \"00\"\
    \ ~ phone_number[1 .. $];\n    return \"00\" ~ phone_number;\n}\n/*\n Return\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcixqb5sn.d(58): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcixqb5sn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ ds = SinglyLinkedList!(Tuple!(long, long)).init;\n    auto result = new long[numbers.length];\n\
    \    foreach (i, e; numbers) {\n        int endIndex = ds.length;\n        //remove\
    \ elements that are smaller than the element at hand\n        while (endIndex\
    \ && ds[endIndex - 1].length > e) {\n            ds.removeAt(endIndex - 1);\n\
    \            endIndex--;\n        }\n        //append element\n        ds.append(tuple(e,\
    \ i));\n        //set the value in the result\n        result[i] = endIndex ?\
    \ ds[endIndex - 1].length : 0;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplqfanfdk.d(12): Error: template instance `SinglyLinkedList!(Tuple!(long,\
    \ long))` template `SinglyLinkedList` is not defined\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmplqfanfdk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \nin {\n \
    \   for (i in 0 .. numbers.length - 1) \n        //assert(numbers[i] >= 0);\n\
    \    assert(numbers.length > 0);\n}\nout (result) {\n    assert(result.length\
    \ == numbers.length);\n    for (i in 0 .. result.length - 1) \n        assert(result[i]\
    \ >= 0);\n}\n{\n    long[] result = new long[numbers.length];\n    long maxSoFar\
    \ = numbers[0];\n    for (i in 0 .. numbers.length - 1) {\n        if (maxSoFar\
    \ < numbers[i]) {\n            maxSoFar = numbers[i];\n        }\n        result[i]\
    \ = maxSoFar;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbp5oz159.d(12): Error: found `..` when expecting `;` following\
    \ statement\\n/tmp/tmpbp5oz159.d(12): Error: found `)` when expecting `;` following\
    \ `for` condition\\n/tmp/tmpbp5oz159.d(14): Error: found `;` when expecting `)`\\\
    n/tmp/tmpbp5oz159.d(15): Error: found `}` instead of statement\\n/tmp/tmpbp5oz159.d(18):\
    \ Error: found `..` when expecting `;` following statement\\n/tmp/tmpbp5oz159.d(18):\
    \ Error: found `)` when expecting `;` following `for` condition\\n/tmp/tmpbp5oz159.d(19):\
    \ Error: found `;` when expecting `)`\\n/tmp/tmpbp5oz159.d(20): Error: found `}`\
    \ instead of statement\\n/tmp/tmpbp5oz159.d(21): Error: missing `do { ... }` after\
    \ `in` or `out`\\n/tmp/tmpbp5oz159.d(24): Error: found `..` when expecting `;`\
    \ following statement\\n/tmp/tmpbp5oz159.d(24): Error: found `)` when expecting\
    \ `;` following `for` condition\\n/tmp/tmpbp5oz159.d(30): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbp5oz159.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
