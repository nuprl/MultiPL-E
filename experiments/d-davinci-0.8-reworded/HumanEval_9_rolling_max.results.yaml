language: d
name: HumanEval_9_rolling_max
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ res = new long[numbers.length];\n\tif (numbers.length > 0)\n\t{\n\t\tres[0]\
    \ = numbers[0];\n\t\tfor (int i = 1; i < numbers.length; i++)\n\t\t{\n\t\t\tres[i]\
    \ = max(res[i - 1], numbers[i]);\n\t\t}\n\t}\n\treturn res;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n\tlong[] res = new long[numbers.length];\n\tif (numbers.length\
    \ > 0)\n\t{\n\t\tres[0] = numbers[0];\n\t\tfor (int i = 1; i < numbers.length;\
    \ i++)\n\t\t{\n\t\t\tres[i] = min(res[i - 1], numbers[i]);\n\t\t}\n\t}\n\treturn\
    \ res;\n}\n/*\n  From a given array of integers, generate an array of rolling\
    \ sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n\tlong[] res = new long[numbers.length];\n\t\
    if (numbers.length > 0)\n\t{\n\t\tres[0] = numbers[0];\n\t\tfor (int i = 1; i\
    \ < numbers.length; i++)\n\t\t{\n\t\t\tres[i] = res[i - 1] + numbers[i];\n\t\t\
    }\n\t}\n\treturn res;\n}\n/*\n  From a given array of integers, generate an array\
    \ of rolling average of elements found until given moment\n\nunittest\n{\n   \
    \ alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprkj11tis.d(63): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprkj11tis.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_until_now = numbers[0];\n    size_t n = numbers.length;\n    long[] result\
    \ = new long[n];\n    result[0] = max_until_now;\n    foreach (i,number; numbers[1..$])\n\
    \    {\n        if (number > max_until_now)\n        {\n            max_until_now\
    \ = number;\n        }\n        result[i] = max_until_now;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_average([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L, 3L, 3L]\n*/\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpqa9117du.d(12): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42858e]

    ??:? long[] tmpqa9117du.rolling_max(long[]) [0x427e4b]

    ??:? void tmpqa9117du.__unittest_L32_C1() [0x427f6e]

    ??:? void tmpqa9117du.__modtest() [0x42825c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b44e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b88]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430665]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b425]

    ??:? runModuleUnitTests [0x42c391]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    bool[]\
    \ current_max_indices = new bool[numbers.length];\n    long[] rolling_max = new\
    \ long[numbers.length];\n    for (long i = 0; i < numbers.length; i++) \n    {\n\
    \        current_max_indices[i] = true;\n        for (long j = 0; j < i; j++)\
    \ \n        {\n            if (numbers[j] >= numbers[i]) \n            {\n   \
    \             current_max_indices[i] = false;\n                break;\n      \
    \      }\n        }\n        if (current_max_indices[i]) \n        {\n       \
    \     rolling_max[i] = numbers[i];\n        } \n        else \n        {\n   \
    \         rolling_max[i] = rolling_max[i - 1];\n        }\n    }\n    return rolling_max;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif\
    \ (numbers.length == 0) return [];\n\tlong[] res = new long[numbers.length];\n\
    \tres[0] = numbers[0];\n\tfor (size_t i = 1; i < numbers.length; i++)\n\t\tres[i]\
    \ = max(res[i - 1], numbers[i]);\n\treturn res;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpts9840tx.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpts9840tx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in \n\
    \    {\n        assert(numbers.length > 0);\n    }\n    out \n    (\n        result.length\
    \ == numbers.length\n    )\n{\n    // https://www.programiz.com/dsa/stack-in-cpp\n\
    \    import std.typecons;\n    import std.algorithm;\n    Stack!long stack = new\
    \ Stack!long();\n    stack.push(numbers[0]);\n    auto max_num = numbers[0];\n\
    \    foreach(i, number; numbers[1..$])\n    {\n        if (number > max_num)\n\
    \        {\n            max_num = number;\n        }\n        stack.push(max_num);\n\
    \    }\n    long[] result = stack.array();\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphrsopd7a.d(17): Error: found `.` when expecting `)`

    /tmp/tmphrsopd7a.d(17): Error: statement expected to be `{ }`, not `length`

    /tmp/tmphrsopd7a.d(18): Error: found `)` when expecting `;` following statement

    /tmp/tmphrsopd7a.d(19): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrsopd7a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (size_t\
    \ i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i -\
    \ 1], numbers[i]);\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyjpz_kgn.d(20): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyjpz_kgn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    static\
    \ struct IndexedLong \n    {\n        size_t index;\n        long value;\n   \
    \ }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpysck8la_.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpysck8la_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //\
    \ Declaring a temporary buffer to keep track of the max found in the loop\n  \
    \  long buffer;\n    // Initalizing the buffer with the first element of the array.\n\
    \    buffer = numbers[0];\n    // Initializing the array to be returned with the\
    \ first element of the array.\n    long[] rolling_max = new long[1];\n    rolling_max[0]\
    \ = numbers[0];\n    // Looping over the numbers in the array, if the buffer is\
    \ less than the number, it is overwritten.\n    // This will be used to return\
    \ the maximum number found in the array so far.\n    for (long i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (buffer < numbers[i])\n        {\n            buffer\
    \ = numbers[i];\n        }\n        rolling_max ~= buffer;\n    }\n    return\
    \ rolling_max;\n}\n// This algorithm doesn't achieve the best possible score because\
    \ of the 'if' statement in the loop.\n// I will implement a solution that is O(n)\
    \ after reviewing the solution.\n// Solution from the book (O(n)):\n// In the\
    \ previous solution we needed to traverse the entire list to find the rolling\
    \ max for\n// each element. This is becase we were always comparing the previous\
    \ elements to find the max so far.\n// In this solution, we traverse the array\
    \ only once, and for each element we record the max element\n// so far, and the\
    \ current element. We then compare the two to determine which element is written\
    \ to the\n// array to be returned. This allows us to only loop over the array\
    \ once and also allows us to find the\n// rolling max for each element.\nlong[]\
    \ rolling_max_better(long[] numbers) \n{\n    // Initializing the array to be\
    \ returned with the first element of the array.\n    long[] rolling_max = new\
    \ long[1];\n    rolling_max[0] = numbers[0];\n    // Declaring the max element\
    \ found so far\n    long max_so_far = numbers[0];\n    // Looping over the array\
    \ and comparing each element to the max found so far\n    for (long i = 1; i <\
    \ numbers.length; i++)\n    {\n        // If the max so far is less than the current\
    \ element, set\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4l2hwz5j.d(51): Error: found `unittest` instead of statement

    /tmp/tmp4l2hwz5j.d(60): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4l2hwz5j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ N = numbers.length;\n    long[] output = new long[N];\n    output[0] = numbers[0];\n\
    \    for (auto index = 1; index < N; index++)\n    {\n        output[index] =\
    \ max(output[index - 1], numbers[index]);\n    }\n    return output;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling maximum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max_alt(long[]\
    \ numbers) \n{\n    auto N = numbers.length;\n    long[] output = new long[N];\n\
    \    auto m = numbers[0];\n    for (auto index = 0; index < N; index++)\n    {\n\
    \        m = max(m, numbers[index]);\n        output[index] = m;\n    }\n    return\
    \ output;\n}\n/*\n    From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    auto N = numbers.length;\n    long[] output\
    \ = new long[N];\n    output[0] = numbers[0];\n    for (auto index = 1; index\
    \ < N; index++)\n    {\n        output[index] = min(output[index - 1], numbers[index]);\n\
    \    }\n    return output;\n}\n/*\n    From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5iaz9ux7.d(58): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5iaz9ux7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ rollingMax;\n    long num = 0;\n    rollingMax.length = numbers.length;\n  \
    \  if (numbers.length) \n    {\n        rollingMax[0] = numbers[0];\n        for\
    \ (int i = 1; i < numbers.length; i++) \n        {\n            num = numbers[i];\n\
    \            if (num > rollingMax[i - 1]) \n            {\n                rollingMax[i]\
    \ = num;\n            }\n            else \n            {\n                rollingMax[i]\
    \ = rollingMax[i - 1];\n            }\n        }\n    }\n    return rollingMax;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    assert(numbers.length\
    \ > 0);\n    auto result = new long[numbers.length];\n    immutable long max_so_far\
    \ = 0;\n    foreach (index, number; numbers) {\n        if (number > max_so_far)\
    \ {\n            max_so_far = number;\n        }\n        result[index] = max_so_far;\n\
    \    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpptvmb_vp.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpptvmb_vp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ output = numbers.dup;\n    foreach (i, e; output)\n    {\n        if (i > 0)\n\
    \        {\n            output[i] = max(output[i], output[i - 1]);\n        }\n\
    \    }\n    return output;\n}\n/*\n Given an array of integers, how many of them\
    \ are unique?\n    >>> unique_elements([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    4L\n\
    \    \n*/\nsize_t unique_elements(long[] numbers) \n{\n    return set(numbers).length;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt6y1dcsp.d(17): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpt6y1dcsp.d(30): Error: undefined identifier `set`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt6y1dcsp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    assert(numbers.length\
    \ >= 1);\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, _; 1 .. numbers.length)\n    {\n        result[i] = max(result[i\
    \ - 1], numbers[i]);\n    }\n    return result;\n}\n \n// From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    // in the sequence.\n// >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n// [1L,\
    \ 1L, 1L, 1L, 1L, 1L, 1L]\nlong[] rolling_min(long[] numbers) \n{\n    assert(numbers.length\
    \ >= 1);\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, _; 1 .. numbers.length)\n    {\n        result[i] = min(result[i\
    \ - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdflxiwob.d(15): Error: found `..` when expecting `)`

    /tmp/tmpdflxiwob.d(15): Error: found `)` when expecting `;` following statement

    /tmp/tmpdflxiwob.d(31): Error: found `..` when expecting `)`

    /tmp/tmpdflxiwob.d(31): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdflxiwob.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ ret = new long[numbers.length];\n    long[] val = new long[numbers.length];\n\
    \    ret[0] = numbers[0];\n    val[0] = numbers[0];\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        ret[i] = numbers[i] > val[i - 1] ? numbers[i] : val[i -\
    \ 1];\n        val[i] = numbers[i];\n    }\n    return ret;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] ret = new long[numbers.length];\n    long[] val = new\
    \ long[numbers.length];\n    ret[0] = numbers[0];\n    val[0] = numbers[0];\n\
    \    for (int i = 1; i < numbers.length; i++)\n    {\n        ret[i] = numbers[i]\
    \ < val[i - 1] ? numbers[i] : val[i - 1];\n        val[i] = numbers[i];\n    }\n\
    \    return ret;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L,\
    \ 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] ret = new\
    \ long[numbers.length];\n    long[] val = new long[numbers.length];\n    ret[0]\
    \ = numbers[0];\n    val[0] = numbers[0];\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        ret\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpex6cezks.d(59): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpex6cezks.d(68): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpex6cezks.d(68): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpex6cezks.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto\
    \ result = new long[](numbers.length);\n  auto current_max = numbers[0];\n  result[0]\
    \ = current_max;\n  foreach (i, n; numbers[1 .. $]) \n  {\n    if (n > current_max)\n\
    \      current_max = n;\n    result[i + 1] = current_max;\n  }\n  return result;\n\
    }\n/*\n    From a given array of integers, generate an array of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    */\nlong[] rolling_min(long[]\
    \ numbers) \n{\n  auto result = new long[](numbers.length);\n  auto current_min\
    \ = numbers[0];\n  result[0] = current_min;\n  foreach (i, n; numbers[1 .. $])\
    \ \n  {\n    if (n < current_min)\n      current_min = n;\n    result[i + 1] =\
    \ current_min;\n  }\n  return result;\n}\n/*\n    From a given array of integers,\
    \ generate an array of rolling sum of elements found until given moment\n    in\
    \ the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L,\
    \ 6L, 8L, 11L, 15L, 17L]\n    */\nlong[] rolling_sum(long[] numbers) \n{\n  auto\
    \ result = new long[](numbers.length);\n  auto current_sum = numbers[0];\n  result[0]\
    \ = current_sum;\n  foreach (i, n; numbers[1 .. $]) \n  {\n    current_sum +=\
    \ n;\n    result[i + 1] = current_sum;\n  }\n  return result;\n}\n/*\n    From\
    \ a given array of integers, generate an array of rolling mean value of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_mean([\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5q6ujr1_.d(60): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5q6ujr1_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ rmax = new long[numbers.length];\n    rmax[0] = numbers[0];\n    foreach (i,\
    \ v; numbers[1 .. $])\n    {\n        rmax[i + 1] = max(v, rmax[i]);\n    }\n\
    \    return rmax;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling maximum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_max_zip(long[] numbers) \n{\n    long[] rmax =\
    \ new long[numbers.length];\n    rmax[0] = numbers[0];\n    foreach (i, v; zip(numbers[1\
    \ .. $], rmax[0 .. $]))\n    {\n        rmax[i + 1] = max(v[0], v[1]);\n    }\n\
    \    return rmax;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling maximum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_max_foreach(long[] numbers) \n{\n    long[] rmax\
    \ = new long[numbers.length];\n    rmax[0] = numbers[0];\n    foreach (i, v; numbers[1\
    \ .. $])\n    {\n        rmax[i + 1] = max(v, rmax[i]);\n    }\n    return rmax;\n\
    }\n/*\n From a given array of integers, generate an array of rolling maximum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdve41ghk.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdve41ghk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ result = new long[];\n    foreach (index, x; numbers)\n    {\n        if (index\
    \ == 0)\n        {\n            result ~= x;\n        }\n        else \n     \
    \   {\n            result ~= max(x, result[$-1]);\n        }\n    }\n    return\
    \ result;\n}\n/*\n    Finds all of the possible rolling maximums of `numbers`\
    \ of size `window_size`\n    >>> rollings_max([1L, 2L, 3L, 2L, 3L, 4L, 2L], 2)\n\
    \    [[1L, 2L], [2L, 3L], [3L, 3L], [2L, 3L], [3L, 4L], [4L, 4L], [2L, 4L]]\n\
    */\nlong[][] rollings_max(long[] numbers, int window_size) \n{\n    assert(window_size\
    \ != 0);\n    if (window_size < 0)\n    {\n        numbers = numbers[0..window_size];\n\
    \        window_size = -window_size;\n    }\n    auto result = new long[][](numbers.length\
    \ - window_size + 1);\n    foreach (i; 0..numbers.length - window_size + 1)\n\
    \    {\n        result[i] = rolling_max(numbers[i..i + window_size]);\n    }\n\
    \    return result;\n}\n/*\n    Finds all of the possible rolling maximums of\
    \ `numbers` of size `window_size`\n    >>> rollings_max([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L], 2)\n    [[1L, 2L], [2L, 3L], [3L, 3L], [2L, 3L], [3L, 4L], [4L, 4L], [2L,\
    \ 4L]]\n*/\nlong[][] rollings_max_zip(long[] numbers, int window_size) \n{\n \
    \   assert(window_size != 0);\n    if (window_size < 0)\n    {\n        numbers\
    \ = numbers[0..window_size];\n        window_size = -\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbbrob0le.d(58): Error: expression expected, not `unittest`

    /tmp/tmpbbrob0le.d(59): Error: found `{` when expecting `;` following statement

    /tmp/tmpbbrob0le.d(67): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbbrob0le.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if\
    \ (numbers.length < 1) return new long[0];\n    if (numbers.length == 1) return\
    \ numbers;\n    long[] result = new long[numbers.length];\n    auto max_so_far\
    \ = numbers[0];\n    result[0] = max_so_far;\n    foreach (n, i; numbers[1 ..\
    \ $])\n    {\n        if (n > max_so_far) max_so_far = n;\n        result[i] =\
    \ max_so_far;\n    }\n    return result;\n}\n/*\n Given a number of seconds, return\
    \ the time in minutes and seconds.\n    >>> minutes_and_seconds(3599)\n    Tuple!(int,\
    \ int)(59, 59)\n    >>> minutes_and_seconds(0)\n    Tuple!(int, int)(0, 0)\n \
    \   >>> minutes_and_seconds(60)\n    Tuple!(int, int)(1, 0)\n    >>> minutes_and_seconds(3660)\n\
    \    Tuple!(int, int)(61, 0)\n*/\nauto minutes_and_seconds(long seconds)\n{\n\
    \    auto mins = seconds / 60;\n    auto secs = seconds % 60;\n    return tuple(mins,\
    \ secs);\n}\n/*\n Given a phone number in international format, return the number\
    \ in local format with a leading zero.\n    >>> local_number(\"+48123456789\"\
    )\n    \"0048123456789\"\n    >>> local_number(\"123456789\")\n    \"00123456789\"\
    \n    >>> local_number(\"0048123456789\")\n    \"0048123456789\"\n*/\nstring local_number(string\
    \ phone_number)\n{\n    if (phone_number.length == 0) return \"\";\n    if (phone_number[0]\
    \ == '+') return \"00\" ~ phone_number[1 .. $];\n    if (phone_number[0 .. 1]\
    \ == \"00\") return phone_number;\n    if (phone_number[0] == '0') return \"00\"\
    \ ~ phone_number[1 .. $];\n    return \"00\" ~ phone_number;\n}\n/*\n Return\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbfo_w16q.d(58): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbfo_w16q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ ds = SinglyLinkedList!(Tuple!(long, long)).init;\n    auto result = new long[numbers.length];\n\
    \    foreach (i, e; numbers) {\n        int endIndex = ds.length;\n        //remove\
    \ elements that are smaller than the element at hand\n        while (endIndex\
    \ && ds[endIndex - 1].length > e) {\n            ds.removeAt(endIndex - 1);\n\
    \            endIndex--;\n        }\n        //append element\n        ds.append(tuple(e,\
    \ i));\n        //set the value in the result\n        result[i] = endIndex ?\
    \ ds[endIndex - 1].length : 0;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp24byj3cq.d(12): Error: template instance `SinglyLinkedList!(Tuple!(long,
    long))` template `SinglyLinkedList` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp24byj3cq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \nin {\n \
    \   for (i in 0 .. numbers.length - 1) \n        //assert(numbers[i] >= 0);\n\
    \    assert(numbers.length > 0);\n}\nout (result) {\n    assert(result.length\
    \ == numbers.length);\n    for (i in 0 .. result.length - 1) \n        assert(result[i]\
    \ >= 0);\n}\n{\n    long[] result = new long[numbers.length];\n    long maxSoFar\
    \ = numbers[0];\n    for (i in 0 .. numbers.length - 1) {\n        if (maxSoFar\
    \ < numbers[i]) {\n            maxSoFar = numbers[i];\n        }\n        result[i]\
    \ = maxSoFar;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2eg7hsj.d(12): Error: found `..` when expecting `;` following
    statement

    /tmp/tmpq2eg7hsj.d(12): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmpq2eg7hsj.d(14): Error: found `;` when expecting `)`

    /tmp/tmpq2eg7hsj.d(15): Error: found `}` instead of statement

    /tmp/tmpq2eg7hsj.d(18): Error: found `..` when expecting `;` following statement

    /tmp/tmpq2eg7hsj.d(18): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmpq2eg7hsj.d(19): Error: found `;` when expecting `)`

    /tmp/tmpq2eg7hsj.d(20): Error: found `}` instead of statement

    /tmp/tmpq2eg7hsj.d(21): Error: missing `do { ... }` after `in` or `out`

    /tmp/tmpq2eg7hsj.d(24): Error: found `..` when expecting `;` following statement

    /tmp/tmpq2eg7hsj.d(24): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmpq2eg7hsj.d(30): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2eg7hsj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif\
    \ (numbers.length == 0)\n\t\treturn [];\n\tif (numbers.length == 1)\n\t\treturn\
    \ [numbers[0]];\n\t\n\tauto maxes = new long[numbers.length];\n\tmaxes[0] = numbers[0];\n\
    \t\n\tforeach (idx, n; numbers[1..$]) \n\t{\n\t\tmaxes[idx] = max(maxes[idx-1],\
    \ n);\n\t}\n\t\n\treturn maxes;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjvznjb75.d(22): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjvznjb75.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ res = new long[numbers.length];\n\tif (numbers.length == 0)\n\t{\n\t\treturn\
    \ res;\n\t}\n\telse\n\t{\n\t\tres[0] = numbers[0];\n\t\tint i = 1;\n\t\twhile\
    \ (i < numbers.length)\n\t\t{\n\t\t\tres[i] = max(res[i - 1], numbers[i]);\n\t\
    \t\ti++;\n\t\t}\n\t\treturn res;\n\t}\n}\n// Generated by Dlang plug-in.\n@SuppressWarnings(\"\
    unused\")\npublic static class tsl_TResult {\n    private static final tsl_TResult\
    \ instance = new tsl_TResult();\n    public static tsl_TResult getInstance() {\n\
    \        return instance;\n    }\n    private static final Func2<Object, tsl_TResult,\
    \ Object> __ctor = (Func2<Object, tsl_TResult, Object>)\n        ((Object o, tsl_TResult\
    \ self) -> {\n            return null;\n        });\n    private static final\
    \ Func2<Object, tsl_TResult, Object> __opAssign = (Func2<Object, tsl_TResult,\
    \ Object>)\n        ((Object o, tsl_TResult self) -> {\n            return null;\n\
    \        });\n    public static final class tsl_TResultMembers {\n        public\
    \ static final Func2<Object, tsl_TResult, Object> ctor = __ctor;\n        public\
    \ static final Func2<Object, tsl_TResult, Object> opAssign = __opAssign;\n   \
    \ }\n}\n// Generated by Dlang plug-in.\n@SuppressWarnings(\"unused\")\npublic\
    \ static class tsl_TResult_0 {\n    private static final tsl_TResult_0 instance\
    \ = new tsl_TResult_0();\n    public static tsl_TResult_0 getInstance() {\n  \
    \      return instance;\n    }\n    private static final Func2<Object, tsl_TResult_0,\
    \ Object> __ctor = (Func2<Object, tsl_TResult_0, Object>)\n        ((Object\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2otu4bcj.d(36): Error: no identifier for declarator `Func2`

    /tmp/tmp2otu4bcj.d(36): Error: declaration expected, not `<`

    /tmp/tmp2otu4bcj.d(39): Error: declaration expected, not `)`

    /tmp/tmp2otu4bcj.d(40): Error: no identifier for declarator `Func2`

    /tmp/tmp2otu4bcj.d(40): Error: declaration expected, not `<`

    /tmp/tmp2otu4bcj.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2otu4bcj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ maximums = new long[numbers.length];\n    long maximum = 0;\n    foreach (i,\
    \ number; numbers) \n    {\n        maximum = std.math.max(maximum, number);\n\
    \        maximums[i] = maximum;\n    }\n    return maximums;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] minimums = new long[numbers.length];\n    long minimum = 0;\n\
    \    foreach (i, number; numbers) \n    {\n        minimum = std.math.min(minimum,\
    \ number);\n        minimums[i] = minimum;\n    }\n    return minimums;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling min/max elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_minmax([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [(1L, 1L), (1L, 2L), (1L, 3L), (1L, 3L), (1L,\
    \ 3L), (1L, 4L), (1L, 4L)]\n*/\nTuple!(long, long)[] rolling_minmax(long[] numbers)\
    \ \n{\n    Tuple!(long, long)[] minmaxs = new Tuple!(long, long)[numbers.length];\n\
    \    long minimum = numbers[0];\n    long maximum = numbers[0];\n    foreach (i,\
    \ number; numbers) \n    {\n        minimum = std.math.min(minimum, number);\n\
    \        maximum = std.math.max(maximum, number);\n        minmaxs[i] = std.typecons.tuple(minimum,\
    \ maximum);\n    }\n    return minmaxs;\n}\n/*\n Given two arrays of integers,\
    \ find the number of valid pairs\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqltda6ib.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqltda6ib.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx0ai9t9j.d(13): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx0ai9t9j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ ret = new long[];\n    long max;\n    if (numbers.length == 0) \n    {\n   \
    \     return ret;\n    }\n    max = numbers[0];\n    ret ~= max;\n    foreach\
    \ (i; 1 .. numbers.length) \n    {\n        if (numbers[i] > max) \n        {\n\
    \            max = numbers[i];\n        }\n        ret ~= max;\n    }\n    return\
    \ ret;\n}\n/*\nWrite a function in D that will render an array of integers as\
    \ a staircase.\n>>> staircase([2L,3L,4L,2L,3L,4L,5L,1L,2L,3L,4L,5L,6L,1L,2L,3L,4L,5L,6L,7L])\n\
    >>> 2\n>>>   3\n>>>     4\n>>>   3\n>>>     4\n>>>       5\n>>> 1\n>>>   2\n>>>\
    \     3\n>>>       4\n>>>         5\n>>>           6\n>>> 1\n>>>   2\n>>>    \
    \ 3\n>>>       4\n>>>         5\n>>>           6\n>>>             7\n*/\nstring\
    \ staircase(long[] numbers) \n{\n    string ret = \"\";\n    string space = \"\
    \";\n    foreach (i; 0 .. numbers.length) \n    {\n        ret ~= space ~ numbers[i]\
    \ ~ \"\\n\";\n        space ~= \" \";\n    }\n    return ret;\n}\n/*\n Create\
    \ an array of constants for the given set of arguments passed.\n constants(1,2,3,4,5,6)\n\
    \ output: [1L, 2L, 3L, 4L, 5L, 6L]\n */\nT[] constants(T)(T args...) \n{\n   \
    \ T[] ret = new T[];\n    foreach (t; args) \n    {\n        ret ~= t;\n    }\n\
    \    return ret;\n}\n/*\n Create an array of the alternating elements, starting\
    \ with the first element.\n alternating(1,2,3,4,5,6)\n output: [1L, 3L, 5L]\n\
    */\nT[] alternating(T)(T\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpskfja4ti.d(84): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpskfja4ti.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.array;\n    long[] acc\
    \ = new long[](numbers.length);\n    acc[0] = numbers[0];\n    auto iter = numbers.save.dropOne.zip(acc.dropOne);\n\
    \    foreach(i, (long val, ref long res))\n    {\n        res = max(res, val);\n\
    \    }\n    return acc;\n}\n// Algorithms\n/*\n Find the longest sequence of consecutive\
    \ elements in an array.\n    >>> longest_seq([1L, 2L, 3L, 4L, 5L, 5L, 6L, 7L,\
    \ 8L, 1L, 2L, 2L, 3L, 5L, 6L, 7L,\n    8L, 10L, 11L, 9L, 8L, 8L, 7L, 6L, 5L, 4L,\
    \ 3L, 2L, 1L])\n    [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]\n*/\nlong[] longest_seq(long[]\
    \ in_arr) \n{\n    import std.array;\n    auto accum = new long[](in_arr.length);\n\
    \    auto index = new long[](in_arr.length);\n    accum[0] = 1;\n    index[0]\
    \ = 0;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    foreach(i, val; in_arr.dropOne.zip(accum.dropOne.zip(index.dropOne)))\n \
    \   {\n        int j = in_arr[i].lowerBound(in_arr[i - 1L + 1L .. $]);\n     \
    \   if (j == in_arr[i].length) \n        {\n            in_arr[i + 1L] = in_arr[i];\n\
    \            index[i + 1L] = index[i];\n        }\n        else \n        {\n\
    \            in_arr[i + 1L] = in_arr[i].length - j;\n            index[i + 1L]\
    \ = i + j;\n        }\n    }\n    return in\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpled883lr.d(18): Error: basic type expected, not `(`

    /tmp/tmpled883lr.d(18): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpled883lr.d(18): Error: no identifier for declarator `_error_(long val,
    ref long res)`

    /tmp/tmpled883lr.d(18): Error: found `)` when expecting `;`

    /tmp/tmpled883lr.d(22): Error: found `return` when expecting `)`

    /tmp/tmpled883lr.d(55): Error: expression expected, not `in`

    /tmp/tmpled883lr.d(56): Error: found `unittest` when expecting `;` following `return`
    statement

    /tmp/tmpled883lr.d(65): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpled883lr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    enum\
    \ num_elements = numbers.length;\n    auto result = new long[num_elements];\n\
    \    auto max_found = numbers[0];\n    for (auto i = 0; i < num_elements; i++)\
    \ \n    {\n        if (numbers[i] > max_found)\n            max_found = numbers[i];\n\
    \        result[i] = max_found;\n    }\n    return result;\n}\nlong[] rolling_max2(long[]\
    \ numbers) \n{\n    auto result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, number; numbers[1..]) \n    {\n        result[i + 1] = max(result[i],\
    \ number);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcxu_0h1r.d(27): Error: expression expected, not `]`

    /tmp/tmpcxu_0h1r.d(27): Error: found `)` when expecting `,`

    /tmp/tmpcxu_0h1r.d(31): Error: found `return` when expecting `,`

    /tmp/tmpcxu_0h1r.d(31): Error: found `;` when expecting `,`

    /tmp/tmpcxu_0h1r.d(32): Error: expression expected, not `}`

    /tmp/tmpcxu_0h1r.d(33): Error: found `unittest` when expecting `,`

    /tmp/tmpcxu_0h1r.d(42): Error: found `void` when expecting `,`

    /tmp/tmpcxu_0h1r.d(42): Error: found `{` when expecting `,`

    /tmp/tmpcxu_0h1r.d(42): Error: expression expected, not `}`

    /tmp/tmpcxu_0h1r.d(42): Error: found `End of File` when expecting `,`

    /tmp/tmpcxu_0h1r.d(42): Error: found `End of File` when expecting `]`

    /tmp/tmpcxu_0h1r.d(42): Error: found `End of File` when expecting `)`

    /tmp/tmpcxu_0h1r.d(42): Error: found `End of File` instead of statement

    /tmp/tmpcxu_0h1r.d(42): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcxu_0h1r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in \n\
    \    {\n        assert(numbers.length > 0);\n    }\n    out\n    (\n        result.length\
    \ == numbers.length\n    )\n{\n    long[] result = new long[];\n    result ~=\
    \ numbers[0];\n    for (int i = 1; i < numbers.length; i++)\n    {\n        result\
    \ ~= max(result[$-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxsgp990h.d(17): Error: found `.` when expecting `)`

    /tmp/tmpxsgp990h.d(17): Error: statement expected to be `{ }`, not `length`

    /tmp/tmpxsgp990h.d(18): Error: found `)` when expecting `;` following statement

    /tmp/tmpxsgp990h.d(19): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxsgp990h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif\
    \ (numbers.length == 0) return [];\n\tlong curr_max = numbers[0];\n\tlong[] result\
    \ = [curr_max];\n\tforeach (n; numbers[1..$])\n\t{\n\t\tcurr_max = max(curr_max,\
    \ n);\n\t\tresult ~= curr_max;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3syedki.d(17): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3syedki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.algorithm.sorting : sort;\n    auto result = numbers.dup;\n    foreach (i,\
    \ num; numbers)\n    {\n        if (i > 0)\n        {\n            result[i] =\
    \ max(result[i-1], num);\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp22p8sgmy.d(18): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp22p8sgmy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ results = new long[numbers.length];\n    int i = 1;\n    results[0] = numbers[0];\n\
    \    foreach(n; numbers[1..$]) {\n        if (n > results[i-1]) results[i] = n;\n\
    \        else results[i] = results[i-1];\n        i++;\n    }\n    return results;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpm28o5d0y.d(14): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285f6]

    ??:? long[] tmpm28o5d0y.rolling_max(long[]) [0x427e69]

    ??:? void tmpm28o5d0y.__unittest_L22_C1() [0x427fda]

    ??:? void tmpm28o5d0y.__modtest() [0x4282c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c623]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430741]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430bf0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b48d]

    ??:? runModuleUnitTests [0x42c3f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxSoFar = numbers[0];\n    for\
    \ (size_t i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] > maxSoFar)\
    \ \n        {\n            maxSoFar = numbers[i];\n        }\n        result[i]\
    \ = maxSoFar;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L]\n   \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long minSoFar = numbers[0];\n    for\
    \ (size_t i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] < minSoFar)\
    \ \n        {\n            minSoFar = numbers[i];\n        }\n        result[i]\
    \ = minSoFar;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum of all elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sumSoFar = numbers[0];\n\
    \    for (size_t i = 0; i < numbers.length; i++) \n    {\n        sumSoFar +=\
    \ numbers[i];\n        result[i] = sumSoFar;\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average of all\
    \ elements found until given moment\n    in the sequence.\n    >>> rolling_av\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1d3s4x9_.d(63): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1d3s4x9_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto\
    \ result = new long[numbers.length];\n  auto current_max = numbers[0];\n  auto\
    \ i = 1;\n  foreach(v;numbers) \n  {\n    if (v > current_max) \n    {\n     \
    \ current_max = v;\n    }\n    result[i] = current_max;\n    i++;\n  }\n  return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpbk22u0ld.d(13): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42853e]

    ??:? long[] tmpbk22u0ld.rolling_max(long[]) [0x427e62]

    ??:? void tmpbk22u0ld.__unittest_L26_C1() [0x427f22]

    ??:? void tmpbk22u0ld.__modtest() [0x428210]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c56b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3fe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430689]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b38]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430615]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d5]

    ??:? runModuleUnitTests [0x42c341]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ last_max = numbers[0];\n    auto result = new long[];\n    for (long number;\
    \ numbers) {\n        number = numbers.front;\n        numbers.popFront;\n   \
    \     last_max = max(last_max, number);\n        result ~= last_max;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6sn_yt0y.d(14): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp6sn_yt0y.d(20): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6sn_yt0y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n    From given array of integers,\
    \ count how many times each value occurs in the array.\n    >>> count_occurrences([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L: 1L, 2L: 3L, 3L: 2L, 4L: 1L]\n    In the case\
    \ of ties, the order of elements in the tuple is unspecified.\n*/\nMap!(long,\
    \ long) count_occurrences(long[] numbers) \n{\n    auto result = new Map!(long,\
    \ long);\n    foreach (n; numbers)\n    {\n        if (result.contains(n))\n \
    \       {\n            result[n]++;\n        }\n        else\n        {\n    \
    \        result[n] = 1;\n        }\n    }\n    return result;\n}\n/*\n    Return\
    \ the number of occurrences of each character from the alphabet in a given string.\n\
    \    >>> count_characters(\"Hello world!\")\n    ['H': 1L, 'e': 1L, 'l': 3L, 'o':\
    \ 2L, ' ': 1L, 'w': 1L, 'r': 1L, 'd': 1L, '!': 1L]\n*/\nMap!(char, long) count_characters(string\
    \ s) \n{\n    auto result = new Map!(char, long);\n    foreach (n; s)\n    {\n\
    \        if (result.contains(n))\n        {\n            result[n]++;\n      \
    \  }\n        else\n        {\n            result[n] = 1;\n        }\n    }\n\
    \    return result;\n}\n/*\n    Return the list of all possible subsequences of\
    \ an input string.\n    >>> list_subsequences(\"abc\")\n    [\"\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51mx2u1a.d(68): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51mx2u1a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = numbers.dup;\n    foreach (i, e; result)\n    {\n        result[i]\
    \ = max(result[0..i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt7fabzrx.d(15): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt7fabzrx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_value = numbers[0];\n    long[] r_max = new long[numbers.length];\n    r_max[0]\
    \ = max_value;\n    foreach(i, v; numbers[1..$])\n    {\n        max_value = max(max_value,\
    \ v);\n        r_max[i+1] = max_value;\n    }\n    return r_max;\n}\n/*\n Provide\
    \ a function, which will return the value of the first element, when pushed by\
    \ the provided\n    distance. As the array does not have to be large enough to\
    \ accommodate the push, the function is\n    to complete the sequence with zeros.\n\
    \    >>> push([1L, 2L, 3L, 4L, 5L], -2)\n    [0L, 0L, 1L, 2L, 3L]\n    >>> push([1L,\
    \ 2L, 3L, 4L, 5L], 1)\n    [0L, 0L, 0L, 0L, 1L]\n    >>> push([1L, 2L, 3L, 4L,\
    \ 5L], 5)\n    [0L, 0L, 0L, 0L, 0L]\n*/\nlong[] push(long[] numbers, long distance)\
    \ \n{\n    long n = 0;\n    foreach(i, v; numbers)\n    {\n        n = max(n,\
    \ abs(i + distance));\n    }\n    long[] pushed = new long[n+1];\n    foreach(i,\
    \ v; numbers)\n    {\n        pushed[i + distance] = v;\n    }\n    return pushed;\n\
    }\n/*\nProvide a function, which will return the highest value found in the array,\
    \ when pushed by the\n    provided distance. As the array does not have to be\
    \ large enough to accommodate the push, the\n    function is to complete the sequence\
    \ with zeros.\n    >>> max_push([1L, 2L, 3L, 4L, 5L], -2)\n    2L\n    >>> max_push([1L,\
    \ 2L, 3L, 4L, 5L], 1)\n    1L\n    >>> max_push([1L, 2L, 3L, 4L, 5\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqs5nc3f1.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqs5nc3f1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_num = numbers[0];\n    long[] result = new long[numbers.length];\n    for\
    \ (long i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] > max_num)\
    \ \n        {\n            max_num = numbers[i];\n        }\n        result[i]\
    \ = max_num;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp1augneng.d(12): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42856e]

    ??:? long[] tmp1augneng.rolling_max(long[]) [0x427e4b]

    ??:? void tmp1augneng.__unittest_L24_C1() [0x427f4e]

    ??:? void tmp1augneng.__modtest() [0x42823c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c59b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b42e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430645]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b405]

    ??:? runModuleUnitTests [0x42c371]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    if (numbers.length\
    \ > 0)\n    {\n        auto result = new long[](numbers.length);\n        result[0]\
    \ = numbers[0];\n        foreach (i, val; numbers[1 .. $])\n        {\n      \
    \      result[i] = max(val, result[i - 1]);\n        }\n        return result;\n\
    \    }\n    else\n    {\n        return null;\n    }\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpabnbiot1.d(11): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpabnbiot1.d(11): Error: declaration expected, not `if`

    /tmp/tmpabnbiot1.d(14): Error: no identifier for declarator `result[0]`

    /tmp/tmpabnbiot1.d(14): Error: declaration expected, not `=`

    /tmp/tmpabnbiot1.d(15): Error: declaration expected, not `foreach`

    /tmp/tmpabnbiot1.d(15): Error: no identifier for declarator `numbers[1 .. __dollar]`

    /tmp/tmpabnbiot1.d(15): Error: declaration expected, not `)`

    /tmp/tmpabnbiot1.d(18): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpabnbiot1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ res = new long[numbers.length];\n    auto max = numbers[0];\n    for (size_t\
    \ i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        res[i] = max;\n    }\n    return res;\n}\n/*\n  Given an array of integer\
    \ and that all elements will be provided at once and \n  then a stream of requests\
    \ to find the minimum element in a given range, do it efficiently, \n  with complexity\
    \ ~O(logn) for each request.\n*/\nlong[] min_array_in_range(long[] array, size_t[][]\
    \ ranges) \n{\n    size_t[][] sparse = sparse_table_creation(array);\n    immutable\
    \ size_t N = array.length;\n    long[] res = new long[ranges.length];\n    for\
    \ (size_t i = 0; i < ranges.length; i++) \n    {\n        immutable size_t L =\
    \ ranges[i][0];\n        immutable size_t R = ranges[i][1];\n        immutable\
    \ size_t K = ilog2(R - L + 1);\n        res[i] = min(sparse[L][K], sparse[R -\
    \ (1 << K) + 1][K]);\n    }\n    return res;\n}\n/*\n Creation of the sparse table.\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8t8yf647.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8t8yf647.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    size_t i = 0;\n    long max_seen = -1;\n\
    \    foreach(n; numbers)\n    {\n        //if(n > max_seen)\n        //{\n   \
    \     //    max_seen = n;\n        //}\n        // We can use max function\n \
    \       max_seen = max(max_seen, n);\n        result[i] = max_seen;\n        i++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpthd_0m_p.d(22): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpthd_0m_p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long current_max = numbers[0];\n   \
    \ result[0] = current_max;\n    foreach (index, item; numbers[1..$]) \n    {\n\
    \        current_max = max(current_max, item);\n        result[index + 1] = current_max;\n\
    \    }\n    return result;\n}\n \n/*\n>| Given a sequence of numbers a_0, a_1,\
    \ ... a_n, calculate the sum of k * a_k.\n   >>> sum_k_times_a_k([1L, 3L, 2L,\
    \ 5L, 4L, 2L, 7L], 2L)\n   59L\n   \n>| Return the sum of k * a_k for k = 0 to\
    \ n, with  n = min(k, len(numbers))\n   >>> sum_k_times_a_k([1L, 3L, 2L, 5L, 4L,\
    \ 2L, 7L])\n   81L\n*/\nlong sum_k_times_a_k(long[] numbers, long k = 0L) \n{\n\
    \    long result = 0L;\n    foreach (index, item; numbers[0..min(k, numbers.length)])\
    \ \n    {\n        result += (index + 1L) * item;\n    }\n    return result;\n\
    }\n \n/*\n>| Find the number of times number has to be added to itself to reach\
    \ or exceed n.\n   >>> number_of_times_to_reach_or_exceed(2L, 10L)\n   5L\n*/\n\
    long number_of_times_to_reach_or_exceed(long number, long n) \n{\n    long sum\
    \ = 0L;\n    long times = 0L;\n    while (sum < n) \n    {\n        sum += number;\n\
    \        times++;\n    }\n    return times;\n}\n \n/*\n>| Solve challenge\n  \
    \  >>> solve(10L, 2L, 3L, 11L)\n    38L\n*/\nlong solve(long a, long b, long c,\
    \ long n) \n{\n    long[] numbers\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpio93lfov.d(67): Error: semicolon expected, not `unittest`

    /tmp/tmpio93lfov.d(67): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpio93lfov.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ res = new long[];\n    res ~= numbers[0];\n    foreach(n; numbers[1..$]) \n\
    \    {\n        if (n > res[$-1]) \n        {\n            res ~= n;\n       \
    \ } \n        else \n        {\n            res ~= res[$-1];\n        }\n    }\n\
    \    return res;\n}\n \nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkjkdspi3.d(12): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkjkdspi3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tauto\
    \ result = new long[](numbers.length);\n\tforeach (i, number; numbers)\n\t{\n\t\
    \tforeach (j; i + 1)\n\t\t{\n\t\t\tresult[i] = max(result[i], numbers[j]);\n\t\
    \t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz2skghf8.d(15): Error: invalid `foreach` aggregate `i + 1LU`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2skghf8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ result = new long[](numbers.length);\n    auto max_element = 0L;\n    auto i\
    \ = 0;\n    foreach(n; numbers)\n    {\n        result[i] = max(max_element, n);\n\
    \        max_element = result[i];\n        i++;\n    }\n    return result;\n}\n\
    \ \n/*\n  From a given array of integers, generate an array of rolling minimum\
    \ element found until given moment\n  in the sequence.\n    \n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    auto result = new long[](numbers.length);\n    auto min_element\
    \ = numbers[0];\n    auto i = 0;\n    foreach(n; numbers)\n    {\n        result[i]\
    \ = min(min_element, n);\n        min_element = result[i];\n        i++;\n   \
    \ }\n    return result;\n}\n \n/*\n  From a given array of integers, generate\
    \ an array of rolling sum of elements found until given moment\n  in the sequence.\n\
    \    \n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L,\
    \ 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    auto result\
    \ = new long[](numbers.length);\n    auto sum = 0L;\n    auto i = 0;\n    foreach(n;\
    \ numbers)\n    {\n        sum += n;\n        result[i] = sum;\n        i++;\n\
    \    }\n    return result;\n}\n \n/*\n  From a given array of integers, generate\
    \ an array of rolling average of elements found until given moment\n  in the sequence.\n\
    \    \n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp20puouo4.d(66): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp20puouo4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, n; numbers[1 .. $]) \n    {\n        result[i] = max(result[i - 1], n);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp10x1hydq.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp10x1hydq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ results = new long[numbers.length];\n    long cur_max = long.min;\n    int i;\n\
    \    foreach(i,item;numbers)\n    {\n        results[i] = max(cur_max,item);\n\
    \        cur_max = results[i];\n    }\n    return results;\n}\nunittest\n{\n \
    \   alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8a5bye8m.d(15): Error: variable `i` is shadowing variable `tmp8a5bye8m.rolling_max.i`

    /tmp/tmp8a5bye8m.d(17): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8a5bye8m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ [] result = [numbers[0]];\n    foreach(idx, number; numbers[1..$])\n    {\n\
    \        if(number > result[$-1])\n            result ~= number;\n        else\n\
    \            result ~= result[$-1];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpfr7p0f4j.d(12): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285e6]

    ??:? long[] tmpfr7p0f4j.rolling_max(long[]) [0x427e5c]

    ??:? void tmpfr7p0f4j.__unittest_L22_C1() [0x427fca]

    ??:? void tmpfr7p0f4j.__modtest() [0x4282b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cfa3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42be36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430889]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d38]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430815]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be0d]

    ??:? runModuleUnitTests [0x42cd79]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ ret = new long[numbers.length];\n\tlong max_num = -(ulong.max);\n\tfor (long\
    \ i = 0; i < numbers.length; i++)\n\t{\n\t\tmax_num = max(max_num, numbers[i]);\n\
    \t\tret[i] = max_num;\n\t}\n\treturn ret;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\tlong[]\
    \ ret = new long[numbers.length];\n\tlong min_num = ulong.max;\n\tfor (long i\
    \ = 0; i < numbers.length; i++)\n\t{\n\t\tmin_num = min(min_num, numbers[i]);\n\
    \t\tret[i] = min_num;\n\t}\n\treturn ret;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum of element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L,\
    \ 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n\t\
    long[] ret = new long[numbers.length];\n\tlong current_sum = 0;\n\tfor (long i\
    \ = 0; i < numbers.length; i++)\n\t{\n\t\tcurrent_sum += numbers[i];\n\t\tret[i]\
    \ = current_sum;\n\t}\n\treturn ret;\n}\n/*\n Given a sequence of integers, generate\
    \ an array of the same integers but with values\n    incremented by 1.\n    >>>\
    \ increment_1([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [2L, 3L, 4L, 3\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaqeolirb.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaqeolirb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  long[]\
    \ res = new long[0];\n  foreach(i, val; numbers)\n  {\n    long[] temp = new long[res.length\
    \ + 1];\n    temp[] = max(val, i == 0 ? -1 : res[$-1]);\n    res ~= temp;\n  }\n\
    \  return res;\n}\n \n/*\n  Given a number n return the minimal steps required\
    \ to reach 1.\n  If a number is even divide it by 2 otherwise multiply it by 3\
    \ and add 1.\n  >>> collatz(6)\n  8\n  >>> collatz(7)\n  17\n  \n*/\nlong collatz(long\
    \ n) \n{\n  int count = 0;\n  while(n != 1)\n  {\n    if(n % 2 == 0)\n    {\n\
    \      n /= 2;\n    }\n    else\n    {\n      n = 3 * n + 1;\n    }\n    count++;\n\
    \  }\n  return count;\n}\n/*\n  Flatten a linked list.\n  >>> ll = new std.container.SList!int([1,2,3,4,5]);\n\
    \  std.container.SList!int([1, 2, 3, 4, 5])\n  >>> flatten(ll);\n  std.container.SList!int([1,\
    \ 2, 3, 4, 5])\n  >>> flatten(ll[3]);\n  std.container.SList!int([4, 5])\n*/\n\
    SList!(int) flatten(SList!(int) l) \n{\n  SList!(int) res = new SList!(int)();\n\
    \  while(l !is null)\n  {\n    res.insertBack(l.head);\n    l = l.tail;\n  }\n\
    \  return res;\n}\n/*\n  A zigzag sequence is a sequence of integers that is made\
    \ up\n  of alternating sequences of increasing and decreasing numbers.\n  Given\
    \ a sequence of integers, return its zigzag sequence.\n  >>> zigzag([1,2,3,4,5,6,7,8,9])\n\
    \  [1, 2, 3, 4, 5, 6, 7, 8, 9\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpep21i2rm.d(67): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpep21i2rm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ result = new long[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpblj2amt_.d(13): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpblj2amt_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \n\
    \    auto result = new long[](numbers.length);\n    result[0] = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.length; i++) \n    {\n        result[i] =\
    \ max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpculc0qzd.d(17): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpculc0qzd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ length = numbers.length;\n    long[long[]] table = new long[length];\n    long[]\
    \ maxarr = new long[length];\n    for (int i = 0; i < length; i++)\n    {\n  \
    \      long[] inner = new long[length];\n        for (int j = 0; j < length; j++)\n\
    \        {\n            inner[j] = numbers[j];\n        }\n        table[i] =\
    \ inner;\n    }\n    for (int i = 0; i < length; i++)\n    {\n        table[i]\
    \ = table[i][0..i+1];\n        maxarr[i] = max(table[i]);\n    }\n    return maxarr;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmx3u0gy1.d(12): Error: cannot implicitly convert expression `numbers.length`
    of type `ulong` to `int`

    /tmp/tmpmx3u0gy1.d(13): Error: cannot implicitly convert expression `new long[](cast(ulong)length)`
    of type `long[]` to `long[const(long)[]]`

    /tmp/tmpmx3u0gy1.d(22): Error: cannot implicitly convert expression `i` of type
    `int` to `const(long)[]`

    /tmp/tmpmx3u0gy1.d(26): Error: cannot implicitly convert expression `i` of type
    `int` to `const(long)[]`

    /tmp/tmpmx3u0gy1.d(27): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmx3u0gy1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ result = new long[numbers.length];\n    auto current_max = long.min;\n    foreach\
    \ (i, number; numbers) {\n        current_max = max(current_max, number);\n  \
    \      result[i] = current_max;\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb5833t6q.d(15): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5833t6q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //\
    \ create a tuple type to store the maximum number found until current moment and\
    \ the index of\n    // the first occurrence.\n    alias tuple = Tuple!(long, long);\n\
    \    // create a stack to store maximum numbers and their indices\n    Stack!tuple\
    \ stack = new Stack!tuple;\n    // initialize output array\n    long[] result\
    \ = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        // check if the current number is greater than the top of the\
    \ stack\n        if (stack.length && numbers[i] > stack.top.item1)\n        {\n\
    \            // if so, remove all elements smaller than current number\n     \
    \       while (stack.length && numbers[i] > stack.top.item1)\n               \
    \ stack.pop();\n            // add current number and its index to the stack\n\
    \            stack.push(tuple(numbers[i], i));\n        }\n        else\n    \
    \    {\n            // if not, push the current number and its index to the stack\n\
    \            stack.push(tuple(numbers[i], i));\n        }\n        // check if\
    \ the index of the top of the stack is smaller than or equal to the index of the\n\
    \        // current number\n        if (stack.top.item2 <= i)\n        {\n   \
    \         // if so, the maximum number found until current moment is the top of\
    \ the stack\n            result[i] = stack.top.item1;\n        }\n        else\n\
    \        {\n            // if not, there was no number greater than the current\
    \ number until current moment\n            result[i] = -1;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3i4zcbuk.d(16): Error: template instance `Stack!tuple` template
    `Stack` is not defined

    /tmp/tmp3i4zcbuk.d(16): Error: template instance `Stack!tuple` template `Stack`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3i4zcbuk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t\
    \ n = numbers.length;\n    assert(n >= 0);\n    if (n == 0)\n        return new\
    \ long[0];\n    long[] output = new long[n];\n    output[0] = numbers[0];\n  \
    \  for (size_t i = 1; i < n; i++)\n    {\n        output[i] = max(output[i - 1],\
    \ numbers[i]);\n    }\n    return output;\n}\nlong[] rolling_max(in long[] numbers)\
    \ \n{\n    size_t n = numbers.length;\n    assert(n >= 0);\n    if (n == 0)\n\
    \        return new long[0];\n    long[] output = new long[n];\n    output[0]\
    \ = numbers[0];\n    for (size_t i = 1; i < n; i++)\n    {\n        output[i]\
    \ = max(output[i - 1], numbers[i]);\n    }\n    return output;\n}\nlong[] rolling_max(in\
    \ long[] numbers) \n{\n    size_t n = numbers.length;\n    assert(n >= 0);\n \
    \   if (n == 0)\n        return new long[0];\n    long[] output = new long[n];\n\
    \    output[0] = numbers[0];\n    for (size_t i = 1; i < n; i++)\n    {\n    \
    \    output[i] = max(output[i - 1], numbers[i]);\n    }\n    return output;\n\
    }\nlong[] rolling_max(in long[] numbers) \n{\n    size_t n = numbers.length;\n\
    \    assert(n >= 0);\n    if (n == 0)\n        return new long[0];\n    long[]\
    \ output = new long[n];\n    output[0] = numbers[0];\n    for (size_t i = 1; i\
    \ < n; i++)\n    {\n        output[i] = max(output[i - 1], numbers[i]);\n    }\n\
    \    return output;\n}\nlong[] rolling_max(in long[] numbers) \n{\n    size_t\
    \ n = numbers.length;\n    assert(n >= 0);\n    if (n == 0\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvd120han.d(71): Error: found `unittest` when expecting `)`

    /tmp/tmpvd120han.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvd120han.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    auto max = n.front;\n\
    \    foreach (i, v; numbers) \n    {\n        if (v > max) \n        {\n     \
    \       max = v;\n        }\n        result[i] = max;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    auto min = n.back;\n    foreach (i, v; numbers) \n    {\n        if (v <\
    \ min) \n        {\n            min = v;\n        }\n        result[i] = min;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    foreach (i, v; numbers) \n    {\n     \
    \   result[i] = numbers[0..i].sum;\n    }\n    return result;\n}\n/*\n Calculate\
    \ the maximum (value, index) pair in array.\n    >>> max_pair([1L, 3L, 6L, 8L,\
    \ 11L, 15L, 17L])\n    (17L, 6)\n    \n*/\nTuple!(long, long) max_pair(long[]\
    \ a) \n{\n    return a.enumerate.max;\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyf9ki22u.d(73): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyf9ki22u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164042
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if\
    \ (numbers.length == 0)\n        return numbers;\n    return range(0, numbers.length).map!((i)\
    \ {\n        long max;\n        if (i == 0)\n            max = numbers[i];\n \
    \       else\n            max = max(numbers[i], numbers[i - 1]);\n        return\
    \ max;\n    }).array;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn0i4c6de.d(14): Error: undefined identifier `range`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn0i4c6de.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    enum\
    \ size_t N = numbers.length;\n    long[] result;\n    if (N == 0)\n    {\n   \
    \     return result;\n    }\n    else\n    {\n        result = new long[N];\n\
    \        result[0] = numbers[0];\n        for (size_t i = 1; i < N; i++)\n   \
    \     {\n            result[i] = max(result[i - 1], numbers[i]);\n        }\n\
    \        return result;\n    }\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1tmh06u1.d(12): Error: variable `numbers` cannot be read at compile
    time

    /tmp/tmp1tmh06u1.d(24): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1tmh06u1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif\
    \ (numbers.length == 0)\n\t\treturn numbers;\n\t// -- Create a sliding maximum\
    \ element\n\tauto prev_max = numbers[0];\n\tforeach (i, ref el; numbers)\n\t{\n\
    \t\tel = max(el, prev_max);\n\t\tprev_max = el;\n\t}\n\treturn numbers;\n}\n/*\n\
    \ Inplace sum of two arrays, which sizes are equal.\n*/\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4axw8v44.d(18): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4axw8v44.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \nin\n{\n\
    \    assert(numbers.length > 0);\n}\nbody \n{\n    auto result = new long[](numbers.length);\n\
    \    long maximum = numbers[0];\n    result[0] = maximum;\n    foreach (i, v;\
    \ numbers[1 .. $])\n    {\n        if (v > maximum)\n        {\n            maximum\
    \ = v;\n        }\n        result[i + 1] = maximum;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzynbe5dg.d(13): Assertion failure

    ----------------

    ??:? _d_assertp [0x4284d5]

    ??:? long[] tmpzynbe5dg.rolling_max(long[]) [0x427e6b]

    ??:? void tmpzynbe5dg.__unittest_L30_C1() [0x427f9a]

    ??:? void tmpzynbe5dg.__modtest() [0x428288]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b52a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430741]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b501]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(ch'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \n\
    \    \n    auto size = numbers.length;\n    long[] result;\n    auto current_max\
    \ = numbers[0];\n    result ~= current_max;\n    for(size_t i = 1; i < size; i++)\n\
    \    {\n        auto current_number = numbers[i];\n        if(current_number >\
    \ current_max)\n        {\n            current_max = current_number;\n       \
    \ }\n        result ~= current_max;\n    }\n    return result;\n    \n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpzo9dzy9y.d(16): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42856e]

    ??:? long[] tmpzo9dzy9y.rolling_max(long[]) [0x427e60]

    ??:? void tmpzo9dzy9y.__unittest_L30_C1() [0x427f4e]

    ??:? void tmpzo9dzy9y.__modtest() [0x42823c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cf2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bdbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430811]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43079d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bd95]

    ??:? runModuleUnitTests [0x42cd01]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, item; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i], item);\n\
    \    }\n    return result;\n}\n/*\n * From a given array of integers, generate\
    \ a count-min sketch.\n * >>> count_min_sketch([1L, 2L, 3L, 4L, 1L, 2L, 5L], 0.001,\
    \ 0.99)\n * CountMinSketch(0.001, 0.99, matrix([[0L, 1L, 0L, 0L, 0L, 0L, 0L],\
    \ [0L, 0L, 1L, 0L, 0L, 0L, 0L], [0L, 0L, 0L, 1L, 0L, 0L, 0L], [0L, 0L, 0L, 0L,\
    \ 1L, 0L, 0L], [1L, 0L, 0L, 0L, 0L, 0L, 0L], [0L, 1L, 0L, 0L, 0L, 0L, 0L], [0L,\
    \ 0L, 0L, 0L, 0L, 0L, 1L]]), [2L, 2L, 1L, 1L, 1L, 2L, 1L])\n *\n * It is a tuple\
    \ containing the epsilon and confidence values\n * of the algorithm, the matrix\
    \ of hashes, and the count of each\n * bucket.\n *\n * This is the same algorithm\
    \ as in the Python version, but adapted\n * to be used as a template.\n */\nCountMinSketch!(long)\
    \ count_min_sketch(long[] numbers, double epsilon, double confidence) \n{\n  \
    \  import std.range : empty;\n    import std.algorithm.iteration : minElement;\n\
    \    double delta = 1 - confidence;\n    int width = cast(int)(ceil(1 / epsilon));\n\
    \    int depth = cast(int)(ceil(log(1 / delta)));\n    int[][] hashes = new int[][](depth,\
    \ width);\n    //\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ko4ht03.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ko4ht03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if(!numbers.length)\n\
    \    {\n        return [];\n    }\n    long[] res = new long[numbers.length];\n\
    \    long max_num = numbers[0];\n    for(size_t i = 0; i < numbers.length; i++)\n\
    \    {\n        max_num = max(max_num, numbers[i]);\n        res[i] = max_num;\n\
    \    }\n    return res;\n}\n/*\n    Given an array of integers, generate an array\
    \ of sums of 2 elements in the order they were found.\n    >>> partial_sums([1L,\
    \ 2L, 3L, 4L, 5L])\n    [3L, 5L, 7L, 9L, 7L]\n    \n*/\nlong[] partial_sums(long[]\
    \ numbers) \n{\n    if(!numbers.length)\n    {\n        return [];\n    }\n  \
    \  long[] res = new long[numbers.length];\n    for(size_t i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(i == 0)\n        {\n            res[i] = numbers[i];\n\
    \        }\n        else\n        {\n            res[i] = res[i - 1] + numbers[i];\n\
    \        }\n    }\n    return res;\n}\n/*\n    Given an array of integers, generate\
    \ an array of sums of n consecutive elements in the order they were found.\n \
    \   >>> window_sums([1L, 2L, 3L, 4L, 5L], 1)\n    [1L, 2L, 3L, 4L, 5L]\n    >>>\
    \ window_sums([1L, 2L, 3L, 4L, 5L], 2)\n    [3L, 5L, 7L, 9L]\n    >>> window_sums([1L,\
    \ 2L, 3L, 4L, 5L], 3)\n    [6L, 9L, 12L]\n    >>> window_sums([1L, 2L, 3L, 4L,\
    \ 5L], 4)\n    [10L, 14L]\n    >>> window_sums([1L, 2L, 3L, 4L, 5L],\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpukduqvri.d(51): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpukduqvri.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ output = new long[numbers.length];\n    output[0] = numbers[0];\n    foreach\
    \ (i, n; numbers[1 .. $]) \n    {\n        output[i] = max(output[i - 1], n);\n\
    \    }\n    return output;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc9ao_lkx.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc9ao_lkx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[long[]]\
    \ result = new long[long[]](2);\n    long max_so_far = -_DFL_LONG_MAX;\n    long\
    \ n = numbers.length;\n    long i;\n    foreach(i; 0..n) \n    {\n        result.insert(max_so_far\
    \ = max(max_so_far, numbers[i]));\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling maximum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max2(long[]\
    \ numbers) \n{\n    long[long[]] result = new long[long[]](2);\n    long max_so_far\
    \ = -_DFL_LONG_MAX;\n    foreach(num; numbers) \n    {\n        result.insert(max_so_far\
    \ = max(max_so_far, num));\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling maximum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max3(long[] numbers)\
    \ \n{\n    long[long[]] result = new long[long[]](2);\n    long max_so_far = -_DFL_LONG_MAX;\n\
    \    foreach(num; numbers) \n    {\n        if(max_so_far < num) \n        {\n\
    \            max_so_far = num;\n        }\n        result.insert(max_so_far);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling maximum element found until given moment\n    in the sequence.\n\
    \    >>>\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg474z4ja.d(12): Error: need size of rightmost array, not type `long[]`

    /tmp/tmpg474z4ja.d(31): Error: need size of rightmost array, not type `long[]`

    /tmp/tmpg474z4ja.d(48): Error: need size of rightmost array, not type `long[]`

    /tmp/tmpg474z4ja.d(60): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg474z4ja.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_so_far = numbers[0];\n    return numbers.map!(number =>\n    {\n       \
    \ if (number > max_so_far)\n        {\n            max_so_far = number;\n    \
    \    }\n        return max_so_far;\n    });\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjavabcxo.d(13): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjavabcxo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in(numbers)\
    \ out(result) {\n    import std.algorithm;\n    auto result = new long[](numbers.length);\n\
    \    result[0] = numbers[0];\n    foreach(i; 1..numbers.length) {\n        result[i]\
    \ = max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnup8cu_x.d(10): Error: function `tmpnup8cu_x.rolling_max` `in`
    and `out` contracts can only appear without a body when they are virtual interface
    functions or abstract

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnup8cu_x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //@assert(numbers.length\
    \ > 0);\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    long currentMax = numbers[0];\n    foreach (i, x; numbers[1..$]) \n    {\n\
    \        if (x > currentMax) \n        {\n            currentMax = x;\n      \
    \  }\n        result[i + 1] = currentMax;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpv8ncgqlh.d(14): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428596]

    ??:? long[] tmpv8ncgqlh.rolling_max(long[]) [0x427e62]

    ??:? void tmpv8ncgqlh.__unittest_L26_C1() [0x427f7a]

    ??:? void tmpv8ncgqlh.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5c3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b456]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306e1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43066d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b42d]

    ??:? runModuleUnitTests [0x42c399]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\timport\
    \ std.algorithm;\n\treturn numbers.scan!(a => max(a, b => b))();\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviwuxl3t.d(13): Error: no property `scan` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviwuxl3t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ n = numbers.length;\n    if (n <= 1)\n        return numbers;\n    long[] result\
    \ = new long[n];\n    result[0] = numbers[0];\n    for (size_t i = 1; i < n; i++)\
    \ \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe1zkws9n.d(19): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe1zkws9n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\treturn\
    \ numbers.isEmpty ? \n\t\t\tnew long[](0) : \n\t\t\tnumbers.take(1) ~ take_while!(numbers[0]\
    \ >) ~ chain(repeat(numbers[0]))(numbers.drop(1));\n}\n/*\n    Return all tuples\
    \ of consecutive elements in the given array and their\n    corresponding indices.\
    \ Indices are 0-based.\n    >>> consecutive_tuples([1L, 2L, 3L, 5L, 6L, 7L, 8L])\n\
    \    [(1L, 2L, 0L, 1L), (2L, 3L, 1L, 2L), (5L, 6L, 3L, 4L), (6L, 7L, 4L, 5L),\
    \ (7L, 8L, 5L, 6L)]\n*/\nauto consecutive_tuples(long[] numbers) \n{\n\t// Check\
    \ if the resulting array is empty.\n\tif (numbers.length < 2)\n\t\treturn new\
    \ tuple!(long, long, long, long)[](0);\n\t// It should be implemented using zip.\n\
    \treturn numbers.drop(1).zip(numbers.dropRight(1)).zip(indices).map!(a => tuple(a[0][0],\
    \ a[0][1], a[1], a[1] + 1L));\n}\n/*\n    Return a copy of the given array with\
    \ the given item inserted at the given\n    index. The new item will be inserted\
    \ *after* the given index.\n    >>> insert_at(3L, [1L, 2L, 4L, 5L], 2L)\n    [1L,\
    \ 2L, 4L, 3L, 5L]\n*/\nlong[] insert_at(long item, long[] input, long index)\n\
    {\n\treturn input.take(index + 1L) ~ [item] ~ input.drop(index + 1L);\n}\n/*\n\
    \    Return a copy of the given array with the given item inserted at the given\n\
    \    index. The new item will be inserted *before* the given index.\n    >>> insert_at(3L,\
    \ [1L, 2L, 4L, 5L], 2L)\n    [1\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1nvxi0qm.d(14): Error: expression expected, not `)`

    /tmp/tmp1nvxi0qm.d(14): Error: found `;` when expecting `)` following template
    argument list

    /tmp/tmp1nvxi0qm.d(15): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmp1nvxi0qm.d(40): Error: unterminated /* */ comment

    /tmp/tmp1nvxi0qm.d(54): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1nvxi0qm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \nin \n{\n\
    \    if(numbers.length == 0) \n    {\n        return [];\n    }\n}\nout\n{\n \
    \   import std.math;\n    import std.algorithm;\n    import std.array;\n    import\
    \ std.range;\n    auto r = numbers.front;\n    foreach(i; 0 .. numbers.length)\
    \ \n    {\n        r ~= max(r.back, numbers[i]);\n    }\n    return r[1 .. $];\n\
    }\ndo \n{\n    import std.algorithm;\n    import std.array;\n    import std.range;\n\
    \    import std.typecons;\n    import std.math;\n    alias p = tuple!(long, long,\
    \ long);\n    auto r = [0L];\n    foreach(i; 1 .. numbers.length) \n    {\n  \
    \      if(numbers[i] > numbers[i - 1]) \n        {\n            r ~= numbers[i];\n\
    \        }\n        else \n        {\n            if(r.back > numbers[i]) \n \
    \           {\n                r ~= r.back;\n            }\n            else \n\
    \            {\n                r ~= numbers[i];\n            }\n        }\n \
    \   }\n    return r;\n}\n \n \n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \nin \n{\n    if(numbers.length\
    \ == 0) \n    {\n        return [];\n    }\n}\nout\n{\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ auto r = numbers.front;\n    foreach(i; 0 .. numbers.length) \n    {\n     \
    \   r ~= min(r.back, numbers[i]);\n    }\n    return r[1 .. $];\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpol31kblv.d(89): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpol31kblv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ res = new long[numbers.length];\n    for (long i = 0; i < numbers.length; i++)\n\
    \    {\n        res[i] = max(numbers[0..i+1]);\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbjpdjnbn.d(15): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbjpdjnbn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long[] nums = numbers.dup;\n    while\
    \ (nums.length) \n    {\n        result ~= nums.max;\n        nums = nums[1 ..\
    \ $];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwz4mrr2d.d(16): Error: no property `max` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwz4mrr2d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ current_max = numbers[0];\n    long[] max_elements = new long[numbers.length];\n\
    \    foreach (n; 0 .. numbers.length)\n    {\n        max_elements[n] = current_max;\n\
    \        if (numbers[n] > current_max)\n        {\n            current_max = numbers[n];\n\
    \        }\n    }\n    return max_elements;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpgobzh9ah.d(12): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42857e]

    ??:? long[] tmpgobzh9ah.rolling_max(long[]) [0x427e4b]

    ??:? void tmpgobzh9ah.__unittest_L24_C1() [0x427f5e]

    ??:? void tmpgobzh9ah.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ r = numbers[];\n    foreach( i, n; numbers[1..$]) \n    {\n        r ~= max(n,\
    \ r[$-1]);\n    }\n    return r;\n}\n \n/*\n What will be printed out by the following\
    \ code?\n    void main() {\n        int[int] m;\n        m[0] = 7;\n        m[1]\
    \ = 9;\n        int[int] n = m;\n        n[0] = 6;\n        writefln(\"%d %d\"\
    , m[0], n[0]);\n    }\n    6 6\n*/\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpib3em4lm.d(15): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpib3em4lm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\timmutable\
    \ long[] max_so_far = new long[0];\n\timmutable long max = numbers[0];\n\tforeach(number;\
    \ numbers)\n\t{\n\t\tif(number > max)\n\t\t{\n\t\t\tmax = number;\n\t\t}\n\t\t\
    max_so_far ~= max;\n\t}\n\treturn max_so_far;\n}\n/*\nGiven an array of n distinct\
    \ elements, find all unique triplets (three numbers, a, b, c) in array \nsuch\
    \ that a + b + c = 0\n    >>> find_triplets([-1L, 0L, 1L, 2L, -1L, -4L])\n   \
    \ [[-1L, -1L, 2L], [-1L, 0L, 1L]]\n*/\nlong[][] find_triplets(long[] numbers)\n\
    {\n\tauto result = new long[][](0);\n\tfor(immutable long i = 0; i < numbers.length;\
    \ i++)\n\t{\n\t\tfor(immutable long j = i + 1; j < numbers.length; j++)\n\t\t\
    {\n\t\t\tfor(immutable long k = j + 1; k < numbers.length; k++)\n\t\t\t{\n\t\t\
    \t\tif(numbers[i] + numbers[j] + numbers[k] == 0)\n\t\t\t\t{\n\t\t\t\t\tresult\
    \ ~= [numbers[i], numbers[j], numbers[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\
    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyziloib9.d(18): Error: cannot modify `immutable` expression `max`

    /tmp/tmpyziloib9.d(20): Error: cannot modify `immutable` expression `max_so_far`

    /tmp/tmpyziloib9.d(22): Error: cannot implicitly convert expression `max_so_far`
    of type `immutable(long[])` to `long[]`

    /tmp/tmpyziloib9.d(33): Error: cannot modify `immutable` expression `0L`

    /tmp/tmpyziloib9.d(35): Error: cannot modify `immutable` expression `1L`

    /tmp/tmpyziloib9.d(37): Error: cannot modify `immutable` expression `2L`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyziloib9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ result = new long[numbers.length];\n\tlong current_max = numbers[0];\n\tresult[0]\
    \ = current_max;\n\tforeach(i, n; numbers[1..$]) \n\t{\n\t\tif (n > current_max)\n\
    \t\t{\n\t\t\tcurrent_max = n;\n\t\t}\n\t\tresult[i + 1] = current_max;\n\t}\n\t\
    return result;\n}\nlong rolling_sum(long[] numbers) \n{\n\tlong result = 0;\n\t\
    foreach(n; numbers) \n\t{\n\t\tresult += n;\n\t}\n\treturn result;\n}\nlong rolling_max(long[]\
    \ numbers) \n{\n\tlong result = numbers[0];\n\tforeach(n; numbers) \n\t{\n\t\t\
    if (n > result)\n\t\t{\n\t\t\tresult = n;\n\t\t}\n\t}\n\treturn result;\n}\nlong\
    \ rolling_min(long[] numbers) \n{\n\tlong result = numbers[0];\n\tforeach(n; numbers)\
    \ \n\t{\n\t\tif (n < result)\n\t\t{\n\t\t\tresult = n;\n\t\t}\n\t}\n\treturn result;\n\
    }\nclass Piece \n{\n\t// Locations of all indexes\n\tsize_t[] indexes;\n\t// Size\
    \ of the piece.\n\tsize_t size;\n\t// Number of cells left to fill by this piece\n\
    \tlong[] pieces_left;\n\t// Number of cells which were filled by this piece\n\t\
    long[] pieces_done;\n\tlong[] pieces_max;\n\tlong[] pieces_sum;\n\t\n\t/*\n\t\t\
    Return amount of possible ways to fill the pattern.\n\t\t\n\t\tArgs:\n\t\t\tcapacity:\
    \ Amount of cells which can be filled in a row.\n\t\t\t\n\t\tReturns:\n\t\t\t\
    Amount of possible ways to fill the pattern.\n\t*/\n\tlong get_possibilities(size_t\
    \ capacity)\n\t{\n\t\tlong temp = 0;\n\t\t\n\t\tif (pieces_max[0] > capacity)\n\
    \t\t{\n\t\t\treturn 0\nunittest\n{\n    alias candidate = rolling_max;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvt20uf3l.d(87): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpvt20uf3l.d(96): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpvt20uf3l.d(96): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpvt20uf3l.d(96): Error: `}` expected following members in `class` declaration
    at /tmp/tmpvt20uf3l.d(58)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvt20uf3l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    struct\
    \ rmax {\n        long[] buffer;\n        size_t position;\n        property inout(long)\
    \ max() inout {\n            return buffer[$-1];\n        }\n        void update(long\
    \ value) {\n            if (buffer.length < position + 1) \n            {\n  \
    \              buffer ~= value;\n            }\n            else \n          \
    \  {\n                buffer[$-1] = max(buffer[$-1], value);\n            }\n\
    \            position += 1;\n        }\n    }\n    auto result = new long[];\n\
    \    auto r = rmax(result);\n    foreach (n; numbers) \n    {\n        r.update(n);\n\
    \        result ~= r.max;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxudlkx9_.d(15): Error: no identifier for declarator `property`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxudlkx9_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \
    \ auto result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i], number);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling cumulative sum of element found in the\n    sequence.\n   \
    \ >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L,\
    \ 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n     auto result = new\
    \ long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1..$]) \n    {\n        result[i + 1] = result[i] + number;\n    }\n\
    \    return result;\n}\n/*\n Compute number of prime numbers below a certain limit.\n\
    \    \n*/\nlong compute_prime_numbers(long limit) \n{\n    long[] is_prime = new\
    \ long[limit];\n    is_prime[0..limit] = 1;\n    long prime_numbers = 0;\n   \
    \ foreach (i; 1..limit + 1) \n    {\n        if (is_prime[i - 1] == 1) \n    \
    \    {\n            prime_numbers += 1;\n            foreach (j; i * i..limit\
    \ + 1; i) \n            {\n                is_prime[j - 1] = 0;\n            }\n\
    \        }\n    }\n    return prime_numbers;\n}\n/*\n Compute a matrix of dot\
    \ product of given two matrices.\n    >>> dot_product([[1, 2], [3, 4]], [[1, 0],\
    \ [0, 1]])\n    [[1, 2], [3, 4]]\n    \n*/\nlong[][] dot_product(long[][] matrix_a,\
    \ long[][] matrix_b) \n{\n    long[][] result = new long[matrix_a.length][mat\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp05bz0nuw.d(51): Error: found `;` when expecting `)`

    /tmp/tmp05bz0nuw.d(51): Error: found `)` when expecting `;` following statement

    /tmp/tmp05bz0nuw.d(68): Error: found `unittest` when expecting `]`

    /tmp/tmp05bz0nuw.d(69): Error: semicolon expected, not `{`

    /tmp/tmp05bz0nuw.d(77): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp05bz0nuw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[];\n    long max = 0;\n    foreach(num; numbers)\n    {\n\
    \        max = max(max, num);\n        result ~= max;\n    }\n    return result;\n\
    }\n/*\n    2.a. Given a sequence of numbers, check if it is acyclic.\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbze7ndrl.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbze7ndrl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    static\
    \ struct Buffer\n    {\n        long[] data;\n        void* p;\n        size_t\
    \ size;\n        size_t capacity;\n    }\n    /*\n    Initialize buffer\n    */\n\
    \    auto init_buffer(size_t capacity)\n    {\n        Buffer result;\n      \
    \  result.capacity = capacity;\n        result.size = 0;\n        result.data\
    \ = new long[capacity];\n        result.p = result.data.ptr;\n        return result;\n\
    \    }\n    /*\n    Release buffer\n    */\n    void release_buffer(ref Buffer\
    \ b)\n    {\n        b.data.ptr = null;\n        b.p = null;\n        b.size =\
    \ 0;\n        b.capacity = 0;\n    }\n    /*\n    Push number to buffer.\n   \
    \ If capacity is not enough to store new value, new buffer is created\n    */\n\
    \    bool push_buffer(ref Buffer b, long value)\n    {\n        if (b.size ==\
    \ b.capacity)\n        {\n            size_t new_capacity = b.capacity * 2;\n\
    \            long[] new_data = new long[new_capacity];\n            new_data[0..b.size]\
    \ = b.data[0..b.size];\n            release_buffer(b);\n            b = init_buffer(new_capacity);\n\
    \            b.data = new_data;\n            b.p = b.data.ptr;\n        }\n  \
    \      b.data[b.size] = value;\n        b.size++;\n        return true;\n    }\n\
    \    /*\n    Fills output with rolling maxima numbers.\n    Returns false if any\
    \ error occured.\n    */\n    bool calculate_rolling_max(long[] input, long[]\
    \ output)\n    {\n        Buffer buffer = init_buffer(128);\n        long max\
    \ = input[0];\n        output[0] = max;\n        push_buffer(buffer, 0);\n   \
    \     for (size_t i = 1; i < input.length; i++)\n        {\n            if (input[i]\
    \ > max)\n            {\n                max = input[i];\n                output[i]\
    \ = max;\n                buffer.size = 0;\n\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq4awpya7.d(79): Error: found `unittest` instead of statement

    /tmp/tmpq4awpya7.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpq4awpya7.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpq4awpya7.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4awpya7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.algorithm.comparison : max;\n    import std.algorithm.iteration : scan,\
    \ dropOne;\n    import std.typecons : tuple;\n    // auto maxNumbers = numbers.scan!(max)(tuple(0L,\
    \ 0L)).dropOne;\n    auto maxNumbers = numbers.scan!(max)(tuple(0L, 0L));\n  \
    \  return maxNumbers.map!(t => t[1]).dropOne;\n}\nlong[] find_max_sliding_window(long[]\
    \ inputArray, size_t windowSize) \n{\n    if (windowSize > inputArray.length)\
    \ \n    {\n        return new long[](0);\n    }\n    auto result = new long[](inputArray.length\
    \ - windowSize + 1);\n    foreach (i, j; 0 .. result.length) \n    {\n       \
    \ result[i] = inputArray[i .. i + windowSize].max;\n    }\n    return result;\n\
    }\n/*\n    Given an array of integers, find the maximum sum of consecutive elements\
    \ in the array.\n    >>> find_max_sum_subarray([1L, 2L, 3L, 2L, 5L, 2L, 1L])\n\
    \    [2L, 5L, 2L]\n*/\nlong[] find_max_sum_subarray(long[] array) \n{\n    import\
    \ std.algorithm.comparison : max;\n    import std.algorithm.iteration : scan,\
    \ dropOne;\n    import std.typecons : tuple;\n    auto maxNumbers = array.scan!(max)(tuple(0L,\
    \ 0L));\n    return maxNumbers.map!(t => t[1]).dropOne;\n}\n/*\n    Given an array\
    \ of integers and a number k, find maximum sum of a subarray of size k.\n    >>>\
    \ find_max_subarray_sum([1L, 2L, 3L, 2L, 5L, 2L, 1L], 3)\n    10L\n*/\nlong find_max_subarray_sum(long[]\
    \ array, size_t k) \n{\n    import std.algorithm.comparison : max;\n    import\
    \ std.algorithm.iter\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz7vfknhc.d(26): Error: found `..` when expecting `)`

    /tmp/tmpz7vfknhc.d(26): Error: found `)` when expecting `;` following statement

    /tmp/tmpz7vfknhc.d(54): Error: `;` expected

    /tmp/tmpz7vfknhc.d(63): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz7vfknhc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ ret = new long[numbers.length];\n\tlong max = numbers[0];\n\tret[0] = max;\n\
    \tfor (int i = 1; i < numbers.length; i++)\n\t{\n\t\tif (numbers[i] > max)\n\t\
    \t{\n\t\t\tmax = numbers[i];\n\t\t}\n\t\tret[i] = max;\n\t}\n\treturn ret;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpk6jid_af.d(13): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428586]

    ??:? long[] tmpk6jid_af.rolling_max(long[]) [0x427e62]

    ??:? void tmpk6jid_af.__unittest_L25_C1() [0x427f66]

    ??:? void tmpk6jid_af.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long currentMax = numbers[0];\n    result[0]\
    \ = currentMax;\n    foreach (i, num; numbers[1..$]) \n    {\n        if (num\
    \ > currentMax)\n        {\n            currentMax = num;\n        }\n       \
    \ result[i + 1] = currentMax;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpc2drjsge.d(13): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42857e]

    ??:? long[] tmpc2drjsge.rolling_max(long[]) [0x427e62]

    ??:? void tmpc2drjsge.__unittest_L25_C1() [0x427f5e]

    ??:? void tmpc2drjsge.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto\
    \ max_until_now = Array!long();\n  max_until_now ~= numbers[0];\n  for (size_t\
    \ i = 1; i < numbers.length; i++) \n  {\n    max_until_now ~= max(max_until_now[$\
    \ - 1], numbers[i]);\n  }\n  return max_until_now;\n}\nlong[] rolling_max2(long[]\
    \ numbers) \n{\n  import std.algorithm.comparison : max;\n  return reduce!((a,\
    \ b) => [a[$ - 1].max(b)])(numbers);\n}\nlong[] rolling_max3(long[] numbers) \n\
    {\n  auto max_until_now = Array!long();\n  max_until_now ~= numbers[0];\n  foreach\
    \ (n; numbers[1 .. $]) \n  {\n    max_until_now ~= max(max_until_now[$ - 1], n);\n\
    \  }\n  return max_until_now;\n}\nlong[] rolling_max4(long[] numbers) \n{\n  return\
    \ scan!((a, b) => max(a, b))(numbers);\n}\nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphy3bdg27.d(12): Error: template instance `Array!long` template
    `Array` is not defined

    /tmp/tmphy3bdg27.d(16): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmphy3bdg27.d(23): Error: template instance `reduce!((a, b) => [a[__dollar
    - 1].max(b)])` template `reduce` is not defined

    /tmp/tmphy3bdg27.d(27): Error: template instance `Array!long` template `Array`
    is not defined

    /tmp/tmphy3bdg27.d(31): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmphy3bdg27.d(37): Error: template instance `scan!((a, b) => max(a, b))`
    template `scan` is not defined, did you mean tan?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphy3bdg27.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    return\
    \ __rmd2.rolling_max(numbers);\n}\nlong[][] rolling_max_array(long[][] numbers)\
    \ \n{\n    return __rmd3.rolling_max_array(numbers);\n}\nlong[][][] rolling_max_array(long[][][]\
    \ numbers) \n{\n    return __rmd4.rolling_max_array(numbers);\n}\nlong[][][][]\
    \ rolling_max_array(long[][][][] numbers) \n{\n    return __rmd5.rolling_max_array(numbers);\n\
    }\nlong[][][][][] rolling_max_array(long[][][][][] numbers) \n{\n    return __rmd6.rolling_max_array(numbers);\n\
    }\n/*\n From a given array of integers, generate an array of rolling maximum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n*/\ndouble[] rolling_max(double[]\
    \ numbers) \n{\n    return __rmd2.rolling_max(numbers);\n}\ndouble[][] rolling_max_array(double[][]\
    \ numbers) \n{\n    return __rmd3.rolling_max_array(numbers);\n}\ndouble[][][]\
    \ rolling_max_array(double[][][] numbers) \n{\n    return __rmd4.rolling_max_array(numbers);\n\
    }\ndouble[][][][] rolling_max_array(double[][][][] numbers) \n{\n    return __rmd5.rolling_max_array(numbers);\n\
    }\ndouble[][][][][] rolling_max_array(double[][][][][] numbers) \n{\n    return\
    \ __rmd6.rolling_max_array(numbers);\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3,\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj2ooey6q.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj2ooey6q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if(!numbers.length)\n\
    \        return numbers;\n    \n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    for(long i = 1L; i < numbers.length; i++) \n\
    \    {\n        result[i] = max(result[i - 1L], numbers[i]);\n    }\n    return\
    \ result;\n}\n \n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    if(!numbers.length)\n        return numbers;\n\
    \    \n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    for(long i = 1L; i < numbers.length; i++) \n    {\n        result[i] = min(result[i\
    \ - 1L], numbers[i]);\n    }\n    return result;\n}\n \n/*\n From a given array\
    \ of integers, generate an array of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    if(!numbers.length)\n        return numbers;\n    \n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    for(long i = 1L;\
    \ i < numbers.length; i++) \n    {\n        result[i] = result[i - 1L] + numbers[i];\n\
    \    }\n    return result;\n}\n \n/*\n From a given array of integers, generate\
    \ an array of rolling product of elements found until given moment\n    in the\
    \ sequence.\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo5q03okk.d(66): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo5q03okk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto\
    \ result = new long[];\n  result ~= numbers[0];\n  foreach(i; 1 .. numbers.length)\
    \ \n  {\n    result ~= max(result[$-1], numbers[i]);\n  }\n  return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp99cg8v5v.d(12): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp99cg8v5v.d(16): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp99cg8v5v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long current_max = numbers[0];\n   \
    \ for (size_t i = 0; i < numbers.length; i++)\n    {\n        result[i] = max(current_max,\
    \ numbers[i]);\n        current_max = result[i];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2rz5ayq4.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2rz5ayq4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long current_max = numbers[0];\n   \
    \ result[0] = current_max;\n    foreach (i, e; numbers[1 .. $]) \n    {\n    \
    \    current_max = max(current_max, e);\n        result[i + 1] = current_max;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpky07m21c.d(17): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpky07m21c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    // TODO: implement\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw5j23lm4.d(21): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283cd]

    ??:? void tmpw5j23lm4.__unittest_L16_C1() [0x427f4d]

    ??:? void tmpw5j23lm4.__modtest() [0x42814c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c437]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2ca]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430555]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a04]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2a1]

    ??:? runModuleUnitTests [0x42c20d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ result = new long[numbers.length];\n\tresult[0] = numbers[0];\n\tfor (int i\
    \ = 1; i < numbers.length; i++)\n\t{\n\t\tresult[i] = max(result[i - 1], numbers[i]);\n\
    \t}\n\treturn result;\n}\n/*\n From a given array of numbers, generate a new array\
    \ where each value is the\n sum of values from the original array up to and including\
    \ it.\n    >>> cumsum([1L, 1L, 1L, 1L, 1L])\n    [1L, 2L, 3L, 4L, 5L]\n*/\nlong[]\
    \ cumsum(long[] numbers) \n{\n\tlong[] result = new long[numbers.length];\n\t\
    result[0] = numbers[0];\n\tfor (int i = 1; i < numbers.length; i++)\n\t{\n\t\t\
    result[i] = result[i - 1] + numbers[i];\n\t}\n\treturn result;\n}\nlong[] cumsum_foreach(long[]\
    \ numbers) \n{\n\tlong[] result = new long[numbers.length];\n\tresult[0] = numbers[0];\n\
    \tint i = 1;\n\tforeach (ref long number; numbers[1 .. $])\n\t{\n\t\tresult[i]\
    \ = result[i - 1] + number;\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw1x70csp.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw1x70csp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\t//\
    \ Type tuple is used to bind the two variables\n\t// first one is the element\
    \ and the second one is the max \n\t// of the sequence till that point.\n\t//\
    \ Since we want to update the max each time we iterate,\n\t// we keep the max\
    \ of the sequence in the second element\n\t// and update it when necessary.\n\t\
    auto tuple = tuple(numbers[0], numbers[0]);\n\tlong[] arr = new long[];\n\tforeach(el;\
    \ numbers)\n\t{\n\t\ttuple[1] = max(tuple[1], el);\n\t\tarr ~= tuple[1];\n\t}\n\
    \treturn arr;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgms02fs7.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpgms02fs7.d(22): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgms02fs7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto\
    \ result = new long[](numbers.length);\n  auto current_max = numbers[0];\n  foreach\
    \ (i, ref e; numbers)\n  {\n    if (e > current_max)\n    {\n      current_max\
    \ = e;\n    }\n    result[i] = current_max;\n  }\n  return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpmecwhu7a.d(13): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42853e]

    ??:? long[] tmpmecwhu7a.rolling_max(long[]) [0x427e62]

    ??:? void tmpmecwhu7a.__unittest_L24_C1() [0x427f22]

    ??:? void tmpmecwhu7a.__modtest() [0x428210]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c56b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3fe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430689]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b38]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430615]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d5]

    ??:? runModuleUnitTests [0x42c341]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ result = new long[numbers.length];\n\t\n\tlong max = numbers[0];\n\tfor(int\
    \ i = 0; i < numbers.length; i++) \n\t{\n\t\tif(max < numbers[i]) \n\t\t{\n\t\t\
    \tmax = numbers[i];\n\t\t}\n\t\tresult[i] = max;\n\t}\n\treturn result;\n}\n \n\
    /*\n    from a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n\tlong[] result = new long[numbers.length];\n\t\n\tlong min =\
    \ numbers[0];\n\tfor(int i = 0; i < numbers.length; i++) \n\t{\n\t\tif(min > numbers[i])\
    \ \n\t\t{\n\t\t\tmin = numbers[i];\n\t\t}\n\t\tresult[i] = min;\n\t}\n\treturn\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpijsskwam.d(14): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4286ae]

    ??:? long[] tmpijsskwam.rolling_max(long[]) [0x427ea2]

    ??:? void tmpijsskwam.__unittest_L47_C1() [0x42808e]

    ??:? void tmpijsskwam.__modtest() [0x42837c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b56e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307f9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430ca8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430785]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b545]

    ??:? runModuleUnitTests [0x42c4b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    size_t\
    \ i = 1;\n    while (i < numbers.length) \n    {\n        result[i] = max(result[i\
    \ - 1], numbers[i]);\n        i++;\n    }\n    return result;\n}\n//\nlong[] rolling_max(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    auto cumulative_max\
    \ = numbers[0];\n    size_t i = 0;\n    while (i < numbers.length) \n    {\n \
    \       cumulative_max = max(cumulative_max, numbers[i]);\n        result[i] =\
    \ cumulative_max;\n        i++;\n    }\n    return result;\n}\n//\nlong[] rolling_max(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] =\
    \ numbers[0];\n    foreach (i, x; numbers[1 .. $]) \n    {\n        result[i]\
    \ = max(result[i - 1], x);\n    }\n    return result;\n}\n//\nlong[] rolling_max(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    foreach (i,\
    \ x; numbers[1 .. $]) \n    {\n        result[i] = max(result[i - 1], x);\n  \
    \  }\n    return result;\n}\n//\nlong[] rolling_max(long[] numbers) \n{\n    return\
    \ new long[numbers.length]\n    {\n        reduce!(max)(numbers[0 .. i])\n   \
    \     foreach(i; 0 .. numbers.length)\n    };\n}\n//\nlong[] rolling_max(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    foreach (i,\
    \ x; numbers[1 .. $]) \n    {\n        result[i] = max(result[i - 1], x);\n  \
    \  }\n    return result;\n}\n//\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result =\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjw9cdoq5.d(61): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmpjw9cdoq5.d(63): Error: found `foreach` when expecting `;` following statement

    /tmp/tmpjw9cdoq5.d(63): Error: found `;` when expecting `)`

    /tmp/tmpjw9cdoq5.d(63): Error: found `0` when expecting `;` following statement

    /tmp/tmpjw9cdoq5.d(63): Error: found `..` instead of statement

    /tmp/tmpjw9cdoq5.d(65): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjw9cdoq5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    if (numbers.length > 0) \n    {\n  \
    \      long maxValue = numbers[0];\n        result[0] = maxValue;\n        foreach\
    \ (int index, long value; numbers[1 .. $]) \n        {\n            if (value\
    \ > maxValue)\n                maxValue = value;\n            result[index + 1]\
    \ = maxValue;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (long\
    \ i = 1; i < numbers.length; i++)\n    {\n        result[i] = max(result[i - 1],\
    \ numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp01_weqlg.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp01_weqlg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int\
    \ i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i -\
    \ 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwi7sf92g.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwi7sf92g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\nunittest\n{\n   \
    \ alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg3d_i7mt.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg3d_i7mt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.stdio;\n    import std.algorithm;\n    static struct rolling_max_s \n  \
    \  {\n        long value;\n        size_t index;\n        @property bool opEquals(const\
    \ ref rolling_max_s rhs) \n        {\n            return value == rhs.value;\n\
    \        }\n        @property bool opCmp(const ref rolling_max_s rhs) \n     \
    \   {\n            return value > rhs.value;\n        }\n    }\n    const rolling_max_s[]\
    \ max_stack = numbers.map!(n => rolling_max_s(n, 0));\n    long[] result = new\
    \ long[numbers.length];\n    foreach (ref r, const i; zip(result, max_stack))\
    \ \n    {\n        r = max_stack.take(i).max.value;\n    }\n    return result;\n\
    }\n/*\n Given a string containing only the characters '(', ')', '{', '}', '['\
    \ and ']', determine if the input string is valid.\n The brackets must close in\
    \ the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\"\
    \ are not.\n \n    >>> is_valid_parentheses(\"()\")\n    true\n    \n    >>> is_valid_parentheses(\"\
    ()[]{}\")\n    true\n    \n    >>> is_valid_parentheses(\"(]\")\n    false\n \
    \   \n    >>> is_valid_parentheses(\"([)]\")\n    false\n*/\nunittest\n{\n   \
    \ alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp_5lmy5w.d(27): Error: cannot implicitly convert expression `map(numbers)`
    of type `MapResult!(__lambda3, long[])` to `const(rolling_max_s[])`

    /tmp/tmpp_5lmy5w.d(29): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp_5lmy5w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.range;\n    return numbers.zip(numbers.scan!((a, b) => max(a, b)));\n}\n\
    \ \n \n \n \n/*\nGiven two arrays of integers, find the intersection.\n    >>>\
    \ intersection([1L, 2L, 3L, 4L], [3L, 4L, 5L, 6L])\n    [3L, 4L]\n*/\nlong[] intersection(long[]\
    \ a, long[] b) \n{\n    import std.algorithm.comparison : equal;\n    import std.algorithm.iteration\
    \ : remove;\n    import std.algorithm.sorting : sort;\n    import std.container.array\
    \ : array;\n    import std.range : uniq;\n    return a.sort.uniq.array.remove!(i\
    \ => !(equal(i, b))).sort.uniq.array;\n}\n \n \n \n \n/*\nRemove duplicates from\
    \ a sequence.\n    >>> remove_duplicates([1L, 2L, 3L, 3L, 4L, 4L, 4L, 5L])\n \
    \   [1L, 2L, 3L, 4L, 5L]\n*/\nlong[] remove_duplicates(long[] a) \n{\n    import\
    \ std.algorithm.iteration : remove;\n    import std.container.array : array;\n\
    \    import std.range : uniq;\n    return a.uniq.array;\n}\n \n \n \n \n/*\nRemove\
    \ zeros from a sequence.\n    >>> remove_zeros([1L, 2L, 0L, 3L, 0L, 4L, 0L, 5L])\n\
    \    [1L, 2L, 3L, 4L, 5L]\n*/\nlong[] remove_zeros(long[] a) \n{\n    import std.algorithm.iteration\
    \ : remove;\n    import std.container.array : array;\n    return a.remove!(i =>\
    \ i == 0).array;\n}\n \n \n \n \n/*\n Remove elements from a given sequence that\
    \ are divisible by 3.\n    >>> remove_divisible_by_3([1L, 2L,\nunittest\n{\n \
    \   alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr_r2oj_5.d(68): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr_r2oj_5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ result;\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp18_lcv9u.d(13): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp18_lcv9u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in(numbers.length\
    \ > 0) \n    out(result.length == numbers.length) \n    body\n{\n    enum n =\
    \ numbers.length;\n    auto result = new long[](n);\n    result[0] = numbers[0];\n\
    \    foreach (idx; 1 .. n) \n    {\n        result[idx] = max(result[idx - 1],\
    \ numbers[idx]);\n    }\n    return result;\n}\n \n/*\n Generate the answer given\
    \ an array of rolling maximum elements and a query.\n    >>> answer([1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L], tuple(1, 4))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L], tuple(2, 4))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(3,\
    \ 4))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(1, 5))\n   \
    \ 3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(2, 5))\n    3L\n    >>>\
    \ answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(3, 5))\n    3L\n    >>> answer([1L,\
    \ 2L, 3L, 3L, 3L, 4L, 4L], tuple(4, 5))\n    3L\n    >>> answer([1L, 2L, 3L, 3L,\
    \ 3L, 4L, 4L], tuple(5, 5))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L],\
    \ tuple(1, 6))\n    4L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(2,\
    \ 6))\n    4L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L,\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76onc8js.d(12): Error: found `.` when expecting `)`

    /tmp/tmp76onc8js.d(12): Error: statement expected to be `{ }`, not `length`

    /tmp/tmp76onc8js.d(12): Error: found `)` when expecting `;` following statement

    /tmp/tmp76onc8js.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76onc8js.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in (numbers.length)\
    \ out (result)\n    body\n    {\n        long[] result;\n        auto n = numbers.length;\n\
    \        foreach (i; 0 .. n) {\n            if (i == 0)\n                result\
    \ ~= numbers[i];\n            else\n                result ~= max(result[$-1],\
    \ numbers[i]);\n        }\n        return result;\n    }\n/*\n Given an array\
    \ of integers, generate an array of rolling maximum integer found until given\
    \ moment\n    in the sequence, given that the number is smaller than the previous\
    \ one.\n    >>> rolling_max_if_less([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_max_if_less(long[] numbers) \n    in\
    \ (numbers.length) out (result)\n    body\n    {\n        long[] result;\n   \
    \     auto n = numbers.length;\n        foreach (i; 0 .. n) {\n            if\
    \ (i == 0)\n                result ~= numbers[i];\n            else if (numbers[i]\
    \ < result[$-1])\n                result ~= numbers[i];\n            else\n  \
    \              result ~= result[$-1];\n        }\n        return result;\n   \
    \ }\n/*\n Given an array of integers, generate an array of rolling maximum integer\
    \ found until given moment\n    in the sequence, given that the number is smaller\
    \ than the previous one.\n    >>> rolling_max_if_less([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_max_if_less(long[]\
    \ numbers) \n    in (numbers.length) out (result)\n    body\n    {\n        long[]\
    \ result;\n        auto n = numbers.length;\n        foreach (i; 0 .. n) {\n \
    \           if (i == 0)\n                result ~= numbers[i];\n            else\
    \ if (numbers[i] < result[$-1])\n               \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd0w_lkwm.d(12): Error: statement expected to be `{ }`, not `body`

    /tmp/tmpd0w_lkwm.d(13): Error: found `{` when expecting `;` following statement

    /tmp/tmpd0w_lkwm.d(16): Error: declaration expected, not `foreach`

    /tmp/tmpd0w_lkwm.d(16): Error: declaration expected, not `0`

    /tmp/tmpd0w_lkwm.d(19): Error: declaration expected, not `else`

    /tmp/tmpd0w_lkwm.d(21): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd0w_lkwm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return\
    \ numbers;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    return numbers;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling mean value found until given moment\n\
    \    in the sequence.\n    >>> rolling_mean([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n  \
    \  [1.0, 1.5, 2.0, 2.0, 2.5, 3.0, 2.857142857142857]\n    \n*/\ndouble[] rolling_mean(long[]\
    \ numbers) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    return numbers;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling standard deviation value found until given moment\n    in\
    \ the sequence.\n    >>> rolling_stddev([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [0.0,\
    \ 0.5, 0.816496580927726, 0.47140452079103173, 0.6123724356957945, 0.816496580927726,\
    \ 0.7249544498480476]\n    \n*/\ndouble[] rolling_stddev(long[] numbers) \n{\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return\
    \ numbers;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ sum of squares found until given moment\n    in the sequence.\n    >>> rolling_sum_of_squ\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsubwkmdm.d(95): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsubwkmdm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max;\n    long[] rollingMaxes;\n    //  max = maxElement(numbers.dup);\n   \
    \ max = numbers[0];\n    rollingMaxes = new long[numbers.length];\n    for (long\
    \ i = 0; i < numbers.length; i++)\n    {\n        max = std.math.max(max, numbers[i]);\n\
    \        rollingMaxes[i] = max;\n    }\n    return rollingMaxes;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpty53x3n8.d(19): Error: undefined identifier `max` in module `std.math`,
    did you mean function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpty53x3n8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //\
    \ FIXME: use std.algorithm.move;\n    import std.array;\n    import std.algorithm;\n\
    \    long[] res = new long[numbers.length];\n    auto m = max(numbers[0], 0L);\n\
    \    for (size_t i = 0; i < numbers.length; i++)\n    {\n        res[i] = m;\n\
    \        m = max(m, numbers[i]);\n    }\n    return res;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    import std.array;\n    import std.algorithm;\n    long[] res = new\
    \ long[numbers.length];\n    auto m = min(numbers[0], 0L);\n    for (size_t i\
    \ = 0; i < numbers.length; i++)\n    {\n        res[i] = m;\n        m = min(m,\
    \ numbers[i]);\n    }\n    return res;\n}\n//https://codegolf.stackexchange.com/questions/48340/help-me-with-these-little-totals\n\
    long[] rolling_totals(long[] numbers) \n{\n    import std.array;\n    import std.algorithm;\n\
    \    long[] res = new long[numbers.length];\n    auto m = numbers[0];\n    for\
    \ (size_t i = 0; i < numbers.length; i++)\n    {\n        res[i] = m;\n      \
    \  m += numbers[i];\n    }\n    return res;\n}\n/*\nFind the index of the largest\
    \ element in the array.\nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprymy5j4m.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprymy5j4m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto\
    \ result = new long[numbers.length];\n  long current_max = long.min;\n  for (size_t\
    \ i = 0; i < numbers.length; i++) \n  {\n    current_max = max(current_max, numbers[i]);\n\
    \    result[i] = current_max;\n  }\n  return result;\n}\n \n \n/*\n Given arrays\
    \ of elements a, b, and a query array q of integer\n    indices, find for each\
    \ query element q[i] the maximum value found\n    in a between the indices b[i]\
    \ and q[i] inclusive.\n    >>> a = [1L, 2L, 3L, 4L, 5L]\n    >>> b = [0L, 0L,\
    \ 0L, 3L, 3L, 3L, 3L]\n    >>> q = [1L, 2L, 3L, 0L, 1L, 2L, 3L, 4L, 5L]\n    >>>\
    \ max_in_slice(a, b, q)\n    [2L, 3L, 4L, 4L, 4L, 4L, 5L, 5L, 5L]\n    \n    \n\
    \    Given arrays of elements a, b, and a query array q of integer\n    indices,\
    \ find for each query element q[i] the maximum value found\n    in a between the\
    \ indices b[i] and q[i] inclusive.\n    >>> a = [2L, 3L, 4L, 5L, 6L]\n    >>>\
    \ b = [0L, 0L, 0L, 3L, 3L, 3L, 3L]\n    >>> q = [1L, 2L, 3L, 0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> max_in_slice(a, b, q)\n    [3L, 4L, 5L, 5L, 5L, 5L, 6L, 6L, 6L]\n\
    \    \n    \n    Given arrays of elements a, b, and a query array q of integer\n\
    \    indices, find for each query element q[i] the maximum value found\n    in\
    \ a between the indices b[i] and q[i] inclusive.\n    >>> a =\nunittest\n{\n \
    \   alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpab7h7o4p.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpab7h7o4p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ out = new long[$];\n    auto rollingMax = new long[$];\n    auto numbersLength\
    \ = numbers.length;\n    auto k = $;\n    foreach (i, e; numbers) \n    {\n  \
    \      rollingMax[i % k] = e;\n        if (i >= k) \n        {\n            rollingMax[i\
    \ % k] = max(rollingMax[i % k], numbers[i - k]);\n        }\n        out[i] =\
    \ rollingMax[i % k];\n    }\n    return out;\n}\n \n \n/*\n    Write a function\
    \ that generates all non-negative integers less than n by\n    repeatedly choosing\
    \ maximum integer m <= n, such that m is coprime with n,\n    and subtracting\
    \ m from n.\n    >>> geng(10)\n    [2L, 2L, 1L, 1L, 1L, 1L, 2L, 1L, 1L, 2L]\n\
    */\nlong[] geng(long n) \n{\n    long[] out = new long[$];\n    int out_i = 0;\n\
    \    long m = n;\n    while (m > 0) \n    {\n        out[out_i] = m;\n       \
    \ m--;\n        while (m > 0 && n % m == 0) \n        {\n            m--;\n  \
    \      }\n        n -= m;\n        out_i++;\n    }\n    return out;\n}\n \n/*\n\
    \    Given a string containing no duplicate characters, return\n    a sorted array\
    \ of all its distinct characters.\n    >>> distinct_characters(\"abcd\")\n   \
    \ ['a', 'b', 'c', 'd']\n    >>> distinct_characters(\"bbb\")\n    ['b']\n*/\n\
    char[] distinct_characters(string s) \n{\n    char[] distinct = new char[$];\n\
    \    auto distinct_i = 0;\n    distinct[distinct_i] = s[0];\n    distinct_i++;\n\
    \    foreach (c; s[1..$]) \n    {\n        if (distinct.canFind(c) == false) \n\
    \        {\n            distinct[distinct_i] = c;\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsty8gkjw.d(12): Error: no identifier for declarator `long[]`

    /tmp/tmpsty8gkjw.d(12): Error: found `out` instead of statement

    /tmp/tmpsty8gkjw.d(15): Error: `$` is valid only inside [] of index or slice

    /tmp/tmpsty8gkjw.d(23): Error: found `out` instead of statement

    /tmp/tmpsty8gkjw.d(25): Error: expression expected, not `out`

    /tmp/tmpsty8gkjw.d(38): Error: no identifier for declarator `long[]`

    /tmp/tmpsty8gkjw.d(38): Error: found `out` instead of statement

    /tmp/tmpsty8gkjw.d(43): Error: found `out` instead of statement

    /tmp/tmpsty8gkjw.d(52): Error: expression expected, not `out`

    /tmp/tmpsty8gkjw.d(74): Error: found `unittest` instead of statement

    /tmp/tmpsty8gkjw.d(83): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpsty8gkjw.d(83): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsty8gkjw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ rolling_max = numbers.dup;\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp17vtf2ra.d(13): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp17vtf2ra.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ deque = deque!long();\n    auto max_numbers = new long[numbers.length];\n  \
    \  foreach (n; 0 .. numbers.length) \n    {\n        while (!deque.empty && numbers[deque.back]\
    \ < numbers[n]) \n        {\n            deque.popBack();\n        }\n       \
    \ deque.pushBack(n);\n        max_numbers[n] = numbers[deque.front];\n       \
    \ if (deque.front == n - numbers.length) \n        {\n            deque.popFront();\n\
    \        }\n    }\n    return max_numbers;\n}\n \n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    auto deque\
    \ = deque!long();\n    auto min_numbers = new long[numbers.length];\n    foreach\
    \ (n; 0 .. numbers.length) \n    {\n        while (!deque.empty && numbers[deque.back]\
    \ > numbers[n]) \n        {\n            deque.popBack();\n        }\n       \
    \ deque.pushBack(n);\n        min_numbers[n] = numbers[deque.front];\n       \
    \ if (deque.front == n - numbers.length) \n        {\n            deque.popFront();\n\
    \        }\n    }\n    return min_numbers;\n}\n/*\n Find all subarray prefix max.\n\
    \    >>> prefix_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n*/\nlong[] prefix_max(long[] items) \n{\n    auto max_items = new long[items.length];\n\
    \    foreach (n; 0 .. items.length) \n    {\n        if (\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsgxggpdh.d(66): Error: expression expected, not `unittest`

    /tmp/tmpsgxggpdh.d(67): Error: found `{` when expecting `)`

    /tmp/tmpsgxggpdh.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsgxggpdh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = std.typecons.minVal!long;\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = std.math.max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2kvcnu3l.d(13): Error: undefined identifier `minVal` in module
    `std.typecons`

    /tmp/tmp2kvcnu3l.d(16): Error: undefined identifier `max` in module `std.math`,
    did you mean function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2kvcnu3l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    auto max = 0L;\n    size_t i = 0;\n\
    \    while (i < numbers.length)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsfntp9al.d(17): Error: function expected before `()`, not `max`
    of type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsfntp9al.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (current, inout result[1 .. $])\n    {\n        if (numbers[current] > result[current\
    \ - 1])\n            result[current] = numbers[current];\n        else\n     \
    \       result[current] = result[current - 1];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpngfalfu8.d(14): Error: no identifier for declarator `result[1 ..
    __dollar]`

    /tmp/tmpngfalfu8.d(14): Error: found `)` when expecting `;`

    /tmp/tmpngfalfu8.d(21): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpngfalfu8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ size = numbers.length;\n    long[size] result;\n    result[0] = numbers[0];\n\
    \    foreach (i, v; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i],\
    \ v);\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    auto size = numbers.length;\n\
    \    long[size] result;\n    result[0] = numbers[0];\n    foreach (i, v; numbers[1..$])\
    \ \n    {\n        result[i + 1] = min(result[i], v);\n    }\n    return result;\n\
    }\n/*\n For a given array, return the sum of all found elements.\n    >>> array_sum([1L,\
    \ 2L, 3L, 4L, 5L])\n    15L\n*/\nlong array_sum(long[] array) \n{\n    long result\
    \ = 0;\n    foreach (x; array) \n    {\n        result += x;\n    }\n    return\
    \ result;\n}\n/*\n For a given array, return the sum of all found elements.\n\
    \    >>> array_sum([1, 2, 3, 4, 5])\n    15\n*/\nlong array_sum(int[] array) \n\
    {\n    long result = 0;\n    foreach (x; array) \n    {\n        result += x;\n\
    \    }\n    return result;\n}\n/*\n Return an array containing a sequence of numbers\
    \ from start to end\n    >>> array_range(1L, 4L)\n    [1L, 2L, 3L, 4L]\n*/\nlong[]\
    \ array_range(long start, long end) \n{\n    assert(start <= end);\n    long[]\
    \ result;\n    long range = end - start + 1\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwjqidj0o.d(77): Error: semicolon expected, not `unittest`

    /tmp/tmpwjqidj0o.d(77): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwjqidj0o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.range;\n    auto max_so_far = numbers[0..1].front;\n    return numbers.map!(n\
    \ => {\n        max_so_far = max(max_so_far, n);\n        return max_so_far;\n\
    \    });\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaky8wf93.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaky8wf93.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_up_to_now = 0;\n    foreach\
    \ (i, number; numbers) \n    {\n        max_up_to_now = max(max_up_to_now, number);\n\
    \        result[i] = max_up_to_now;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdrjk6q7a.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdrjk6q7a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ rolling = numbers[0];\n    long[] res = new long[numbers.length];\n    res[0]\
    \ = rolling;\n    foreach(const i, e; numbers[1..$])\n    {\n        rolling =\
    \ max(rolling, e);\n        res[i] = rolling;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwtfxpb2d.d(17): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwtfxpb2d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long[] ret = new long[];\n    foreach(i, e; numbers)\n    {\n\
    \        max = max(max, e);\n        ret ~= max;\n    }\n    return ret;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfx7pkaaa.d(13): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpfx7pkaaa.d(16): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfx7pkaaa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \nin {\n \
    \   assert(numbers.length > 0);\n}\nout (result) {\n    result.length == numbers.length;\n\
    \    for (int i = 0; i < numbers.length; ++i) {\n        assert(result[i] >= numbers[i]);\n\
    \    }\n}\ndo \n{\n    long[] result = numbers[0..$];\n    for (int i = 1; i <\
    \ numbers.length; ++i) {\n        result[i] = max(result[i - 1], numbers[i]);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplk9gf4nx.d(24): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmplk9gf4nx.d(15): Error: `result.length == numbers.length` has no effect

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplk9gf4nx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maximum = numbers[0];\n    result[0]\
    \ = maximum;\n    foreach (index, n; numbers[1..$]) \n    {\n        if (n > maximum)\
    \ \n        {\n            maximum = n;\n        }\n        result[index + 1]\
    \ = maximum;\n    }\n    return result;\n}\n/*\n Find the next element of the\
    \ maximal subsequence in a given sequence\n    >>> next_max_element([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    4L\n*/\nlong next_max_element(long[] numbers) \n{\n  \
    \  long next_max_element = numbers[0];\n    foreach (n; numbers) \n    {\n   \
    \     if (n > next_max_element) \n        {\n            next_max_element = n;\n\
    \        }\n    }\n    return next_max_element;\n}\n/*\n Construct a bit sequence\
    \ from a given sequence of integers.\n    >>> sequence_to_bit_sequence([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [0L, 1L, 0L, 1L, 0L, 1L, 0L]\n*/\nlong[] sequence_to_bit_sequence(long[]\
    \ numbers) \n{\n    long[] bit_sequence = new long[numbers.length];\n    foreach\
    \ (index, n; numbers) \n    {\n        bit_sequence[index] = n == next_max_element(numbers[index..$])\
    \ ? 1L : 0L;\n    }\n    return bit_sequence;\n}\n/*\n Convert a given integer\
    \ to a binary number.\n    >>> to_binary(10L)\n    [1L, 0L, 1L, 0L]\n*/\nlong[]\
    \ to_binary(long n) \n{\n    long[] binary = new long[];\n    while (n > 0) \n\
    \    {\n        binary ~= n % 2;\n        n /= 2;\n    }\n    return binary;\n\
    }\n/*\n Convert a given binary number to an integer.\n    >>> from_\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpommth0mn.d(71): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpommth0mn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0]\
    \ = max_so_far;\n    foreach (i, x; numbers[1..$])\n    {\n        max_so_far\
    \ = max(max_so_far, x);\n        result[i+1] = max_so_far;\n    }\n    return\
    \ result;\n}\n \n/*\n Given an array of integers and a window size, generate another\
    \ array containing the\n    rolling minimum element found until given moment in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L], 3L)\n    [1L,\
    \ 1L, 2L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_min(long[] numbers, size_t window_size)\
    \ \n{\n    assert(window_size <= numbers.length);\n    size_t n = numbers.length;\n\
    \    long[] result = new long[n];\n    long min_so_far = numbers[0];\n    result[0]\
    \ = min_so_far;\n    for (size_t i = 1; i < n; i++)\n    {\n        if (i >= window_size)\n\
    \        {\n            min_so_far = numbers[i - window_size + 1..i].min;\n  \
    \      }\n        min_so_far = min(min_so_far, numbers[i]);\n        result[i]\
    \ = min_so_far;\n    }\n    return result;\n}\n \n/*\n Given an array of integers\
    \ and a window size, generate another array containing the\n    rolling maximum\
    \ element found until given moment in the sequence.\n    >>> rolling_max([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L], 3L)\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n*/\nlong[] rolling_max(long[]\
    \ numbers, size_t window_size) \n{\n    assert(window_size <= numbers.length);\n\
    \    size_t n = numbers.length;\n    long\nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ktlgrr6.d(59): Error: no identifier for declarator `long`

    /tmp/tmp_ktlgrr6.d(59): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ktlgrr6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int\
    \ i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i -\
    \ 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwi7sf92g.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwi7sf92g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ i = 0;\n    long max_so_far = numbers[0];\n    long[] result = new long[numbers.length];\n\
    \    foreach(number; numbers) \n    {\n        if (number > max_so_far) \n   \
    \     {\n            max_so_far = number;\n        }\n        result[i] = max_so_far;\n\
    \        i++;\n    }\n    return result;\n}\nlong[][] rolling_max2d(long[][] numbers)\
    \ \n{\n    long[] temp;\n    long[][] result = new long[numbers.length][];\n \
    \   foreach(i, number; numbers) \n    {\n        temp = rolling_max(number);\n\
    \        result[i] = temp;\n    }\n    return result;\n}\n/*\n *  check if two\
    \ arrays are equal\n */\nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9yc9pszr.d(29): Error: variable `numbers` cannot be read at compile
    time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9yc9pszr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tint\
    \ length = numbers.length;\n\tlong[] maxs = new long[length];\n\tlong max = 0;\n\
    \tfor (int i = 0; i < length; i++) \n\t{\n\t\tmax = max(max, numbers[i]);\n\t\t\
    maxs[i] = max;\n\t}\n\treturn maxs;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbn5dy9ne.d(12): Error: cannot implicitly convert expression `numbers.length`
    of type `ulong` to `int`

    /tmp/tmpbn5dy9ne.d(17): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbn5dy9ne.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ maxes = new long[numbers.length];\n    long currentMax = numbers[0];\n    foreach(index,\
    \ value; numbers)\n    {\n        if(value > currentMax)\n        {\n        \
    \    currentMax = value;\n        }\n        maxes[index] = currentMax;\n    }\n\
    \    return maxes;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp96lr69fc.d(13): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428536]

    ??:? long[] tmp96lr69fc.rolling_max(long[]) [0x427e62]

    ??:? void tmp96lr69fc.__unittest_L24_C1() [0x427f1a]

    ??:? void tmp96lr69fc.__modtest() [0x428208]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c563]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3f6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430681]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43060d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3cd]

    ??:? runModuleUnitTests [0x42c339]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t\
    \ n = numbers.length;\n    auto result = new long[](n);\n    result[0] = numbers[0];\n\
    \    foreach (i; 1 .. n)\n    {\n        result[i] = max(result[i - 1], numbers[i]);\n\
    \    }\n    return result;\n}\n/*\n Given a sequence of numbers, find the second\
    \ maximum element in the sequence.\n    >>> second_max([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    3L\n    >>> second_max([3L, 2L, 1L])\n    2L\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpewokt25t.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpewokt25t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  int\
    \ N = numbers.length;\n  long[] result = new long[N];\n  result[0] = numbers[0];\n\
    \  for (int i = 1; i < N; i++) \n  {\n    result[i] = max(result[i - 1], numbers[i]);\n\
    \  }\n  return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n  int N = numbers.length;\n\
    \  long[] result = new long[N];\n  result[0] = numbers[0];\n  for (int i = 1;\
    \ i < N; i++) \n  {\n    result[i] = min(result[i - 1], numbers[i]);\n  }\n  return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n  int N = numbers.length;\n  long[] result\
    \ = new long[N];\n  result[0] = numbers[0];\n  for (int i = 1; i < N; i++) \n\
    \  {\n    result[i] = result[i - 1] + numbers[i];\n  }\n  return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph2mkl7su.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2mkl7su.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (long\
    \ i = 1; i < numbers.length; i++)\n    {\n        result[i] = max(result[i - 1],\
    \ numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp01_weqlg.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp01_weqlg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in\n\
    \    {\n        assert(numbers.length >= 1);\n    }\n    out\n    (\n        result.length\
    \ == numbers.length\n    )\n{\n    long[] result = new long[numbers.length];\n\
    \    // *IMPORTANT*: std.concurrency cannot be used in @safe code.\n    long max_value\
    \ = numbers[0];\n    foreach(index, ref num; numbers)\n    {\n        max_value\
    \ = max(max_value, num);\n        result[index] = max_value;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuy9vwrj6.d(17): Error: found `.` when expecting `)`

    /tmp/tmpuy9vwrj6.d(17): Error: statement expected to be `{ }`, not `length`

    /tmp/tmpuy9vwrj6.d(18): Error: found `)` when expecting `;` following statement

    /tmp/tmpuy9vwrj6.d(19): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuy9vwrj6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tint\
    \ len = numbers.length;\n\tlong[] result = new long[len];\n\t\n\tif (len > 0)\n\
    \t{\n\t\tlong currMax = numbers[0];\n\t\tresult[0] = currMax;\n\t\tfor (int i\
    \ = 1; i < len; i++)\n\t\t{\n\t\t\tcurrMax = max(currMax, numbers[i]);\n\t\t\t\
    result[i] = currMax;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n// \n/*\n    From a\
    \ given array of integers, generate a corresponding array of boolean values\n\
    \    which tells, whether the corresponding element in original array is a local\
    \ maxima\n    or not.\n    >>> local_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [false,\
    \ false, true, false, true, true, false]\n*/\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjnnqie14.d(12): Error: cannot implicitly convert expression `numbers.length`
    of type `ulong` to `int`

    /tmp/tmpjnnqie14.d(21): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjnnqie14.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    for (size_t i = 0;\
    \ i < numbers.length; i++) \n    {\n        if (max < numbers[i]) \n        {\n\
    \            max = numbers[i];\n        }\n        result[i] = max;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long[] stack = new\
    \ long[n];\n    int top = 0;\n    for (int i = 0; i < n; i++) \n    {\n      \
    \  while (top > 0 && stack[top - 1] < numbers[i])\n            top--;\n      \
    \  if (top == 0)\n            result[i] = numbers[i];\n        else\n        \
    \    result[i] = stack[top - 1];\n        stack[top++] = numbers[i];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppjwhxa9x.d(12): Error: cannot implicitly convert expression `numbers.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppjwhxa9x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    auto numbers_max = new long[numbers.length];\n    foreach (i,\
    \ e; numbers) \n    {\n        if (e > max) \n        {\n            max = e;\n\
    \        }\n        numbers_max[i] = max;\n    }\n    return numbers_max;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  //std.algorithm.move(numbers.begin(),\
    \ numbers.end(), max_numbers.begin());\n  return numbers;\n}\nunittest\n{\n  \
    \  alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr82i8_tw.d(21): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283cd]

    ??:? void tmpr82i8_tw.__unittest_L15_C1() [0x427fee]

    ??:? void tmpr82i8_tw.__modtest() [0x428150]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b26e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430401]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43038d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b245]

    ??:? runModuleUnitTests [0x42c1b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42881c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    // Look for a max for a subsequence\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        // Slice subsequence\n\
    \        long[] sub_sequence = numbers[0..i];\n        // Calculate max element\
    \ for subsequence\n        long max_element = reduce!max(sub_sequence);\n    \
    \    // Fill result array\n        result[i] = max_element;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeayef5yl.d(19): Error: template instance `reduce!max` template
    `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeayef5yl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ window;\n    long[] result;\n    result.length = numbers.length;\n    immutable\
    \ size = window.length;\n    for (immutable i = 0; i < numbers.length; i++)\n\
    \    {\n        window ~= numbers[i];\n        if (window.length > size)\n   \
    \     {\n            window = window[1..$];\n        }\n        if (window.length\
    \ == size)\n        {\n            immutable maximum = max(window);\n        \
    \    result[i] = maximum;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp70py0bbc.d(16): Error: cannot modify `immutable` expression `0`

    /tmp/tmp70py0bbc.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp70py0bbc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.algorithm.iteration : map;\n    import std.algorithm.comparison : max;\n\
    \    import std.range : iota;\n    return iota(numbers.length).map!(i => numbers[0..i].max);\n\
    }\n \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3z26opr_.d(15): Error: template `std.algorithm.comparison.max`
    cannot deduce function from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/comparison.d(1550):        `std.algorithm.comparison.max(T...)(T
    args) if (T.length >= 2)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):        instantiated
    from here: `MapResult!(__lambda2, Result)`

    /tmp/tmp3z26opr_.d(15):        instantiated from here: `map!(Result)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3z26opr_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //\
    \ this is array of maximum elements found so far.\n    long[] running_maxes =\
    \ new long[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsn_vix86.d(14): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsn_vix86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ n = numbers.length;\n    long[] maxes = new long[n];\n    maxes[0] = numbers[0];\n\
    \    foreach (i, x; numbers[1..n]) \n    {\n        maxes[i] = max(maxes[i - 1],\
    \ x);\n    }\n    return maxes;\n}\n//\n//     O(n)\n//\n// From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n//     in the sequence.\n//     >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n//     [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n//     \n//\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    auto n = numbers.length;\n    long[] mins = new long[n];\n\
    \    mins[0] = numbers[0];\n    foreach (i, x; numbers[1..n]) \n    {\n      \
    \  mins[i] = min(mins[i - 1], x);\n    }\n    return mins;\n}\n//\n//     O(n)\n\
    //\n// From a given array of integers, generate an array of rolling sum elements\
    \ found until given moment\n//     in the sequence.\n//     >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n//     [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n//     \n\
    //\nlong[] rolling_sum(long[] numbers) \n{\n    auto n = numbers.length;\n   \
    \ long[] sums = new long[n];\n    sums[0] = numbers[0];\n    foreach (i, x; numbers[1..n])\
    \ \n    {\n        sums[i] = sums[i - 1] + x;\n    }\n    return sums;\n}\n//\n\
    //     O(n)\n//\n// From a given array of integers, generate an array of rolling\
    \ product elements found until given moment\n//     in the sequence.\n//     >>>\
    \ rolling_product([1L, 2L, 3\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9_v4fxab.d(17): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmp9_v4fxab.d(37): Error: undefined identifier `min`, did you mean variable
    `mins`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9_v4fxab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ d = new long[numbers.length];\n    d[0] = numbers[0];\n    foreach (i, n; numbers[1..$])\n\
    \    {\n        d[i] = max(d[i-1], n);\n    }\n    return d;\n}\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqsptc23t.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsptc23t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \n\
    \    \n    \n}\n \n/*\n Decorates input array with rolling maximum values.\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeyv7r674.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeyv7r674.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ result = new long[](numbers.length);\n    long currentMax = numbers[0];\n  \
    \  foreach (i, n; numbers) {\n        currentMax = max(currentMax, n);\n     \
    \   result[i] = currentMax;\n    }\n    return result;\n}\nlong max_score(long[]\
    \ arr)\n{\n    size_t n = arr.length;\n    long[] lmax = rolling_max(arr);\n \
    \   long[] rmax = rolling_max(arr[n-1..0]);\n    long score = 0;\n    foreach\
    \ (i, e; arr) {\n        score += min(lmax[i], rmax[n-1-i]) - e;\n    }\n    return\
    \ score;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp25fygjeo.d(15): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmp25fygjeo.d(27): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp25fygjeo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in\n\
    \    {\n        assert(numbers.length > 0);\n    }\n    body\n    {\n        long[]\
    \ result = new long[numbers.length];\n        long max = numbers[0];\n       \
    \ foreach (idx, n; numbers)\n        {\n            if (n > max)\n           \
    \ {\n                max = n;\n            }\n            result[idx] = max;\n\
    \        }\n        return result;\n    }\nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps7onisfn.d(13): Assertion failure

    ----------------

    ??:? _d_assertp [0x428495]

    ??:? long[] tmps7onisfn.rolling_max(long[]) [0x427e6b]

    ??:? void tmps7onisfn.__unittest_L29_C1() [0x427f56]

    ??:? void tmps7onisfn.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c657]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430775]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430701]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4c1]

    ??:? runModuleUnitTests [0x42c42d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(ch'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ result = new long[];\n    long local_max = 0;\n    foreach(n; numbers) \n  \
    \  {\n        local_max = max(local_max, n);\n        result ~= local_max;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp86yyx1_.d(12): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpp86yyx1_.d(16): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp86yyx1_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ result = new long[](numbers.length);\n    auto it = numbers.save;\n    foreach\
    \ (long current_value; numbers)\n    {\n        if (it == numbers.save) {\n  \
    \          result ~= current_value;\n        } else {\n            result ~= max(current_value,\
    \ result[$-1]);\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfhpjuprd.d(13): Error: no property `save` for type `long[]`

    /tmp/tmpfhpjuprd.d(16): Error: no property `save` for type `long[]`

    /tmp/tmpfhpjuprd.d(19): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfhpjuprd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, e; numbers[1 .. $])\n    {\n        result[i] = max(result[i - 1], e);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbpbg_0tf.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpbg_0tf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    for (long\
    \ i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}\nlong[] solve(long[] data,\
    \ long start, long end) \n{\n    long[] result = new long[data.length];\n    long[]\
    \ left = rolling_max(data[0..start]);\n    long[] right = rolling_max(data[end..$]);\n\
    \    for (long i = 0; i < start; i++) \n    {\n        result[i] = left[i];\n\
    \    }\n    for (long i = start; i < end; i++) \n    {\n        result[i] = data[i];\n\
    \    }\n    for (long i = end; i < data.length; i++) \n    {\n        result[i]\
    \ = right[i - end];\n    }\n    return result;\n}\nlong[] solve(long[] data) \n\
    {\n    long[] result = new long[data.length];\n    for (long i = 0; i < data.length;\
    \ i++) \n    {\n        result[i] = data[i];\n    }\n    for (long start = 0;\
    \ start < data.length; start++) \n    {\n        for (long end = start + 1; end\
    \ <= data.length; end++) \n        {\n            long[] v = solve(data, start,\
    \ end);\n            if (greater(v, result)) \n            {\n               \
    \ result = v;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzpe9k2_m.d(16): Error: function expected before `()`, not `max`
    of type `long`

    /tmp/tmpzpe9k2_m.d(52): Error: undefined identifier `greater`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzpe9k2_m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t\
    \ length = numbers.length;\n    return iota(length).map!(n => numbers[0..n].max);\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb5fdnabw.d(13): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5fdnabw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //\
    \ TODO: your code here\n    long[] array = new long[numbers.length];\n    long\
    \ max = 0;\n    foreach(inout i; numbers)\n    {\n        if(i > max)\n      \
    \  {\n            max = i;\n        }\n        array ~= max;\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5_5jrkw3.d(15): Error: variable `tmp5_5jrkw3.rolling_max.i` `inout`
    variables can only be declared inside `inout` functions

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_5jrkw3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0]\
    \ = max_so_far;\n    foreach (n; numbers[1..$])\n    {\n        max_so_far = max(max_so_far,\
    \ n);\n        result[n] = max_so_far;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt6p6xqz7.d(17): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt6p6xqz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ ret;\n    long max = numbers[0];\n    for (size_t i = 0; i < numbers.length;\
    \ i++) \n    {\n        max = max(max, numbers[i]);\n        ret ~= max;\n   \
    \ }\n    return ret;\n}\n/*\nFrom a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\nin the sequence.\n>>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n[1L, 1L, 1L, 1L, 1L, 1L, 1L]\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdtqlgpq.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdtqlgpq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ subarrays = tuple(map!(a => numbers[0..a], iota(1, numbers.length + 1)));\n\
    \    auto maxs = map!(arr => arr.max)(subarrays);\n    return maxs.array;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7encta2o.d(12): Error: template instance `map!((a) => numbers[0..a],
    iota(1, numbers.length + 1))` template `map` is not defined

    /tmp/tmp7encta2o.d(13): Error: template instance `map!((arr) => arr.max)` template
    `map` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7encta2o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    enum\
    \ MAX_CHUNK_SIZE = 64;\n    enum CMP = 0;\n    enum RESULT = 1;\n    size_t numbers_size\
    \ = numbers.length;\n    // Tuple!(long, bool)[]\n    auto cmp_result = new Tuple!(long,\
    \ bool)[](numbers_size);\n    cmp_result[] = tuple(numbers[], true);\n    for\
    \ (size_t i = 1; i < numbers_size; i++) \n    {\n        if (cmp_result[i - 1][CMP]\
    \ > numbers[i]) \n        {\n            cmp_result[i] = tuple(cmp_result[i -\
    \ 1][CMP], false);\n        } \n        else \n        {\n            cmp_result[i]\
    \ = tuple(numbers[i], true);\n        }\n    }\n    long[] result = new long[](numbers_size);\n\
    \    size_t b = MAX_CHUNK_SIZE;\n    for (size_t i = numbers_size - 1; i != size_t.max;\
    \ i--) \n    {\n        if (cmp_result[i][RESULT]) \n        {\n            for\
    \ (size_t a = b - 1; a != size_t.max; a--) \n            {\n                result[a]\
    \ = cmp_result[i][CMP];\n            }\n            b = MAX_CHUNK_SIZE;\n    \
    \    } \n        else \n        {\n            b--;\n        }\n    }\n    return\
    \ result;\n}\nlong[] test_rolling_max() \n{\n    assert (rolling_max([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]) == [1L, 2L, 3L, 3L, 3L, 4L, 4L]);\n    assert (rolling_max([])\
    \ == []);\n    assert (rolling_max([1L]) == [1L]);\n    assert (rolling_max([1L,\
    \ 2L]) == [1L, 2L]);\n    assert (rolling_max([2L, 1L]) == [2L, 2L]);\n    assert\
    \ (rolling_max\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvfryagg3.d(57): Error: found `unittest` when expecting `)`

    /tmp/tmpvfryagg3.d(58): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvfryagg3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //\
    \ Type inference failed in constrainded context\n    inout(size_t)[] positions\
    \ = new size_t[numbers.length];\n    long[] result = new long[numbers.length];\n\
    \    auto max_element = std.typecons.scoped(long.max);\n    inout(size_t) max_index\
    \ = size_t.max;\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n   \
    \     if (numbers[i] >= max_element) \n        {\n            max_element = numbers[i];\n\
    \            max_index = i;\n        }\n        positions[i] = max_index;\n  \
    \  }\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        result[i]\
    \ = numbers[positions[i]];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmple793hbc.d(13): Error: variable `tmple793hbc.rolling_max.positions`
    `inout` variables can only be declared inside `inout` functions

    /tmp/tmple793hbc.d(13): Error: cannot implicitly convert expression `new ulong[](numbers.length)`
    of type `ulong[]` to `inout(ulong)[]`

    /tmp/tmple793hbc.d(15): Error: template `std.typecons.scoped` cannot deduce function
    from argument types `!()(long)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(7512):        `std.typecons.scoped(T)
    if (is(T == class))`

    /tmp/tmple793hbc.d(16): Error: variable `tmple793hbc.rolling_max.max_index` `inout`
    variables can only be declared inside `inout` functions

    /tmp/tmple793hbc.d(22): Error: cannot modify `inout` expression `max_index`

    /tmp/tmple793hbc.d(24): Error: cannot modify `inout` expression `positions[i]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmple793hbc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    alias\
    \ I = size_t;\n    long[I] stack;\n    long[] result;\n    foreach (index, value;\
    \ numbers) \n    {\n        while (!stack.empty && numbers[stack.back] < value)\
    \ \n        {\n            stack.popBack();\n        }\n        stack ~= index;\n\
    \        if (index >= (I)stack.front) \n        {\n            result ~= numbers[stack.front];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfmagkc5e.d(22): Error: C style cast illegal, use `cast(I)stack.front`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfmagkc5e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if\
    \ (numbers.length == 0) \n    {\n        return numbers;\n    }\n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1;\
    \ i < numbers.length; i++) \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeefz968i.d(20): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeefz968i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ res = new long[numbers.length];\n    res[0] = numbers[0];\n    for (long i =\
    \ 1; i < numbers.length; i++)\n    {\n        res[i] = max(res[i - 1], numbers[i]);\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptp8jl_hu.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptp8jl_hu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    for (long\
    \ i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   for (long i = 0; i < numbers.length; i++)\n    {\n        min = min(min, numbers[i]);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling sum \n of elements found until given\
    \ moment in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    for (long i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2pqusppx.d(16): Error: function expected before `()`, not `max`
    of type `long`

    /tmp/tmp2pqusppx.d(33): Error: function expected before `()`, not `min` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2pqusppx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.algorithm.iteration : max;\n    import std.algorithm.mutation : popFront;\n\
    \    import std.container.array : array;\n    import std.typecons : tuple;\n \
    \   import std.conv : to;\n    import std.range : until;\n    import std.math\
    \ : max;\n    import std.array : split;\n    long[] result = numbers.map!(x =>\
    \ x.max(0L));\n    long[] prefix = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9z8dl3rj.d(22): Error: comma expected separating array initializers,
    not `unittest`

    /tmp/tmp9z8dl3rj.d(23): Error: semicolon expected, not `{`

    /tmp/tmp9z8dl3rj.d(31): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9z8dl3rj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    assert(!numbers.empty);\n\
    \    long[] result = new long[numbers.length];\n    auto max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, v; numbers[1 .. $]) \n    {\n        if (v\
    \ > max) \n        {\n            max = v;\n        }\n        result[i + 1] =\
    \ max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo7x_x5yu.d(12): Error: no property `empty` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo7x_x5yu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    if (numbers.length == 0)\n        return\
    \ result;\n    // maximum element seen so far\n    // for the first element, we\
    \ just assign it to the\n    // maximum element.\n    result[0] = numbers[0];\n\
    \    foreach (index, element; numbers[1 .. $]) \n    {\n        // next elements,\
    \ we store the maximum of\n        // either the current maximum element or the\n\
    \        // current element.\n        result[index] = max(result[index - 1], element);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu_gl336i.d(24): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu_gl336i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    size_t index = 0;\n    long max = 0;\n\
    \    foreach(number; numbers) \n    {\n        max = max(max, number);\n     \
    \   result[index] = max;\n        index++;\n    }\n    return result;\n}\n/*\n\
    \ Given a string, returns a tuple where the first element is the part of the string\n\
    \ without the last character, and the second element is the last character.\n\
    \    \n    >>> pop_last(\"dog\")\n    Tuple!(string, string)(\"do\", \"g\")\n\
    \    >>> pop_last(\"\")\n    Tuple!(string, string)(\"\", \"\")\n    \n*/\nTuple!(string,\
    \ string) pop_last(string input)\n{\n    if(input.length == 0)\n    {\n      \
    \  return tuple(\"\", \"\");\n    }\n    else\n    {\n        return tuple(input[0..$-1],\
    \ input[$-1..$]);\n    }\n}\n/*\n Given a string, returns a tuple where the first\
    \ element is the part of the string\n without the first character, and the second\
    \ element is the first character.\n    \n    >>> pop_first(\"dog\")\n    Tuple!(string,\
    \ string)(\"og\", \"d\")\n    >>> pop_first(\"\")\n    Tuple!(string, string)(\"\
    \", \"\")\n    \n*/\nTuple!(string, string) pop_first(string input)\n{\n    if(input.length\
    \ == 0)\n    {\n        return tuple(\"\", \"\");\n    }\n    else\n    {\n  \
    \      return tuple(input[1..$], input[0..1]);\n    }\n}\n/*\n Write a function\
    \ fib(n) which returns the n-th Fibonacci number\n    >>> fib(1)\n    1\n    >>>\
    \ fib(2)\n    1\n    >>> fib(3)\n    2\n    >>> fib(4)\n    3\n    >>> fib(5)\n\
    \    5\n    >>> fib(6)\n    8\n    >>> fib(7)\n    13\n    >>> fib(8)\n    21\n\
    \    >>> fib(9)\n    34\n    >>> fib\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpghs16hlf.d(65): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpghs16hlf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    return\
    \ iota(numbers.length).map!(a => take(a+1, numbers).max).array;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp25zljbp4.d(12): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp25zljbp4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    auto max_element = new long(numbers[0]);\n\
    \    result[0] = max_element;\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        max_element = max(max_element, number);\n        result[i + 1] = max_element;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplykjb8m5.d(14): Error: cannot implicitly convert expression `max_element`
    of type `long*` to `long`

    /tmp/tmplykjb8m5.d(17): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmplykjb8m5.d(18): Error: cannot implicitly convert expression `max_element`
    of type `long*` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplykjb8m5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    size_t write_index = 0;\n    for (size_t\
    \ i = 0; i < numbers.length; i++) \n    {\n        if (i == 0) \n        {\n \
    \           result[write_index] = numbers[i];\n            write_index++;\n  \
    \      } \n        else \n        {\n            auto new_max = max(result[write_index\
    \ - 1], numbers[i]);\n            if (new_max != result[write_index - 1]) \n \
    \           {\n                result[write_index] = new_max;\n              \
    \  write_index++;\n            }\n        }\n    }\n    return result[0 .. write_index];\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzy9hltjb.d(23): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzy9hltjb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    { \n\
    \        if(numbers.length == 0) return numbers;\n        size_t size = numbers.length;\n\
    \        long[] result = new long[size];\n        size_t index = 0;\n        result[index]\
    \ = numbers[index];\n        index++;\n        for(index; index < size; index++)\n\
    \        {\n            result[index] = max(result[index-1], numbers[index]);\n\
    \        }\n        return result;\n    }\nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjqquqyzn.d(18): Error: `index` has no effect

    /tmp/tmpjqquqyzn.d(20): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjqquqyzn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.array;\n    import std.algorithm;\n    import std.range;\n    import std.typecons;\n\
    \    import std.math;\n    long[] result = new long[numbers.length];\n    foreach(i,\
    \ number; numbers)\n    {\n        result[i] = max(numbers[0..i]);\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpda2usquk.d(20): Error: template `std.algorithm.comparison.max`
    cannot deduce function from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/comparison.d(1550):        `std.algorithm.comparison.max(T...)(T
    args) if (T.length >= 2)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpda2usquk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    ulong[]\
    \ max_sequence = new ulong[numbers.length];\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp17jymkun.d(13): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp17jymkun.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \
    \ long[] result = new long[numbers.length];\n     foreach (i, e; numbers) \n \
    \    {\n         e = numbers[i];\n         result[i] = max(numbers[0..i]);\n \
    \    }\n     return result;\n}\n/*\n    rolling maximum 2\n*/\nlong[] rolling_max2(long[]\
    \ numbers) \n{\n     long[] result = new long[numbers.length];\n     result[0]\
    \ = numbers[0];\n     for (size_t i = 1; i < numbers.length; i++) \n     {\n \
    \        result[i] = max(result[i - 1], numbers[i]);\n     }\n     return result;\n\
    }\n/*\n    rolling maximum 3\n*/\nlong[] rolling_max3(long[] numbers) \n{\n  \
    \   struct max_history \n     {\n         long max;\n         long[] history;\n\
    \     }\n     return unfold!(max_history)(x => x.max, x => x.history, max_history(numbers[0],\
    \ numbers[1..$]));\n}\n/*\n    rolling maximum 4\n*/\nlong[] rolling_max4(long[]\
    \ numbers) \n{\n     long[] result = new long[numbers.length];\n     result[0]\
    \ = numbers[0];\n     for (size_t i = 1; i < numbers.length; i++) \n     {\n \
    \        result[i] = max(result[i - 1], numbers[i]);\n     }\n     return result;\n\
    }\n/*\n    rolling maximum 5\n*/\nlong[] rolling_max5(long[] numbers) \n{\n  \
    \   long[] result = new long[numbers.length];\n     result[0] = numbers[0];\n\
    \     for (size_t i = 1; i < numbers.length; i++) \n     {\n         result[i]\
    \ = max(result[i - 1], numbers[i]);\n     }\n     return result;\n}\n/*\n    rolling\
    \ maximum 6\n*/\nlong[] rolling_max6(long[] numbers) \n{\n     long[] result =\
    \ new long[numbers.length];\n     result[0] = numbers[0];\n     for (size_t\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiup3nxhp.d(79): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpiup3nxhp.d(88): Error: found `void` when expecting `;` following `for`
    condition

    /tmp/tmpiup3nxhp.d(88): Error: found `{` when expecting `)`

    /tmp/tmpiup3nxhp.d(88): Error: found `}` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiup3nxhp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //\
    \ 1. find maximum element in an array\n    // 2. for each element of the array,\
    \ do a slice of the array\n    // 3. each slice is compared to max value\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpluw8ftx_.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpluw8ftx_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ elements;\n    foreach(i; 0 .. numbers.length)\n    {\n        elements ~= numbers[i\
    \ .. i + 1].max;\n    }\n    return elements;\n}\n// version 1.0.6\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgonq4kab.d(15): Error: no property `max` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgonq4kab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ rolling_max_numbers = [];\n    long[] best_until_now = [];\n    foreach(n; numbers)\n\
    \    {\n        rolling_max_numbers ~= n;\n        best_until_now ~= max(n, best_until_now);\n\
    \    }\n    return rolling_max_numbers;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ rolling_max_numbers = [];\n    long best_until_now = 0;\n    foreach(n; numbers)\n\
    \    {\n        rolling_max_numbers ~= n;\n        best_until_now = max(n, best_until_now);\n\
    \    }\n    return rolling_max_numbers;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ rolling_max_numbers = [];\n    long best_until_now = 0;\n    foreach(n; numbers)\n\
    \    {\n        rolling_max_numbers ~= best_until_now;\n        best_until_now\
    \ = max(n, best_until_now);\n    }\n    return rolling_max_numbers;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling maximum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpivm53lkg.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpivm53lkg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //\
    \ If there are no numbers, then return an empty array.\n    if (numbers.length\
    \ == 0)\n    {\n        return [];\n    }\n    long max = numbers[0];\n    //\
    \ Create an array with the same length as numbers and initialize\n    // all elements\
    \ to max.\n    long[] maxes = new long[numbers.length];\n    foreach (index, val;\
    \ numbers)\n    {\n        maxes[index] = max;\n        if (val > max)\n     \
    \   {\n            max = val;\n        }\n    }\n    return maxes;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpokf53t23.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284a5]

    ??:? void tmpokf53t23.__unittest_L31_C1() [0x428029]

    ??:? void tmpokf53t23.__modtest() [0x428228]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c583]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b416]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b50]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43062d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3ed]

    ??:? runModuleUnitTests [0x42c359]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428968]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.array;\n    auto r = numbers.take(1);\n\
    \    foreach(i; 1..numbers.length)\n    {\n        r ~= max(numbers[i..$]);\n\
    \    }\n    return r;\n}\n/*\ntest \n*/\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpma9nxhos.d(18): Error: template `std.algorithm.comparison.max`
    cannot deduce function from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/comparison.d(1550):        `std.algorithm.comparison.max(T...)(T
    args) if (T.length >= 2)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpma9nxhos.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] > max)\n   \
    \         max = numbers[i];\n        result[i] = max;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpgtrp4y43.d(13): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428566]

    ??:? long[] tmpgtrp4y43.rolling_max(long[]) [0x427e62]

    ??:? void tmpgtrp4y43.__unittest_L22_C1() [0x427f4a]

    ??:? void tmpgtrp4y43.__modtest() [0x428238]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c593]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b426]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43063d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]

    ??:? runModuleUnitTests [0x42c369]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if\
    \ (numbers.length == 0)\n        return new long[0];\n    long[] result = new\
    \ long[numbers.length];\n    result[0] = numbers[0];\n    for (size_t i = 1; i\
    \ < numbers.length; i++)\n    {\n        result[i] = max(result[i - 1], numbers[i]);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    if (numbers.length == 0)\n\
    \        return new long[0];\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    for (size_t i = 1; i < numbers.length; i++)\n\
    \    {\n        result[i] = min(result[i - 1], numbers[i]);\n    }\n    return\
    \ result;\n}\n/*\n Find unique prime factors of a number, i.e. the set of prime\
    \ factors\n    >>> unique_prime_factors(2L)\n    [2L]\n    >>> unique_prime_factors(27L)\n\
    \    [3L]\n    >>> unique_prime_factors(60L)\n    [2L, 3L, 5L]\n    >>> unique_prime_factors(180L)\n\
    \    [2L, 3L, 5L]\n    >>> unique_prime_factors(12L)\n    [2L, 3L]\n*/\nulong[]\
    \ unique_prime_factors(ulong number) \n{\n    if (number == 1)\n        return\
    \ new ulong[0];\n    auto factors = prime_factors(number);\n    return factors.dedup;\n\
    }\n/*\n    Find all the prime factors of a number.\n    >>> prime_factors(2L)\n\
    \    [2L]\n    >>> prime_fact\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2j3vu9k6.d(60): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2j3vu9k6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  return\
    \ numbers.map!((n) => numbers[0..i].max)();\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeqk03q7b.d(12): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeqk03q7b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ ret = new long[numbers.length];\n    auto maxIter = numbers.maxElement();\n\
    \    long max = *maxIter;\n    int maxIndex = maxIter - numbers.begin;\n    int\
    \ index = 0;\n    foreach(e; numbers)\n    {\n        if(e >= max)\n        {\n\
    \            max = e;\n            maxIndex = index;\n        }\n        ret[index]\
    \ = max;\n        index++;\n    }\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf72yjuwr.d(13): Error: no property `maxElement` for type `long[]`

    /tmp/tmpf72yjuwr.d(15): Error: no property `begin` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf72yjuwr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ t = tuple(0L, numbers[0]);\n    auto res = [t];\n    foreach(i, ref v; numbers[1..$])\n\
    \    {\n        auto tmp = t.field0;\n        if(t.field1 > v)\n        {\n  \
    \          t.field0 = i;\n            t.field1 = v;\n        }\n        res ~=\
    \ t;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuj60ej9p.d(16): Error: no property `field0` for type `Tuple!(long,
    long)`, did you mean `std.typecons.Tuple!(long, long).Tuple.field`?

    /tmp/tmpuj60ej9p.d(17): Error: no property `field1` for type `Tuple!(long, long)`,
    did you mean `std.typecons.Tuple!(long, long).Tuple.field`?

    /tmp/tmpuj60ej9p.d(19): Error: no property `field0` for type `Tuple!(long, long)`,
    did you mean `std.typecons.Tuple!(long, long).Tuple.field`?

    /tmp/tmpuj60ej9p.d(20): Error: no property `field1` for type `Tuple!(long, long)`,
    did you mean `std.typecons.Tuple!(long, long).Tuple.field`?

    /tmp/tmpuj60ej9p.d(24): Error: cannot implicitly convert expression `res` of type
    `Tuple!(long, long)[]` to `long[]`

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (size_t\
    \ i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i -\
    \ 1], numbers[i]);\n    }\n    return result;\n}\n \n/*\n Find period of repetition\
    \ in the time series.\n    >>> period_lookback([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    3L\n    >>> period_lookback([2L, 3L, 1L, 2L, 3L, 4L, 2L])\n    4L\n    >>>\
    \ period_lookback([0L, 2L, 1L, 3L, 1L, 2L, 1L])\n    2L\n    >>> period_lookback([0L,\
    \ 2L, 3L, 1L, 3L, 2L, 1L])\n    2L\n    >>> period_lookback([2L, 3L, 2L, 1L, 3L,\
    \ 2L, 1L])\n    1L\n    >>> period_lookback([1L, 2L, 3L, 4L, 3L, 2L, 1L])\n  \
    \  7L\n    >>> period_lookback([1L, 2L, 3L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 3L, 2L,\
    \ 1L])\n    7L\n*/\nlong period_lookback(long[] numbers) \n{\n    long current_max\
    \ = numbers[0];\n    size_t i = 1;\n    while (i < numbers.length && numbers[i]\
    \ > current_max) \n    {\n        current_max = numbers[i];\n        i++;\n  \
    \  }\n    return i;\n}\n \n/*\n From array of integers, find the period of the\
    \ repeating subsequence inside the array.\n    >>> period([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    3L\n    >>> period([0L, 2L, 1L, 3L, 1L, 2L, 1L])\n    2L\n   \
    \ >>> period([2\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6xx2rtj5.d(50): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6xx2rtj5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    enum\
    \ size_t const size = numbers.length;\n    size_t i = 0;\n    long[] result =\
    \ new long[size];\n    if(size) \n    {\n        auto max = numbers[0];\n    \
    \    result[0] = max;\n        for(i = 1; i < size; ++i) \n        {\n       \
    \     if(numbers[i] > max) \n            {\n                max = numbers[i];\n\
    \            }\n            result[i] = max;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp23fxwr4t.d(12): Error: no identifier for declarator `size_t`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23fxwr4t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long[] result = [];\n    foreach(i, num; numbers)\n    {\n   \
    \     max = max(max, num);\n        result ~= max;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplrylo_sk.d(16): Error: function expected before `()`, not `max`
    of type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplrylo_sk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto\
    \ result = new long[](numbers.length);\n    // manual loop without std.algorithm.max\n\
    \    foreach (index, x; numbers) \n    {\n        if (index == 0) \n        {\n\
    \            result[index] = x;\n        }\n        else \n        {\n       \
    \     result[index] = max(result[index - 1], x);\n        }\n    }\n    return\
    \ result;\n}\n/*\n    From a given array of integers, generate an array of rolling\
    \ maximum element found until given moment\n    in the sequence.\n    >>> max_with_index([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nTuple!(long,\
    \ long)[] max_with_index(long[] numbers) \n{\n    auto result = new Tuple!(long,\
    \ long)[](numbers.length);\n    auto maximum = std.algorithm.max(numbers);\n \
    \   auto index = numbers.indexOf(maximum);\n    // manual loop without std.algorithm.max\n\
    \    foreach (index, x; numbers) \n    {\n        if (index == 0) \n        {\n\
    \            result[index] = tuple(x, index);\n        }\n        else \n    \
    \    {\n            result[index] = result[index - 1];\n            if (maximum\
    \ < x) \n            {\n                result[index] = tuple(x, index);\n   \
    \         }\n        }\n    }\n    return result;\n}\n/*\n    From a given array\
    \ of integers, generate an array of rolling maximum element found until given\
    \ moment\n    in the sequence.\n    >>> min_with_index([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nTuple!(long, long)[] min_with_index(long[]\
    \ numbers) \n{\n    auto result = new Tuple!(long, long)[](numbers.length);\n\
    \    auto minimum = std.\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbzbcx2fc.d(68): Error: identifier expected following `.`, not `unittest`

    /tmp/tmpbzbcx2fc.d(69): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpbzbcx2fc.d(77): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbzbcx2fc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ ret = new long[numbers.length];\n    long max = long.min;\n    for (size_t i\
    \ = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        ret[i] = max;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe9cnxb58.d(16): Error: function expected before `()`, not `max`
    of type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe9cnxb58.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[0];\n    result ~= numbers[0];\n    foreach(i; 1..numbers.length)\n\
    \    {\n        result ~= max(result[$-1], numbers[i]);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5shewbve.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5shewbve.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t\
    \ sz = numbers.length;\n    auto ret = new long[](sz);\n    static if (sz > 0)\n\
    \    {\n        ret[0] = numbers[0];\n        for (size_t i = 1; i < sz; i++)\n\
    \        {\n            ret[i] = max(ret[i - 1], numbers[i]);\n        }\n   \
    \ }\n    return ret;\n}\n \nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdy5on413.d(14): Error: variable `sz` cannot be read at compile
    time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdy5on413.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if\
    \ (numbers.length == 0) return long.init[];\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (index, number; numbers[1 .. $])\n \
    \   {\n        result[index] = max(result[index - 1], number);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgv1cs9_9.d(12): Error: only one index allowed to index `long`

    /tmp/tmpgv1cs9_9.d(17): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgv1cs9_9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tint\
    \ len = numbers.length;\n\tlong[] res = new long[len];\n\t\n\tif (len >= 1) \n\
    \t{\n\t\tres[0] = numbers[0];\n\t\tfor (int i = 1; i < len; i++) \n\t\t{\n\t\t\
    \tif (numbers[i] > res[i - 1])\n\t\t\t\tres[i] = numbers[i];\n\t\t\telse\n\t\t\
    \t\tres[i] = res[i - 1];\n\t\t}\n\t}\n\treturn res;\n}\n/*\n The following function\
    \ takes a strin and returns the number of vowels in the string.\n The function\
    \ is case insensitive.\n */\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9nvetexi.d(12): Error: cannot implicitly convert expression `numbers.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9nvetexi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[]\
    \ result = new long[numbers.length];\n\tlong max_element = numbers[0];\n\tfor\
    \ (uint i = 0; i < numbers.length; i++) \n\t{\n\t\tmax_element = max(max_element,\
    \ numbers[i]);\n\t\tresult[i] = max_element;\n\t}\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy5s7365k.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy5s7365k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif\
    \ (numbers.length == 0) \n\t{\n\t\treturn [];\n\t}\n\t\n\tauto rolling_max = [=](in\
    \ long[] numbers) \n\t{\n\t\tlong[] result;\n\t\tresult ~= numbers[0];\n\t\tforeach\
    \ (i, val; numbers[1 .. $]) \n\t\t{\n\t\t\tif (val > result[$ - 1]) \n\t\t\t{\n\
    \t\t\t\tresult ~= val;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tresult ~= result[$\
    \ - 1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\t\n\tlong[] result = rolling_max(numbers);\n\
    \t\n\tassert(result.length == numbers.length);\n\t\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tdfxwmh.d(17): Error: expression expected, not `=`

    /tmp/tmp_tdfxwmh.d(17): Error: expression expected, not `in`

    /tmp/tmp_tdfxwmh.d(17): Error: found `long` when expecting `,`

    /tmp/tmp_tdfxwmh.d(17): Error: found `numbers` when expecting `,`

    /tmp/tmp_tdfxwmh.d(18): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmp_tdfxwmh.d(33): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tdfxwmh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++) \n    {\n        result[i] = max(numbers[0..i]);\n    }\n    return result;\n\
    }\n/*\n This is the sliding window approach.\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max2(long[] numbers) \n{\n   \
    \ int size = numbers.length;\n    long[] maxSliding = new long[size];\n    auto\
    \ deque = new Deque!long();\n    deque.insertFront(0);\n    maxSliding[0] = numbers[0];\n\
    \    for (int i = 1; i < size; i++) \n    {\n        if (numbers[i] > maxSliding[i\
    \ - 1]) \n        {\n            maxSliding[i] = numbers[i];\n            deque.clear();\n\
    \            deque.insertFront(i);\n        } \n        else \n        {\n   \
    \         maxSliding[i] = maxSliding[i - 1];\n        }\n        while (!deque.empty\
    \ && numbers[deque.back] < numbers[i]) \n        {\n            deque.removeBack();\n\
    \        }\n        deque.insertBack(i);\n        while (deque.front < i - 3)\
    \ \n        {\n            deque.removeFront();\n        }\n        maxSliding[i]\
    \ = max(maxSliding[i], numbers[deque.front]);\n    }\n    return maxSliding;\n\
    }\n// TESTS\nunittest \n{\n    static assert(rolling_max([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L]) == [1L, 2L, 3L, 3L, 3L, 4L, 4L]);\n    static assert(rolling_max2\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvnrkfvpz.d(64): Error: found `unittest` when expecting `)`

    /tmp/tmpvnrkfvpz.d(65): Error: found `{` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvnrkfvpz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    foreach(long\
    \ i, ref long val; typeof(numbers).init)\n    {\n        max_value = max(max_value,\
    \ val);\n        result[i] = max_value;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps391xbnr.d(16): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps391xbnr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ rolling_maxes = new long[numbers.length];\n    long cur_max = 0;\n    foreach\
    \ (idx, number; numbers) \n    {\n        if (number > cur_max) \n        {\n\
    \            cur_max = number;\n        }\n        rolling_maxes[idx] = cur_max;\n\
    \    }\n    return rolling_maxes;\n}\n/*\n    Given an array of integers, and\
    \ a number 'k', find the maximum for each and every contiguous subarray of size\
    \ 'k'.\n    >>> max_sliding_window([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L],\
    \ 4)\n    [4L, 5L, 6L, 7L, 8L, 9L, 10L]\n    \n*/\nlong[] max_sliding_window(long[]\
    \ numbers, size_t k) \n{\n    long[] max_sliding_window = new long[numbers.length\
    \ - k + 1];\n    long[] rolling_maxes = rolling_max(numbers);\n    long[] rolling_maxes_window\
    \ = rolling_maxes[0 .. $ - k + 1];\n    long[] rolling_maxes_window_next = rolling_maxes[k\
    \ .. $];\n    foreach (idx, rolling_max; rolling_maxes_window) \n    {\n     \
    \   long next_rolling_max = rolling_maxes_window_next[idx];\n        max_sliding_window[idx]\
    \ = max(rolling_max, next_rolling_max);\n    }\n    return max_sliding_window;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsbm78ub_.d(39): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsbm78ub_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t\
    \ size = numbers.length;\n    long[] result = new long[size];\n    if (size ==\
    \ 0) return result;\n    result[0] = numbers[0];\n    foreach (i, n; numbers[1\
    \ .. $])\n    {\n        if (n >= result[i - 1])\n            result[i] = n;\n\
    \        else\n            result[i] = result[i - 1];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpttmf1c81.d(18): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42860e]

    ??:? long[] tmpttmf1c81.rolling_max(long[]) [0x427f23]

    ??:? void tmpttmf1c81.__unittest_L25_C1() [0x42807a]

    ??:? void tmpttmf1c81.__modtest() [0x4282e0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c63b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430759]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c08]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306e5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4a5]

    ??:? runModuleUnitTests [0x42c411]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long current_max = 0;\n    foreach (i,\
    \ number; numbers) {\n        if (number > current_max) {\n            current_max\
    \ = number;\n        }\n        result[i] = current_max;\n    }\n    return result;\n\
    }\n/*\n    Given two parallel arrays:\n    >>> a = [1L, 2L, 3L, 2L, 1L, 2L, 1L]\n\
    \    >>> b = [4L, 1L, 2L, 2L, 3L, 1L, 3L]\n    These arrays store the indices\
    \ of a pair of elements in another array.\n    In this case,\n    >>> a = [1L,\
    \ 2L, 3L, 2L, 1L, 2L, 1L]\n    >>> b = [4L, 1L, 2L, 2L, 3L, 1L, 3L]\n    For each\
    \ pair, the element with lower index comes first.\n    Given those two arrays,\
    \ generate\n    >>> [3L, 4L, 4L, 3L, 1L, 3L, 1L]\n    where each number indicates\
    \ the length of the longest non-decreasing subsequence,\n    starting from the\
    \ element in the first array and ending with the element in the second array.\n\
    \    If the number is 1, it means that there is no such subsequence.\n    To build\
    \ this sequence, you will have to maintain an array of the longest non-decreasing\
    \ subsequence\n    so far for each element.\n    For example, for the sequence\n\
    \    >>> [4L, 3L, 2L, 1L, 1L, 2L, 3L, 4L]\n    you will compute the length of\
    \ the longest non-decreasing subsequence ending at each position:\n    >>> [1L,\
    \ 1L, 1L, 1L, 1L, 2L, 2L, 3L]\n    and then you will add the result of the longest\
    \ non-decreasing subsequence starting at each position\n    >>> [1L, 1L, 1L, 1L,\
    \ 1L, 2L, 2L, 3L]\n    >>> [1L, 1L, 1L, 1L, 1L, 1\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe8u4jrol.d(22): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe8u4jrol.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif\
    \ (numbers.length == 0)\n\t\treturn [];\n\t\n\treturn std.algorithm.scan!((a,\
    \ b) => max(a, b))(numbers).dropOne;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphpijmrdq.d(15): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphpijmrdq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
