name: HumanEval_66_digitSum
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nTask\n    Write a function that\
  \ takes a string as input and returns the sum of the upper characters only'\n  \
  \  ASCII codes.\n\n    Examples:\n    >>> digitSum(\"\")\n    0L\n    >>> digitSum(\"\
  abAB\")\n    131L\n    >>> digitSum(\"abcCd\")\n    67L\n    >>> digitSum(\"helloE\"\
  )\n    69L\n    >>> digitSum(\"woArBld\")\n    131L\n    >>> digitSum(\"aAaaaXa\"\
  )\n    153L\n    \n*/\nlong digitSum(string s) \n"
tests: "unittest\n{\n    alias candidate = digitSum;\n\n    assert(candidate(\"\"\
  ) == 0L);\n    assert(candidate(\"abAB\") == 131L);\n    assert(candidate(\"abcCd\"\
  ) == 67L);\n    assert(candidate(\"helloE\") == 69L);\n    assert(candidate(\"woArBld\"\
  ) == 131L);\n    assert(candidate(\"aAaaaXa\") == 153L);\n    assert(candidate(\"\
  \ How are yOu?\") == 151L);\n    assert(candidate(\"You arE Very Smart\") == 327L);\n\
  }\nvoid main(){}"
completions: ["{\n    long sum = 0;\n    foreach(immutable c; s)\n    {\n        if(c\
    \ >= 'A' && c <= 'Z')\n            sum += (long)c;\n    }\n    return sum;\n}",
  "{\n    long sum = 0;\n    foreach(c; s) {\n        if(c.isUpper) sum += c;\n  \
    \  }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(char c; s) \n  \
    \  {\n        if (c >= 'A' && c <= 'Z')\n            sum += cast(long)c;\n   \
    \ }\n    return sum;\n}", "{\n    long sum = 0;\n    for (long i = 0; i < s.length;\
    \ i++)\n    {\n        if (s[i] >= 65 && s[i] <= 90)\n        {\n            sum\
    \ += (s[i] - 64);\n        }\n    }\n    return sum;\n}", "{\n    string upper\
    \ = filter!(c => isUpper(c))(s);\n    long sum = 0;\n    foreach(i;0..upper.length)\
    \ {\n        sum += upper[i];\n    }\n    return sum;\n}", "{\n    long sum =\
    \ 0;\n    foreach(char c; s) \n    {\n        if (c >= 'A' && c <= 'Z') \n   \
    \     {\n            sum += (long)c;\n        }\n    }\n    return sum;\n}", "{\n\
    \tlong sum = 0;\n\tfor (int i = 0; i < s.length; i++)\n\t{\n\t\tint c = s[i];\n\
    \t\tif (c >= 65 && c <= 90)\n\t\t{\n\t\t\tsum += c;\n\t\t}\n\t}\n\treturn sum;\n\
    }", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n        if(char.isUpper(c))\n\
    \        {\n            sum += cast(long)char.toUpper(c);\n        }\n    }\n\
    \    return sum;\n}", "{\n    auto result = 0L;\n    auto upperBound = 'Z'.to!long;\n\
    \    auto lowerBound = 'A'.to!long;\n    foreach(character; s)\n    {\n      \
    \  if (character.to!long <= upperBound && character.to!long >= lowerBound)\n \
    \       {\n            result += character.to!long;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long result = 0;\n    foreach(c; s)\n    {\n        result\
    \ += c.toUpper().to!long();\n    }\n    return result;\n}", "{\n    return accumulate!(\"\
    a + b\")(map!(\"toUpper(a) == a ? to!int(a) : 0\")(s));\n}", "{\n    int ret =\
    \ 0;\n    foreach(c; s)\n    {\n        if(c <= 'Z' && c >= 'A')\n           \
    \ ret += c;\n    }\n    return ret;\n}", "{\n    long sum = 0;\n    foreach(char\
    \ c; s)\n    {\n        if (c >= 'A' && c <= 'Z')\n            sum += c;\n   \
    \ }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n  \
    \      if(c >= 'A' && c <= 'Z')\n            sum += (long)c;\n    }\n    return\
    \ sum;\n}", "{\n\tlong sum = 0;\n\tforeach(ch; s)\n\t{\n\t\tif(ch >= 'A' && ch\
    \ <= 'Z')\n\t\t\tsum += ch;\n\t}\n\treturn sum;\n}", "{\n    import std.ascii\
    \ : isUpper;\n    return s.filter!(isUpper).sum!(a => a);\n}\n/*\nTask\n    Given\
    \ an array of integers, return the indexes of the two numbers that they add up\
    \ to a specific target.\n    You may assume that each input would have exactly\
    \ one solution, and you may not use the same element twice.", "{\n    string temp\
    \ = \"\";\n    long sum = 0;\n    foreach(c; s)\n    {\n        if(c.isUpper)\n\
    \        {\n            sum += c;\n        }\n    }\n    return sum;\n}", "{\n\
    \    long result = 0;\n    foreach(c;s)\n    {\n        if(c >= 'A' && c <= 'Z')\n\
    \        {\n            // printf(\"%c %lld\\n\",c,cast(long)c);\n           \
    \ result += cast(long)c;\n        }\n    }\n    return result;\n}", "{\n    import\
    \ std.typecons;\n    import std.math;\n    auto uppers = s.filter!(c => c >= 'A'\
    \ && c <= 'Z');\n    auto ints = uppers.map!(x => x.to!int);\n    auto sum = reduce!((acc,\
    \ x) => acc + x)(ints);\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(immutable\
    \ c; s)\n    {\n        if (c >= 'A' && c <= 'Z')\n            sum += c;\n   \
    \ }\n    return sum;\n}", "{\n    long sum = 0;\n    for (char c : s) \n    {\n\
    \        if (c.isUpper) \n        {\n            sum += c.to!int;\n        }\n\
    \    }\n    return sum;\n}\n/*\nTask:\n   Convert the given ints to a list of\
    \ ints that are in reverse order.", "{\n    return reduce!q{a + b}(map!q{a}(filter!q{a\
    \ >= 'A' && a <= 'Z'}(s)));\n}", "{\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.ascii;\n    import std.char;\n    auto to_int\
    \ = (ulong c) => c.to!int();\n    auto to_ascii = (ulong c) => c.to!ascii();\n\
    \    auto is_upper = (ulong c) => c.isUpper();\n    long total = 0;\n    foreach(value;\
    \ s)\n    {\n        auto temp = to_int(value);\n        if(is_upper(to_ascii(temp)))\n\
    \        {\n            total += temp;\n        }\n    }\n    return total;\n}",
  "{\n    long ans = 0;\n    if (s == \"\")\n        return ans;\n    long m = s.length;\n\
    \    for (long i = 0; i < m; i++)\n    {\n        if (isUpper(s[i]))\n       \
    \     ans += (long)s[i];\n    }\n    return ans;\n}", "{\n    long sum = 0;\n\
    \    foreach(immutable c; s)\n    {\n        if(c.isUpperCase)\n        {\n  \
    \          sum += cast(long)c;\n        }\n    }\n    return sum;\n}", "{\n  \
    \  auto res = 0L;\n    foreach(c; s)\n    {\n        if(c >= 'A' && c <= 'Z')\
    \ res += (long)c;\n    }\n    return res;\n}", "{\n    long ret = 0;\n    long\
    \ x = s.length;\n    foreach(j; 0 .. x)\n    {\n        if(j == s.length)\n  \
    \          break;\n        if(s[j] >= 65 && s[j] <= 90)\n            ret += s[j];\n\
    \    }\n    return ret;\n}", "{\n    long sum = 0;\n    foreach(ch; s)\n    {\n\
    \        if (ch.isUpper)\n            sum += ch;\n    }\n    return sum;\n}",
  "{\n    long sum = 0;\n    foreach(c; s)\n    {\n        if (c >= 'A' && c <= 'Z')\n\
    \            sum += c;\n    }\n    return sum;\n}", "{\n    int res = 0;\n   \
    \ foreach(i; s)\n    {\n        res += (i > 'a' && i < 'z') ? 0 : i;\n    }\n\
    \    return res;\n}", "{\n    if (s.length == 0)\n        return 0;\n    if (s.length\
    \ == 1)\n        return s[0];\n    if (s.length == 2)\n        return s[0] + s[1];\n\
    \    if (s.length == 3)\n        return s[0] + s[1] + s[2];\n    if (s.length\
    \ == 4)\n        return s[0] + s[1] + s[2] + s[3];\n    if (s.length == 5)\n \
    \       return s[0] + s[1] + s[2] + s[3] + s[4];\n    if (s.length == 6)\n   \
    \     return s[0] + s[1] + s[2] + s[3] + s[4] + s[5];\n    if (s.length == 7)\n\
    \        return s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6];\n    if (s.length\
    \ == 8)\n        return s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6] + s[7];\n\
    \    if (s.length == 9)\n        return s[0] + s[1] + s[2] + s[3] + s[4] + s[5]\
    \ + s[6] + s[7] + s[8];\n    if (s.length == 10)\n        return s[0] + s[1] +\
    \ s[2] + s[3] + s[4] + s[5] + s[6] + s[7] + s[8] + s[9];\n    if (s.length ==\
    \ 11)\n        return s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6] + s[7] +\
    \ s[8] + s[9] + s[10];\n    if (s.length == 12)\n        return s[0] + s[1] +\
    \ s[2] + s[3] +", "{\n    size_t j = 0;\n    for (size_t i = 0; i < s.length;\
    \ i++) \n    {\n        if ('A' <= s[i] && s[i] <= 'Z') \n        {\n        \
    \    j += s[i];\n        }\n    }\n    return j;\n}", "{\n  return s.filter!isUpperCase()\n\
    \          .map!(char => char.idup).sum;\n}", "{\n    long val = 0;\n    int n\
    \ = s.length;\n    foreach(i; 0..n)\n    {\n        char c = s[i];\n        int\
    \ asc = cast(int)c;\n        if(asc >= 65 && asc <= 90) val += asc;\n    }\n \
    \   return val;\n}", "{\n    // pure nothrow @safe @nogc:\n    long sum = 0;\n\
    \    foreach(c; s) \n    {\n        if(c >= 'A' && c <= 'Z')\n            sum\
    \ += c;\n    }\n    return sum;\n}", "{\n    long res = 0;\n    foreach(immutable\
    \ c; s)\n    {\n        if (c.isUpper)\n            res += c;\n    }\n    return\
    \ res;\n}", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n        if(c.isUpper)\n\
    \        {\n            sum += c;\n        }\n    }\n    return sum;\n}", "{\n\
    \    long upperSum = 0;\n    foreach(c; s)\n    {\n        if(c.isUpper)\n   \
    \     {\n            upperSum += cast(long)c;\n        }\n    }\n    return upperSum;\n\
    }", "{\n    return foldl!(s, (sum, c) => c.isUpper ? sum + c : sum)(0L);\n}",
  "{\n    long res = 0;\n    foreach(char c; s)\n    {\n        if(c >= 'A' && c <=\
    \ 'Z')\n            res += c;\n    }\n    return res;\n}", "{\n    long ret =\
    \ 0;\n    foreach(c; s)\n    {\n        if (toupper(c) == c)\n            ret\
    \ += c;\n    }\n    return ret;\n}", "{\n    long sum = 0;\n    foreach(c; s)\
    \ {\n        if(isUpper(c)) {\n            sum += cast(long)c;\n        }\n  \
    \  }\n    return sum;\n}", "{\n    long upper = 0;\n    foreach(c; s)\n    {\n\
    \        c = toUpper(c);\n        upper += c;\n    }\n    return upper;\n}", "{\n\
    \    long total = 0;\n    foreach(immutable char c; s)\n    {\n        auto c1\
    \ = toUpper(c);\n        if(c1 >= 'A' && c1 <= 'Z')\n        {\n            total\
    \ += c1;\n        }\n    }\n    return total;\n}", "{\n    long result = 0;\n\
    \    foreach(index, char c; s)\n    {\n        if(c > 64 && c < 91)\n        {\n\
    \            result += (long)c;\n        }\n    }\n    return result;\n}", "{\n\
    \    long sum = 0;\n    foreach(int i; s)\n    {\n        if (i < 123 && i > 96)\n\
    \            sum += i - 32;\n    }\n    return sum;\n}", "{\n    long sum = 0;\n\
    \    foreach(ch; s)\n    {\n        sum += ch.isUpper() ? ch : 0;\n    }\n   \
    \ return sum;\n}", "{\n    return s.filter!(char.isUpper)().map!(char.isUpper\
    \ => (int)=>int(to!int) - int('A') + 1)().sum;\n}", "{\n    return s.filter!isUpper.map!(c\
    \ => c + 0).sum;\n}", "{\n    auto get = (char c) => (c > 'A' && c < 'Z') ? c\
    \ : 0;\n    return s.map!(get).sum;\n}", "{\n    long output = 0;\n    foreach(i;\
    \ s) \n    {\n        if(isUpper(i)) \n        {\n            output += (long)\
    \ i;\n        }\n    }\n    return output;\n}\n// By chrisbwong\nlong digitSum2(string\
    \ s) \n{\n    return s.sum!((a) => isUpper(a) ? a : 0);\n}\n// By mousahamadeh\n\
    long digitSum3(string s) \n{\n    auto toSum = s.filter!(a => a.isUpper);\n  \
    \  return toSum.sum;\n}\n// By arnobibhor\nlong digitSum4(string s) \n{\n    long\
    \ sum = 0;\n    foreach(i; 0 .. s.length) \n    {\n        if(isUpper(s[i]))\n\
    \            sum += (long) s[i];\n    }\n    return sum;\n}\n// By seyProg\nlong\
    \ digitSum5(string s) \n{\n    long sum = 0;\n    foreach(c; s) \n    {\n    \
    \    sum += isUpper(c) ? c : 0;\n    }\n    return sum;\n}\n// By Joses W.\nlong\
    \ digitSum6(string s) \n{\n    long sum = 0;\n    for(size_t i = 0; i < s.length;\
    \ i++) \n    {\n        if(isUpper(s[i]))\n            sum += s[i];\n    }\n \
    \   return sum;\n}\n// By agar3s\nlong digitSum7(string s) \n{\n    long sum =\
    \ 0;\n    foreach(c; s) \n    {\n        if(isUpper(c))\n            sum += c;\n\
    \    }\n    return sum;\n}\n// By Sezgin\nlong digitSum8(string s) \n{\n    long\
    \ sum = 0;\n    foreach(c; s) \n    {\n        if(c.isUpper)\n            sum\
    \ += c;\n    }\n    return sum;\n}\n// By Claudio Rodriguez\nlong digitSum", "{\n\
    \    long sum = 0;\n    foreach(char x; s)\n    {\n        if(x >= 'A' && x <=\
    \ 'Z')\n            sum += x;\n    }\n    return sum;\n}", "{\n    long ret =\
    \ 0;\n    foreach(i; 0 .. s.length) \n    {\n        ret += s[i] < 'a' ? s[i]\
    \ : 0;\n    }\n    return ret;\n}", "{\n    return s.filter!(c => 'A' <= c &&\
    \ c <= 'Z').sum!(c => cast(long)c);\n}", "{\n    auto result = 0;\n    foreach(ch;\
    \ s)\n    {\n        if('A' <= ch && ch <= 'Z')\n            result += ch;\n \
    \   }\n    return result;\n}", "{\n    auto result = 0L;\n    auto s_upper = s.upper;\n\
    \    foreach(c; s_upper)\n    {\n        if (c >= 'A' && c <= 'Z')\n        {\n\
    \            result += c;\n        }\n    }\n    return result;\n}", "{\n    long\
    \ sum = 0;\n    foreach(c; s)\n    {\n        if(isUpper(c))\n        {\n    \
    \        sum += cast(long)c;\n        }\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    auto temp = s.toUpper;\n    foreach(x;temp)\n    {\n        if(x\
    \ >= 'A' && x <= 'Z')\n        {\n            sum += x;\n        }\n    }\n  \
    \  return sum;\n}", "{\n    auto sf = filter!((i){return 'A' <= i <= 'Z';})(s);\n\
    \    auto sum = 0L;\n    foreach(i; sf)\n    {\n        sum += i;\n    }\n   \
    \ return sum;\n}", "{\n  //your code here\n  long result = 0;\n  foreach(char\
    \ c; s)\n  {\n    int ascii = cast(int)c;\n    if(ascii >= 65 && ascii <= 90)\n\
    \      result += ascii;\n  }\n  return result;\n}", "{\n    long result=0;\n \
    \   foreach(c;s)\n    {\n        if(isUpper(c))\n        {\n            result+=c;\n\
    \        }\n    }\n    return result;\n}", "{\n    auto isUpper = (dchar c) =>\
    \ 'A' <= c && c <= 'Z';\n    auto charSum = (dchar c) => c;\n    return s.filter!isUpper.map!charSum.sum;\n\
    }\n// Ranges\nimport std.algorithm;\n/*\n    Task\n    You are given a string\
    \ s.\n    s consists of English alphabetic letters only.\n    Your task is to\
    \ find the top three most common characters in the string s.\n    If the occurrence\
    \ count is the same, sort the characters in alphabetical order.", "{\n    return\
    \ sum(s.filter!(c => c >= 'A' && c <= 'Z').map!(c => c.to!long));\n}", "{\n  \
    \  long sum = 0;\n    foreach(c; s)\n    {\n        if(c >= 'A' && c <= 'Z')\n\
    \            sum += (long)c;\n    }\n    return sum;\n}", "{\n    long sum = 0;\n\
    \    auto ua = s.toUpper.array;\n    foreach(immutable c;ua)\n    {\n        sum\
    \ += c;\n    }\n    return sum;\n}\n/*\nTask\n    Given a positive integer n and\
    \ a string s consisting only of letters D or I, you have to find any permutation\
    \ of first n positive integer that satisfy the given input string.", "{\n    static\
    \ import std.conv;\n    static import std.string;\n    static import std.range;\n\
    \    static import std.algorithm;\n    long sum = 0;\n    auto uppers = s.filter!(\"\
    a\" <= a && a <= \"z\")\n                   .map!((a) => to!long(a)).sum;\n  \
    \  \n    return uppers;\n}", "{\n    return s.filter!(x => x.isUpper).sum!(x =>\
    \ x);\n}\n ", "{\n    long sum = 0;\n    foreach(w; s) {\n        if (isUpper(w))\
    \ sum += to!long(w);\n    }\n    return sum;\n}\n/*\nTask\n    Write a function\
    \ that takes a lowercase string as input and returns a tuple of a string and \n\
    \    a long, where the long is the number of times the string occurred.\n    The\
    \ original string is empty if there was no occurrence of it.", "{\n    long result\
    \ = 0;\n    foreach(c; s)\n    {\n        auto cc = to!char(c);\n        result\
    \ += isUpper(cc) ? to!int(cc) : 0;\n    }\n    return result;\n}", "{\n    long\
    \ sum = 0;\n    foreach(i;s)\n    {\n        if(isUpper(i))\n        {\n     \
    \       sum += i;\n        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n\
    \    foreach(c; s) \n    {\n        sum +=  to!long(c) >= 65 && to!long(c) <=\
    \ 90 ? to!long(c) : 0;\n    }\n    return sum;\n}", "{\n\treturn s.filter!(x =>\
    \ x > 64 && x < 91).map!(x => x - 64).sum;\n}", "{\n    static long[] upperAscii\
    \ = new long[256];\n    static bool[] isUpper = new bool[256];\n    static this()\n\
    \    {\n        foreach(ascii; 0 .. 256)\n        {\n            isUpper[ascii]\
    \ = 'A' <= cast(char)ascii && cast(char)ascii <= 'Z';\n            upperAscii[ascii]\
    \ = cast(char)ascii;\n        }\n    }\n    return s.sum!(ch => upperAscii[ch])();\n\
    }", "{\n    auto result = 0L;\n    auto isUpper = 'A' <= s[0] && s[0] <= 'Z';\n\
    \    auto isLower = 'a' <= s[0] && s[0] <= 'z';\n    if (isUpper) {\n        result\
    \ += to!int(s[0]);\n    }\n    foreach (c; s[1 .. $]) {\n        auto isUpper\
    \ = 'A' <= c && c <= 'Z';\n        auto isLower = 'a' <= c && c <= 'z';\n    \
    \    if (isUpper) {\n            result += to!int(c);\n        }\n    }\n    return\
    \ result;\n}", "{\n    //typeof(s[0]) will return char which is an int\n    typeof(s[0])[]\
    \ uppers = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    long sum =\
    \ 0;\n    foreach(int i, char c; s)\n    {\n        if(uppers.canFind(c))\n  \
    \      {\n            sum += i;\n        }\n    }\n    return sum;\n}", "{\n \
    \   long sum = 0;\n    foreach(inout ch; s)\n    {\n        if (ch.isUpper)\n\
    \        {\n            sum += (long)ch;\n        }\n    }\n    return sum;\n}",
  "{\n    long sum = 0;\n    foreach(c; s) \n    {\n        if (isUpper(c)) \n   \
    \     {\n            sum += cast(long) c;\n        }\n    }\n    return sum;\n\
    }", "{\n    return s.filter!(x => 65 <= x && x <= 90).reduce!((a, b) => a + b).sum;\n\
    }", "{\n    return s.filter!((x) => x.isUpper).sum!((x) => x.value);\n}", "{\n\
    \    long result = 0;\n    foreach(c; s)\n    {\n        if (c >= 'A' && c <=\
    \ 'Z')\n            result += c;\n    }\n    return result;\n}\n//or\nlong digitSum(string\
    \ s)\n{\n    long result = 0;\n    auto s_upper = toUpper(s);\n    foreach(c;\
    \ s_upper)\n    {\n        result += c;\n    }\n    return result;\n}\n//or\n\
    long digitSum(string s)\n{\n    long result = 0;\n    for(auto c : s)\n    {\n\
    \        if (c >= 'A' && c <= 'Z')\n            result += c;\n    }\n    return\
    \ result;\n}\n//or\nlong digitSum(string s)\n{\n    long result = 0;\n    auto\
    \ s_upper = toUpper(s);\n    for(auto c : s_upper)\n    {\n        result += c;\n\
    \    }\n    return result;\n}", "{\n    int sum = 0;\n    foreach(d; s)\n    {\n\
    \        // D is the char\n        if(d >= 'A' && d <= 'Z')\n        {\n     \
    \       sum += d;\n        }\n    }\n    return sum;\n}\n// write your own test\
    \ cases\n/*\nTask2\n    Write a function that takes a string as input and returns\
    \ the sum of the lower characters only'\n    ASCII codes.", "{\n    long result\
    \ = 0;\n    foreach(c; s)\n    {\n        if(isUpper(c))\n        {\n        \
    \    result += cast(long)c;\n        }\n    }\n    return result;\n}", "{\n  \
    \  return s.filter!(c => c.isUpper).map!(c => c.to!int).sum;\n}", "{\n    long\
    \ sum = 0;\n    foreach(c; s) \n    {\n        if(c.isUpper) \n        {\n   \
    \         sum += c;\n        }\n    }\n    return sum;\n}", "{\n    long sum =\
    \ 0;\n    foreach(c; s) {\n        if(isUpper(c))\n            sum += c;\n   \
    \ }\n    return sum;\n}", "{\n    long result = 0;\n    for (int i = 0; i < s.length;\
    \ i++) \n    {\n        auto c = s[i];\n        result += ulong(c).to!('upper')\
    \ == c ? ulong(c) : 0;\n    }\n    return result;\n}", "{\n    auto sum_up_letters\
    \ = 0;\n    foreach( c; s)\n    {\n        if(isUpper(c))\n        {\n       \
    \     sum_up_letters += c;\n        }\n    }\n    return sum_up_letters;\n}",
  "{\n    return s.fold!((char,a)=>a+char.toUpper.to!long)(0L);\n}", "{\n    long\
    \ sum = 0;\n    foreach(char c; s)\n    {\n        if(c >= 'A' && c <= 'Z')\n\
    \            sum += c;\n    }\n    return sum;\n}", "{\n    // The reduce-left\
    \ function takes a binary function and an array.\n    // It applies the binary\
    \ function to each element, left to right,\n    // and reduces the array to a\
    \ single value.\n    // In this case, the binary function is an anonymous lambda\
    \ function\n    // that returns the sum of the upper character ASCII code and\
    \ the accumulator.\n    return s.reduce!((a, b) => a + (b.isUpper ? b : 0)).sum;\n\
    }", "{\n    // long sum = 0;\n    // foreach(c; s) {\n    //     if (isAlpha(c)\
    \ && isUpper(c)) {\n    //         sum += c;\n    //     }\n    // }\n    // return\
    \ sum;\n    return s.walkLength.filter!(c => isAlpha(c) && isUpper(c)).map!(c\
    \ => c).sum;\n}\n/*\n    Function compose\n    Write a function compose(f, g)\
    \ that takes as input two functions of one argument and returns their function\
    \ composition.\n    Examples:\n    >>> import std.stdio;\n    >>> auto negate\
    \ = (x) => -x;\n    >>> auto square = (x) => x * x;\n    >>> auto f = compose(negate,\
    \ square);\n    >>> f(3);\n    -9\n    >>> f(5);\n    -25\n    >>> auto h = compose(f,\
    \ f);\n    >>> h(9);\n    -81\n*/\nT compose(alias f, alias g)(T x)\n{\n    return\
    \ f(g(x));\n}", "{\n    long sum = 0;\n    foreach(i; s)\n    {\n        if (i.toUpper()\
    \ == i)\n        {\n            sum += cast(long)i;\n        }\n    }\n    return\
    \ sum;\n}", "{\n    /*\n    return\n    s.filter!(c => (c >= 'A' && c <= 'Z')).fold!(0L,\
    \ (a, c) => a + cast(long)c);\n    */\n    //My Solution\n    long result = 0;\n\
    \    for(int i = 0; i < s.length; i++)\n    {\n        if(s[i] >= 'A' && s[i]\
    \ <= 'Z')\n        {\n            result += cast(long)s[i];\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] temp = new long[s.length];\n    long res\
    \ = 0;\n    foreach(i, c; s)\n    {\n        if(c >= 'A' && c <= 'Z')\n      \
    \  {\n            temp[i] = c;\n            res += temp[i];\n        }\n    }\n\
    \    return res;\n}", "{\n    string upperS = toUpper(s);\n    long res = 0;\n\
    \    for (int i = 0; i < s.length; i++)\n    {\n        res += cast(long)upperS[i];\n\
    \    }\n    return res;\n}", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n\
    \        if(c >= 'A' && c <= 'Z')\n            sum += c;\n    }\n    return sum;\n\
    }", "{\n    long result = 0;\n    foreach(c; s)\n    {\n        if(c>='A' && c<='Z')\n\
    \            result += (long)c;\n    }\n    return result;\n}", "{\n    long result=0;\n\
    \    for(int i=0;i<s.length;i++)\n    {\n        if(isAlpha(s[i]) && isUpper(s[i]))\n\
    \        {\n            result+=(s[i]-'0');\n        }\n    }\n    return result;\n\
    }", "{\n    long n = 0;\n    foreach(i; 0 .. s.length)\n    {\n        int c =\
    \ s[i];\n        if(c >= 'A' && c <= 'Z')\n            n += c;\n    }\n    return\
    \ n;\n}", "{\n\tlong sum = 0;\n\tforeach(c;s)\n\t{\n\t\tif(c >= 'A' && c <= 'Z')\n\
    \t\t\tsum += c;\n\t}\n\treturn sum;\n}", "{\n    long n = 0;\n    foreach(c; s)\n\
    \    {\n        if(!char.isUpper(c))\n            continue;\n        n += ulong(c);\n\
    \    }\n    return n;\n}", "{\n    // Test Case\n    if (s.empty) return 0L;\n\
    \    // Loop\n    long sum = 0L;\n    foreach(c; s)\n    {\n        if (c.isUpper)\n\
    \        {\n            sum += c.ascii;\n        }\n    }\n    return sum;\n}",
  "{\n    long res = 0;\n    foreach(c; s)\n    {\n        res += (isUpper(c) ? c\
    \ : 0);\n    }\n    return res;\n}", "{\n    long r = 0;\n    s.replace('A', '1').replace('B',\
    \ '2').replace('C', '3').replace('D', '4').replace('E', '5').replace('F', '6').replace('G',\
    \ '7').replace('H', '8').replace('I', '9').replace('J', '10').replace('K', '11').replace('L',\
    \ '12').replace('M', '13').replace('N', '14').replace('O', '15').replace('P',\
    \ '16').replace('Q', '17').replace('R', '18').replace('S', '19').replace('T',\
    \ '20').replace('U', '21').replace('V', '22').replace('W', '23').replace('X',\
    \ '24').replace('Y', '25').replace('Z', '26');\n    string[] tokens = s.split('\
    \ ');\n    foreach(string token; tokens)\n    {\n        if(token != \"\")\n \
    \       {\n            r += to!long(token);\n        }\n    }\n    return r;\n\
    }", "{\n    long n = 0;\n    for (dchar c : s)\n    {\n        if (toUpper(c)\
    \ == c)\n        {\n            n += cast(long)c;\n        }\n    }\n    return\
    \ n;\n}", "{\n    long result = 0;\n    foreach(inout char c; s)\n    {\n    \
    \    if(isUpper(c))\n        {\n            result += c;\n        }\n    }\n \
    \   return result;\n}", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n    \
    \    if(c > 64 && c < 91)\n        {\n            sum += c;\n        }\n    }\n\
    \    return sum;\n}\n/*\nTask\nWrite a function that takes a string s and an integer\
    \ n as arguments and returns a string with the first n characters of s and the\
    \ last n characters of s swapped.", "{\n    int sum = 0;\n    foreach(c; s){\n\
    \        if(c >= 'A' && c <= 'Z'){\n            sum += cast(int)c;\n        }\n\
    \    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(inout(char) c;\
    \ s) \n    {\n        if(c >= 'A' && c <= 'Z')\n            sum += (int)c;\n \
    \   }\n    return sum;\n}", "{\n    long r = 0;\n    foreach(i; s)\n    {\n  \
    \      if(i >= 'A' && i <= 'Z')\n            r += (cast(long)i);\n    }\n    return\
    \ r;\n}\n/*\nTask\n    Implement a modulo operation to return the remainder of\
    \ 2 longs numbers. It should work like the\n    built-in modulo operator (%) with\
    \ 2 arguments, but it should not use it.", "{\n    long sum = 0;\n    foreach(i;\
    \ 0 .. s.length)\n    {\n        if(isUpper(s[i]))\n        {\n            sum\
    \ += (int)s[i];\n        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n\
    \    foreach(c; s){\n        //65~90 \uC740 \uB300\uBB38\uC790\uC758 ASCII\n \
    \       if(c >= 65 && c <= 90)\n            sum += c;\n    }\n    return sum;\n\
    }", "{\n    long sum = 0;\n    foreach(c; s) \n    {\n        if(c > 64 && c <\
    \ 91) \n        {\n            //writeln(c);\n            sum += (long)c;\n  \
    \      }\n    }\n    return sum;\n}", "{\n    long result = 0;\n    for (immutable(char)\
    \ letter : s)\n    {\n        if (letter >= 'A' && letter <= 'Z')\n        {\n\
    \            result += to!long(letter);\n        }\n    }\n    return result;\n\
    }", "{\n    long sum=0;\n    foreach(immutable c; s)\n    {\n        if(c.toUpper\
    \ == c)\n        {\n            sum += c;\n        }\n    }\n    return sum;\n\
    }\n/*\nTask\n    Write a function that takes a string as input and returns the\
    \ sum of the upper characters only.", "{\n    // string s;\n    long sum = 0;\n\
    \    foreach(i; 0 .. s.length) \n    {\n        long asci = s[i];\n        if\
    \ (asci >= 65 && asci <= 90) sum += asci;\n    }\n    return sum;\n}\n// void\
    \ main(string[] args) \n// {\n//     string s;\n//     s = \"abcCd\";\n//    \
    \ writeln(digitSum(s));\n// }", "{\n    return s.filter!isUpper().sum!(c => c.to!uint()).to!long();\n\
    }", "{\n  //TODO:\n  auto range = s.filter!(ch => ch >= 'A' && ch <= 'Z');\n \
    \ long total = 0;\n  foreach(ch; range)\n  {\n    total += ch;\n  }\n  return\
    \ total;\n}", "{\n    long sum=0;\n    foreach(immutable c; s) \n    {\n     \
    \   auto c2 = toUpper(c);\n        int i = c2.idup;\n        if(i >= 'A'.idup\
    \ && i <= 'Z'.idup)\n            sum += i;\n    }\n    return sum;\n}", "{\n \
    \   // basic solution\n    long result = 0;\n    foreach(c; s)\n    {\n      \
    \  if(c >= 'A' && c <= 'Z')\n            result += c;\n    }\n    return result;\n\
    }", "{\n    long tot = 0;\n    foreach(ch; s)\n    {\n        if (isUpper(ch))\n\
    \            tot += ch;\n    }\n    return tot;\n}", "{\n    long sum = 0;\n \
    \   foreach(c; s)\n    {\n        if(c.isUpper)\n        {\n            sum +=\
    \ (long)c;\n        }\n    }\n    return sum;\n}", "{\n    long sLength = s.length;\n\
    \    long sum = 0;\n    foreach(i; 0 .. sLength)\n    {\n        sum += s[i] &\
    \ 0b00100000;\n    }\n    return sum;\n}", "{\n\tlong sum = 0;\n\tforeach(immutable\
    \ c; s)\n\t{\n\t\tif(isUpper(c))\n\t\t\tsum += cast(long)c;\n\t}\n\treturn sum;\n\
    }\n/*\nTask\n    Sum all the items in an array that are integers or are floating\
    \ point numbers that are whole numbers.", "{\n\tlong res = 0;\n\tforeach(c; s)\n\
    \t{\n\t\tauto a = cast(int) c;\n\t\tif (a >= 65 && a <= 90)\n\t\t\tres += a;\n\
    \t}\n\treturn res;\n}", "{\n    long tot = 0;\n    foreach(c; s) {\n        if(isUpper(c))\n\
    \            tot += c;\n    }\n    return tot;\n}", "{\n    long sum = 0;\n  \
    \  foreach(c; s)\n    {\n        if (isUpper(c))\n            sum += c;\n    }\n\
    \    return sum;\n}\n/*\nTask\n    Write a program that takes a string as input\
    \ and returns the sum of the ASCII codes of all the upper characters only.", "{\n\
    \    return s.filter!(a => a.isUpper).map!(a => a.ord).sum;\n}\n/*\nElementary\
    \ 5\nTask\n    One of the famous interview questions for programmers is... \"\
    Which character is absent in the string?\"", "{\n    return s.toUpper.filter!(x\
    \ => x.isUpper).sum!(x => x.toInt);\n}", "{\n    long ret = 0;\n    static immutable\
    \ long a = cast(long)('A');\n    static immutable long z = cast(long)('Z');\n\
    \    foreach(c; s)\n    {\n        auto x = cast(long)(c);\n        if(x >= a\
    \ && x <= z)\n            ret += x;\n    }\n    return ret;\n}", "{\n    import\
    \ std.typecons : tuple;\n    import std.conv : to;\n    import std.ascii : isUpper;\n\
    \    long sum = 0;\n    char[] a = to!(char[])(s);\n    foreach(c; a)\n    {\n\
    \        if(isUpper(c))\n        {\n            sum += c;\n        }\n    }\n\
    \    return sum;\n}", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n      \
    \  if(isUpper(c))\n        {\n            sum += (long)c;\n        }\n    }\n\
    \    return sum;\n}", "{\n  long result = 0;\n  foreach(i; 0 .. s.length) \n \
    \ {\n    result += s[i] in ['A' .. 'Z'] ? (s[i] - 'A' + 1) : 0;\n  }\n  return\
    \ result;\n}", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n        if (c.isUpperCase)\n\
    \            sum += c;\n    }\n    return sum;\n}", "{\n    long sum = 0;\n  \
    \  foreach(immutable char c; s)\n    {\n        if(c.isUpper)\n        {\n   \
    \         sum += c;\n        }\n    }\n    return sum;\n}", "{\n    int result\
    \ = 0;\n    foreach(c; s) \n    {\n        if(c.isUpper)\n            result +=\
    \ c;\n    }\n    return result;\n}", "{\n    long sum=0;\n    foreach(c;s)\n \
    \   {\n        if(c>='A' && c<='Z')\n        {\n            sum+=c;\n        }\n\
    \    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(c; s) {\n    \
    \    if(c.isUpper)\n            sum += c;\n    }\n    return sum;\n}\n/*\nTask\n\
    \    Write a function that takes a string as input and returns the sum of the\
    \ lower characters only'\n    ASCII codes.", "{\n    long sum = 0;\n    string\
    \ upcase = uppercase(s);\n    foreach(d;zip(s,upcase)) {\n        if(d[0] == d[1])\
    \ {\n            sum += cast(long)d[0];\n        }\n    }\n    return sum;\n}",
  "{\n    long res = 0;\n    foreach(c; s)\n    {\n        res += c.isUpper ? c :\
    \ 0;\n    }\n    return res;\n}", "{\n    long sum = 0;\n    foreach(char c; s)\n\
    \    {\n        if(c >= 'A' && c <= 'Z')\n            sum += (long)c;\n    }\n\
    \    return sum;\n}", "{\n  long res = 0;\n  foreach(immutable ch; s)\n  {\n \
    \   if(ch >= 'A' && ch <= 'Z')\n      res += ch;\n  }\n  return res;\n}\n/*\n\
    Task\n    Write a function that takes two strings as input and returns the sum\
    \ of their lengths.", "{\n    long result = 0;\n    foreach(c; s)\n    {\n   \
    \     if(c.isUpper())\n        {\n            result += c;\n        }\n    }\n\
    \    return result;\n}", "{\n    long sum = 0;\n    foreach(char c; s) \n    {\n\
    \        if (isUpper(c)) \n        {\n            sum += c;\n        }\n    }\n\
    \    return sum;\n}", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n      \
    \  if(c >= 'A' && c <= 'Z')\n            sum += c;\n    }\n    return sum;\n}\n\
    /*\nTask\n    The Fibonacci numbers, commonly denoted F(n) form a sequence, called\
    \ the Fibonacci sequence, \n    such that each number is the sum of the two preceding\
    \ ones, starting from 0 and 1. That is,\n    >>> F(0) = 0, F(1) = 1\n    >>> F(N)\
    \ = F(N - 1) + F(N - 2), for N > 1.\n    Given N, calculate F(N).\n    \n    Examples:\n\
    \    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(7)\n\
    \    13\n    >>> fibonacci(12)\n    144\n    >>> fibonacci(200)\n    280571172992510140037611932413038677189525\n\
    */\nlong fibonacci(long n)\n{\n    if(n == 0)\n        return 0;\n    if(n ==\
    \ 1)\n        return 1;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\
    /*\nTask\n    Rotate an array of n elements to the right by k steps.\n    For\
    \ example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].\n\
    \    \n    Example:\n    >>> right_rotate([1,2,3,4,5,6,7], 3)\n    [5,6,7,1,2,3,4]\n\
    \    >>> right_rotate([1,2,3,4,5,6,7], 8)\n    [1,2,3,4,5,6,7]\n    >>> right_rotate([1,2,3,4,5,6,7],\
    \ 9)\n    [6,7,1,2,3,4,5]\n*/\nlong[] right_rotate(long[]", "{\n    import std.string;\n\
    \    long sum = 0;\n    foreach(immutable c; s)\n    {\n        if(isUpper(c))\n\
    \        {\n            sum += cast(long)c;\n        }\n    }\n    return sum;\n\
    }", "{\n    long result = 0;\n    foreach(inout c; s)\n    {\n        if(c >=\
    \ 'A' && c <= 'Z')\n        {\n            result += cast(long)c;\n        }\n\
    \    }\n    return result;\n}\n/*\nTask\n    Write a function that takes an array\
    \ of strings as input and returns a list of the words in \n    the same order,\
    \ without duplicates.", "{\n    long sum = 0;\n    foreach(inout c; s) \n    {\n\
    \        if(isUpper(c))\n            sum += c;\n    }\n    return sum;\n}", "{\n\
    \    return s.sum()(x => {\n        if (isUpperCase(x)) return x;\n        else\
    \ return 0;\n    });\n}", "{\n    // or we can use isa<ulong>\n    auto a = s.toUpperArray;\
    \ //ascii\n    auto b = a.map!(to!int);\n    return b.sum;\n}", "{\n    long res\
    \ = 0;\n    foreach(wchar c; s)\n    {\n        if(c >= 'A' && c <= 'Z')\n   \
    \         res += c;\n    }\n    return res;\n}", "{\n    import std.stdio;\n \
    \   long sum = 0;\n    for(int i = 0; i < s.length; i++)\n    {\n        if(toUpper(s[i])\
    \ == s[i])\n        {\n            sum += cast(long) s[i];\n        }\n    }\n\
    \    return sum;\n}", "{\n    long result = 0;\n    foreach(c; s)\n    {\n   \
    \     result += c & 31;\n    }\n    return result;\n}", "{\n    int sum = 0;\n\
    \    foreach(char c; s)\n    {\n        if(c >= 'A' && c <= 'Z')\n           \
    \ sum += cast(int)c;\n    }\n    return sum;\n}", "{\n    import std.algorithm\
    \ : map;\n    import std.range : iota;\n    return s.map!((c) => (char.isUpper(c)\
    \ ? c : 'a') - 'a').sum;\n}\n// Solution 2:", "{\n\tlong sum = 0;\n\tforeach(c;\
    \ s) \n\t{\n\t\tif (c.isUpper) \n\t\t{\n\t\t\tsum += (long)c;\n\t\t}\n\t}\n\t\
    return sum;\n}", "{\n    long result = 0;\n    foreach(c; s)\n    {\n       if(c\
    \ >= 'A' && c <= 'Z')\n           result += (long)c;\n    }\n    return result;\n\
    }\n/*\nTask\n    Write a function to compute the sum of the digits in a String.",
  "{\n    long sum = 0;\n    foreach(c; s)\n    {\n        sum += to!long(c) >= 65\
    \ && to!long(c) <= 90 ? to!long(c) : 0;\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    foreach(ch; s)\n    {\n        if(isUpper(ch))\n        {\n  \
    \          sum += ch;\n        }\n    }\n    return sum;\n}\n/*\nTask\n    Complete\
    \ the method/function so that it converts dash/underscore delimited words into\
    \ camel casing. \n    The first word within the output should be capitalized only\
    \ if the original word was capitalized.", "{\n    string up = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    char[] ch = up.dup;\n    long sum = 0;\n    foreach(c; s)\n    {\n    \
    \    if(ch.count(c)) sum += c;\n    }\n    return sum;\n}", "{\n    long sum =\
    \ 0;\n    foreach(c; s)\n    {\n        if(c >= 'A' && c <= 'Z')\n           \
    \ sum += c;\n    }\n    return sum;\n}", "{\n    auto sum = 0L;\n    foreach(c;\
    \ s)\n    {\n        if(c >= 'A' && c <= 'Z')\n            sum += c;\n    }\n\
    \    return sum;\n}", "{\n    return sum(iota(s.length)\n                    \
    \        .map!(idx => s[idx])\n                            .filter!(c => c.isUpper)\n\
    \                            .map!(c => c.to!long)\n                         \
    \   );\n}", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n        if(isUpper(c))\n\
    \        {\n            sum += c;\n        }\n    }\n    return sum;\n}", "{\n\
    \    long sum = 0;\n    foreach(c; s)\n    {\n        if(c > 'A' && c < 'Z')\n\
    \            sum += (cast(int)c);\n    }\n    return sum;\n}\n/*", "{\n    long\
    \ result = 0;\n    foreach(char c; s)\n    {\n        if (c >='A' && c <='Z')\n\
    \            result += c;\n    }\n    return result;\n}", "{\n    long res = 0;\n\
    \    foreach(char c; s) \n    {\n        if(c >= 'A' && c <= 'Z') \n        {\n\
    \            res += c;\n        }\n    }\n    return res;\n}", "{\n    return\
    \ s.map!(c => (c.isUpper) ? c.ord : 0).sum;\n}", "{\n    long out=0;\n    for(int\
    \ i=0;i<s.length;i++)\n    {\n        if(s[i]>=65 && s[i]<=90)\n        {\n  \
    \          out+=s[i];\n        }\n    }\n    return out;\n}", "{\n    return s.count!((char\
    \ ch) =>  ch >= 'A' && ch <= 'Z')().total!((ulong ch) => ch)();\n}", "{\n    long\
    \ sum = 0;\n    foreach(immutable c; s) \n    {\n        auto[lower, upper] =\
    \ to!(char[])(c).tupleof;\n        sum += c == lower ? 0 : (long)c;\n    }\n \
    \   return sum;\n}", "{\n    long res = 0;\n    foreach(c; s)\n    {\n       \
    \ if(c >= 'A' && c <= 'Z')\n            res += c;\n    }\n    return res;\n}",
  "{\n\treturn std.valarray(s.map!(c => c.isUpper ? c : '0').to!string).apply!(a =>\
    \ a - '0').sum;\n}", "{\n    import std.string;\n    return countUntil!(pred ==\
    \ 0)(map!(c => c.isUpper() ? c : 0)(s));\n}", "{\n    enum isNotUpper = (char\
    \ c) \n    {\n        return cast(uint)c < cast(uint)'A' || cast(uint)c > cast(uint)'Z';\n\
    \    };\n    long result = 0;\n    foreach(i, c; s)\n    {\n        if(!isNotUpper(c))\
    \ \n        {\n            result += cast(long)c;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long result = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ >= 'A' && c <= 'Z') result += c;\n    }\n    return result;\n}", "{\n    long\
    \ sum = 0;\n    foreach(i; s)\n    {\n        if (i >= 'A' && i <= 'Z')\n    \
    \        sum += i;\n    }\n    return sum;\n}\n/*\nTask\n    Write a function\
    \ that takes a string as input and returns the sum of the upper characters only.",
  "{\n    /*\n        If the given string is empty, return 0\n    */\n    if(s.empty)\n\
    \        return 0;\n    \n    /*\n        Create an array with the ASCII codes\
    \ of the given string.\n    */\n    auto ascii_list = map!(to!int)(s.idup);\n\
    \    \n    /*\n        Convert the ASCII codes to upper case, if they are not\
    \ upper case.\n    */\n    auto ascii_upper_list = map!((x) => x < 91 ? x : x\
    \ - 32)(ascii_list);\n    \n    /*\n        Filter out the characters that are\
    \ not between 65 and 90\n    */\n    auto filtered_ascii_list = filter!((x) =>\
    \ 65 <= x <= 90)(ascii_upper_list);\n    \n    /*\n        Sum the filtered characters.\n\
    \    */\n    auto result = reduce!((acc, x) => acc + x)(0, filtered_ascii_list);\n\
    \    \n    return result;\n}", "{\n    long sum = 0;\n    foreach(c; s)\n    {\n\
    \        if(isUpper(c))\n        {\n            sum += c;\n        }\n    }\n\
    \    return sum;\n}\n/*\nTask\n    Write a function that takes a string as input\
    \ and returns the sum of the lower characters only'\n    ASCII codes.", "{\n \
    \   long result=0;\n    foreach(c; s)\n    {\n        if(isUpper(c))\n       \
    \ {\n            result += int(c);\n        }\n    }\n    return result;\n}\n\
    /*\nTask\n    The task is to write a function that takes a string as an argument,\
    \ and returns the first character that is not repeated anywhere in the string.",
  "{\n    static if (__VERSION__ < 201602L) {\n        long sum = 0;\n        foreach\
    \ (c; s)\n            sum += isUpper(c) ? (cast(long)c) : 0;\n        return sum;\n\
    \    }\n    else {\n        return to!(long)(s.filter!(c => isUpper(c)).map!(c\
    \ => c));\n    }\n}", "{\n    int n = 0;\n    for (int i = 0; i < s.length; i++)\n\
    \    {\n        if ('A' <= s[i] && s[i] <= 'Z')\n        {\n            n += s[i];\n\
    \        }\n    }\n    return n;\n}", "{\n  auto sum = 0L;\n  auto isUpper = (char\
    \ c) => ('A' <= c) && (c <= 'Z');\n  foreach(c; filter!isUpper(s))\n  {\n    sum\
    \ += cast(long)c;\n  }\n  return sum;\n}", "{\n    long sum = 0;\n    foreach(char\
    \ ch; s) \n    {\n        if(toupper(ch) == ch) \n        {\n            sum +=\
    \ cast(long)ch;\n        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n\
    \    for (int i = 0; i < s.length; i++)\n    {\n        if (s[i] > 64 && s[i]\
    \ < 91)\n        {\n            sum += s[i];\n        }\n    }\n    return sum;\n\
    }", "{\n    int index = 0;\n    long sum = 0;\n    foreach(char c; s)\n    {\n\
    \        if(c >= 'A' && c <= 'Z')\n        {\n            sum += cast(long)c;\n\
    \        }\n    }\n    return sum;\n}", "{\n    return  s.filter!(a => a.isUpper).map!(a\
    \ => a.ord).reduce!((a, b) => a + b).sum;\n}", "{\n    long sum = 0;\n    foreach(c;\
    \ s)\n    {\n        if(isUpper(c))\n        {\n            sum += (long)c;\n\
    \        }\n    }\n    return sum;\n}", "{\n    auto sum = 0L;\n    foreach(i,\
    \ c; s) \n    {\n        sum += iota(0).take(s.length)\n                .filter!(i\
    \ => char.isUpper(s[i]))\n                .foldLeft(0, (a, b) => a + b);\n   \
    \ }\n    return sum;\n}", "{\n    long result = 0;\n    foreach(c; s)\n    {\n\
    \        if (toUpper(c) == c)\n        {\n            result += to!ulong(c);\n\
    \        }\n    }\n    return result;\n}", "{\n    long sum = 0;\n    for (char\
    \ c : s)\n    {\n        if (('A' <= c) && (c <= 'Z'))\n        {\n          \
    \  sum += cast(long)c;\n        }\n    }\n    return sum;\n}\n ", "{\n    long\
    \ sum = 0;\n    foreach(c; s)\n    {\n        //if it's in the range [65, 90]\n\
    \        if(c >= 'A' && c <= 'Z')\n        {\n            //convert it to a number\
    \ and add it to sum\n            sum += cast(long)c;\n        }\n    }\n    return\
    \ sum;\n}\n/*\nTask\n    Write a function that takes a string as input and returns\
    \ the sum of the ASCII codes of each character.", "{\n    long[] ascii = s.map!((in\
    \ c) => cast(long)c).filter!((in c) => c > 64 && c < 91).array;\n    return ascii.reduce!((a,\
    \ b) => a + b);\n}", "{\n    /*\n        Since we are only interested in the upper\
    \ chars, we can simply\n        convert the string to uppercase.\n        Then\
    \ we can map the chars to their corresponding integer value\n        by subtracting\
    \ 'A' which has an ASCII code of 65.\n    */\n    return s.toUpper().map!(a =>\
    \ a - 'A').sum;\n}", "{\n    int uppercase = 'A';\n    int lowercase = 'a';\n\
    \    long sum = 0;\n    foreach(c; s)\n    {\n        if(c >= uppercase && c <=\
    \ uppercase + 25)\n        {\n            sum += c;\n        }\n        else if(c\
    \ >= lowercase && c <= lowercase + 25)\n        {\n            sum += c - 32;\n\
    \        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(c;\
    \ s)\n    {\n        sum += isUpper(c) ? c : 0;\n    }\n    return sum;\n}", "{\n\
    \    long result = 0;\n    foreach(inout c; s)\n    {\n        if(c.isUpper)\n\
    \        {\n            result += c;\n        }\n    }\n    return result;\n}",
  "{\n    string ret = \"\";\n    foreach( i, char c; s ) {\n        if( c.isUpper\
    \ ) ret ~= c;\n    }\n    long total = 0;\n    foreach( char c; ret ) {\n    \
    \    total += c;\n    }\n    return total;\n}", "{\n    long sum = 0;\n    foreach(ch;\
    \ s) {\n        if(isUpper(ch)) sum += ch;\n    }\n    return sum;\n}", "{\n \
    \   long sum = 0;\n    foreach(c; s) {\n        if (c <= 'Z' && c >= 'A') {\n\
    \            sum += c;\n        }\n    }\n    return sum;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
