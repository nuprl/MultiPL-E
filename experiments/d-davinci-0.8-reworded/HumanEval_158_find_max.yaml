name: HumanEval_158_find_max
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
  \ an array of strings.\n    The array contains different words. Return the word\
  \ with maximum number\n    of unique characters. If multiple strings have maximum\
  \ number of unique\n    characters, return the one which comes first in lexicographical\
  \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n \
  \   >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
  aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
  \ words) \n"
tests: "unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
  , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
  , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"])\
  \ == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
  play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
  we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
  this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) ==\
  \ \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n\
  }\nvoid main(){}"
completions: ["{\n  string max = \"\";\n  int max_count = 0;\n  foreach(string word;\
    \ words)\n  {\n    int count = 0;\n    foreach(char c; word)\n    {\n      if(c\
    \ != '0')\n      {\n        count += 1;\n        word = replace(word, c, '0');\n\
    \      }\n    }\n    if(count > max_count)\n    {\n      max = word;\n      max_count\
    \ = count;\n    }\n  }\n  return max;\n}", "{\n    int max = 0;\n    string max_string\
    \ = words[0];\n    foreach(i, s; words) \n    {\n        int unique_count = 0;\n\
    \        foreach(c; s)\n        {\n            if(count(c, s) == 1)\n        \
    \    {\n                unique_count++;\n            }\n        }\n        if(unique_count\
    \ > max)\n        {\n            max = unique_count;\n            max_string =\
    \ s;\n        }\n    }\n    return max_string;\n}", "{\n    auto a = new string[];\n\
    \    int max_count = 0;\n    for (int i = 0; i < words.length; i++) \n    {\n\
    \        a ~= words[i];\n        auto c = count_unique(words[i]);\n        if\
    \ (c > max_count) \n        {\n            max_count = c;\n        }\n    }\n\
    \    auto b = new string[];\n    for (int i = 0; i < a.length; i++) \n    {\n\
    \        if (count_unique(a[i]) == max_count) \n        {\n            b ~= a[i];\n\
    \        }\n    }\n    return b[0];\n}", "{\n    struct word_t \n    {\n     \
    \   string word;\n        uint count;\n    }", "{\n    string result = \"\";\n\
    \    foreach(string word; words)\n    {\n        if(result.length < word.length)\n\
    \        {\n            auto set = new TypeTuple!char;\n            foreach(char\
    \ ch; word)\n            {\n                set.insert(ch);\n            }\n \
    \           if(result.length < set.length)\n            {\n                result\
    \ = word;\n            }\n        }\n    }\n    return result;\n}", "{\n    string\
    \ the_string;\n    int max_length = 0;\n    foreach(string a; words)\n    {\n\
    \        string tmp = \"\";\n        foreach(char c; a)\n        {\n         \
    \   if(!in(c, tmp))\n            {\n                tmp ~= c;\n            }\n\
    \        }\n        if(tmp.length > max_length)\n        {\n            max_length\
    \ = tmp.length;\n            the_string = a;\n        }\n    }\n    return the_string;\n\
    }", "{\n    string res = \"\";\n    int max = 0;\n    foreach(word; words)\n \
    \   {\n        int cnt = 0;\n        char[] ch = to!char[](word);\n        foreach(char\
    \ c; ch)\n        {\n            if (find(res, c) == -1) \n            {\n   \
    \             res ~= c;\n                cnt++;\n            }\n        }\n  \
    \      if (cnt > max) \n        {\n            max = cnt;\n            res = word;\n\
    \        }\n    }\n    return res;\n}", "{\n    //T[] sort(T,T)(T[] arr, T predicate)\n\
    \    words = words.sort;\n    string result;\n    int max = 0;\n    foreach(word;\
    \ words)\n    {\n        int count = 0;\n        for(int i = 0; i < word.length;\
    \ i++)\n        {\n            char c = word[i];\n            if(c >= 'a' && c\
    \ <= 'z')\n            {\n                count++;\n            }\n        }\n\
    \        if(count > max)\n        {\n            max = count;\n            result\
    \ = word;\n        }\n    }\n    return result;\n}", "{\n    string max_word;\n\
    \    auto max_unique_count = 0;\n    foreach(word; words)\n    {\n        auto\
    \ unique_count = 0;\n        auto c = word[0];\n        foreach(ch; word)\n  \
    \      {\n            if(c != ch)\n            {\n                unique_count++;\n\
    \                c = ch;\n            }\n        }\n        if(unique_count >=\
    \ max_unique_count)\n        {\n            max_unique_count = unique_count;\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}", "{\n\
    \    string max_w;\n    auto x = words.length;\n    uint max_len = x.max;\n  \
    \  foreach(i; 0 .. x.length)\n    {\n        uint tem = unique(words[i]).length;\n\
    \        if(tem == max_len)\n        {\n            if(words[i] < max_w)\n   \
    \         {\n                max_w = words[i];\n            }\n        }\n   \
    \     else if(tem > max_len)\n        {\n            max_len = tem;\n        \
    \    max_w = words[i];\n        }\n    }\n    return max_w;\n}", "{\n    immutable(string)\
    \ result;\n    size_t max_count = 0;\n    foreach(immutable(string) word; words)\n\
    \    {\n        size_t numOfUnique = 0;\n        foreach(immutable(char) c; word)\n\
    \        {\n            if(word.count(c) == 1)\n                numOfUnique++;\n\
    \        }\n        if(numOfUnique > max_count)\n        {\n            max_count\
    \ = numOfUnique;\n            result = word;\n        }\n    }\n    return result;\n\
    }", "{\n    string[] new_words = words.dup;\n    string[] new_words2 = words.dup;\n\
    \    foreach(ref word; new_words)\n    {\n        char[] letters;\n        foreach(c;\
    \ word)\n        {\n            if(c !in letters)\n            {\n           \
    \     letters ~= c;\n            }\n        }\n        //word = word.length;\n\
    \        word = letters.length;\n    }\n    int max = new_words[0];\n    foreach(word;\
    \ new_words)\n    {\n        if(word > max)\n        {\n            max = word;\n\
    \        }\n    }\n    string[] new_words3 = [];\n    foreach(word; new_words2)\n\
    \    {\n        char[] letters;\n        foreach(c; word)\n        {\n       \
    \     if(c !in letters)\n            {\n                letters ~= c;\n      \
    \      }\n        }\n        if(letters.length == max)\n        {\n          \
    \  new_words3 ~= word;\n        }\n    }\n    //new_words3.sort;\n    std.algorithm.sort(new_words3);\n\
    \    return new_words3[0];\n}", "{\n    int maxIndex = 0;\n    // iterate through\
    \ the words and find the one with the most unique characters\n    for (int i =\
    \ 1; i < words.length; i++) \n    {\n        int u1 = getUniqueCount(words[maxIndex]);\n\
    \        int u2 = getUniqueCount(words[i]);\n        // if equal, then compare\
    \ the lexicographic order\n        if (u1 < u2 || (u1 == u2 && words[maxIndex]\
    \ > words[i]))\n            maxIndex = i;\n    }\n    return words[maxIndex];\n\
    }", "{\n    assert(words.length > 0);\n    auto max_num_chars = 0;\n    auto result\
    \ = \"\";\n    foreach(word; words) \n    {\n        auto m = typeof(uniq(word)).init;\n\
    \        auto length = m.length;\n        if (length > max_num_chars) \n     \
    \   {\n            max_num_chars = length;\n            result = word;\n     \
    \   } \n        else if (length == max_num_chars) \n        {\n            result\
    \ = min(result, word);\n        }\n    }\n    return result;\n}", "{\n    string\
    \ best_word = words[0];\n    int best_word_num_unique_characters = num_unique_characters(best_word);\n\
    \    foreach(string word; words)\n    {\n        int word_num_unique_characters\
    \ = num_unique_characters(word);\n        if(word_num_unique_characters > best_word_num_unique_characters)\n\
    \        {\n            best_word = word;\n            best_word_num_unique_characters\
    \ = word_num_unique_characters;\n        }\n    }\n    return best_word;\n}",
  "{\n    int numberOfWords = words.length;\n    int[] counts = new int[numberOfWords];\n\
    \    int maxUnique = 0;\n    int maxWordIndex = 0;\n    foreach(index, word; words)\n\
    \    {\n        foreach(c; word)\n        {\n            if (c in (unique!char)(word))\n\
    \            {\n                counts[index]++;\n            }\n        }\n \
    \       if (counts[index] > maxUnique)\n        {\n            maxUnique = counts[index];\n\
    \            maxWordIndex = index;\n        }\n    }\n    return words[maxWordIndex];\n\
    }", "{\n    // create an array of type Tuple with the first element being the\
    \ number of\n    // different characters in a word (which is the function length(to!set(x)))\n\
    \    // and the second element being the word itself\n    Tuple!(int, string)[]\
    \ t = words.map!(x => tuple(length(to!set(x)), x));\n    // Sorts the array by\
    \ comparing the first element of each element in the \n    // array. Thus, you\
    \ can only compare elements of the same type.\n    // The last parameter is a\
    \ function that returns a -1 if the first element \n    // of the first element\
    \ is less than the first element of the second\n    // element, 0 if equal, and\
    \ 1 if greater.\n    // If the elements are equal, then it returns a -1 if the\
    \ second element\n    // of the first element comes first in lexicographical order,\
    \ 0 if equal,\n    // and 1 if greater.\n    t.sort!((a, b) => a[0] < b[0] ? -1\
    \ : (a[0] > b[0] ? 1 : (a[1] < b[1] ? -1 : (a[1] > b[1] ? 1 : 0))));\n    // returns\
    \ the second element of the last element in the array.\n    return t[$-1][1];\n\
    }", "{\n  int max_len = -1;\n  string max_string = \"\";\n  foreach(string word;\
    \ words) \n  {\n    int len = word.length;\n    if (len > max_len) \n    {\n \
    \     max_len = len;\n      max_string = word;\n    }\n  }\n  return max_string;\n\
    }", "{\n    auto result = reduce!((a,b) => a.length>b.length?a:b)(words);\n  \
    \  auto ln = result.length;\n    foreach(w; words)\n    {\n        if(w.length\
    \ == ln)\n        {\n            if(w < result) result = w;\n        }\n    }\n\
    \    return result;\n}", "{\n    int highest = 0;\n    string answer = \"\";\n\
    \    for (int i = 0; i < words.length; i++) \n    {\n        string temp = words[i];\n\
    \        int counter = 0;\n        for (int j = 0; j < temp.length; j++) \n  \
    \      {\n            for (int k = j + 1; k < temp.length; k++) \n           \
    \ {\n                if (temp[j] == temp[k]) \n                {\n           \
    \         counter++;\n                    break;\n                }\n        \
    \    }\n        }\n        if (counter == 0) \n        {\n            return temp;\n\
    \        }\n        else if (counter == highest) \n        {\n            if (temp\
    \ < answer) \n            {\n                answer = temp;\n            }\n \
    \       }\n        else if (counter > highest) \n        {\n            highest\
    \ = counter;\n            answer = temp;\n        }\n    }\n    return answer;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
