name: HumanEval_19_sort_numbers
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Input is a space-delimited string\
  \ of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two',\
  \ 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string\
  \ with numbers sorted from smallest to largest\n    >>> sort_numbers(\"three one\
  \ five\")\n    \"one three five\"\n    \n*/\nstring sort_numbers(string numbers)\
  \ \n"
tests: "unittest\n{\n    alias candidate = sort_numbers;\n\n    assert(candidate(\"\
  \") == \"\");\n    assert(candidate(\"three\") == \"three\");\n    assert(candidate(\"\
  three five nine\") == \"three five nine\");\n    assert(candidate(\"five zero four\
  \ seven nine eight\") == \"zero four five seven eight nine\");\n    assert(candidate(\"\
  six five four three two one zero\") == \"zero one two three four five six\");\n\
  }\nvoid main(){}"
completions: ["{\n    int maxLength = 0;\n    auto numArray = numbers.split();\n \
    \   maxLength = std.algorithm.maxElement!((a, b) => (a.length < b.length)).length;\n\
    \    auto toNumber = new int[numArray.length];\n    int counter = 0;\n    foreach(n;\
    \ numArray)\n    {\n        if(n == \"zero\")\n            toNumber[counter] =\
    \ 0;\n        else if(n == \"one\")\n            toNumber[counter] = 1;\n    \
    \    else if(n == \"two\")\n            toNumber[counter] = 2;\n        else if(n\
    \ == \"three\")\n            toNumber[counter] = 3;\n        else if(n == \"four\"\
    )\n            toNumber[counter] = 4;\n        else if(n == \"five\")\n      \
    \      toNumber[counter] = 5;\n        else if(n == \"six\")\n            toNumber[counter]\
    \ = 6;\n        else if(n == \"seven\")\n            toNumber[counter] = 7;\n\
    \        else if(n == \"eight\")\n            toNumber[counter] = 8;\n       \
    \ else if(n == \"nine\")\n            toNumber[counter] = 9;\n        counter++;\n\
    \    }\n    std.algorithm.sort!((a, b) => (a < b))(toNumber);\n    auto toString\
    \ = new string[numArray.length];\n    counter = 0;\n    foreach(n; toNumber)\n\
    \    {\n        if(n == 0)\n            toString[counter] = \"zero\";\n      \
    \  else if(n == 1)\n            toString[counter] = \"one\";\n        else if(n\
    \ == 2)\n            toString[counter] = \"two\";\n        else if(n == 3)\n \
    \           toString[counter] = \"three\";\n        else if(n == 4)\n        \
    \    toString[counter] = \"four\";\n        else if(n == 5)\n            toString[counter]\
    \ = \"five\";\n        else if(n == 6)\n            toString[counter] = \"six\"\
    ;\n        else if(n == 7)\n            toString[counter] = \"seven\";\n     \
    \   else if(n", "{\n\tstring[int] valid_numbers = [\"zero\" : 0, \"one\" : 1,\
    \ \"two\" : 2, \"three\" : 3, \"four\" : 4, \"five\" : 5, \"six\" : 6, \"seven\"\
    \ : 7, \"eight\" : 8, \"nine\" : 9];\n\tint[string] number_values;\n\tforeach(number;\
    \ numbers.split())\n\t{\n\t\tif(number in valid_numbers)\n\t\t{\n\t\t\tnumber_values[number]\
    \ = valid_numbers[number];\n\t\t}\n\t}\n\treturn join(sort(number_values.keys),\
    \ \" \");\n}", "{\n    enum Numeral {\n        zero, one, two, three, four, five,\
    \ six, seven, eight, nine\n    }\n    string[] m = numbers.split(\" \");\n   \
    \ string[] result;\n    result.length = m.length;\n    Numeral[] sorted;\n   \
    \ sorted.length = m.length;\n    foreach(i, e; m) {\n        sorted[i] = to!Numeral(e);\n\
    \    }\n    //reverse sort, so the highest is at front\n    //http://dlang.org/phobos/std_algorithm_sorting.html#.sort\n\
    \    sort!((a, b) => b < a)(sorted);\n    foreach(i, e; sorted) {\n        result[i]\
    \ = to!string(e);\n    }\n    return result.join(\" \");\n}", "{\n    const string\
    \ numeral_strings[] = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\"\
    , \"six\", \"seven\", \"eight\", \"nine\"];\n    auto numeral_to_int = numeral_strings.toHash;\n\
    \    //println(numeral_to_int);\n    auto numbers_array = numbers.split;\n   \
    \ //println(numbers_array);\n    auto string_to_int = (string str) {return to!int(numeral_to_int[str]);};\n\
    \    auto str_as_ints = numbers_array.map!string_to_int;\n    auto sorted_ints\
    \ = sort(str_as_ints);\n    //println(sorted_ints);\n    auto int_to_string =\
    \ (int num) {return numeral_strings[num];};\n    auto sorted_numbers = sorted_ints.map!int_to_string;\n\
    \    //println(sorted_numbers);\n    return sorted_numbers.join(\" \");\n}\n//sort_numbers(\"\
    three one five\");", "{\n    return sort(explode(numbers, \" \")).map!(to!string)();\n\
    }", "{\n    char[] numbers_char = numbers.dup;\n    string[] words = numbers.split;\n\
    \    int[] numbers_int = new int[words.length];\n    int num = 0;\n    foreach(string\
    \ n; words)\n    {\n        switch(n)\n        {\n            case \"zero\":\n\
    \                num = 0;\n                break;\n            case \"one\":\n\
    \                num = 1;\n                break;\n            case \"two\":\n\
    \                num = 2;\n                break;\n            case \"three\"\
    :\n                num = 3;\n                break;\n            case \"four\"\
    :\n                num = 4;\n                break;\n            case \"five\"\
    :\n                num = 5;\n                break;\n            case \"six\"\
    :\n                num = 6;\n                break;\n            case \"seven\"\
    :\n                num = 7;\n                break;\n            case \"eight\"\
    :\n                num = 8;\n                break;\n            case \"nine\"\
    :\n                num = 9;\n                break;\n        }\n        numbers_int\
    \ ~= num;\n    }\n    sort(numbers_int);\n    string number_str = \"\";\n    foreach(int\
    \ i; numbers_int)\n    {\n        switch(i)\n        {\n            case 0:\n\
    \                number_str ~= \"zero \";\n                break;\n          \
    \  case 1:\n                number_str ~= \"one \";\n                break;\n\
    \            case 2:\n                number_str ~= \"two \";\n              \
    \  break;\n            case 3:\n                number_str ~= \"three \";\n  \
    \              break;\n            case 4:\n                number_str ~= \"four\
    \ \";\n                break;\n            case 5:\n                number_str\
    \ ~= \"five \";\n                break;\n            case 6:\n               \
    \ number_str ~= \"six \";\n                break;\n            case 7:\n     \
    \           number_str ~= \"seven \";\n                break;\n            case\
    \ 8:\n                number_str ~= \"eight \";\n                break;\n    \
    \        case 9:\n                number_str ~= \"nine \";\n                break;\n\
    \        }\n    }\n    number_str.popBack;\n    return number_str;\n}\nstring",
  "{\n\tstring[int] numbers_map = [\"zero\":0, \"one\":1, \"two\":2, \"three\":3,\
    \ \"four\":4, \"five\":5, \"six\":6, \"seven\":7, \"eight\":8, \"nine\":9];\n\t\
    \n\tstring[] number_strings = numbers.split;\n\tint[] nums;\n\tforeach(n; number_strings)\
    \ {\n\t\tint num = numbers_map[n];\n\t\tnums ~= num;\n\t}\n\t\n\tsort(nums);\n\
    \t\n\tstring sorted_str = \"\";\n\tforeach(n; nums) {\n\t\tauto t = numbers_map.byValue(n);\n\
    \t\tif(t !is null) {\n\t\t\tsorted_str ~= t.key;\n\t\t\tsorted_str ~= \" \";\n\
    \t\t}\n\t}\n\t\n\treturn sorted_str;\n}", "{\n    int[] nums;\n    foreach(immutable\
    \ word; numbers.split)\n    {\n        enum TMP = to!(int)(word);\n        nums\
    \ ~= TMP;\n    }\n    sort(nums);\n    string tmp;\n    foreach(n; nums)\n   \
    \ {\n        enum t = to!(string)(n);\n        tmp ~= t;\n        tmp ~= \" \"\
    ;\n    }\n    return tmp;\n}", "{\n    string[] number_list = numbers.split(\"\
    \ \");\n    string result = \"\";\n    int[] keys = new int[number_list.length];\n\
    \    string[] temp = new string[number_list.length];\n    for (int i = 0; i <\
    \ number_list.length; i++)\n    {\n        temp[i] = number_list[i];\n       \
    \ switch (number_list[i])\n        {\n            case \"zero\": keys[i] = 0;\
    \ break;\n            case \"one\": keys[i] = 1; break;\n            case \"two\"\
    : keys[i] = 2; break;\n            case \"three\": keys[i] = 3; break;\n     \
    \       case \"four\": keys[i] = 4; break;\n            case \"five\": keys[i]\
    \ = 5; break;\n            case \"six\": keys[i] = 6; break;\n            case\
    \ \"seven\": keys[i] = 7; break;\n            case \"eight\": keys[i] = 8; break;\n\
    \            case \"nine\": keys[i] = 9; break;\n        }\n    }\n    sort(keys,\
    \ temp);\n    foreach (n; temp)\n    {\n        if (result == \"\")\n        \
    \    result = n;\n        else\n            result ~= \" \" ~ n;\n    }\n    return\
    \ result;\n}", "{\n    auto numeralNames = [\n        \"zero\", \"one\", \"two\"\
    , \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"\n   \
    \ ];\n    auto toNumeral = [](string numeral) { return numeralNames.indexOf(numeral);\
    \ };\n    auto toString = [](int numeral) { return numeralNames[numeral]; };\n\
    \    auto numberStrings = numbers.split(\" \");\n    auto numberNumbers = numberStrings.map!toNumeral;\n\
    \    numberNumbers.sort;\n    return numberNumbers.map!toString.join(\" \");\n\
    }", "{\n    string[] _numbers = numbers.split;\n    string[] _newNumbers = _numbers;\n\
    \    string[] _nums = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\"\
    , \"six\", \"seven\", \"eight\", \"nine\"];\n    for (int i = 0; i < _numbers.length;\
    \ i++) \n    {\n        for (int j = 0; j < _numbers.length; j++) \n        {\n\
    \            if (j != _numbers.length - 1) \n            {\n                if\
    \ (_nums.indexOf(_numbers[j]) > _nums.indexOf(_numbers[j + 1])) \n           \
    \     {\n                    string temp = _numbers[j];\n                    _numbers[j]\
    \ = _numbers[j + 1];\n                    _numbers[j + 1] = temp;\n          \
    \      }\n            }\n        }\n    }\n    return _numbers.join(\" \");\n}",
  "{\n\tauto numbers_arr = numbers.split(\" \");\n\tstring result;\n\tforeach(i; sort!((a,\
    \ b) => numeral_to_int(a) > numeral_to_int(b))(numbers_arr))\n\t{\n\t\tresult\
    \ ~= i ~ \" \";\n\t}\n\treturn result.stripRight();\n}", "{\n    return to!string(sort(map!(a\
    \ => to!int(a))(numbers.split())));\n}", "{\n    immutable numbers_map = [\"zero\"\
    , \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\"\
    , \"nine\"];\n    enum index = 0;\n    int[] keys = [];\n    auto tokens = numbers.split;\n\
    \    foreach(token; tokens)\n    {\n        keys ~= numbers_map.indexOf(token);\n\
    \    }\n    keys.sort;\n    string result = \"\";\n    foreach(key; keys)\n  \
    \  {\n        if(result.length > 0)\n        {\n            result ~= \" \";\n\
    \        }\n        result ~= numbers_map[key];\n    }\n    return result;\n}",
  "{\n    import std.math : min;\n    import std.algorithm : map, sort, filter;\n\
    \    import std.range : take;\n    import std.stdio : writeln;\n    import std.typecons\
    \ : tuple;\n    import std.conv : to;\n    import std.array : array;\n    import\
    \ std.traits : isIntegral;\n    import std.range : iota;\n    static immutable\
    \ number_names = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"\
    six\", \"seven\", \"eight\", \"nine\"];\n    auto number_sorted = numbers.split(\"\
    \ \")\n                                .map!(a =&gt; { auto result = number_names.indexOf(a);\
    \ return result; })\n                                .sort!((a, b) =&gt; { return\
    \ a &lt; b; })\n                                .map!(a =&gt; { return number_names[a];\
    \ });\n    return number_sorted.join(\" \");\n}\n</code>\nMy solution is working\
    \ fine and passes all the test cases. I wanted to know if there is a better way\
    \ of achieving the same result.\nAn inline solution would be fine too. ", "{\n\
    \    enum number = tuple(string str, int num);\n    const number[] nums = [ number(\"\
    zero\", 0),\n                            number(\"one\", 1),\n               \
    \             number(\"two\", 2),\n                            number(\"three\"\
    , 3),\n                            number(\"four\", 4),\n                    \
    \        number(\"five\", 5),\n                            number(\"six\", 6),\n\
    \                            number(\"seven\", 7),\n                         \
    \   number(\"eight\", 8),\n                            number(\"nine\", 9)];\n\
    \    \n    string[] parts = numbers.split();\n    int[] pos = new int[parts.length];\n\
    \    foreach(i,num; enumerate(parts))\n    {\n        foreach(j, n; enumerate(nums))\n\
    \        {\n            if(num == n.str)\n            {\n                pos[i]\
    \ = n.num;\n                break;\n            }\n        }\n    }\n    sort(pos);\n\
    \    foreach(i,num; enumerate(pos))\n    {\n        foreach(j, n; enumerate(nums))\n\
    \        {\n            if(num == n.num)\n            {\n                parts[i]\
    \ = n.str;\n                break;\n            }\n        }\n    }\n    return\
    \ join(parts, \" \");\n}\n//***************************************************************************************************************************\n\
    /*\n For a given positive integer N, a harmonic series is the sum of 1/i, where\
    \ i is the numerator and goes from 1 to N.\n    Given N, return the sum of the\
    \ harmonic series from 1 to N, inclusive.\n    >>> sum_harmonic(1)\n    1.0\n\
    \    \n*/\nfloat sum_harmonic(uint N) \n{\n    float sum = 0;\n    for(int i =\
    \ 1; i <= N; i++)\n    {\n        sum += 1.0 / i;\n    }\n    return sum;\n}\n\
    //***************************************************************************************************************************\n\
    /*\n The first player keeps rolling until she gets a total of at least 20.\n \
    \   The second player will then roll the remaining number of times necessary to\
    \ beat the first player's total.\n    If the first player rolls a 1, the second\
    \ player automatically wins.\n    If the second player ever rolls a 1,", "{\n\
    \    auto numbersArray = numbers.split(\" \");\n    sort(numbersArray);\n    return\
    \ join(numbersArray, \" \");\n}", "{\n    import std.algorithm.comparison : less;\n\
    \    int[] values = numbers.split.map!(to!int);\n    sort(values);\n    return\
    \ values.map!(to!string).join(\" \");\n}\n/*\n   Return a string with all non-alphabetic\
    \ characters replaced by spaces.\n   >>> strip_non_alphabet(\"This is a string!\
    \ w00t!\")\n   \"This is a string  w t \"\n*/\nstring strip_non_alphabet(string\
    \ text)\n{\n    import std.algorithm.iteration : filter;\n    return text.filter!isAlpha.joiner;\n\
    }\n/*\n   Return the word with the longest length from the string.\n   If there\
    \ is a tie, return the first word encountered in the string.\n   >>> longest_word(\"\
    This is a string\")\n   \"string\"\n*/\nstring longest_word(string text)\n{\n\
    \    return text.split.reduce!max.to!string;\n}\n/*\n   Return the indices of\
    \ all anagrams of the word in the list of words.\n   >>> get_anagram_indices(\"\
    listen\", [\"enlists\", \"google\", \"inlets\", \"banana\"])\n   [0, 3]\n*/",
  "{\n    auto tokens = split(numbers);", "{\n    if(!numbers) \n        return \"\
    \";\n    import std.conv : to;\n    string[] words = numbers.split;\n    int[]\
    \ nums;\n    foreach(x; words) \n    {\n        nums ~= to!int(x);\n    }\n  \
    \  nums.sort;\n    string ret = nums[0];\n    foreach(x; nums[1..$]) \n    {\n\
    \        ret ~= \" \" ~ x;\n    }\n    return ret;\n}\n/*\n    Write a function\
    \ isValid(formula) that takes a string, and returns whether or not it's a valid\n\
    \    chess board filling. Here's an example of a valid board filling:\n    >>>\
    \ isValid(\"wbwbwbwb/wbwbwbwb/wbwbwbwb/wbwbwbwb/wbwbwbwb/wbwbwbwb/wbwbwbwb/wbwbwbwb\"\
    )\n    True\n    >>> isValid(\"bbbbbbbb/wwwwwwww/bbbbbbbb/wwwwwwww/bbbbbbbb/wwwwwwww/bbbbbbbb/wwwwwwww\"\
    )\n    True\n    >>> isValid(\"bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrr\"\
    )\n    True\n    >>> isValid(\"bbbbbbbb/rrrrrrrr/bbbbbbbb/wwwwwwww/bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrr\"\
    )\n    False\n    >>> isValid(\"bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrw/bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrr\"\
    )\n    False\n    >>> isValid(\"rrrrrrrr/bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrr/bbbbbbbb\"\
    )\n    True\n    >>> isValid(\"rrrrrrrr/bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrr/bbbbbbbb/rrrrrrrr/wwwwwwww\"\
    )\n    False\n"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
