name: HumanEval_29_filter_by_prefix
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of strings\
  \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([], \"\
  a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\
  a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings,\
  \ string prefix) \n"
tests: "unittest\n{\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([],\
  \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
  , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
completions: ["{\n    return strings.filter!(s => s.startsWith(prefix));\n}\n/*\n\
    A convenience wrapper of std.array.filter which iterates over the array without\n\
    copying. It stores the indexes of the elements that satisfy the predicate in\n\
    reverse order, so that the final result can be obtained by copying the result\n\
    array in reverse.\n*/\nsize_t[] get_filtered_indexes(size_t[]! indices, alias\
    \ pred) \n{\n    assert(!indices.empty);\n    auto result = index_tuple();\n \
    \   foreach (size_t i; indices) \n    {\n        if (pred(i)) \n        {\n  \
    \          result ~= i;\n        }\n    }\n    return result.reverse;\n}", "{\n\
    \    return filter!(str => str.startsWith(prefix))(strings);\n}", "{\n    string[]\
    \ new_string = [];\n    foreach(i, string_to_filter; strings) \n    {\n      \
    \  if(startsWith(string_to_filter, prefix))\n        {\n            new_string\
    \ ~= string_to_filter;\n        }\n    }\n    return new_string;\n}", "{\n   \
    \ string[] ret_array;\n    foreach(string i; strings) \n    {\n        // Condition\
    \ to check whether the first character of a string matches with a given prefix.\n\
    \        if(i[0..prefix.length] == prefix)\n        {\n            ret_array ~=\
    \ i;\n        }\n    }\n    return ret_array;\n}", "{\n    if (prefix.empty) return\
    \ strings;\n    return strings.filter!(s => s.startsWith(prefix));\n}", "{\n\t\
    string[] result;\n\tforeach(s; strings) \n\t{\n\t\tif(s.length >= prefix.length\
    \ && s[0 .. prefix.length] == prefix) \n\t\t{\n\t\t\tresult ~= s;\n\t\t}\n\t}\n\
    \treturn result;\n}", "{\n    auto result = [];\n    foreach (string s; strings)\n\
    \    {\n        if (s.startsWith(prefix))\n        {\n            result ~= s;\n\
    \        }\n    }\n    return result;\n}\n/*\n Return the first element of a (nonempty)\
    \ array.\n    >>> first([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> first([])\n\
    \    Traceback (most recent call last):\n        ...\n    std.exception.AssertError:\
    \ Array is empty\n*/\nstring first(string[] strings)\n{\n    assert(strings.length\
    \ > 0);\n    return strings[0];\n}\n/*\n Attempt to convert a string to an int,\
    \ returning None if it fails.\n    >>> parse_int(\"10\")\n    10\n    >>> parse_int(\"\
    ten\")\n    None\n*/", "{\n\treturn strings.filter!(s => s.startsWith(prefix)).array;\n\
    }\n/*\n  Remove all elements from an array that satisfy some predicate.\n    >>>\
    \ remove_if([1,2,3,4,5], (x) => x % 2 == 0)\n    [1, 3, 5]\n*/\nT[] remove_if(T)(T[]\
    \ arr, bool delegate(T elem) dg) \n{\n\treturn arr.filter!(elem => !dg(elem)).array;\n\
    }\n/*\n  Return the union of two arrays.\n    >>> union([1,2,3], [3,4,5])\n  \
    \  [1, 2, 3, 4, 5]\n*/\nT[] union(T)(T[] arr1, T[] arr2) \n{\n\tT[] result = new\
    \ T[arr1.length + arr2.length];\n\tsize_t i = 0;\n\tforeach (elem; arr1) {\n\t\
    \tresult[i++] = elem;\n\t}\n\tforeach (elem; arr2) {\n\t\tresult[i++] = elem;\n\
    \t}\n\treturn result;\n}\n/*\n  Return the intersection of two arrays.\n    >>>\
    \ intersection([1,2,3], [3,4,5])\n    [3]\n*/\nT[] intersection(T)(T[] arr1, T[]\
    \ arr2) \n{\n\treturn arr1.filter!(elem => arr2.canFind(elem)).array;\n}\n/*\n\
    \  Flip the order of an array.\n    >>> flip([1,2,3])\n    [3, 2, 1]\n*/\nT[]\
    \ flip(T)(T[] arr) \n{\n\tT[] result = new T[arr.length];\n\tforeach (i, elem;\
    \ arr) {\n\t\tresult[arr.length - i - 1] = elem;\n\t}\n\treturn result;\n}\n/*\n\
    \  Append the elements of the second array to the first array.\n    >>> append([1,2,3],\
    \ [4,5,6])\n    [1, 2, 3, 4, 5, 6]\n*/\n", "{\n    auto filtered = new string[](strings.length);\n\
    \    auto i = 0;\n    foreach(string s; strings) \n    {\n        if (s.startsWith(prefix))\
    \ \n        {\n            filtered[i] = s;\n            i++;\n        }\n   \
    \ }\n    filtered.length = i;\n    return filtered;\n}", "{\n    string[] res;\n\
    \    foreach(s; strings) {\n        if(s.length > prefix.length && s[0..prefix.length]\
    \ == prefix)\n            res ~= s;\n    }\n    return res;\n}\n/*\n Reverse a\
    \ string of characters.\n    >>> reverse(\"abc\")\n    \"cba\"\n    >>> reverse(\"\
    a\")\n    \"a\"\n    >>> reverse(\"\")\n    \"\"\n    >>> reverse(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    \"zyxwvutsrqponmlkjihgfedcba\"\n*/\nstring reverse(string s) \n{\n    string\
    \ res;\n    auto it = s.length;\n    while(it--) {\n        res ~= s[it];\n  \
    \  }\n    return res;\n}\n/*\n Find the first occurrence of a substring in a string.\n\
    \    >>> find_first(\"abcdefghijklmnopqrstuvwxyz\", \"lmn\")\n    11\n    >>>\
    \ find_first(\"abcdefghijklmnopqrstuvwxyz\", \"hij\")\n    8\n    >>> find_first(\"\
    abcdefghijklmnopqrstuvwxyz\", \"abc\")\n    0\n    >>> find_first(\"abcdefghijklmnopqrstuvwxyz\"\
    , \"xyz\")\n    23\n    >>> find_first(\"abcdefghijklmnopqrstuvwxyz\", \"hello\"\
    )\n    -1\n    >>> find_first(\"abcdefghijklmnopqrstuvwxyz\", \"\")\n    -1\n\
    \    >>> find_first(\"\", \"hello\")\n    -1\n*/", "    if(isInputRange!string\
    \ && is(ElementType!string : string)) \n{\n    string[] result;\n    foreach(index,\
    \ element; strings) \n    {\n        if(element.startsWith(prefix)) \n       \
    \ {\n            result ~= element;\n        }\n    }\n    return result;\n}\n\
    /*\n Compute the distance between two points in 2D space.\n    >>> compute_distance((0,\
    \ 0), (1, 1))\n    1.4142135623730951\n*/\ndouble compute_distance(Tuple!(double,\
    \ double) point1, Tuple!(double, double) point2) \n    if(is(Tuple!(double, double)\
    \ : Tuple!(double, double)) && is(Tuple!(double, double) : Tuple!(double, double)))\
    \ \n{\n    import std.math;\n    return sqrt((point1[0] - point2[0]) ** 2 + (point1[1]\
    \ - point2[1]) ** 2);\n}\n/*\n Compute the total distance across a sequence of\
    \ points in 2D space.\n    >>> compute_total_distance([(0, 0), (1, 1), (3, 4)])\n\
    \    6.164414002968976\n*/\ndouble compute_total_distance(Tuple!(double, double)[]\
    \ points) \n    if(isInputRange!(Tuple!(double, double)) && is(ElementType!(Tuple!(double,\
    \ double)) : Tuple!(double, double))) \n{\n    import std.range;\n    double distance\
    \ = 0;\n    foreach(a, b; zip(points, points[1 .. $])) \n    {\n        distance\
    \ += compute_distance(a, b);\n    }\n    return distance;\n}\n/*\n Find the nearest\
    \ neighbor to an input point in a list of points.\n    >>> find_nearest_neighbor((0,\
    \ 0), [(1, 1), (3, 4), (1, 2)])\n    (1, 1)\n*/\nTuple!(double, double) find_nearest_neighbor(Tuple!(double,\
    \ double) point, Tuple!(", "in { assert(prefix.length > 0); }\nout (result) {\
    \ assert(result.canFind(prefix)); }\ndo\n{\n    string[] result;\n    foreach\
    \ (string s; strings)\n    {\n        if (s.startsWith(prefix))\n        {\n \
    \           result ~= s;\n        }\n    }\n    return result;\n}\n/*\nFind the\
    \ maximum element in an array of ints.\n    >>> max_array([])\n    -1\n    >>>\
    \ max_array([1, 2, 3])\n    3\n    >>> max_array([10, 20, 3])\n    20\n    \n\
    */", "{\n    string[] filtered_list;\n    foreach(string s; strings)\n    {\n\
    \        if(s.startsWith(prefix))\n        {\n            filtered_list ~= s;\n\
    \        }\n    }\n    return filtered_list;\n}", "{\n    return strings.filter!(s\
    \ => s.startsWith(prefix)).array;\n}", "{\n    int n = strings.length;\n    //\
    \ Create a string builder with `n` elements.\n    Appender!(string[]) builder\
    \ = appender(strings);\n    foreach (ref s; strings) {\n        // Append the\
    \ element to the string builder if it starts with the prefix.\n        if (s.startsWith(prefix))\
    \ {\n            builder.put(s);\n        }\n    }\n    // Return the constructed\
    \ array.\n    return builder.data;\n}", "{\n    string[] filtered_strings;\n \
    \   foreach(string s; strings) \n    {\n        if(s.length > 0 && s[0] == prefix[0])\n\
    \            filtered_strings ~= s;\n    }\n    return filtered_strings;\n}\n\
    /*\n    >>> fibonacci_gen(0)\n    []\n    >>> fibonacci_gen(1)\n    [0]\n    >>>\
    \ fibonacci_gen(2)\n    [0, 1]\n    >>> fibonacci_gen(5)\n    [0, 1, 1, 2, 3]\n\
    */", "{\n    return filter!(p => p.startsWith(prefix))(strings);\n}\n/*\n Filter\
    \ an input array of strings only for ones that start with a given prefix.\n  \
    \  >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n    [\"bcd\"]\n*/\nstring[] filter_by_prefix_in_a_particular_order(string[]\
    \ strings, string prefix) \n{\n    return filter!(p => p.startsWith(prefix))(strings.sorted);\n\
    }\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    >>>\
    \ filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n    [\"bcd\"\
    ]\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"z\")\n \
    \   []\n*/\nstring[] filter_by_prefix_in_an_even_better_order(string[] strings,\
    \ string prefix) \n{\n    return prefix.empty ? [] : filter!(p => p.startsWith(prefix))(strings.sorted);\n\
    }\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    >>>\
    \ filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n    [\"bcd\"\
    ]\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"z\")\n \
    \   []\n    >>> filter_by_prefix([\"bcd\",", "{\n    return strings.filter!(a\
    \ => a.startsWith(prefix));\n}", "{\n    return strings.filter!(x => x.startsWith(prefix));\n\
    }", "{\n    immutable size_t prefix_len = prefix.length;\n    return strings.filter!(a\
    \ => a.startsWith(prefix))();\n}\n/*\n Filter a list of strings based on a test\
    \ function.\n    >>> filter_by_function([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], (a) => a.length == 3)\n    [\"abc\", \"bcd\"]\n    >>> filter_by_function([\"\
    abc\", \"bcd\", \"cde\", \"array\"], (a) => a.length == 4)\n    [\"cde\", \"array\"\
    ]\n    \n*/\nT[] filter_by_function(T)(T[] strings, bool test(T str)) if (isArray!T)\n\
    {\n    return strings.filter!test();\n}\n/*\n Get a new array of all the square\
    \ roots for the values in an array.\n    >>> array_of_square_roots([])\n    []\n\
    \    >>> array_of_square_roots([1.0, 4.0, 9.0])\n    [1.0, 2.0, 3.0]\n    \n*/\n\
    double[] array_of_square_roots(double[] arr)\n{\n    return arr.map!(a => sqrt(a))();\n\
    }\n/*\n Get a new array of all the square roots for the values in an array.\n\
    \    >>> array_of_square_roots([])\n    []\n    >>> array_of_square_roots([1.0,\
    \ 4.0, 9.0])\n    [1.0, 2.0, 3.0]\n    \n*/\ndouble[] array_of_square_roots(double[]\
    \ arr)\n{\n    return arr.map!(a => sqrt(a))();\n}\n/*\n Modify the original array\
    \ to change the value at a specified index.\n    >>> modify_array([], 1, 12.3)\n\
    \    []\n    >>> modify_array([1.0, 2.0, 3.0], 1, 12.3)\n    [1.0, 12.3, 3.0]\n\
    \    \n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
