name: HumanEval_29_filter_by_prefix
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of strings\
  \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([], \"\
  a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\
  a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings,\
  \ string prefix) \n"
tests: "unittest\n{\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([],\
  \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
  , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
completions: ["{\n    return strings.filter!(s => s.startsWith(prefix));\n}\n/*\n\
    A convenience wrapper of std.array.filter which iterates over the array without\n\
    copying. It stores the indexes of the elements that satisfy the predicate in\n\
    reverse order, so that the final result can be obtained by copying the result\n\
    array in reverse.\n*/\nsize_t[] get_filtered_indexes(size_t[]! indices, alias\
    \ pred) \n{\n    assert(!indices.empty);\n    auto result = index_tuple();\n \
    \   foreach (size_t i; indices) \n    {\n        if (pred(i)) \n        {\n  \
    \          result ~= i;\n        }\n    }\n    return result.reverse;\n}", "{\n\
    \    return filter!(str => str.startsWith(prefix))(strings);\n}", "{\n    string[]\
    \ new_string = [];\n    foreach(i, string_to_filter; strings) \n    {\n      \
    \  if(startsWith(string_to_filter, prefix))\n        {\n            new_string\
    \ ~= string_to_filter;\n        }\n    }\n    return new_string;\n}", "{\n   \
    \ string[] ret_array;\n    foreach(string i; strings) \n    {\n        // Condition\
    \ to check whether the first character of a string matches with a given prefix.\n\
    \        if(i[0..prefix.length] == prefix)\n        {\n            ret_array ~=\
    \ i;\n        }\n    }\n    return ret_array;\n}", "{\n    if (prefix.empty) return\
    \ strings;\n    return strings.filter!(s => s.startsWith(prefix));\n}", "{\n\t\
    string[] result;\n\tforeach(s; strings) \n\t{\n\t\tif(s.length >= prefix.length\
    \ && s[0 .. prefix.length] == prefix) \n\t\t{\n\t\t\tresult ~= s;\n\t\t}\n\t}\n\
    \treturn result;\n}", "{\n    auto result = [];\n    foreach (string s; strings)\n\
    \    {\n        if (s.startsWith(prefix))\n        {\n            result ~= s;\n\
    \        }\n    }\n    return result;\n}\n/*\n Return the first element of a (nonempty)\
    \ array.\n    >>> first([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> first([])\n\
    \    Traceback (most recent call last):\n        ...\n    std.exception.AssertError:\
    \ Array is empty\n*/\nstring first(string[] strings)\n{\n    assert(strings.length\
    \ > 0);\n    return strings[0];\n}\n/*\n Attempt to convert a string to an int,\
    \ returning None if it fails.\n    >>> parse_int(\"10\")\n    10\n    >>> parse_int(\"\
    ten\")\n    None\n*/", "{\n\treturn strings.filter!(s => s.startsWith(prefix)).array;\n\
    }\n/*\n  Remove all elements from an array that satisfy some predicate.\n    >>>\
    \ remove_if([1,2,3,4,5], (x) => x % 2 == 0)\n    [1, 3, 5]\n*/\nT[] remove_if(T)(T[]\
    \ arr, bool delegate(T elem) dg) \n{\n\treturn arr.filter!(elem => !dg(elem)).array;\n\
    }\n/*\n  Return the union of two arrays.\n    >>> union([1,2,3], [3,4,5])\n  \
    \  [1, 2, 3, 4, 5]\n*/\nT[] union(T)(T[] arr1, T[] arr2) \n{\n\tT[] result = new\
    \ T[arr1.length + arr2.length];\n\tsize_t i = 0;\n\tforeach (elem; arr1) {\n\t\
    \tresult[i++] = elem;\n\t}\n\tforeach (elem; arr2) {\n\t\tresult[i++] = elem;\n\
    \t}\n\treturn result;\n}\n/*\n  Return the intersection of two arrays.\n    >>>\
    \ intersection([1,2,3], [3,4,5])\n    [3]\n*/\nT[] intersection(T)(T[] arr1, T[]\
    \ arr2) \n{\n\treturn arr1.filter!(elem => arr2.canFind(elem)).array;\n}\n/*\n\
    \  Flip the order of an array.\n    >>> flip([1,2,3])\n    [3, 2, 1]\n*/\nT[]\
    \ flip(T)(T[] arr) \n{\n\tT[] result = new T[arr.length];\n\tforeach (i, elem;\
    \ arr) {\n\t\tresult[arr.length - i - 1] = elem;\n\t}\n\treturn result;\n}\n/*\n\
    \  Append the elements of the second array to the first array.\n    >>> append([1,2,3],\
    \ [4,5,6])\n    [1, 2, 3, 4, 5, 6]\n*/\n", "{\n    auto filtered = new string[](strings.length);\n\
    \    auto i = 0;\n    foreach(string s; strings) \n    {\n        if (s.startsWith(prefix))\
    \ \n        {\n            filtered[i] = s;\n            i++;\n        }\n   \
    \ }\n    filtered.length = i;\n    return filtered;\n}", "{\n    string[] res;\n\
    \    foreach(s; strings) {\n        if(s.length > prefix.length && s[0..prefix.length]\
    \ == prefix)\n            res ~= s;\n    }\n    return res;\n}\n/*\n Reverse a\
    \ string of characters.\n    >>> reverse(\"abc\")\n    \"cba\"\n    >>> reverse(\"\
    a\")\n    \"a\"\n    >>> reverse(\"\")\n    \"\"\n    >>> reverse(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    \"zyxwvutsrqponmlkjihgfedcba\"\n*/\nstring reverse(string s) \n{\n    string\
    \ res;\n    auto it = s.length;\n    while(it--) {\n        res ~= s[it];\n  \
    \  }\n    return res;\n}\n/*\n Find the first occurrence of a substring in a string.\n\
    \    >>> find_first(\"abcdefghijklmnopqrstuvwxyz\", \"lmn\")\n    11\n    >>>\
    \ find_first(\"abcdefghijklmnopqrstuvwxyz\", \"hij\")\n    8\n    >>> find_first(\"\
    abcdefghijklmnopqrstuvwxyz\", \"abc\")\n    0\n    >>> find_first(\"abcdefghijklmnopqrstuvwxyz\"\
    , \"xyz\")\n    23\n    >>> find_first(\"abcdefghijklmnopqrstuvwxyz\", \"hello\"\
    )\n    -1\n    >>> find_first(\"abcdefghijklmnopqrstuvwxyz\", \"\")\n    -1\n\
    \    >>> find_first(\"\", \"hello\")\n    -1\n*/", "    if(isInputRange!string\
    \ && is(ElementType!string : string)) \n{\n    string[] result;\n    foreach(index,\
    \ element; strings) \n    {\n        if(element.startsWith(prefix)) \n       \
    \ {\n            result ~= element;\n        }\n    }\n    return result;\n}\n\
    /*\n Compute the distance between two points in 2D space.\n    >>> compute_distance((0,\
    \ 0), (1, 1))\n    1.4142135623730951\n*/\ndouble compute_distance(Tuple!(double,\
    \ double) point1, Tuple!(double, double) point2) \n    if(is(Tuple!(double, double)\
    \ : Tuple!(double, double)) && is(Tuple!(double, double) : Tuple!(double, double)))\
    \ \n{\n    import std.math;\n    return sqrt((point1[0] - point2[0]) ** 2 + (point1[1]\
    \ - point2[1]) ** 2);\n}\n/*\n Compute the total distance across a sequence of\
    \ points in 2D space.\n    >>> compute_total_distance([(0, 0), (1, 1), (3, 4)])\n\
    \    6.164414002968976\n*/\ndouble compute_total_distance(Tuple!(double, double)[]\
    \ points) \n    if(isInputRange!(Tuple!(double, double)) && is(ElementType!(Tuple!(double,\
    \ double)) : Tuple!(double, double))) \n{\n    import std.range;\n    double distance\
    \ = 0;\n    foreach(a, b; zip(points, points[1 .. $])) \n    {\n        distance\
    \ += compute_distance(a, b);\n    }\n    return distance;\n}\n/*\n Find the nearest\
    \ neighbor to an input point in a list of points.\n    >>> find_nearest_neighbor((0,\
    \ 0), [(1, 1), (3, 4), (1, 2)])\n    (1, 1)\n*/\nTuple!(double, double) find_nearest_neighbor(Tuple!(double,\
    \ double) point, Tuple!(", "in { assert(prefix.length > 0); }\nout (result) {\
    \ assert(result.canFind(prefix)); }\ndo\n{\n    string[] result;\n    foreach\
    \ (string s; strings)\n    {\n        if (s.startsWith(prefix))\n        {\n \
    \           result ~= s;\n        }\n    }\n    return result;\n}\n/*\nFind the\
    \ maximum element in an array of ints.\n    >>> max_array([])\n    -1\n    >>>\
    \ max_array([1, 2, 3])\n    3\n    >>> max_array([10, 20, 3])\n    20\n    \n\
    */", "{\n    string[] filtered_list;\n    foreach(string s; strings)\n    {\n\
    \        if(s.startsWith(prefix))\n        {\n            filtered_list ~= s;\n\
    \        }\n    }\n    return filtered_list;\n}", "{\n    return strings.filter!(s\
    \ => s.startsWith(prefix)).array;\n}", "{\n    int n = strings.length;\n    //\
    \ Create a string builder with `n` elements.\n    Appender!(string[]) builder\
    \ = appender(strings);\n    foreach (ref s; strings) {\n        // Append the\
    \ element to the string builder if it starts with the prefix.\n        if (s.startsWith(prefix))\
    \ {\n            builder.put(s);\n        }\n    }\n    // Return the constructed\
    \ array.\n    return builder.data;\n}", "{\n    string[] filtered_strings;\n \
    \   foreach(string s; strings) \n    {\n        if(s.length > 0 && s[0] == prefix[0])\n\
    \            filtered_strings ~= s;\n    }\n    return filtered_strings;\n}\n\
    /*\n    >>> fibonacci_gen(0)\n    []\n    >>> fibonacci_gen(1)\n    [0]\n    >>>\
    \ fibonacci_gen(2)\n    [0, 1]\n    >>> fibonacci_gen(5)\n    [0, 1, 1, 2, 3]\n\
    */", "{\n    return filter!(p => p.startsWith(prefix))(strings);\n}\n/*\n Filter\
    \ an input array of strings only for ones that start with a given prefix.\n  \
    \  >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n    [\"bcd\"]\n*/\nstring[] filter_by_prefix_in_a_particular_order(string[]\
    \ strings, string prefix) \n{\n    return filter!(p => p.startsWith(prefix))(strings.sorted);\n\
    }\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    >>>\
    \ filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n    [\"bcd\"\
    ]\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"z\")\n \
    \   []\n*/\nstring[] filter_by_prefix_in_an_even_better_order(string[] strings,\
    \ string prefix) \n{\n    return prefix.empty ? [] : filter!(p => p.startsWith(prefix))(strings.sorted);\n\
    }\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    >>>\
    \ filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n    [\"bcd\"\
    ]\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"z\")\n \
    \   []\n    >>> filter_by_prefix([\"bcd\",", "{\n    return strings.filter!(a\
    \ => a.startsWith(prefix));\n}", "{\n    return strings.filter!(x => x.startsWith(prefix));\n\
    }", "{\n    immutable size_t prefix_len = prefix.length;\n    return strings.filter!(a\
    \ => a.startsWith(prefix))();\n}\n/*\n Filter a list of strings based on a test\
    \ function.\n    >>> filter_by_function([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], (a) => a.length == 3)\n    [\"abc\", \"bcd\"]\n    >>> filter_by_function([\"\
    abc\", \"bcd\", \"cde\", \"array\"], (a) => a.length == 4)\n    [\"cde\", \"array\"\
    ]\n    \n*/\nT[] filter_by_function(T)(T[] strings, bool test(T str)) if (isArray!T)\n\
    {\n    return strings.filter!test();\n}\n/*\n Get a new array of all the square\
    \ roots for the values in an array.\n    >>> array_of_square_roots([])\n    []\n\
    \    >>> array_of_square_roots([1.0, 4.0, 9.0])\n    [1.0, 2.0, 3.0]\n    \n*/\n\
    double[] array_of_square_roots(double[] arr)\n{\n    return arr.map!(a => sqrt(a))();\n\
    }\n/*\n Get a new array of all the square roots for the values in an array.\n\
    \    >>> array_of_square_roots([])\n    []\n    >>> array_of_square_roots([1.0,\
    \ 4.0, 9.0])\n    [1.0, 2.0, 3.0]\n    \n*/\ndouble[] array_of_square_roots(double[]\
    \ arr)\n{\n    return arr.map!(a => sqrt(a))();\n}\n/*\n Modify the original array\
    \ to change the value at a specified index.\n    >>> modify_array([], 1, 12.3)\n\
    \    []\n    >>> modify_array([1.0, 2.0, 3.0], 1, 12.3)\n    [1.0, 12.3, 3.0]\n\
    \    \n*/", "{\n    string[] result;\n    foreach(string s; strings) \n    {\n\
    \        if(s.startsWith(prefix)) \n        {\n            result ~= s;\n    \
    \    }\n    }\n    return result;\n}\n/*", "{\n    auto results = [\"\"];\n  \
    \  foreach(str; strings) {\n        if(str.startsWith(prefix)) results ~= str;\n\
    \    }\n    return results;\n}", "{\n    return filter!(a => a.startsWith(prefix))(strings);\n\
    }\n//Exercice 2\n/*\nTake the string representation of an array of numbers and\
    \ convert it to a number array.\n    >>> convert_to_int_array(\"[1, 2, 3]\")\n\
    \    [1, 2, 3]\n    >>> convert_to_int_array(\"[-2, -2, 3]\")\n    [-2, -2, 3]\n\
    \    >>> convert_to_int_array(\"[0, 0, 0]\")\n    [0, 0, 0]", "{\n\tauto filtered\
    \ = filter!((string s) => s.startsWith(prefix))(strings);\n\treturn filtered.array;\n\
    }\n/*\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]", "{\n \
    \   return filter!(string s => s.startsWith(prefix))(strings);\n}\n/*\n Create\
    \ an associative array based on a given array of arrays.\n \n Each inner array\
    \ should be of the form [key, value].\n    >>> aa_from_aaa([])\n    []\n    >>>\
    \ aa_from_aaa([[\"a\", \"b\"], [\"c\", \"d\"]])\n    [\"a\": \"b\", \"c\": \"\
    d\"]\n    >>> aa_from_aaa([[\"a\", \"b\"], [\"c\", \"d\"], [\"a\", \"e\"]])\n\
    \    [\"a\": \"e\", \"c\": \"d\"]\n    \n*/\nTuple!(TKey, TValue)[][TKey, TValue]\
    \ aa_from_aaa(Tuple!(TKey, TValue)[][] tts) \n{\n    return tts.array;\n}\n/*\n\
    \ Create an associative array from a given array of arrays, where the first\n\
    \ inner array is the keys and the second is the values.\n    >>> aa_from_key_value_arrays([],\
    \ [])\n    []\n    >>> aa_from_key_value_arrays([\"a\", \"b\"], [\"c\", \"d\"\
    ])\n    [\"a\": \"c\", \"b\": \"d\"]\n    >>> aa_from_key_value_arrays([\"a\"\
    , \"b\"], [\"c\", \"d\", \"e\"])\n    [\"a\": \"c\", \"b\": \"d\"]\n    \n*/\n\
    TKey[][TKey, TValue] aa_from_key_value_arrays(TKey[] keys, TValue[] values) \n\
    {\n    return keys.zip(values).array;\n}\n/*\n Find the first value in an array\
    \ that satisfies a given predicate.\n    >>> find_first([1, 2, 3], e => e > 2)\n\
    \    3\n    >>> find_first([1, 2, 3], e => e > 4)\n    0\n    \n*/\nT find_first(T[]\
    \ arr, Predicate!T predicate) \n{\n    return arr.filter!predicate[0];\n}\n/*\n\
    \ Find the value in an array of arrays", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }", "{\n    string[] result;\n    foreach(string s; strings) \n    {\n       \
    \ if(s.startsWith(prefix)) \n        {\n            result ~= s;\n        }\n\
    \    }\n    return result;\n}", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }", "    in \n    {\n        assert(prefix.length > 0);\n    }\n    body\n   \
    \ {\n        string[] ret;\n        foreach(str; strings)\n        {\n       \
    \     if(str.startsWith(prefix)) ret ~= str;\n        }\n        return ret;\n\
    \    }\n    ", "{\n    import std.algorithm : filter;\n    return strings.filter!(s\
    \ => s.startsWith(prefix)).array;\n}\n/*\nList the names of files in a directory\
    \ tree matching a given suffix.\n*/\nstring[] list_files_in_dir(string path, string\
    \ suffix) \n{\n    import std.file : readdir, canonicalize;\n    import std.path\
    \ : dirEntries, filters, splitter;\n    import std.stdio : writeln;\n    string[]\
    \ files;\n    foreach (path; dirEntries(path)) \n    {\n        string p = to!string(path);\n\
    \        if (p.isDir) \n        {\n            files ~= list_files_in_dir(p, suffix);\n\
    \        } \n        else if (p.splitter(\".\").back == suffix) \n        {\n\
    \            files ~= p;\n        }\n    }\n    return files;\n}\n/*\nClass for\
    \ saving and loading data to and from the filesystem.\n*/\n@safe abstract class\
    \ BaseDataset \n{\n\tabstract File toFile();\n    abstract void fromFile(File\
    \ f);\n    File saveTo(string filename) \n    {\n        File f = File(filename,\
    \ \"w\");\n        f.write(this.toFile());\n        return f;\n    }\n    void\
    \ loadFrom(string filename) \n    {\n        File f = File(filename, \"r\");\n\
    \        this.fromFile(f);\n    }\n}\n@safe abstract class BaseGrammar \n{\n \
    \   abstract File toFile();\n    abstract void fromFile(File f);\n    File saveTo(string\
    \ filename) \n    {\n        File f = File(filename, \"w\");\n        f.write(this.toFile());\n\
    \        return f;\n    }\n    void loadFrom(string filename) \n    {\n      \
    \  File f = File(filename, \"r\");\n        this.fromFile(f);\n    }\n}\n/*\n\
    Generic class for `File`, `String`, `stdout` and `stderr`.\n*/\nstruct Writer\
    \ \n{\n    ubyte[] buffer;\n    char[] buffer2;\n    string filename;", "{\n \
    \   return filter!(a => a.startsWith(prefix))(strings);\n}", "{\n    return strings.filter!(a\
    \ => a.startsWith(prefix));\n}\n/*\nTally an array of floating point numbers by\
    \ each of their integer components.\n    >>> tally([1.0, 2.5, 3.0, 2.5, 2.5, 1.0])\n\
    \    [1: 2, 2: 3, 3: 1]\n*/\nsize_t[size_t] tally(real[] list)\n{\n    size_t[size_t]\
    \ counter;\n    foreach(x; list)\n    {\n        ++counter[cast(size_t)x];\n \
    \   }\n    return counter;\n}\n/*\n Split an input array into an array of arrays\
    \ based on a given element count.\n    >>> split_by_elems([], 3)\n    []\n   \
    \ >>> split_by_elems([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)\n    [[1, 2, 3], [4, 5, 6],\
    \ [7, 8, 9]]\n*/\nT[][] split_by_elems(T)(T[] input, size_t elems) \n{\n    size_t\
    \ chunks = ceil(input.length / elems);\n    T[][] output;\n    output.length =\
    \ chunks;\n    size_t chunkIdx = 0;\n    size_t chunkIdx = 0;\n    foreach(elem;\
    \ input)\n    {\n        output[chunkIdx] ~= elem;\n        if(++chunkIdx % elems\
    \ == 0)\n        {\n            chunkIdx = 0;\n        }\n    }\n    return output;\n\
    }\n/*\n Find the most common element in a list.\n    >>> most_common([1, 1, 2,\
    \ 3, 4, 1, 2, 1, 1])\n    1\n*/\nT most_common(T)(T[] list)\n{\n    T[T] counter;\n\
    \    foreach(x; list)\n    {\n        ++counter[x];\n    }\n    return counter.byValue[1].key;\n\
    }", "{\n    return strings.filter!(s => s.startsWith(prefix));\n}\n/*\n Test that\
    \ all strings in an array start with a given prefix.\n    >>> all_start_with_prefix([],\
    \ \"a\")\n    true\n    >>> all_start_with_prefix([\"abc\", \"bcd\", \"cde\",\
    \ \"array\"], \"a\")\n    false\n    >>> all_start_with_prefix([\"abc\", \"aardvark\"\
    , \"accent\", \"array\"], \"a\")\n    true\n*/", "{\n\treturn strings.filter!(s\
    \ => s.startsWith(prefix));\n}", "{\n\tauto l = strings.filter!(a => a.startsWith(prefix));\n\
    \treturn l;\n}\n/*\n `parse_int` is a function that parses an integer from a string.\n\
    \ If the string is not a valid integer, it returns a `none`\n value. Otherwise,\
    \ it returns the integer.\n    >>> parse_int(\"-3\")\n    -3\n    >>> parse_int(\"\
    abc\")\n    none\n*/\nauto parse_int(string s) \n{\n\t// Write your code here\n\
    \tint ret;\n\tint res = s.to!int(ret);\n\tif (res != 0)\n\t\treturn none;\n\t\
    return ret;\n}", "{\n    return strings.filter!(s => s.startsWith(prefix));\n}",
  "{\n    string[] new_list;\n    foreach(i, element; strings)\n    {\n        if(element.startsWith(prefix))\n\
    \        {\n            new_list ~= element;\n        }\n    }\n    return new_list;\n\
    }", "{\n\treturn filter!(a => a.startsWith(prefix))(strings);\n}\n/*\n Filter\
    \ an input array of strings only for ones that have a given length.\n    >>> filter_by_len([],\
    \ 3)\n    []\n    >>> filter_by_len([\"abc\", \"bcd\", \"cde\", \"array\"], 4)\n\
    \    [\"bcd\", \"cde\"]\n*/\nstring[] filter_by_len(string[] strings, int len)\
    \ \n{\n\treturn filter!(a => a.length == len)(strings);\n}\n/*\n Filter an input\
    \ array of strings only for ones that contain a given char.\n    >>> filter_by_char([],\
    \ 'a')\n    []\n    >>> filter_by_char([\"abc\", \"bcd\", \"cde\", \"array\"],\
    \ 'a')\n    [\"abc\", \"array\"]\n*/\nstring[] filter_by_char(string[] strings,\
    \ char c) \n{\n\treturn filter!(a => a.indexOf(c) != -1)(strings);\n}\n/*\n Filter\
    \ an input array of strings only for ones that contain a given substring.\n  \
    \  >>> filter_by_substr([], \"abc\")\n    []\n    >>> filter_by_substr([\"abc\"\
    , \"bcd\", \"cde\", \"abcdef\"], \"abc\")\n    [\"abc\", \"abcdef\"]\n*/\nstring[]\
    \ filter_by_substr(string[] strings, string substr) \n{\n\treturn filter!(a =>\
    \ a.indexOf(substr) != -1)(strings);\n}", "in {\n    assert(prefix.length > 0);\n\
    }\nout (result) {\n    assert(result.length <= strings.length);\n    result.each!(s\
    \ => assert(s.startsWith(prefix)));\n}\nbody {\n    string[] res;\n    foreach\
    \ (string s; strings) {\n        if (s.startsWith(prefix)) {\n            res\
    \ ~= s;\n        }\n    }\n    return res;\n}", "{\n    string[] result;\n   \
    \ for (auto s : strings) {\n        if (s.starts_with(prefix)) {\n           \
    \ result ~= s;\n        }\n    }\n    return result;\n}", "{\n    // string[]\
    \ result;\n    // foreach(string s; strings)\n    // {\n    //     if(s.startsWith(prefix))\n\
    \    //     {\n    //         result ~= s;\n    //     }\n    // }\n    // return\
    \ result;\n    return strings.filter!(s => s.startsWith(prefix));\n}\n/*\n Check\
    \ whether a given array is sorted.\n    >>> is_sorted([])\n    true\n    >>> is_sorted([1,\
    \ 2, 3])\n    true\n    >>> is_sorted([1, 2, 1])\n    false\n*/", "{\n    string[]\
    \ result;\n    for (string s; s = strings.popFront()) \n    {\n        if (s.startsWith(prefix))\
    \ \n        {\n            result ~= s;\n        }\n    }\n    return result;\n\
    }", "{\n    return strings.filter!(s => s.startsWith(prefix)).array;\n}", "in\
    \ {\n    foreach (string str; strings) {\n        str.in;\n    }\n    prefix.in;\n\
    } out {\n    foreach (string str; result) {\n        str.out;\n    }\n} body {\n\
    \    auto result = new string[];\n    int length = strings.length;\n    int i\
    \ = 0;\n    while (i < length) {\n        if (strings[i].startsWith(prefix)) {\n\
    \            result ~= strings[i];\n        }\n        i = i + 1;\n    }\n   \
    \ return result;\n}", "{\n    return filter!(a => startsWith(a, prefix))(strings);\n\
    }\n// the same functions with if elses\nstring[] filter_by_prefix_1(string[] strings,\
    \ string prefix) \n{\n    return filter!(a => if (startsWith(a, prefix)) return\
    \ true; else return false;)(strings);\n}\n// a shorter version\nstring[] filter_by_prefix_2(string[]\
    \ strings, string prefix) \n{\n    return filter!(a => startsWith(a, prefix))(strings);\n\
    }\n ", "    in(string[], strings) in(string, prefix)\n{\n    string[] filtered\
    \ = new string[0];\n    foreach(s; strings)\n    {\n        if(s.startsWith(prefix))\n\
    \        {\n            filtered ~= s;\n        }\n    }\n    return filtered;\n\
    }\n/*\n Display the output of a function.\n    >>> display_output(do_nothing)\n\
    \    nothing\n*/", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }\n/*\n    Pass arguments into a function object.", "{\n    string[] filtered;\n\
    \    foreach(str; strings) \n    {\n        if(str.startsWith(prefix)) \n    \
    \    {\n            filtered ~= str;\n        }\n    }\n    return filtered;\n\
    }", "{\n    string[] ans = [];\n    foreach(string s; strings) \n    {\n     \
    \   if(s.startsWith(prefix)) \n        {\n            ans ~= s;\n        }\n \
    \   }\n    return ans;\n}\n/*\n    Write an algorithm that computes the area of\
    \ a triangle.\n*/\ndouble areaOfTriangle(double base, double height) \n{\n   \
    \ double ans = 0.5 * base * height;\n    return ans;\n}\n/*\n Given a string and\
    \ a boolean indicating if the string is encoded, return the decoded or encoded\
    \ string.\n*/\nstring decodeString(string s, bool isEncoded) \n{\n    string ans\
    \ = \"\";\n    if(isEncoded) \n    {\n        foreach(char c; s) \n        {\n\
    \            c = cast(char)(cast(int)(c) - 10);\n            ans ~= c;\n     \
    \   }\n    }\n    else \n    {\n        foreach(char c; s) \n        {\n     \
    \       c = cast(char)(cast(int)(c) + 10);\n            ans ~= c;\n        }\n\
    \    }\n    return ans;\n}\n/*\n Given a string, return the string reversed.\n\
    */\nstring reverseString(string s) \n{\n    string ans = \"\";\n    for(int i\
    \ = s.length - 1; i >= 0; i--) \n    {\n        ans ~= s[i];\n    }\n    return\
    \ ans;\n}\n/*\n Given a string, return a string with all vowels in upper case.\n\
    */\nstring upperCaseVowels(string s) \n{\n    string ans = \"\";\n    foreach(char\
    \ c; s) \n    {\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') \n        {\n            c = cast(char)(cast(int)(c) - 32);\n      \
    \  }\n        ans ~= c;\n    }\n    return ans;\n}\n/*\n Given a string and an\
    \ integer representing the length of the prefix, return a string array of all\
    \ prefixes of length len.\n    >>> prefix", "{\n    /*\n    >>> filter_by_prefix([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"array\"]\n    */\n    import std.range;\n    // answer:[]\n\
    \    string[] answer;\n    if (strings.length > 0 && prefix.length > 0) \n   \
    \ {\n        // answer:[\"abc\", \"array\"]\n        answer = strings.filter!(string\
    \ candidate => prefix == candidate[0 .. prefix.length]).array;\n    }\n    return\
    \ answer;\n}", "{\n    auto result = [];\n    foreach (string s; strings) \n \
    \   {\n        if (s.startsWith(prefix)) \n        {\n            result ~= s;\n\
    \        }\n    }\n    return result;\n}\n/*\n \n \nFilter an input array of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"array\"]\n*/\nstring[] filter_by_prefix_2(string[]\
    \ strings, string prefix) \n{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }", "{\n    return strings.filter!(x => x.startsWith(prefix));\n}\n/*\n Get the\
    \ sum of all the numbers in a given array.\n    >>> sum_of_numbers([1, 2, 3, 4,\
    \ 5])\n    15\n    >>> sum_of_numbers([0])\n    0\n    >>> sum_of_numbers([])\n\
    \    0\n    \n*/\ndouble sum_of_numbers(double[] nums) \n{\n    return nums.sum();\n\
    }\n/*\n Get the sum of all the numbers at even indices.\n    >>> sum_of_evens([1,\
    \ 2, 3, 4, 5])\n    6\n    >>> sum_of_evens([0])\n    0\n    >>> sum_of_evens([])\n\
    \    0\n    \n*/\ndouble sum_of_evens(double[] nums) \n{\n    return nums.sum!(x\
    \ => x % 2 == 0);\n}\n/*\n Filter an input array of strings only for ones whose\
    \ lengths are less than a given number.\n    >>> filter_by_max_length([], 1)\n\
    \    []\n    >>> filter_by_max_length([\"a\", \"ab\", \"abc\", \"abcd\"], 3)\n\
    \    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] filter_by_max_length(string[]\
    \ strings, size_t max_length) \n{\n    return strings.filter!(x => x.length <\
    \ max_length);\n}\n/*\n Multiply all the numbers in an array by a given number.\n\
    \    >>> mult_array([1, 2, 3, 4, 5], 0)\n    [0, 0, 0, 0, 0]\n    >>> mult_array([1,\
    \ 2, 3, 4, 5], 2)\n    [2, 4, 6, 8, 10]\n    \n*/\ndouble[] mult_array(double[]\
    \ nums, double mult) \n{\n    return nums.map!(x => x * mult);\n}\n/*\n Get the\
    \ sum of all the even numbers in an array.\n    >>> sum_evens([1, 2, 3, 4, 5])\n\
    \    6\n    >>> sum_even", "{\n    //template<class Range>\n    //struct FilterResult\n\
    \    //{\n    //\tRange range;\n    //\tsize_t[] indicies;\n    //};\n    auto\
    \ result = filter!((string str) => str.startsWith(prefix))(strings);\n    return\
    \ result.range;\n}\n/*\n    >>> curry!((int, int, int)(int x, int y, int z) =>\
    \ x + y + z)(1)(2)(3)\n    6\n*/", "{\n  auto filter = filter!(a => a.startsWith(prefix));\n\
    \  return filter(strings);\n}\n/*\n    Check if a function is pure.\n*/", "{\n\
    \  return strings.filter!(s => s.startsWith(prefix));\n}\nfilter_by_prefix([\"\
    ab\", \"bcd\", \"cde\", \"array\"], \"a\");", "{\n\treturn strings.filter!(s =>\
    \ s.startsWith(prefix));\n}\n \n/*\n Split a string into words by splitting at\
    \ spaces.\n    >>> words(\"this is a test\")\n    [\"this\", \"is\", \"a\", \"\
    test\"]\n    >>> words(\" abc\")\n    [\"abc\"]\n    >>> words(\" abc \")\n  \
    \  [\"abc\"]\n    >>> words(\" \")\n    []\n    >>> words(\"\")\n    []\n    >>>\
    \ words(\"a\")\n    [\"a\"]\n*/\nstring[] words(string str) \n{\n\treturn str.split('\
    \ ').filter!(s => s != \"\");\n}\n \n/*\n Split a string into words by splitting\
    \ at spaces, but\n only keep the words that are longer than some given length.\n\
    \    >>> words_longer_than(3, \"this is a test\")\n    [\"this\", \"test\"]\n\
    \    >>> words_longer_than(3, \" abc\")\n    []\n    >>> words_longer_than(3,\
    \ \" abc \")\n    []\n    >>> words_longer_than(3, \" \")\n    []\n    >>> words_longer_than(3,\
    \ \"\")\n    []\n    >>> words_longer_than(3, \"a\")\n    []\n*/\nstring[] words_longer_than(uint\
    \ length, string str) \n{\n\treturn words(str).filter!(s => s.length > length);\n\
    }\n \n/*\n Split a string into words by splitting at spaces, but\n only keep the\
    \ words that are smaller than some given length.\n    >>> words_smaller_than(3,\
    \ \"this is a test\")\n    [\"is\", \"a\"]\n    >>> words_smaller_than(3, \" abc\"\
    )\n    [\"abc\"]\n    >>> words_smaller_than(3, \" abc \")\n    [\"abc\"]\n  \
    \  >>> words_smaller_than(3, \" \")\n    []\n    >>> words_smaller_than(3, \"\"\
    )\n    []\n    >>> words_smaller_than(3, \"a\")\n    [\"a\"]\n*/\nstring[] words_smaller_than(uint\
    \ length, string str) ", "{\n\treturn strings.filter!(s => s.startsWith(prefix));\n\
    }", "{\n    return strings.filter!(a => a.startsWith(prefix)).array;\n}\n ", "{\n\
    \    \n    auto result = filter!(s => s.startsWith(prefix))(strings);\n    return\
    \ result;\n}\n/*\nReturns the largest number from a given array of integers.\n\
    \    >>> max_array([1, 4, 9, 2, 3])\n    9\n*/", "{\n\timport std.algorithm;\n\
    \treturn strings.filter!(s => s.startsWith(prefix)).array;\n}\n/*\n Compare an\
    \ array of strings to see if they all start with a given prefix.\n    >>> compare_prefixes([],\
    \ \"a\")\n    []\n    >>> compare_prefixes([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"array\"]\n    \n*/", "{\n    foreach(string str; strings)\n\
    \    {\n        if(startsWith(str, prefix))\n        {\n            yield(str);\n\
    \        }\n    }\n}\n \n/*\n \n Find an element in an array that is equal to\
    \ a particular element.\n    >>> find_element([\"a\", \"b\", \"c\"], \"a\")\n\
    \    \"a\"\n    >>> find_element([\"a\", \"b\", \"c\"], \"d\")\n    null\n \n\
    \ */\nstring find_element(string[] strings, string element) \n{\n    foreach(string\
    \ str; strings)\n    {\n        if(str == element)\n        {\n            return\
    \ str;\n        }\n    }\n    return null;\n}\n \n/*\n \n Check if two strings\
    \ are the same\n    >>> are_equal(\"a\", \"a\")\n    true\n    >>> are_equal(\"\
    a\", \"b\")\n    false\n \n */", "{\n  return strings.filter!(x => x.startsWith(prefix));\n\
    }\n/*\n Flatten a given 2D matrix, into 1D array.\n    >>> flatten_2d([[1, 2],\
    \ [3, 4], [5, 6]])\n    [1, 2, 3, 4, 5, 6]\n*/", "{\n\treturn strings.filter!(s\
    \ => s.startsWith(prefix));\n}\n/*\nA very simple and naive prime number checker.\n\
    >>> is_prime(0)\nfalse\n>>> is_prime(1)\nfalse\n>>> is_prime(2)\ntrue\n>>> is_prime(3)\n\
    true\n>>> is_prime(4)\nfalse\n>>> is_prime(5)\ntrue\n>>> is_prime(6)\nfalse\n\
    */", "{\n    int n = strings.length;\n    string[] retval = new string[];\n  \
    \  retval.length = n;\n    int[] retinds = new int[];\n    retinds.length = n;\n\
    \    int j = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (strings[i].indexOf(prefix)\
    \ == 0)\n        {\n            retval[j] = strings[i];\n            retinds[j]\
    \ = i;\n            j++;\n        }\n    }\n    return retval[0..j];\n}\nstring[]\
    \ filter_by_prefix(string[] strings, string prefix) \n{\n    return strings.filter!(str\
    \ => str.indexOf(prefix) == 0);\n}\n/*\n Sorting a range of strings by last character.\n\
    \    >>> sort_by_last([])\n    []\n    >>> sort_by_last([\"a\", \"ab\", \"abc\"\
    , \"abcd\"])\n    [\"a\", \"abcd\", \"abc\", \"ab\"]\n    >>> sort_by_last([\"\
    a\", \"ab\", \"abc\", \"abcd\", \"abcde\"])\n    [\"a\", \"abcd\", \"abcde\",\
    \ \"abc\", \"ab\"]\n*/\nstring[] sort_by_last(string[] strings) \n{\n    strings.sort!((s1,\
    \ s2) => {\n        if (s1.length == s2.length)\n            return 0;\n     \
    \   else\n            return (s1.length > s2.length) ? -1 : 1;\n    });\n    return\
    \ strings;\n}\n/*\n Group an input array of strings by their first character.\
    \ \n    \n    >>> group_by_first([\"abc\", \"bcd\", \"cde\", \"array\"])\n   \
    \ { \"a\": [\"abc\", \"array\"], \"b\": [\"bcd\"], \"c\": [\"cde\"] }\n    \n\
    */\nSortedAssocArray!(string, string[]) group_by_first(string[] strings) \n{\n\
    \    return strings.groupBy!(str => str[0]);\n}\n/*\n Partition a range of strings\
    \ by the number of vowels they contain. ", "{\n\treturn filter!(a => startsWith(a,\
    \ prefix))(strings);\n}", "{\n    string[] filtered_strings;\n    string cur_string;\n\
    \    foreach(cur_string; strings) \n    {\n        if(cur_string.startsWith(prefix))\
    \ \n        {\n            filtered_strings ~= cur_string;\n        }\n    }\n\
    \    return filtered_strings;\n}\n//array(T)[]\n/*\n Merge two input arrays of\
    \ strings, and return only strings that are in both arrays.\n    >>> merge_by_intersection([],\
    \ [])\n    []\n    >>> merge_by_intersection([\"abc\", \"bcd\", \"cde\"], [\"\
    abc\", \"array\"])\n    [\"abc\"]", "{\n    return filter!(a => a.startsWith(prefix))(strings);\n\
    }\n/*\n Other versions:\n    >>> strings = [\"abc\", \"bcd\", \"cde\", \"array\"\
    ];\n    >>> filter!(a => a.startsWith(\"a\"))(strings)\n    [\"abc\", \"array\"\
    ]\n    \n    >>> strings.filter!(a => a.startsWith(\"a\"))\n    [\"abc\", \"array\"\
    ]\n    >>> strings.filter!((string a) => a.startsWith(\"a\"))\n    [\"abc\", \"\
    array\"]\n    >>> strings.filter!((string a) => a.startsWith(\"a\")).array\n \
    \   [\"abc\", \"array\"]\n    \n*/\n/*\n Return the length of the longest string\
    \ in an array of strings.\n    >>> longest_string([\"abc\", \"bcd\", \"cde\",\
    \ \"array\"])\n    6\n    >>> longest_string([\"\", \"a\", \"longer string\",\
    \ \"but not this one\"])\n    18\n*/\n// int longest_string(string[] strings)\
    \ \n// {\n//     int max_length = 0;\n//     foreach (string s; strings) {\n//\
    \         max_length = max(max_length, s.length);\n//     }\n//     return max_length;\n\
    // }", "in {\n\tforeach(string str; strings)\n\t{\n\t\tassert(str.length > 0);\n\
    \t}\n} out {\n\tforeach(string str; strings)\n\t{\n\t\tassert(str.length > 0);\n\
    \t}\n}\nbody {\n\tstring[] result;\n\tforeach(string str; strings)\n\t{\n\t\t\
    if(str.length > 0 && str.find(prefix) == 0)\n\t\t{\n\t\t\tresult ~= str;\n\t\t\
    }\n\t}\n\treturn result;\n}", "{\n\treturn strings.filter!(x => x.startsWith(prefix));\n\
    }\n/*\nFind the minimum of an array of values, e.g. min([1, 4, 2, 8, 9]) == 1.\n\
    \    >>> min([])\n    0\n    >>> min([1, 2, 3])\n    1\n    >>> min([-3, -2, -1])\n\
    \    -3\n*/\nT min(T)(T[] t)\n{\n\tif (t.length == 0) return t[0];\n\tauto m =\
    \ t[0];\n\tforeach (value; t)\n\t{\n\t\tif (value < m) m = value;\n\t}\n\treturn\
    \ m;\n}\n/*\nFind the maximum of an array of values, e.g. max([1, 4, 2, 8, 9])\
    \ == 9.\n    >>> max([])\n    0\n    >>> max([1, 2, 3])\n    3\n    >>> max([-3,\
    \ -2, -1])\n    -1\n*/\nT max(T)(T[] t)\n{\n\tif (t.length == 0) return t[0];\n\
    \tauto m = t[0];\n\tforeach (value; t)\n\t{\n\t\tif (value > m) m = value;\n\t\
    }\n\treturn m;\n}\n/*\nFind the mean of an array of values, e.g. mean([1, 2, 3])\
    \ == 2.\n    >>> mean([])\n    0\n    >>> mean([1, 2, 3])\n    2\n    >>> mean([-3,\
    \ -2, -1])\n    -2\n*/\nT mean(T)(T[] t)\n{\n\tT mean = 0;\n\tint length = t.length;\n\
    \tforeach (value; t)\n\t{\n\t\tmean += value;\n\t}\n\treturn mean / length;\n\
    }\n/*\nFind the median of an array of values, e.g. median([1, 4, 2, 8, 9]) ==\
    \ 5.\n    >>> median([])\n    0\n    >>> median([1, 2, 3])\n    2\n    >>> median([-3,\
    \ -2, -1])\n    -", "{\n    string[] filtered = [\"\"];\n    foreach(string str;\
    \ strings)\n    {\n        if(str.startsWith(prefix))\n        {\n           \
    \ filtered ~= str;\n        }\n    }\n    return filtered;\n}", "{\n    int[]\
    \ index_range = filter!((x => strings[x].startsWith(prefix)))(iota(strings.length));\n\
    \    return strings[index_range];\n}", "{\n    import std.algorithm;\n    import\
    \ std.string;\n    return strings.filter!(x => startsWith(x, prefix));\n}", "{\n\
    \    string[] ret;\n    foreach(s; strings)\n    {\n        if(s.startsWith(prefix))\n\
    \        {\n            ret ~= s;\n        }\n    }\n    return ret;\n}\n/*\n\
    \ filter an array of strings to include only ones that end with a given suffix.\n\
    \    >>> filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"array\"]\n    >>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"\")\n    [\"abc\", \"bcd\", \"cde\", \"\
    array\"]\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\
    e\")\n    [\"cde\"]\n*/\nstring[] filter_by_suffix(string[] strings, string suffix)\
    \ \n{\n    string[] ret;\n    foreach(s; strings)\n    {\n        if(s.endsWith(suffix))\n\
    \        {\n            ret ~= s;\n        }\n    }\n    return ret;\n}\n/*\n\
    \ Filter an array of strings to exclude any that end with a given suffix.\n  \
    \  >>> filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bcd\", \"cde\"]\n    >>>\
    \ filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\")\n    []\n   \
    \ >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"e\")\n    [\"\
    abc\", \"bcd\", \"array\"]\n*/\nstring[] filter_by_exclude_suffix(string[] strings,\
    \ string suffix) \n{\n    string[] ret;\n    foreach(s; strings)\n    {\n    \
    \    if(!s.endsWith(suffix))\n        {\n            ret ~= s;\n        }\n  \
    \  }\n    return ret;\n}\n/*\n Filter an array of strings to exclude any that\
    \ start with a given prefix", "{\n    return strings.filter!(s => s.startsWith(prefix)).array;\n\
    }\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n\
    */\nstring[] filter_by_prefix(string[] strings, string prefix) \n{\n    return\
    \ strings.filter!(s => s.startsWith(prefix)).array;\n}\n/*\n Return the sum of\
    \ two integers.\n*/", "{\n    \n    return strings.filter!(x => x.startsWith(prefix));\n\
    }", "{\n    return strings.filter!(str => str.startsWith(prefix));\n}", "in {\n\
    \    assert(all!((string x) => x.length >= prefix.length)(strings));\n}\nbody\
    \ {\n    return filter!((string s) => s.startsWith(prefix))(strings);\n}", "{\n\
    \    string[] ret;\n    foreach(s; strings) \n    {\n        if(s.startsWith(prefix))\n\
    \            ret ~= s;\n    }\n    return ret;\n}", "{\n    return strings.filter!(s\
    \ => s.startsWith(prefix)).array;\n}", "{\n    return strings.filter!(s => s.startsWith(prefix)).idup;\n\
    }\n/*\n Filter an input array of integers only for ones that are even.\n    >>>\
    \ filter_even([])\n    []\n    >>> filter_even([1, 2, 3, 4, 5])\n    [2, 4]\n\
    \    \n*/", "{\n    // Code here\n    auto ret = new string[];\n    foreach(string\
    \ s; strings) {\n        if(s.startsWith(prefix)) {\n            ret ~= s;\n \
    \       }\n    }\n    return ret;\n}", "{\n    return filter!(a => a.startsWith(prefix))(strings);\n\
    }", "    in\n    {\n        assert(strings != null);\n        assert(prefix !=\
    \ null);\n    }\n    body\n    {\n        import std.algorithm.searching : startsWith;\n\
    \        return strings.filter!(s => s.startsWith(prefix));\n    }", "{\n    return\
    \ filter!(s => s.startsWith(prefix))(strings);\n}", "{\n    return strings.filter!(str\
    \ => str.startsWith(prefix));\n}", "{\n    // Use the `std.range.filter` algorithm\
    \ to filter elements\n    // of the given `strings` array that start with `prefix`.\n\
    \    string[] ret;\n    import std.range;\n    import std.algorithm;\n    return\
    \ filter!(str => str.startsWith(prefix))(strings).array;\n}\n/*\n Sort an array\
    \ of strings.\n    >>> sort_array([\"abc\", \"bcd\", \"cde\", \"array\"])\n  \
    \  [\"abc\", \"array\", \"bcd\", \"cde\"]\n*/\nstring[] sort_array(string[] strings)\n\
    {\n    // Use the `std.algorithm.sort` function to sort `strings`.\n    string[]\
    \ ret;\n    import std.algorithm;\n    return strings.dup.sort;\n}\n/*\n Sort\
    \ an array of strings, but reverse the order.\n    >>> sort_array_reverse([\"\
    abc\", \"bcd\", \"cde\", \"array\"])\n    [\"cde\", \"bcd\", \"array\", \"abc\"\
    ]\n*/\nstring[] sort_array_reverse(string[] strings)\n{\n    // Use the `std.algorithm.sort`\
    \ function to sort `strings`\n    // and set the `descending` template parameter\
    \ to `true`.\n    string[] ret;\n    import std.algorithm;\n    return strings.dup.sort!(a\
    \ => a, true);\n}\n/*\n Calculate the product of the values in an array of integers.\n\
    \    >>> multiply_array([1, 2, 3, 4])\n    24\n*/", "{\n  return strings.filter!(s\
    \ => s.startsWith(prefix));\n}\n/*\n Filter a given list of tuples according to\
    \ some conditions on the tuple elements.\n    >>> filter_tuples([])\n    []\n\
    \    >>> filter_tuples([(0, 1, 2)])\n    []\n    >>> filter_tuples([(1, 2, 3),\
    \ (4, 5, 6), (7, 8, 9)])\n    [(4, 5, 6)]\n*/", "{\n\tstring[] ret = new string[];\n\
    \tforeach(string s; strings) \n\t{\n\t\tif(s.startsWith(prefix)) \n\t\t{\n\t\t\
    \tret ~= s;\n\t\t}\n\t}\n\treturn ret;\n}", "{\n    assert(prefix != null);\n\
    \    string[] result = new string[];\n    foreach (string str; strings) \n   \
    \ {\n        if (str.length < prefix.length) continue;\n        if (str[0 .. prefix.length]\
    \ == prefix) result ~= str;\n    }\n    return result;\n}\n \nunittest \n{\n \
    \   string[] strings = [\"abc\", \"bcd\", \"cde\", \"array\"];\n    assert(filter_by_prefix(strings,\
    \ \"a\") == [\"abc\", \"array\"]);\n    assert(filter_by_prefix(strings, \"c\"\
    ) == [\"cde\"]);\n    assert(filter_by_prefix(strings, \"d\") == []);\n}\n/*\n\
    \ Filter an input array of strings only for ones that start with a given prefix.\n\
    \    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[]\
    \ filter_by_prefix(string[] strings, string prefix) \n{\n    assert(prefix !=\
    \ null);\n    string[] result = new string[];\n    foreach (string str; strings)\
    \ \n    {\n        if (str.length < prefix.length) continue;\n        if (str[0\
    \ .. prefix.length] == prefix) result ~= str;\n    }\n    return result;\n}\n\
    \ \nunittest \n{\n    string[] strings = [\"abc\", \"bcd\", \"cde\", \"array\"\
    ];\n    assert(filter_by_prefix(strings, \"a\") == [\"abc\", \"array\"]);\n  \
    \  assert(filter_by_prefix(strings, \"c\") == [\"cde\"]);\n    assert(filter_by_prefix(strings,\
    \ \"d\") == []);\n}\n//dub run --single ./goto.d\n//dub test -b unittest-cov-gcc-debug\n\
    /*\n Filter an input array of strings only for ones that start with a given prefix.\n\
    \    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"abc\"\
    , \"", "{\n    return strings.filter!(s => s.startsWith(prefix));\n}\n/*\n Consume\
    \ the given input array, and return a new one that contains only the elements\
    \ of the original array that meet the given predicate.\n    >>> filter_ints([],\
    \ i => i % 2 == 0)\n    []\n    >>> filter_ints([1, 2, 3, 4, 5], i => i % 2 ==\
    \ 0)\n    [2, 4]\n    \n*/", "{\n    return filter!(x => startsWith(x, prefix))(strings);\n\
    }\n/*\nFilter an input array of strings only for ones that contain a given substring.\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n*/\nstring[]\
    \ filter_by_substring(string[] strings, string substring) \n{\n    return filter!(x\
    \ => contains(x, substring))(strings);\n}\n/*\n Filter an input array of strings\
    \ only for ones that have a length\n    larger than a given value.\n    \n   \
    \ >>> filter_by_size([], 5)\n    []\n    >>> filter_by_size([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], 5)\n    [\"array\"]\n*/\nstring[] filter_by_size(string[]\
    \ strings, size_t min_size) \n{\n    return filter!(x => x.length > min_size)(strings);\n\
    }\n/*\n Find the longest string in an array of strings.\n    >>> find_longest([])\n\
    \    \"\"\n    >>> find_longest([\"abc\", \"bcd\", \"cde\", \"array\"])\n    \"\
    array\"\n*/\nstring find_longest(string[] strings) \n{\n    if (strings.length\
    \ == 0) \n    {\n        return \"\";\n    }\n    auto result = reduce!((x, y)\
    \ => x.length > y.length ? x : y)(strings);\n    return result;\n}\n/*\n Find\
    \ the shortest string in an array of strings.\n    >>> find_shortest([])\n   \
    \ \"\"\n    >>> find_shortest([\"abc\", \"bcd\", \"cde\", \"array\"])\n    \"\
    abc\"\n*/\nstring find_shortest(string[] strings) \n{\n    if (strings.length\
    \ == 0) \n    {\n        return \"\";\n    }\n    auto result = reduce!((x, y)\
    \ => x.length < y.length ? x : y)(strings);\n    return result;\n}\n/*\nFind the\
    \ most common string in an", "{\n    string[] result;\n    foreach(string s; strings)\
    \ \n    {\n        if(s.startsWith(prefix)) \n        {\n            result ~=\
    \ s;\n        }\n    }\n    return result;\n}", "{\n    auto res = strings.filter!(a\
    \ => a.startsWith(prefix));\n    return res;\n}", "{\n    string[] result;\n \
    \   foreach(i, s; strings) {\n        if(s.length >= prefix.length && s[0 .. prefix.length]\
    \ == prefix) {\n            result ~= s;\n        }\n    }\n    return result;\n\
    }\n/*\n Find the only element in a List that is greater than or equal to all other\
    \ elements\n    >>> one_greater([5, 4, 5, 5, 5])\n    5\n    >>> one_greater([])\n\
    \    >>> one_greater([1, 2, 3, 4, 5])\n    >>> one_greater([1, 2, 3, 4, 5, 6])\n\
    \    6\n    >>> one_greater([5, 4, 5, 5, 6])\n    6\n    \n*/", "{\n    string[]\
    \ filtered;\n    foreach(string s; strings)\n    {\n        if(startsWith(s, prefix))\n\
    \        {\n            filtered ~= s;\n        }\n    }\n    return filtered;\n\
    }\n//filter_by_prefix", "{\n    return strings.filter!(s => s.startsWith(prefix)).array;\n\
    }", "{\n    return filter!(s => s.length >= prefix.length && s[0 .. prefix.length]\
    \ == prefix)(strings);\n}\n/*\n Compute the mode of an array of integers.\n  \
    \  >>> mode([])\n    []\n    >>> mode([1, 2, 3, 3, 3, 4, 5])\n    [3]\n    >>>\
    \ mode([1, 2, 3, 4, 5])\n    []\n    >>> mode([1, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,", "{\n    return filter!(a => a.startsWith(prefix))(strings);\n\
    }", "{\n\tstring[] result;\n\tforeach(string s; strings) \n\t{\n\t\tif(s.length\
    \ > prefix.length) \n\t\t{\n\t\t\t// s[0..prefix.length] can be an invalid range\
    \ if s is too short\n\t\t\tif(s[0..prefix.length] == prefix) \n\t\t\t{\n\t\t\t\
    \tresult ~= s;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n// Print out all moves\
    \ possible on a 5x5 chess board with one piece at (3,3)", "{\n    return strings.filter!(s\
    \ => s.startsWith(prefix)).array;\n}", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }", "{\n    // IMPLEMENT ME\n}", "{\n    string[] result;\n    foreach(string\
    \ s; strings)\n    {\n        if(s.startsWith(prefix))\n        {\n          \
    \  result ~= s;\n        }\n    }\n    return result;\n}\n/*\n    Given an array\
    \ of numbers, find the maximum value.\n    >>> find_max([])\n    -inf\n    >>>\
    \ find_max([0])\n    0\n    >>> find_max([1,0])\n    1\n    >>> find_max([4,0,9])\n\
    \    9\n*/\nT find_max(T)(T[] numbers) \n{\n    T maximum = -std.numeric.inf;\n\
    \    foreach(T n; numbers)\n    {\n        if(n > maximum)\n        {\n      \
    \      maximum = n;\n        }\n    }\n    return maximum;\n}\n/*\nCalculate the\
    \ factorial of a given number.\n    >>> factorial(0)\n    1\n    >>> factorial(1)\n\
    \    1\n    >>> factorial(2)\n    2\n    >>> factorial(3)\n    6\n    >>> factorial(4)\n\
    \    24\n*/", "    in(strings, prefix)\n    body \n    for(index_t i = 0; i <\
    \ strings.length; i++) \n        if(strings[i].starts_with(prefix)) {\n      \
    \      return strings[i];\n        }\n    return null;\n    \n    \n/*\n Find\
    \ the maximal element of an array of integers.\n    >>> max_el([0, 2, 3, 2, 1])\n\
    \    3\n*/", "{\n    return filter!(x => x.startsWith(prefix))(strings);\n}\n\
    /*\n Convert an input array of strings to a new array with all strings\n    converted\
    \ to uppercase. \n    >>> to_upper([\"Foo\", \"Bar\"])\n    [\"FOO\", \"BAR\"\
    ]\n*/\nstring[] to_upper(string[] strings) \n{\n    return map!(x => x.toUpper())(strings);\n\
    }\n/*\n Split all input strings on the given character. \n    >>> split_on([\"\
    ab.c\", \"d.e.f\", \"g,h,i\"], \".\")\n    [[\"ab\", \"c\"], [\"d\", \"e\", \"\
    f\"], [\"g,h,i\"]]\n*/\nstring[][] split_on(string[] strings, string sep) \n{\n\
    \    return map!(x => x.split(sep))(strings);\n}\n/*\nSplit all input strings\
    \ on the given character and flatten the resulting\n    array.\n    >>> split_on_and_flatten([\"\
    ab.c\", \"d.e.f\", \"g,h,i\"], \".\")\n    [\"ab\", \"c\", \"d\", \"e\", \"f\"\
    , \"g,h,i\"]\n*/\nstring[] split_on_and_flatten(string[] strings, string sep)\
    \ \n{\n    return splitterator(strings, sep).array;\n}\n/*\n Flatten an array\
    \ of arrays.\n    >>> flatten([[1, 2], [3, 4]])\n    [1, 2, 3, 4]\n*/\nT[] flatten(T)(T[][]\
    \ array) \n{\n    T[] ret = [];\n    foreach(a; array) \n    {\n        ret ~=\
    \ a;\n    }\n    return ret;\n}\n/*\n Split all strings on the given character\
    \ and flatten the resulting\n    array.\n    >>> flat_map([\"ab.c\", \"d.e.f\"\
    , \"g,h,i\"], \".\")\n    [\"ab\", \"c\", \"d\", \"e\", \"f\", \"g,h,i\"]\n*/\n\
    string[] flat_map(string[] strings, string sep", "{\n    string[] output = new\
    \ string[];\n    foreach(input; strings) \n    {\n        if(input.startsWith(prefix))\
    \ \n        {\n            output ~= input;\n        }\n    }\n    return output;\n\
    }\n/*\n Find all the values in the map that start with a given prefix.\n    >>>\
    \ filter_map_by_prefix([\"a\": 1, \"b\": 2, \"c\": 3], \"a\")\n    [1]\n    >>>\
    \ filter_map_by_prefix([\"abc\": 1, \"bcd\": 2, \"cde\": 3], \"a\")\n    [1]\n\
    \    >>> filter_map_by_prefix([\"abc\": 1, \"bcd\": 2, \"cde\": 3], \"ab\")\n\
    \    [1]\n    >>> filter_map_by_prefix([\"abc\": 1, \"bcd\": 2, \"cde\": 3], \"\
    abc\")\n    [1]\n*/\nV[] filter_map_by_prefix(V, K[])(in K[] keys, in string prefix)\
    \ \n{\n    K[] filtered_keys = filter_by_prefix(keys, prefix);\n    return map!(filtered_keys);\n\
    }\n/*\n    Filter an input array of strings only for ones that match a given pattern.\n\
    \    >>> filter_by_pattern([], \"a\")\n    []\n    >>> filter_by_pattern([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \".*c.*\")\n    [\"abc\", \"cde\"]\n    >>> filter_by_pattern([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \".*C.*\")\n    []\n    >>> filter_by_pattern([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \".*C.*\", 1)\n    [\"abc\", \"cde\"]\n*/\n\
    string[] filter_by_pattern(string[] strings, string pattern, int ignore_case =\
    \ 0) \n{\n    string[] output = new string[];\n    auto options = 0;\n    if(ignore_case)\
    \ \n    {\n        options = Regex.caseInsensitive;\n    }\n    foreach(input;\
    \ strings) \n    {\n        auto regex =", "{\n    return filter!(x => x.startsWith(prefix))(strings);\n\
    }\n/*\n Check if a string array contains only unique elements.\n    >>> unique([\"\
    abc\", \"abc\", \"abc\"])\n    false\n    >>> unique([\"abc\", \"def\", \"abc\"\
    ])\n    false\n    >>> unique([\"abc\", \"def\", \"ghi\"])\n    true\n*/", "{\n\
    \    return strings.filter!(a => a.startsWith(prefix));\n}", "{\n    auto result\
    \ = strings.filter!(s => s.startsWith(prefix)).array;\n    return result;\n}\n\
    /*\n Split a string by the given delimiter.\n    >>> split(\"Here is a string\"\
    , ' ')\n    [\"Here\", \"is\", \"a\", \"string\"]\n    >>> split(\"Long,delimiter,string\"\
    , ',')\n    [\"Long\", \"delimiter\", \"string\"]\n*/\nstring[] split(string input,\
    \ char delimiter)\n{\n    return input.split(delimiter).map!(a => a.to!string).array;\n\
    }", "{\n  return strings.filter!(x => x.startsWith(prefix));\n}\n/*\n    Filter\
    \ an input array of numbers only for ones that are smaller than a given max.\n\
    \    \n    >>> filter_by_max([], 3)\n    []\n    >>> filter_by_max([1, 2, 3, 4,\
    \ 5], 3)\n    [1, 2]\n*/", "{\n    return filter!(a => a.startsWith(prefix))(strings);\n\
    }\n/*\n Count the occurrences of each letter in the input array and display the\
    \ count of each.\n    >>> count_letters([])\n    {}\n    >>> count_letters([\"\
    a\", \"b\", \"c\", \"a\", \"c\", \"a\"])\n    {'a': 3, 'b': 1, 'c': 2}\n*/", "{\n\
    \    string[] result;\n    foreach(string s; strings) \n    {\n        if(s.length\
    \ > 0 && s[0] == prefix[0])\n            result ~= s;\n    }\n    return result;\n\
    }\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    >>>\
    \ filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"c\")\n    []\n  \
    \  >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n    [\"\
    bcd\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings, string prefix) \n\
    {\n    string[] result;\n    foreach(string s; strings) \n    {\n        if(s.length\
    \ > 0 && s[0] == prefix[0])\n            result ~= s;\n    }\n    return result;\n\
    }\n/*\n    >>> map_to_string([])\n    \"[]\"\n    >>> map_to_string([1, 2, 3])\n\
    \    \"[1, 2, 3]\"\n    >>> map_to_string([\"abc\", \"def\"])\n    \"[\\\"abc\\\
    \", \\\"def\\\"]\"\n*/\nstring map_to_string(T[])(T[] input) \n{\n    if(input.length\
    \ == 0)\n        return \"[]\";\n    string result = \"[\";\n    foreach(index,\
    \ elem; input) \n    {\n        if(index > 0)\n            result ~= \", \";\n\
    \        result ~= elem.to!string;\n    }\n    result ~= \"]\";\n    return result;\n\
    }\n/*\nGet the slope between two pairs of points.\n    >>> get_slope((1, 2), (3,\
    \ 4))\n    1\n    >>> get_slope((1, 2), (1, 4))\n    2\n    >>> get_slope((1,\
    \ 2), (1, 2))\n    0\n*/", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }\n/*\n A simple predicate-based filter.\n    >>> filter!(isEven)([1, 2, 3, 4,\
    \ 5])\n    [2, 4]\n    >>> filter!(isOdd)([1, 2, 3, 4, 5])\n    [1, 3, 5]\n  \
    \  >>> filter!(isOdd)([])\n    []\n    >>> filter!(isEven)([])\n    []\n*/\nauto\
    \ filter(alias pred) {\n    return (T)(T[] arr) => \n        return arr.filter!(x\
    \ => pred(x));\n}\n// Predicates for testing filter.", "{\n    return strings.filter!(x\
    \ => x.startsWith(prefix));\n}", "{\n    string[] result;\n    foreach(string\
    \ word; strings) \n    {\n        if (startsWith(word, prefix)) \n        {\n\
    \            result ~= word;\n        }\n    }\n    return result;\n}", "{\n \
    \ import std.stdio;\n  return strings.filter!(s => s.startsWith(prefix)).array;\n\
    }\n/*", "{\n    /*if (strings.length == 0)\n        return [\"\"];\n    if (strings[0].startsWith(prefix))\n\
    \        return [strings[0]]~filter_by_prefix(strings[1..$], prefix);\n    else\n\
    \        return filter_by_prefix(strings[1..$], prefix);*/\n    \n    /*\n   \
    \     // Really bad\n        return map!(toLower)([\"AbC\", \"Bcd\", \"Cde\",\
    \ \"Array\"])\n        .filter!((s) => s.startsWith(prefix.toLower()));\n    */\n\
    \    \n    // Good\n    return strings.filter!((s) => s.startsWith(prefix));\n\
    }\n/*\n Accept an array of integers and return an array of the results of applying\
    \ a function on each element.\n \n    >>> map([], fun(x) => x*2)\n    []\n   \
    \ >>> map([1, 2, 3], fun(x) => x*2)\n    [2, 4, 6]\n    \n*/\nT[] map(T[] input,\
    \ alias fun)(T[] arr) \n{\n    if (arr.length == 0)\n        return input;\n \
    \   return input~[fun(arr[0])]~map!fun(arr[1..$]);\n}", "{\n    string[] filtered_array;\n\
    \    foreach(string e; strings)\n    {\n        if(e.startsWith(prefix))\n   \
    \     {\n            append(filtered_array, e);\n        }\n    }\n    return\
    \ filtered_array;\n}", "{\n    auto result = [];\n    foreach(string s; strings)\n\
    \    {\n        if(s.startsWith(prefix))\n        {\n            result ~= s;\n\
    \        }\n    }\n    return result;\n}", "{\n    auto retval = new typeof(return)();\n\
    \    foreach(string s; strings) {\n        if(s.startsWith(prefix)) {\n      \
    \      retval ~= s;\n        }\n    }\n    return retval;\n}\n/*\nGiven an input\
    \ array of strings, return a tuple where the first element is\nthe array of strings\
    \ that start with \"A\" and the second element is the array\nof strings that start\
    \ with \"B\".\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n\
    */\nTuple!(string[], string[]) filter_by_prefix2(string[] strings, string prefix)\
    \ \n{\n    auto a_array = new typeof(return.field[0])();\n    auto b_array = new\
    \ typeof(return.field[1])();\n    foreach(string s; strings) {\n        if(s.startsWith(prefix))\
    \ {\n            a_array ~= s;\n        } else {\n            b_array ~= s;\n\
    \        }\n    }\n    return Tuple!(string[], string[])(a_array, b_array);\n\
    }\n/*\nGiven a string, return the number of vowels that appear in it.\n    >>>\
    \ count_vowels(\"abcdefg\")\n    2\n    >>> count_vowels(\"abcdefga\")\n    3\n\
    \    \n*/\nsize_t count_vowels(string s) \n{\n    size_t vowels = 0;\n    foreach(ch;\
    \ s) {\n        if(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')\
    \ {\n            vowels++;\n        }\n    }\n    return vowels;\n}\n/*\nGiven\
    \ a string, return a new string that doubles each consonant and puts an\noccurrence\
    \ of \"0\" in between.\n    >>> double_consonants(\"abcdefg\")\n    \"a0bc0d0ef0g0\"\
    \n    >>> double_consonants(\"abcdef", "{\n    return filter!(string s => s.startsWith(prefix))(strings);\n\
    }", "{\n    string[] results;\n    foreach(string s; strings) \n    {\n      \
    \  if(s.startsWith(prefix))\n            results ~= s;\n    }\n    return results;\n\
    }\n/*\n Function-like function that returns whether its input is zero.\n    >>>\
    \ is_zero(0)\n    true\n    >>> is_zero(1)\n    false\n    >>> is_zero(-1)\n \
    \   false\n*/", "    pure nothrow @safe @nogc {\n    return strings.filter!(a\
    \ => a.startsWith(prefix)).array;\n}\n/*\n Given a key and a value, remove any\
    \ occurrence of the value from the key in the map.\n    >>> Map!string!string\
    \ m;\n    >>> m[\"a\"] = \"b\";\n    >>> m[\"a\"] = \"c\";\n    >>> m[\"a\"] =\
    \ \"d\";\n    >>> m[\"b\"] = \"d\";\n    >>> m[\"c\"] = \"d\";\n    >>> remove_value_from_key(m,\
    \ \"a\", \"c\");\n    >>> m\n    [\"a\": \"b\", \"a\": \"d\", \"b\": \"d\", \"\
    c\": \"d\"]\n    >>> remove_value_from_key(m, \"a\", \"d\");\n    >>> m\n    [\"\
    a\": \"b\", \"b\": \"d\", \"c\": \"d\"]\n*/", "in {\n\tfor (int i = 0; i < strings.length;\
    \ i++) {\n\t\tassert(strings[i].length() > 0);\n\t}\n}\nout (result) {\n\tfor\
    \ (int i = 0; i < result.length; i++) {\n\t\tassert(result[i].length() > 0);\n\
    \t\tassert(result[i].starts_with(prefix));\n\t}\n}\n{\n\timport std.algorithm\
    \ : filter;\n\treturn strings.filter!(s => s.starts_with(prefix)).array;\n}",
  "{\n    auto matches = filter!(s => s.startsWith(prefix))(strings);\n    return\
    \ matches.array;\n}", "{\n    foreach(index, value; strings)\n    {\n        if(!value.startsWith(prefix))\n\
    \        {\n            strings = strings[0..index] ~ strings[index+1..$];\n \
    \       }\n    }\n    return strings;\n}", "{\n  auto result = filter!((string\
    \ s) => s.startsWith(prefix))(strings);\n  return result;\n}\n \n/*\n    Transform\
    \ an input array of strings by adding a given suffix to each element.\n    >>>\
    \ map_by_suffix([], \"suffix\")\n    []\n    >>> map_by_suffix([\"abc\", \"bcd\"\
    , \"cde\"], \"suffix\")\n    [\"abcsuffix\", \"bcdsuffix\", \"cdesuffix\"]\n*/\n\
    string[] map_by_suffix(string[] strings, string suffix) \n{\n  auto result = map!((string\
    \ s) => s ~ suffix)(strings);\n  return result;\n}", "{\n\tstring[] filtered =\
    \ [];\n\tforeach(s; strings)\n\t{\n\t\tif(startsWith(s, prefix))\n\t\t{\n\t\t\t\
    filtered ~= s;\n\t\t}\n\t}\n\treturn filtered;\n}", "in {\n    assert(prefix.length\
    \ > 0);\n}\nout (result) {\n    assert(result.length <= strings.length);\n   \
    \ foreach (string s; result) {\n        assert(s.startsWith(prefix));\n    }\n\
    }\nbody {\n    return strings.filter!(s => s.startsWith(prefix));\n}", "{\n  \
    \  enum prefix_size = prefix.length;\n    return strings.filter!(e => e.startsWith(prefix));\n\
    }\n/*\nFilter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n\
    */\n// string[] filter_by_prefix(string[] strings, string prefix) \n// {\n// \
    \    return strings.filter!(e => e.startsWith(prefix));\n// }\n/*\nFilter an input\
    \ array of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\n// string[] filter_by_prefix(string[]\
    \ strings, string prefix) \n// {\n//     return strings.filter!(e => e.startsWith(prefix)).array;\n\
    // }\n/*\nFilter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n\
    */\n// string[] filter_by_prefix(string[] strings, string prefix) \n// {\n// \
    \    return strings.filter!(e => e.startsWith(prefix)).dup;\n// }\n/*\nFilter\
    \ an input array of strings only for ones that start with a given prefix.\n  \
    \  >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\n//\
    \ string[] filter_by_prefix(string[] strings, string prefix) \n// {\n//     return\
    \ strings.filter!(e => e.startsWith(prefix)).idup;\n// }\n/*\nFilter an input\
    \ array", "{\n    return strings.filter!(s => s.startsWith(prefix));\n}\n \n/*\n\
    \  A function that takes another function and a list.\n*/", "{\n    return strings.filter!(s\
    \ => s.startsWith(prefix));\n}", "{\n    return strings.filter!(s => s.startsWith(prefix)).toArray();\n\
    }\n/*\n    >>> parse_primes(\"2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,",
  "{\n    auto filtered = string[];\n    foreach(i, s; strings)\n    {\n        if(s.startsWith(prefix))\n\
    \        {\n            filtered ~= s;\n        }\n    }\n    return filtered;\n\
    }", "{\n    return strings.filter!(a => a.startsWith(prefix)).array;\n}", "{\n\
    \    return filter!(s => s.startsWith(prefix))(strings);\n}\n/*\n Filter an input\
    \ array of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\n//string[] filter_by_prefix(string[]\
    \ strings, string prefix) \n//{\n//    return filter!(s => s.startsWith(prefix))(strings);\n\
    //}\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n\
    */\n//string[] filter_by_prefix(string[] strings, string prefix) \n//{\n//   \
    \ return filter!(s => s.startsWith(prefix))(strings);\n//}\n/*\n Filter an input\
    \ array of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\n//string[] filter_by_prefix(string[]\
    \ strings, string prefix) \n//{\n//    return filter!(s => s.startsWith(prefix))(strings);\n\
    //}\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n\
    */\n//string[] filter_by_prefix(string[] strings, string prefix) \n//{\n//   \
    \ return filter!(s => s.startsWith(prefix))(strings);\n//}\n/*\n Filter an input\
    \ array of strings only for ones that start with a given prefix.\n   ", "{\n \
    \   string[] result;\n    foreach(string s; strings)\n    {\n        if(s.beginsWith(prefix))\n\
    \        {\n            result ~= s;\n        }\n    }\n    return result;\n}\n\
    /*\n    Given an array of strings, return the indices where the array of strings\
    \ differ.\n    >>> diff_indices([], [])\n    []\n    >>> diff_indices([\"1\",\
    \ \"2\", \"3\"], [\"1\", \"3\", \"3\"])\n    [1]\n    >>> diff_indices([\"1\"\
    , \"2\", \"3\"], [\"1\", \"2\", \"3\", \"4\"])\n    [3]\n    >>> diff_indices([\"\
    1\", \"2\", \"3\", \"4\"], [\"1\", \"2\", \"3\"])\n    [3]\n    >>> diff_indices([\"\
    1\", \"2\", \"3\"], [\"1\", \"2\", \"3\"])\n    []\n    >>> diff_indices([\"1\"\
    , \"2\", \"3\"], [\"4\", \"5\", \"6\"])\n    [0, 1, 2]\n*/", "{\n    return strings.filter!(s\
    \ => s.startsWith(prefix));\n}\n/*\n Determine if a string array is a palindrome\
    \ by using \n the std.algorithm.isPalindrome function.\n    >>> is_palindrome([])\n\
    \    true\n    >>> is_palindrome([\"racecar\"])\n    true\n    >>> is_palindrome([\"\
    hello\", \"world\"])\n    false\n*/", "{\n    return filter!(a => a.startsWith(prefix))(strings);\n\
    }", "  in\n    assert(strings.length >= 0);\n    assert(prefix.length >= 0);\n\
    \  out(result)\n    assert(result.length <= strings.length);\n    foreach (i,\
    \ s; result) assert(s.length >= prefix.length);\n    foreach (i, s; result) assert(s[0\
    \ .. prefix.length] == prefix);\n  do\n    /*@\n      /@/ local_variables\n  \
    \      int i = 0;\n        int result_len = 0;\n        string[] result = @alloc(@mutable,\
    \ @size(strings.length));\n      /@/ end\n    @*/\n    foreach (i, s; strings)\
    \ {\n      /*@\n        /@/ local_variables\n          bool _match = true;\n \
    \       /@/ end\n      @*/\n      foreach (j, c; prefix) {\n        if (s[j] !=\
    \ c) {\n          /*@\n            /@/ local_variables\n              _match =\
    \ false;\n            /@/ end\n          @*/\n          break;\n        }\n  \
    \    }\n      if (_match) {\n        result[result_len] = s;\n        result_len++;\n\
    \      }\n    }\n    return result[0 .. result_len];\n}", "{\n  string[] result;\n\
    \  foreach(string str; strings) \n  {\n    if(startsWith(str, prefix)) \n    {\n\
    \      result ~= str;\n    }\n  }\n  return result;\n}", "{\n    return strings.filter!(s\
    \ => s.startsWith(prefix));\n}", "    in(string[] strings, string prefix) nothrow\n\
    {\n    string[] ret_val;\n    for (int i = 0; i < strings.length; i++)\n    {\n\
    \        if (strings[i].startsWith(prefix))\n        {\n            ret_val ~=\
    \ strings[i];\n        }\n    }\n    return ret_val;\n}\n/*\n    >>> swap_pair(12)\n\
    \    21\n    >>> swap_pair(21)\n    12\n    >>> swap_pair(24)\n    42\n*/", "in{\n\
    \  assert(strings.size >= 0);\n  assert(prefix.size >= 0);\n}\nout(result) {\n\
    \  assert(result.size >= 0);\n  assert(result.size <= strings.size);\n  foreach(string\
    \ s; result) {\n    assert(s.startsWith(prefix));\n  }\n}\n{\n  int num_matches\
    \ = 0;\n  foreach(string s; strings) {\n    if(s.startsWith(prefix)) {\n     \
    \ num_matches++;\n    }\n  }\n  string[] result = new string[num_matches];\n \
    \ int i = 0;\n  foreach(string s; strings) {\n    if(s.startsWith(prefix)) {\n\
    \      result[i] = s;\n      i++;\n    }\n  }\n  return result;\n}", "{\n    //\
    \ O(n)\n    return strings.filter!(e => e.startsWith(prefix));\n}\n/*\nFilter\
    \ an input array of strings only for ones that have no duplicates.\n    >>> filter_by_duplicates([])\n\
    \    []\n    >>> filter_by_duplicates([\"abc\", \"bcd\", \"cde\", \"array\"])\n\
    \    [\"abc\", \"bcd\", \"cde\"]\n    >>> filter_by_duplicates([\"abc\", \"bcd\"\
    , \"abc\", \"array\"])\n    [\"bcd\", \"array\"]\n*/\nstring[] filter_by_duplicates(string[]\
    \ strings)\n{\n    // O(n^2)\n    return strings.filter!(e => strings.count(e)\
    \ < 2);\n}\n/*\nFilter an input array of strings only for ones that have no duplicates.\n\
    \    >>> filter_by_duplicates([])\n    []\n    >>> filter_by_duplicates([\"abc\"\
    , \"bcd\", \"cde\", \"array\"])\n    [\"abc\", \"bcd\", \"cde\"]\n    >>> filter_by_duplicates([\"\
    abc\", \"bcd\", \"abc\", \"array\"])\n    [\"bcd\", \"array\"]\n*/\nstring[] filter_by_duplicates_hash(string[]\
    \ strings)\n{\n    // O(n)\n    return strings.filter!(e => {\n        string[]\
    \ mutable_strings = strings.dup;\n        mutable_strings.remove(e);\n       \
    \ return !mutable_strings.contains(e);\n    });\n}", "{\n    immutable filtered\
    \ = std.algorithm.filter!(s => s.startsWith(prefix))(strings);\n    return filtered.array;\n\
    }", "{\n    return strings.filter!(a => a.startsWith(prefix));\n}\n// the above\
    \ is equivalent to:\nstring[] filter_by_prefix2(string[] strings, string prefix)\
    \ \n{\n    return strings.filter!((a) => a.startsWith(prefix));\n}\n// the above\
    \ is equivalent to:\nstring[] filter_by_prefix3(string[] strings, string prefix)\
    \ \n{\n    return strings.filter!((string a) => a.startsWith(prefix));\n}", "in\n\
    {\n    foreach (str; strings) {\n        assert(str.length > 0);\n    }\n}\nout\
    \ (result) \n{\n    foreach (str; result) {\n        assert(str.length > 0);\n\
    \        assert(str.startsWith(prefix));\n    }\n}\nbody \n{\n    return strings.filter!(str\
    \ => str.startsWith(prefix));\n}", "{\n    auto start = lower_bound(strings, prefix);\n\
    \    auto end = upper_bound(strings, prefix ~ \"zzz\");\n    return slice(strings,\
    \ start, end);\n}\n// Example usage:\nunittest \n{\n    auto strings = [\"abc\"\
    , \"bcd\", \"cde\", \"array\"];\n    assert(filter_by_prefix(strings, \"a\") ==\
    \ [\"abc\", \"array\"]);\n}", "{\n\treturn strings.filter!(s => s.startsWith(prefix)).array;\n\
    }", "{\n  import std.algorithm.filter;\n  import std.algorithm.mutation;\n  return\
    \ strings.filter!(a => a.startsWith(prefix)).array;\n}", "{\n    string[] filtered;\n\
    \    foreach(s; strings) \n    {\n        if(s.startsWith(prefix)) \n        {\n\
    \            filtered ~= s;\n        }\n    }\n    return filtered;\n}", "{\n\
    \    import std.algorithm : filter;\n    return strings.filter!(a => a.startsWith(prefix)).array;\n\
    }\n/*\n Return an array of all elements of an input array that are equal to a\
    \ given value.\n    >>> filter_by_value([1, 2, 3, 4, 5], 3)\n    [3]\n    >>>\
    \ filter_by_value([1, 2, 3, 4, 5], 6)\n    []\n    \n*/", "{\n\tforeach(string\
    \ s; strings) \n\t{\n\t\tif(s.startsWith(prefix))\n\t\t\twriteln(s);\n\t}\n\t\
    return strings;\n}", "    in {\n    assert(strings.length <= 20);\n    foreach\
    \ (string str; strings)\n        assert(str.length <= 20);\n    assert(prefix.length\
    \ <= 20);\n}\nbody {\n    string[] result;\n    foreach (string str; strings)\
    \ {\n        if (str.startsWith(prefix)) {\n            result ~= str;\n     \
    \   }\n    }\n    return result;\n}\n/*\n Filter an input array of strings only\
    \ for ones that start with a given prefix.\n    >>> filter_by_prefix([], \"a\"\
    )\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\
    a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings,\
    \ string prefix) \n    in {\n    assert(strings.length <= 20);\n    foreach (string\
    \ str; strings)\n        assert(str.length <= 20);\n    assert(prefix.length <=\
    \ 20);\n}\nbody {\n    string[] result;\n    foreach (string str; strings) {\n\
    \        if (str.startsWith(prefix)) {\n            result ~= str;\n        }\n\
    \    }\n    return result;\n}\npublic class BinarySearch {\n/*\n     Binary search\
    \ requires a sorted array.\n    >>> binary_search([], 0)\n    Traceback (most\
    \ recent call last):\n        ...\n    AssertionError\n    >>> binary_search([1,2,3,4,5],\
    \ 0)\n    Traceback (most recent call last):\n        ...\n    AssertionError\n\
    \    >>> binary_search([1,2,3,4,5], 6)\n    Traceback (most recent call last):\n\
    \        ...\n    AssertionError\n    >>> binary_search([0,1,2,3,4,5], 0)\n  \
    \  0\n    >>> binary_search([0,1,2,3,4,5], 1)\n    1\n    >>> binary_search([0,1,2,3,4,5],\
    \ 2)\n    2\n    >>> binary_search([0,1,2,3,4,5], 3)\n    3\n    >>> binary_search",
  "  in(strings) in(prefix)\n{\n  import std.algorithm : filter;\n  return strings.filter!(a\
    \ => a.startsWith(prefix)).array;\n}", "{\n    string[] filtered;\n    foreach(string\
    \ s; strings) \n    {\n        if(s.startsWith(prefix)) \n        {\n        \
    \    filtered ~= s;\n        }\n    }\n    return filtered;\n}", "{\n    return\
    \ strings.filter!(str => str.startsWith(prefix));\n}\n/*\n    >>> filter_by_prefix_alt([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix_alt([\"abc\", \"bcd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"array\"]\n*/", "    in { foreach(string s; strings)\
    \ { assert(s.length > 0); } }\n    out(result) { foreach(string s; result) { assert(s.startsWith(prefix));\
    \ } }\n{\n    string[] filtered = strings.filter!(s => s.startsWith(prefix))();\n\
    \    return filtered;\n}", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }\n/*\n Filter an input array of strings only for ones that end with a given suffix.\n\
    \    >>> filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"y\")\n    [\"array\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    return strings.filter!(s => s.endsWith(suffix));\n\
    }\n/*\n Filter an input array of strings only for ones that do not start with\
    \ a given prefix.\n    >>> filter_not_by_prefix([], \"a\")\n    []\n    >>> filter_not_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"bcd\", \"cde\"]\n    \n*/\n\
    string[] filter_not_by_prefix(string[] strings, string prefix) \n{\n    return\
    \ strings.filter!(s => !s.startsWith(prefix));\n}\n/*\n Filter an input array\
    \ of strings only for ones that do not end with a given suffix.\n    >>> filter_not_by_suffix([],\
    \ \"a\")\n    []\n    >>> filter_not_by_suffix([\"abc\", \"bcd\", \"cde\", \"\
    array\"], \"y\")\n    [\"abc\", \"bcd\", \"cde\"]\n    \n*/\nstring[] filter_not_by_suffix(string[]\
    \ strings, string suffix) \n{\n    return strings.filter!(s => !s.endsWith(suffix));\n\
    }\n/*\nFilter an input array of strings only for ones that include a given substring.\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"ar\")\n    [\"abc\", \"array\"]\n    \n\
    */\nstring[] filter_by_substring(string[] strings, string substring) \n{\n   \
    \ return strings.filter!(s => s.indexOf(substring) != -1);\n}\n/*\n Filter an\
    \ input", "{\n    auto ret = new string[];\n    foreach(string s; strings) \n\
    \    {\n        if(s.startsWith(prefix)) \n        {\n            ret ~= s;\n\
    \        }\n    }\n    return ret;\n}", "{\n    //return strings.filter!(str =>\
    \ str.startsWith(prefix)).array;\n    return strings.filter!((str) => str.startsWith(prefix)).array;\n\
    }\n//Mapping a function to an array", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }\n/*\n Given an array of strings and a string, find the first index of that string\
    \ in the array.\n    >>> index_of_first_prefix([\"abc\", \"bcd\", \"cde\", \"\
    array\"], \"a\")\n    0\n    >>> index_of_first_prefix([\"abc\", \"bcd\", \"cde\"\
    , \"array\"], \"b\")\n    1\n    >>> index_of_first_prefix([\"abc\", \"bcd\",\
    \ \"cde\", \"array\"], \"c\")\n    2\n    >>> index_of_first_prefix([\"abc\",\
    \ \"bcd\", \"cde\", \"array\"], \"d\")\n    -1\n*/", "{\n    int n = strings.length;\n\
    \    string[] output;\n    foreach (i, s; strings)\n    {\n        // if (s.startsWith(prefix))\
    \ \n        if (s.length > prefix.length) \n        {\n            bool match\
    \ = true;\n            for (int j = 0; j < prefix.length; j++) \n            {\n\
    \                if (s[j] != prefix[j]) \n                {\n                \
    \    match = false;\n                    break;\n                }\n         \
    \   }\n            if (match)\n            {\n                output ~= s;\n \
    \           }\n        }\n    }\n    return output;\n}", "in {\n    assert(strings.length\
    \ >= 0);\n    for (int i = 0; i < strings.length; i++) {\n        assert(strings[i].length\
    \ > 0);\n    }\n}\nout (result) {\n    for (int i = 0; i < result.length; i++)\
    \ {\n        assert(prefix.startswith(result[i]));\n    }\n}\n{\n    string[]\
    \ result = [];\n    for (int i = 0; i < strings.length; i++) {\n        if (strings[i].startswith(prefix))\
    \ {\n            result.append(strings[i]);\n        }\n    }\n    return result;\n\
    }", "{\n    return strings.filter!(s => s.startsWith(prefix));\n}\n/*\n Filter\
    \ an input array of strings only for ones that have a given suffix.\n    >>> filter_by_suffix([],\
    \ \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"y\")\n    [\"array\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings,\
    \ string suffix) \n{\n    return strings.filter!(s => s.endsWith(suffix));\n}\n\
    /*\n Reduce an input array of strings to its longest string.\n    >>> longest_string([])\n\
    \    \"\"\n    >>> longest_string([\"a\", \"ab\", \"c\"])\n    \"ab\"\n    \n\
    */\nstring longest_string(string[] strings) \n{\n    return strings.reduce!((s1,\
    \ s2) => s1.length > s2.length ? s1 : s2)(\"\");\n}\n/*\n Reduce an input array\
    \ of strings to its shortest string.\n    >>> shortest_string([])\n    \"\"\n\
    \    >>> shortest_string([\"a\", \"ab\", \"c\"])\n    \"a\"\n    \n*/\nstring\
    \ shortest_string(string[] strings) \n{\n    return strings.reduce!((s1, s2) =>\
    \ s1.length < s2.length ? s1 : s2)(\"\");\n}\n/*\n Return a list of the lengths\
    \ of all the input strings.\n    >>> string_lengths([])\n    []\n    >>> string_lengths([\"\
    a\", \"ab\", \"c\"])\n    [1, 2, 1]\n    \n*/", "{\n    int num_matches = 0;\n\
    \    foreach (string s; strings)\n    {\n        if (s.startsWith(prefix))\n \
    \       {\n            num_matches++;\n        }\n    }\n    string[] result =\
    \ new string[];\n    result.length = num_matches;\n    int current_index = 0;\n\
    \    foreach (string s; strings)\n    {\n        if (s.startsWith(prefix))\n \
    \       {\n            result[current_index] = s;\n            current_index++;\n\
    \        }\n    }\n    return result;\n}\n/*\n Filter an input string array for\
    \ strings starting with a given prefix\n    \n*/", "{\n    if(strings.length ==\
    \ 0)\n    {\n        return [];\n    }\n    else\n    {\n        if(strings[0].find(prefix)\
    \ == 0)\n        {\n            return [strings[0]] ~ filter_by_prefix(strings[1..$],\
    \ prefix);\n        }\n        else\n        {\n            return filter_by_prefix(strings[1..$],\
    \ prefix);\n        }\n    }\n}\n//also works with lines\nstring[] filter_by_prefix(string\
    \ strings, string prefix) \n{\n    return filter_by_prefix(split(strings, '\\\
    n'), prefix);\n}\n// Also works with tags\nstring[] filter_by_prefix(Tag[] tags,\
    \ string prefix) \n{\n    return filter_by_prefix(map!((t) {return t.name;})(tags),\
    \ prefix);\n}\nstruct tag_filter(string prefix)\n{\n    Tag[] tags;\n    mixin(\"\
    this = filter_by_prefix(tags, prefix);\");\n}", "{\n    return strings.filter!(s\
    \ => s.startsWith(prefix)).array;\n}\n/*\n Check if at least one item of an array\
    \ passes a given test.\n    >>> any_of_v([1, 2, 3], (a) => a > 2)\n    true\n\
    \    >>> any_of_v([1, 2, 3], (a) => a > 3)\n    false\n*/", "{\n    immutable\
    \ returned = new string[];\n    foreach(string str; strings)\n    {\n        if(startsWith(str,\
    \ prefix))\n        {\n            returned ~= str;\n        }\n    }\n    return\
    \ returned;\n}", "{\n    string[] result;\n    foreach(string s; strings)\n  \
    \  {\n        if(s.startsWith(prefix))\n        {\n            result ~= s;\n\
    \        }\n    }\n    return result;\n}\n/*\n \n Merge two sorted arrays of numbers\
    \ into a single sorted array.\n    >>> merge_sorted([1, 2, 3], [])\n    [1, 2,\
    \ 3]\n    >>> merge_sorted([1, 2, 3], [4, 5, 6])\n    [1, 2, 3, 4, 5, 6]\n   \
    \ >>> merge_sorted([1, 3, 5], [2, 4, 6])\n    [1, 2, 3, 4, 5, 6]\n*/\nuint[] merge_sorted(uint[]\
    \ a, uint[] b) \n{\n    uint[] result;\n    uint i, j;\n    i = 0;\n    j = 0;\n\
    \    while (i < a.length && j < b.length) \n    {\n        if (a[i] < b[j]) \n\
    \        {\n            result ~= a[i];\n            i++;\n        } \n      \
    \  else \n        {\n            result ~= b[j];\n            j++;\n        }\n\
    \    }\n    while (i < a.length) \n    {\n        result ~= a[i];\n        i++;\n\
    \    }\n    while (j < b.length) \n    {\n        result ~= b[j];\n        j++;\n\
    \    }\n    return result;\n}\n/*\n Given a list of numbers and a window size,\
    \ return the moving average of the numbers.\n    >>> moving_average([1, 2, 3,\
    \ 4, 5], 2)\n    [1.5, 2.5, 3.5, 4.5]\n*/\ndouble[] moving_average(double[] numbers,\
    \ uint window_size) \n{\n    double[] result;\n    if (numbers.length == 0) \n\
    \    {\n        return result;\n    }\n    for (uint i = 0; i <= numbers.length\
    \ - window_size; i++) \n    {\n        auto sum = 0.0;\n        for (uint j",
  "{\n    return filter!(v => startsWith(v, prefix))(strings);\n}\n/*\nGiven a list\
    \ of names and a mapping of name to number,\n    return a list of the names that\
    \ are not in the mapping.\n    >>> missing_names([\"Joe\", \"Jane\", \"John\"\
    ],\n    ... {\"John\": 1, \"Jane\": 2})\n    [\"Joe\"]\n*/\nstring[] missing_names(string[]\
    \ names, string[] mapping)\n{\n    return filter!(n => !(n in mapping))(names);\n\
    }\n/*\nGiven a list of integers and a mapping of integer to boolean,\n    return\
    \ a list of the integers that are not in the mapping\n    or that are in the mapping\
    \ and not true.\n    >>> missing_numbers([1, 2, 3], [1: true, 2: false])\n   \
    \ [2, 3]\n*/", "{\n    auto filtered = []{\n        foreach(string s; strings)\
    \ {\n            if (s.startsWith(prefix)) {\n                yield s;\n     \
    \       }\n        }\n    }();\n    return filtered.array;\n}", "{\n    return\
    \ strings.filter!(a => a.startsWith(prefix));\n}\n/*\n    >>> count_spaces(\"\"\
    )\n    0\n    >>> count_spaces(\"a\")\n    0\n    >>> count_spaces(\"a \")\n \
    \   1\n    >>> count_spaces(\"a b c\")\n    2\n    >>> count_spaces(\"  \")\n\
    \    2\n    >>> count_spaces(\"a  b  c  \")\n    4\n    >>> count_spaces(\"a \
    \ b\")\n    2\n*/", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }\n/**\nFilter an input array of strings only for ones that start with a given\
    \ prefix.\n>>> filter_by_prefix([], \"a\")\n[]\n>>> filter_by_prefix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n[\"abc\", \"array\"]", "{\n  string[]\
    \ filtered_strings;\n  foreach(string s; strings) \n  {\n    if(s.startsWith(prefix))\
    \ \n    {\n      filtered_strings ~= s;\n    }\n  }\n  return filtered_strings;\n\
    }", "{\n    string[] filtered = [\"_\"];\n    for (i,s; i < strings.length; i++)\
    \ \n    {\n        // if string starts with prefix\n        if (s = strings[i];\
    \ starts_with(s, prefix)) \n        {\n            filtered ~= s;\n        }\n\
    \    }\n    // return without the first element (just a placeholder)\n    return\
    \ filtered[1..$];\n}", "{\n    string[] filter_by_prefix_result;\n    foreach\
    \ (string s; strings) \n    {\n        if (s.startsWith(prefix)) \n        {\n\
    \            filter_by_prefix_result ~= s;\n        }\n    }\n    return filter_by_prefix_result;\n\
    }\n/*\n Find all the possible combinations of a set of strings, separated by a\
    \ given\n separator.\n    >>> combinations([\"hello\", \"world\"], \".\")\n  \
    \  [\"hello.world\", \"world.hello\"]\n    \n*/\nstring[] combinations(string[]\
    \ strings, string separator) \n{\n    int[] combinations_range;\n    foreach (i;\
    \ 0 .. strings.length) \n    {\n        combinations_range ~= i;\n    }\n    int[]\
    \ combinations_indexes;\n    foreach (i; 0 .. strings.length) \n    {\n      \
    \  combinations_indexes ~= 0;\n    }\n    string[] combinations_result;\n    bool\
    \ combinations_more = true;\n    while (combinations_more) \n    {\n        string\
    \ combinations_current;\n        foreach (i; combinations_range) \n        {\n\
    \            combinations_current ~= strings[combinations_indexes[i]];\n     \
    \       if (i != combinations_range.length - 1) \n            {\n            \
    \    combinations_current ~= separator;\n            }\n        }\n        combinations_result\
    \ ~= combinations_current;\n        int combinations_i = 0;\n        while (combinations_i\
    \ < combinations_range.length) \n        {\n            combinations_indexes[combinations_i]\
    \ += 1;\n            if (combinations_indexes[combinations_i] == strings.length)\
    \ \n            {\n                combinations_indexes[combinations_i] = 0;\n\
    \                combinations_i += 1;\n            }\n            else \n    \
    \        {\n                break;\n            }\n        }\n        if (combinations_i\
    \ == combinations_range.length) \n        {\n            combinations_more = false;\n\
    \        }\n    }\n    return combinations_result;\n}\n/*\n Return a dictionary\
    \ of keyword arguments for a given function.\n    >>> kwargs(foo, [\"bar\",",
  "{\n    import std.algorithm : filter;\n    return strings.filter!(a => a.startsWith(prefix));\n\
    }", "{\n    // Create the output empty array.\n    string[] output;\n    foreach\
    \ (str; strings)\n    {\n        if (str.startsWith(prefix))\n        {\n    \
    \        output ~= str;\n        }\n    }\n    return output;\n}", "  in\n  {\n\
    \    assert(prefix.length() > 0);\n  }\n  body\n  {\n    return strings.filter!(s\
    \ => s.startsWith(prefix));\n  }", "{\n\treturn strings.filter!(s => s.startsWith(prefix)).array;\n\
    }\n/*\nSort a list of strings with a given prefix.\n    >>> sort_by_prefix([],\
    \ \"a\")\n    []\n    >>> sort_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"array\"]\n*/\nstring[] sort_by_prefix(string[] strings,\
    \ string prefix) \n{\n\treturn strings.filter!(s => s.startsWith(prefix)).array.sort;\n\
    }\n/*\nFilter an input array of strings only for ones that contain a given substring.\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"bc\")\n    [\"abc\", \"bcd\"]\n*/\nstring[]\
    \ filter_by_substring(string[] strings, string substring) \n{\n\treturn strings.filter!(s\
    \ => s.contains(substring)).array;\n}\n/*\nSort a list of strings with a given\
    \ substring.\n    >>> sort_by_substring([], \"a\")\n    []\n    >>> sort_by_substring([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"bc\")\n    [\"abc\", \"bcd\"]\n*/\nstring[]\
    \ sort_by_substring(string[] strings, string substring) \n{\n\treturn strings.filter!(s\
    \ => s.contains(substring)).array.sort;\n}\n/*\nFind the first string in an array\
    \ that starts with a given prefix.\n    >>> find_first_by_prefix([], \"a\")\n\
    \    null\n    >>> find_first_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    \"abc\"\n*/\nstring find_first_by_prefix(string[] strings, string\
    \ prefix) \n{\n\treturn strings.filter!(s => s.startsWith(prefix)).array.front;\n\
    }\n/*\nFind the first string in an array that contains a given substring.\n  \
    \  >>> find_first_by_substring([], \"a\")\n   ", "in {\n    assert(prefix.length\
    \ > 0);\n}\nout (result) {\n    assert(result.length <= strings.length);\n   \
    \ foreach (string s; result) {\n        assert(s.startsWith(prefix));\n    }\n\
    } \nbody {\n    string[] result;\n    foreach (string s; strings) {\n        if\
    \ (s.startsWith(prefix)) {\n            result ~= s;\n        }\n    }\n    return\
    \ result;\n}", "  in (string[], string) out (string[])\n{\n  string[] result;\n\
    \  foreach (string s; strings) {\n    if (s.starts_with(prefix)) {\n      result\
    \ ~= s;\n    }\n  }\n  return result;\n}", "{\n    return strings.filter!( (s){\
    \ return s.startsWith(prefix); });\n}", "{\n    import std.algorithm;\n    import\
    \ std.range;\n    return strings.filter!(a => a.startsWith(prefix)).array;\n}",
  "{\n    string[] result;\n    foreach(string s; strings)\n    {\n        if(s.startsWith(prefix))\n\
    \        {\n            result ~= s;\n        }\n    }\n    return result;\n}\n\
    /*\n  Return a new array with the elements sorted by length.\n    >>> sort_by_length([\"\
    abc\", \"bcd\", \"cde\", \"array\"])\n    [\"abc\", \"bcd\", \"cde\", \"array\"\
    ]\n    \n*/\nstring[] sort_by_length(string[] strings) \n{\n    sort!((a, b) =>\
    \ a.length < b.length)(strings);\n    return strings;\n}\n/*\n  Return the array\
    \ with each element converted to upper case.\n    >>> to_upper([\"abc\", \"bcd\"\
    , \"cde\", \"array\"])\n    [\"ABC\", \"BCD\", \"CDE\", \"ARRAY\"]\n    \n*/\n\
    string[] to_upper(string[] strings) \n{\n    return map!(s => s.toUpper)(strings);\n\
    }\n/*\n  Return a new array with only the elements that are anagrams of the input\
    \ string.\n    >>> anagrams(\"abc\", [\"abc\", \"bcd\", \"cde\", \"array\"])\n\
    \    [\"abc\"]\n    >>> anagrams(\"cba\", [\"abc\", \"bcd\", \"cde\", \"array\"\
    ])\n    [\"abc\"]\n    >>> anagrams(\"cba\", [\"abc\", \"bcd\", \"cde\", \"array\"\
    ])\n    [\"abc\"]\n    >>> anagrams(\"foo\", [\"abc\", \"bcd\", \"cde\", \"array\"\
    ])\n    []\n    \n*/\nstring[] anagrams(string s, string[] strings) \n{\n    bool\
    \ test(string a)\n    {\n        return a.toUpper().sort() == s.toUpper().sort();\n\
    \    }\n    return filter!test(strings);\n}\n/*\n  Return a new array with the\
    \ numbers in reverse order.\n    >>> reverse([1, 2, 3, 4])\n    [4, 3, 2, 1]\n\
    \    >>> reverse([10, 20, 30, 40])\n    [40, 30, 20", "{\n    auto prefix_len\
    \ = prefix.length;\n    return strings.filter!(x => x.length >= prefix_len &&\
    \ x[0 .. prefix_len] == prefix);\n}", "{\n    return strings.filter!(s => s.indexOf(prefix)\
    \ == 0);\n}", "{\n    return strings.filter!(x => x.startsWith(prefix));\n}",
  "{\n    if(strings.length == 0) \n    {\n        return strings;\n    } \n    else\
    \ if(strings[0].startswith(prefix)) \n    {\n        return [strings[0]] ~ filter_by_prefix(strings[1..$],\
    \ prefix);\n    } \n    else \n    {\n        return filter_by_prefix(strings[1..$],\
    \ prefix);\n    }\n}", "{\n    string[] result;\n    foreach(s; strings) \n  \
    \  {\n        if(s.startsWith(prefix))\n            result ~= s;\n    }\n    return\
    \ result;\n}\n/*\n Get all prefixes that can be constructed from a set of strings.\n\
    \    >>> set_of_prefixes([\"abc\", \"bcd\", \"cde\", \"array\"])\n    [\"a\",\
    \ \"b\", \"c\", \"d\", \"e\", \"ar\", \"ra\", \"arr\", \"rra\", \"rray\", \"ray\"\
    ]\n*/\nstring[] set_of_prefixes(string[] strings)\n{\n    string[] result;\n \
    \   foreach(s; strings) \n    {\n        foreach(prefix; s.split(\"\"))\n    \
    \        result ~= prefix;\n    }\n    return result;\n}", "    return strings.filter!(s\
    \ => s.startsWith(prefix));\n/*\nRemove all vowels from a string.\n    >>> remove_vowels(\"\
    abcde\")\n    \"bcdf\"\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"\
    hello world\")\n    \"hll wrld\"\n*/\nstring remove_vowels(string s) \n    string\
    \ vowels = \"aeiou\";\n    auto is_vowel = (c => c in vowels);\n    return s.filter!(c\
    \ => !is_vowel(c));\n/*\n Pad a string from the left with a certain character.\n\
    \    >>> pad_left(\"abc\", 10, '-')\n    \"------abc\"\n    >>> pad_left(\"abc\"\
    , 4, '-')\n    \"abc\"\n    >>> pad_left(\"abc\", 0, '-')\n    \"abc\"\n    >>>\
    \ pad_left(\"abc\", -1, '-')\n    \"abc\"\n*/\nstring pad_left(string s, int n,\
    \ char pad_char) \n    return s.dup.padLeft(n, pad_char);\n/*\nPadd a string from\
    \ the right with a certain character.\n    >>> pad_right(\"abc\", 10, '-')\n \
    \   \"abc------\"\n    >>> pad_right(\"abc\", 4, '-')\n    \"abc\"\n    >>> pad_right(\"\
    abc\", 0, '-')\n    \"abc\"\n    >>> pad_right(\"abc\", -1, '-')\n    \"abc\"\n\
    */\nstring pad_right(string s, int n, char pad_char) \n    return s.dup.padRight(n,\
    \ pad_char);\n/*\nFlatten an array with two dimensions.\n    >>> flatten([[1,\
    \ 2], [3, 4], [5, 6]])\n    [1, 2, 3, 4, 5, 6]\n    >>> flatten([[1, 2], [3, 4],\
    \ [5, 6], []])\n    [1, 2, 3, 4, 5, 6]\n    >>> flatten([])\n    []\n*/\nalias\
    \ ArrayLength = size_t;\nT[] flatt", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }", "{\n    return filter!(x => x.startsWith(prefix))(strings);\n}\n/*\n An arity-3\
    \ version of filter which takes a predicate, a container of elements and a place\
    \ to put the results.\n \n    >>> filter!(x => x > 10)([1, 9, 12, 15, 8, 18])([])\n\
    \    [12, 15, 18]\n    \n*/\nTItem[] filter!(alias pred, Item)(Item[] items, TItem[]\
    \ results) if (isCallable!(pred, int, Item)) \n{\n    return items.filter!pred(results);\n\
    }\n/*\n A function which creates a Slice from a forward range.\n    >>> auto r\
    \ = iota(10);\n    >>> r.take(3)\n    [0, 1, 2]\n    >>> toSlice(r)\n    [0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]\n    \n*/\n//auto toSlice(R)(R r) if (isForwardRange!R)\
    \ \n//{\n//    return r.front.dup.put(r);\n//}\n/*\n A version of transform which\
    \ takes a separate input and output container.\n    >>> auto inc = (x) => x +\
    \ 1;\n    >>> transform!inc([1, 2, 3])([])\n    [2, 3, 4]\n    \n*/\nTItem[] transform!(alias\
    \ func, Item)(Item[] items, TItem[] results) if (isCallable!(func, int, Item))\
    \ \n{\n    return items.transform!func(results);\n}\n/*\n A version of map which\
    \ can also return information about how many times the iterator was incremented.\n\
    \ \n    >>> auto inc = (x) => x + 1;\n    >>> auto f = map!inc;\n    >>> int count;\n\
    \    >>> f([1, 2, 3], count)\n    [2, 3, 4]\n    >>> count\n    3\n    \n*/\n\
    TItem[] map!(alias func, Item)(Item[] items, size_t numCalls) if (isCallable!(func,\
    \ int, Item)) \n{\n    numCalls = 0;\n    return", "{\n  return strings.filter!(a\
    \ => a.startsWith(prefix)).array;\n}", "{\n    return filter!(x => x.startsWith(prefix))(strings);\n\
    }\n/*\n    Remove the suffix of a given string.\n    >>> remove_suffix(\"abc.exe\"\
    , \".exe\")\n    \"abc\"\n*/\nstring remove_suffix(string input, string suffix)\n\
    {\n    return input[0..$-suffix.length];\n}", "{\n    int length = strings.length;\n\
    \    string[] filtered = new string[length];\n    foreach (index, string s; strings)\n\
    \    {\n        if (s.startsWith(prefix))\n        {\n            filtered[index]\
    \ = s;\n        }\n    }\n    return filtered;\n}\n/*\n Return the reciprocal\
    \ of a value.\n    >>> reciprocal(2)\n    0.5\n    >>> reciprocal(0)\n    infinity\n\
    \    >>> reciprocal(-3)\n    -0.3333333333333333\n*/\ndouble reciprocal(double\
    \ n) \n{\n    if (n == 0)\n    {\n        return double.infinity;\n    }\n   \
    \ return 1.0 / n;\n}\n/*\n Swaps the positions of two values that are passed by\
    \ reference.\n    >>> a = \"a\"\n    >>> b = \"b\"\n    >>> swap(a, b)\n    >>>\
    \ a\n    \"b\"\n    >>> b\n    \"a\"\n*/", "{\n    string[] res;\n    foreach(str;\
    \ strings)\n    {\n        if(str.startsWith(prefix))\n        {\n           \
    \ res ~= str;\n        }\n    }\n    return res;\n}", "{\n    return strings.filter!(s\
    \ => s.startsWith(prefix)).array;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
