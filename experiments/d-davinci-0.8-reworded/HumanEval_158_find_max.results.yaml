language: d
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  string max = \"\";\n  int max_count = 0;\n  foreach(string word;\
    \ words)\n  {\n    int count = 0;\n    foreach(char c; word)\n    {\n      if(c\
    \ != '0')\n      {\n        count += 1;\n        word = replace(word, c, '0');\n\
    \      }\n    }\n    if(count > max_count)\n    {\n      max = word;\n      max_count\
    \ = count;\n    }\n  }\n  return max;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpod_06zbx.d(29): Error: undefined identifier `replace`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpod_06zbx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string max_string = words[0];\n    foreach(i,\
    \ s; words) \n    {\n        int unique_count = 0;\n        foreach(c; s)\n  \
    \      {\n            if(count(c, s) == 1)\n            {\n                unique_count++;\n\
    \            }\n        }\n        if(unique_count > max)\n        {\n       \
    \     max = unique_count;\n            max_string = s;\n        }\n    }\n   \
    \ return max_string;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl0yy1iy3.d(26): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0yy1iy3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto a = new string[];\n    int max_count = 0;\n    for (int\
    \ i = 0; i < words.length; i++) \n    {\n        a ~= words[i];\n        auto\
    \ c = count_unique(words[i]);\n        if (c > max_count) \n        {\n      \
    \      max_count = c;\n        }\n    }\n    auto b = new string[];\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        if (count_unique(a[i]) == max_count)\
    \ \n        {\n            b ~= a[i];\n        }\n    }\n    return b[0];\n}\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0qqm9uf.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpa0qqm9uf.d(24): Error: undefined identifier `count_unique`

    /tmp/tmpa0qqm9uf.d(30): Error: new can only create structs, dynamic arrays or
    class objects, not `string[]`''s

    /tmp/tmpa0qqm9uf.d(33): Error: undefined identifier `count_unique`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0qqm9uf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    struct word_t \n    {\n        string word;\n        uint count;\n\
    \    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7oup2cah.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7oup2cah.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    foreach(string word; words)\n   \
    \ {\n        if(result.length < word.length)\n        {\n            auto set\
    \ = new TypeTuple!char;\n            foreach(char ch; word)\n            {\n \
    \               set.insert(ch);\n            }\n            if(result.length <\
    \ set.length)\n            {\n                result = word;\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3j6hil_m.d(24): Error: template instance `TypeTuple!char` template
    `TypeTuple` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3j6hil_m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string the_string;\n    int max_length = 0;\n    foreach(string\
    \ a; words)\n    {\n        string tmp = \"\";\n        foreach(char c; a)\n \
    \       {\n            if(!in(c, tmp))\n            {\n                tmp ~=\
    \ c;\n            }\n        }\n        if(tmp.length > max_length)\n        {\n\
    \            max_length = tmp.length;\n            the_string = a;\n        }\n\
    \    }\n    return the_string;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptn3jzgl8.d(26): Error: expression expected, not `in`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptn3jzgl8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string res = \"\";\n    int max = 0;\n    foreach(word; words)\n\
    \    {\n        int cnt = 0;\n        char[] ch = to!char[](word);\n        foreach(char\
    \ c; ch)\n        {\n            if (find(res, c) == -1) \n            {\n   \
    \             res ~= c;\n                cnt++;\n            }\n        }\n  \
    \      if (cnt > max) \n        {\n            max = cnt;\n            res = word;\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphm0pdsj7.d(24): Error: template instance `to!char` template `to`
    is not defined, did you mean No?

    /tmp/tmphm0pdsj7.d(27): Error: undefined identifier `find`, did you mean template
    `Bind(alias Template, args1...)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphm0pdsj7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    //T[] sort(T,T)(T[] arr, T predicate)\n    words = words.sort;\n\
    \    string result;\n    int max = 0;\n    foreach(word; words)\n    {\n     \
    \   int count = 0;\n        for(int i = 0; i < word.length; i++)\n        {\n\
    \            char c = word[i];\n            if(c >= 'a' && c <= 'z')\n       \
    \     {\n                count++;\n            }\n        }\n        if(count\
    \ > max)\n        {\n            max = count;\n            result = word;\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnuvvl27r.d(20): Error: no property `sort` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnuvvl27r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_word;\n    auto max_unique_count = 0;\n    foreach(word;\
    \ words)\n    {\n        auto unique_count = 0;\n        auto c = word[0];\n \
    \       foreach(ch; word)\n        {\n            if(c != ch)\n            {\n\
    \                unique_count++;\n                c = ch;\n            }\n   \
    \     }\n        if(unique_count >= max_unique_count)\n        {\n           \
    \ max_unique_count = unique_count;\n            max_word = word;\n        }\n\
    \    }\n    return max_word;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxgvugrpb.d(30): Error: cannot modify `immutable` expression `c`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxgvugrpb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_w;\n    auto x = words.length;\n    uint max_len\
    \ = x.max;\n    foreach(i; 0 .. x.length)\n    {\n        uint tem = unique(words[i]).length;\n\
    \        if(tem == max_len)\n        {\n            if(words[i] < max_w)\n   \
    \         {\n                max_w = words[i];\n            }\n        }\n   \
    \     else if(tem > max_len)\n        {\n            max_len = tem;\n        \
    \    max_w = words[i];\n        }\n    }\n    return max_w;\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ng0fsgz.d(21): Error: cannot implicitly convert expression `18446744073709551615LU`
    of type `ulong` to `uint`

    /tmp/tmp1ng0fsgz.d(22): Error: no property `length` for type `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ng0fsgz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    immutable(string) result;\n    size_t max_count = 0;\n    foreach(immutable(string)\
    \ word; words)\n    {\n        size_t numOfUnique = 0;\n        foreach(immutable(char)\
    \ c; word)\n        {\n            if(word.count(c) == 1)\n                numOfUnique++;\n\
    \        }\n        if(numOfUnique > max_count)\n        {\n            max_count\
    \ = numOfUnique;\n            result = word;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7invgstw.d(26): Error: no property `count` for type `immutable(string)`

    /tmp/tmp7invgstw.d(32): Error: cannot modify `immutable` expression `result`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7invgstw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string[] new_words = words.dup;\n    string[] new_words2 = words.dup;\n\
    \    foreach(ref word; new_words)\n    {\n        char[] letters;\n        foreach(c;\
    \ word)\n        {\n            if(c !in letters)\n            {\n           \
    \     letters ~= c;\n            }\n        }\n        //word = word.length;\n\
    \        word = letters.length;\n    }\n    int max = new_words[0];\n    foreach(word;\
    \ new_words)\n    {\n        if(word > max)\n        {\n            max = word;\n\
    \        }\n    }\n    string[] new_words3 = [];\n    foreach(word; new_words2)\n\
    \    {\n        char[] letters;\n        foreach(c; word)\n        {\n       \
    \     if(c !in letters)\n            {\n                letters ~= c;\n      \
    \      }\n        }\n        if(letters.length == max)\n        {\n          \
    \  new_words3 ~= word;\n        }\n    }\n    //new_words3.sort;\n    std.algorithm.sort(new_words3);\n\
    \    return new_words3[0];\n}\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuvpm_sv7.d(26): Error: incompatible types for `(c) in (letters)`:
    `immutable(char)` and `char[]`

    /tmp/tmpuvpm_sv7.d(32): Error: cannot implicitly convert expression `letters.length`
    of type `ulong` to `string`

    /tmp/tmpuvpm_sv7.d(34): Error: cannot implicitly convert expression `new_words[0]`
    of type `string` to `int`

    /tmp/tmpuvpm_sv7.d(37): Error: incompatible types for `(word) > (max)`: `string`
    and `int`

    /tmp/tmpuvpm_sv7.d(39): Error: cannot implicitly convert expression `word` of
    type `string` to `int`

    /tmp/tmpuvpm_sv7.d(48): Error: incompatible types for `(c) in (letters)`: `immutable(char)`
    and `char[]`

    /tmp/tmpuvpm_sv7.d(59): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuvpm_sv7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxIndex = 0;\n    // iterate through the words and find\
    \ the one with the most unique characters\n    for (int i = 1; i < words.length;\
    \ i++) \n    {\n        int u1 = getUniqueCount(words[maxIndex]);\n        int\
    \ u2 = getUniqueCount(words[i]);\n        // if equal, then compare the lexicographic\
    \ order\n        if (u1 < u2 || (u1 == u2 && words[maxIndex] > words[i]))\n  \
    \          maxIndex = i;\n    }\n    return words[maxIndex];\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5aopw6b0.d(23): Error: undefined identifier `getUniqueCount`

    /tmp/tmp5aopw6b0.d(24): Error: undefined identifier `getUniqueCount`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5aopw6b0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(words.length > 0);\n    auto max_num_chars = 0;\n   \
    \ auto result = \"\";\n    foreach(word; words) \n    {\n        auto m = typeof(uniq(word)).init;\n\
    \        auto length = m.length;\n        if (length > max_num_chars) \n     \
    \   {\n            max_num_chars = length;\n            result = word;\n     \
    \   } \n        else if (length == max_num_chars) \n        {\n            result\
    \ = min(result, word);\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjmekcssv.d(24): Error: undefined identifier `uniq`

    /tmp/tmpjmekcssv.d(33): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjmekcssv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string best_word = words[0];\n    int best_word_num_unique_characters\
    \ = num_unique_characters(best_word);\n    foreach(string word; words)\n    {\n\
    \        int word_num_unique_characters = num_unique_characters(word);\n     \
    \   if(word_num_unique_characters > best_word_num_unique_characters)\n       \
    \ {\n            best_word = word;\n            best_word_num_unique_characters\
    \ = word_num_unique_characters;\n        }\n    }\n    return best_word;\n}\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3kemqw9s.d(20): Error: undefined identifier `num_unique_characters`

    /tmp/tmp3kemqw9s.d(23): Error: undefined identifier `num_unique_characters`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3kemqw9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int numberOfWords = words.length;\n    int[] counts = new int[numberOfWords];\n\
    \    int maxUnique = 0;\n    int maxWordIndex = 0;\n    foreach(index, word; words)\n\
    \    {\n        foreach(c; word)\n        {\n            if (c in (unique!char)(word))\n\
    \            {\n                counts[index]++;\n            }\n        }\n \
    \       if (counts[index] > maxUnique)\n        {\n            maxUnique = counts[index];\n\
    \            maxWordIndex = index;\n        }\n    }\n    return words[maxWordIndex];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcwm056ln.d(27): Error: C style cast illegal, use `cast(unique!char)word`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcwm056ln.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // create an array of type Tuple with the first element being\
    \ the number of\n    // different characters in a word (which is the function\
    \ length(to!set(x)))\n    // and the second element being the word itself\n  \
    \  Tuple!(int, string)[] t = words.map!(x => tuple(length(to!set(x)), x));\n \
    \   // Sorts the array by comparing the first element of each element in the \n\
    \    // array. Thus, you can only compare elements of the same type.\n    // The\
    \ last parameter is a function that returns a -1 if the first element \n    //\
    \ of the first element is less than the first element of the second\n    // element,\
    \ 0 if equal, and 1 if greater.\n    // If the elements are equal, then it returns\
    \ a -1 if the second element\n    // of the first element comes first in lexicographical\
    \ order, 0 if equal,\n    // and 1 if greater.\n    t.sort!((a, b) => a[0] < b[0]\
    \ ? -1 : (a[0] > b[0] ? 1 : (a[1] < b[1] ? -1 : (a[1] > b[1] ? 1 : 0))));\n  \
    \  // returns the second element of the last element in the array.\n    return\
    \ t[$-1][1];\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ef79uvt.d(22): Error: no property `map` for type `string[]`

    /tmp/tmp0ef79uvt.d(31): Error: no property `sort` for type `Tuple!(int, string)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ef79uvt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  int max_len = -1;\n  string max_string = \"\";\n  foreach(string\
    \ word; words) \n  {\n    int len = word.length;\n    if (len > max_len) \n  \
    \  {\n      max_len = len;\n      max_string = word;\n    }\n  }\n  return max_string;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_aehzjx1.d(23): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_aehzjx1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto result = reduce!((a,b) => a.length>b.length?a:b)(words);\n\
    \    auto ln = result.length;\n    foreach(w; words)\n    {\n        if(w.length\
    \ == ln)\n        {\n            if(w < result) result = w;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyo166c97.d(19): Error: template instance `reduce!((a, b) => a.length
    > b.length ? a : b)` template `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyo166c97.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int highest = 0;\n    string answer = \"\";\n    for (int i\
    \ = 0; i < words.length; i++) \n    {\n        string temp = words[i];\n     \
    \   int counter = 0;\n        for (int j = 0; j < temp.length; j++) \n       \
    \ {\n            for (int k = j + 1; k < temp.length; k++) \n            {\n \
    \               if (temp[j] == temp[k]) \n                {\n                \
    \    counter++;\n                    break;\n                }\n            }\n\
    \        }\n        if (counter == 0) \n        {\n            return temp;\n\
    \        }\n        else if (counter == highest) \n        {\n            if (temp\
    \ < answer) \n            {\n                answer = temp;\n            }\n \
    \       }\n        else if (counter > highest) \n        {\n            highest\
    \ = counter;\n            answer = temp;\n        }\n    }\n    return answer;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw30kc5bn.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291d5]

    ??:? void tmpw30kc5bn.__unittest_L55_C1() [0x427d55]

    ??:? void tmpw30kc5bn.__modtest() [0x428440]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db77]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f2e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aa25]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aab4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a9b1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f05]

    ??:? runModuleUnitTests [0x42d94d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string r;\n    int m = 0;\n    foreach(w; words)\n    {\n  \
    \      int q = unique(to!string(w)).length;\n        if(q > m)\n        {\n  \
    \          m = q;\n            r = w;\n        }\n    }\n    return r;\n}\n/*\n\
    Given a string, return a new string where the first and last chars have\n    been\
    \ exchanged.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0em2nsu9.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0em2nsu9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string[] a = [ \"name\", \"of\", \"string\" ];\n    string[]\
    \ b = [ \"name\", \"enam\", \"game\" ];\n    string[] c = [ \"aaaaaaa\", \"bb\"\
    , \"cc\" ];\n    string result;\n    int max = -1;\n    int temp;\n    string[]\
    \ all = [a, b, c];\n    foreach(string i; all)\n    {\n        temp = find_max_helper(i);\n\
    \        if(temp > max)\n        {\n            max = temp;\n            result\
    \ = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxfnm1j_u.d(25): Error: cannot implicitly convert expression `[a,
    b, c]` of type `string[][]` to `string[]`

    /tmp/tmpxfnm1j_u.d(28): Error: undefined identifier `find_max_helper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxfnm1j_u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max = \"\";\n    int max_uniques = 0;\n    foreach(word;\
    \ words) \n    {\n        int num_uniques = 0;\n        char[] uniques = [];\n\
    \        foreach(char c; word) \n        {\n            if(c !in uniques) \n \
    \           {\n                num_uniques++;\n                uniques ~= c;\n\
    \            }\n        }\n        if(num_uniques > max_uniques) \n        {\n\
    \            max = word;\n            max_uniques = num_uniques;\n        } \n\
    \        else if(num_uniques == max_uniques) \n        {\n            max = std.algorithm.min(max,\
    \ word);\n        }\n    }\n    return max;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxgth78_.d(27): Error: incompatible types for `(c) in (uniques)`:
    `char` and `char[]`

    /tmp/tmpaxgth78_.d(40): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxgth78_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = words[0];\n    ulong max = unique_chars(result);\n\
    \    foreach(string word; words) \n    {\n        ulong count = unique_chars(word);\n\
    \        if(count > max) \n        {\n            max = count;\n            result\
    \ = word;\n        } \n        else if(count == max) \n        {\n           \
    \ result = min(result, word);\n        }\n    }\n    return result;\n}\nulong\
    \ unique_chars(string word) \n{\n    HashSet!char set;\n    foreach(char ch; word)\
    \ \n    {\n        set.insert(ch);\n    }\n    return set.length;\n}\n/*\n   \
    \ Write a function that accepts an array of strings. The array contains\n    different\
    \ words. The function returns a new array in which the words are\n    sorted in\
    \ descending order of their length. If two words have the same\n    length, return\
    \ the one which comes first in lexicographical order.\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4f2qdkxm.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4f2qdkxm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tauto result = words[0];\n\tint max = 0;\n\tforeach(word; words)\
    \ \n\t{\n\t\tauto uniques = toHashSet(word);\n\t\tif(uniques.length > max) \n\t\
    \t{\n\t\t\tmax = uniques.length;\n\t\t\tresult = word;\n\t\t}\n\t}\n\treturn result;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbpx3ruiv.d(23): Error: undefined identifier `toHashSet`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpx3ruiv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_word = \"\";\n    foreach(string word; words)\n \
    \   {\n        if(word.length > max_word.length)\n        {\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjx19uej.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmpmjx19uej.__unittest_L29_C1() [0x427cc2]

    ??:? void tmpmjx19uej.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d93f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a87c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a779]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d715]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint[] size = new int[words.length];\n\tint[] max = new int[words.length];\n\
    \tint x = 0;\n\tforeach(int i, string word; words)\n\t{\n\t\tint[] temp = new\
    \ int[256];\n\t\tforeach(char c; word)\n\t\t{\n\t\t\ttemp[cast(int)c] = 1;\n\t\
    \t}\n\t\tint sum = 0;\n\t\tforeach(i; temp)\n\t\t{\n\t\t\tsum += i;\n\t\t}\n\t\
    \tsize[x] = sum;\n\t\tx++;\n\t}\n\tint max_size = max(size);\n\tint index = 0;\n\
    \twhile(index < size.length)\n\t{\n\t\tif(size[index] == max_size)\n\t\t{\n\t\t\
    \treturn words[index];\n\t\t}\n\t\tindex++;\n\t}\n\treturn \"error\";\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz1jkmfy6.d(30): Error: variable `i` is shadowing variable `tmpz1jkmfy6.find_max.i`

    /tmp/tmpz1jkmfy6.d(37): Error: function expected before `()`, not `max` of type
    `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz1jkmfy6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  // get the longest word first\n  string longest_word = words[0];\n\
    \  foreach(w; words)\n  {\n    if(w.length > longest_word.length)\n    {\n   \
    \   longest_word = w;\n    }\n  }\n  // now find the number of unique characters\n\
    \  // this is a set of characters with no duplicates\n  import std.algorithm;\n\
    \  auto unique_chars = longest_word.distinct;\n  // \n  // now check if any other\
    \ word has the same number of unique chars\n  string[] words_with_unique_char\
    \ = [];\n  foreach(w; words)\n  {\n    if(w.distinct.length == unique_chars.length)\n\
    \    {\n      words_with_unique_char ~= w;\n    }\n  }\n  // return the first\
    \ word as this is lexiographically smallest\n  return words_with_unique_char[0];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj0sz219u.d(31): Error: no property `distinct` for type `string`

    /tmp/tmpj0sz219u.d(37): Error: no property `distinct` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj0sz219u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_w;\n    max_w = words[0];\n    int max_n;\n    max_n\
    \ = 0;\n    bool[] used;\n    used = new bool[256];\n    int c, i, j, n;\n   \
    \ foreach(string w; words)\n    {\n        n = 0;\n        foreach(i; 0 .. w.length)\n\
    \        {\n            c = w[i];\n            if(!used[c])\n            {\n \
    \               n++;\n                used[c] = true;\n            }\n       \
    \ }\n        foreach(j; 0 .. used.length)\n        {\n            used[j] = false;\n\
    \        }\n        if(n > max_n)\n        {\n            max_n = n;\n       \
    \     max_w = w;\n        }\n    }\n    return max_w;\n}\n/*\nWrite a function\
    \ that accepts a string. Count the number of its unique characters.\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8p0pi6t6.d(50): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8p0pi6t6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if (words.length == 0)\n        return \"\";\n    auto find_max_helper\
    \ = delegate string(string[] words, string max_word, int idx) \n    {\n      \
    \  if (idx >= words.length)\n            return max_word;\n        auto cur_word\
    \ = words[idx];\n        if (cur_word.length > max_word.length)\n            return\
    \ find_max_helper(words, cur_word, idx + 1);\n        if (cur_word.length == max_word.length)\n\
    \        {\n            if (cur_word.toHash() > max_word.toHash())\n         \
    \       return find_max_helper(words, cur_word, idx + 1);\n        }\n       \
    \ return find_max_helper(words, max_word, idx + 1);\n    };\n    return find_max_helper(words,\
    \ words[0], 1);\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt31_mmkn.d(27): Error: undefined identifier `find_max_helper`

    /tmp/tmpt31_mmkn.d(30): Error: no property `toHash` for type `string`

    /tmp/tmpt31_mmkn.d(30): Error: no property `toHash` for type `string`

    /tmp/tmpt31_mmkn.d(31): Error: undefined identifier `find_max_helper`

    /tmp/tmpt31_mmkn.d(33): Error: undefined identifier `find_max_helper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt31_mmkn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max_unique_count = 0;\n    string max_unique_string = \"\
    \";\n    foreach(word; words)\n    {\n        int unique_count = 0;\n        foreach(ch;\
    \ word)\n        {\n            if(count_if!(x => x == ch)(word) == 1)\n     \
    \       {\n                unique_count++;\n            }\n        }\n       \
    \ if(unique_count > max_unique_count)\n        {\n            max_unique_count\
    \ = unique_count;\n            max_unique_string = word;\n        }\n    }\n \
    \   return max_unique_string;\n}\n/*\nWrite a function that accepts a string representing\
    \ an expression. \n    The expression contains integer numbers and operators +,\
    \ -, *, /. \n    Return the result of the expression. \n    The expression is\
    \ guaraneed to be valid.\nunittest\n{\n    alias candidate = find_max;\n\n   \
    \ assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi5jxm4v2.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi5jxm4v2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    return max(words);\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdsy_vv15.d(19): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdsy_vv15.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string mx = \"\";\n    foreach(string s; words) \n    {\n  \
    \      if(s.length > mx.length) \n        {\n            mx = s;\n        }\n\
    \    }\n    return mx;\n}\nunittest\n{\n    alias candidate = find_max;\n\n  \
    \  assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyqtqplvc.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmpyqtqplvc.__unittest_L29_C1() [0x427cc2]

    ??:? void tmpyqtqplvc.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d93f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a87c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a779]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d715]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    size_t max_unique = 0;\n    string first_string = \"\";\n  \
    \  string max_string = \"\";\n    for (string w : words) \n    {\n        if (w.length\
    \ > max_unique) \n        {\n            size_t unique = 0;\n            for (size_t\
    \ i = 0; i < w.length; i++) \n            {\n                if (w[i] != ' ')\
    \ \n                {\n                    bool is_unique = true;\n          \
    \          for (size_t j = 0; j < w.length; j++) \n                    {\n   \
    \                     if (w[i] == w[j] && i != j) \n                        {\n\
    \                            is_unique = false;\n                        }\n \
    \                   }\n                    if (is_unique) \n                 \
    \   {\n                        unique++;\n                    }\n            \
    \    }\n            }\n            if (unique > max_unique) \n            {\n\
    \                max_unique = unique;\n                max_string = w;\n     \
    \       }\n            else if (unique == max_unique) \n            {\n      \
    \          if (first_string == \"\") \n                {\n                   \
    \ first_string = w;\n                }\n                if (w < first_string)\
    \ \n                {\n                    max_string = w;\n                }\n\
    \            }\n        }\n    }\n    return max_string;\n}\nunittest\n{\n   \
    \ alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6ef00r2.d(22): Error: found `w` when expecting `;` following statement

    /tmp/tmpv6ef00r2.d(22): Error: expression expected, not `:`

    /tmp/tmpv6ef00r2.d(22): Error: found `words` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6ef00r2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    \n    string output = null;\n    int[] arr = new int[words.length];\n\
    \    foreach(i, j; words)\n    {\n        int max = 0;\n        foreach(q; j)\n\
    \        {\n            //writeln(j[q]);\n            if (j[q] != 0)\n       \
    \     {\n                //writeln(j[q]);\n                j[q] = j[q] - 1;\n\
    \                max = max + 1;\n            }\n        }\n        arr[i] = max;\n\
    \        //writeln(max);\n    }\n    int max = arr[0];\n    int temp = 0;\n  \
    \  foreach(i, j; arr)\n    {\n        if (j > max)\n        {\n            max\
    \ = j;\n            temp = i;\n        }\n    }\n    output = words[temp];\n \
    \   //writeln(output);\n    return output;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp08izpzqw.d(31): Error: cannot modify `immutable` expression `j[cast(ulong)q]`

    /tmp/tmp08izpzqw.d(45): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp08izpzqw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tif (words.length == 0) return null;\n\t//1. count \n\timmutable\
    \ int max_len = words[0].length;\n\tstring ret = words[0];\n\tforeach (string\
    \ word; words)\n\t{\n\t\tif (word.length > max_len)\n\t\t{\n\t\t\tmax_len = word.length;\n\
    \t\t\tret = word;\n\t\t}\n\t}\n\t\n\t//2. remove duplicates\n\t\n\t//3. find the\
    \ longest word\n\t\n\treturn ret;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmc1kj025.d(21): Error: cannot implicitly convert expression `words[0].length`
    of type `ulong` to `immutable(int)`

    /tmp/tmpmc1kj025.d(27): Error: cannot modify `immutable` expression `max_len`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmc1kj025.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    static bool my_comparator(string a, string b) \n    {\n    \
    \    uint lena = a.length;\n        uint lenb = b.length;\n        if (lena !=\
    \ lenb) return lena < lenb;\n        return a < b;\n    }\n    // Logic: first\
    \ compute the max length, then compute the set of\n    //   words with that length.\
    \ Then find the minimum in that set.\n    uint max_len = max(words.map!(x => x.length));\n\
    \    string[] long_words = words.filter!(x => x.length == max_len);\n    return\
    \ min(long_words, my_comparator);\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpam4vn9zd.d(21): Error: cannot implicitly convert expression `a.length`
    of type `ulong` to `uint`

    /tmp/tmpam4vn9zd.d(22): Error: cannot implicitly convert expression `b.length`
    of type `ulong` to `uint`

    /tmp/tmpam4vn9zd.d(28): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpam4vn9zd.d(29): Error: no property `filter` for type `string[]`

    /tmp/tmpam4vn9zd.d(30): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpam4vn9zd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  int max = 0;\n  string word = \"\";\n  foreach(w; words) \n  {\n\
    \    int unique_chars = 0;\n    foreach(c; w)\n    {\n      if(w.indexOf(c) ==\
    \ w.lastIndexOf(c)) \n      {\n        unique_chars++;\n      }\n    }\n    if(unique_chars\
    \ > max) \n    {\n      max = unique_chars;\n      word = w;\n    }\n  }\n  return\
    \ word;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6f6uxd3z.d(26): Error: no property `indexOf` for type `string`

    /tmp/tmp6f6uxd3z.d(26): Error: no property `lastIndexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6f6uxd3z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    alias Map = Map!(char, int);\n    string currentMax;\n    int\
    \ maxCharCount = 0;\n    foreach(string w; words)\n    {\n        Map chrs = Map();\n\
    \        foreach(char c; w)\n        {\n            chrs[c] = chrs.count++;\n\
    \        }\n        if(chrs.count > maxCharCount)\n        {\n            maxCharCount\
    \ = chrs.count;\n            currentMax = w;\n        }\n    }\n    return currentMax;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmxen92ky.d(19): Error: alias `Map` recursive alias declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmxen92ky.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string best_word = words[0];\n    dchar[string] unique_chars;\n\
    \    immutable dchar[] unique_chars_best_word = unique_chars(best_word);\n   \
    \ foreach(word; words)\n    {\n        immutable dchar[] unique_chars_word = unique_chars(word);\n\
    \        if(unique_chars_word.length > unique_chars_best_word.length)\n      \
    \  {\n            best_word = word;\n            unique_chars_best_word = unique_chars_word;\n\
    \        }\n        else if(unique_chars_word.length == unique_chars_best_word.length)\n\
    \        {\n            if(word < best_word)\n            {\n                best_word\
    \ = word;\n                unique_chars_best_word = unique_chars_word;\n     \
    \       }\n        }\n    }\n    return best_word;\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplxh84o4i.d(21): Error: function expected before `()`, not `unique_chars`
    of type `dchar[string]`

    /tmp/tmplxh84o4i.d(24): Error: function expected before `()`, not `unique_chars`
    of type `dchar[string]`

    /tmp/tmplxh84o4i.d(28): Error: cannot modify `immutable` expression `unique_chars_best_word`

    /tmp/tmplxh84o4i.d(35): Error: cannot modify `immutable` expression `unique_chars_best_word`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplxh84o4i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string[] rt = new string[0];\n    rt ~= words[0];\n    string\
    \ s;\n    dchar[] set;\n    foreach(string elem; words)\n    {\n        set =\
    \ new dchar[0];\n        foreach(dchar c; elem)\n        {\n            if(!c\
    \ in set)\n            {\n                set ~= c;\n            }\n        }\n\
    \        if(set.length > rt[0].length)\n        {\n            rt = new string[0];\n\
    \            rt ~= elem;\n        }\n        else if(set.length == rt[0].length)\n\
    \        {\n            rt ~= elem;\n        }\n    }\n    rt.sort;\n    return\
    \ rt[0];\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpomy1cikk.d(28): Error: incompatible types for `(!c) in (set)`:
    `bool` and `dchar[]`

    /tmp/tmpomy1cikk.d(43): Error: no property `sort` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpomy1cikk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // Iterator returned type\n    auto it = maxElement(words.front,\
    \ words.back, (a, b) {\n        // unique_char is used to store Unique Chars in\
    \ string\n        auto unique_char = new Set!char();\n        for (auto c : a)\
    \ {\n            unique_char.insert(c);\n        }\n        auto a_size = unique_char.size;\n\
    \        unique_char.clear();\n        for (auto c : b) {\n            unique_char.insert(c);\n\
    \        }\n        auto b_size = unique_char.size;\n        if (a_size == b_size)\
    \ {\n            // If both have same size\n            return a > b;\n      \
    \  }\n        return a_size > b_size;\n    });\n    return it;\n}\n/*\nWrite a\
    \ function that accepts an array of strings. The array contains\n    different\
    \ words. Return true if the array contains the word \"gold\".\n    Otherwise,\
    \ return false.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgghbeo4p.d(23): Error: no identifier for declarator `c`

    /tmp/tmpgghbeo4p.d(23): Error: expression expected, not `:`

    /tmp/tmpgghbeo4p.d(23): Error: found `a` when expecting `;` following `for` condition

    /tmp/tmpgghbeo4p.d(28): Error: no identifier for declarator `c`

    /tmp/tmpgghbeo4p.d(28): Error: expression expected, not `:`

    /tmp/tmpgghbeo4p.d(28): Error: found `b` when expecting `;` following `for` condition

    /tmp/tmpgghbeo4p.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgghbeo4p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    \n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqtkbs6lj.d(17): Error: function `tmpqtkbs6lj.find_max` has no `return`
    statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtkbs6lj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if (words.length == 0) return \"\";\n    int max = 0;\n    int\
    \ max_idx = 0;\n    for (int i = 0; i < words.length; i++) {\n        if (max\
    \ < num_unique_chars(words[i])) {\n            max = num_unique_chars(words[i]);\n\
    \            max_idx = i;\n        }\n    }\n    return words[max_idx];\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_u26yc4n.d(23): Error: undefined identifier `num_unique_chars`

    /tmp/tmp_u26yc4n.d(24): Error: undefined identifier `num_unique_chars`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_u26yc4n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    tuple!(string, string[]) lexicographical_min;\n    tuple!(size_t,\
    \ string[]) max_unique_characters;\n    foreach(word; words)\n    {\n        auto\
    \ unique_chars = [word[0]];\n        foreach(ch; word[1..$])\n        {\n    \
    \        if(unique_chars.indexOf(ch) == -1)\n            {\n                unique_chars\
    \ ~= ch;\n            }\n        }\n        if(unique_chars.length == max_unique_characters[0])\n\
    \        {\n            max_unique_characters[1] ~= word;\n        }\n       \
    \ else if(unique_chars.length > max_unique_characters[0])\n        {\n       \
    \     max_unique_characters = tuple(unique_chars.length, [word]);\n        }\n\
    \        lexicographical_min = min(lexicographical_min, tuple(word, []));\n  \
    \  }\n    return min(lexicographical_min, tuple(max_unique_characters[1][0], []));\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyde9idtd.d(19): Error: `tuple!(string, string[])` is used as a
    type

    /tmp/tmpyde9idtd.d(20): Error: `tuple!(ulong, string[])` is used as a type

    /tmp/tmpyde9idtd.d(26): Error: no property `indexOf` for type `string`

    /tmp/tmpyde9idtd.d(41): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyde9idtd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tauto max = 0;\n\tstring best_word = \"\";\n\tforeach(string word;\
    \ words)\n\t{\n\t\tauto count = 0;\n\t\tforeach(char c; word)\n\t\t{\n\t\t\tif(c\
    \ != word[0])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count > max)\n\
    \t\t{\n\t\t\tmax = count;\n\t\t\tbest_word = word;\n\t\t}\n\t}\n\treturn best_word;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoftcdbjq.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290e5]

    ??:? void tmpoftcdbjq.__unittest_L39_C1() [0x427d46]

    ??:? void tmpoftcdbjq.__modtest() [0x428350]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e3e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8e1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a970]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a86d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e15]

    ??:? runModuleUnitTests [0x42d809]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    int result_len = 0;\n    foreach(word;\
    \ words) \n    {\n        auto counts = std.algorithm.uniq(word);\n        int\
    \ len = counts.length;\n        if (len > result_len) \n        {\n          \
    \  result = word;\n            result_len = len;\n        }\n        else if (len\
    \ == result_len) \n        {\n            result = min(result, word);\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv27inqd4.d(23): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpv27inqd4.d(32): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv27inqd4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string max_str = \"\";\n    foreach(str; words)\n\
    \    {\n        if(str.length > max)\n        {\n            max = str.length;\n\
    \            max_str = str;\n        }\n    }\n    return max_str;\n}\n/*\nWrite\
    \ a function that finds unique characters in a string.\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuouxx3kl.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuouxx3kl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(words.length > 0);\n    return words.max!((string a,\
    \ string b) {\n        auto count = a.length < b.length ? a.length : b.length;\n\
    \        for (size_t i = 0; i < count; i++) {\n            if (a[i] < b[i]) return\
    \ true;\n            if (a[i] > b[i]) return false;\n        }\n        return\
    \ a.length < b.length;\n    });\n}\n//+---------------------+\n//|     TESTING\
    \ AREA    |\n//+---------------------+\nunittest\n{\n    //test_find_max\n   \
    \ assert(find_max([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(find_max([\"aaaaaaa\",\
    \ \"bb\", \"cc\"]) == \"aaaaaaa\");\n}\n//+---------------------+\n//|  HELPER\
    \ FUNCTIONS   |\n//+---------------------+\n/*\n    When a function, delegate,\
    \ or template is defined with the @nogc attribute, it can never\n    call a function\
    \ marked with @system or access a global variable that has the @system attribute.\n\
    \    The @system attribute can only be applied to function declarations, not function\
    \ definitions.\n*/\n/*\n    If a function is pure and nothrow, it can be called\
    \ from within a @safe pure\n    function, a @safe nothrow function, and a pure\
    \ nothrow delegate.\n*/\n/*\npure means that the function cannot modify the state\
    \ of the program nor read any global state\nexcept what is passed in as an argument.\
    \ pure functions are those that can be called\nat compile time. In order to be\
    \ pure, a function must not:\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp68pht500.d(51): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp68pht500.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    size_t[] uniqueCount;\n    foreach(string word; words)\n   \
    \ {\n        uniqueCount ~= uniq.count(word);\n    }\n    return words[maxElement(uniqueCount)];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb9k7h72e.d(22): Error: undefined identifier `uniq`

    /tmp/tmpb9k7h72e.d(24): Error: undefined identifier `maxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9k7h72e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(words.length > 0);\n    string[] initial = words[0..1];\n\
    \    auto max = reduce!(initial, (a, b) => a.length > b.length ? a : b);\n   \
    \ return max;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7qc48d_8.d(21): Error: template instance `reduce!(initial, (a,
    b) => a.length > b.length ? a : b)` template `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7qc48d_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    uint counter = 0;\n    uint max_counter = 0;\n    string result;\n\
    \    foreach(string word; words)\n    {\n        counter = 1;\n        foreach(immutable\
    \ char c; word)\n        {\n            if(word.filter!(a => a == c).length ==\
    \ word.length-1)\n            {\n                counter++;\n            }\n \
    \       }\n        if(counter >= max_counter)\n        {\n            max_counter\
    \ = counter;\n            result = word;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpty097qhj.d(27): Error: no property `filter` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpty097qhj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    static assert(words.length >= 1);\n    return  maxElement(words,\
    \ (a, b) => \n            a.length - a.count(c => a.count(d => d == c) > 1)\n\
    \                - b.length + b.count(c => b.count(d => d == c) > 1));\n}\nunittest\
    \ \n{\n    assert(find_max([\"name\", \"of\", \"string\"]) == \"string\");\n \
    \   assert(find_max([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp15hvo4pk.d(19): Error: variable `words` cannot be read at compile
    time

    /tmp/tmp15hvo4pk.d(19):        while evaluating: `static assert(words.length >=
    1LU)`

    /tmp/tmp15hvo4pk.d(20): Error: undefined identifier `maxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp15hvo4pk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result;\n    auto max_char = 0;\n    foreach(ref word;\
    \ words) \n    {\n        auto chars = new Set!char();\n        foreach(letter;\
    \ word)\n        {\n            chars.insert(letter);\n        }\n        auto\
    \ cur_char = chars.length;\n        if(cur_char > max_char) \n        {\n    \
    \        max_char = cur_char;\n            result = word;\n        }\n       \
    \ else if(cur_char == max_char) \n        {\n            auto max_less = strcmp(result,\
    \ word);\n            if(max_less > 0) \n            {\n                result\
    \ = word;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprcj8rq1m.d(23): Error: template instance `Set!char` template `Set`
    is not defined, did you mean get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)?

    /tmp/tmprcj8rq1m.d(36): Error: undefined identifier `strcmp`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprcj8rq1m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    return words.map!((x) => tuple(x, x.unique_length())).max()[0];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpry8bdl2t.d(19): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpry8bdl2t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string res = \"\";\n    foreach(word; words)\n    {\n      \
    \  if(res.length < word.length)\n        {\n            auto s = set(word);\n\
    \            if(s.length == word.length)\n            {\n                res =\
    \ word;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk6gaex6d.d(24): Error: undefined identifier `set`, did you mean
    template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk6gaex6d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    //TODO: implement me\n    return \"\";\n}\nunittest\n{\n   \
    \ alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9zxtt07d.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fdd]

    ??:? void tmp9zxtt07d.__unittest_L22_C1() [0x427b99]

    ??:? void tmp9zxtt07d.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a765]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a7f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a6f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d0d]

    ??:? runModuleUnitTests [0x42d68d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42942c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string res = \"\";\n    int max = 0;\n    foreach(ref string\
    \ word; words)\n    {\n        int uniq = 0;\n        foreach(w; word)\n     \
    \   {\n            if(word.count(w) == 1)\n                uniq++;\n        }\n\
    \        if(uniq > max)\n        {\n            max = uniq;\n            res =\
    \ word;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq_tnvuq4.d(26): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_tnvuq4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max_length = 0;\n    string result = \"\";\n    for (int\
    \ i = 0; i < words.length; i++)\n    {\n        if (words[i].length > max_length)\n\
    \        {\n            max_length = words[i].length;\n            result = words[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_hah459d.d(25): Error: cannot implicitly convert expression `words[cast(ulong)i].length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hah459d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    //initialize our current_max and return value.\n    int current_max\
    \ = 0;\n    string ret;\n    foreach(word; words) \n    {\n        //narrow the\
    \ scope down to one word\n        int[] letters = new int[256];\n        foreach(letter;\
    \ word) \n        {\n            letters[letter] = 1;\n        }\n        //now,\
    \ how many unique characters were in that word?\n        int count = 0;\n    \
    \    foreach(val; letters) \n        {\n            count += val;\n        }\n\
    \        //is this the highest count we've seen so far?\n        if(count > current_max)\
    \ \n        {\n            current_max = count;\n            ret = word;\n   \
    \     }\n        //was this a tie?\n        else if(count == current_max) \n \
    \       {\n            //compare lexicographically\n            if(word > ret)\
    \ \n            {\n                ret = word;\n            }\n        }\n   \
    \ }\n    return ret;\n}\n/*\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgfcy95v8.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgfcy95v8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    import std.algorithm;\n    import std.array;\n    return words.length\
    \ == 0 ? \"\" : words.max!(x => x.length)();\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3f3jprp6.d(21): Error: template instance `tmp3f3jprp6.find_max.max!((x)
    => x.length)` does not match template declaration `max(T...)(T args) if (T.length
    >= 2)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3f3jprp6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max_unique_char_count = 0;\n    string best_word = words[0];\n\
    \    foreach(word; words) \n    {\n        const unique_chars = new string[];\n\
    \        foreach(c; word) \n        {\n            if(!c in unique_chars)\n  \
    \              unique_chars ~= c;\n        }\n        if(unique_chars.length >\
    \ max_unique_char_count) \n        {\n            max_unique_char_count = unique_chars.length;\n\
    \            best_word = word;\n        }\n    }\n    return best_word;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuzfcnutc.d(23): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuzfcnutc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(!words.empty);\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1rvvatxy.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1rvvatxy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tstring wordMax = \"\";\n\tint wordLength = 0;\n\tforeach(string\
    \ word; words)\n\t{\n\t\tif(unique_chars(word) > wordLength)\n\t\t{\n\t\t\twordLength\
    \ = unique_chars(word);\n\t\t\twordMax = word;\n\t\t}\n\t}\n\treturn wordMax;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2yo1dxej.d(23): Error: undefined identifier `unique_chars`

    /tmp/tmp2yo1dxej.d(25): Error: undefined identifier `unique_chars`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2yo1dxej.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // YOUR CODE GOES HERE!\n    return \"\";\n}\n/*\nWrite a function\
    \ that accepts an array of strings.\n    The array contains different words. Return\
    \ the word which has all\n    the characters in alphabetical order. If there are\
    \ multiple words,\n    return the one which comes first in lexicographical order.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw3ev1ucz.d(22): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw3ev1ucz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    size_t[] max = new size_t[words.length];\n    foreach(i, e;\
    \ words) \n    {\n        size_t uc = 0;\n        foreach(c; e)\n        {\n \
    \           if (std.algorithm.contains(e[0..i], c)) \n            {\n        \
    \        uc++;\n            }\n        }\n        max[i] = uc;\n    }\n    auto\
    \ max_word = words[0];\n    auto max_count = max[0];\n    foreach(i, e; max) \n\
    \    {\n        if (e > max_count) \n        {\n            max_count = e;\n \
    \           max_word = words[i];\n        }\n    }\n    return max_word;\n}\n\
    //writefln(find_max([\"aaaaaaa\", \"bb\", \"cc\"]));\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpemfabwiy.d(25): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpemfabwiy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  return words.reduce!((word1, word2) => word1.length > word2.length\
    \ ? word1 : word2);\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpauy2y7jh.d(19): Error: no property `reduce` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpauy2y7jh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if (words.length == 0) \n    {\n        return \"\";\n    }\n\
    \    else \n    {\n        return find_max(words, words[0]);\n    }\n}\nstring\
    \ find_max(string[] words, string max_word) \n{\n    if (words.length == 0) \n\
    \    {\n        return max_word;\n    }\n    else \n    {\n        string current_word\
    \ = words[0];\n        words = words[1 .. $];\n        if (unique_chars(current_word)\
    \ > unique_chars(max_word)) \n        {\n            return find_max(words, current_word);\n\
    \        }\n        else if (unique_chars(current_word) == unique_chars(max_word))\
    \ \n        {\n            return find_max(words, std.algorithm.min(current_word,\
    \ max_word));\n        }\n        else \n        {\n            return find_max(words,\
    \ max_word);\n        }\n    }\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu62p8wd9.d(38): Error: undefined identifier `unique_chars`

    /tmp/tmpu62p8wd9.d(38): Error: undefined identifier `unique_chars`

    /tmp/tmpu62p8wd9.d(42): Error: undefined identifier `unique_chars`

    /tmp/tmpu62p8wd9.d(42): Error: undefined identifier `unique_chars`

    /tmp/tmpu62p8wd9.d(44): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu62p8wd9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tauto r = words[0];\n\tforeach( ref word; words ) {\n\t\tif( word.length\
    \ > r.length ) {\n\t\t\tr = word;\n\t\t}\n\t}\n\treturn r;\n}\nunittest\n{\n \
    \   alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd3dq5m2v.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x42906d]

    ??:? void tmpd3dq5m2v.__unittest_L27_C1() [0x427cce]

    ??:? void tmpd3dq5m2v.__modtest() [0x4282d8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dc6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a869]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d9d]

    ??:? runModuleUnitTests [0x42d791]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429530]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto result = \"\";\n    auto max_count = 0;\n    foreach(word;\
    \ words)\n    {\n        auto local_count = uniq(word).length;\n        if(local_count\
    \ > max_count)\n        {\n            max_count = local_count;\n            result\
    \ = word;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzo0lla5q.d(23): Error: undefined identifier `uniq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzo0lla5q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // max - maximum length of unique characters in words array\n\
    \    // index - index of word with maximum number of unique characters\n    int\
    \ max = 0, index = 0;\n    // Iterate through array, calculating length of unique\
    \ chars\n    foreach(i, word; words) \n    {\n        immutable set = typeof(word).init.unique(word);\n\
    \        immutable cur_length = set.length;\n        if (cur_length > max) \n\
    \        {\n            max = cur_length;\n            index = i;\n        }\n\
    \    }\n    return words[index];\n}\n/*\nWrite a function that accepts an array\
    \ of strings and returns the longest string\nin the array, using std.range.chunks\
    \ to break the array into chunks of the same\nlength.\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4k3jhr83.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4k3jhr83.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if (words.length == 0)\n        return \"\";\n    int max_len\
    \ = words[0].length;\n    int max_index = 0;\n    int i = 1;\n    while (i < words.length)\
    \ \n    {\n        auto curr_len = words[i].length;\n        if (curr_len > max_len)\
    \ \n        {\n            max_len = curr_len;\n            max_index = i;\n \
    \       }\n        i += 1;\n    }\n    return words[max_index];\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0m0zht4b.d(21): Error: cannot implicitly convert expression `words[0].length`
    of type `ulong` to `int`

    /tmp/tmp0m0zht4b.d(29): Error: cannot implicitly convert expression `curr_len`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0m0zht4b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    int max = 0;\n    for (string word;\
    \ word : words)\n    {\n        if (word.length > max)\n        {\n          \
    \  result = word;\n            max = word.length;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplgnuosws.d(21): Error: found `:` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplgnuosws.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max = \"\";\n    foreach(word; words)\n    {\n      \
    \  if(word.length > max.length)\n        {\n            max = word;\n        }\n\
    \    }\n    return max;\n}\n/*\nYou are given a sequence of words. Return the\
    \ longest word that contains\n    only letters from the first word in the sequence.\n\
    \    \n    >>> find_longest([\"name\", \"of\", \"string\"])\n    \"ring\"\n  \
    \  >>> find_longest([\"word\", \"or\", \"wordl\"])\n    \"word\"\n    >>> find_longest([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    >>> find_longest([\"bb\", \"\
    a\", \"cc\"])\n    \"a\"\n    \n    \n*/\nstring find_longest(string[] words)\
    \ \n{\n    string first = words[0];\n    string best = \"\";\n    foreach(word;\
    \ words)\n    {\n        bool good = true;\n        foreach(character; word)\n\
    \        {\n            if(!first.canFind(character))\n            {\n       \
    \         good = false;\n            }\n        }\n        if(good && word.length\
    \ > best.length)\n        {\n            best = word;\n        }\n    }\n    return\
    \ best;\n}\n/*\nYou are given an array of words. Return an array of words, that\
    \ have at least\n    one character shared between them. Return array words in\
    \ lexicographical\n    order. \n    \n    >>> find_common([\"name\", \"of\", \"\
    string\"])\n    [\"name\", \"of\", \"string\"]\n    >>> find_common([\"bb\", \"\
    a\", \"cc\"])\n    [\"a\", \"bb\"]\n    >>> find_common([\"bb\", \"asd\", \"cc\"\
    ])\n    [\"asd\", \"bb\"]\n    >>> find_common([\"word\", \"or\", \"wordl\"])\n\
    \    [\"or\", \"word\", \"wordl\"]\n*/\nstring[] find_common(string[] words) \n\
    {\n    string[] common = [];\n    foreach(word; words)\n    {\n        foreach(compare;\
    \ words)\n        {\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3av4wkei.d(86): Error: found `unittest` instead of statement

    /tmp/tmp3av4wkei.d(101): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp3av4wkei.d(101): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3av4wkei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string s = \"\";\n    foreach(string i; words)\n    {\n    \
    \    if(i.length > s.length)\n        {\n            s = i;\n        }\n    }\n\
    \    return s;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6xp43hwn.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmp6xp43hwn.__unittest_L29_C1() [0x427cc2]

    ??:? void tmp6xp43hwn.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d93f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a87c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a779]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d715]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max = \"\";\n    int max_unique = 0;\n    foreach(string\
    \ word; words)\n    {\n        int unique = 1;\n        foreach(string test; words)\n\
    \        {\n            if(test != word)\n            {\n                if(word.indexOf(test)\
    \ == -1)\n                {\n                    unique++;\n                }\n\
    \            }\n        }\n        if(unique > max_unique)\n        {\n      \
    \      max = word;\n            max_unique = unique;\n        }\n    }\n    return\
    \ max;\n}\n/*\nWrite a function that accepts an array of integers.\n    Return\
    \ the second smallest number in the array. If there is no second\n    smallest\
    \ number, return None.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuefmn8gw.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuefmn8gw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    //One way to solve this challenge is to use the \"maxElement\"\
    \ function in\n    //the \"std.algorithm\" module.\n    //maxElement returns the\
    \ string with the maximum number of characters,\n    //which is what the challenge\
    \ is asking for.\n    //TODO: make this into a template\n    //alias max = maxElement!((a,\
    \ b) => a.length > b.length);\n    string max = maxElement!((a, b) => a.length\
    \ > b.length)(words);\n    return max;\n}\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnrherfzl.d(25): Error: template instance `maxElement!((a, b) =>
    a.length > b.length)` template `maxElement` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnrherfzl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto result = tuple(\"\", 0);\n    foreach(w; words) \n    {\n\
    \        int count = 0;\n        char[] current = w.dup;\n        sort(current);\n\
    \        for(int i = 0; i < current.length - 1; i++) \n        {\n           \
    \ if(current[i] != current[i + 1]) \n            {\n                count++;\n\
    \            }\n        }\n        if(count > result[1]) \n        {\n       \
    \     result = tuple(w, count);\n        }\n    }\n    return result[0];\n}\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv4hh0r_4.d(24): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv4hh0r_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto max_len = 0;\n    string max_str;\n    foreach(word; words)\n\
    \    {\n        int len = word.length;\n        auto ch = set!string();\n    \
    \    foreach(i; 0 .. len)\n        {\n            ch.insert(word[i .. i]);\n \
    \       }\n        if(ch.length > max_len)\n        {\n            max_len = ch.length;\n\
    \            max_str = word;\n        }\n        else if(ch.length == max_len)\n\
    \        {\n            if(word < max_str)\n            {\n                max_str\
    \ = word;\n            }\n        }\n    }\n    return max_str;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_t445q3z.d(23): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_t445q3z.d(24): Error: template instance `set!string` template `set` is
    not defined, did you mean get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_t445q3z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] wordLength = new int[words.length];\n    string[] sortedWords\
    \ = new string[words.length];\n    for (int i = 0; i < words.length; i++) \n \
    \   {\n        wordLength[i] = words[i].length;\n        sortedWords[i] = words[i];\n\
    \    }\n    quicksort(wordLength, sortedWords);\n    int[] count = new int[256];\n\
    \    bool[] flag = new bool[words.length];\n    for (int i = 0; i < words.length;\
    \ i++)\n    {\n        for (int j = 0; j < 256; j++)\n        {\n            count[j]\
    \ = 0;\n        }\n        for (int j = 0; j < words[i].length; j++)\n       \
    \ {\n            count[cast(int) words[i][j]]++;\n        }\n        int uniqueCount\
    \ = 0;\n        for (int j = 0; j < 256; j++)\n        {\n            if (count[j]\
    \ > 0)\n            {\n                uniqueCount++;\n            }\n       \
    \ }\n        flag[i] = uniqueCount == wordLength[i];\n    }\n    for (int i =\
    \ 0; i < words.length; i++)\n    {\n        if (flag[i])\n        {\n        \
    \    return sortedWords[i];\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiv2qylmn.d(23): Error: cannot implicitly convert expression `words[cast(ulong)i].length`
    of type `ulong` to `int`

    /tmp/tmpiv2qylmn.d(26): Error: undefined identifier `quicksort`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiv2qylmn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto longest_word = words[0];\n    auto longest_word_length\
    \ = longest_word.length;\n    auto current_word_lenght = 0;\n    immutable auto\
    \ swap_criterion = true;\n    foreach(word; words)\n    {\n        current_word_lenght\
    \ = word.length;\n        if(current_word_lenght > longest_word_length)\n    \
    \    {\n            longest_word = word;\n            longest_word_length = current_word_lenght;\n\
    \        }\n        else if(current_word_lenght == longest_word_length)\n    \
    \    {\n            foreach(i; 0..current_word_lenght)\n            {\n      \
    \          if(longest_word[i] < word[i])\n                {\n                \
    \    longest_word = word;\n                    longest_word_length = current_word_lenght;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return longest_word;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkncp3i40.d(25): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkncp3i40.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int index = 0;\n    // compare number of unique characters\n\
    \    int max_unique = 0;\n    for (int i = 0; i < words.length; i++) \n    {\n\
    \        int cnt = 0;\n        char[] ch = to!(char[])(words[i]);\n        for\
    \ (int j = 0; j < ch.length; j++) \n        {\n            // count unique characters\n\
    \            bool unique = true;\n            for (int k = 0; k < j; k++) \n \
    \           {\n                if (ch[k] == ch[j]) \n                {\n     \
    \               unique = false;\n                    break;\n                }\n\
    \            }\n            if (unique)\n                cnt++;\n        }\n \
    \       if (cnt > max_unique) \n        {\n            index = i;\n          \
    \  max_unique = cnt;\n        }\n    }\n    return words[index];\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3jfuvliu.d(25): Error: template instance `to!(char[])` template
    `to` is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3jfuvliu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string found;\n    int[] counter;\n    int max = 0;\n    foreach(string\
    \ word; words)\n    {\n        counter = to!int[](bool[](word.length));\n    \
    \    foreach(char letter; word)\n        {\n            if (counter[indexOf(word,\
    \ letter)] == 0)\n            {\n                counter[indexOf(word, letter)]\
    \ = 1;\n            }\n        }\n        if (sum(counter) > max)\n        {\n\
    \            max = sum(counter);\n            found = word;\n        }\n    }\n\
    \    return found;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_kembstt.d(24): Error: found `[` when expecting `.` following bool

    /tmp/tmp_kembstt.d(24): Error: found `]` when expecting identifier following `bool`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_kembstt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // Check for null pointer\n    if (words.length == 0) \n   \
    \ {\n        return null;\n    }\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3vkpfr3a.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3vkpfr3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_word;\n    foreach(string i; words)\n    {\n    \
    \    if (i.length > max_word.length)\n        {\n            max_word = i;\n \
    \       }\n    }\n    return max_word;\n}\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvc2m5ws1.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmpvc2m5ws1.__unittest_L29_C1() [0x427cc2]

    ??:? void tmpvc2m5ws1.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d93f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a87c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a779]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d715]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    struct words_count_chars\n    {\n        string word;\n    \
    \    int unique_char_count;\n    }\n    words_count_chars[] arr_word_count = new\
    \ words_count_chars[];\n    foreach(word; words)\n    {\n        int unique_char_count\
    \ = 0;\n        for(int i = 0; i < word.length; i++)\n        {\n            if(word[i]\
    \ != ' ')\n            {\n                if(word.indexOf(word[i]) == i)\n   \
    \             {\n                    unique_char_count++;\n                }\n\
    \            }\n        }\n        words_count_chars wcc;\n        wcc.word =\
    \ word;\n        wcc.unique_char_count = unique_char_count;\n        arr_word_count\
    \ ~= wcc;\n    }\n    int maximum = 0;\n    for(int i = 0; i < arr_word_count.length;\
    \ i++)\n    {\n        if(arr_word_count[i].unique_char_count > maximum)\n   \
    \     {\n            maximum = arr_word_count[i].unique_char_count;\n        }\n\
    \    }\n    foreach(w; arr_word_count)\n    {\n        if(w.unique_char_count\
    \ == maximum)\n        {\n            return w.word;\n        }\n    }\n    return\
    \ null;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptcntwbvn.d(24): Error: new can only create structs, dynamic arrays
    or class objects, not `words_count_chars[]`''s

    /tmp/tmptcntwbvn.d(32): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptcntwbvn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string s = words[0];\n    int n = 0;\n    foreach(string w;\
    \ words)\n    {\n        if(n < w.length)\n        {\n            n = w.length;\n\
    \            s = w;\n        }\n    }\n    return s;\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp70rrufkw.d(25): Error: cannot implicitly convert expression `w.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp70rrufkw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    return words.reduce!((a, b) => \n                         {\n\
    \                             // Same number of unique characters\n          \
    \                   if (a.length == b.length)\n                             {\n\
    \                                 return (a < b) ? a : b;\n                  \
    \           }\n                             // Different number of unique characters\n\
    \                             else\n                             {\n         \
    \                        return (a.length > b.length) ? a : b;\n             \
    \                }\n                         }\n                        );\n}\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl2lkxm0f.d(19): Error: no property `reduce` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl2lkxm0f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    Tuple!(string,int)[] word_unique = new Tuple!(string,int)[words.length];\n\
    \    foreach(idx,string word; words)\n    {\n        string clean_word = word.strip().idup;\n\
    \        sort(clean_word);\n        char[] clean_array = clean_word.dup;\n   \
    \     char[] unique_array = new char[clean_array.length];\n        unique_array[0]\
    \ = clean_array[0];\n        int unique_count = 1;\n        for(int i = 1; i <\
    \ clean_array.length; i++)\n        {\n            if(clean_array[i] != clean_array[i-1])\n\
    \            {\n                unique_array[unique_count] = clean_array[i];\n\
    \                unique_count++;\n            }\n        }\n        unique_array\
    \ = unique_array[0..unique_count];\n        Tuple!(string,int) word_unique_tuple\
    \ = tuple(word,unique_count);\n        word_unique[idx] = word_unique_tuple;\n\
    \    }\n    int max_unique = max(word_unique.map!(tuple_of => tuple_of[1]));\n\
    \    Tuple!(string,int)[] max_words = word_unique.filter!(x => x[1] == max_unique);\n\
    \    return min(max_words.map!(tuple_of => tuple_of[0]));\n}\n/*\nWrite a function\
    \ to count the frequency of each symbol (character) in a string.\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnfp5tah5.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnfp5tah5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto find_max_itr = words.front;\n    int max_chars = 0;\n \
    \   foreach(word; words)\n    {\n        int chars = 0;\n        foreach(c; word)\n\
    \        {\n            if(word.indexOf(c) == word.lastIndexOf(c))\n         \
    \   {\n                chars++;\n            }\n        }\n        if(chars >\
    \ max_chars)\n        {\n            max_chars = chars;\n            find_max_itr\
    \ = word;\n        }\n    }\n    return find_max_itr;\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpot5pis6u.d(19): Error: no property `front` for type `string[]`

    /tmp/tmpot5pis6u.d(26): Error: no property `indexOf` for type `string`

    /tmp/tmpot5pis6u.d(26): Error: no property `lastIndexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpot5pis6u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    \n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqtkbs6lj.d(17): Error: function `tmpqtkbs6lj.find_max` has no `return`
    statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtkbs6lj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\timport std.algorithm : max, maxElement;\n\timport std.array :\
    \ array;\n\timport std.conv : to;\n\timport std.typecons : Tuple;\n\tauto freq\
    \ = (Tuple!(string,string[]))[\"\"];\n\t// freq[1] = unique chars\n\tforeach(word;\
    \ words)\n\t{\n\t\tstring[] temp;\n\t\tforeach(ch; word)\n\t\t{\n\t\t\ttemp ~=\
    \ to!string(ch);\n\t\t}\n\t\ttemp = temp.array.sort().array.dup.squeeze.array;\n\
    \t\tfreq = max(freq, Tuple!(string,string[])(word, temp));\n\t}\n\treturn freq[0];\n\
    }\nstring find_max2(string[] words) \n{\n\timport std.algorithm : maxElement;\n\
    \timport std.array : array;\n\timport std.conv : to;\n\timport std.typecons :\
    \ Tuple;\n\tauto freq = (Tuple!(string,string[]))[\"\"];\n\t// freq[1] = unique\
    \ chars\n\tforeach(word; words)\n\t{\n\t\tstring[] temp;\n\t\tforeach(ch; word)\n\
    \t\t{\n\t\t\ttemp ~= to!string(ch);\n\t\t}\n\t\ttemp = temp.array.sort().array.dup.squeeze.array;\n\
    \t\tfreq = maxElement(freq, Tuple!(string,string[])(word, temp));\n\t}\n\treturn\
    \ freq[0];\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe0pl5mu8.d(23): Error: cannot implicitly convert expression `""`
    of type `string` to `ulong`

    /tmp/tmpe0pl5mu8.d(32): Error: no property `sort` for type `string[]`

    /tmp/tmpe0pl5mu8.d(43): Error: cannot implicitly convert expression `""` of type
    `string` to `ulong`

    /tmp/tmpe0pl5mu8.d(52): Error: no property `sort` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0pl5mu8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto t1 = map!(a => Tuple!(a, set(a.dup))(a), words);\n    auto\
    \ max = maxElement!( (a, b) => b[1].length < a[1].length )(t1);\n    return max[0];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdvrnkua9.d(19): Error: template instance `map!((a) => Tuple!(a,
    set(a.dup))(a), words)` template `map` is not defined

    /tmp/tmpdvrnkua9.d(20): Error: template instance `maxElement!((a, b) => b[1].length
    < a[1].length)` template `maxElement` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdvrnkua9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    \n    string best_word = words[0];\n    foreach(string word;\
    \ words)\n    {\n        if(unique_chars(word) > unique_chars(best_word))\n  \
    \      {\n            best_word = word;\n        }\n    }\n    return best_word;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaib6q5i_.d(23): Error: undefined identifier `unique_chars`

    /tmp/tmpaib6q5i_.d(23): Error: undefined identifier `unique_chars`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaib6q5i_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto result = words[0];\n    auto result_len = set(result).length;\n\
    \    foreach(w; words) \n    {\n        auto w_len = set(w).length;\n        if\
    \ (w_len > result_len) \n        {\n            result = w;\n            result_len\
    \ = w_len;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9pcb93lc.d(20): Error: undefined identifier `set`, did you mean
    template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmp9pcb93lc.d(23): Error: undefined identifier `set`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9pcb93lc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // pragma(msg, typeof(words));\n    size_t idx = 0;\n    size_t\
    \ max_count = 0;\n    size_t count = 0;\n    foreach(i, idx, words)\n    {\n \
    \       if(words[i].length > max_count)\n        {\n            // check for each\
    \ letter if it's duplicated\n            max_count = words[i].length;\n      \
    \      count = 0;\n            for(size_t l = 0; l < words[i].length; l++)\n \
    \           {\n                for(size_t k = 0; k < words[i].length; k++)\n \
    \               {\n                    if(l == k) continue;\n                \
    \    if(words[i][l] == words[i][k]) break;\n                    count++;\n   \
    \             }\n            }\n            if(count == max_count)\n         \
    \   {\n                idx = i;\n            }\n        }\n    }\n    return words[idx];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkx4kivz_.d(23): Error: no identifier for declarator `words`

    /tmp/tmpkx4kivz_.d(23): Error: found `)` when expecting `;`

    /tmp/tmpkx4kivz_.d(45): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkx4kivz_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // your code here\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps26stzb0.d(17): Error: function `tmps26stzb0.find_max` has no `return`
    statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps26stzb0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(words.length > 0);\n    string[] sorted_words = words.sort();\n\
    \    string max_word = sorted_words[0];\n    size_t max_count = max_word.length;\n\
    \    foreach(string word; sorted_words) \n    {\n        size_t count = word.length;\n\
    \        if (count > max_count) \n        {\n            max_count = count;\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphdlnkmf8.d(20): Error: no property `sort` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphdlnkmf8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    return words.max!((a, b) => {\n        return a.length.compare(b.length);\n\
    \    });\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyz331flu.d(19): Error: no property `max` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyz331flu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint max_unique_chars = 0;\n\tstring max_unique_char_word = \"\"\
    ;\n\t// Count the number of unique chars in each word in the words array\n\tforeach(string\
    \ word; words)\n\t{\n\t\tint num_of_unique_chars = word.length;\n\t\tforeach(char\
    \ c; word)\n\t\t{\n\t\t\tif(word.count(c) > 1) \n\t\t\t{\n\t\t\t\t--num_of_unique_chars;\n\
    \t\t\t}\n\t\t}\n\t\tif(num_of_unique_chars > max_unique_chars)\n\t\t{\n\t\t\t\
    max_unique_chars = num_of_unique_chars;\n\t\t\tmax_unique_char_word = word;\n\t\
    \t}\n\t}\n\treturn max_unique_char_word;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbdkaq8jy.d(24): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpbdkaq8jy.d(27): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbdkaq8jy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    bool[] used;\n    int[] counts;\n    int max_count = 0;\n  \
    \  string result = \"\";\n    foreach(i, word; words)\n    {\n        used = new\
    \ bool[word.length];\n        counts = new int[word.length];\n        foreach(j,\
    \ c; word)\n        {\n            if(used[j] == false)\n            {\n     \
    \           int c_count = 1;\n                for(int k = j + 1; k < word.length;\
    \ k++)\n                {\n                    if(word[k] == c)\n            \
    \        {\n                        c_count++;\n                        used[k]\
    \ = true;\n                    }\n                }\n                counts[j]\
    \ = c_count;\n            }\n        }\n        int sum = 0;\n        foreach(k,\
    \ count; counts)\n        {\n            sum += count;\n        }\n        if(sum\
    \ > max_count)\n        {\n            max_count = sum;\n            result =\
    \ word;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7v35wz8y.d(32): Error: cannot implicitly convert expression `j
    + 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7v35wz8y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_word = words[0];\n    int max_unique = 0;\n    foreach(string\
    \ word; words)\n    {\n        int unique = 0;\n        char[] arr = word.dup;\n\
    \        arr.sort;\n        unique = arr.length;\n        foreach(char letter;\
    \ word)\n        {\n            if(arr[0] == letter)\n            {\n        \
    \        arr.removeFront;\n            }\n        }\n        unique -= arr.length;\n\
    \        if(unique > max_unique)\n        {\n            max_unique = unique;\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7c2k6vt6.d(25): Error: no property `sort` for type `char[]`

    /tmp/tmp7c2k6vt6.d(26): Error: cannot implicitly convert expression `arr.length`
    of type `ulong` to `int`

    /tmp/tmp7c2k6vt6.d(31): Error: no property `removeFront` for type `char[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7c2k6vt6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string maxWord = \"\";\n    size_t maxSize = 0;\n    foreach(word;\
    \ words)\n    {\n        size_t newMaxSize = 0;\n        foreach(char c; word)\n\
    \        {\n            //need to keep track of new word size\n            if(count(word,\
    \ c) == 1) \n            {\n                newMaxSize += 1;\n            }\n\
    \        }\n        if(newMaxSize > maxSize)\n        {\n            maxSize =\
    \ newMaxSize;\n            maxWord = word;\n        } else if(newMaxSize == maxSize)\n\
    \        {\n            if(word < maxWord)\n            {\n                maxWord\
    \ = word;\n            }\n        }\n    }\n    return maxWord;\n}\n/*\nWrite\
    \ a function that takes a range of integers and returns the length of the\n  \
    \  longest sequence of consecutive integers in that range.\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3rhfra_9.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3rhfra_9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] count = new int[words.length];\n    int index = 0;\n \
    \   // iterate through array\n    foreach(string word; words)\n    {\n       \
    \ // iterate through the word\n        foreach(dchar c; word)\n        {\n   \
    \         // check if the char is unique or not\n            if(word.indexOf(c)\
    \ == word.lastIndexOf(c))\n            {\n                count[index]++;\n  \
    \          }\n        }\n        index++;\n    }\n    // get the maximum unique\
    \ chars in an array\n    int max = count.max;\n    // find the index of the max\
    \ unique char\n    index = count.indexOf(max);\n    // return the word with max\
    \ unique char\n    return words[index];\n}\n/*\n    Write a function that accepts\
    \ a string (s) and returns a bool. The string\n    contains a sequence of digits.\
    \ Determine if the string is a valid ISBN\n    number as per rules specified below:\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_a30et74.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_a30et74.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    foreach(word;\
    \ words)\n    {\n        int unique = unique_count(word);\n        if(unique >\
    \ max)\n        {\n            max = unique;\n            maxWord = word;\n  \
    \      }\n    }\n    return maxWord;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp75dsms0j.d(23): Error: undefined identifier `unique_count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp75dsms0j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] word_uniq_count;\n    foreach(word; words)\n    {\n  \
    \      word_uniq_count ~= word.length - word.dup.length;\n    }\n    return words[maxIndex(word_uniq_count)];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp96hnj9yn.d(22): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmp96hnj9yn.d(24): Error: undefined identifier `maxIndex`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp96hnj9yn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string res;\n    int max = 0;\n    foreach(word; words) \n \
    \   {\n        int cur = toHashSet(word).length;\n        if (cur > max) \n  \
    \      {\n            max = cur;\n            res = word;\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf9bxiie4.d(23): Error: undefined identifier `toHashSet`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf9bxiie4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    return max(words, (string a, string b) {\n        auto alen\
    \ = uniq(a).length;\n        auto blen = uniq(b).length;\n        return alen\
    \ == blen ? a < b : alen < blen;\n    });\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8isbbl95.d(19): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8isbbl95.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    int result_size = 0;\n    foreach(string\
    \ word; words)\n    {\n        int size = word.size;\n        int max = 0;\n \
    \       for(int i = 0; i < size; i++)\n        {\n            foreach(char ch;\
    \ word)\n            {\n                if(ch == word[i])\n                {\n\
    \                    max++;\n                }\n            }\n        }\n   \
    \     if(max > result_size)\n        {\n            result = word;\n         \
    \   result_size = max;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2iv5vqhx.d(23): Error: no property `size` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2iv5vqhx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    size_t maxLen = 0;\n    string maxStr = \"\";\n    foreach(word;\
    \ words)\n    {\n        maxLen = max(maxLen, uniq(word).length);\n    }\n   \
    \ foreach(word; words)\n    {\n        if(uniq(word).length == maxLen)\n     \
    \   {\n            maxStr = word;\n            break;\n        }\n    }\n    return\
    \ maxStr;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_b_us0f5.d(23): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmp_b_us0f5.d(27): Error: undefined identifier `uniq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_b_us0f5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\t// Write your solution here.\n\tint max = 0;\n\tstring r;\n\t\
    foreach(string s; words)\n\t{\n\t\tint n = unique(s);\n\t\tif(n > max)\n\t\t{\n\
    \t\t\tmax = n;\n\t\t\tr = s;\n\t\t}\n\t}\n\treturn r;\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6oh51atn.d(24): Error: undefined identifier `unique`, did you mean
    struct `Unique(T)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6oh51atn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    //Tuple!(int, string)[] lengths = new Tuple!(int, string)[];\n\
    \    Tuple!(int, string)[] lengths = new Tuple!(int, string)[];\n    for (int\
    \ i = 0; i < words.length; i++) \n    {\n        string word = words[i];\n   \
    \     string word1 = word;\n        int l = word.length;\n        for (int j =\
    \ 0; j < l; j++) \n        {\n            if (word1.indexOf(word[j]) != word1.lastIndexOf(word[j]))\
    \ \n            {\n                word1 = word1.remove(word1.indexOf(word[j]),1);\n\
    \            }\n        }\n        lengths ~= tuple(word1.length, word);\n   \
    \ }\n    int max = -1;\n    string maxWord = \"\";\n    for (int i = 0; i < lengths.length;\
    \ i++) \n    {\n        if (lengths[i][0] > max) \n        {\n            max\
    \ = lengths[i][0];\n            maxWord = lengths[i][1];\n        } \n       \
    \ else if (lengths[i][0] == max) \n        {\n            if (lengths[i][1] <\
    \ maxWord) \n            {\n                maxWord = lengths[i][1];\n       \
    \     }\n        }\n    }\n    return maxWord;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_78m7zr1.d(20): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(int, string)[]`''s

    /tmp/tmp_78m7zr1.d(25): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_78m7zr1.d(28): Error: no property `indexOf` for type `string`

    /tmp/tmp_78m7zr1.d(28): Error: no property `lastIndexOf` for type `string`

    /tmp/tmp_78m7zr1.d(30): Error: no property `remove` for type `string`

    /tmp/tmp_78m7zr1.d(33): Error: cannot append type `Tuple!(ulong, string)` to type
    `Tuple!(int, string)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_78m7zr1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    /*\n     * \n     * Use a Set or Hashtable to find the unique\
    \ characters.\n     * \n     * - the documentation says:\n     *    - the remove()\
    \ function will return \n     *      true if the element was removed and \n  \
    \   *      false if it was not found. \n     *    - the element could have been\
    \ \"removed\" if it was not found because\n     *      a set only contains unique\
    \ elements.\n     * \n     * - therefore, the iterate function will return \n\
    \     *     - false if the element was not found, and\n     *     - true if the\
    \ element was found.\n     *  \n     * - since I am iterating through the characters\
    \ in the word, I will get \n     *   false if the character has already been found.\n\
    \     *   This is the opposite of what I want.\n     *   \n     * - negate the\
    \ boolean with the ! (not) function.\n     * \n     * - I want to use the reduce\
    \ function (or foldl).\n     *   - it takes a \"range\" (the input list) and a\
    \ function\n     *     (the function being applied to the elements).\n     * \
    \  - the function takes two parameters:\n     *     - the accumulator (here, it\
    \ will hold the accumulator from \n     *       the previous step, the initial\
    \ value being \"true\")\n     *     - the element (here, it will be the character)\n\
    \     *     \n     * - the reduce function will return the reduced value, which\
    \ will\n     *   be the result of the final call to the function.\n     * \n \
    \    * - the final result will be true if all the characters in the word are\n\
    \     *   unique. \n     *   \n     * - if the word is unique, we want to add\
    \ it to a tuple\n     *   that contains the unique characters and the word.\n\
    \     *   - if it is not unique, we don't need to add it.\n     *   - we want\
    \ to use the ? (ternary) operator.\n     * \n     * - if the word is unique and\
    \ already exists in the result, \n     *   we want to return the word with the\
    \ smaller lexicographical order.\n     *   \n     * - so, if\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4q1rs37f.d(19): Error: unterminated /* */ comment

    /tmp/tmp4q1rs37f.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4q1rs37f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // TODO:\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpglp8i7mo.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fdd]

    ??:? void tmpglp8i7mo.__unittest_L22_C1() [0x427b99]

    ??:? void tmpglp8i7mo.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a765]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a7f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a6f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d0d]

    ??:? runModuleUnitTests [0x42d68d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42942c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string s_max_word;\n    int max_word = 0;\n    foreach(w; words)\n\
    \    {\n        int current_word = 0;\n        foreach(c; w)\n        {\n    \
    \        current_word += 1;\n        }\n        if(current_word > max_word)\n\
    \        {\n            max_word = current_word;\n            s_max_word = w;\n\
    \        }\n    }\n    return s_max_word;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj0377h0s.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290c5]

    ??:? void tmpj0377h0s.__unittest_L36_C1() [0x427d26]

    ??:? void tmpj0377h0s.__modtest() [0x428330]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a84d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8dc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428df5]

    ??:? runModuleUnitTests [0x42d775]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429514]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max(null);\n    string[] result;\n    foreach(word; words)\
    \ \n    {\n        if (word.length > max.length) \n        {\n            result\
    \ = [word];\n            max = word;\n        } \n        else if (word.length\
    \ == max.length) \n        {\n            result ~= word;\n        }\n    }\n\
    \    return result[0];\n}\nunittest\n{\n    alias candidate = find_max;\n\n  \
    \  assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpapt9cpku.d(19): Error: found `max` when expecting `;` following
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpapt9cpku.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint max = 0;\n\tint max_word_num = 0;\n\tstring[] word_uniq =\
    \ new string[words.length];\n\tfor (int i = 0; i < words.length; i++)\n\t{\n\t\
    \tword_uniq[i] = uniq(words[i]);\n\t\tif (word_uniq[i].length > max)\n\t\t{\n\t\
    \t\tmax = word_uniq[i].length;\n\t\t\tmax_word_num = i;\n\t\t}\n\t}\n\tif (max_word_num\
    \ != 0)\n\t{\n\t\twords[0] = words[max_word_num];\n\t\twords[max_word_num] = words[0];\n\
    \t}\n\treturn words[0];\n}\n/*\nWrite a function that accepts an array of integers.\n\
    \    The function should return the second smallest integer\n    in the array.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwfnnjref.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfnnjref.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_word = \"\";\n    int max_count = 0;\n    foreach(word;\
    \ words) \n    {\n        int count = 0;\n        foreach(i; 0 .. word.length)\
    \ \n        {\n            char char = word[i];\n            count++;\n      \
    \      if(word[i+1 .. $] ~= char) \n            {\n                break;\n  \
    \          }\n        }\n        if(count > max_count) \n        {\n         \
    \   max_count = count;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1j0k0_bj.d(26): Error: no identifier for declarator `char`

    /tmp/tmp1j0k0_bj.d(26): Error: no identifier for declarator `char`

    /tmp/tmp1j0k0_bj.d(26): Error: found `=` instead of statement

    /tmp/tmp1j0k0_bj.d(28): Error: found `)` when expecting `.` following char

    /tmp/tmp1j0k0_bj.d(29): Error: found `{` when expecting identifier following `char`.

    /tmp/tmp1j0k0_bj.d(30): Error: found `break` when expecting `)`

    /tmp/tmp1j0k0_bj.d(30): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmp1j0k0_bj.d(39): Error: declaration expected, not `return`

    /tmp/tmp1j0k0_bj.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1j0k0_bj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tauto comp(T)(T a, T b) \n\t{\n\t\treturn (a > b) ? 1 : (a < b)\
    \ ? -1 : 0;\n\t}\n\tauto word_comparator = &comp;\n\tauto word_score(string word)\
    \ \n\t{\n\t\tauto score = [0];\n\t\tforeach(char c; word) \n\t\t{\n\t\t\tif (c\
    \ in score) \n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tscore[c] = 1;\n\t\t}\n\
    \t\treturn score.length;\n\t}\n\tauto word_score_comparator = &word_score;\n\t\
    auto words_with_score = map!(Tuple!(string, int))(words, word_score_comparator);\n\
    \tauto max_score = reduce!max(words_with_score.map!(tuple => tuple[1]));\n\tauto\
    \ candidates = words_with_score.filter!(tuple => tuple[1] == max_score);\n\tif\
    \ (candidates.length == 1) \n\t{\n\t\treturn candidates[0][0];\n\t}\n\treturn\
    \ reduce!min(candidates, word_comparator).tuple[0];\n}\n/*\nWrite a function called\
    \ tag_text(input_file, output_file, tag_name) that\n    accepts an input file\
    \ and an output file as arguments. Then, the function\n    should read all the\
    \ lines from the input file, wrap all the lines in the\n    given tag and then\
    \ write the content to the output file.\n    \n    Here is a sample file that\
    \ contains the text that needs to be marked up:\n        \"`My name is `Travis\
    \ Green``.\n        `I am from `North Carolina``.\"\n    The function tag_text()\
    \ should write the following content to the output\n    file.\n        \"<name>My\
    \ name is Travis Green</name>.\n        <state>I am from North Carolina</state>.\"\
    \n    >>> tag_text(\"input.txt\", \"output.txt\", \"name\")\n*/\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppvcaqnjw.d(23): Error: `comp(T)(T a, T b)` is not an lvalue and
    cannot be modified

    /tmp/tmppvcaqnjw.d(29): Error: incompatible types for `(c) in (score)`: `char`
    and `int[]`

    /tmp/tmppvcaqnjw.d(38): Error: template instance `map!(Tuple!(string, int))` template
    `map` is not defined

    /tmp/tmppvcaqnjw.d(39): Error: template instance `reduce!max` template `reduce`
    is not defined

    /tmp/tmppvcaqnjw.d(45): Error: template instance `reduce!min` template `reduce`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppvcaqnjw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_word = words[0];\n    int max_length = length(set(max_word));\n\
    \    foreach(string word; words) \n    {\n        int l = length(set(word));\n\
    \        if (l > max_length) \n        {\n            max_length = l;\n      \
    \      max_word = word;\n        }\n        else if (l == max_length) \n     \
    \   {\n            if (word < max_word) \n            {\n                max_word\
    \ = word;\n            }\n        }\n    }\n    return max_word;\n}\n/*\nWrite\
    \ a function that accepts an array of strings, and one more string,\n    that\
    \ is to be searched. The function should return the index of the first\n    occurrence\
    \ of the needle in haystack. If the needle is not found, the\n    function should\
    \ return -1.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvu0i9efp.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvu0i9efp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\t// Maximum number of unique characters (in any given word)\n\t\
    int maxUniqueChars = 0;\n\tstring maxString = \"\";\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo1l42qz9.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo1l42qz9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result;\n    for (int i = 0; i < words.length; i++) \n\
    \    {\n        string the_words = words[i];\n        if(the_words.length > result.length)\n\
    \        {\n            result = the_words;\n        }\n    }\n    return result;\n\
    }\n// UNIT TEST\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2_kdubcj.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42905d]

    ??:? void tmp2_kdubcj.__unittest_L31_C1() [0x427cbe]

    ??:? void tmp2_kdubcj.__modtest() [0x4282c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428db6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a859]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7e5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d8d]

    ??:? runModuleUnitTests [0x42d781]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429520]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    const uint MAX_WORD_LENGTH = 30;\n    uint[MAX_WORD_LENGTH]\
    \ char_count;\n    uint max_unique_chars = 0;\n    uint idx = 0;\n    foreach(string\
    \ word; words)\n    {\n        uint cnt = 0;\n        foreach(char ch; word)\n\
    \        {\n            if(!char_count[ch]) \n            {\n                ++cnt;\n\
    \                char_count[ch] = 1;\n            }\n        }\n        if(cnt\
    \ > max_unique_chars)\n        {\n            max_unique_chars = cnt;\n      \
    \      idx = word.idx;\n        }\n        char_count[] = 0;\n    }\n    return\
    \ words[idx];\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagxya6ny.d(37): Error: no property `idx` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagxya6ny.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    size_t max_value = 0;\n    string result = \"\";\n    for (auto\
    \ word : words) \n    {\n        size_t word_value = 0;\n        for (auto i =\
    \ 0; i < word.length; i++) \n        {\n            if (word[i] >= word_value)\
    \ \n            {\n                word_value = word[i];\n            }\n    \
    \    }\n        if (word_value > max_value) \n        {\n            max_value\
    \ = word_value;\n            result = word;\n        }\n    }\n    return result;\n\
    }\n/*\nWrite a function to find the longest common prefix string amongst an array\
    \ of strings.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpohl0vyje.d(21): Error: no identifier for declarator `word`

    /tmp/tmpohl0vyje.d(21): Error: expression expected, not `:`

    /tmp/tmpohl0vyje.d(21): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmpohl0vyje.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpohl0vyje.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    import std.algorithm;\n    import std.range;\n    import std.typecons;\n\
    \    return words.map!(a => tuple(a, a.sort)).map!(b => tuple(b[0], b[1].uniq)).sort!((a,\
    \ b) => a[1].length > b[1].length).front[0];\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp97m24uih.d(22): Error: template `std.algorithm.sorting.sort` cannot
    deduce function from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/sorting.d(1847):        `std.algorithm.sorting.sort(alias
    less = "a < b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range r) if ((ss
    == SwapStrategy.unstable && (hasSwappableElements!Range || hasAssignableElements!Range)
    || ss != SwapStrategy.unstable && hasAssignableElements!Range) && isRandomAccessRange!Range
    && hasSlicing!Range && hasLength!Range)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):        instantiated
    from here: `MapResult!(__lambda2, string[])`

    /tmp/tmp97m24uih.d(22):        instantiated from here: `map!(string[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp97m24'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string m = words[0];\n    for (size_t i = 1; i < words.length;\
    \ i++)\n    {\n        string current = words[i];\n        if (current.length\
    \ > m.length)\n        {\n            m = current;\n        }\n        else if\
    \ (current.length == m.length)\n        {\n            int current_num = find_unique(current);\n\
    \            int m_num = find_unique(m);\n            if (current_num > m_num)\n\
    \            {\n                m = current;\n            }\n            else\
    \ if (current_num == m_num)\n            {\n                if (current < m)\n\
    \                {\n                    m = current;\n                }\n    \
    \        }\n        }\n    }\n    return m;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg801wsyv.d(29): Error: undefined identifier `find_unique`

    /tmp/tmpg801wsyv.d(30): Error: undefined identifier `find_unique`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg801wsyv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string[string] dict;\n    int max = 0;\n    string ans = \"\"\
    ;\n    foreach(word; words) \n    {\n        dict = words[word];\n        foreach(ch;\
    \ word)\n        {\n            dict[ch]++;\n        }\n        if(dict.length\
    \ > max) \n        {\n            max = dict.length;\n            ans = word;\n\
    \        } \n        else if(dict.length == max) \n        {\n            if(ans\
    \ > word) \n            {\n                ans = word;\n            }\n      \
    \  }\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt07601wc.d(24): Error: cannot implicitly convert expression `word`
    of type `string` to `ulong`

    /tmp/tmpt07601wc.d(27): Error: cannot implicitly convert expression `ch` of type
    `immutable(char)` to `string`

    /tmp/tmpt07601wc.d(31): Error: cannot implicitly convert expression `_aaLen(dict)`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt07601wc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint max = 0;\n\tint count = 0;\n\tint index = 0;\n\tforeach(string\
    \ s; words) \n\t{\n\t\tcount = s.length;\n\t\tif(count > max) \n\t\t{\n\t\t\t\
    max = count;\n\t\t\tindex = i;\n\t\t}\n\t}\n\treturn words[index];\n}\n/*\nWrite\
    \ a program that accepts an array of integers, and returns an array of\n    same\
    \ length where elements at i'th index are multiplied by (i+1)\n    >>> multiply([1,\
    \ 2, 3, 4, 5])\n    [1, 4, 9, 16, 25]\n    >>> multiply([0, 1, 0, 1, 0])\n   \
    \ [0, 1, 0, 4, 0]\n*/\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxyd9mt68.d(24): Error: cannot implicitly convert expression `s.length`
    of type `ulong` to `int`

    /tmp/tmpxyd9mt68.d(28): Error: undefined identifier `i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyd9mt68.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    int result_length = 0;\n    foreach(word;\
    \ words) \n    {\n        auto word_set = word.split(\"\").sort().uniq;\n    \
    \    if(word_set.length > result_length) \n        {\n            result = word;\n\
    \            result_length = word_set.length;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpftfzg3pj.d(23): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpftfzg3pj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  // put your code here\n  //string max_word;\n  string max_word\
    \ = \"\";\n  string max_word_aux;\n  char[] max_letters;\n  char[] max_letters_aux;\n\
    \  int count_letters = 0;\n  int count_letters_aux = 0;\n  foreach(string word;\
    \ words)\n  {\n    count_letters_aux = 0;\n    max_letters_aux = [];\n    foreach(char\
    \ letter; word)\n    {\n      if(letter !in max_letters_aux)\n      {\n      \
    \  max_letters_aux ~= letter;\n        count_letters_aux++;\n      }\n    }\n\
    \    if(count_letters_aux > count_letters)\n    {\n      count_letters = count_letters_aux;\n\
    \      max_letters = max_letters_aux;\n      max_word = word;\n    }\n  }\n  return\
    \ max_word;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplyvg0ca9.d(33): Error: incompatible types for `(letter) in (max_letters_aux)`:
    `char` and `char[]`

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    import std.range, std.algorithm, std.typecons;\n    static struct\
    \ Tuple\n    {\n        immutable string word;\n        immutable uint num;\n\
    \    }\n    return words.map!(s => Tuple(s, s.array.unique.length))\n        \
    \         .max!((Tuple x, Tuple y) => x.num < y.num || x.num == y.num && x.word\
    \ > y.word).word;\n}\n/*\n    Write a function that accepts two integer arguments:\
    \ an array and a key to\n    be searched. Return index of the element with the\
    \ given key.\n    If the key is not found, return -1.\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqgzkd_70.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqgzkd_70.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string result = \"\";\n    foreach(word; words)\n\
    \    {\n        int temp = unique_characters(word);\n        if(temp > max)\n\
    \        {\n            max = temp;\n            result = word;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpau9agldv.d(23): Error: undefined identifier `unique_characters`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpau9agldv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // TODO: Implement this function\n    string max_str;\n    uint\
    \ max_size = 0;\n    uint size;\n    for (int i = 0; i < words.length; i++)\n\
    \    {\n        size = words[i].length;\n        if (size > max_size)\n      \
    \  {\n            max_size = size;\n            max_str = words[i];\n        }\n\
    \    }\n    return max_str;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp72wx7rhi.d(25): Error: cannot implicitly convert expression `words[cast(ulong)i].length`
    of type `ulong` to `uint`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72wx7rhi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    foreach(string s ; words)\n    {\n        if(!s.empty)\n   \
    \     {\n            string[] temp = s.split();\n            if(temp.length ==\
    \ s.length)\n            {\n                return s;\n            }\n       \
    \ }\n    }\n    return \"\";\n}\n/*\nWrite a function that accepts two arrays\
    \ of integers.\n    Return true if the arrays have the same content and false\
    \ otherwise.\n    >>> array_compare([1, 2, 3], [1, 2, 3])\n    true\n    >>> array_compare([1,\
    \ 2, 3], [1, 2, 3, 4])\n    false\n    >>> array_compare([1, 2, 3], [4, 5, 6])\n\
    \    false\n    >>> array_compare([1, 2, 3], [3, 2, 1])\n    false\n    \n*/\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi8swgq82.d(21): Error: no property `empty` for type `string`

    /tmp/tmpi8swgq82.d(23): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi8swgq82.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    \n\tint max = 0;\n\tint index = 0;\n\tint[] count = new int[words.length];\n\
    \tforeach(int i, string w; words) \n\t{\n\t\tcount[i] = 0;\n\t\tw = w.idup;\n\t\
    \tforeach(string c; w) \n\t\t{\n\t\t\tif(c != \"\") \n\t\t\t{\n\t\t\t\tauto remove_index\
    \ = w.indexOf(c);\n\t\t\t\tw[remove_index .. remove_index + 1] = \"\";\n\t\t\t\
    \tcount[i]++;\n\t\t\t}\n\t\t}\n\t\tif(count[i] > max) \n\t\t{\n\t\t\tmax = count[i];\n\
    \t\t\tindex = i;\n\t\t}\n\t}\n\treturn words[index];\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp902ks7u.d(27): Error: cannot implicitly convert expression `__r79[__key80]`
    of type `immutable(char)` to `string`

    /tmp/tmpp902ks7u.d(31): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp902ks7u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(words);\n    // for each word in words,\n    // find\
    \ the number of unique characters\n    // find the word with the most unique characters\n\
    \    // if there are more than one, find the lexicographically first\n    int\
    \ max_unique = 0;\n    string result = \"\";\n    foreach(word; words) \n    {\n\
    \        // find unique characters in word\n        int unique = 0;\n        foreach(c;\
    \ word) \n        {\n            if (word.count(c) == 1) \n            {\n   \
    \             unique += 1;\n            }\n        }\n        if (unique > max_unique)\
    \ \n        {\n            max_unique = unique;\n            result = word;\n\
    \        }\n        else if (unique == max_unique) \n        {\n            //\
    \ Check if word comes before current result\n            // if it does, replace\
    \ result with word\n            if (word < result) \n            {\n         \
    \       result = word;\n            }\n        }\n    }\n    return result;\n\
    }\n/*\n    Write a function that accepts two arrays of strings,\n    and returns\
    \ the string that occurs most often in each array.\n    If multiple strings occur\
    \ the same number of times,\n    return the lexicographically first string.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8y_m47ov.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8y_m47ov.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_str = \"\";\n    foreach(string str; words)\n   \
    \ {\n        if(str.length > max_str.length)\n        {\n            max_str =\
    \ str;\n        }\n    }\n    return max_str;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi6r75584.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmpi6r75584.__unittest_L29_C1() [0x427cc2]

    ??:? void tmpi6r75584.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d93f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a87c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a779]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d715]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(words.length > 0);\n    string maxUniqueStr = words[0];\n\
    \    uint maxCountUnique = getCountUnique(maxUniqueStr);\n    foreach(string word;\
    \ words)\n    {\n        uint countUnique = getCountUnique(word);\n        if(countUnique\
    \ > maxCountUnique)\n        {\n            maxCountUnique = countUnique;\n  \
    \          maxUniqueStr = word;\n        }\n    }\n    return maxUniqueStr;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw756jqe_.d(21): Error: undefined identifier `getCountUnique`

    /tmp/tmpw756jqe_.d(24): Error: undefined identifier `getCountUnique`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw756jqe_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    //TODO\n    int maxLength = 0;\n    string maxWord = \"\";\n\
    \    foreach(string word; words)\n    {\n        int[] chars = new int[256];\n\
    \        foreach(char c; word)\n        {\n            chars[c] = 1;\n       \
    \ }\n        int count = 0;\n        foreach(int ch; chars)\n        {\n     \
    \       count += ch;\n        }\n        if(count > maxLength)\n        {\n  \
    \          maxLength = count;\n            maxWord = word;\n        }\n    }\n\
    \    return maxWord;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfisqexgq.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x429415]

    ??:? void tmpfisqexgq.__unittest_L42_C1() [0x428076]

    ??:? void tmpfisqexgq.__modtest() [0x428680]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dfa3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42916e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ac6d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42acfc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42abf9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429145]

    ??:? runModuleUnitTests [0x42dd79]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4298d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    import std.algorithm;\n    import std.range;\n    import std.string;\n\
    \    import std.array;\n    import std.typecons;\n    import std.math;\n    auto\
    \ num_uniq = (string word) =>\n    {\n        auto arr = word.split;\n       \
    \ arr.sort;\n        auto res = arr.uniq;\n        return res.length;\n    };\n\
    \    import std.algorithm : maxElement;\n    auto max_word = words.maxElement!(num_uniq);\n\
    \    return max_word;\n}\n/*\nWrite a program that accepts a list of numbers from\
    \ console and then uses\n    recursion to print all the numbers in the list.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8nu2upe5.d(36): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8nu2upe5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string res;\n    int max_count = 0;\n    foreach(string word;\
    \ words) \n    {\n        int count = 0;\n        foreach(char c; word) \n   \
    \     {\n            if(!res.canFind(c))\n                count++;\n        }\n\
    \        if(count > max_count) \n        {\n            max_count = count;\n \
    \           res = word;\n        }\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpucriap4q.d(26): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpucriap4q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if (words.length == 0) return \"\";\n    // Compare strings\
    \ by length first, then alphabetically\n    // shorter strings will be placed\
    \ before longer strings\n    // with equal length when sorted\n    string[] sorted\
    \ = sort(words, (a, b) => \n    {\n        if (a.length == b.length) \n      \
    \  {\n            return a < b;\n        }\n        return a.length < b.length;\n\
    \    });\n    // Retrieve the last element\n    string max_word = sorted[$ - 1];\n\
    \    // Find the number of unique characters\n    auto set = uniq(max_word);\n\
    \    int num_unique = set.length;\n    // If the number of unique characters is\
    \ the same as the number of\n    // characters in the current word, we found the\
    \ largest string.\n    if (num_unique == max_word.length) return max_word;\n \
    \   // Otherwise search backwards to find the first element with the \n    //\
    \ maximum number of unique characters\n    foreach (i, word; sorted[0 .. $ - 1])\
    \ \n    {\n        if (word.length != num_unique) break;\n        max_word = word;\n\
    \    }\n    return max_word;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcmq9woh5.d(23): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpcmq9woh5.d(34): Error: undefined identifier `uniq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcmq9woh5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tauto res = words[0];\n\tforeach(i, ref word; words) \n\t{\n\t\t\
    if(to!(Set)(word).length > to!(Set)(res).length) \n\t\t{\n\t\t\tres = word;\n\t\
    \t}\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = find_max;\n\n \
    \   assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm6mf8owp.d(22): Error: template instance `to!Set` template `to`
    is not defined, did you mean No?

    /tmp/tmpm6mf8owp.d(22): Error: template instance `to!Set` template `to` is not
    defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm6mf8owp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] counts = [];\n    foreach(word; words) \n    {\n     \
    \   auto uc = count(word);\n        counts ~= uc;\n    }\n    int max = reduce!max(counts);\n\
    \    int index = 0;\n    for(int i = 0; i < counts.length; i++) \n    {\n    \
    \    if(counts[i] == max)\n        {\n            index = i;\n            break;\n\
    \        }\n    }\n    return words[index];\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzt1gmc0d.d(22): Error: undefined identifier `count`, did you mean
    variable `counts`?

    /tmp/tmpzt1gmc0d.d(25): Error: template instance `reduce!max` template `reduce`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzt1gmc0d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max_unique = 0;\n    string max_string = \"\";\n    foreach(string\
    \ word; words) \n    {\n        string newword = \"\";\n        foreach(char c;\
    \ word) \n        {\n            if(!newword.find(c)) \n            {\n      \
    \          newword ~= c;\n            }\n        }\n        int unique = newword.length;\n\
    \        if(unique > max_unique) \n        {\n            max_unique = unique;\n\
    \            max_string = word;\n        }\n        else if(unique == max_unique)\
    \ \n        {\n            if(word < max_string) \n            {\n           \
    \     max_string = word;\n            }\n        }\n    }\n    return max_string;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpedcjfz7v.d(26): Error: no property `find` for type `string`

    /tmp/tmpedcjfz7v.d(31): Error: cannot implicitly convert expression `newword.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedcjfz7v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tauto maxLength = std.range.maxElement!((x) { return x.length;\
    \ })(words);\n\tauto maxCount = 0;\n\tforeach(ref word; words)\n\t{\n\t\tif(word.length\
    \ == maxLength)\n\t\t{\n\t\t\tauto count = std.algorithm.uniq!(std.functional.unaryFun!(toLower)(std.functional.identity))(word).length;\n\
    \t\t\tif(count > maxCount)\n\t\t\t{\n\t\t\t\tmaxCount = count;\n\t\t\t}\n\t\t\
    }\n\t}\n\t\n\tauto maxWord = \"\";\n\tforeach(ref word; words)\n\t{\n\t\tif(word.length\
    \ == maxLength)\n\t\t{\n\t\t\tauto count = std.algorithm.uniq!(std.functional.unaryFun!(toLower)(std.functional.identity))(word).length;\n\
    \t\t\tif(count == maxCount)\n\t\t\t{\n\t\t\t\tif(maxWord == \"\")\n\t\t\t\t{\n\
    \t\t\t\t\tmaxWord = word;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(word\
    \ < maxWord)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxWord = word;\n\t\t\t\t\t}\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\treturn maxWord;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuwwnwuj9.d(19): Deprecation: package `std.range` is not accessible
    here

    /tmp/tmpuwwnwuj9.d(19): Error: undefined identifier `maxElement` in package `std.range`

    /tmp/tmpuwwnwuj9.d(25): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmpuwwnwuj9.d(38): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwwnwuj9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    return words.sort[0];\n}\n/*\nWrite a function that accepts\
    \ an array of integers. The array contains\n    different numbers. Return the\
    \ number that appears most in the array. If\n    multiple numbers appear equally\
    \ most, return the first one.\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzrupc2vd.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzrupc2vd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max = \"\";\n    foreach(string word; words)\n    {\n\
    \        int[] count = new int[256];\n        foreach(char c; word)\n        {\n\
    \            count[c]++;\n        }\n        int unique = 0;\n        foreach(int\
    \ elem; count)\n        {\n            if(elem == 1)\n            {\n        \
    \        unique++;\n            }\n        }\n        if(unique > max.length)\n\
    \        {\n            max = word;\n        }\n    }\n    return max;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqzyxsjk1.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x429405]

    ??:? void tmpqzyxsjk1.__unittest_L42_C1() [0x428066]

    ??:? void tmpqzyxsjk1.__modtest() [0x428670]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42df93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42915e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ac5d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42acec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42abe9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429135]

    ??:? runModuleUnitTests [0x42dd69]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4298c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    import std.algorithm : max;\n    import std.algorithm : uniq;\n\
    \    import std.range : map;\n    import std.string : join;\n    import std.math\
    \ : ln, pow;\n    import std.conv : to;\n    import std.typecons : tuple;\n  \
    \  import std.array : array;\n    auto tuples = words.map!(a =&gt; tuple(a, a.uniq.length));\n\
    \    auto max_tuple = tuples.max!((a, b) =&gt; a[1] &lt; b[1]);\n    return max_tuple[0];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ui2sv19.d(27): Error: found `;` when expecting `)` following template
    argument list

    /tmp/tmp7ui2sv19.d(27): Error: semicolon expected following auto declaration,
    not `tuple`

    /tmp/tmp7ui2sv19.d(27): Error: found `)` when expecting `;` following statement

    /tmp/tmp7ui2sv19.d(27): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp7ui2sv19.d(28): Error: found `;` when expecting `)` following template
    argument list

    /tmp/tmp7ui2sv19.d(28): Error: semicolon expected following auto declaration,
    not `a`

    /tmp/tmp7ui2sv19.d(28): Error: found `)` when expecting `;` following statement

    /tmp/tmp7ui2sv19.d(28): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ui2sv19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(words.length > 0);\n    return words.max!((a, b) => a.length\
    \ < b.length)();\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkr4ce0ku.d(20): Error: no property `max` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkr4ce0ku.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(!words.empty);\n    string max = words[0];\n    for (int\
    \ i = 1; i < words.length; i++)\n    {\n        if (words[i].length > max.length)\n\
    \        {\n            max = words[i];\n        }\n        else if (words[i].length\
    \ == max.length)\n        {\n            if (words[i] < max)\n            {\n\
    \                max = words[i];\n            }\n        }\n    }\n    return\
    \ max;\n}\n/*\nWrite a function that accepts a string s and an int n. Return a\
    \ string\n    where the character at index n is replaced by the character '_'.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprt3xclau.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprt3xclau.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    //Type: tuple!(int, string)\n    size_t max = 0;\n    string\
    \ result = \"\";\n    foreach(w; words)\n    {\n        size_t num = uniqs(w);\n\
    \        if(num > max)\n        {\n            max = num;\n            result\
    \ = w;\n        }\n        else if(num == max)\n        {\n            result\
    \ = min(result, w);\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl0u2hwsw.d(24): Error: undefined identifier `uniqs`

    /tmp/tmpl0u2hwsw.d(32): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0u2hwsw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    return words.max!((a, b) => a.length - b.length || a.compare(b))();\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn_g4drpe.d(19): Error: no property `max` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn_g4drpe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_word = words[0];\n    int max_num = 0;\n    int[]\
    \ arr;\n    foreach(elem; words)\n    {\n        //writeln(elem);\n        arr\
    \ = new int[256];\n        foreach(ch; elem)\n        {\n            //writeln(ch);\n\
    \            arr[ch] = 1;\n        }\n        int temp = 0;\n        foreach(e;\
    \ arr)\n        {\n            temp += e;\n        }\n        if(temp > max_num)\n\
    \        {\n            max_num = temp;\n            max_word = elem;\n      \
    \  }\n    }\n    return max_word;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgvkji8u1.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x42944d]

    ??:? void tmpgvkji8u1.__unittest_L44_C1() [0x4280aa]

    ??:? void tmpgvkji8u1.__modtest() [0x4286b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dfdb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4291a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aca5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ad34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ac31]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42917d]

    ??:? runModuleUnitTests [0x42ddb1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429910]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string[] split;\n    string max_string;\n    int[] count_arr;\n\
    \    int max_count;\n    foreach(string word; words)\n    {\n        split = split(word);\n\
    \        count_arr = [0];\n        foreach(string splitted; split)\n        {\n\
    \            if(splitted !in count_arr)\n            {\n                count_arr\
    \ ~= splitted;\n            }\n        }\n        if(max_count < count_arr.length)\n\
    \        {\n            max_count = count_arr.length;\n            max_string\
    \ = word;\n        }\n    }\n    return max_string;\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl0yh2tp2.d(25): Error: function expected before `()`, not `split`
    of type `string[]`

    /tmp/tmpl0yh2tp2.d(29): Error: incompatible types for `(splitted) in (count_arr)`:
    `string` and `int[]`

    /tmp/tmpl0yh2tp2.d(31): Error: cannot append type `string` to type `int[]`

    /tmp/tmpl0yh2tp2.d(36): Error: cannot implicitly convert expression `count_arr.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0yh2tp2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tstatic string res = \"\";\n\tstatic int max = 0;\n\tstatic int\
    \ res_length = 0;\n\tforeach(word; words)\n\t{\n\t\tint cur_length = 0;\n\t\t\
    char[] unique_chars = [];\n\t\tforeach(c; word)\n\t\t{\n\t\t\tif(!std.algorithm.contains(unique_chars,\
    \ c))\n\t\t\t{\n\t\t\t\tunique_chars ~= c;\n\t\t\t\tcur_length++;\n\t\t\t}\n\t\
    \t}\n\t\tif(cur_length > max)\n\t\t{\n\t\t\tmax = cur_length;\n\t\t\tres = word;\n\
    \t\t\tres_length = word.length;\n\t\t}\n\t\telse if(cur_length == max)\n\t\t{\n\
    \t\t\tif(word.length < res_length)\n\t\t\t{\n\t\t\t\tres = word;\n\t\t\t\tres_length\
    \ = word.length;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpogfwihqb.d(28): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpogfwihqb.d(38): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpogfwihqb.d(45): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogfwihqb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint[] counts;\n\tint pos = 0;\n\tforeach(string word; words) \n\
    \t{\n\t\tcounts ~= uniq(word).length;\n\t\tpos++;\n\t}\n\t\n\tint[] maxs = std.algorithm.maxElement(counts);\n\
    \t\n\tint index = maxs[0];\n\tint value = maxs[1];\n\t\n\tforeach(string word;\
    \ words) \n\t{\n\t\tif(uniq(word).length == value) \n\t\t{\n\t\t\tif(word.compare(words[index])\
    \ < 0)\n\t\t\t\tindex = pos;\n\t\t}\n\t\tpos++;\n\t}\n\t\n\treturn words[index];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv96jvdiw.d(23): Error: undefined identifier `uniq`

    /tmp/tmpv96jvdiw.d(27): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmpv96jvdiw.d(34): Error: undefined identifier `uniq`

    /tmp/tmpv96jvdiw.d(36): Error: no property `compare` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv96jvdiw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    ulong max = 0;\n    string max_str = \"\";\n    foreach(str;\
    \ words)\n    {\n        ulong cur = std.uniq(str).length;\n        if(cur > max)\n\
    \        {\n            max = cur;\n            max_str = str;\n        }\n  \
    \  }\n    return max_str;\n}\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9waeo2a9.d(23): Error: undefined identifier `uniq` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9waeo2a9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string[] dups = new string[];\n    string[] uniqs = new string[];\n\
    \    string[] check = new string[];\n    foreach(string s; words)\n    {\n   \
    \     foreach(char c; s)\n        {\n            check ~= to!string(c);\n    \
    \    }\n        check = set(check);\n        if(check.length == s.length)\n  \
    \      {\n            uniqs ~= s;\n        }\n        else\n        {\n      \
    \      dups ~= s;\n        }\n        check = [];\n    }\n    if(uniqs.length\
    \ == 0)\n    {\n        string min = dups[0];\n        foreach(string s; dups)\n\
    \        {\n            if(s.length < min.length)\n            {\n           \
    \     min = s;\n            }\n        }\n        return min;\n    }\n    else\n\
    \    {\n        string max = uniqs[0];\n        foreach(string s; uniqs)\n   \
    \     {\n            if(s.length > max.length)\n            {\n              \
    \  max = s;\n            }\n        }\n        return max;\n    }\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqoyc2vtr.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpqoyc2vtr.d(20): Error: new can only create structs, dynamic arrays or
    class objects, not `string[]`''s

    /tmp/tmpqoyc2vtr.d(21): Error: new can only create structs, dynamic arrays or
    class objects, not `string[]`''s

    /tmp/tmpqoyc2vtr.d(26): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpqoyc2vtr.d(28): Error: undefined identifier `set`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqoyc2vtr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    int index = 0;\n    for (int i = 0; i < words.length;\
    \ i++) \n    {\n        int count = 0;\n        for (int j = 0; j < words[i].length;\
    \ j++) \n        {\n            for (int k = j+1; k < words[i].length; k++) \n\
    \            {\n                if (words[i][j] == words[i][k])\n            \
    \        break;\n                if (k == words[i].length-1)\n               \
    \     count++;\n            }\n        }\n        if (count > max)\n        {\n\
    \            max = count;\n            index = i;\n        }\n    }\n    return\
    \ words[index];\n}\n/*\nWrite a function that accepts an array of integers.\n\
    \    The array can contain both negative and positive integers. Return the\n \
    \   contiguous subarray with the highest sum.\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcqj51518.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqj51518.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto max_unique = 0;\n    auto max_word = \"\";\n    foreach(word;\
    \ words)\n    {\n        auto num_unique = 0;\n        foreach(letter; word)\n\
    \        {\n            if(count(word, letter) == 1)\n            {\n        \
    \        num_unique++;\n            }\n        }\n        if(num_unique > max_unique)\n\
    \        {\n            max_unique = num_unique;\n            max_word = word;\n\
    \        }\n        else if(num_unique == max_unique)\n        {\n           \
    \ if(word < max_word)\n            {\n                max_word = word;\n     \
    \       }\n        }\n    }\n    return max_word;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb0peoh9s.d(26): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb0peoh9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tstring result;\n\tint nMaxCharacters = 0;\n\tforeach(word; words)\
    \ \n\t{\n\t\tint nCharacters = uniq(word).length;\n\t\tif(nCharacters > nMaxCharacters)\
    \ \n\t\t{\n\t\t\tnMaxCharacters = nCharacters;\n\t\t\tresult = word;\n\t\t}\n\t\
    }\n\treturn result;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf403yq_s.d(23): Error: undefined identifier `uniq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf403yq_s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // your code goes here\n    int max_len = 0;\n    int max_word\
    \ = 0;\n    int count = 0;\n    int flag = 0;\n    foreach(int i;0..words.length)\n\
    \    {\n        char[] tmp_char = words[i].dup;\n        sort(tmp_char);\n   \
    \     foreach(int j;1..tmp_char.length)\n        {\n            if(tmp_char[j]\
    \ == tmp_char[j-1])\n            {\n                flag = 1;\n              \
    \  break;\n            }\n        }\n        if(flag == 0)\n        {\n      \
    \      count++;\n            if(count > max_len)\n            {\n            \
    \    max_len = count;\n                max_word = i;\n            }\n        }\n\
    \        else\n        {\n            flag = 0;\n            count = 0;\n    \
    \    }\n    }\n    return words[max_word];\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy3pcdqu0.d(24): Error: cannot implicitly convert expression `words.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy3pcdqu0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max = \"\";\n    foreach(string s; words)\n    {\n  \
    \      if(s.length>max.length)\n        {\n            max = s;\n        }\n \
    \   }\n    return max;\n}\nunittest\n{\n    alias candidate = find_max;\n\n  \
    \  assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzk_el05y.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmpzk_el05y.__unittest_L29_C1() [0x427cc2]

    ??:? void tmpzk_el05y.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d93f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a87c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a779]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d715]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    assert(words.length >= 1);\n    string max_word = words[0];\n\
    \    foreach(word; words)\n    {\n        if(to_set(word).length > to_set(max_word).length)\n\
    \        {\n            max_word = word;\n        }\n        else if(to_set(word).length\
    \ == to_set(max_word).length)\n        {\n            max_word = min(word, max_word);\n\
    \        }\n    }\n    return max_word;\n}\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1r1io5pj.d(23): Error: undefined identifier `to_set`

    /tmp/tmp1r1io5pj.d(23): Error: undefined identifier `to_set`

    /tmp/tmp1r1io5pj.d(27): Error: undefined identifier `to_set`

    /tmp/tmp1r1io5pj.d(27): Error: undefined identifier `to_set`

    /tmp/tmp1r1io5pj.d(29): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1r1io5pj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // TODO\n    immutable result = \"\";\n    immutable resultCount\
    \ = 0;\n    foreach(i, w; words)\n    {\n        immutable uniqueLetters = set(w);\n\
    \        immutable count = uniqueLetters.length;\n        if(count > resultCount)\n\
    \        {\n            result = w;\n            resultCount = count;\n      \
    \  }\n        else if(count == resultCount)\n        {\n            if(w < result)\n\
    \            {\n                result = w;\n                resultCount = count;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\n    >>> find_min([\"\
    name\", \"of\", \"string\"])\n    \"name\"\n    >>> find_min([\"name\", \"enam\"\
    , \"game\"])\n    \"name\"\n    >>> find_min([\"aaaaaaa\", \"bb\", \"cc\"])\n\
    \    \"bb\"\n*/\nstring find_min(string[] words)\n{\n    // TODO\n    immutable\
    \ result = \"\";\n    immutable resultCount = 100;\n    foreach(i, w; words)\n\
    \    {\n        immutable uniqueLetters = set(w);\n        immutable count = uniqueLetters.length;\n\
    \        if(count < resultCount)\n        {\n            result = w;\n       \
    \     resultCount = count;\n        }\n        else if(count == resultCount)\n\
    \        {\n            if(w < result)\n            {\n                result\
    \ = w;\n                resultCount = count;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7p_9jx8a.d(24): Error: undefined identifier `set`, did you mean
    template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmp7p_9jx8a.d(28): Error: cannot modify `immutable` expression `result`

    /tmp/tmp7p_9jx8a.d(35): Error: cannot modify `immutable` expression `result`

    /tmp/tmp7p_9jx8a.d(57): Error: undefined identifier `set`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmp7p_9jx8a.d(61): Error: cannot modify `immutable` expression `result`

    /tmp/tmp7p_9jx8a.d(68): Error: cannot modify `immutable` expression `result`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7p_9jx8a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\treturn words.length == 0 ? \"\" : words.map!(a => a.histogram)\n\
    \t\t.reduce!((a, b) => a.length > b.length ? a : b)\n\t\t.idup\n\t\t.array\n\t\
    \t.map!(t => t[0])\n\t\t.joiner(\"\");\n}\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpram0xw0p.d(19): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpram0xw0p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\treturn [\"aaaaaaa\", \"bb\", \"cc\"].min();\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprv8mc5l9.d(19): Error: no property `min` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprv8mc5l9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string longest = \"\";\n    foreach(string word; words)\n  \
    \  {\n        if(maxUniqueChars(word) > maxUniqueChars(longest))\n        {\n\
    \            longest = word;\n        }\n    }\n    return longest;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplhdg1b4z.d(22): Error: undefined identifier `maxUniqueChars`

    /tmp/tmplhdg1b4z.d(22): Error: undefined identifier `maxUniqueChars`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplhdg1b4z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] unique_char = new int[words.length];\n    for (int i =\
    \ 0; i < words.length; i++)\n    {\n        foreach (char c; words[i])\n     \
    \   {\n            if (c == chomp(c))\n            {\n                ++unique_char[i];\n\
    \            }\n        }\n    }\n    return words[index_of_max(unique_char)];\n\
    }\n/*\nWrite a function that accepts a list of strings.\n    The function must\
    \ return a 2-tuple of strings.\n    The tuple must contain (1) the word with maximum\
    \ number of unique characters\n    and (2) the word with minimum number of unique\
    \ characters. \n    If multiple strings have maximum number of unique characters,\
    \ \n    return the one which comes first in lexicographical order.\n    If multiple\
    \ strings have minimum number of unique characters, \n    return the one which\
    \ comes last in lexicographical order.\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwuayv_m6.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwuayv_m6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string maxWord = \"\";\n    int maxChar = 0;\n    foreach(string\
    \ word; words) \n    {\n        int uniqueChar = 0;\n        foreach(char c; word)\n\
    \        {\n            if (count(word, c) == 1)\n            {\n            \
    \    uniqueChar++;\n            }\n        }\n        if (uniqueChar > maxChar)\n\
    \        {\n            maxChar = uniqueChar;\n            maxWord = word;\n \
    \       }\n        else if (uniqueChar == maxChar)\n        {\n            if\
    \ (word < maxWord)\n            {\n                maxWord = word;\n         \
    \   }\n        }\n    }\n    return maxWord;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcdq1xtj4.d(26): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcdq1xtj4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int unique_chars = 0;\n    int max_unique_chars = 0;\n    int\
    \ index = 0;\n    string result = \"\";\n    bool more_than_one = false;\n   \
    \ int last_max_index = 0;\n    foreach(i, e; words)\n    {\n        unique_chars\
    \ = 0;\n        foreach(j, letter; e)\n        {\n            if (e[j] != e[j\
    \ + 1])\n            {\n                unique_chars++;\n            }\n     \
    \   }\n        if (unique_chars > max_unique_chars)\n        {\n            max_unique_chars\
    \ = unique_chars;\n            last_max_index = index;\n            result = e;\n\
    \            more_than_one = false;\n        }\n        else if (unique_chars\
    \ == max_unique_chars)\n        {\n            more_than_one = true;\n       \
    \ }\n        index++;\n    }\n    if (more_than_one)\n    {\n        foreach(i,\
    \ e; words)\n        {\n            unique_chars = 0;\n            foreach(j,\
    \ letter; e)\n            {\n                if (e[j] != e[j + 1])\n         \
    \       {\n                    unique_chars++;\n                }\n          \
    \  }\n            if (unique_chars == max_unique_chars)\n            {\n     \
    \           result = e;\n                break;\n            }\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpzlax6vj9.d(30): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x429356]

    ??:? immutable(char)[] tmpzlax6vj9.find_max(immutable(char)[][]) [0x427bf1]

    ??:? void tmpzlax6vj9.__unittest_L69_C1() [0x427e28]

    ??:? void tmpzlax6vj9.__modtest() [0x42850c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dbf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ffe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aaa1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ab30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aa2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fd5]

    ??:? runModuleUnitTests [0x42d9c9]

    ??:? void rt.dmain2._d_run_main(int, char**, ext'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    struct Word\n    {\n        string text;\n        int unique_chars;\n\
    \    }\n    Word[] result;\n    foreach(word; words) \n    {\n        auto pos\
    \ = find(result, (w) => w.text == word);\n        if(pos.empty) \n        {\n\
    \            Word temp;\n            temp.text = word;\n            temp.unique_chars\
    \ = 0;\n            std.algorithm.uniq(word).length;\n            result ~= temp;\n\
    \        }\n    }\n    // return max(result, (w) => w.unique_chars).text;\n  \
    \  return max(result, (a, b) => (a.unique_chars == b.unique_chars) ? a.text <\
    \ b.text : a.unique_chars > b.unique_chars).text;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1tqbo6ge.d(27): Error: undefined identifier `find`, did you mean
    template `Bind(alias Template, args1...)`?

    /tmp/tmp1tqbo6ge.d(33): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp1tqbo6ge.d(38): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1tqbo6ge.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] counts = new int[words.length];\n    foreach(i, word;\
    \ words)\n    {\n        foreach(char ch; word)\n        {\n            if(ch\
    \ in word[0..i])\n                continue;\n            else\n              \
    \  counts[i] += 1;\n        }\n    }\n    int max_index = 0;\n    foreach(i, count;\
    \ counts)\n    {\n        if(count > counts[max_index])\n            max_index\
    \ = i;\n    }\n    return words[max_index];\n}\n// version 2\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string result = \"\";\n    foreach(word; words)\n\
    \    {\n        if(word.length > max)\n        {\n            result = word;\n\
    \            max = word.length;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp74wbc4iy.d(24): Error: incompatible types for `(ch) in (word[0..i])`:
    `char` and `string`

    /tmp/tmp74wbc4iy.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp74wbc4iy.d(48): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp74wbc4iy.d(57): Error: `tmp74wbc4iy.find_max` called with argument types
    `(string[])` matches both:

    /tmp/tmp74wbc4iy.d(17):     `tmp74wbc4iy.find_max(string[] words)`

    and:

    /tmp/tmp74wbc4iy.d(39):     `tmp74wbc4iy.find_max(string[] words)`

    /tmp/tmp74wbc4iy.d(58): Error: `tmp74wbc4iy.find_max` called with argument types
    `(string[])` matches both:

    /tmp/tmp74wbc4iy.d(17):     `tmp74wbc4iy.find_max(string[] words)`

    and:

    /tmp/tmp74wbc4iy.d(39):     `tmp74wbc4iy.find_max(string[] words)`

    /tmp/tmp74wbc4iy.d(59): Error: `tmp74wbc4iy.find_max` called with argument types
    `(string[])` matches both:

    /tmp/tmp74wbc4iy.d(17):     `tmp74wbc4iy.find_max(string[] words)`

    and:

    /tmp/tmp74wbc4iy.d(39):     `tmp74wbc4iy.find_ma'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string ret = words[0];\n    foreach(string w; words) \n    {\n\
    \        if(set_length(uniq(w)) > set_length(uniq(ret))) ret = w;\n    }\n   \
    \ return ret;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpunyt8o9z.d(22): Error: undefined identifier `set_length`

    /tmp/tmpunyt8o9z.d(22): Error: undefined identifier `set_length`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpunyt8o9z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result;\n    int num_unique;\n    int max_unique = 0;\n\
    \    foreach(word; words)\n    {\n        num_unique = uniq(word).length;\n  \
    \      if(num_unique > max_unique)\n        {\n            max_unique = num_unique;\n\
    \            result = word;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpst9ncxxc.d(24): Error: undefined identifier `uniq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpst9ncxxc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto result = \"\";\n    foreach(string word; words)\n    {\n\
    \        if(word.length > result.length)\n        {\n            result = word;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp50p5ofz2.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmp50p5ofz2.__unittest_L29_C1() [0x427cc2]

    ??:? void tmp50p5ofz2.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d93f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a87c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a779]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d715]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    \n    string res = \"\";\n    foreach(string word; words)\n\
    \    {\n        if(get_unique_char_count(word) > get_unique_char_count(res))\n\
    \        {\n            res = word;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3iqg4cp3.d(23): Error: undefined identifier `get_unique_char_count`

    /tmp/tmp3iqg4cp3.d(23): Error: undefined identifier `get_unique_char_count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3iqg4cp3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string word_with_max_unique_chars = \"\";\n    int max_unique_chars\
    \ = 0;\n    foreach(string word; words)\n    {\n        int[] checker = new int[256];\n\
    \        int unique_chars = 0;\n        foreach(char c; word)\n        {\n   \
    \         //index of c\n            int i = cast(int)c;\n            if(checker[i]\
    \ == 0)\n            {\n                checker[i] = 1;\n                unique_chars++;\n\
    \            }\n        }\n        if(unique_chars > max_unique_chars)\n     \
    \   {\n            max_unique_chars = unique_chars;\n            word_with_max_unique_chars\
    \ = word;\n        }\n    }\n    return word_with_max_unique_chars;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplap61ca6.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x429405]

    ??:? void tmplap61ca6.__unittest_L43_C1() [0x428066]

    ??:? void tmplap61ca6.__modtest() [0x428670]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42df93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42915e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ac5d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42acec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42abe9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429135]

    ??:? runModuleUnitTests [0x42dd69]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4298c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto temp = new string[];\n    string cmp;\n    string max_num;\n\
    \    int count = 0;\n    for (auto s; s in words) \n    {\n        if(count ==\
    \ 0) \n        {\n            count++;\n            max_num = s;\n           \
    \ continue;\n        }\n        if(count > 0) \n        {\n            count++;\n\
    \            if(max_num.length < s.length) \n            {\n                max_num\
    \ = s;\n            }\n        }\n    }\n    return max_num;\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4mfjvbgd.d(23): Error: no identifier for declarator `s`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4mfjvbgd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\t// pre-condition\n\tassert(words.length > 0);\n\t\n\tint max_count\
    \ = 0;\n\tstring max_word = \"\";\n\tforeach(word; words) \n\t{\n\t\timmutable\
    \ unique_chars = toSet(word);\n\t\tint count = unique_chars.length;\n\t\tif(count\
    \ > max_count) \n\t\t{\n\t\t\tmax_count = count;\n\t\t\tmax_word = word;\n\t\t\
    }\n\t\telse if(count == max_count) \n\t\t{\n\t\t\tmax_word = min(max_word, word);\n\
    \t\t}\n\t}\n\treturn max_word;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpscixyvtq.d(26): Error: undefined identifier `toSet`

    /tmp/tmpscixyvtq.d(35): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpscixyvtq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto max_word = \"\";\n    auto max_count = 0;\n    foreach(w;\
    \ words) \n    {\n        auto count = count_unique(w);\n        if (count > max_count)\
    \ \n        {\n            max_count = count;\n            max_word = w;\n   \
    \     }\n    }\n    return max_word;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcuv5w05n.d(23): Error: undefined identifier `count_unique`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcuv5w05n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int currentMax = words[0].length;\n    string currentMaxWord\
    \ = words[0];\n    string temp = \"\";\n    foreach(string word; words)\n    {\n\
    \        temp = uniq(word);\n        if(temp.length > currentMax)\n        {\n\
    \            currentMax = temp.length;\n            currentMaxWord = word;\n \
    \       }\n    }\n    return currentMaxWord;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp46cl1g8d.d(19): Error: cannot implicitly convert expression `words[0].length`
    of type `ulong` to `int`

    /tmp/tmp46cl1g8d.d(24): Error: undefined identifier `uniq`

    /tmp/tmp46cl1g8d.d(27): Error: cannot implicitly convert expression `temp.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp46cl1g8d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tsize_t max = 0;\n\tforeach(i, word; words)\n\t{\n\t\tmax = max(max,\
    \ word.length);\n\t}\n\t\n\tstring[] temp;\n\tforeach(i, word; words)\n\t{\n\t\
    \tif(word.length == max)\n\t\t{\n\t\t\ttemp ~= word;\n\t\t}\n\t}\n\t\n\tsize_t\
    \ unique = 0;\n\tforeach(i, word; temp)\n\t{\n\t\tforeach(j, sub_word; temp)\n\
    \t\t{\n\t\t\tif(sub_word == word)\n\t\t\t{\n\t\t\t\tunique++;\n\t\t\t}\n\t\t}\n\
    \t}\n\t\n\tif(unique > 1)\n\t{\n\t\tstd.sort.sort(temp);\n\t\treturn temp[0];\n\
    \t}\n\telse\n\t{\n\t\treturn temp[0];\n\t}\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbw1rz_5f.d(22): Error: function expected before `()`, not `max`
    of type `ulong`

    /tmp/tmpbw1rz_5f.d(48): Error: undefined identifier `sort` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbw1rz_5f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max_len = 0;\n    string best = \"\";\n    foreach(word;\
    \ words) \n    {\n        if (word.length > max_len) \n        {\n           \
    \ max_len = word.length;\n            best = word;\n        }\n    }\n    return\
    \ best;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyvwclwt7.d(25): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyvwclwt7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    size_t max_count = 0;\n    string max_word = \"\";\n    foreach(word;\
    \ words) \n    {\n        size_t count = 0;\n        // Create an empty set.\n\
    \        auto set = Appender!(std.typecons.Set!(char))();\n        foreach(ch;\
    \ word) \n        {\n            // Insert the char into the set.\n          \
    \  set.put(ch);\n        }\n        // Get the size of the set.\n        count\
    \ = set.data.length;\n        if(count > max_count) \n        {\n            max_count\
    \ = count;\n            max_word = word;\n        } \n        else if(count ==\
    \ max_count) \n        {\n            if(word < max_word) \n            {\n  \
    \              max_word = word;\n            }\n        }\n    }\n    return max_word;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu_6d2cv7.d(25): Error: template instance `Appender!(std.typecons.Set!char)`
    template `Appender` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu_6d2cv7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    uint max_unique = 0;\n    string max_unique_word = \"\";\n \
    \   foreach(string word; words)\n    {\n        dchar[] unique_chars = new dchar[0];\n\
    \        foreach(dchar c; word)\n        {\n            if(all!(dchar)(c !=)(unique_chars))\n\
    \            {\n                unique_chars ~= c;\n            }\n        }\n\
    \        uint unique_len = unique_chars.length;\n        if(unique_len > max_unique)\n\
    \        {\n            max_unique = unique_len;\n            max_unique_word\
    \ = word;\n        }\n        else if(unique_len == max_unique)\n        {\n \
    \           if(word < max_unique_word)\n            {\n                max_unique_word\
    \ = word;\n            }\n        }\n    }\n    return max_unique_word;\n}\n/*\n\
    Write a function that accepts a string. The string contains alphabets and\n  \
    \  numbers. Return a string where the order of characters are reversed, \n   \
    \ and uppercase characters are converted to lowercase and vice versa.\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0fync0ne.d(26): Error: expression expected, not `)`

    /tmp/tmp0fync0ne.d(27): Error: found `{` when expecting `)`

    /tmp/tmp0fync0ne.d(45): Error: declaration expected, not `return`

    /tmp/tmp0fync0ne.d(46): Error: unrecognized declaration

    /tmp/tmp0fync0ne.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0fync0ne.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    return words[maxIndex!((a, b) => \n    {\n        if (a.length\
    \ == b.length) \n        {\n            return a < b;\n        }\n        return\
    \ a.length < b.length;\n    })(map!((string x) => \n    {\n        return tuple(x,\
    \ set(x).length);\n    })(words))[1]];\n}\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7a1iegti.d(19): Error: template instance `maxIndex!((a, b) => ()

    {

    if (a.length == b.length)

    {

    return a < b;

    }

    return a.length < b.length;

    }

    )` template `maxIndex` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7a1iegti.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint longest;\n\tint i = 0;\n\tstring longestStr;\n\tforeach(string\
    \ s; words)\n\t{\n\t\tif(s.length > longest)\n\t\t{\n\t\t\tlongest = s.length;\n\
    \t\t\tlongestStr = s;\n\t\t}\n\t\t\n\t}\n\treturn longestStr;\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpva7k235z.d(26): Error: cannot implicitly convert expression `s.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpva7k235z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    int max_cnt = 0;\n    foreach(str;\
    \ words) \n    {\n        int cnt = unique_cnt(str);\n        if (cnt > max_cnt)\
    \ \n        {\n            max_cnt = cnt;\n            result = str;\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp10y7zo3t.d(23): Error: undefined identifier `unique_cnt`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp10y7zo3t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string ans = \"\";\n    uint ansLen = 0;\n    foreach(string\
    \ w; words) \n    {\n        auto uc = set(w.front)\n            .retro;\n   \
    \     auto ucLen = uc.length;\n        if (ucLen > ansLen || (ucLen == ansLen\
    \ && w < ans)) \n        {\n            ans = w;\n            ansLen = ucLen;\n\
    \        }\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpobg5qyds.d(23): Error: undefined identifier `set`, did you mean
    template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobg5qyds.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    auto result = \"\";\n    auto max_len = 0;\n    foreach(w; words)\n\
    \    {\n        if(w.length > max_len)\n        {\n            max_len = w.length;\n\
    \            result = w;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_qpsmqo_.d(25): Error: cannot implicitly convert expression `w.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_qpsmqo_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max = \"\";\n    foreach(w; words)\n    {\n        if(w.length\
    \ > max.length)\n        {\n            max = w;\n        }\n        else if(w.length\
    \ == max.length)\n        {\n            if(w > max)\n            {\n        \
    \        max = w;\n            }\n        }\n    }\n    return max;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp84ffpe8m.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmp84ffpe8m.__unittest_L36_C1() [0x427d5a]

    ??:? void tmp84ffpe8m.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a919]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9a8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8a5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d841]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max_word = \"\";\n    size_t[] count = new size_t[words.length];\n\
    \    for (size_t i = 0; i < words.length; i++)\n    {\n        // Filter the word\
    \ to only contain unique characters.\n        count[i] = uniq(words[i]).length;\n\
    \        if (count[i] > max_word.length)\n        {\n            max_word = words[i];\n\
    \        }\n    }\n    return max_word;\n}\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfck7y98f.d(24): Error: undefined identifier `uniq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfck7y98f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string winner = words[0];\n    int max_chars = winner.length;\n\
    \    foreach(word; words)\n    {\n        if(winner.length < word.length)\n  \
    \      {\n            winner = word;\n            max_chars = winner.length;\n\
    \        }\n        else if(winner.length == word.length)\n        {\n       \
    \     if(winner.compare(word) > 0)\n            {\n                winner = word;\n\
    \                max_chars = winner.length;\n            }\n        }\n    }\n\
    \    return winner;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphk980jkj.d(20): Error: cannot implicitly convert expression `winner.length`
    of type `ulong` to `int`

    /tmp/tmphk980jkj.d(26): Error: cannot implicitly convert expression `winner.length`
    of type `ulong` to `int`

    /tmp/tmphk980jkj.d(30): Error: no property `compare` for type `string`

    /tmp/tmphk980jkj.d(33): Error: cannot implicitly convert expression `winner.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphk980jkj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string res;\n    size_t max_unique = 0;\n    foreach(string\
    \ word; words)\n    {\n        size_t unique_num = 0;\n        foreach(c; word)\n\
    \        {\n            if (word.count(c) == 1)\n                unique_num++;\n\
    \        }\n        if (unique_num > max_unique)\n        {\n            max_unique\
    \ = unique_num;\n            res = word;\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyhgmnhhe.d(26): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyhgmnhhe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    import std.algorithm: max, reduce;\n    import std.array: array;\n\
    \    auto max_len = words.max!((a, b) => a.length < b.length);\n    string result\
    \ = max_len;\n    foreach (word; words)\n    {\n        if (word.length == max_len.length)\n\
    \        {\n            if (word.reduce!((a, b) => a ~ b).array.uniq.length >\
    \ max_len.reduce!((a, b) => a ~ b).array.uniq.length)\n            {\n       \
    \         result = word;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa3cvpnfe.d(21): Error: template instance `tmpa3cvpnfe.find_max.max!((a,
    b) => a.length < b.length)` does not match template declaration `max(T...)(T args)
    if (T.length >= 2)`

    /tmp/tmpa3cvpnfe.d(27): Error: incompatible types for `(cast(uint)a) ~ (cast(uint)b)`:
    both operands are of type `uint`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/meta.d(803):        instantiated
    from here: `F!(__lambda3)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(2843):        instantiated
    from here: `staticMap!(ReduceSeedType, __lambda3)`

    /tmp/tmpa3cvpnfe.d(27):        instantiated from here: `reduce!string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa3cvpnfe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string str1 = \"\";\n    foreach(a; words) \n    {\n       \
    \ if(a.length > str1.length) \n        {\n            str1 = a;\n        }\n \
    \   }\n    return str1;\n}\nunittest\n{\n    alias candidate = find_max;\n\n \
    \   assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzlsbbw78.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmpzlsbbw78.__unittest_L29_C1() [0x427cc2]

    ??:? void tmpzlsbbw78.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d93f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a87c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a779]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d715]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    enum max_word;\n    foreach(word; words)\n    {\n        string[]\
    \ word_uniq;\n        foreach(char; word)\n        {\n            if(!word_uniq.canFind(cast(string)char))\n\
    \            {\n                word_uniq ~= cast(string)char;\n            }\n\
    \        }\n        if(word_uniq.length > max_word.length)\n        {\n      \
    \      max_word = word;\n        }\n    }\n    return max_word;\n}\n/*\nWrite\
    \ a function that accepts two inputs, array of strings and a substring.\nThe function\
    \ returns the number of times the substring appears in the array of strings.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxniy6ndi.d(23): Error: no identifier for declarator `char`

    /tmp/tmpxniy6ndi.d(25): Error: found `)` when expecting `.` following char

    /tmp/tmpxniy6ndi.d(25): Error: found `)` when expecting identifier following `char`.

    /tmp/tmpxniy6ndi.d(26): Error: found `{` when expecting `,`

    /tmp/tmpxniy6ndi.d(27): Error: found `;` when expecting `.` following char

    /tmp/tmpxniy6ndi.d(28): Error: found `}` when expecting identifier following `char`.

    /tmp/tmpxniy6ndi.d(29): Error: found `}` when expecting `,`

    /tmp/tmpxniy6ndi.d(30): Error: expression expected, not `if`

    /tmp/tmpxniy6ndi.d(31): Error: found `{` when expecting `,`

    /tmp/tmpxniy6ndi.d(32): Error: found `;` when expecting `,`

    /tmp/tmpxniy6ndi.d(33): Error: expression expected, not `}`

    /tmp/tmpxniy6ndi.d(34): Error: found `}` when expecting `,`

    /tmp/tmpxniy6ndi.d(35): Error: expression expected, not `return`

    /tmp/tmpxniy6ndi.d(35): Error: found `max_word` when expecting `,`

    /tmp/tmpxniy6ndi.d(35): Error: expression expected, not `;`

    /tmp/tmpxniy6ndi.d(36): '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    import std.string : toHash;\n    auto max = 0;\n    auto result\
    \ = null;\n    foreach(index, word; words)\n    {\n        if(word.toHash.length\
    \ > max)\n        {\n            max = word.toHash.length;\n            result\
    \ = word;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7bi6j3ks.d(19): Error: module `std.string` import `toHash` not
    found

    /tmp/tmp7bi6j3ks.d(27): Error: cannot implicitly convert expression `word` of
    type `string` to `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7bi6j3ks.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
