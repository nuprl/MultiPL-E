language: d
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    while(decimal > 0)\n    {\n        int i = decimal\
    \ % 2;\n        binary ~= i.to!string;\n        decimal /= 2;\n    }\n    binary\
    \ ~= \"db\";\n    return binary.dup.reverse;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplrdemz3a.d(24): Error: no property `to` for type `int`

    /tmp/tmplrdemz3a.d(28): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplrdemz3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\n\
    \tstring s = \"db\";\n\treturn s + to!string(decimal,2) + \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4m3o595c.d(22): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4m3o595c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" ~ to!string(decimal, 2) ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvjk9qbdj.d(20): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvjk9qbdj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    while(decimal > 0) {\n        if(decimal % 2 ==\
    \ 0) {\n            result = \"0\" ~ result;\n        } else {\n            result\
    \ = \"1\" ~ result;\n        }\n        decimal /= 2;\n    }\n    return result\
    \ ~ \"db\";\n}\n/*\n    >>>decimal_to_binary(15L)\n    \"db1111db\"\n    >>>decimal_to_binary(32L)\n\
    \    \"db100000db\"\n*/\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp15l2ffe3.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f75]

    ??:? void tmp15l2ffe3.__unittest_L37_C1() [0x427b85]

    ??:? void tmp15l2ffe3.__modtest() [0x427cf8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd67]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ac76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc45]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbd1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac4d]

    ??:? runModuleUnitTests [0x42bb3d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  int size = log(decimal)/log(2) + 1;\n    char[] result = new char[size];\n\
    \    result[] = '0';\n    for (int i = size - 1; i >= 0; i--)\n    {\n       \
    \ result[i] = (decimal & 1) ? '1' : '0';\n        decimal >>= 1;\n    }\n    return\
    \ \"db\" ~ result.idup ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81aguz8g.d(20): Error: cannot implicitly convert expression `log(cast(real)decimal)
    / log(2.00000L) + 1.00000L` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81aguz8g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ret;\n    ret ~= \"db\";\n    if (decimal==0) {\n        ret ~= \"0\"\
    ;\n    } else {\n        while (decimal!=0) {\n            ret ~= cast(string)(decimal%2);\n\
    \            decimal/=2;\n        }\n    }\n    ret ~= \"db\";\n    return std.algorithm.reverse(ret);\n\
    }\n/*\nYou will be given a string in binary format, and your task is to convert\
    \ it to\n    decimal format. The function should return a long number, that represents\
    \ the decimal\n    representation of the given binary string.\nunittest\n{\n \
    \   alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8wuyknop.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wuyknop.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  import std.string : to;\n    import std.conv : to;\n    import std.format :\
    \ format;\n    string s = \"\";\n    if (decimal == 0)\n        return \"db0db\"\
    ;\n    else\n    {\n        foreach(i; 0..64)\n        {\n            if (decimal\
    \ & (1L << i))\n                s ~= \"1\";\n            else\n              \
    \  s ~= \"0\";\n        }\n        //removing left zeros\n        while (s[$-1]\
    \ == '0')\n            s = s[0..$-1];\n        //adding db at the beginning and\
    \ the end\n        s = \"db\" ~ s.reverse ~ \"db\";\n        return s;\n    }\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm_r5wh1x.d(20): Error: module `std.string` import `to` not found,
    did you mean alias `std.string.No`?

    /tmp/tmpm_r5wh1x.d(39): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm_r5wh1x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  if (decimal < 0) return \"\";\n    string result = \"db\";\n    while (decimal\
    \ > 0) {\n        result += (decimal % 2 == 0) ? \"0\" : \"1\";\n        decimal\
    \ /= 2;\n    }\n    return result ~ \"db\";\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7mjnammk.d(23): Error: slice `result` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7mjnammk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    const int [] base = [ 1, 2, 4, 8, 16, 32, 64, 128, 256,\
    \ 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576,\
    \ 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456,\
    \ 536870912, 1073741824 ];\n    int size = base.length;\n    foreach(int i; 0..size)\n\
    \    {\n        if(decimal == 0)\n            break;\n        else if(decimal\
    \ >= base[i])\n        {\n            decimal -= base[i];\n            result\
    \ ~= \"1\";\n        }\n        else\n            result ~= \"0\";\n    }\n  \
    \  return \"db\" ~ result ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg002uiwv.d(22): Error: cannot implicitly convert expression `base.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg002uiwv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    enum {binary, octal, hexadecimal} num_type;\n\tnum_type = binary;\n\tstring[]\
    \ prefixes = { \"db\", \"ob\", \"ox\", \"x\" };\n\tstring prefix = prefixes[num_type];\n\
    \tchar[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b',\
    \ 'c', 'd', 'e', 'f' };\n\tstring res = \"\";\n\twhile (decimal != 0) {\n\t\t\
    res = digits[decimal % 16] ~ res;\n\t\tdecimal /= 16;\n\t}\n\tres = prefix ~ res\
    \ ~ prefix;\n\treturn res;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeszyjx1i.d(20): Error: undefined identifier `num_type`

    /tmp/tmpeszyjx1i.d(21): Error: undefined identifier `num_type`

    /tmp/tmpeszyjx1i.d(22): Error: a struct is not a valid initializer for a `string[]`

    /tmp/tmpeszyjx1i.d(23): Error: undefined identifier `num_type`

    /tmp/tmpeszyjx1i.d(24): Error: a struct is not a valid initializer for a `char[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeszyjx1i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  char[]\
    \ binary = new char[32];\n  int start = 0;\n  int end = binary.length - 1;\n \
    \ for (long i = 0; i < binary.length; i++)\n  {\n    long bit = decimal % 2;\n\
    \    decimal /= 2;\n    binary[start] = (bit == 0) ? '0' : '1';\n    binary[end]\
    \ = binary[start];\n    start++;\n    end--;\n  }\n  return format(\"db%sdb\"\
    , binary);\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzzn1eagh.d(22): Error: cannot implicitly convert expression `binary.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpzzn1eagh.d(32): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzzn1eagh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string s=\"db\";\n    while(decimal>0)\n    {\n        s+=to!string(decimal%2);\n\
    \        decimal/=2;\n    }\n    reverse(s.length-1);\n    s+=\"db\";\n    return\
    \ s;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpijwfbh2g.d(23): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpijwfbh2g.d(26): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(ulong)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmpijwfbh2g.d(27): Error: slice `s` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpijwfbh2g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto result = \"db\";\n    while (decimal > 0)\n    {\n        if (decimal\
    \ % 2 == 0)\n            result ~= \"0\";\n        else\n            result ~=\
    \ \"1\";\n        decimal /= 2;\n    }\n    result ~= \"db\";\n    return result.dup.idup.rev;\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp39ob92gz.d(30): Error: no property `rev` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp39ob92gz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    if (decimal == 0)\n        return binary + \"\
    0\" + binary;\n    while (decimal > 0)\n    {\n        binary += \"1\";\n    \
    \    decimal -= pow(2L, find(decimal));\n    }\n    binary += \"db\";\n    return\
    \ binary;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgj3u5b3.d(22): Error: invalid array operation `binary + "0"` (possible
    missing [])

    /tmp/tmpwgj3u5b3.d(25): Error: slice `binary` is not mutable

    /tmp/tmpwgj3u5b3.d(26): Error: undefined identifier `find`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmpwgj3u5b3.d(28): Error: slice `binary` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwgj3u5b3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    binary ~= \"db\";\n    while(decimal >= 1)\n    {\n   \
    \     if(decimal % 2 == 0)\n        {\n            binary ~= \"0\";\n        }\n\
    \        else\n        {\n            binary ~= \"1\";\n        }\n        decimal\
    \ /= 2;\n    }\n    binary ~= \"db\";\n    return binary;\n}\n/*\nYou will be\
    \ given a string of binary numbers. Your task is to write a function which converts\n\
    \    it to a decimal number.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4xwgj3tr.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xwgj3tr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto str = to!string(decimal);\n    int[] result = new int[str.length];\n \
    \   int i = 0;\n    while (decimal > 0)\n    {\n        result[i] = decimal %\
    \ 2;\n        decimal /= 2;\n        i++;\n    }\n    string str2 = \"db\";\n\
    \    for (int j = result.length - 1; j >= 0; j--)\n    {\n        str2 ~= result[j];\n\
    \    }\n    str2 ~= \"db\";\n    return str2;\n}\n \n/*\nYou are in a life or\
    \ death situation and a mysterious wise man gives you the following riddle:\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3o4xkxpd.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3o4xkxpd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  if (decimal == 0)\n        return \"db0db\";\n    \n    enum binaryLength =\
    \ to!uint(ceil(log(decimal)/log(2)));\n    string binary = \"db\";\n    binary.length\
    \ = binaryLength + 4;\n    binary[1 .. $ - 2] = '0';\n    binary[$ - 1] = 'd';\n\
    \    binary[$ - 2] = 'b';\n    \n    while (decimal != 0)\n    {\n        immutable\
    \ remainder = cast(char)(decimal % 2);\n        if (remainder == 1)\n        \
    \    binary[binaryLength] = '1';\n        else\n            binary[binaryLength]\
    \ = '0';\n        decimal /= 2;\n        binaryLength--;\n    }\n    return binary;\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp718d3sxl.d(23): Error: template instance `to!uint` template `to`
    is not defined, did you mean No?

    /tmp/tmp718d3sxl.d(26): Error: slice `binary[1..__dollar - 2LU]` is not mutable

    /tmp/tmp718d3sxl.d(27): Error: cannot modify `immutable` expression `binary[__dollar
    - 1LU]`

    /tmp/tmp718d3sxl.d(28): Error: cannot modify `immutable` expression `binary[__dollar
    - 2LU]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp718d3sxl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  enum type_symbol_long : long \n    {\n        zero = 0L,\n        one = 1L,\n\
    \        two = 2L,\n        three = 3L,\n        four = 4L,\n        five = 5L,\n\
    \        six = 6L,\n        seven = 7L,\n        eight = 8L,\n        nine = 9L,\n\
    \        ten = 10L,\n        eleven = 11L,\n        twelve = 12L,\n        thirteen\
    \ = 13L,\n        fourteen = 14L,\n        fifteen = 15L,\n        sixteen = 16L,\n\
    \        seventeen = 17L,\n        eighteen = 18L,\n        nineteen = 19L,\n\
    \        twenty = 20L,\n        thirty = 30L,\n        forty = 40L,\n        fifty\
    \ = 50L,\n        sixty = 60L,\n        seventy = 70L,\n        eighty = 80L,\n\
    \        ninety = 90L,\n        hundred = 100L,\n        thousand = 1000L,\n \
    \       million = 1000000L,\n        billion = 1000000000L,\n        trillion\
    \ = 1000000000000L,\n        quadrillion = 1000000000000000L,\n        quintillion\
    \ = 1000000000000000000L,\n        sextillion = 1000000000000000000000L,\n   \
    \     septillion = 1000000000000000000000000L,\n        octillion = 1000000000000000000000000000L,\n\
    \        nonillion = 1000000000000000000000000000000L,\n        decillion = 1000000000000000000000000000000000L,\n\
    \        undecillion = 1000000000000000000000000000000000000L,\n        duodecillion\
    \ = 1000000000000000000000000000000000000000L,\n        tredecillion = 1000000000000000000000000000000000000000000L,\n\
    \        quattuordecillion = 1000000000000000000000000000000000000000000000L,\n\
    \        quindecillion = 1000000000000000000000000000000000000000000000000000L,\n\
    \        sexdecillion = 1000000000000000000000000000000000000000000000000000000L,\n\
    \        septendecillion = 1000000000000000000000000000000000000000000000000000000000L,\n\
    \        octodecillion = 10000000000000000000000000000000000000000000000000000000000000L,\n\
    \        novemdecillion = 10000000000000000000000000000000000000000000000000000000000000000L,\n\
    \        vigintillion = 100000000000000000000000000000000000000000000000000000000000000000000000L,\n\
    \        centillion = 1000000000000000000000000000000000000000000000000000000000000000000000000000000L,\n\
    \    };\n    string binary = \"db\";\n    for (int i = 1; i < 64; i++)\n    {\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4c52t9fl.d(57): Error: integer overflow

    /tmp/tmp4c52t9fl.d(58): Error: integer overflow

    /tmp/tmp4c52t9fl.d(59): Error: integer overflow

    /tmp/tmp4c52t9fl.d(60): Error: integer overflow

    /tmp/tmp4c52t9fl.d(61): Error: integer overflow

    /tmp/tmp4c52t9fl.d(62): Error: integer overflow

    /tmp/tmp4c52t9fl.d(63): Error: integer overflow

    /tmp/tmp4c52t9fl.d(64): Error: integer overflow

    /tmp/tmp4c52t9fl.d(65): Error: integer overflow

    /tmp/tmp4c52t9fl.d(66): Error: integer overflow

    /tmp/tmp4c52t9fl.d(67): Error: integer overflow

    /tmp/tmp4c52t9fl.d(68): Error: integer overflow

    /tmp/tmp4c52t9fl.d(69): Error: integer overflow

    /tmp/tmp4c52t9fl.d(70): Error: integer overflow

    /tmp/tmp4c52t9fl.d(71): Error: integer overflow

    /tmp/tmp4c52t9fl.d(72): Error: integer overflow

    /tmp/tmp4c52t9fl.d(73): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp4c52t9fl.d(77): Error: found `unittest` instead of statement

    /tmp/tmp4c52t9fl.d(86): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ['
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    while(decimal != 0)\n    {\n        if(decimal\
    \ % 2 == 0)\n            binary = \"0\" ~ binary;\n        else\n            binary\
    \ = \"1\" ~ binary;\n        decimal /= 2;\n    }\n    return binary ~ \"db\"\
    ;\n}\n/*\nYou will be given a list of digits in the form of a string, your task\
    \ is to add the digits up and return\n    the result. The input will be in the\
    \ form of a string, and the output should be an integer.\n    Examples:\n    >>>\
    \ add_digits(\"1234\")\n    10\n    >>> add_digits(\"423\")\n    9\n*/\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppyjlf04v.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f75]

    ??:? void tmppyjlf04v.__unittest_L40_C1() [0x427b85]

    ??:? void tmppyjlf04v.__modtest() [0x427cf8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd67]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ac76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc45]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbd1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac4d]

    ??:? runModuleUnitTests [0x42bb3d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto binary = typeof(decimal)();\n    while (decimal != 0) \n    {\n      \
    \  binary.insertFront(decimal % 2);\n        decimal /= 2;\n    }\n    return\
    \ \"db\" ~ binary.text ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8t_bkpxd.d(23): Error: no property `insertFront` for type `long`

    /tmp/tmp8t_bkpxd.d(26): Error: no property `text` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8t_bkpxd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" ~ format(\"%b\",decimal) ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph2w7prky.d(20): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2w7prky.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" ~ to!string(decimal,2) ~ \"db\";\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr2xy4h_x.d(20): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr2xy4h_x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  int list_of_ones_and_zeros[] = new int[128];\n    int array_index = 0;\n  \
    \  int quotient;\n    int remainder;\n    string final_binary_string = \"db\"\
    ;\n    while(decimal > 0)\n    {\n        quotient = decimal / 2;\n        remainder\
    \ = decimal % 2;\n        list_of_ones_and_zeros[array_index] = remainder;\n \
    \       array_index++;\n        decimal = quotient;\n    }\n    for(int i = array_index-1;\
    \ i >= 0; i--)\n    {\n        final_binary_string ~= list_of_ones_and_zeros[i];\n\
    \    }\n    final_binary_string ~= \"db\";\n    return final_binary_string;\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppn91jdzi.d(20): Deprecation: instead of C-style syntax, use D-style
    syntax `int[] list_of_ones_and_zeros`

    /tmp/tmppn91jdzi.d(27): Error: cannot implicitly convert expression `decimal /
    2L` of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppn91jdzi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    string binary = \"db\";\n\tstring binary_reversed = \"\";\n\tif (decimal == 0)\n\
    \t{\n\t\tbinary_reversed = \"0\";\n\t}\n\telse\n\t{\n\t\twhile (decimal > 0)\n\
    \t\t{\n\t\t\tbinary_reversed ~= decimal % 2;\n\t\t\tdecimal /= 2;\n\t\t}\n\t}\n\
    \treturn binary ~ binary_reversed.\n\treverse.\n\tidup.\n\t\"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplkmb80za.d(37): Error: identifier expected following `.`, not `"db"`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplkmb80za.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return (decimal == 0 ? \"db0db\" : \"db\" ~ split(decimal.representation(2L),\
    \ \"0\")\n                                            .map!(x => \"1\" ~ \"0\"\
    (x.length - 1))\n                                            .join(\"\")\n   \
    \                                         .dropRight(1)\n                    \
    \                        .join(\"\")\n                                       \
    \     .dropRight(1)\n                                            .reverse()\n\
    \                                            .join(\"\")\n                   \
    \                         .reverse()\n                                       \
    \     .join(\"\")\n                                            .dropRight(1)\n\
    \                                            .join(\"\")\n                   \
    \                         .dropRight(1)\n                                    \
    \        .reverse()\n                                            .join(\"\")\n\
    \                                            .reverse()\n                    \
    \                        .join(\"\")\n                                       \
    \     .dropRight(1)\n                                            .join(\"\")\n\
    \                                            .dropRight(1)\n                 \
    \                           .reverse()\n                                     \
    \       .join(\"\")\n                                            .reverse()\n\
    \                                            .join(\"\")\n                   \
    \                         .dropRight(1)\n                                    \
    \        .join(\"\")\n                                            .dropRight(1)\n\
    \                                            .reverse()\n                    \
    \                        .join(\"\")\n                                       \
    \     .reverse()\n                                            .join(\"\")\n  \
    \                                          .dropRight(1)\n                   \
    \                         .join(\"\")\n                                      \
    \      .dropRight(1)\n                                            .reverse()\n\
    \                                            .join(\"\")\n                   \
    \                         .reverse()\n                                       \
    \     .join(\"\")\n                                            .dropRight(1)\n\
    \                                            .join(\"\")\n                   \
    \                         .dropRight(1)\n                                    \
    \        .reverse()\n                                            .join(\"\")\n\
    \                                            .reverse()\n                    \
    \                        .join(\"\")\n                                       \
    \     .dropRight(1)\n                                            .join(\"\")\n\
    \                                            .dropRight(1)\n                 \
    \                           .reverse()\n                                     \
    \       .join(\"\")\n                                            .reverse()\n\
    \                                            .join(\"\")\n                   \
    \                         .dropRight(1)\n                                    \
    \        .join(\"\")\n                                            .dropRight(1)\n\
    \                                            .reverse()\n                    \
    \                       \nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz1lt2e26.d(20): Error: found `unittest` when expecting `)`

    /tmp/tmpz1lt2e26.d(78): Error: found `{` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz1lt2e26.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    string str;\n\tstr ~= \"db\";\n\tstr ~= decimal.to!string();\n\tstr ~= \"db\"\
    ;\n\treturn str;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n\
    \    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_f3mhls.d(22): Error: no property `to` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_f3mhls.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    int n = cast(int) decimal;\n    int i = 0;\n    bool bit;\n\
    \    for (i = 0; n > 0; i++)\n    {\n        bit = n % 2;\n        n = n/2;\n\
    \        binary ~= bit ? \"1\" : \"0\";\n    }\n    return binary;\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkdgt5rin.d(26): Error: cannot implicitly convert expression `n
    % 2` of type `int` to `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkdgt5rin.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  enum bits = 64;\n    // extend to 64bit\n    decimal = to!(ulong)(decimal);\n\
    \    string result = \"db\";\n    while(decimal)\n    {\n        result ~= decimal\
    \ % 2;\n        decimal /= 2;\n    }\n    // extend to 64bit\n    result ~= \"\
    0000000000000000000000000000000000000000000000000000000000000000db\";\n    return\
    \ result[$-bits..$];\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbglf7m6f.d(22): Error: template instance `to!ulong` template `to`
    is not defined, did you mean No?

    /tmp/tmpbglf7m6f.d(26): Error: cannot append type `long` to type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbglf7m6f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  bool up = true;\n    int length = 0;\n    if (decimal < 0L) {\n        decimal\
    \ = -decimal;\n        up = false;\n    }\n    int c = 0;\n    string result =\
    \ \"\";\n    while (decimal >= pow(2, c)) {\n        ++c;\n    }\n    result =\
    \ \"0\" ~ result;\n    while (--c >= 0) {\n        if (decimal >= pow(2, c)) {\n\
    \            result = \"1\" ~ result;\n            decimal -= pow(2, c);\n   \
    \     } else {\n            result = \"0\" ~ result;\n        }\n    }\n    return\
    \ \"db\" ~ result ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi2ll67zo.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x4280d5]

    ??:? void tmpi2ll67zo.__unittest_L42_C1() [0x427c9e]

    ??:? void tmpi2ll67zo.__modtest() [0x427e58]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bec7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42add6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fda5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430254]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fd31]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42adad]

    ??:? runModuleUnitTests [0x42bc9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428524]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto binary = to!string(decimal, 2);\n    return \"db\" ~ binary ~ \"db\";\n\
    }\n/*\n    Write a function that converts a binary number to decimal format. The\
    \ function should take\n    string as an argument and return a number as a result.\
    \ The string will be of length\n    1, 10, 32 or 64, so it will be a very small\
    \ number.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6a7ztwhz.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6a7ztwhz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    if (decimal==0)\n        return binary+'0'+'db';\n\
    \    while (decimal!=0)\n    {\n        binary+=to!string(decimal%2);\n      \
    \  decimal/=2;\n    }\n    reverse(binary.ptr+2,binary.ptr+binary.length);\n \
    \   return binary+'db';\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi30c5mfm.d(22): Error: unterminated character constant

    /tmp/tmpi30c5mfm.d(22): Error: found `b` when expecting `;` following `return`
    statement

    /tmp/tmpi30c5mfm.d(22): Error: unterminated character constant

    /tmp/tmpi30c5mfm.d(23): Error: found `while` when expecting `;` following statement

    /tmp/tmpi30c5mfm.d(23): Error: found `!=` when expecting `)`

    /tmp/tmpi30c5mfm.d(23): Error: missing `{ ... }` for function literal

    /tmp/tmpi30c5mfm.d(23): Error: found `0` when expecting `;` following statement

    /tmp/tmpi30c5mfm.d(23): Error: found `)` instead of statement

    /tmp/tmpi30c5mfm.d(28): Error: unexpected `(` in declarator

    /tmp/tmpi30c5mfm.d(28): Error: found `+` when expecting `)`

    /tmp/tmpi30c5mfm.d(28): Error: no identifier for declarator `reverse(binary.ptr)`

    /tmp/tmpi30c5mfm.d(28): Error: semicolon expected following function declaration

    /tmp/tmpi30c5mfm.d(28): Error: declaration expected, not `2`

    /tmp/tmpi30c5mfm.d(29): Error: declaration expected, not `return`

    /tmp/tmpi30c5mfm.d(29): Error: unterminate'
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  long result = decimal;\n    string result2 = \"\";\n    result2 += \"db\";\n\
    \    for(int i = 0; i < decimal; i++)\n    {\n        if(result % 2 == 0)\n  \
    \      {\n            result2 += \"0\";\n        }\n        else\n        {\n\
    \            result2 += \"1\";\n        }\n        result /= 2;\n    }\n    result2\
    \ += \"db\";\n    return result2;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsjrbqb7g.d(22): Error: slice `result2` is not mutable

    /tmp/tmpsjrbqb7g.d(27): Error: slice `result2` is not mutable

    /tmp/tmpsjrbqb7g.d(31): Error: slice `result2` is not mutable

    /tmp/tmpsjrbqb7g.d(35): Error: slice `result2` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsjrbqb7g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string s = \"db\";\n    if (decimal == 0)\n        return s + \"0\" + s;\n\
    \    while (decimal > 0) {\n        s += (decimal & 1) ? \"1\" : \"0\";\n    \
    \    decimal >>= 1;\n    }\n    reverse(s.begin(), s.end());\n    return s + \"\
    db\";\n}\n/*\nYou will be given a number in binary format and your task is to\
    \ convert it to\n    decimal format. The function should return a string, with\
    \ each character representing a decimal\n    number.\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ee2j_ji.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ee2j_ji.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // Your code goes here\n    /*\n        - Step 1: Get an array of the numbers\
    \ in reverse order\n            - Use % 2\n        - Step 2: Turn array into a\
    \ string\n            - Use an array of char, since that's what strings use\n\
    \            - foreach(n; a)\n        - Step 3: Return formatted string\n    */\n\
    \    import std.algorithm : reverse;\n    import std.conv : to;\n    import std.string\
    \ : join;\n    auto base = 2;\n    long dividend = decimal;\n    auto[dividend_,\
    \ remainder] = divMod(dividend, base);\n    auto digits = new char[1];\n    digits[0]\
    \ = to!char(remainder);\n    while(dividend_ > 0) {\n        auto[dividend__,\
    \ remainder_] = divMod(dividend_, base);\n        digits ~= to!char(remainder_);\n\
    \        dividend_ = dividend__;\n    }\n    string bin = digits.reverse.join(\"\
    \");\n    return \"db\" ~ bin ~ \"db\";\n}\nunittest\n{\n    alias candidate =\
    \ decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj7a9yatx.d(34): Error: basic type expected, not `[`

    /tmp/tmpj7a9yatx.d(34): Error: found `,` when expecting `]`

    /tmp/tmpj7a9yatx.d(34): Error: semicolon expected, not `]`

    /tmp/tmpj7a9yatx.d(34): Error: found `]` instead of statement

    /tmp/tmpj7a9yatx.d(38): Error: basic type expected, not `[`

    /tmp/tmpj7a9yatx.d(38): Error: found `,` when expecting `]`

    /tmp/tmpj7a9yatx.d(38): Error: semicolon expected, not `]`

    /tmp/tmpj7a9yatx.d(38): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj7a9yatx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  import std.math;\n    string binary = to!string(decimal, 2);\nunittest\n{\n\
    \    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5h3c0pb7.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5h3c0pb7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ret;\n    foreach(idx; 0 .. 64)\n    {\n        ret ~= \"db\";\n   \
    \     ret ~= (decimal & (1 << idx)) != 0 ? \"1\" : \"0\";\n    }\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpewc_ztnn.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f3d]

    ??:? void tmpewc_ztnn.__unittest_L28_C1() [0x427b4d]

    ??:? void tmpewc_ztnn.__modtest() [0x427cc0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c683]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b592]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42feb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430368]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fe45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]

    ??:? runModuleUnitTests [0x42c459]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42838c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string s = \"db\";\n    long n = decimal;\n    while(n>0) {\n        long remainder\
    \ = n%2;\n        n /= 2;\n        s = s + to!string(remainder);\n    }\n    reverse(s);\n\
    \    s = s ~ \"db\";\n    return s;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvjh9anke.d(25): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpvjh9anke.d(27): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvjh9anke.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string myStr = \"db\";\n    if (decimal == 0) return \"db0db\";\n    while\
    \ (decimal > 0)\n    {\n        myStr ~= to!string(decimal % 2);\n        decimal\
    \ /= 2;\n    }\n    return myStr.reversed ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqcwi8all.d(24): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpqcwi8all.d(27): Error: no property `reversed` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqcwi8all.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // 'db' to_string(decimal) 'db'\n    string binary = \"db\";\n    long rem\
    \ = 0;\n    long tmp = decimal;\n    while(tmp > 0)\n    {\n        rem = tmp\
    \ % 2;\n        tmp = tmp / 2;\n        binary += to_string(rem);\n    }\n   \
    \ binary += \"db\";\n    return binary;\n}\nunittest\n{\n    alias candidate =\
    \ decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeinqxfcy.d(28): Error: undefined identifier `to_string`

    /tmp/tmpeinqxfcy.d(30): Error: slice `binary` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeinqxfcy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string r = \"db\";\n    while(decimal > 0) {\n        auto remainder = decimal\
    \ % 2;\n        r = cast(string)remainder ~ r;\n        decimal /= 2;\n    }\n\
    \    r ~= \"db\";\n    return r;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf1uk86fo.d(23): Error: cannot cast expression `remainder` of type
    `long` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf1uk86fo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string retval = \"db\";\n    while(decimal != 0)\n    {\n        retval ~=\
    \ cast(char)(decimal % 2);\n        decimal /= 2;\n    }\n    return retval ~\
    \ \"db\";\n}\n/*\nThis challenge is similar to the previous one, but now you will\
    \ be given a binary\n    string and you have to convert it to a decimal. The function\
    \ should return a long. You will only\n    be given a valid binary string, without\
    \ extra characters at the beginning or at the end.\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvu2codo9.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvu2codo9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // \u043F\u0440\u043E\u0431\u0435\u0433\u0430\u0435\u043C\u0441\u044F \u043E\
    \u0442 0 \u0434\u043E 100\n    // \u0432\u044B\u0447\u0438\u0441\u043B\u044F\u0435\
    \u043C \u0441\u0442\u0435\u043F\u0435\u043D\u044C \u0434\u0432\u043E\u0439\u043A\
    \u0438 2^i\n    // \u0434\u0435\u043B\u0438\u043C \u043D\u0430 \u0434\u0432\u043E\
    \u0439\u043A\u0443. \u0435\u0441\u043B\u0438 \u043F\u0440\u043E\u043C\u0435\u0436\
    \u0443\u0442\u043E\u0447\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E \u0431\
    \u043E\u043B\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u043E\
    \ \u043D\u0430\u0439\u0434\u0435\u043D\u043D\u043E\u0439 \u0441\u0442\u0435\u043F\
    \u0435\u043D\u0438\n    // \u0442\u043E \u0432 \u0431\u0438\u043D\u0430\u0440\u043D\
    \u044B\u0439 \u043A\u043E\u0434 \u043F\u0438\u0448\u0435\u043C 1 \u0438 \u0432\
    \u044B\u0447\u0438\u0442\u0430\u0435\u043C \u0438\u0437 \u043F\u0440\u043E\u043C\
    \u0435\u0436\u0443\u0442\u043E\u0447\u043D\u043E\u0433\u043E \u0447\u0438\u0441\
    \u043B\u0430 \u043D\u0430\u0439\u0434\u0435\u043D\u043D\u0443\u044E \u0441\u0442\
    \u0435\u043F\u0435\u043D\u044C \u0434\u0432\u043E\u0439\u043A\u0438\n    // \u0438\
    \u043D\u0430\u0447\u0435 \u043F\u0438\u0448\u0435\u043C 0\n    string result =\
    \ \"db\";\n    if (decimal == 0)\n    {\n        result += \"0\";\n    }\n   \
    \ else\n    {\n        while (decimal != 0)\n        {\n            if (decimal\
    \ % 2 == 0)\n            {\n                result += \"0\";\n            }\n\
    \            else\n            {\n                result += \"1\";\n         \
    \   }\n            decimal /= 2;\n        }\n    }\n    reverse(result.begin()\
    \ + 2, result.end());\n    result += \"db\";\n    return result;\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuakkslqn.d(28): Error: slice `result` is not mutable

    /tmp/tmpuakkslqn.d(36): Error: slice `result` is not mutable

    /tmp/tmpuakkslqn.d(40): Error: slice `result` is not mutable

    /tmp/tmpuakkslqn.d(45): Error: no property `begin` for type `string`

    /tmp/tmpuakkslqn.d(45): Error: no property `end` for type `string`

    /tmp/tmpuakkslqn.d(46): Error: slice `result` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuakkslqn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  int i = 0;\n    char[] buffer = new char[40000];\n    for (; decimal != 0;\
    \ decimal /= 2) {\n        if (decimal % 2)\n            buffer[i++] = '1';\n\
    \        else\n            buffer[i++] = '0';\n    }\n    char[] ret = new char[i];\n\
    \    foreach (j; 0 .. i) {\n        ret[j] = buffer[i - j - 1];\n    }\n    return\
    \ \"db\" ~ to!string(ret) ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvha_ph5y.d(32): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvha_ph5y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  return\
    \ format(\"db%0*sdb\", 64, to!string(decimal, 2).idup);\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxge7d5q.d(20): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxge7d5q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    while(decimal!=0)\n    {\n        binary = to!string(decimal\
    \ % 2) ~ binary;\n        decimal /= 2;\n    }\n    return \"db\" ~ binary ~ \"\
    db\";\n}\n/*\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3v9ns2hr.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3v9ns2hr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // Convert to binary string\n    string result = \"\";\n    bool is_binary_digit\
    \ = false;\n    while (decimal != 0)\n    {\n        if (decimal % 2 == 1)\n \
    \       {\n            result = \"1\" ~ result;\n            is_binary_digit =\
    \ true;\n        }\n        else if (is_binary_digit)\n        {\n           \
    \ result = \"0\" ~ result;\n        }\n        decimal /= 2;\n    }\n    // Add\
    \ extra characters 'db'\n    if (result.length != 0)\n    {\n        result =\
    \ \"db\" ~ result ~ \"db\";\n    }\n    else\n    {\n        result = \"db0db\"\
    ;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpc1b1iask.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x427fd5]

    ??:? void tmpc1b1iask.__unittest_L47_C1() [0x427c22]

    ??:? void tmpc1b1iask.__modtest() [0x427d54]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bdc7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42acd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430154]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc31]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42acad]

    ??:? runModuleUnitTests [0x42bb9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428424]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  string\
    \ res;\n  if (decimal == 0)\n    return \"db0db\";\n  else\n  {\n    while (decimal)\n\
    \    {\n      res = (decimal % 2 ? \"1\" : \"0\") ~ res;\n      decimal /= 2;\n\
    \    }\n    return \"db\" ~ res ~ \"db\";\n  }\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    string ret;\n\tret ~= \"db\";\n\twhile(decimal > 0)\n\t{\n\t\tret ~= to!string(decimal\
    \ % 2);\n\t\tdecimal /= 2;\n\t}\n\tstd.algorithm.reverse(ret);\n\tret ~= \"db\"\
    ;\n\treturn ret;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n\
    \    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcnjilu6q.d(24): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpcnjilu6q.d(27): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcnjilu6q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    foreach(l; 0..100)\n    {\n        long digit\
    \ = decimal & 1;\n        result ~= to!string(digit);\n        decimal >>= 1;\n\
    \    }\n    result ~= \"db\";\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdq_7izni.d(24): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdq_7izni.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  const string res = \"db\";\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq0fl3z6y.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq0fl3z6y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  //Your code here.\n    string result = \"db\";\n    int counter = 0;\n    int\
    \ temp = 0;\n    if(decimal == 0)\n    {\n        result.append(\"0db\");\n  \
    \      return result;\n    }\n    while(decimal != 0)\n    {\n        temp = decimal\
    \ % 2;\n        result.append(to!string(temp));\n        decimal /= 2;\n     \
    \   ++counter;\n    }\n    string temp2 = \"\";\n    for(int i = counter - 1;\
    \ i >= 0; --i)\n    {\n        temp2.append(result[i + 2]);\n    }\n    temp2.append(\"\
    db\");\n    return temp2;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxa0rbh9c.d(26): Error: no property `append` for type `string`

    /tmp/tmpxa0rbh9c.d(32): Error: no property `append` for type `string`

    /tmp/tmpxa0rbh9c.d(39): Error: no property `append` for type `string`

    /tmp/tmpxa0rbh9c.d(41): Error: no property `append` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxa0rbh9c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ret = \"db\";\n    while(decimal != 0)\n    {\n        ret ~= (decimal\
    \ % 2);\n        decimal /= 2;\n    }\n    ret ~= \"db\";\n    return ret;\n}\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0p28di0n.d(23): Error: cannot append type `long` to type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0p28di0n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  import std.string;\n    auto output=string.init;\n    output ~= \"db\";\n \
    \   while(decimal!=0)\n    {\n      if(decimal%2==0)\n        output ~= \"0\"\
    ;\n      else\n        output ~= \"1\";\n      decimal = decimal/2;\n    }\n \
    \   output ~= \"db\";\n    return output.dup.retro;\n}\n/*\nYou will be given\
    \ a string in binary format and your task is to convert it to\n    decimal format.\
    \ The function should return a long, with the decimal number.\nunittest\n{\n \
    \   alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfze223su.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfze223su.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  import std.stdio;\n    string binary;\n    int temp;\n    int res = decimal;\n\
    \    while(res > 0)\n    {\n        temp = res % 2;\n        res = res / 2;\n\
    \        binary ~= format(\"%d\", temp);\n    }\n    binary = binary.reverse;\n\
    \    return \"db\" ~ binary ~ \"db\";\n}\n// Best solution \nstring decimal_to_binary(long\
    \ decimal) \n{\n    return \"db\" ~ decimal.format(\"%b\") ~ \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbdrs_dmv.d(23): Error: cannot implicitly convert expression `decimal`
    of type `long` to `int`

    /tmp/tmpbdrs_dmv.d(28): Error: undefined identifier `format`

    /tmp/tmpbdrs_dmv.d(30): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmpbdrs_dmv.d(36): Error: no property `format` for type `long`

    /tmp/tmpbdrs_dmv.d(42): Error: `tmpbdrs_dmv.decimal_to_binary` called with argument
    types `(long)` matches both:

    /tmp/tmpbdrs_dmv.d(18):     `tmpbdrs_dmv.decimal_to_binary(long decimal)`

    and:

    /tmp/tmpbdrs_dmv.d(34):     `tmpbdrs_dmv.decimal_to_binary(long decimal)`

    /tmp/tmpbdrs_dmv.d(43): Error: `tmpbdrs_dmv.decimal_to_binary` called with argument
    types `(long)` matches both:

    /tmp/tmpbdrs_dmv.d(18):     `tmpbdrs_dmv.decimal_to_binary(lo'
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    if (decimal == 0)\n        return result + \"\
    0\" + \"db\";\n    while (decimal > 0)\n    {\n        result += to!string(decimal\
    \ % 2);\n        decimal /= 2;\n    }\n    reverse(result);\n    return result\
    \ + \"db\";\n}\n/*\nYou will be given a number of decimal digits, and your task\
    \ is to return a string with alternating\n    0s and 1s, starting with 0s. The\
    \ length of the string should be the same as the number of digits.\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb6o1w6_h.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb6o1w6_h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  int binary = 0;\n    string result;\n    int i = 1;\n    while (decimal !=\
    \ 0) {\n\t\tbinary += (decimal % 2) * i;\n\t\tdecimal /= 2;\n\t\ti *= 10;\n\t\
    }\n    result = \"db\" + to!string(binary) + \"db\";\n    return result;\n}\n\
    //unittest\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxw38_str.d(28): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxw38_str.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  enum bint = char[];\n    bint reverse_bin(in long decimal) {\n        bint\
    \ res;\n        while (decimal) {\n            res ~= (decimal & 1).to!char;\n\
    \            decimal /= 2;\n        }\n        return res;\n    }\n    bint bina\
    \ = reverse_bin(decimal);\n    string result = \"db\" ~ bina.reverse;\n    return\
    \ result ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmqcalv2c.d(20): Error: found `[` when expecting `.` following char

    /tmp/tmpmqcalv2c.d(20): Error: found `]` when expecting identifier following `char`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmqcalv2c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" ~ long_to_binary(decimal) ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4rkg0yxx.d(20): Error: undefined identifier `long_to_binary`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4rkg0yxx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string s = \"db\";\n    if (decimal == 0)\n        return s + \"0\" + s;\n\
    \    while (decimal != 0) {\n        s += (decimal & 1).to!string;\n        decimal\
    \ >>= 1;\n    }\n    return s ~ \"db\";\n}\nunittest\n{\n    alias candidate =\
    \ decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz62au_jl.d(22): Error: invalid array operation `s + "0"` (possible
    missing [])

    /tmp/tmpz62au_jl.d(24): Error: no property `to` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz62au_jl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return format(\"db%sdb\", std.math.toBinaryString(decimal));\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm6s4w6yy.d(20): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm6s4w6yy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string r = \"db\";\n    while(decimal > 0)\n    {\n        r ~= (decimal %\
    \ 2).to!string;\n        decimal /= 2;\n    }\n    return r.reverse ~ \"db\";\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnywkd4cq.d(23): Error: no property `to` for type `long`

    /tmp/tmpnywkd4cq.d(26): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnywkd4cq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  long result = 0;\n    string ret = \"db\";\n    while(decimal != 0) {\n   \
    \     result = decimal % 2;\n        decimal /= 2;\n        ret = format!(\"%d%s\"\
    , result, ret);\n    }\n    ret = format!(\"%sdb\", ret);\n    return ret;\n}\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpldgvfrtv.d(25): Error: template instance `format!("%d%s", result,
    ret)` template `format` is not defined

    /tmp/tmpldgvfrtv.d(27): Error: template instance `format!("%sdb", ret)` template
    `format` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpldgvfrtv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  /*\n    binary = decimal\n    binary_string = \"\"\n    while (binary > 0)\n\
    \        binary_string = binary % 2 + binary_string\n        binary /= 2\n   \
    \ return \"db\" + binary_string + \"db\"\n    */\n    string binary_string;\n\
    \    while (decimal > 0)\n    {\n        binary_string ~= (char)((decimal % 2)\
    \ + '0');\n        decimal /= 2;\n    }\n    return \"db\" ~ binary_string ~ \"\
    db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_3g8gxpn.d(31): Error: C style cast illegal, use `cast(char)(decimal
    % 2 + ''0'')`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_3g8gxpn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // your code goes here\n    int remainder;\n    string binary = \"\";\n   \
    \ while(decimal > 0)\n    {\n        remainder = decimal % 2;\n        binary\
    \ = format(\"%d\", remainder) ~ binary;\n        decimal /= 2;\n    }\n    binary\
    \ = \"db\" ~ binary ~ \"db\";\n    return binary;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5a75vz5k.d(26): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5a75vz5k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    while(decimal > 0)\n    {\n        result = decimal\
    \ % 2 + result;\n        decimal /= 2;\n    }\n    return result ~ \"db\";\n}\n\
    /*\nYou will be given a number in binary format and your task is to convert it\
    \ to\n    decimal format. The function should return a string, with each character\
    \ representing a decimal\n    number.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmlf4a9ar.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmlf4a9ar.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res = \"db\";\n    while(decimal > 0)\n    {\n        res = to!string(decimal\
    \ % 2) ~ res;\n        decimal /= 2;\n    }\n    return res ~ \"db\";\n}\n/*\n\
    You will be given a string consisting of uppercase, lowercase, and punctuation\
    \ characters.\n    Your task is to return a string with all of the uppercase characters\
    \ swapped with their lowercase\n    equivalents. And punctuation characters removed.\n\
    \    Examples:\n    >>> swap_case(\"ProgrammingIsFun\")\n    \"pROGRAMMINGiSFUN\"\
    \n    >>> swap_case(\"I<3CS\")\n    \"i<3cs\"\n    >>> swap_case(\"1234!_?\")\n\
    \    \"1234\"\n    \n*/\nstring swap_case(string s) \n{\n    string res = \"\"\
    ;\n    for(char c: s)\n    {\n        if(c == ' ') continue;\n        else if(c\
    \ >= 'A' && c <= 'Z')\n            res ~= to!string(c.toLower());\n        else\
    \ if(c >= 'a' && c <= 'z')\n            res ~= to!string(c.toUpper());\n    }\n\
    \    return res;\n}\n/*\nYou will be given an array of strings. Your task is to\
    \ return a string, in which the\n    first character of each string is present,\
    \ in the order they come in the array.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw2hfb0jf.d(44): Error: semicolon expected, not `:`

    /tmp/tmpw2hfb0jf.d(44): Error: expression expected, not `:`

    /tmp/tmpw2hfb0jf.d(44): Error: found `s` when expecting `;` following `for` condition

    /tmp/tmpw2hfb0jf.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw2hfb0jf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ans;\n    ans += \"db\";\n    auto bit_len = cast(int)log2(decimal)\
    \ + 1;\n    for (int i = 0; i < bit_len; i++)\n    {\n        auto bit = decimal\
    \ & 1;\n        ans += (bit)?\"1\":\"0\";\n        decimal >>= 1;\n    }\n   \
    \ ans += \"db\";\n    return ans;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5a5vyuxf.d(21): Error: slice `ans` is not mutable

    /tmp/tmp5a5vyuxf.d(26): Error: slice `ans` is not mutable

    /tmp/tmp5a5vyuxf.d(29): Error: slice `ans` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5a5vyuxf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    for (int i = 0; i < 64; i++)\n    {\n        if\
    \ (decimal / (pow(2,63-i)) >= 1)\n        {\n            binary += \"1\";\n  \
    \          decimal = decimal - (pow(2,63-i));\n        }\n        else\n     \
    \   {\n            binary += \"0\";\n        }\n    }\n    binary += \"db\";\n\
    \    return binary;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyy0ni3u3.d(25): Error: slice `binary` is not mutable

    /tmp/tmpyy0ni3u3.d(30): Error: slice `binary` is not mutable

    /tmp/tmpyy0ni3u3.d(33): Error: slice `binary` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyy0ni3u3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  int remainder;\n    string binary = \"db\";\n    while (decimal > 0)\n    {\n\
    \        remainder = decimal % 2;\n        binary += cast(char)(remainder + 48);\n\
    \        decimal /= 2;\n    }\n    binary += \"db\";\n    return binary;\n}\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4fo7yk2x.d(25): Error: slice `binary` is not mutable

    /tmp/tmp4fo7yk2x.d(28): Error: slice `binary` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4fo7yk2x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // Write your code here\n    string ret=\"db\";\n    bool first;\n    for(int\
    \ i=0;i<32;i++)\n    {\n        int digit = decimal % 2;\n        ret = format(\"\
    %d%s\",digit,ret);\n        decimal /= 2;\n    }\n    ret += \"db\";\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ukjadcb.d(26): Error: undefined identifier `format`

    /tmp/tmp9ukjadcb.d(29): Error: slice `ret` is not mutable

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string bin_str;\n    int quotient = decimal;\n    int remainder = 0;\n    while\
    \ (quotient != 0) {\n        remainder = quotient % 2;\n        quotient = quotient\
    \ / 2;\n        bin_str = std.string.toString(remainder) ~ bin_str;\n    }\n \
    \   bin_str = \"db\" ~ bin_str ~ \"db\";\n    return bin_str;\n}\nunittest\n{\n\
    \    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvgh2354p.d(21): Error: cannot implicitly convert expression `decimal`
    of type `long` to `int`

    /tmp/tmpvgh2354p.d(26): Error: undefined identifier `string` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvgh2354p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  const int maxlen = 10;\n    immutable char[maxlen] binary = \"dbdbdbdbdb\"\
    ;\n    int len = maxlen;\n    int i = 0;\n    do {\n        binary[i] = (decimal\
    \ % 2 == 0) ? '0' : '1';\n        decimal /= 2;\n        ++i;\n    } while (decimal\
    \ != 0);\n    reverse(binary[1..i-1]);\n    len = i + 1;\n    return to!string(binary[0..len]);\n\
    }\n/*\n    Write a function that takes a number and returns the first three numbers\
    \ in its binary representation.\n    >>> first_three_bits(5L)\n    \"101\"\n \
    \   >>> first_three_bits(23L)\n    \"101\"\n*/\nstring first_three_bits(long n)\
    \ \n{\n    string s = decimal_to_binary(n);\n    return s[2..5];\n}\n/*\n    Write\
    \ a function that takes a number and returns the last three numbers in its binary\
    \ representation.\n    >>> last_three_bits(5L)\n    \"101\"\n    >>> last_three_bits(23L)\n\
    \    \"101\"\n*/\nstring last_three_bits(long n) \n{\n    string s = decimal_to_binary(n);\n\
    \    int len = s.length;\n    return s[len-4..len-1];\n}\n/*\n    Write a function\
    \ that takes a number and returns a tuple containing the first three and the last\
    \ three bits.\n    >>> last_and_first_three_bits(5L)\n    Tuple!(\"101\", \"101\"\
    )\n    >>> last_and_first_three_bits(23L)\n    Tuple!(\"101\", \"101\")\n*/\n\
    Tuple!(\"dbxxx\", \"xxxdb\") last_and_first_three_bits(long n) \n{\n    return\
    \ tuple(first_three_bits(n), last_three_bits(n));\n}\n/*\n    Given a binary string,\
    \ return true if it is a valid binary code, otherwise return false.\n    >>> test_binary_string(\"\
    db100101101db\")\n    true\n    >>> test_binary_\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0k2j165z.d(69): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0k2j165z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  const(char)[] binary = \"db\";\n    string result = \"\";\n    while(decimal)\n\
    \    {\n        result ~= (decimal % 2).to!string;\n        decimal /= 2;\n  \
    \  }\n    return binary ~ result ~ binary;\n}\n/*\nYou will be given a number\
    \ in binary format and your task is to convert it to\n    decimal format. The\
    \ function should return a long, with each number representing a decimal\n   \
    \ number. Each character in the string will be '0' or '1'.\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptf9qufag.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptf9qufag.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return decimal.to!string.bin;\n}\n/*\nYou will be given a number in binary\
    \ format and your task is to convert it to\n    decimal format. The function should\
    \ return a long, with each character representing a binary\n    number. Each character\
    \ in the string will be '0' or '1'.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdjr8s7n0.d(22): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjr8s7n0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  ulong\
    \ n = decimal;\n  string bstring = \"db\";\n  do {\n    bstring ~= (n & 1).to!string;\n\
    \  } while (n >>= 1);\n  bstring = bstring.reverse.join();\n  bstring ~= \"db\"\
    ;\n  return bstring;\n}\n// Alternative Solution:\n// string decimal_to_binary(long\
    \ decimal) {\n//     string s;\n//     do\n//     {\n//         s = (decimal %\
    \ 2).to!string ~ s;\n//         decimal /= 2;\n//     } while (decimal);\n// \
    \    return \"db\" ~ s ~ \"db\";\n// }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg_q034kf.d(23): Error: no property `to` for type `ulong`

    /tmp/tmpg_q034kf.d(25): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_q034kf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ret;\n    while(decimal)\n    {\n        ret = to!string(decimal & 1L)\
    \ ~ ret;\n        decimal >>= 1;\n    }\n    return \"db\" ~ ret ~ \"db\";\n}\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp56ma8gmt.d(23): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp56ma8gmt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string str;\n    str ~= \"db\";\n    for(long n = decimal; n > 0; n /= 2)\n\
    \    {\n        if(n%2 == 0)\n            str ~= \"0\";\n        else\n      \
    \      str ~= \"1\";\n    }\n    if(str.length > 2)\n        str = str[0..2] ~\
    \ str[$-2..$];\n    return str;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuqz3g4fu.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427fdd]

    ??:? void tmpuqz3g4fu.__unittest_L33_C1() [0x427bed]

    ??:? void tmpuqz3g4fu.__modtest() [0x427d60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c8df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b7ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ffcd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43047c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ff59]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7c5]

    ??:? runModuleUnitTests [0x42c6b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4284a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  string\
    \ db = \"db\";\n  string result = db;\n  while(decimal != 0L) {\n    long temp\
    \ = decimal % 2L;\n    decimal /= 2L;\n    result ~= to!string(temp);\n  }\n \
    \ result ~= db;\n  return result;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt7s75xtk.d(25): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt7s75xtk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    while(decimal > 0)\n    {\n        binary ~= to!string(decimal\
    \ % 2);\n        decimal /= 2;\n    }\n    return binary ~ \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvlr1wxaj.d(23): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvlr1wxaj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  string\
    \ db = \"db\";\n  string binary = \"\";\n  while(decimal > 0)\n  {\n    binary\
    \ = to!string(decimal % 2) ~ binary;\n    decimal /= 2;\n  }\n  return \"db\"\
    \ ~ binary ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw5vwaa5d.d(24): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw5vwaa5d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  enum charset = \"01\";\n    string ret = \"db\";\n    if (decimal == 0)\n \
    \       ret += \"0\";\n    else\n    {\n        while (decimal > 0)\n        {\n\
    \            ret += charset[decimal % 2];\n            decimal /= 2;\n       \
    \ }\n    }\n    return ret ~= \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp9t7nx7y.d(23): Error: slice `ret` is not mutable

    /tmp/tmpp9t7nx7y.d(28): Error: slice `ret` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp9t7nx7y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res = \"db\";\n    while(decimal > 0)\n    {\n        res ~= (decimal\
    \ % 2).to!string;\n        decimal /= 2;\n    }\n    return res ~ \"db\";\n}\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphmvb4f76.d(23): Error: no property `to` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphmvb4f76.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    ulong tmp = cast(ulong)decimal;\n    while(tmp\
    \ != 0)\n    {\n        binary = \"01\"[tmp & 1] ~ binary;\n        tmp >>= 1;\n\
    \    }\n    binary ~= \"db\";\n    return binary;\n}\n/*\nThe function should\
    \ return a string, with each character representing a binary\n    number. Each\
    \ character in the string will be '0' or '1'.\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpskje1y_o.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpskje1y_o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    if (decimal == 0)\n        return \"db0db\";\n    while\
    \ (decimal > 0)\n    {\n        long rest = decimal % 2;\n        decimal /= 2;\n\
    \        result = to!string(rest) ~ result;\n    }\n    return \"db\" ~ result\
    \ ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_g6ns2e8.d(27): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_g6ns2e8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string s = \"db\";\n    long r = 0;\n    long div = decimal;\n    long remain\
    \ = 0;\n    while(div > 0)\n    {\n        r = div % 2;\n        div = div / 2;\n\
    \        remain = decimal - div * 2;\n        decimal = div;\n        s ~= remain.to!string;\n\
    \    }\n    return s ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb966nono.d(30): Error: no property `to` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb966nono.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  import std.string;\n    import std.conv;\n    return \"db\" ~ to!string(decimal,\
    \ 2L) ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n\
    \    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/conv.d(222):
    Error: template `std.conv.toImpl` cannot deduce function from argument types `!(string)(long,
    long)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/conv.d(493):        `std.conv.toImpl(T,
    S)(S value) if (isImplicitlyConvertible!(S, T) && !isEnumStrToStr!(S, T) && !isNullToStr!(S,
    T))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/conv.d(607):        `std.conv.toImpl(T,
    S)(ref S s) if (isStaticArray!S)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/conv.d(623):        `std.conv.toImpl(T,
    S)(S value) if (!isImplicitlyConvertible!(S, T) && is(typeof(S.init.opCast!T())
    : T) && !isExactSomeString!T && !is(typeof(T(value))))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/conv.d(674):        `std.conv.toImpl(T,
    S)(S value) if (!isImplicitlyConvertible!(S, T) && is(T == struct) && is(typeof(T(value))))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/conv.d(723):        `std.conv.toImpl(T,
    S)(S value) if (!isImplicitlyConvertible!(S, T) && is(T == class) && is(typeof(new
    T(value))))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/conv.d(796):        `std.conv.toImpl(T,
    S)(S value) if (!isImplicitlyConvertible!(S, T) && (is(S == class) || is(S ==
    interface)) && !is(typeof(value.opCast!T()) : T) && (is(T == class) || is(T ==
    interface)) && !is(typeof(new T(value))))`

    /home'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    string answer = \"db\";\n\twhile(decimal)\n\t{\n\t\tanswer += cast(char)('0' +\
    \ (decimal % 2));\n\t\tdecimal /= 2;\n\t}\n\tauto result = answer.dup;\n\tfor(auto\
    \ i = answer.length; i > 2; i--)\n\t\tresult[i - 1] = answer[answer.length - i\
    \ + 2];\n\tresult ~= \"db\";\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp55sav6zt.d(23): Error: slice `answer` is not mutable

    /tmp/tmp55sav6zt.d(30): Error: cannot implicitly convert expression `result` of
    type `char[]` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp55sav6zt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    char[] ans = appender!(char[])(binary);\n    for\
    \ (; decimal > 0; decimal >>= 1)\n    {\n        ans.put(decimal & 1);\n    }\n\
    \    ans.put('d');\n    ans.put('b');\n    ans.reverse();\n    return ans.idup;\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4z2gbc3.d(21): Error: template instance `appender!(char[])` template
    `appender` is not defined

    /tmp/tmp_4z2gbc3.d(24): Error: no property `put` for type `char[]`

    /tmp/tmp_4z2gbc3.d(26): Error: no property `put` for type `char[]`

    /tmp/tmp_4z2gbc3.d(27): Error: no property `put` for type `char[]`

    /tmp/tmp_4z2gbc3.d(28): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_4z2gbc3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // calculate index of first bit\n    uint pow = uint.max;\n    while(!(decimal\
    \ & (1L << pow)))\n        pow--;\n    uint outLen = pow+2;\n    auto out = new\
    \ string(\"db\").dup;\n    foreach(p; reverse(0..pow+1))\n    {\n        auto\
    \ bit = decimal & (1L << p);\n        if(bit) out ~= \"1\";\n        else out\
    \ ~= \"0\";\n    }\n    out ~= \"db\";\n    return out;\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4gku5c8b.d(25): Error: basic type expected, not `out`

    /tmp/tmp4gku5c8b.d(25): Error: no identifier for declarator `_error_`

    /tmp/tmp4gku5c8b.d(25): Error: found `out` instead of statement

    /tmp/tmp4gku5c8b.d(26): Error: found `..` when expecting `,`

    /tmp/tmp4gku5c8b.d(29): Error: found `out` instead of statement

    /tmp/tmp4gku5c8b.d(30): Error: found `out` instead of statement

    /tmp/tmp4gku5c8b.d(32): Error: found `out` instead of statement

    /tmp/tmp4gku5c8b.d(33): Error: expression expected, not `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4gku5c8b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary_str =\"db\";\n    // Check is the number is zero.\n    if (decimal\
    \ == 0)\n    {\n        return binary_str + \"0\" + \"db\";\n    }\n    // Check\
    \ if the number is positive.\n    else if (decimal > 0)\n    {\n        while\
    \ (decimal > 0)\n        {\n            // Use the modulo operator to test the\
    \ binary digit (remainder / bit).\n            binary_str += (decimal % 2).to!string;\n\
    \            // Use the integer division operator to reduce the decimal number\
    \ (quotient).\n            decimal /= 2;\n        }\n        // Reverse the string.\n\
    \        binary_str = binary_str.dup.reverse;\n        // Add the end delimiter.\n\
    \        binary_str += \"db\";\n        return binary_str;\n    }\n    // Handle\
    \ negative numbers.\n    else if (decimal < 0)\n    {\n        // Get the absolute\
    \ value of the number.\n        decimal = abs(decimal);\n        while (decimal\
    \ > 0)\n        {\n            // Use the modulo operator to test the binary digit\
    \ (remainder / bit).\n            binary_str += (decimal % 2).to!string;\n   \
    \         // Use the integer division operator to reduce the decimal number (quotient).\n\
    \            decimal /= 2;\n        }\n        // Pad the end with 1's to comply\
    \ with the sign and magnitude format.\n        for (; binary_str.length < 32;)\n\
    \        {\n            binary_str += \"1\";\n        }\n        // Flip the bits.\n\
    \        binary_str = binary_str.map!(a => (a == '1') ? \"0\" : \"1\");\n    \
    \    // Add one to the string.\n        binary_str = (to!ulong(binary_str) + 1).to!string;\n\
    \        // Reverse the string.\n        binary_str = binary_str.dup.reverse;\n\
    \        // Add the end delimiter.\n        binary_str += \"db\";\n        return\
    \ binary_str;\n    }\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa7_xixm5.d(24): Error: invalid array operation `binary_str + "0"`
    (possible missing [])

    /tmp/tmpa7_xixm5.d(32): Error: no property `to` for type `long`

    /tmp/tmpa7_xixm5.d(37): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmpa7_xixm5.d(39): Error: slice `binary_str` is not mutable

    /tmp/tmpa7_xixm5.d(50): Error: no property `to` for type `long`

    /tmp/tmpa7_xixm5.d(57): Error: slice `binary_str` is not mutable

    /tmp/tmpa7_xixm5.d(60): Error: no property `map` for type `string`

    /tmp/tmpa7_xixm5.d(62): Error: template instance `to!ulong` template `to` is not
    defined, did you mean No?

    /tmp/tmpa7_xixm5.d(64): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmpa7_xixm5.d(66): Error: slice `binary_str` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa7_xixm5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  enum {\n        len = 64,\n    };\n    static char[len] bin = void;\n    static\
    \ int index = len - 1;\n    static bool first = true;\n    if (first) {\n    \
    \    first = false;\n        foreach (i; len) {\n            bin[i] = '0';\n \
    \       }\n    }\n    foreach (i; len) {\n        if (decimal & 1L) {\n      \
    \      bin[index] = '1';\n        } else {\n            bin[index] = '0';\n  \
    \      }\n        decimal >>= 1;\n        index--;\n    }\n    return \"db\" ~\
    \ to!string(bin[index..len - 1]) ~ \"db\";\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_n0bix17.d(22): Deprecation: use `{ }` for an empty statement,
    not `;`

    /tmp/tmp_n0bix17.d(28): Error: invalid `foreach` aggregate `64`

    /tmp/tmp_n0bix17.d(32): Error: invalid `foreach` aggregate `64`

    /tmp/tmp_n0bix17.d(41): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_n0bix17.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto r = \"db\";\n    auto b = \"\";\n    while(decimal > 0)\n    {\n     \
    \   if(decimal % 2)\n            b = \"1\" ~ b;\n        else\n            b =\
    \ \"0\" ~ b;\n        decimal /= 2;\n    }\n    return r ~ b ~ r;\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvkclndgl.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427fa5]

    ??:? void tmpvkclndgl.__unittest_L32_C1() [0x427bb5]

    ??:? void tmpvkclndgl.__modtest() [0x427d28]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd97]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aca6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc75]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430124]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc01]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac7d]

    ??:? runModuleUnitTests [0x42bb6d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" ~ bint.to!string(decimal, 2) ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpla_p2tgu.d(20): Error: undefined identifier `bint`, did you mean
    function `rint`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpla_p2tgu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" + \"\".to(decimal ? decimal, long x => x / 2, long x => (x ?\
    \ \"1\" : \"0\") + to!string(x % 2)) + \"db\";\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp50opwf2t.d(20): Error: found `x` when expecting `.` following long

    /tmp/tmp50opwf2t.d(20): Error: found `=>` when expecting identifier following
    `long`.

    /tmp/tmp50opwf2t.d(20): Error: found `x` when expecting `:`

    /tmp/tmp50opwf2t.d(20): Error: expression expected, not `/`

    /tmp/tmp50opwf2t.d(20): Error: found `2` when expecting `,`

    /tmp/tmp50opwf2t.d(20): Error: expression expected, not `,`

    /tmp/tmp50opwf2t.d(20): Error: found `long` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp50opwf2t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  //Convert Decimal to Binary\n    //15\n    //0000 1111\n    //----\n    //\
    \     1\n    //    1\n    //   1\n    //  1\n    // 1\n    int [] binary = new\
    \ int[to!int(log(decimal, 2)+1)];\n    long n = decimal;\n    int i=0;\n    while(n>0)\n\
    \    {\n        binary[i] = n%2;\n        n/=2;\n        i++;\n    }\n    return\
    \ \"db\" ~ to!string(binary.dup.reversed.join(\"\")) ~ \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz_epjplx.d(29): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    /tmp/tmpz_epjplx.d(38): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_epjplx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    result ~= \"db\";\n    while(decimal > 0)\n    {\n    \
    \    result ~= decimal % 2;\n        decimal /= 2;\n    }\n    result ~= \"db\"\
    ;\n    return result;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4gdilisx.d(24): Error: cannot append type `long` to type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4gdilisx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    while(decimal) {\n        binary ~= decimal%2;\n      \
    \  decimal /= 2;\n    }\n    return \"db\" ~ binary.reverse ~ \"db\";\n}\n \n\
    /*\nYou will be given a string in binary format and your task is to convert it\
    \ to decimal format.\n    The function should return a long.\nunittest\n{\n  \
    \  alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd6uob1f0.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd6uob1f0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto binary_temp = \"\";\n    while(decimal > 0){\n      binary_temp = binary_temp\
    \ ~ to!string(decimal % 2);\n      decimal /= 2;\n    }\n    return \"db\" ~ binary_temp.reversed\
    \ ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgsf8gv1h.d(22): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpgsf8gv1h.d(25): Error: no property `reversed` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgsf8gv1h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  int i = 0;\n    char[] str = new char[65];\n    do {\n        str[i++] = cast(char)('0'\
    \ + (decimal & 1));\n        decimal >>= 1;\n    } while (decimal != 0);\n   \
    \ str[i] = '\\0';\n    str.reverse;\n    auto result = \"db\" ~ str ~ \"db\";\n\
    \    return result;\n}\n/*\n    You are given a string that represents a binary\
    \ number. You need to write a function that converts\n    it to a decimal number.\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp25698dv5.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp25698dv5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    while(decimal != 0) {\n        result = \"db\" ~ to!string(decimal\
    \ & 1) ~ result;\n        decimal >>= 1;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbpel6wso.d(22): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpel6wso.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res = \"db\";\n    while(decimal != 0)\n    {\n        res ~= decimal\
    \ % 2;\n        decimal /= 2;\n    }\n    return res ~ \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwsdl1kwz.d(23): Error: cannot append type `long` to type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwsdl1kwz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string s = \"db\";\n    while(decimal != 0L)\n    {\n        s ~= (decimal\
    \ % 2L == 0L ? '0' : '1');\n        decimal /= 2L;\n    }\n    s ~= \"db\";\n\
    \    return s.retro;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp096r9wu9.d(27): Error: no property `retro` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp096r9wu9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res = \"db\";\n    while(decimal > 0)\n    {\n        res ~= decimal\
    \ % 2;\n        decimal /= 2;\n    }\n    res ~= \"db\";\n    return res.reverse;\n\
    }\n/*\nNext is converting binary to decimal. Your task is to convert the binary\
    \ string\n    to a decimal number.\n    Example:\n    >>> binary_to_decimal(\"\
    db100101db\")\n    37L\n*/\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4y9l0sid.d(23): Error: cannot append type `long` to type `string`

    /tmp/tmp4y9l0sid.d(27): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4y9l0sid.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    while(decimal>0)\n    {\n        if(decimal%2==0) result\
    \ = \"0\" ~ result;\n        else result = \"1\" ~ result;\n        decimal =\
    \ decimal/2;\n    }\n    return \"db\" ~ result ~ \"db\";\n}\n/*\nUsing the decimal_to_binary\
    \ function, you will now be given a string in binary format.\n    Your task is\
    \ to convert it back to decimal format and return the decimal number.\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbtacauym.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbtacauym.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto bits = typeof(return)();\n    string binary_string;\n    if (decimal ==\
    \ 0)\n    {\n        binary_string = \"db0db\";\n    }\n    else\n    {\n    \
    \    while (decimal != 0)\n        {\n            bits.insert(0, decimal % 2);\n\
    \            decimal /= 2;\n        }\n        binary_string = \"db\" ~ to!string(bits)\
    \ ~ \"db\";\n    }\n    return binary_string;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpip8jd8th.d(20): Error: function expected before `()`, not `string`
    of type `string`

    /tmp/tmpip8jd8th.d(33): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" ~ to!string(2, decimal) ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7fl1y8f3.d(20): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7fl1y8f3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    while(decimal != 0)\n    {\n        binary ~= (decimal\
    \ & 1L) ? \"1\" : \"0\";\n        decimal >>= 1;\n    }\n    return \"db\" ~ binary.reverse\
    \ ~ \"db\";\n}\n/*\nYou will be given a positive integer and your task is to convert\
    \ it to the base of your choice.\n    The function should return a string, with\
    \ each character representing a number of the chosen base.\n    Each character\
    \ in the string will be a digit between 0 and 9, or a letter between A and Z.\n\
    \    The letter A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U,\
    \ V, W, X, Y, Z will be used\n    to represent the decimal numbers 10, 11, 12,\
    \ 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\n    28, 29, 30,\
    \ 31, 32, 33, 34, 35 respectively.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpixtzqqwh.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpixtzqqwh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ret;\n    bool start = true;\n    while(decimal)\n    {\n        ret\
    \ = (decimal & 1 ? \"1\" : \"0\") ~ ret;\n        decimal >>= 1;\n        if(start)\n\
    \        {\n            ret = \"db\" ~ ret;\n            start = false;\n    \
    \    }\n    }\n    if(start)\n        ret = \"db0db\";\n    else\n        ret\
    \ ~= \"db\";\n    return ret;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpymd0w1gf.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f95]

    ??:? void tmpymd0w1gf.__unittest_L38_C1() [0x427be2]

    ??:? void tmpymd0w1gf.__modtest() [0x427d14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c823]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b732]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fe9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b709]

    ??:? runModuleUnitTests [0x42c5f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    while(decimal > 0)\n    {\n        binary = to!string(decimal%2)~binary;\n\
    \        decimal /= 2;\n    }\n    binary = \"db\"~binary~\"db\";\n    return\
    \ binary;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_8wv4on_.d(23): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_8wv4on_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  static const string one = \"1\";\n    static const string zero = \"0\";\n \
    \   static const string db = \"db\";\n    string bits;\n    int size = decimal.sizeof;\n\
    \    for (int i = 0; i < size; i++) {\n        if (decimal & 0x01) {\n       \
    \     bits = one ~ bits;\n        } else {\n            bits = zero ~ bits;\n\
    \        }\n        decimal >>= 1;\n    }\n    return db ~ bits ~ db;\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqzqo4866.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x428075]

    ??:? void tmpqzqo4866.__unittest_L35_C1() [0x427c85]

    ??:? void tmpqzqo4866.__modtest() [0x427df8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42be67]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ad76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fd45]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4301f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fcd1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ad4d]

    ??:? runModuleUnitTests [0x42bc3d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4284c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string s = \"db\";\n    return s ~ string.format(\"%b\",decimal) ~ \"db\";\n\
    }\n/*\nYou will be given a string representing a binary number, and your task\
    \ is to convert it to decimal format. The function should return a long integer.\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppg5m8t62.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppg5m8t62.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  if (decimal < 0)\n        decimal = decimal.to!(long);\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfipol4_7.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfipol4_7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  int byte = 8;\n    string ret = \"db\";\n    int len = decimal.bitLength;\n\
    \    int rem = len % byte;\n    if (rem != 0) len += (byte - rem);\n    foreach\
    \ (i; 0 .. len) \n    {\n        ret = \"0\" ~ ret;\n    }\n    foreach (i; 0\
    \ .. len) \n    {\n        if (decimal % 2 == 1) \n        {\n            ret[len\
    \ - i] = '1';\n        }\n        decimal = decimal / 2;\n    }\n    return ret\
    \ ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf5rzbgd9.d(20): Error: no identifier for declarator `int`

    /tmp/tmpf5rzbgd9.d(20): Error: no identifier for declarator `byte`

    /tmp/tmpf5rzbgd9.d(20): Error: found `=` instead of statement

    /tmp/tmpf5rzbgd9.d(23): Error: found `;` when expecting `.` following byte

    /tmp/tmpf5rzbgd9.d(24): Error: found `if` when expecting identifier following
    `byte`.

    /tmp/tmpf5rzbgd9.d(24): Error: semicolon expected, not `len`

    /tmp/tmpf5rzbgd9.d(24): Error: found `-` when expecting `.` following byte

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf5rzbgd9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  int bit;\n    string result;\n    result ~= \"db\";\n    if (decimal == 0)\n\
    \    {\n        result ~= \"0\";\n    }\n    else\n    {\n        while (decimal\
    \ != 0)\n        {\n            bit = decimal % 2;\n            result ~= bit.to!string;\n\
    \            decimal /= 2;\n        }\n    }\n    result ~= \"db\";\n    return\
    \ result;\n}\n/*\nYou will be given a number in binary format and your task is\
    \ to convert it to\n    decimal format. The function should return a long, which\
    \ is the converted number.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpntg9_dmw.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpntg9_dmw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  const char[] alphabet = \"01\";\n    bool firstTime = true;\n    bool cont\
    \ = true;\n    bool firstDigit = true;\n    string result = \"\";\n    while(cont)\n\
    \    {\n        int digit = decimal % 2;\n        decimal /= 2;\n        if(!firstDigit)\n\
    \        {\n            result = \"0\" ~ result;\n        }\n        else\n  \
    \      {\n            firstDigit = false;\n        }\n        if(decimal == 0)\n\
    \        {\n            if(firstTime)\n            {\n                result =\
    \ \"db\" ~ result ~ \"db\";\n                firstTime = false;\n            }\n\
    \            cont = false;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpx331bpdw.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x427fad]

    ??:? void tmpx331bpdw.__unittest_L49_C1() [0x427bb9]

    ??:? void tmpx331bpdw.__modtest() [0x427d2c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd9f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42acae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc7d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43012c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc09]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac85]

    ??:? runModuleUnitTests [0x42bb75]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    string str = \"db\";\n\tchar[] chr;\n\twhile(decimal > 0) {\n\t\tstr ~= (cast(char)(decimal\
    \ % 2 + 48));\n\t\tdecimal /= 2;\n\t}\n\tstr ~= \"db\";\n\tchr = str[$ - 1];\n\
    \tstr = \"\";\n\tforeach(index, c; chr) {\n\t\tstr ~= c;\n\t}\n\treturn str;\n\
    }\n//*******************************************************\nstring decimal_to_binary2(long\
    \ decimal) \n{\n\treturn \"db\" ~ reverse(to!string(decimal, 2)) ~ \"db\";\n}\n\
    //*******************************************************\nstring decimal_to_binary3(long\
    \ decimal) \n{\n\treturn \"db\" ~ format(\"%=b\", decimal) ~ \"db\";\n}\n//*******************************************************\n\
    string decimal_to_binary4(long decimal) \n{\n\treturn \"db\" ~ split(to!string(decimal,\
    \ 2)) ~ \"db\";\n}\n//*******************************************************\n\
    string decimal_to_binary5(long decimal) \n{\n\treturn \"db\" ~ std.algorithm.map!(decimalToChar)(iota(decimal))\
    \ ~ \"db\";\n}\n//*******************************************************\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz8zxwk9m.d(27): Error: cannot implicitly convert expression `str[__dollar
    - 1LU]` of type `immutable(char)` to `char[]`

    /tmp/tmpz8zxwk9m.d(37): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpz8zxwk9m.d(42): Error: undefined identifier `format`

    /tmp/tmpz8zxwk9m.d(47): Error: undefined identifier `split`

    /tmp/tmpz8zxwk9m.d(52): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz8zxwk9m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    string binaryStr = \"db\";\n\tint binaryInt = decimal;\n\twhile(binaryInt > 0)\n\
    \t{\n\t\tbinaryStr = (binaryInt % 2 == 0 ? \"0\" : \"1\") ~ binaryStr;\n\t\tbinaryInt\
    \ /= 2;\n\t}\n\tbinaryStr ~= \"db\";\n\treturn binaryStr;\n}\nunittest\n{\n  \
    \  alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvnqf17tb.d(21): Error: cannot implicitly convert expression `decimal`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvnqf17tb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res;\n    long n = decimal;\n    while(n != 0)\n    {\n        res =\
    \ to!string(n % 2) ~ res;\n        n /= 2;\n    }\n    return \"db\" ~ res ~ \"\
    db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpech7e36e.d(24): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpech7e36e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    // Your code goes here.\n    //return binary;\n\
    \    if(decimal == 0L) return \"db0db\";\n    if(decimal < 0L) {\n        binary\
    \ = \"db1\";\n        decimal = -decimal;\n    }\n    while(decimal > 0L) {\n\
    \        if(decimal % 2L == 0L)\n            binary ~= \"0\";\n        else\n\
    \            binary ~= \"1\";\n        decimal /= 2L;\n    }\n    binary ~= \"\
    db\";\n    return binary;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxej1i31k.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f95]

    ??:? void tmpxej1i31k.__unittest_L38_C1() [0x427be6]

    ??:? void tmpxej1i31k.__modtest() [0x427d18]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fe9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5c1]

    ??:? runModuleUnitTests [0x42c4b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ret;\n    if (decimal == 0) {\n        ret = \"db0db\";\n    } else\
    \ {\n        ret = \"db\";\n        while (decimal > 0) {\n            ret = ret\
    \ ~ cast(string)(decimal % 2);\n            decimal /= 2;\n        }\n       \
    \ ret = ret ~ \"db\";\n        ret = ret.retro;\n    }\n    return ret;\n}\n/*\n\
    In math, the Fibonacci numbers are a sequence of numbers named after Leonardo\
    \ Fibonacci, who wrote\nabout them in the early 1200s.\nThe sequence starts with\
    \ 1, 1, and each subsequent number is the sum of the previous two.\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpibp00zmm.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpibp00zmm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto a = to!(string)(decimal, 2);\n    return a.prepend(\"db\").append(\"db\"\
    );\n}\n/*\nYou have to create a function that takes a positive integer number\
    \ and returns the next bigger number formed by the same digits:\n    12 ==> 21\n\
    \    513 ==> 531\n    2017 ==> 2071\n    If no bigger number can be composed using\
    \ those digits, return -1:\n    9 ==> -1\n    111 ==> -1\n    531 ==> -1\n*/\n\
    long next_bigger(long n) \n{\n    //Convert from long to string\n    auto str\
    \ = to!(string)(n);\n    int len = str.length;\n    //Bool for checking if a bigger\
    \ number can be composed\n    bool flag = false;\n    //Loop through the string\
    \ to find a smaller char\n    for(int i = len - 1; i > 0; i--)\n    {\n      \
    \  if(str[i] > str[i - 1])\n        {\n            flag = true;\n            //Get\
    \ the index of i\n            int x = i - 1;\n            //Choose a min index\n\
    \            int min = x + 1;\n            //Loop to get the smallest index that\
    \ satisfies the statement\n            for(int j = x + 1; j < len; j++)\n    \
    \        {\n                if(str[j] > str[x] && str[j] < str[min])\n       \
    \         {\n                    min = j;\n                }\n            }\n\
    \            //Swap x and min\n            auto t = str[x];\n            str[x]\
    \ = str[min];\n            str[min] = t;\n            //Reverse the string\n \
    \           for(int j = x + 1; j < len; j++)\n            {\n                if(j\
    \ <= len - j - 1)\n                {\n                    auto t = str[j];\n \
    \                   str[j] = str[len - j - 1];\n                    str[len -\
    \ j - 1] = t;\n                }\n            }\n            break;\n        }\n\
    \    }\n    //If flag is false, return -1\n    if(!flag)\n    {\n        return\
    \ -1;\n    }\n   \nunittest\n{\n    alias candidate = decimal_to_binary;\n\n \
    \   assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpce_n_hm1.d(81): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpce_n_hm1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto range = map!((int r) { return r.to!char; })(\n        reduce!(\n     \
    \       (string r, int x) => map!((int r) { return r.to!char; })(\n          \
    \      map!(\n                    (bool b) => b ? 1 : 0\n                )(\n\
    \                    map!(\n                        (int x) => x == 1\n      \
    \              )(\n                        split(\n                          \
    \  format(\"%02b\", x)\n                        )\n                    )\n   \
    \             )\n            )\n        )(\n            reduce!(\n           \
    \     (long r, long x) => x == 0 ? r : [r, x / 2]\n            )(\n          \
    \      [decimal]\n            )\n        )\n    );\n    string result = \"db\"\
    ;\n    foreach(x; range)\n    {\n        result ~= x;\n    }\n    result ~= \"\
    db\";\n    return result;\n}\n \nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp972rjfzg.d(20): Error: template instance `map!((int r)

    {

    return r.to!char;

    }

    )` template `map` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp972rjfzg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" ~ to!string(decimal, 2) ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvjk9qbdj.d(20): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvjk9qbdj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res = \"db\";\n    long denom = 1;\n    long remainder = 0;\n    long\
    \ quotient = 0;\n    long org = decimal;\n    while(denom <= decimal)\n    {\n\
    \        denom *= 2;\n    }\n    while(denom > 1)\n    {\n        denom /= 2;\n\
    \        quotient = decimal / denom;\n        remainder = decimal % denom;\n \
    \       if(quotient == 1)\n        {\n            res ~= \"1\";\n        } else\
    \ {\n            res ~= \"0\";\n        }\n        decimal = remainder;\n    }\n\
    \    res ~= \"db\";\n    return res;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_x8o4c0q.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f95]

    ??:? void tmp_x8o4c0q.__unittest_L45_C1() [0x427ba5]

    ??:? void tmp_x8o4c0q.__modtest() [0x427d18]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fe9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5c1]

    ??:? runModuleUnitTests [0x42c4b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  static string bits[] = [\"db0db\", \"db1db\"];\n    static string ret;\n  \
    \  static long x;\n    if (decimal <= 1)\n        return bits[decimal];\n    else\
    \ \n    {\n        ret = decimal_to_binary(decimal / 2);\n        x = decimal\
    \ % 2;\n        return ret[0..^2] ~ bits[x];\n    }\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaqgizjck.d(20): Deprecation: instead of C-style syntax, use D-style
    syntax `string[] bits`

    /tmp/tmpaqgizjck.d(29): Error: expression expected, not `^`

    /tmp/tmpaqgizjck.d(29): Error: found `2` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaqgizjck.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string b_string = \"db\";\n    if (decimal < 0)\n    {\n        b_string +=\
    \ \"1\";\n        decimal = decimal * -1;\n    }\n    else\n    {\n        b_string\
    \ += \"0\";\n    }\n    long l = 0;\n    long max = log2(decimal);\n    while\
    \ (l <= max)\n    {\n        if (decimal >= (1 << l))\n        {\n           \
    \ b_string += \"1\";\n            decimal -= (1 << l);\n        }\n        else\n\
    \        {\n            b_string += \"0\";\n        }\n        l++;\n    }\n \
    \   b_string += \"db\";\n    return b_string;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxspck5sv.d(23): Error: slice `b_string` is not mutable

    /tmp/tmpxspck5sv.d(28): Error: slice `b_string` is not mutable

    /tmp/tmpxspck5sv.d(31): Error: cannot implicitly convert expression `log2(cast(real)decimal)`
    of type `real` to `long`

    /tmp/tmpxspck5sv.d(36): Error: slice `b_string` is not mutable

    /tmp/tmpxspck5sv.d(41): Error: slice `b_string` is not mutable

    /tmp/tmpxspck5sv.d(45): Error: slice `b_string` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxspck5sv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    while(decimal>0)\n    {\n        result~=decimal%2;\n\
    \        decimal/=2;\n    }\n    std.array.reverse(result);\n    result~=\"db\"\
    ;\n    return result;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmb91e1ue.d(23): Error: cannot append type `long` to type `string`

    /tmp/tmpmb91e1ue.d(26): Error: undefined identifier `array` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmb91e1ue.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return \"\
    db\" + decimal.text.map!(a => a == '0' ? \"0\" : \"1\").joiner(\"\") + \"db\"\
    ;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp94k68o_u.d(31): Error: no property `text` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp94k68o_u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  int bin[] = new int[200];\n    int i = 0;\n    while (decimal != 0) {\n   \
    \     bin[i] = (int) (decimal % 2);\n        decimal = decimal / 2;\n        i++;\n\
    \    }\n    string bin_string = \"db\";\n    for (int j = i - 1; j >= 0; j--)\
    \ {\n        bin_string ~= bin[j];\n    }\n    bin_string ~= \"db\";\n    return\
    \ bin_string;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n  \
    \  assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptemovw5r.d(20): Deprecation: instead of C-style syntax, use D-style
    syntax `int[] bin`

    /tmp/tmptemovw5r.d(23): Error: C style cast illegal, use `cast(int)(decimal %
    2)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptemovw5r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string bin = \"db\";\n    while(decimal > 0)\n    {\n        bin += to!string(decimal\
    \ % 2);\n        decimal /= 2;\n    }\n    return bin ~ \"db\";\n}\n/*\nYou will\
    \ be given a number in decimal form and your task is to convert it to\n    hexadecimal\
    \ format. The function should return a string, with each character representing\
    \ a hexadecimal\n    number. Each character in the string will be '0'-'9' or 'a'-'f'.\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphn6gu025.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphn6gu025.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  //write your code here\n    string res = \"db\";\n    if (decimal == 0)\n \
    \       return res + \"0\" + \"db\";\n    for (; decimal > 0; decimal /= 2)\n\
    \        res = res + (char)(decimal % 2 + '0');\n    return res + \"db\";\n}\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpebtk_rwh.d(25): Error: C style cast illegal, use `cast(char)(decimal
    % 2 + ''0'')`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpebtk_rwh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  //\
    \ Convert to binary and remove the '0b' from the beginning\n  string binary =\
    \ to!string(decimal, 2)[2 .. $];\n  // Pad the string on the left with 0s until\
    \ we have 32 digits\n  return \"db\" ~ binary.rpad(32, '0') ~ \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_vxkpvqv.d(21): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmp_vxkpvqv.d(23): Error: no property `rpad` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_vxkpvqv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    while(decimal != 0)\n    {\n        binary +=\
    \ cast(char)(48 + (decimal % 2));\n        decimal /= 2;\n    }\n    binary +=\
    \ \"db\";\n    return binary;\n}\n/*\n    You will be given a string, in binary\
    \ format, representing a number\n    You will have to return this number as a\
    \ decimal.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp422rbl_1.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp422rbl_1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // Cast to uint64 to avoid the corner case of negative values.\n    ulong binary\
    \ = cast(ulong)decimal;\n    // The binary representation of decimal is reversed\
    \ in binary.\n    string result = \"db\";\n    while (binary > 0) {\n        result\
    \ ~= (binary & 1);\n        binary >>= 1;\n    }\n    result ~= \"db\";\n    return\
    \ result.dup.reverse;\n}\n/*\n    You will be given a string of characters, consisting\
    \ of binary characters.\n    The first and last characters will be 'db', which\
    \ you should ignore. The remaining characters\n    will be '0' or '1'.\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmdznfkxx.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmdznfkxx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    while(decimal > 0)\n    {\n        result ~= to!string(decimal%2);\n\
    \        decimal /= 2;\n    }\n    return \"db\" ~ reverse(result) ~ \"db\";\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm5muwx8.d(23): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpvm5muwx8.d(26): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm5muwx8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\n\
    \tstring binary = \"db\";\n\t\n\tif(decimal == 0)\n\t{\n\t\tbinary += \"0db\"\
    ;\n\t\treturn binary;\n\t}\n\t\n\tauto digits = 0;\n\t\n\twhile(pow(2, digits)\
    \ <= decimal)\n\t{\n\t\tdigits++;\n\t}\n\t\n\tdigits--;\n\t\n\twhile(digits >=\
    \ 0)\n\t{\n\t\tif(pow(2, digits) <= decimal)\n\t\t{\n\t\t\tbinary += \"1\";\n\t\
    \t\tdecimal -= pow(2, digits);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbinary += \"0\"\
    ;\n\t\t}\n\t\tdigits--;\n\t}\n\t\n\tbinary += \"db\";\n\t\n\treturn binary;\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpry08s5hd.d(25): Error: slice `binary` is not mutable

    /tmp/tmpry08s5hd.d(42): Error: slice `binary` is not mutable

    /tmp/tmpry08s5hd.d(47): Error: slice `binary` is not mutable

    /tmp/tmpry08s5hd.d(52): Error: slice `binary` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpry08s5hd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  enum L = long.sizeof;\n    // b = L * 8;\n    // char[L * 8 + 4] d_b;\n   \
    \ char[L * 8 + 4] d_b;\n    d_b[0..2] = \"db\";\n    d_b[$ - 2..$] = \"db\";\n\
    \    auto index = L * 8 - 1;\n    while (decimal)\n    {\n        d_b[index] =\
    \ (decimal & 1) ? '1' : '0';\n        decimal >>= 1;\n        index--;\n    }\n\
    \    return d_b.idup;\n}\n/*\nThe function should return the number of square\
    \ matrices that can be found\n    in the given matrix. A square matrix is a matrix\
    \ of which all rows and all columns have the same\n    length, and each cell has\
    \ the same distance as the others from the main diagonal.\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppexxzauy.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppexxzauy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    if (decimal == 0)\n        return binary + \"\
    0\" + binary;\n    while (decimal != 0) {\n        binary += (decimal % 2).to!string;\n\
    \        decimal /= 2;\n    }\n    return binary + \"db\";\n}\nunittest\n{\n \
    \   alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx557bnf7.d(22): Error: invalid array operation `binary + "0"` (possible
    missing [])

    /tmp/tmpx557bnf7.d(24): Error: no property `to` for type `long`

    /tmp/tmpx557bnf7.d(27): Error: invalid array operation `binary + "db"` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx557bnf7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  static const string db = \"db\";\n    string reverse_bitstring;\n    while\
    \ (decimal) {\n        reverse_bitstring ~= (decimal % 2) ? '1' : '0';\n     \
    \   decimal = decimal / 2;\n    }\n    return db ~ reverse_bitstring.dup.reverse\
    \ ~ db;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo8v96e56.d(26): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo8v96e56.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ret = \"db\";\n    while(decimal > 0) {\n        if(decimal % 2 == 0)\n\
    \            ret = \"0\" ~ ret;\n        else\n            ret = \"1\" ~ ret;\n\
    \        decimal /= 2;\n    }\n    ret ~= \"db\";\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzp0hubep.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f75]

    ??:? void tmpzp0hubep.__unittest_L31_C1() [0x427b85]

    ??:? void tmpzp0hubep.__modtest() [0x427cf8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c803]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b712]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fef1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fe7d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6e9]

    ??:? runModuleUnitTests [0x42c5d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \   string binary;\n     while(decimal)\n     {\n        binary = \"0\" ~ binary;\n\
    \        if(decimal & 1)\n        {\n            binary[0] = '1';\n        }\n\
    \        decimal >>= 1;\n     }\n     return \"db\" ~ binary ~ \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ag4jfcl.d(26): Error: cannot modify `immutable` expression `binary[0]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ag4jfcl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    string binary =\"db\";\n\tlong i = 0;\n\tlong tmp = decimal;\n\tlong remain =\
    \ 0;\n\tlong old = 0;\n\tlong count = 0;\n\t\n\twhile(tmp > 0)\n\t{\n\t\ttmp /=\
    \ 2;\n\t\tcount++;\n\t}\n\ttmp = decimal;\n\tif(tmp == 0)\n\t{\n\t\tbinary +=\
    \ \"0\";\n\t}\n\telse\n\t{\n\t\twhile(i < count)\n\t\t{\n\t\t\told = tmp;\n\t\t\
    \ttmp /= 2;\n\t\t\tremain = old - (tmp * 2);\n\t\t\tbinary += std.to!string(remain);\n\
    \t\t\ti++;\n\t\t}\n\t}\n\tbinary += \"db\";\n\treturn binary;\n}\nunittest\n{\n\
    \    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn3afy6j9.d(35): Error: slice `binary` is not mutable

    /tmp/tmpn3afy6j9.d(44): Error: undefined identifier `to` in package `std`

    /tmp/tmpn3afy6j9.d(48): Error: slice `binary` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn3afy6j9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  const char* format = \"db%db\";\n    string result = to!string(decimal, format);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp15r0fxky.d(21): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp15r0fxky.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return std.typecons.to!string(decimal,2);\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkdk_xolv.d(20): Error: undefined identifier `to` in module `std.typecons`,
    did you mean struct `No`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkdk_xolv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    return \"db\" ~ format!(\"%b\", decimal) ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmh30x48i.d(20): Error: template instance `format!("%b", decimal)`
    template `format` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmh30x48i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    while(decimal > 0) {\n        result ~= decimal\
    \ % 2;\n        decimal /= 2;\n    }\n    return result ~ \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl7hd2_v0.d(22): Error: cannot append type `long` to type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl7hd2_v0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    while(decimal > 0)\n    {\n        binary = (decimal %\
    \ 2).to!string + binary;\n        decimal /= 2;\n    }\n    binary = \"db\" ~\
    \ binary ~ \"db\";\n    return binary;\n}\nunittest\n{\n    alias candidate =\
    \ decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7t1m1n5i.d(23): Error: no property `to` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7t1m1n5i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  import std.range;\n    import std.algorithm;\n    return \"db\" ~ decimal.bitScanReverse.map!((a)\
    \ => a % 2).format(\"%s\").joiner(\"\").joiner(\"db\");\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_w2ozh86.d(22): Error: no property `bitScanReverse` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_w2ozh86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res = \"db\";\n    while(decimal>0)\n    {\n        long r = decimal%2;\n\
    \        res = format(\"%s%d\",res,r);\n        decimal /= 2;\n    }\n    return\
    \ format(\"%sdb\",reverse(res));\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_zyhww4h.d(24): Error: undefined identifier `format`

    /tmp/tmp_zyhww4h.d(27): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_zyhww4h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    string out = \"db\";\n\tif (decimal == 0)\n\t\treturn out + \"0\" + \"db\";\n\t\
    while (decimal != 0)\n\t{\n\t\tout += cast(char)((decimal & 1) + '0');\n\t\tdecimal\
    \ >>= 1;\n\t}\n\treverse(out);\n\treturn out + \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp41is4f9o.d(20): Error: found `out` when expecting `;` following
    statement

    /tmp/tmp41is4f9o.d(20): Error: found `=` instead of statement

    /tmp/tmp41is4f9o.d(22): Error: expression expected, not `out`

    /tmp/tmp41is4f9o.d(25): Error: found `out` instead of statement

    /tmp/tmp41is4f9o.d(28): Error: expression expected, not `out`

    /tmp/tmp41is4f9o.d(29): Error: expression expected, not `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp41is4f9o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    if (decimal == 0)\n        return binary + \"\
    0\" + binary;\n    while (decimal != 0)\n    {\n        if (decimal % 2 == 0)\n\
    \            binary += \"0\";\n        else\n            binary += \"1\";\n  \
    \      decimal /= 2;\n    }\n    binary += \"db\";\n    return binary;\n}\n/*\n\
    \    In this exercise, you will be given a non-empty string that represents a\
    \ positive integer.\n    You must return the string in its decimal form.\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjijterhe.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjijterhe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  /* read more on http://dlang.org/phobos/std_conv.html#.to!string */\n    return\
    \ \"db\" ~ to!string(decimal, \"b\") ~ \"db\";\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwersxrqm.d(21): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwersxrqm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    // TODO: Fill in this function\n    //\n    // NOTE: This\
    \ is really really easy to do in D.  For example:\n    //\n    // static assert(to!string(15L,\
    \ 2) == \"1111\");\n    // static assert(to!string(32L, 2) == \"100000\");\n \
    \   //\n    // This may help, if you think about it:\n    // http://www.digitalmars.com/d/2.0/phobos/std_conv.html#.to\n\
    \    //\n    // ALTERNATIVELY, if you are feeling obsessive compulsive, you\n\
    \    // can go ahead and use division and modulus, and push the\n    // correct\
    \ character ('0' or '1') onto a string or a dchar[]\n    // (which can be turned\
    \ into a string).\n    return \"db\" ~ result ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp06s0o71f.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ee5]

    ??:? void tmp06s0o71f.__unittest_L37_C1() [0x427af5]

    ??:? void tmp06s0o71f.__modtest() [0x427c68]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430064]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb41]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa75]

    ??:? runModuleUnitTests [0x42b965]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428334]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  import std.string;\n    auto s = to!string(decimal,2);\n    return \"db\" ~\
    \ s ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n  \
    \  assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpznuit2hq.d(21): Error: template instance `to!string` template `to`
    is not defined, did you mean tr(C1, C2, C3, C4 = immutable(char))(C1[] str, const(C2)[]
    from, const(C3)[] to, const(C4)[] modifiers = null)?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpznuit2hq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" ~ to!string(decimal,2) ~ \"db\";\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr2xy4h_x.d(20): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr2xy4h_x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164151
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res = \"db\";\n    if (decimal > 1)\n    {\n        while (decimal !=\
    \ 0)\n        {\n            if (decimal % 2 == 0)\n            {\n          \
    \      res ~= \"0\";\n            }\n            else\n            {\n       \
    \         res ~= \"1\";\n            }\n            decimal /= 2;\n        }\n\
    \    }\n    else\n    {\n        res ~= \"1\";\n    }\n    res ~= \"db\";\n  \
    \  return res.dup.reverse;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_u1um_qa.d(41): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_u1um_qa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    auto p = 2;\n    while(decimal > 0)\n    {\n \
    \       binary ~= (decimal % 2).to!string;\n        decimal /= 2;\n    }\n   \
    \ binary ~= \"db\";\n    return binary[$-2..$].dup.reverse;\n}\nunittest\n{\n\
    \    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc7ybsndo.d(24): Error: no property `to` for type `long`

    /tmp/tmpc7ybsndo.d(28): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc7ybsndo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  long temp = decimal;\n    string binary_string = \"db\";\n    int i = 0;\n\
    \    for(;;)\n    {\n        i++;\n        if(temp == 0) break;\n        if(temp%2\
    \ == 0) binary_string += \"0\";\n        else binary_string += \"1\";\n      \
    \  temp /= 2;\n    }\n    binary_string += \"db\";\n    return binary_string;\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpscoz8gf1.d(27): Error: slice `binary_string` is not mutable

    /tmp/tmpscoz8gf1.d(28): Error: slice `binary_string` is not mutable

    /tmp/tmpscoz8gf1.d(31): Error: slice `binary_string` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpscoz8gf1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // version 1\n    string result = \"db\";\n    long number = decimal;\n   \
    \ while (number > 0)\n    {\n        result = \"db\" ~ to!string(number % 2) ~\
    \ result;\n        number /= 2;\n    }\n    return result;\n    \n    // version\
    \ 2\n    //string result = \"db\";\n    //string bits = \"\";\n    //while (decimal\
    \ > 0)\n    //{\n    //    bits = to!string(decimal % 2) ~ bits;\n    //    decimal\
    \ /= 2;\n    //}\n    //return result ~ bits ~ \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvsw6l9uq.d(25): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvsw6l9uq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    long power = 0L;\n    long value = decimal;\n    while(value\
    \ > 0L)\n    {\n        result = (value % 2L == 0L ? \"0\" : \"1\") ~ result;\n\
    \        value = value / 2L;\n    }\n    return \"db\" ~ result ~ \"db\";\n}\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpizdj6o79.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f6d]

    ??:? void tmpizdj6o79.__unittest_L30_C1() [0x427b7d]

    ??:? void tmpizdj6o79.__modtest() [0x427cf0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd5f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ac6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc3d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300ec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbc9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac45]

    ??:? runModuleUnitTests [0x42bb35]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  \n    int size = 0;\n    ulong temp = decimal;\n    while(temp>0)\n    {\n\
    \        temp/=2;\n        size++;\n    }\n    string str;\n    string tempstr;\n\
    \    if(size==0)\n    {\n        str=\"db0db\";\n        return str;\n    }\n\
    \    for(int i=0;i<size;i++)\n    {\n        str~=decimal%2;\n        decimal/=2;\n\
    \    }\n    str~=\"db\";\n    for(int i=str.length-1;i>=0;i--)\n    {\n      \
    \  tempstr~=str[i];\n    }\n    return tempstr;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4w_o7qzp.d(37): Error: cannot append type `long` to type `string`

    /tmp/tmp4w_o7qzp.d(41): Error: cannot implicitly convert expression `str.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4w_o7qzp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    foreach(int;0..8)\n    {\n        result ~= to!string(decimal%2);\n\
    \        decimal /= 2;\n    }\n    return \"db\" ~ result ~ \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmputxcp0w5.d(21): Error: no identifier for declarator `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmputxcp0w5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return \"db\" + format(\"%b\", decimal) + \"db\";\n}\nunittest\n{\n    alias\
    \ candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n\
    \    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L) ==\
    \ \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdvay47hk.d(20): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdvay47hk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  auto result = \"db\";\n    for (; decimal != 0; decimal /= 2)\n    {\n    \
    \    result ~= (decimal % 2).to!string;\n    }\n    result ~= \"db\";\n    return\
    \ reverse(result);\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu92ykmy0.d(23): Error: no property `to` for type `long`

    /tmp/tmpu92ykmy0.d(26): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu92ykmy0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    long temp;\n    ulong maxULong = 2UL * (ulong.max\
    \ / 2) + 1;\n    do \n    {\n        temp = decimal;\n        decimal /= 2;\n\
    \        if(temp % 2 == 0) \n        {\n            result = '0' + result;\n \
    \       }\n        else \n        {\n            result = '1' + result;\n    \
    \    }\n    } while(decimal != 0);\n    return result ~ \"db\";\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3yfcot4l.d(29): Error: incompatible types for `(''0'') + (result)`:
    `char` and `string`

    /tmp/tmp3yfcot4l.d(33): Error: incompatible types for `(''1'') + (result)`: `char`
    and `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3yfcot4l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    while(decimal > 0) {\n        result ~= cast(char)(decimal\
    \ % 2 + 48);\n        decimal /= 2;\n    }\n    reverse(result);\n    result ~=\
    \ \"db\";\n    return result;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2m8sf_tx.d(25): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2m8sf_tx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    int res;\n    bool negative = false;\n    enum bool negative_true\
    \ = true;\n    if (decimal < 0) {\n        decimal = -decimal;\n        negative\
    \ = true;\n    }\n    while (decimal != 0) {\n        res = decimal % 2;\n   \
    \     decimal /= 2;\n        binary ~= to!string(res);\n    }\n    if (negative)\
    \ {\n        enum bool is_even = false;\n        binary ~= to!string(2);\n   \
    \     for (int i = 0; i < binary.length; i++) {\n            if (binary[i] ==\
    \ '0') {\n                binary[i] = '1';\n            } else {\n           \
    \     binary[i] = '0';\n            }\n            if (i == 0) {\n           \
    \     if (binary[i] == '0') {\n                    binary[i] = '1';\n        \
    \        } else {\n                    binary[i] = '0';\n                    is_even\
    \ = true;\n                }\n            }\n        }\n        if (is_even) {\n\
    \            binary ~= to!string(1);\n        } else {\n            binary ~=\
    \ to!string(0);\n        }\n    }\n    return \"db\" ~ binary.reverse ~ \"db\"\
    ;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt8o01o9r.d(31): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpt8o01o9r.d(35): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpt8o01o9r.d(38): Error: cannot modify `immutable` expression `binary[cast(ulong)i]`

    /tmp/tmpt8o01o9r.d(40): Error: cannot modify `immutable` expression `binary[cast(ulong)i]`

    /tmp/tmpt8o01o9r.d(44): Error: cannot modify `immutable` expression `binary[cast(ulong)i]`

    /tmp/tmpt8o01o9r.d(46): Error: cannot modify `immutable` expression `binary[cast(ulong)i]`

    /tmp/tmpt8o01o9r.d(47): Error: cannot modify constant `is_even`

    /tmp/tmpt8o01o9r.d(52): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpt8o01o9r.d(54): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpt8o01o9r.d(57): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/op'
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    for(; decimal != 0; decimal /= 2)\n    {\n        if(decimal\
    \ % 2 == 0)\n            binary ~= \"0\";\n        else\n            binary ~=\
    \ \"1\";\n    }\n    binary ~= \"db\";\n    binary = binary.reverse();\n    binary\
    \ = \"db\" ~ binary;\n    return binary;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpccmg27xc.d(29): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpccmg27xc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res = \"db\";\n    long digit = (decimal != 0) ? 1L : 0L;\n    while\
    \ (true)\n    {\n        digit *= 2;\n        res += \"0\";\n        if (digit\
    \ > decimal)\n            break;\n    }\n    res += \"1\";\n    decimal -= digit\
    \ / 2;\n    while (decimal != 0)\n    {\n        digit = (decimal != 0) ? 1L :\
    \ 0L;\n        while (true)\n        {\n            digit *= 2;\n            res\
    \ += \"0\";\n            if (digit > decimal)\n                break;\n      \
    \  }\n        res += \"1\";\n        decimal -= digit / 2;\n    }\n    return\
    \ res + \"db\";\n}\n/*\nYou will be given a binary string and your task is to\
    \ convert it to a decimal number.\n    You will return an integer.\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc195_bkl.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc195_bkl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  static string map = \"01\";\n    static char [] result;\n    int i = 0;\n \
    \   long remainder;\n    result = new char[65];\n    for (i = 0; i < 65; i++)\
    \ {\n        result[i] = '0';\n    }\n    result[0] = 'd';\n    result[1] = 'b';\n\
    \    i = 2;\n    while (decimal != 0) {\n        remainder = decimal % 2;\n  \
    \      decimal /= 2;\n        result[i] = map[remainder];\n        i++;\n    }\n\
    \    result[i] = 'd';\n    result[i + 1] = 'b';\n    result = result.take(i +\
    \ 2);\n    result = result.reverse;\n    return result.idup;\n}\nunittest\n{\n\
    \    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyplb9yvb.d(39): Error: no property `take` for type `char[]`

    /tmp/tmpyplb9yvb.d(40): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyplb9yvb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  static ubyte[] bin_b = \"db\";\n    static ubyte[] bin_0 = \"0\";\n    static\
    \ ubyte[] bin_1 = \"1\";\n    string binary;\n    int exponent = 0;\n    int multiplier\
    \ = 1;\n    bool bit = false;\n    binary ~= bin_b;\n    while( multiplier <=\
    \ decimal ) {\n        exponent++;\n        multiplier *= 2;\n    }\n    exponent--;\n\
    \    for( int i = exponent; i >= 0; i-- ) {\n        bit = false;\n        if(\
    \ (decimal / (int)pow(2, i)) >= 1 ) {\n            decimal -= (int)pow(2, i);\n\
    \            bit = true;\n        }\n        if( bit ) {\n            binary ~=\
    \ bin_1;\n        } else {\n            binary ~= bin_0;\n        }\n    }\n \
    \   binary ~= bin_b;\n    return binary;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyxgcndux.d(35): Error: C style cast illegal, use `cast(int)pow(2,
    i)`

    /tmp/tmpyxgcndux.d(36): Error: C style cast illegal, use `cast(int)pow(2, i)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyxgcndux.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  enum d2b = \"db\";\n    string output = \"\";\n    ulong uDecimal = cast(ulong)decimal;\n\
    \    while(uDecimal != 0)\n    {\n        output = \"01\"[uDecimal & 1] ~ output;\n\
    \        uDecimal >>= 1;\n    }\n    if(output.length > 0)\n        return d2b\
    \ ~ output ~ d2b;\n    else\n        return d2b ~ \"0\" ~ d2b;\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary(decimal.stringof);\n    binary = binary.replace(\"0\",\"db0\"\
    );\n    binary = binary.replace(\"1\",\"db1\");\n    binary = binary.replace(\"\
    2\",\"db10\");\n    binary = binary.replace(\"3\",\"db11\");\n    binary = binary.replace(\"\
    4\",\"db100\");\n    binary = binary.replace(\"5\",\"db101\");\n    binary = binary.replace(\"\
    6\",\"db110\");\n    binary = binary.replace(\"7\",\"db111\");\n    binary = binary.replace(\"\
    8\",\"db1000\");\n    binary = binary.replace(\"9\",\"db1001\");\n    return binary;\n\
    }\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhxf08t9.d(20): Error: `decimal.stringof` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhxf08t9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    if (decimal == 0) return binary + \"0\" + binary;\n\
    \    long n = 2;\n    for (n = 2; n < decimal; n*=2);\n    if (n != decimal) n\
    \ /= 2;\n    while (n > 0) {\n        if (decimal >= n) {\n            binary\
    \ += \"1\";\n            decimal -= n;\n        } else {\n            binary +=\
    \ \"0\";\n        }\n        n /= 2;\n    }\n    return binary + binary;\n}\n\
    /*\nYou will be given a string and your task is to return a tuple containing\n\
    \    three strings, in the order:\n        - the input string with the first character\
    \ capitalized\n        - the input string in reverse\n        - the input string\
    \ in uppercase\n*/\ntuple(string, string, string) mixed_case(string input)\n{\n\
    \    return tuple(\n        input[0].uppercased ~ input[1..$],\n        input[$..0],\n\
    \        input.toUpper\n    );\n}\n/*\nCreate a function that takes a string (word)\
    \ and a string (sentence), and returns\n    a string. The function should capitalize\
    \ the first letter of each word in the sentence,\n    and return the resulting\
    \ sentence.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdhm9puqn.d(23): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmpdhm9puqn.d(43): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpdhm9puqn.d(43): Error: no identifier for declarator `tuple(string, string,
    string)`

    /tmp/tmpdhm9puqn.d(43): Error: semicolon expected following function declaration

    /tmp/tmpdhm9puqn.d(43): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpdhm9puqn.d(44): Error: no identifier for declarator `mixed_case(string
    input)`

    /tmp/tmpdhm9puqn.d(51): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdhm9puqn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  bool negative = decimal < 0L;\n    if (negative) decimal = -decimal;\n    auto\
    \ digits = new string;\n    while (decimal > 0L) {\n        digits ~= (decimal\
    \ & 1L) ? '1' : '0';\n        decimal = decimal >> 1L;\n    }\n    digits = digits.reverse;\n\
    \    if (negative) digits ~= '1';\n    else digits ~= '0';\n    auto padding =\
    \ 8 - digits.length;\n    if (padding > 0) digits = '0'.repeat(padding) ~ digits;\n\
    \    return \"db\" ~ digits ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1dgrcaie.d(22): Error: new can only create structs, dynamic arrays
    or class objects, not `string`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1dgrcaie.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ret = \"db\";\n    while(decimal)\n    {\n        ret ~= cast(char)((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    ret ~= \"db\";\n    return ret.dup.mirror;\n\
    }\n/*\nYou will be given a string consisting of letters a-z (in random case),\
    \ numbers and the\n    question mark symbol.\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb085qaxt.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb085qaxt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    bool isNegative = decimal < 0;\n    decimal =\
    \ abs(decimal);\n    if (decimal == 0)\n        return \"db0db\";\n    while (decimal\
    \ > 0)\n    {\n        result ~= (decimal & 1) ? \"1\" : \"0\";\n        decimal\
    \ >>= 1;\n    }\n    if (isNegative)\n        result ~= \"1\";\n    else\n   \
    \     result ~= \"0\";\n    return std.algorithm.reverse(result) ~ \"db\";\n}\n\
    unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmd1v2w0m.d(34): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmd1v2w0m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    binary.append(\"db\");\n    while(decimal > 0)\n    {\n\
    \        if(decimal%2 == 0)\n        {\n            binary.append(\"0\");\n  \
    \      }\n        else\n        {\n            binary.append(\"1\");\n       \
    \ }\n        decimal /= 2;\n    }\n    binary.append(\"db\");\n    binary = binary.dup.reverse;\n\
    \    return binary;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8tv9ukpj.d(21): Error: no property `append` for type `string`

    /tmp/tmp8tv9ukpj.d(26): Error: no property `append` for type `string`

    /tmp/tmp8tv9ukpj.d(30): Error: no property `append` for type `string`

    /tmp/tmp8tv9ukpj.d(34): Error: no property `append` for type `string`

    /tmp/tmp8tv9ukpj.d(35): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8tv9ukpj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  //\
    \  5  0\n  // 3  2\n  // 2  1\n  // 1  0\n  string binary;\n  for(int i = 0; i\
    \ < decimal.sizeof * 8; i++)\n  {\n      binary ~= decimal & 1;\n      decimal\
    \ = decimal >> 1;\n  }\n  // Reverse the string.\n  binary = binary.dup.reverse;\n\
    \  return \"db\" ~ binary ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpisp0e406.d(31): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpisp0e406.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  //your code here\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjwurpdpo.d(18): Error: function `tmpjwurpdpo.decimal_to_binary`
    has no `return` statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjwurpdpo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    bool is_a_one = false;\n    if (decimal == 0)\
    \ {\n        result = \"db0db\";\n    }\n    while (decimal != 0) {\n        if\
    \ (decimal % 2 == 1) {\n            is_a_one = true;\n            result = \"\
    1\" ~ result;\n        } else {\n            if (is_a_one) {\n               \
    \ result = \"0\" ~ result;\n            }\n        }\n        decimal /= 2;\n\
    \    }\n    return result ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp060z3zas.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x427fad]

    ??:? void tmp060z3zas.__unittest_L38_C1() [0x427bb9]

    ??:? void tmp060z3zas.__modtest() [0x427d2c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd9f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42acae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc7d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43012c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc09]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac85]

    ??:? runModuleUnitTests [0x42bb75]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string rs = \"db\";\n    if (decimal == 0) return rs + \"0\" + rs;\n    long\
    \ m = decimal;\n    while (m != 0)\n    {\n        int i = m % 2;\n        rs\
    \ = (i == 0) ? \"0\" + rs : \"1\" + rs;\n        m = m / 2;\n    }\n    return\
    \ rs + rs;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbtm9kmph.d(21): Error: invalid array operation `rs + "0"` (possible
    missing [])

    /tmp/tmpbtm9kmph.d(26): Error: invalid array operation `"0" + rs` (possible missing
    [])

    /tmp/tmpbtm9kmph.d(26): Error: invalid array operation `"1" + rs` (possible missing
    [])

    /tmp/tmpbtm9kmph.d(29): Error: invalid array operation `rs + rs` (possible missing
    [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbtm9kmph.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  \n    string binary = \"db\";\n    while(decimal != 0)\n    {\n        if(decimal\
    \ % 2 == 0)\n        {\n            binary += \"0\";\n        }\n        else\n\
    \        {\n            binary += \"1\";\n        }\n        decimal /= 2;\n \
    \   }\n    binary += \"db\";\n    return binary;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdfk1pnle.d(26): Error: slice `binary` is not mutable

    /tmp/tmpdfk1pnle.d(30): Error: slice `binary` is not mutable

    /tmp/tmpdfk1pnle.d(34): Error: slice `binary` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdfk1pnle.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result;\n    int i = 0;\n    while(decimal > 0)\n    {\n        int\
    \ x = decimal % 2;\n        if(x == 0)\n            result = \"0\" ~ result;\n\
    \        else\n            result = \"1\" ~ result;\n        decimal /= 2;\n \
    \   }\n    while(i < 4)\n    {\n        result = \"0\" ~ result;\n        i++;\n\
    \    }\n    return \"db\" ~ result ~ \"db\";\n}\n/*\nWrite a function that takes\
    \ a string and a character, and returns the number of occurences of\n    the character\
    \ in the string.\n    Examples:\n    >>> count_characters(\"The quick brown fox\
    \ jumps over the lazy dog\", 'o')\n    2\n    >>> count_characters(\"The quick\
    \ brown fox jumps over the lazy dog\", 'q')\n    1\n    >>> count_characters(\"\
    The quick brown fox jumps over the lazy dog\", '?')\n    0\n*/\nunittest\n{\n\
    \    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1n5urp4b.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x427fd5]

    ??:? void tmp1n5urp4b.__unittest_L49_C1() [0x427be5]

    ??:? void tmp1n5urp4b.__modtest() [0x427d58]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bdc7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42acd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430154]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc31]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42acad]

    ??:? runModuleUnitTests [0x42bb9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428424]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  //TO DO: Write the function that converts decimal to binary\n    return \"\"\
    ;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwib38_7o.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ea5]

    ??:? void tmpwib38_7o.__unittest_L23_C1() [0x427ab5]

    ??:? void tmpwib38_7o.__modtest() [0x427c28]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb4f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb75]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430024]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb01]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa35]

    ??:? runModuleUnitTests [0x42b925]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string ret = \"db\";\n    while(decimal > 0) {\n        long temp = decimal\
    \ / 2;\n        ret ~= to!string(decimal - 2 * temp);\n        decimal = temp;\n\
    \    }\n    ret ~= \"db\";\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps96amjdm.d(23): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps96amjdm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  enum\
    \ binary = {'0', '1'};\n  auto i = decimal;\n  string bin;\n  while(i>0)\n  {\n\
    \    int rem = i%2;\n    bin ~= binary[rem];\n    i/=2;\n  }\n  return \"db\"\
    \ ~ bin.reverse ~ \"db\";\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvvnc7mjy.d(20): Error: cannot infer type from struct initializer

    /tmp/tmpvvnc7mjy.d(29): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvvnc7mjy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  static char[] bin_form = [ '0', '1' ];\n    static char[] db = \"db\";\n  \
    \  char[] result;\n    int index;\n    long[size_t] results;\n    size_t i;\n\
    \    long current;\n    int temp;\n    while (decimal > 0) {\n        results\
    \ ~= decimal % 2;\n        decimal /= 2;\n    }\n    result.length = results.length\
    \ + 2;\n    result[] = db;\n    foreach (i, current; results) {\n        result[result.length\
    \ - i - 1] = bin_form[current];\n    }\n    result[result.length - 1] = db[1];\n\
    \    return result.idup;\n}\n/*\nAs a soldier you are obliged to die for your\
    \ country. Your death rate will be calculated as a number\n    between 0-1, 0\
    \ means you are alive, 1 means you are dead. This number is calculated by the\n\
    \    following formula:\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcqgwzxrz.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqgwzxrz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    while(decimal != 0)\n    {\n        binary +=\
    \ to!string(decimal % 2);\n        decimal /= 2;\n    }\n    reverse(binary.begin()\
    \ + 2, binary.end());\n    binary += \"db\";\n    return binary;\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvgmxnb4e.d(23): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpvgmxnb4e.d(26): Error: no property `begin` for type `string`

    /tmp/tmpvgmxnb4e.d(26): Error: no property `end` for type `string`

    /tmp/tmpvgmxnb4e.d(27): Error: slice `binary` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvgmxnb4e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    enum binaryEnum = \"01\";\n    while(decimal > 0)\n   \
    \ {\n        binary ~= binaryEnum[decimal % 2];\n        decimal /= 2;\n    }\n\
    \    return \"db\" ~ binary.reverse ~ \"db\";\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsnfg8e3n.d(27): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsnfg8e3n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  return format(\"db%sdb\", std.math.toBinaryString(decimal));\n}\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm6s4w6yy.d(20): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm6s4w6yy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164152
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n\t\
    string res;\n\tres = \"db\";\n\tint i = 0;\n\twhile (decimal > 0)\n\t{\n\t\tres\
    \ += to!string(decimal % 2);\n\t\tdecimal /= 2;\n\t}\n\t\n\tres += \"db\";\n\t\
    \n\tres = res.dup.reverse;\n\t\n\treturn res;\n}\n/*\nYou will be given a string\
    \ and you need to convert it to a decimal number. The string will contain\n  \
    \  binary numbers (0 and 1). Your function should return an int.\nunittest\n{\n\
    \    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\"\
    );\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnirj1v0m.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnirj1v0m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    while(decimal != 0) {\n        binary ~= (decimal\
    \ % 2).to!string;\n        decimal /= 2;\n    }\n    binary ~= \"db\";\n    return\
    \ binary.dup.reverse;\n}\n/*\nYou will be given a binary number in the form of\
    \ a string.\n    The string will have the characters 'db' at the beginning and\
    \ at the end,\n    and each character inside the string will be either '0' or\
    \ '1'. The function must return the number\n    in decimal format.\nunittest\n\
    {\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L) == \"\
    db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpll8vbz_e.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpll8vbz_e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  // long bits = (sizeof(long) * 8);\n    long bits = 64;\n    // long bits =\
    \ 4;\n    // long bits = 64;\n    string ret_val = \"db\";\n    for (long i =\
    \ 0; i < bits; i++) {\n        // ret_val ~= (((decimal & 0x8000000000000000UL)\
    \ != 0UL) ? \"1\" : \"0\");\n        ret_val ~= (((decimal & (0x1UL << (bits -\
    \ i - 1))) != 0UL) ? \"1\" : \"0\");\n        // ret_val ~= (((decimal & 0x1UL)\
    \ != 0UL) ? \"1\" : \"0\");\n        // decimal = decimal >> 1;\n    }\n    ret_val\
    \ ~= \"db\";\n    return ret_val;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp77_2hab8.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f55]

    ??:? void tmp77_2hab8.__unittest_L34_C1() [0x427b61]

    ??:? void tmp77_2hab8.__modtest() [0x427cd4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5aa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fed1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430380]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fe5d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b581]

    ??:? runModuleUnitTests [0x42c471]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary;\n    binary ~= \"db\";\n    if (decimal == 0)\n    {\n     \
    \   binary ~= \"0\";\n    }\n    else\n    {\n        long i = decimal;\n    \
    \    while (i != 0)\n        {\n            binary ~= to!string(i % 2);\n    \
    \        i /= 2;\n        }\n    }\n    binary ~= \"db\";\n    binary = binary.dup.reverse;\n\
    \    return binary;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3yzxaioq.d(31): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmp3yzxaioq.d(36): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3yzxaioq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string bin = \"db\";\n    while(decimal>1)\n    {\n        bin += decimal%2.to!string;\n\
    \        decimal /= 2;\n    }\n    bin += decimal.to!string;\n    bin += \"db\"\
    ;\n    return bin;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3ube0xsm.d(23): Error: no property `to` for type `int`

    /tmp/tmp3ube0xsm.d(26): Error: no property `to` for type `long`

    /tmp/tmp3ube0xsm.d(27): Error: slice `bin` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3ube0xsm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string binary = \"db\";\n    while(decimal != 0) {\n        int temp = decimal\
    \ % 2;\n        binary = to!string(temp) ~ binary;\n        decimal /= 2;\n  \
    \  }\n    binary ~= \"db\";\n    return binary;\n}\nunittest\n{\n    alias candidate\
    \ = decimal_to_binary;\n\n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L)\
    \ == \"db100000db\");\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6nbqfcih.d(23): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6nbqfcih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  long binary = 0;\n    int base = 1;\n    int rem;\n    string str;\n    while\
    \ (decimal > 0) {\n        rem = decimal % 2;\n        binary = binary + rem *\
    \ base;\n        decimal = decimal / 2;\n        base = base * 10;\n    }\n  \
    \  string bin = to!string(binary);\n    str = \"db\" ~ bin ~ \"db\";\n    return\
    \ str;\n}\n/*\nIn a temple there are N bells that ring at regularly spaced time\
    \ intervals throughout the day.\nunittest\n{\n    alias candidate = decimal_to_binary;\n\
    \n    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9j75y3lf.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9j75y3lf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string res = \"db\";\n    while(decimal > 0)\n    {\n        res ~= cast(char)(decimal\
    \ % 2);\n        decimal /= 2;\n    }\n    reverse(res);\n    res ~= \"db\";\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n\
    \    assert(candidate(0L) == \"db0db\");\n    assert(candidate(32L) == \"db100000db\"\
    );\n    assert(candidate(103L) == \"db1100111db\");\n    assert(candidate(15L)\
    \ == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpilaszan8.d(26): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpilaszan8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number\
    \ in decimal form and your task is to convert it to\n    binary format. The function\
    \ should return a string, with each character representing a binary\n    number.\
    \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n \
    \   The extra characters are there to help with the format.\n\n    Examples:\n\
    \    >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
    \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n{\n  \
    \  string result = \"db\";\n    int num = cast(int)decimal;\n    while(num > 0)\n\
    \    {\n        result ~= num % 2;\n        num /= 2;\n    }\n    // \u7FFB\u8F6C\
    \u5B57\u7B26\u4E32\n    result = reverse(result);\n    return result ~ \"db\"\
    ;\n}\nunittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
    \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
    \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjvgpvqb8.d(28): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjvgpvqb8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164153
