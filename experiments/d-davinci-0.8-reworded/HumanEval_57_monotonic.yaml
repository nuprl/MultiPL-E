name: HumanEval_57_monotonic
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
  \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n\
  \    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
  \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n"
tests: "unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
  \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n \
  \   assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
  \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
  \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
completions: ["{\n    return (l[1..$].zip(l[0..$-1]).every!((a, b) => a > b || a <\
    \ b));\n}\n/*\nThis function reads numbers from a file and writes it back to a\
    \ file. It is based on\nstd.algorithm.map to transform it to a new range.\n*/",
  "{\n    bool found = false;\n    foreach(int i, long e; l) \n    {\n        if (i\
    \ != 0 && l[i - 1] != e) \n        {\n            if (found) \n            {\n\
    \                return false;\n            }\n            found = true;\n   \
    \     }\n    }\n    return true;\n}", "  pure nothrow @safe\n{\n  if (l.length\
    \ <= 1) return true;\n  bool increasing = true;\n  bool decreasing = true;\n \
    \ foreach (i, e; l[1..$])\n  {\n    if (e < l[i - 1]) increasing = false;\n  \
    \  if (e > l[i - 1]) decreasing = false;\n  }\n  return increasing || decreasing;\n\
    }\n/*\n{\n    return (l.length <= 1) ||\n        (l[0] < l[1] && monotonic(l[1..$]))\
    \ ||\n        (l[0] > l[1] && monotonic(l[1..$]));\n}\n*/", "{\n    if (l.length\
    \ > 1)\n    {\n      long[] ll;\n      ll[] = l[0..l.length-1];\n      long[]\
    \ lr;\n      lr[] = l[1..l.length];\n      if (all!(a => b => a <= b)(ll[], lr[]))\n\
    \      {\n          if (all!(a => b => a >= b)(ll[], lr[]))\n          {\n   \
    \           return true;\n          }\n      }\n    }\n    return false;\n}",
  "in \n{\n    return l.length == 0 || \n    (!all!(i => l[i] <= l[i + 1]) && !all!(i\
    \ => l[i] >= l[i + 1]));\n}", "{\n    auto direction = 0;\n    foreach (i, ref\
    \ a; l) {\n        if (i == 0) {\n            continue;\n        }\n        if\
    \ (direction == 0) {\n            if (a > l[i - 1]) {\n                direction\
    \ = 1;\n            } else if (a < l[i - 1]) {\n                direction = -1;\n\
    \            }\n        } else if (direction == 1) {\n            if (a < l[i\
    \ - 1]) {\n                return false;\n            }\n        } else if (direction\
    \ == -1) {\n            if (a > l[i - 1]) {\n                return false;\n \
    \           }\n        }\n    }\n    return true;\n}", "{\n    auto res = zip(l[0\
    \ .. $ - 1], l[1 .. $]);\n    foreach(res; (long a, long b))\n    {\n        if\
    \ (a < b)\n        {\n            long[] temp_l;\n            foreach(res; (long\
    \ a, long b))\n            {\n                if (a > b)\n                {\n\
    \                    return false;\n                }\n            }\n       \
    \     return true;\n        }\n        else if (a > b)\n        {\n          \
    \  long[] temp_l;\n            foreach(res; (long a, long b))\n            {\n\
    \                if (a < b)\n                {\n                    return false;\n\
    \                }\n            }\n            return true;\n        }\n    }\n\
    \    return true;\n}", "{\n    return isMonotonic(l[], (a, b) => a < b) ||\n \
    \          isMonotonic(l[], (a, b) => a > b);\n}\n ", "{\n    return isMonotonic(l);\n\
    }", "{\n    return is(typeof(l[]) == long[]);\n}\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    true\n    >>> monotonic([1, 20, 4, 10])\n    false\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    true\n    \n*/", "{\n    if(l.length < 2) \n    {\n       \
    \ return true;\n    } \n    else if(l[0] > l[1]) \n    {\n        auto flag =\
    \ true;\n        foreach(index, val; l) \n        {\n            if(index > 0)\
    \ \n            {\n                if(l[index - 1] > l[index]) \n            \
    \    {\n                    flag = true;\n                } \n               \
    \ else \n                {\n                    flag = false;\n              \
    \      break;\n                }\n            }\n        }\n        return flag;\n\
    \    } \n    else \n    {\n        auto flag = true;\n        foreach(index, val;\
    \ l) \n        {\n            if(index > 0) \n            {\n                if(l[index\
    \ - 1] < l[index]) \n                {\n                    flag = true;\n   \
    \             } \n                else \n                {\n                 \
    \   flag = false;\n                    break;\n                }\n           \
    \ }\n        }\n        return flag;\n    }\n}", "{\n\tbool inc = true;\n\tbool\
    \ dec = true;\n\t\n\tfor (int i = 0; i < l.length - 1; i++)\n\t{\n\t\tif (l[i]\
    \ > l[i + 1])\n\t\t{\n\t\t\tinc = false;\n\t\t}\n\t\tif (l[i] < l[i + 1])\n\t\t\
    {\n\t\t\tdec = false;\n\t\t}\n\t}\n\t\n\treturn inc || dec;\n}", "{\n\tif (l.length\
    \ <= 1) \n\t{\n\t\treturn true;\n\t}\n\t\n\timmutable inc = is(typeof(l[0]) ==\
    \ long);\n\tauto prev = l[0];\n\tforeach (cur; l[1 .. $]) \n\t{\n\t\tif (inc)\
    \ \n\t\t{\n\t\t\tif (cur < prev)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\
    } \n\t\telse \n\t\t{\n\t\t\tif (cur > prev)\n\t\t\t{\n\t\t\t\treturn false;\n\t\
    \t\t}\n\t\t}\n\t\tprev = cur;\n\t}\n\treturn true;\n}\n/*\nReturn the relative\
    \ height of pixels.\n    >>> heightmap([0, 1, 0, 2, 0, 2, 0, 1, 0])\n    [1, 0,\
    \ 1, 0, 1, 0, 1, 0, 1]\n    >>> heightmap([0, 1, 0, 2, 0, 2, 0, 1, 0])\n    [1,\
    \ 0, 1, 0, 1, 0, 1, 0, 1]\n*/\nlong[] heightmap(long[] ls) \n{\n\tlong[] res;\n\
    \tres.length = ls.length;\n\tforeach (immutable i, cur; ls) \n\t{\n\t\tres[i]\
    \ = cur;\n\t\tif (i > 0) \n\t\t{\n\t\t\tif (ls[i - 1] >= cur) \n\t\t\t{\n\t\t\t\
    \tres[i] = ls[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n/*\nReturn a\
    \ list of pixels representing a mountain.\n    >>> mountain(2, 3)\n    [1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> mountain(2, 3, peak_type='inverted_v')\n\
    \    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> mountain(2, 3, peak_type='sp",
  "{\n    return monotonic(map!((x) => x[0])(l.zip(l[1..$])));\n}\n/*\nReturn true\
    \ is array elements are monotonically increasing or decreasing.\n    >>> monotonic([0,\
    \ 0, 0, 0])\n    true\n    >>> monotonic([1, 2, 4, 20])\n    true\n    >>> monotonic([1,\
    \ 20, 4, 10])\n    false\n    >>> monotonic([4, 1, 0, -10])\n    true\n    \n\
    */", "{\n  bool cmp_asc = true;\n  bool cmp_desc = true;\n  bool cmp = true;\n\
    \  long prev;\n  foreach(index, elem; l)\n  {\n    if(index == 0)\n    {\n   \
    \   prev = elem;\n      continue;\n    }\n    cmp_asc &= elem > prev;\n    cmp_desc\
    \ &= elem < prev;\n    prev = elem;\n  }\n  cmp = cmp_asc | cmp_desc;\n  return\
    \ cmp;\n}", "{\n    return (l[$-1] > l[0]) == all!((l[0] > a) => (a))(l);\n}\n\
    \ \n/*\nReturn true if array elements are strictly increasing.\n    >>> strictly_increasing([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> strictly_increasing([1L, 20L, 4L, 10L])\n \
    \   false\n    >>> strictly_increasing([4L, 1L, 0L, -10L])\n    false\n    \n\
    */", "{\n\tint count1=0;\n\tint count2=0;\n\tforeach(i; 1..l.length) \n\t{\n\t\
    \tif(l[i]>l[i-1])\n\t\t\tcount1++;\n\t\telse if(l[i]<l[i-1])\n\t\t\tcount2++;\n\
    \t}\n\tif(count1==0||count2==0)\n\t\treturn true;\n\telse\n\t\treturn false;\n\
    }", "{\n    if (l.length<2) return true;\n    enum bool increasing = l[0]<l[1];\n\
    \    for (long n=2; n<l.length; n++) {\n        if (increasing) {\n          \
    \  if (l[n-1]>l[n]) return false;\n        } else {\n            if (l[n-1]<l[n])\
    \ return false;\n        }\n    }\n    return true;\n}\n \n/*\nReturn true if\
    \ array is sorted.\n    >>> sorted([1L, 2L, 3L, 4L])\n    true\n    >>> sorted([-9L,\
    \ 10L, 100L, 4L])\n    false\n    >>> sorted([1L, 4L, 0L, -10L])\n    false\n\
    */", "{\n    bool increasing = true;\n    bool decreasing = true;\n    for (long\
    \ i = 1; i < l.length; i++) {\n        if (l[i - 1] > l[i]) {\n            increasing\
    \ = false;\n        }\n        if (l[i - 1] < l[i]) {\n            decreasing\
    \ = false;\n        }\n    }\n    return increasing || decreasing;\n}\n/*\nReturn\
    \ true if the longest monotonic subsequence of the array is increasing.\n    >>>\
    \ monotonic_increasing([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n\
    \    false\n    \n*/", "{\n    auto prev = l[0];\n    auto increasing = true;\n\
    \    auto decreasing = true;\n    for (auto current : l[1..$]) \n    {\n     \
    \   if (current > prev) \n        {\n            decreasing = false;\n       \
    \ }\n        else if (current < prev) \n        {\n            increasing = false;\n\
    \        }\n        prev = current;\n    }\n    return increasing || decreasing;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
