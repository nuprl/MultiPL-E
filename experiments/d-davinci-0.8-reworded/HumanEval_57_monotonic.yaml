name: HumanEval_57_monotonic
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
  \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n\
  \    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
  \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n"
tests: "unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
  \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n \
  \   assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
  \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
  \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
completions: ["{\n    return (l[1..$].zip(l[0..$-1]).every!((a, b) => a > b || a <\
    \ b));\n}\n/*\nThis function reads numbers from a file and writes it back to a\
    \ file. It is based on\nstd.algorithm.map to transform it to a new range.\n*/",
  "{\n    bool found = false;\n    foreach(int i, long e; l) \n    {\n        if (i\
    \ != 0 && l[i - 1] != e) \n        {\n            if (found) \n            {\n\
    \                return false;\n            }\n            found = true;\n   \
    \     }\n    }\n    return true;\n}", "  pure nothrow @safe\n{\n  if (l.length\
    \ <= 1) return true;\n  bool increasing = true;\n  bool decreasing = true;\n \
    \ foreach (i, e; l[1..$])\n  {\n    if (e < l[i - 1]) increasing = false;\n  \
    \  if (e > l[i - 1]) decreasing = false;\n  }\n  return increasing || decreasing;\n\
    }\n/*\n{\n    return (l.length <= 1) ||\n        (l[0] < l[1] && monotonic(l[1..$]))\
    \ ||\n        (l[0] > l[1] && monotonic(l[1..$]));\n}\n*/", "{\n    if (l.length\
    \ > 1)\n    {\n      long[] ll;\n      ll[] = l[0..l.length-1];\n      long[]\
    \ lr;\n      lr[] = l[1..l.length];\n      if (all!(a => b => a <= b)(ll[], lr[]))\n\
    \      {\n          if (all!(a => b => a >= b)(ll[], lr[]))\n          {\n   \
    \           return true;\n          }\n      }\n    }\n    return false;\n}",
  "in \n{\n    return l.length == 0 || \n    (!all!(i => l[i] <= l[i + 1]) && !all!(i\
    \ => l[i] >= l[i + 1]));\n}", "{\n    auto direction = 0;\n    foreach (i, ref\
    \ a; l) {\n        if (i == 0) {\n            continue;\n        }\n        if\
    \ (direction == 0) {\n            if (a > l[i - 1]) {\n                direction\
    \ = 1;\n            } else if (a < l[i - 1]) {\n                direction = -1;\n\
    \            }\n        } else if (direction == 1) {\n            if (a < l[i\
    \ - 1]) {\n                return false;\n            }\n        } else if (direction\
    \ == -1) {\n            if (a > l[i - 1]) {\n                return false;\n \
    \           }\n        }\n    }\n    return true;\n}", "{\n    auto res = zip(l[0\
    \ .. $ - 1], l[1 .. $]);\n    foreach(res; (long a, long b))\n    {\n        if\
    \ (a < b)\n        {\n            long[] temp_l;\n            foreach(res; (long\
    \ a, long b))\n            {\n                if (a > b)\n                {\n\
    \                    return false;\n                }\n            }\n       \
    \     return true;\n        }\n        else if (a > b)\n        {\n          \
    \  long[] temp_l;\n            foreach(res; (long a, long b))\n            {\n\
    \                if (a < b)\n                {\n                    return false;\n\
    \                }\n            }\n            return true;\n        }\n    }\n\
    \    return true;\n}", "{\n    return isMonotonic(l[], (a, b) => a < b) ||\n \
    \          isMonotonic(l[], (a, b) => a > b);\n}\n ", "{\n    return isMonotonic(l);\n\
    }", "{\n    return is(typeof(l[]) == long[]);\n}\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    true\n    >>> monotonic([1, 20, 4, 10])\n    false\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    true\n    \n*/", "{\n    if(l.length < 2) \n    {\n       \
    \ return true;\n    } \n    else if(l[0] > l[1]) \n    {\n        auto flag =\
    \ true;\n        foreach(index, val; l) \n        {\n            if(index > 0)\
    \ \n            {\n                if(l[index - 1] > l[index]) \n            \
    \    {\n                    flag = true;\n                } \n               \
    \ else \n                {\n                    flag = false;\n              \
    \      break;\n                }\n            }\n        }\n        return flag;\n\
    \    } \n    else \n    {\n        auto flag = true;\n        foreach(index, val;\
    \ l) \n        {\n            if(index > 0) \n            {\n                if(l[index\
    \ - 1] < l[index]) \n                {\n                    flag = true;\n   \
    \             } \n                else \n                {\n                 \
    \   flag = false;\n                    break;\n                }\n           \
    \ }\n        }\n        return flag;\n    }\n}", "{\n\tbool inc = true;\n\tbool\
    \ dec = true;\n\t\n\tfor (int i = 0; i < l.length - 1; i++)\n\t{\n\t\tif (l[i]\
    \ > l[i + 1])\n\t\t{\n\t\t\tinc = false;\n\t\t}\n\t\tif (l[i] < l[i + 1])\n\t\t\
    {\n\t\t\tdec = false;\n\t\t}\n\t}\n\t\n\treturn inc || dec;\n}", "{\n\tif (l.length\
    \ <= 1) \n\t{\n\t\treturn true;\n\t}\n\t\n\timmutable inc = is(typeof(l[0]) ==\
    \ long);\n\tauto prev = l[0];\n\tforeach (cur; l[1 .. $]) \n\t{\n\t\tif (inc)\
    \ \n\t\t{\n\t\t\tif (cur < prev)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\
    } \n\t\telse \n\t\t{\n\t\t\tif (cur > prev)\n\t\t\t{\n\t\t\t\treturn false;\n\t\
    \t\t}\n\t\t}\n\t\tprev = cur;\n\t}\n\treturn true;\n}\n/*\nReturn the relative\
    \ height of pixels.\n    >>> heightmap([0, 1, 0, 2, 0, 2, 0, 1, 0])\n    [1, 0,\
    \ 1, 0, 1, 0, 1, 0, 1]\n    >>> heightmap([0, 1, 0, 2, 0, 2, 0, 1, 0])\n    [1,\
    \ 0, 1, 0, 1, 0, 1, 0, 1]\n*/\nlong[] heightmap(long[] ls) \n{\n\tlong[] res;\n\
    \tres.length = ls.length;\n\tforeach (immutable i, cur; ls) \n\t{\n\t\tres[i]\
    \ = cur;\n\t\tif (i > 0) \n\t\t{\n\t\t\tif (ls[i - 1] >= cur) \n\t\t\t{\n\t\t\t\
    \tres[i] = ls[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n/*\nReturn a\
    \ list of pixels representing a mountain.\n    >>> mountain(2, 3)\n    [1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> mountain(2, 3, peak_type='inverted_v')\n\
    \    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> mountain(2, 3, peak_type='sp",
  "{\n    return monotonic(map!((x) => x[0])(l.zip(l[1..$])));\n}\n/*\nReturn true\
    \ is array elements are monotonically increasing or decreasing.\n    >>> monotonic([0,\
    \ 0, 0, 0])\n    true\n    >>> monotonic([1, 2, 4, 20])\n    true\n    >>> monotonic([1,\
    \ 20, 4, 10])\n    false\n    >>> monotonic([4, 1, 0, -10])\n    true\n    \n\
    */", "{\n  bool cmp_asc = true;\n  bool cmp_desc = true;\n  bool cmp = true;\n\
    \  long prev;\n  foreach(index, elem; l)\n  {\n    if(index == 0)\n    {\n   \
    \   prev = elem;\n      continue;\n    }\n    cmp_asc &= elem > prev;\n    cmp_desc\
    \ &= elem < prev;\n    prev = elem;\n  }\n  cmp = cmp_asc | cmp_desc;\n  return\
    \ cmp;\n}", "{\n    return (l[$-1] > l[0]) == all!((l[0] > a) => (a))(l);\n}\n\
    \ \n/*\nReturn true if array elements are strictly increasing.\n    >>> strictly_increasing([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> strictly_increasing([1L, 20L, 4L, 10L])\n \
    \   false\n    >>> strictly_increasing([4L, 1L, 0L, -10L])\n    false\n    \n\
    */", "{\n\tint count1=0;\n\tint count2=0;\n\tforeach(i; 1..l.length) \n\t{\n\t\
    \tif(l[i]>l[i-1])\n\t\t\tcount1++;\n\t\telse if(l[i]<l[i-1])\n\t\t\tcount2++;\n\
    \t}\n\tif(count1==0||count2==0)\n\t\treturn true;\n\telse\n\t\treturn false;\n\
    }", "{\n    if (l.length<2) return true;\n    enum bool increasing = l[0]<l[1];\n\
    \    for (long n=2; n<l.length; n++) {\n        if (increasing) {\n          \
    \  if (l[n-1]>l[n]) return false;\n        } else {\n            if (l[n-1]<l[n])\
    \ return false;\n        }\n    }\n    return true;\n}\n \n/*\nReturn true if\
    \ array is sorted.\n    >>> sorted([1L, 2L, 3L, 4L])\n    true\n    >>> sorted([-9L,\
    \ 10L, 100L, 4L])\n    false\n    >>> sorted([1L, 4L, 0L, -10L])\n    false\n\
    */", "{\n    bool increasing = true;\n    bool decreasing = true;\n    for (long\
    \ i = 1; i < l.length; i++) {\n        if (l[i - 1] > l[i]) {\n            increasing\
    \ = false;\n        }\n        if (l[i - 1] < l[i]) {\n            decreasing\
    \ = false;\n        }\n    }\n    return increasing || decreasing;\n}\n/*\nReturn\
    \ true if the longest monotonic subsequence of the array is increasing.\n    >>>\
    \ monotonic_increasing([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n\
    \    false\n    \n*/", "{\n    auto prev = l[0];\n    auto increasing = true;\n\
    \    auto decreasing = true;\n    for (auto current : l[1..$]) \n    {\n     \
    \   if (current > prev) \n        {\n            decreasing = false;\n       \
    \ }\n        else if (current < prev) \n        {\n            increasing = false;\n\
    \        }\n        prev = current;\n    }\n    return increasing || decreasing;\n\
    }", "{\n    return monotonic(array(l));\n}\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/", "{\n    if (l.length==0) return true; \n\
    \    bool monotonic = true;\n    long last = l[0];\n    for (int i=1; i<l.length;\
    \ i++)\n    {\n      if (last > l[i])\n      {\n        monotonic = false;\n \
    \       break;\n      }\n      last = l[i];\n    }\n    return monotonic;\n}\n\
    /*\nReturn true is array elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic_str([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic_str([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic_str([4L, 1L, 0L, -10L])\n    true\n\
    \    \n*/", "{\n    if (l.length < 2) \n    {\n        return true;\n    }\n \
    \   else \n    {\n        long x = l[0];\n        long y = l[1];\n        int\
    \ direction = compare(x, y);\n        foreach (i, y; l[1..$]) \n        {\n  \
    \          if (compare(x, y) != direction) \n            {\n                return\
    \ false;\n            }\n            x = y;\n        }\n        return true;\n\
    \    }\n}", "{\n    long[] temp = l[];\n    sort(temp);\n    if(l[0] == temp[0])\n\
    \    {\n        for(int i = 0; i < l.length - 1; i++)\n        {\n           \
    \ if(l[i] > l[i + 1])\n            {\n                return false;\n        \
    \    }\n        }\n        return true;\n    }\n    else\n    {\n        for(int\
    \ i = 0; i < l.length - 1; i++)\n        {\n            if(l[i] < l[i + 1])\n\
    \            {\n                return false;\n            }\n        }\n    \
    \    return true;\n    }\n}\n/*\nReturn the index of the middle element of an\
    \ array.\n    >>> middle([1L, 2L, 3L, 4L, 5L])\n    2\n    >>> middle([1L, 4L,\
    \ 3L, 2L, 5L])\n    2\n    >>> middle([1L, 4L, 3L, 5L, 2L])\n    2\n    >>> middle([5L,\
    \ 2L, 4L, 3L, 1L])\n    2\n    >>> middle([2L, 5L, 4L, 3L, 1L])\n    2\n*/\nlong\
    \ middle(long[] l) \n{\n    sort(l);\n    long len = l.length;\n    long middle\
    \ = cast(long) floor(len / 2);\n    return middle;\n}\n/*\nReturn the amount of\
    \ primes in the range 1 - n.\n    >>> primeRange(0L)\n    0\n    >>> primeRange(1L)\n\
    \    0\n    >>> primeRange(2L)\n    1\n    >>> primeRange(5L)\n    3\n    >>>\
    \ primeRange(100L)\n    25\n*/\nlong primeRange(long n) \n{\n    long counter\
    \ = 0;\n    if(n > 1)\n    {\n        foreach(i; 1 .. n + 1)\n        {\n    \
    \        if(isPrime(i))\n            {\n                counter++;\n         \
    \   }\n        }\n    }\n    return counter;\n}\n/*\nReturn true if a number is\
    \ prime, false otherwise.\n    >>> isPrime", "{\n    auto old = l[0];\n    long\
    \ flag = 0;\n    foreach(old; l)\n    {\n        if(old < old)\n        {\n  \
    \          flag = 1;\n        }\n        else if(old > old)\n        {\n     \
    \       flag = -1;\n        }\n        if(flag != 0 && flag != sign(old - old))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    /*\nReturn true if array elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([1, 2, 4, 20])\n    true\n    >>> monotonic([1, 20, 4, 10])\n\
    \    false\n    >>> monotonic([4, 1, 0, -10])\n    true\n    \n*/", "{\n   bool\
    \ up=true; bool down=true;\n   if (l.length > 1)\n   {\n       for (size_t i=1;\
    \ i<l.length; i++)\n       {\n            if (l[i] > l[i-1]) { down=false; }\n\
    \            if (l[i] < l[i-1]) { up=false; }\n            if ( (up==false) &&\
    \ (down==false) ) { return false; }\n       }\n   }\n   return true;\n}", "{\n\
    \    long[] new_l = l.dup;\n    sort(new_l);\n    if(new_l == l)\n        return\
    \ true;\n    reverse(new_l);\n    if(new_l == l)\n        return true;\n    return\
    \ false;\n}\n/*\n    Tuple of the first and last elements of the input array.\n\
    \    >>> first_last([0L, 1L, 2L, 5L, 7L])\n    (0L, 7L)\n*/\ntuple(long, long)\
    \ first_last(long[] l)\n{\n    auto first = l[0];\n    auto last = l[$-1];\n \
    \   return tuple(first, last);\n}\n/*\n    Return the index of the first element\
    \ which is greater than\n    all previous elements, starting from the end of the\
    \ input array.\n    If no such element exists, return -1.\n    >>> first_above([0L,\
    \ 1L, 2L, 3L, 4L, 4L, 3L, 2L, 1L, 0L])\n    4\n    >>> first_above([4L, 4L, 4L,\
    \ 4L, 4L])\n    -1\n    >>> first_above([5L, 4L, 3L, 2L, 1L])\n    -1\n*/\nlong\
    \ first_above(long[] l)\n{\n    int result = -1;\n    for(int i = $-1; i > 0;\
    \ i--)\n    {\n        if(l[i] > l[i-1])\n        {\n            result = i;\n\
    \            break;\n        }\n    }\n    return result;\n}\n/*\n    Return the\
    \ sum of the absolute differences between neighbouring\n    elements in the input\
    \ array.\n    >>> sum_distances([1L, 2L, 5L, 7L])\n    4\n    >>> sum_distances([-1L,\
    \ 2L, 1L, 0L])\n    6\n*/\nlong sum_distances(long[] l)\n{\n    long result =\
    \ 0;\n    for(int i = 0; i < $-1; i++)\n    {\n        result += abs(l[i+1] -\
    \ l[i]);", "{\n    bool dir = (l[0] < l[1]);\n    foreach(i; 1..$-1) \n    {\n\
    \        if (l[i-1] == l[i])\n            continue;\n        if (dir != (l[i-1]\
    \ < l[i]))\n            return false;\n    }\n    return true;\n}\n/*", "{\n \
    \ long i = 0L;\n  long n = l.length;\n  while ((i < n - 1L))\n  {\n    if (((l[i]\
    \ > l[i + 1L]) && (i == 0L)))\n    {\n      i += 1L;\n      while ((i < n - 1L))\n\
    \      {\n        if ((l[i] < l[i + 1L]))\n        {\n          return false;\n\
    \        }\n        i += 1L;\n      }\n      return true;\n    }\n    else if\
    \ (((l[i] < l[i + 1L]) && (i == 0L)))\n    {\n      i += 1L;\n      while ((i\
    \ < n - 1L))\n      {\n        if ((l[i] > l[i + 1L]))\n        {\n          return\
    \ false;\n        }\n        i += 1L;\n      }\n      return true;\n    }\n  \
    \  else\n    {\n      return false;\n    }\n  }\n  return true;\n}\n/*\nReturns\
    \ true if the array is sorted in increasing order.\n    >>> is_sorted([1L, 2L,\
    \ 3L, 5L])\n    true\n    >>> is_sorted([1L, 2L, 3L, 5L, 4L])\n    false\n   \
    \ >>> is_sorted([1L, 2L, 3L, 5L, 3L])\n    false\n    \n*/", "{\n\talias typ =\
    \ typeof(l[0]);\n\tauto diffs = l[1..$].map!((x) => cast(typ) (x - l[$ - 1]));\n\
    \treturn diffs.uniq.length <= 1;\n}\n/*\nReturn true if array of integers is a\
    \ permutation of range(n).\n    >>> isPermutation([1L, 2L, 3L, 4L])\n    true\n\
    \    >>> isPermutation([3L, 2L, 4L, 1L])\n    true\n    >>> isPermutation([4L,\
    \ 3L, 1L, 0L])\n    false\n    >>> isPermutation([1L, 2L, 3L, 2L])\n    false\n\
    \    \n*/", "{\n    bool increasing = false;\n    bool decreasing = false;\n \
    \   long prev;\n    int i;\n    if(l.length > 1) \n    {\n        prev = l[0];\n\
    \        i = 1;\n        while(i < l.length) \n        {\n            if(l[i]\
    \ > prev) \n            {\n                increasing = true;\n            }\n\
    \            else if(l[i] < prev) \n            {\n                decreasing\
    \ = true;\n            }\n            prev = l[i];\n            i++;\n       \
    \ }\n    }\n    else \n    {\n        return true;\n    }\n    return !increasing\
    \ || !decreasing;\n}", "{\n    auto i = 0L;\n    auto j = 0L;\n    auto k = 0L;\n\
    \    auto incrementing = false;\n    auto decrementing = false;\n    if (l.length\
    \ > 0L) \n    {\n        i = 1L;\n        j = l.length - 1L;\n        k = l[i]\
    \ - l[i - 1L];\n        while (i < j) \n        {\n            if (k > 0L) \n\
    \            {\n                incrementing = true;\n                if (l[i]\
    \ < l[i - 1L]) \n                {\n                    return false;\n      \
    \          }\n            }\n            else if (k < 0L) \n            {\n  \
    \              decrementing = true;\n                if (l[i] > l[i - 1L]) \n\
    \                {\n                    return false;\n                }\n   \
    \         }\n            if (incrementing && decrementing) \n            {\n \
    \               return false;\n            }\n            i = i + 1L;\n      \
    \  }\n    }\n    return true;\n}\n/*\nReturn the running sum of an array.\n  \
    \  >>> running_sum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> running_sum([])\n\
    \    []\n*/\nlong[] running_sum(long[] l) \n{\n    auto out = new long[](l.length);\n\
    \    if (l.length > 0L) \n    {\n        out[0L] = l[0L];\n        auto i = 1L;\n\
    \        while (i < l.length) \n        {\n            out[i] = out[i - 1L] +\
    \ l[i];\n            i = i + 1L;\n        }\n    }\n    return out;\n}\n/*\nReturn\
    \ the running product of an array.\n    >>> running_product([1, 2, 3, 4])\n  \
    \  [1, 2, 6, 24]\n    >>> running_product([])\n    []\n*/\nlong[] running_product(long[]\
    \ l) \n{\n    auto out = new long[](l.length);\n    if (l.length > 0L) \n", "{\n\
    \    return  l.length < 2 || reduce!(\"lhs < rhs\")(l);\n}\n/*\nFind the point\
    \ of insertion.\n    >>> pointofinsertion([2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L,\
    \ 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L,\
    \ 97L], 13L)\n    5\n    >>> pointofinsertion([2L, 3L, 5L, 7L, 11L, 13L, 17L,\
    \ 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L,\
    \ 89L, 97L], 53L)\n    15\n    >>> pointofinsertion([2L, 3L, 5L, 7L, 11L, 13L,\
    \ 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L,\
    \ 83L, 89L, 97L], 1L)\n    0\n    >>> pointofinsertion([2L, 3L, 5L, 7L, 11L, 13L,\
    \ 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L,\
    \ 83L, 89L, 97L], 100L)\n    25\n*/\nlong pointofinsertion(long[] l, long x) \n\
    {\n    size_t insertPoint = 0;\n    foreach(range; 0 .. l.length) \n    {\n  \
    \      if(l[range] > x)\n            break;\n        insertPoint++;\n    }\n \
    \   return insertPoint;\n}\n/*\nGiven a list, return a new list with a position\
    \ move. A position move is a tuple with two elements:\n    the position of the\
    \ element to move, and\n    the destination position, where", "{\n    bool dec;\n\
    \    long prev, curr;\n    if (l.length < 2) return true;\n    curr = l[0];\n\
    \    dec = false;\n    foreach (i,e; l[1..$]) \n    {\n        prev = curr;\n\
    \        curr = e;\n        if (prev != curr) \n        {\n            if (dec\
    \ && prev < curr) return false;\n            if (!dec && prev > curr) return false;\n\
    \            dec = prev > curr;\n        }\n    }\n    return true;\n}\n/*\nReturn\
    \ true if array elements are monotonically increasing, monotonically decreasing\
    \ or are constant.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n\
    \    >>> monotonic([4L, 1L, 0L, -10L, -10L])\n    true\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L, -9L])\n    false\n    \n*/", "{\n    if (l.length < 2) return\
    \ true;\n    bool increasing = true;\n    long last = l[0];\n    foreach (i; l[1..$])\
    \ {\n        if (last != i) increasing = last < i;\n        if (last < i != increasing)\
    \ return false;\n        last = i;\n    }\n    return true;\n}\n/*\nReturn the\
    \ length of the longest monotonic subsequence of the given array.\n    >>> longest_monotonic_subsequence([3L,\
    \ 1L, 4L, 1L, 5L, 9L, 2L, 6L, 5L, 3L, 5L, 8L, 9L, 7L, 9L])\n    7\n    >>> longest_monotonic_subsequence([])\n\
    \    0\n    >>> longest_monotonic_subsequence([1L])\n    1\n*/", "{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    long[] w = l[];\n    if (w[0]\
    \ > w[1]) \n    {\n        reverse(w);\n    }\n    foreach (immutable i, immutable\
    \ x; w) \n    {\n        if (i > 0 && x < w[i - 1]) \n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n/*\nReturn the maximum value\
    \ of the elements in the array. If the array is empty,\n    return an empty optional.\n\
    \    >>> maximum([1L, 4L, 20L, -1L])\n    20L\n    >>> maximum([])\n    empty\n\
    \    \n*/\nTypeTuple!(long, bool) maximum(long[] l) \n{\n    if (l.length < 1)\
    \ \n    {\n        return tuple(0L, false);\n    }\n    long[] w = l[];\n    reverse(w);\n\
    \    return tuple(w[0], true);\n}\n/*\nCompute the mean (average) of the elements\
    \ in the array.\n    >>> mean([1L, 2L, 3L, 4L])\n    2.5\n    >>> mean([])\n \
    \   0.0\n    \n*/\ndouble mean(long[] l) \n{\n    if (l.length < 1) \n    {\n\
    \        return 0.0;\n    }\n    long[] w = l[];\n    return sum(w) / w.length;\n\
    }\n/*\nReturn the median (middle value) of the elements in the array. If the array\
    \ is\n    empty, return an empty optional.\n    >>> median([1L, 2L, 3L, 4L])\n\
    \    2L\n    >>> median([1L, 2L, 3L, 4L, 5L])\n    3L\n    >>> median([])\n  \
    \  empty\n    \n*/\nTypeTuple!(long, bool) median(long[] l) \n{\n    if (l.length\
    \ < 1) \n    {\n        return tuple(0L, false);\n    }\n    long[] w = l[];\n\
    \    sort(w);", "{\n    if (l.length == 0) return true;\n    long prev = l[0];\n\
    \    long direction = 0;\n    foreach (i; 1..l.length) {\n        if (prev ==\
    \ l[i]) continue;\n        if (direction == 0) {\n            direction = l[i]\
    \ - prev;\n        } else if (direction > 0 && l[i] - prev < 0) {\n          \
    \  return false;\n        } else if (direction < 0 && l[i] - prev > 0) {\n   \
    \         return false;\n        }\n        prev = l[i];\n    }\n    return true;\n\
    }\n/*\nReturns a 2-tuple of two arrays, the first containing those elements\n\
    \    in the input array `l` that are smaller than `k`, the second of\n    which\
    \ contains those elements in `l` that are larger than `k`.\n    >>> partition([2L,\
    \ 3L, 1L, 20L, 14L, 5L], 10L)\n    ([2L, 3L, 1L, 5L], [20L, 14L])\n*/\nTuple!(long[],\
    \ long[]) partition(long[] l, long k) \n{\n    long[] small = [];\n    long[]\
    \ large = [];\n    foreach (i; l) {\n        if (i < k) {\n            small ~=\
    \ i;\n        } else {\n            large ~= i;\n        }\n    }\n    return\
    \ tuple(small, large);\n}\n/*\nReturns a pair of lists, the first containing those\
    \ elements in the\n    input list `l` that are smaller than `k`, the second of\
    \ which\n    contains those elements in `l` that are larger than `k`.\n    >>>\
    \ partition2([2L, 3L, 1L, 20L, 14L, 5L], 10L)\n    ([2L, 3L, 1L, 5L], [20L, 14L])\n\
    */\nTuple!(Long[], Long[]) partition2(Long[] l, long k) \n{\n    Long[] small\
    \ = [];\n    Long[] large = [];\n    foreach (i; l) {\n        if (i < k) {\n\
    \            small ~= i;\n        }", "{\n    bool increasing = true;\n    bool\
    \ decreasing = true;\n    int n = l.length;\n    for (int i = 1; i < n; i++)\n\
    \    {\n        increasing &= l[i] >= l[i - 1];\n        decreasing &= l[i] <=\
    \ l[i - 1];\n    }\n    return increasing || decreasing;\n}", "{\n    if (l.length<=1)\n\
    \        return true;\n    bool increasing=l[1]>l[0];\n    foreach(index,e;l[1..$])\n\
    \    {\n        if (e>l[index-1] && !increasing)\n            return false;\n\
    \        if (e<l[index-1] && increasing)\n            return false;\n    }\n \
    \   return true;\n}\n/*\nReturn true is array elements are monotonically increasing\
    \ or decreasing.\n    >>> monotonic([\"a\", \"b\", \"c\", \"d\"])\n    true\n\
    \    >>> monotonic([\"a\", \"d\", \"c\", \"b\"])\n    false\n*/", "{\n    if (l.length\
    \ < 2)\n    {\n        return true;\n    }\n    return l[$-1] >= l[0] || l[$-1]\
    \ <= l[0];\n}\n/*\n    >>> monotonic([2L, 1L, -1L, -10L])\n    false\n    >>>\
    \ monotonic([3L, 3L, 3L, 3L])\n    true\n*/\n \n/*\nReturn true if the mean of\
    \ a series of values is close to the target value.\n*/", "{\n    switch (l.length)\
    \ \n    {\n        case 0:\n            return true;\n        case 1:\n      \
    \      return true;\n        default:\n            return l[0] < l[1] ? std.all!(a\
    \ => a < l[1])(l) : std.all!(a => a > l[1])(l);\n    }\n}", "{\n    if(l.length\
    \ == 0)\n    {\n        return true;\n    }\n    long previousValue = l[0];\n\
    \    bool directionIsUp = false;\n    bool first = true;\n    foreach(const currentValue;\
    \ l)\n    {\n        if(!first)\n        {\n            if(currentValue < previousValue)\n\
    \            {\n                if(directionIsUp)\n                {\n       \
    \             return false;\n                }\n            }\n            else\
    \ if(currentValue > previousValue)\n            {\n                if(!directionIsUp)\n\
    \                {\n                    directionIsUp = true;\n              \
    \  }\n            }\n        }\n        else\n        {\n            first = false;\n\
    \        }\n        previousValue = currentValue;\n    }\n    return true;\n}",
  "{\n    if (l.length < 2) return true;\n    long first = l[0];\n    bool inc = l[1]\
    \ >= first;\n    for (long i = 1; i < l.length; i++)\n    {\n        long cur\
    \ = l[i];\n        if (cur == first) continue;\n        bool newInc = cur >= first;\n\
    \        if (newInc != inc) return false;\n    }\n    return true;\n}\n/*\nReturn\
    \ the index of the first monotonic part of the array.\n    >>> first_monotonic([1L,\
    \ 20L, 4L, 10L])\n    1\n    >>> first_monotonic([1L, 1L, 1L, 1L])\n    0\n*/\n\
    long first_monotonic(long[] l) \n{\n    return first_monotonic(l, 0, l.length);\n\
    }", "{\n    // TODO: use `zip` or maybe reduce\n    // TODO: use `if` instead\
    \ of `continue`\n    // TODO: use `break` instead of return\n    if (l.length\
    \ < 2) return true;\n    bool increasing = true;\n    foreach (i, v; l) {\n  \
    \      if (i==0) continue;\n        if (v < l[i-1]) {\n            increasing\
    \ = false;\n            break;\n        }\n    }\n    if (increasing) return true;\n\
    \    bool decreasing = true;\n    foreach (i, v; l) {\n        if (i==0) continue;\n\
    \        if (v > l[i-1]) {\n            decreasing = false;\n            break;\n\
    \        }\n    }\n    return decreasing;\n}", "{\n    long n = l.length;\n  \
    \  /*\n    // can use this but not allowed in d language\n    return all(l[i]\
    \ < l[i+1] for i in range(n-1)) or all(l[i] > l[i+1] for i in range(n-1));\n \
    \   */\n    bool increasing = true;\n    bool decreasing = true;\n    for (long\
    \ i = 0; i < n-1; i++)\n    {\n        if(l[i] >= l[i+1])\n            increasing\
    \ = false;\n        if(l[i] <= l[i+1])\n            decreasing = false;\n    }\n\
    \    return increasing || decreasing;\n}", "{\n    immutable bool increasing =\
    \ true;\n    immutable bool decreasing = true;\n    return l.length < 2 || ((increasing\
    \ && !std.algorithm.any!((a, b) => a > b)(l))\n                            ||\
    \ (decreasing && !std.algorithm.any!((a, b) => a < b)(l)));\n}", "{\n\tbool direction\
    \ = l[1] > l[0];\n\tforeach( long i, long j; l[1..$])\n\t{\n\t\ti = j;\n\t\tj\
    \ = l[$-1];\n\t\tif((i - j) * (1L - (1L - direction) * 2L) < 0L)\n\t\t\treturn\
    \ false;\n\t}\n\treturn true;\n}\n/*\nEliminate adjacent duplicates.\n    >>>\
    \ dedupe([1L, 2L, 2L, 1L, 2L, 1L, 1L, 2L, 3L, 3L, 3L, 4L, 5L, 5L, 3L, 3L, 1L,\
    \ 2L, 3L, 4L, 5L, 5L, 1L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 5L, 2L, 1L, 2L, 3L,\
    \ 4L, 5L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 5L, 4L,\
    \ 3L, 2L, 1L, 2L, 3L, 4L, 5L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L,\
    \ 3L, 4L, 5L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L,\
    \ 5L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 5L,\
    \ 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 5L, 4L, 3L,\
    \ 2L, 1", "{\n    bool monotonic = true;\n    long[] tmpL = l[$-1..$];\n    while\
    \ (tmpL.length > 0)\n    {\n        auto min = min(tmpL);\n        auto pos =\
    \ std.algorithm.find(tmpL, min);\n        if (pos.empty)\n        {\n        \
    \    break;\n        }\n        auto posLast = pos.front;\n        tmpL = tmpL[0..posLast];\n\
    \        if (posLast > 0)\n        {\n            long[] tmp = tmpL[$-1..$];\n\
    \            long[] minL = tmpL[0..$-1];\n            if (tmp > minL)\n      \
    \      {\n                monotonic = false;\n                break;\n       \
    \     }\n        }\n    }\n    return monotonic;\n}\n/*\nReturn the first non-monotonic\
    \ index.\n    >>> first_nonomonic_index([1L, 2L, 4L, 20L])\n    -1\n    >>> first_nonomonic_index([1L,\
    \ 20L, 4L, 10L])\n    1\n    >>> first_nonomonic_index([4L, 1L, 0L, -10L])\n \
    \   -1\n*/\nlong first_nonomonic_index(long[] l) \n{\n    bool monotonic = true;\n\
    \    long ind = -1;\n    long[] tmpL = l[$-1..$];\n    while (tmpL.length > 0)\n\
    \    {\n        auto min = min(tmpL);\n        auto pos = std.algorithm.find(tmpL,\
    \ min);\n        if (pos.empty)\n        {\n            break;\n        }\n  \
    \      auto posLast = pos.front;\n        tmpL = tmpL[0..posLast];\n        if\
    \ (posLast > 0)\n        {\n            long[] tmp = tmpL[$-1..$];\n         \
    \   long[] minL = tmpL[0..$-1];\n            if (tmp > minL)\n            {\n\
    \                monotonic = false;\n                ind = ind + posLast + 1;\n\
    \                break;\n            }\n        }\n        ind = ind + posLast",
  "{\n    return map!(a => a[0] > a[1])(zip(l[1 .. $], l[0 .. $ - 1])).all!((a) =>\
    \ !a);\n}", "    if (l.length == 0) return true;\n    auto limit = l[0];\n   \
    \ bool increasing = true;\n    foreach (i, e; l) \n    {\n        if (e != limit)\
    \ \n        {\n            if (increasing) \n            {\n                if\
    \ (e < limit) \n                {\n                    increasing = false;\n \
    \                   if (e < limit) return false;\n                }\n        \
    \    } \n            else \n            {\n                if (e > limit) return\
    \ false;\n            }\n            limit = e;\n        }\n    }\n    return\
    \ true;\n}\n/*\nReturn true if given number is a prime.\n    >>> is_prime(2L)\n\
    \    true\n    >>> is_prime(3L)\n    true\n    >>> is_prime(4L)\n    false\n*/",
  "    pure nothrow @safe @nogc\n{\n    bool increasing = true;\n    bool decreasing\
    \ = true;\n    for (long i = 1; i < l.length; i++)\n    {\n        increasing\
    \ &= l[i - 1] <= l[i];\n        decreasing &= l[i - 1] >= l[i];\n    }\n    return\
    \ increasing || decreasing;\n}", "{\n    if(l.length < 2) return true;\n    long\
    \ prev = l[0];\n    bool increase = true;\n    if(prev > l[1]) increase = false;\n\
    \    prev = l[1];\n    int i = 2;\n    while(i < l.length) {\n        if(increase\
    \ && prev > l[i]) return false;\n        if(!increase && prev < l[i]) return false;\n\
    \        prev = l[i];\n        i++;\n    }\n    return true;\n}", "{\n    if(l.length\
    \ <= 1) \n    {\n        return true;\n    }\n    size_t half = l.length / 2;\n\
    \    auto l1 = l[0 .. half];\n    auto l2 = l[half .. $];\n    return l1.back\
    \ <= l2.front && monotonic(l1) && monotonic(l2);\n}\n// Length of list l.\nsize_t\
    \ len(T)(T[] l) \n{\n    return l.length;\n}\n// Memory used by the list.\nlong\
    \ mem(T)(T[] l) \n{\n    return l.capacity * l.tupleof.sizeof;\n}\n// Test if\
    \ all items in l are unique.", "{\n    bool result;\n    auto l2 = sort(l);\n\
    \    if(l == l2)\n    {\n        result = true;\n    }\n    else\n    {\n    \
    \    l2 = sort(l, std.less);\n        if(l == l2)\n        {\n            result\
    \ = true;\n        }\n        else\n        {\n            result = false;\n \
    \       }\n    }\n    return result;\n}\n//Function that converts an integer to\
    \ a tuple.\nauto intToTuple(long l)\n{\n    long[] l2;\n    auto result = l2.init;\n\
    \    while(l > 0)\n    {\n        result ~= l % 10;\n        l /= 10;\n    }\n\
    \    return result;\n}", "{\n   return std.algorithm.isSorted(l, lt) \n      ||\
    \ std.algorithm.isSorted(l, gt);\n}\n ", "{\n    auto sign = 0;\n    foreach (i,\
    \ a; l) \n    {\n        if (i + 1 >= l.length)\n            break;\n        if\
    \ (a == l[i + 1])\n            continue;\n        if (sign == 0)\n           \
    \ sign = a < l[i + 1] ? 1 : -1;\n        if (sign != (a < l[i + 1] ? 1 : -1))\n\
    \            return false;\n    }\n    return true;\n}\n/*\nReturn successive\
    \ combination items:", "{\n    if (l.length <= 1)\n    {\n        return true;\n\
    \    }\n    long prev_elem = l[0];\n    long prev_diff = 0;\n    foreach (elem;\
    \ l[1..])\n    {\n        long diff = elem - prev_elem;\n        if (prev_diff\
    \ == 0)\n        {\n            prev_diff = diff;\n        }\n        else if\
    \ (prev_diff > 0 && diff < 0)\n        {\n            return false;\n        }\n\
    \        else if (prev_diff < 0 && diff > 0)\n        {\n            return false;\n\
    \        }\n        prev_elem = elem;\n    }\n    return true;\n}", "{\n    bool\
    \ ascending = true;\n    bool descending = true;\n    if(l.length < 2)\n     \
    \   return true;\n    auto a = l.dup;\n    auto b = l.dup;\n    sort(a);\n   \
    \ sort(b,std.algorithm.greater!\"a < b\");\n    if(a == l)\n        return true;\n\
    \    if(b == l)\n        return true;\n    return false;\n}\n/*\nReturn true if\
    \ array elements are monotonically increasing or decreasing.\n    >>> monotonic([1f,\
    \ 2f, 4f, 20f])\n    true\n    >>> monotonic([1f, 20f, 4f, 10f])\n    false\n\
    \    >>> monotonic([4f, 1f, 0f, -10f])\n    true\n*/", "pure nothrow @nogc @safe\n\
    {\n    if (l.length == 0) \n    {\n        return true;\n    }\n    // assert(l.length\
    \ != 0);\n    auto el = l[0];\n    foreach (i, ref a; l) \n    {\n        if (a\
    \ > el) \n        {\n            el = a;\n        }\n        else if (a < el)\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }", "in {\n    assert(l.length > 0);\n}\nout (bool result)\n{\n    assert(result\
    \ == true);\n}\n{\n    bool increasing = true;\n    bool decreasing = true;\n\
    \    for (int i = 1; i < l.length; i++) {\n        if (l[i-1] > l[i]) {\n    \
    \        increasing = false;\n        }\n        if (l[i-1] < l[i]) {\n      \
    \      decreasing = false;\n        }\n    }\n    return increasing || decreasing;\n\
    }", "{\n    bool increasing = true;\n    foreach (i, j; zip(l[0..$-1], l[1..$]))\n\
    \    {\n        if (i > j)\n        {\n            increasing = false;\n     \
    \       break;\n        }\n    }\n    if (increasing)\n        return true;\n\
    \    else\n    {\n        bool decreasing = true;\n        foreach (i, j; zip(l[0..$-1],\
    \ l[1..$]))\n        {\n            if (i < j)\n            {\n              \
    \  decreasing = false;\n                break;\n            }\n        }\n   \
    \     return decreasing;\n    }\n}\n/*\nReturn true if list of numbers are in\
    \ increasing order and adjacent values are not equal.\n    >>> strict_monotonic([1L,\
    \ 3L, 4L, 6L])\n    true\n    >>> strict_monotonic([1L, 3L, 4L, 4L])\n    false\n\
    \    >>> strict_monotonic([-10L, -9L, -7L, -2L])\n    true\n    \n*/", "{\n  \
    \  bool increase = true;\n    bool decrease = true;\n    for (int i = 1; i < l.length;\
    \ i++) {\n        increase &= l[i - 1] <= l[i];\n        decrease &= l[i - 1]\
    \ >= l[i];\n    }\n    return increase || decrease;\n}", "{\n    return all(zip(l[0..$-1],\
    \ l[1..$]).map!((a, b) { return b > a; }));\n}", "{\n    bool up = l[0] < l[1];\n\
    \    foreach(size_t i, long e; l) \n    {\n        if(up && e < l[i - 1])\n  \
    \          return false;\n        if(!up && e > l[i - 1])\n            return\
    \ false;\n    }\n    return true;\n}", "{\n    if (l.length < 2) \n    {\n   \
    \     return true;\n    }\n    auto sign = (l[1] - l[0]) / abs(l[1] - l[0]);\n\
    \    if (sign == 0) \n    {\n        return false;\n    }\n    foreach (i, val;\
    \ l[1..]) \n    {\n        if (sign * (val - l[i - 1]) < 0) \n        {\n    \
    \        return false;\n        }\n    }\n    return true;\n}\n/*\nReturn true\
    \ if array elements are monotonically increasing or decreasing,\n    treating\
    \ elements as if they were in a circular list.\n    >>> circular_monotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> circular_monotonic([1L, 20L, 4L, 10L])\n  \
    \  false\n    >>> circular_monotonic([4L, 1L, 0L, -10L])\n    true\n    >>> circular_monotonic([4L,\
    \ 1L, -10L, 0L])\n    true\n    >>> circular_monotonic([1L, 20L, -10L, 10L])\n\
    \    true\n    >>> circular_monotonic([1L, -10L, 20L, 10L])\n    true\n    >>>\
    \ circular_monotonic([1L, 20L, -10L, -20L])\n    true\n    >>> circular_monotonic([1L,\
    \ -10L, -20L, 20L])\n    true\n    >>> circular_monotonic([1L, 10L, 20L, -10L])\n\
    \    true\n    >>> circular_monotonic([1L, -10L, 20L, 10L])\n    true\n*/", "{\n\
    \    if(l.length < 3) return true;\n    bool increasing = true;\n    long prev\
    \ = l[0];\n    foreach(i, cur; l[1..$])\n    {\n        if(prev > cur)\n     \
    \   {\n            increasing = false;\n            break;\n        }\n      \
    \  prev = cur;\n    }\n    if(increasing) return true;\n    bool decreasing =\
    \ true;\n    prev = l[0];\n    foreach(i, cur; l[1..$])\n    {\n        if(prev\
    \ < cur)\n        {\n            decreasing = false;\n            break;\n   \
    \     }\n        prev = cur;\n    }\n    return decreasing;\n}", "{\n    long[long]\
    \ seqs;\n    long currentMax = -1;\n    foreach (i; l) \n    {\n        if (i\
    \ <= currentMax)\n        {\n            seqs[currentMax] = i;\n            currentMax\
    \ = i;\n        }\n        else\n        {\n            currentMax = i;\n    \
    \    }\n    }\n    return seqs.length == 0;\n}\n/*\nReturn true if array elements\
    \ are monotonically increasing or decreasing.\n*/", "  //std.algorithm.isSorted(l)\n\
    \  //return true;\n{\n    auto it = l.front.next;\n    bool ret = it.isValid;\n\
    \    while (it.isValid) {\n        bool cond;\n        cond = it.value > it.previous.value;\n\
    \        if (ret) ret = cond;\n        else ret = !cond;\n        it = it.next;\n\
    \    }\n    return ret;\n}", "{\n    size_t i = 1L;\n    size_t l_len = l.length;\n\
    \    bool res = true;\n    while (i < l_len)\n    {\n        if (l[i - 1L] > l[i])\n\
    \        {\n            res = false;\n            break;\n        }\n        i\
    \ += 1L;\n    }\n    return res;\n}\n/*\nReturn true is array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n\
    \    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L,\
    \ 0L, -10L])\n    true\n    \n*/", "{\n    \n    bool dir;\n    foreach(i,j; zip(l[0..$-1],\
    \ l[1..$]))\n    {\n        if (i==0)\n        {\n            dir = (j-i > 0);\n\
    \        }\n        else\n        {\n            if (dir != (j-i > 0)) return\
    \ false;\n        }\n    }\n    return true;\n}", "{\n    bool up = true;\n  \
    \  bool down = true;\n    int last = l[0];\n    foreach(int v; l)\n    {\n   \
    \     if (v > last)\n            down = false;\n        if (v < last)\n      \
    \      up = false;\n        last = v;\n    }\n    return up || down;\n}\n/*\n\
    Return true if array elements are monotonically increasing.\n    >>> strictly_monotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> strictly_monotonic([1L, 20L, 4L, 10L])\n  \
    \  false\n    >>> strictly_monotonic([4L, 1L, 0L, -10L])\n    false\n*/", "{\n\
    \tbool descending;\n\tif (l.length < 2) \n\t{\n\t\treturn true;\n\t}\n\tdescending\
    \ = (l[0] > l[1]);\n\tfor (size_t i = 1; i < l.length - 1; i++) \n\t{\n\t\tif\
    \ ((descending && l[i] < l[i + 1]) || (!descending && l[i] > l[i + 1])) \n\t\t\
    {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n/*\n    >>> majorVersion(1L)\n\
    \    0\n    >>> majorVersion(10L)\n    1\n    >>> majorVersion(20L)\n    2\n*/\n\
    size_t majorVersion(long N) \n{\n\tint count = 0;\n\tfor (; N > 1; N = N / 10)\
    \ \n\t{\n\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n    >>> minVersion(0L)\n \
    \   1\n    >>> minVersion(1L)\n    10\n    >>> minVersion(2L)\n    20\n*/\nlong\
    \ minVersion(long N) \n{\n\treturn 10L ^ N;\n}\n/*\n    >>> maxVersion(0L)\n \
    \   9\n    >>> maxVersion(1L)\n    99\n    >>> maxVersion(2L)\n    999\n*/\nlong\
    \ maxVersion(long N) \n{\n\tif (N == 0) \n\t{\n\t\treturn 9;\n\t}\n\treturn 10L\
    \ ^ N - 1;\n}\n/*\n    >>> validVersions([0L, 3L, 5L])\n    3\n    >>> validVersions([1L,\
    \ 2L, 4L])\n    0\n    >>> validVersions([1L, 2L, 3L])\n    1\n    >>> validVersions([2L,\
    \ 3L, 4L])\n    2\n    >>> validVersions([3L, 4L, 5L])\n    3\n    >>> validVersions([3L,\
    \ 4L, 5L, 8L])\n    3\n    >>> validVersions([3L, 4L, 5L, 6L])\n    4\n    >>>\
    \ validVersions([3", "{\n    bool incr = true;\n    bool decr = true;\n    bool\
    \ first = true;\n    long prev = 0L;\n    foreach (i; l) \n    {\n        if (first)\
    \ \n        {\n            first = false;\n        } \n        else \n       \
    \ {\n            if (prev > i)\n                incr = false;\n            if\
    \ (prev < i)\n                decr = false;\n        }\n        prev = i;\n  \
    \  }\n    return incr or decr;\n}", "{\n    bool direction = null;\n    if (l.length\
    \ <= 1)\n    {\n        return true;\n    }\n    foreach (i, elem; l)\n    {\n\
    \        if (i == 0)\n        {\n            continue;\n        }\n        if\
    \ (elem < l[i - 1])\n        {\n            if (direction is true)\n         \
    \   {\n                return false;\n            }\n            direction = false;\n\
    \        }\n        else if (elem > l[i - 1])\n        {\n            if (direction\
    \ is false)\n            {\n                return false;\n            }\n   \
    \         direction = true;\n        }\n    }\n    return true;\n}\n/*\nTest if\
    \ an array is sorted\n    >>> sorted([1L, 2L, 4L, 20L])\n    true\n    >>> sorted([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> sorted([1L, 20L, 4L, 4L, 10L])\n    false\n\
    \    \n*/", "in\n{\n    assert(l.length > 0);\n}\nbody\n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length; i++)\n\
    \    {\n        if (l[i - 1] > l[i])\n        {\n            increasing = false;\n\
    \        }\n        if (l[i - 1] < l[i])\n        {\n            decreasing =\
    \ false;\n        }\n    }\n    return increasing || decreasing;\n}", "{\n   \
    \ return l[0] <= l[l.length - 1] \n        ? __monotonic(l) \n        : __monotonic(l.reversed);\n\
    }", "{\n    return all(l[0..$-1] < l[1..$]) or all(l[0..$-1] > l[1..$]);\n}",
  "in {\n  assert(l.length > 0);\n}\nout {\n  assert(foreach (i, j; zip(l[0 .. $ -\
    \ 1], l[1 .. $])) | i < j);\n}\nbody {\n  bool increasing = true;\n  bool decreasing\
    \ = true;\n  foreach (i, j; zip(l[0 .. $ - 1], l[1 .. $])) {\n    if (i > j) {\n\
    \      increasing = false;\n    } else if (i < j) {\n      decreasing = false;\n\
    \    }\n  }\n  return increasing || decreasing;\n}\n/*\nReturn the list of the\
    \ maximal elements of the array.\n    >>> maxima([0L, 1L, 2L, 3L, 3L, 2L, 1L,\
    \ 0L])\n    [3L, 3L]\n    >>> maxima([1L, 2L, 3L, 3L, 3L, 2L, 1L, 0L])\n    [3L,\
    \ 3L, 3L]\n    >>> maxima([])\n    []\n*/\nlong[] maxima(long[] l) \nin {\n  assert(l.length\
    \ > 0);\n}\nout {\n  assert(foreach (i, j; zip(result[0 .. $ - 1], result[1 ..\
    \ $])) | i < j);\n}\nbody {\n  return [item for (item; l) if (item == maximum(l))];\n\
    }\n/*\nLeft-rotate the array by an integer number of elements.\nThe leftmost elements\
    \ are wrapped around to the right.\n    >>> rotateLeft([1L, 2L, 3L, 4L, 5L], 1)\n\
    \    [2L, 3L, 4L, 5L, 1L]\n    >>> rotateLeft([1L, 2L, 3L, 4L, 5L], 4)\n    [5L,\
    \ 1L, 2L, 3L, 4L]\n    >>> rotateLeft([1L, 2L, 3L, 4L, 5L], -1)\n    [5L, 1L,\
    \ 2L, 3L, 4L]\n    >>> rotateLeft([1L, 2L, 3L, 4L, 5L", "{\n    return all(l[1..l.length\
    \ - 2] .map!(x => (x < l[0]) == (x < l[-1])));\n}", "{\n    bool res = true;\n\
    \    if(l.length != 0)\n    {\n\tlong ref = l[0];\n\tfor(long i = 1; i < l.length;\
    \ i++)\n\t{\n\t    if(ref < l[i])\n\t    {\n\t\tref = l[i];\n\t    }\n\t    else\n\
    \t    {\n\t\tres = false;\n\t\tbreak;\n\t    }\n\t}\n    }\n    return res;\n\
    }\n/*\nGenerate 'n' samples from unit gaussian.  Return array of samples.\n  \
    \  >>> unit_gaussian(5)\n    [-0.04682082121118954, -1.821595319174724, -0.1530484645345898,\
    \ 0.19459690547489435, -0.27678214812195586]\n    \n*/\nlong[] unit_gaussian(long\
    \ n) \n{\n    long[] res = new long[n];\n    for(long i = 0; i < n; i++)\n   \
    \ {\n\tres[i] = (long)random();\n    }\n    return res;\n}\n/*\nReturn the mean\
    \ of a list of numbers.\n    >>> mean([1L, 2L, 3L, 4L, 5L])\n    3.0\n    \n*/\n\
    double mean(long[] l) \n{\n    long sum = 0;\n    for(long i = 0; i < l.length;\
    \ i++)\n    {\n\tsum += l[i];\n    }\n    return (double)sum / l.length;\n}\n\
    /*\nReturn the covariance of a list of numbers.\n    >>> covariance([1L, 2L, 3L,\
    \ 4L, 5L], [1L, 2L, 3L, 4L, 5L])\n    2.5\n    \n*/\ndouble covariance(long[]\
    \ l1, long[] l2) \n{\n    assert(l1.length == l2.length);\n    double m1 = mean(l1);\n\
    \    double m2 = mean(l2);\n    double res = 0;\n    for(long i = 0; i < l1",
  "in {\n  assert(isValid(l));\n}\nout {\n  assert(forall (a, b; 0 <= a < b < |l|\
    \ ==> l[a] <= l[b]) ||\n\t forall (a, b; 0 <= a < b < |l| ==> l[a] >= l[b]));\n\
    }\ndo {\n  return (forall (a, b; 0 <= a < b < |l| ==> l[a] <= l[b]) ||\n\t  forall\
    \ (a, b; 0 <= a < b < |l| ==> l[a] >= l[b]));\n}", "{\n    bool mono = true;\n\
    \    int i = 0;\n    while(i < l.length - 1)\n    {\n        if (l[i] >= l[i+1])\n\
    \        {\n            mono = false;\n            break;\n        }\n       \
    \ i++;\n    }\n    return mono;\n}\n/*\nTest if an array is sorted.\n    >>> issorted([1L,\
    \ 1L, 2L, 4L, 20L])\n    true\n    >>> issorted([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> issorted([4L, 1L, 0L, -10L])\n    false\n    >>> issorted([1L, 1L, 2L,\
    \ 4L, 20L], false)\n    true\n    >>> issorted([1L, 20L, 4L, 10L], false)\n  \
    \  false\n    >>> issorted([4L, 1L, 0L, -10L], false)\n    true\n    \n*/", "{\n\
    \    if (l.length <= 1)\n        return true;\n    \n    auto direction = l[1]\
    \ - l[0];\n    foreach (i, e; l[1..$])\n    {\n        if (i != 0 && direction\
    \ * (e - l[i - 1]) < 0)\n            return false;\n    }\n    return true;\n}",
  "{\n\treturn l.all!\"a < b\"(l);\n}\n ", "{\n    bool monotonic;\n    for (int i\
    \ = 1; i < l.length; i++) {\n        if (!(l[i] >= l[i - 1])) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n/*\nReturn true if array elements\
    \ are decreasing.\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/", "{\n    if(l.length == 0)\n        return\
    \ true;\n    bool is_monotonic = true;\n    bool increasing = l[0] < l[1];\n \
    \   if(increasing)\n    {\n        for(int i = 1; i < l.length; i++)\n       \
    \ {\n            if(l[i] < l[i-1])\n            {\n                is_monotonic\
    \ = false;\n                break;\n            }\n        }\n    }\n    else\n\
    \    {\n        for(int i = 1; i < l.length; i++)\n        {\n            if(l[i]\
    \ > l[i-1])\n            {\n                is_monotonic = false;\n          \
    \      break;\n            }\n        }\n    }\n    return is_monotonic;\n}\n\
    /*\nfind the first element in ascending order that is larger than the key value.\
    \ \nreturn 0 if the key value is the largest in the array.\n    >>> find_max_index_ascending([3L,\
    \ 4L, 5L, 10L], 8L)\n    3\n    >>> find_max_index_ascending([3L, 4L, 5L, 10L],\
    \ 10L)\n    3\n    >>> find_max_index_ascending([3L, 4L, 5L, 10L], 0L)\n    0\n\
    \    >>> find_max_index_ascending([3L, 4L, 5L, 10L], 5L)\n    2\n*/\nlong find_max_index_ascending(long[]\
    \ l, long key)\n{\n    long hi = l.length - 1;\n    if(key >= l[hi])\n       \
    \ return hi;\n    long lo = 0;\n    while(lo < hi)\n    {\n        long mid =\
    \ (lo + hi) / 2;\n        if(l[mid] <= key)\n            lo = mid + 1;\n     \
    \   else\n            hi = mid;\n    }\n    return lo;\n}\n/*\nBinary search for\
    \ key index in ascending ordered list. \nReturn index of the matched value. If\
    \ no match, return negative number \n    >>> binary_search_ascending([3L, 4L,\
    \ 5L, 10L", "{\n    \n    if (l.length < 3)\n        return true;\n    \n    auto\
    \ ids = std.algorithm.sort!((a, b) => a < b)(iota(l.length));\n    bool sign =\
    \ true;\n    bool old_sign = true;\n    bool res = true;\n    foreach (id; ids)\n\
    \    {\n        auto cur_i = id;\n        auto next_i = id + 1;\n        if (next_i\
    \ >= l.length)\n            break;\n        auto cur = l[cur_i];\n        auto\
    \ next = l[next_i];\n        sign = cur < next;\n        if (old_sign != sign)\n\
    \        {\n            res = false;\n            break;\n        }\n        old_sign\
    \ = sign;\n    }\n    return res;\n}\n/*\nReturn true is array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1.0, 2.0, 4.0, 20.0])\n    true\n\
    \    >>> monotonic([1.0, 20.0, 4.0, 10.0])\n    false\n    >>> monotonic([4.0,\
    \ 1.0, 0.0, -10.0])\n    true\n    \n*/", "{\n    auto len = l.length;\n    auto\
    \ sign = l[1] > l[0] ? 1 : -1;\n    for (int i = 1; i < len - 1; i++)\n    {\n\
    \        if (sign * (l[i + 1] - l[i]) < 0)\n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n/*\nReturn true if the element of array\
    \ is all the same.\n    >>> all_same([1L, 1L, 1L, 1L])\n    true\n    >>> all_same([1L,\
    \ 1L, 2L, 1L])\n    false\n    >>> all_same([1L, 1L, -1L, 1L])\n    false\n  \
    \  \n*/", "{\n    return isIncreasing(l) || isDecreasing(l);\n}", "{\n    if (l.length\
    \ > 1)\n    {\n        return equal(l, sort(l));\n    }\n    else \n    {\n  \
    \      return true;\n    }\n}", "    if (l.length < 2) return true;\n    auto\
    \ isLess = false;\n    auto isMore = false;\n    foreach (idx, item; l)\n    {\n\
    \        if (idx == 0) continue;\n        if (item > l[idx - 1]) isMore = true;\n\
    \        if (item < l[idx - 1]) isLess = true;\n        if (isMore && isLess)\
    \ return false;\n    }\n    return true;\n}", "{\n    long diff = l[1] - l[0];\n\
    \    for (int i = 1; i < l.length; i++)\n    {\n        if ((diff > 0 && l[i]\
    \ < l[i - 1]) || (diff < 0 && l[i] > l[i - 1]))\n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n/*\nGenerate all binomial coefficients\
    \ of n\n    >>> pascal(5)\n    ((1,), (1, 1), (1, 2, 1), (1, 3, 3, 1), (1, 4,\
    \ 6, 4, 1))\n*/\nauto pascal(long n) \n{\n    //\n    //if (n < 0)\n    //{\n\
    \    //    return null;\n    //}\n    //if (n == 0)\n    //{\n    //    return\
    \ tuple(tuple(1L));\n    //}\n    //auto prev = pascal(n - 1);\n    //auto next\
    \ = new long[prev.length + 1];\n    //next[0] = 1;\n    //next[next.length - 1]\
    \ = 1;\n    //for (int i = 1; i < next.length - 1; i++)\n    //{\n    //    next[i]\
    \ = prev[i - 1] + prev[i];\n    //}\n    //return tuple(next);\n    //\n    long[]\
    \ prev = null;\n    foreach (dummy; 0..n + 1)\n    {\n        long[] next = null;\n\
    \        if (dummy == 0)\n        {\n            next = new long[1];\n       \
    \     next[0] = 1;\n        }\n        else\n        {\n            next = new\
    \ long[prev.length + 1];\n            next[0] = 1;\n            next[next.length\
    \ - 1] = 1;\n            for (int i = 1; i < next.length - 1; i++)\n         \
    \   {\n                next[i] = prev[i - 1] + prev[i];\n            }\n     \
    \   }\n        yield tuple(next);\n        prev = next;\n    }\n}\n/*\nReturn\
    \ a list of (n", "{\n    long diff = 0L;\n    foreach (i, v; l) {\n        if\
    \ (i == 0)\n            continue;\n        else if (i == 1) {\n            diff\
    \ = v - l[i - 1];\n            continue;\n        }\n        else {\n        \
    \    if (v - l[i - 1] != diff) {\n                return false;\n            }\n\
    \        }\n    }\n    return true;\n}\n/*\nis_square(n)\nDetermine if a number\
    \ is square\n*/", "{\n\tassert(l.length > 0);\n\tlong[] z = l.dup;\n\tz.sort;\n\
    \treturn l == z || l == z.reverse;\n}\n/*\nReturn true if sequence elements are\
    \ monotonically increasing or decreasing.\n    >>> monotonic('abcde')\n    true\n\
    \    >>> monotonic('abhjik')\n    false\n    >>> monotonic('hello')\n    false\n\
    \    >>> monotonic('zyxwvutsrqponmlkjihgfedcba')\n    true\n    \n*/", "in {\n\
    \    assert(l.length > 0);\n}\nout(result) {\n    if (result)\n        assert(l.length\
    \ > 0);\n}\n{\n    return l.map!(a => a - l[0]).elementsAreEqual;\n}", "{\n  \
    \  int n = l.length;\n    bool increasing = true;\n    bool decreasing = true;\n\
    \    long sign = 1L;\n    long prev = 0L;\n    long curr = 0L;\n    foreach (i,\
    \ e; l) {\n        curr = e;\n        if (i > 0) {\n            sign = (curr -\
    \ prev) / abs(curr - prev);\n            increasing = increasing && (sign > 0L);\n\
    \            decreasing = decreasing && (sign < 0L);\n        }\n        prev\
    \ = curr;\n    }\n    return increasing || decreasing;\n}", "{\n    if (l.length\
    \ < 2) return true;\n    bool ret;\n    long first = l[0];\n    ret = true;\n\
    \    foreach (i, value; l) {\n        if (value > first) {\n            if (ret\
    \ == false) return false;\n            ret = true;\n        }\n        else if\
    \ (value < first) {\n            if (ret == true) return false;\n            ret\
    \ = false;\n        }\n        first = value;\n    }\n    return true;\n}\n/*\n\
    Return true if 'n' is prime.\n    >>> isprime(2L)\n    true\n    >>> isprime(3L)\n\
    \    true\n    >>> isprime(4L)\n    false\n    >>> isprime(5L)\n    true\n   \
    \ >>> isprime(10L)\n    false\n    >>> isprime(100L)\n    false\n*/", "{\n   \
    \ if (l.length==0) \n        return true;\n    if (l.length==1) \n        return\
    \ true;\n    if (l.length==2) \n        return l[0] < l[1];\n    int direction\
    \ = -1; // unknown\n    for (int i=1; i<l.length; i++) \n    {\n        if (l[i-1]\
    \ == l[i]) \n            continue;\n        if (direction == -1) \n          \
    \  direction = l[i-1] < l[i] ? 1 : 0;\n        if (direction == 0 && l[i-1] >\
    \ l[i]) \n            return false;\n        if (direction == 1 && l[i-1] < l[i])\
    \ \n            return false;\n    }\n    return true;\n}\n/*\nReturn true if\
    \ number is monotonically increasing or decreasing.\n    >>> monotonic(3198)\n\
    \    true\n    >>> monotonic(2465)\n    false\n    >>> monotonic(7689)\n    true\n\
    */", "{\n    bool result = true;\n    long prev = l[0];\n    int i = 1;\n    for\
    \ (; i < l.length; i++)\n    {\n        long curr = l[i];\n        if (prev >\
    \ curr)\n        {\n            result = false;\n            break;\n        }\n\
    \        prev = curr;\n    }\n    if (result)\n    {\n        return true;\n \
    \   }\n    result = true;\n    prev = l[0];\n    for (i = 1; i < l.length; i++)\n\
    \    {\n        long curr = l[i];\n        if (prev < curr)\n        {\n     \
    \       result = false;\n            break;\n        }\n        prev = curr;\n\
    \    }\n    return result;\n}", "{\n\tsize_t i; \n\tsize_t size = l.length;\n\t\
    \n\tif (size == 0) \n\t{\n\t\treturn true;\n\t}\n\telse \n\t{\n\t\tlong x0 = l[0];\n\
    \t\tbool increasing = true;\n\t\tbool decreasing = true;\n\t\tforeach (x; l[1..$])\
    \ \n\t\t{\n\t\t\tif (x0 > x) \n\t\t\t{\n\t\t\t\tincreasing = false;\n\t\t\t}\n\
    \t\t\tif (x0 < x) \n\t\t\t{\n\t\t\t\tdecreasing = false;\n\t\t\t}\n\t\t\tif (!increasing\
    \ && !decreasing) \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tx0 = x;\n\t\
    \t}\n\t\treturn true;\n\t}\n}\n/*\nReturn the number of elements in array that\
    \ are monotonically increasing.\n    >>> count_increasing([1L, 2L, 4L, 20L])\n\
    \    3\n    >>> count_increasing([1L, 20L, 4L, 10L])\n    2\n    >>> count_increasing([4L,\
    \ 1L, 0L, -10L])\n    1\n    >>> count_increasing([])\n    0\n*/\nsize_t count_increasing(long[]\
    \ l) \n{\n\tsize_t i; \n\tsize_t size = l.length;\n\tsize_t count = 0;\n\tif (size\
    \ == 0) \n\t{\n\t\treturn 0;\n\t}\n\telse \n\t{\n\t\tlong x0 = l[0];\n\t\tforeach\
    \ (x; l[1..$]) \n\t\t{\n\t\t\tif (x0 <= x) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\
    }\n\t\t\tx0 = x;\n\t\t}\n\t\treturn count;\n\t}\n}", "{\n    //printf(\"monotonic:%L\\\
    n\", l);\n    bool increasing = true;\n    if (l.length == 0)\n        return\
    \ true;\n    long val = l[0];\n    foreach (long i, idx; l)\n    {\n        if\
    \ (val != i)\n        {\n            if (val > i)\n                increasing\
    \ = false;\n            break;\n        }\n    }\n    if (increasing)\n    {\n\
    \        //printf(\"increasing:%L\\n\", l);\n        foreach (long i, idx; l)\n\
    \        {\n            if (val < i)\n                return false;\n        \
    \    val = i;\n        }\n    }\n    else\n    {\n        //printf(\"decreasing:%L\\\
    n\", l);\n        foreach (long i, idx; l)\n        {\n            if (val > i)\n\
    \                return false;\n            val = i;\n        }\n    }\n    return\
    \ true;\n}\n/*\nReturn true if a sequence is monotonic.\n    >>> isMonotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> isMonotonic([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> isMonotonic([4L, 1L, 0L, -10L])\n    true\n*/", "{\n    bool b = true;\n\
    \    foreach(immutable idx; 0 .. l.length - 1)\n    {\n        if(l[idx] < l[idx\
    \ + 1])\n        {\n            b = false;\n            break;\n        }\n  \
    \  }\n    return b;\n}", "{\n    bool increasing = true;\n    bool decreasing\
    \ = true;\n    long len = l.length;\n    if (len == 0) \n    {\n        return\
    \ true;\n    }\n    long last = l[0];\n    for (long i = 1; i < len; i++) \n \
    \   {\n        if (l[i] < last) \n        {\n            increasing = false;\n\
    \        }\n        if (l[i] > last) \n        {\n            decreasing = false;\n\
    \        }\n        last = l[i];\n    }\n    return increasing || decreasing;\n\
    }\n/*", "{\n    if (l.length <= 1) \n    {\n        return true;\n    }\n    else\
    \ \n    {\n        auto it = l.front;\n        auto next = l.popFront();\n   \
    \     int change = 0;\n        while (next !is null) \n        {\n           \
    \ change += (next - it);\n            if (change < 0) \n            {\n      \
    \          return false;\n            }\n            it = next;\n            next\
    \ = l.popFront();\n        }\n        return true;\n    }\n}\n/*\nGiven a list\
    \ of numbers, return a pair of numbers that have the lowest difference between\
    \ them.\n    >>> min_difference([1L, 3L, 20L, -11L, 100L, -120L])\n    [1L, 2L]\n\
    \    >>> min_difference([1L, 2L, 4L, 20L])\n    [1L, 2L]\n    >>> min_difference([1L,\
    \ 2L, 4L, 20L, 100L])\n    [1L, 2L]\n    >>> min_difference([1L, 2L, 4L, 20L,\
    \ 101L])\n    [20L, 21L]\n*/\nTuple!(long, long) min_difference(long[] l) \n{\n\
    \    l.sort;\n    long[] differences = [];\n    for (int i = 0; i < l.length -\
    \ 1; i++) \n    {\n        differences ~= l[i + 1] - l[i];\n    }\n    auto index\
    \ = differences.indexOf(differences.min);\n    return tuple(l[index], l[index\
    \ + 1]);\n}\n/*\nGiven a list of numbers, return a pair of numbers that have the\
    \ largest difference between them.\n    >>> max_difference([1L, 3L, 20L, -11L,\
    \ 100L, -120L])\n    [100L, 101L]\n    >>> max_difference([1L, 2L, 4L, 20L])\n\
    \    [20L, 21L]\n    >>> max_difference([1L, 2L, 4L, 20L, 100L])\n    [100L, 101L]\n\
    \    >>>", "    in \n    {\n        assert(l.length > 0);\n    }\n    body \n\
    \    {\n        long[] a = l[];\n        bool is_inc = l[0] < l[1];\n        for\
    \ (size_t i = 1; i < a.length; i++)\n        {\n            if ((is_inc && a[i]\
    \ < a[i - 1]) || (!is_inc && a[i] > a[i - 1]))\n            {\n              \
    \  return false;\n            }\n        }\n        return true;\n    }", "{\n\
    \    bool result = false;\n    bool direction = true;\n    for (size_t i = 0;\
    \ i < l.length - 1; i++) \n    {\n        bool dir = l[i] < l[i + 1];\n      \
    \  if(direction != dir) \n        {\n            if(result) \n            {\n\
    \                return false;\n            }\n            result = true;\n  \
    \          direction = dir;\n        }\n    }\n    return true;\n}", "{\n   bool\
    \ monotonic = true;\n   long[] diffs = [l[1] - l[0]];\n   for (int i = 1; i <\
    \ l.length; i++) \n   {\n      diffs ~= l[i] - l[i - 1];\n   }\n   for (int i\
    \ = 1; i < diffs.length; i++) \n   {\n      if (diffs[i] * diffs[i - 1] < 0) \n\
    \      {\n         monotonic = false;\n         break;\n      }\n   }\n   return\
    \ monotonic;\n}\n/*\nReturn position indices of monotonically increasing or decreasing\
    \ runs of\nlength >= window.\n    >>> monotonic([1L, 2L, 4L, 20L], window=2)\n\
    \    [0, 1, 2]\n    >>> monotonic([1L, 20L, 4L, 10L], window=2)\n    [0, 1]\n\
    \    >>> monotonic([4L, 1L, 0L, -10L], window=2)\n    [2, 3]\n*/\nlong[] monotonic(long[]\
    \ l, long window) \n{\n   long[] diffs = [l[1] - l[0]];\n   for (int i = 1; i\
    \ < l.length; i++) \n   {\n      diffs ~= l[i] - l[i - 1];\n   }\n   long[] idx\
    \ = [];\n   long sign_idx = -1;\n   for (int i = 0; i < diffs.length; i++) \n\
    \   {\n      if (diffs[i] != 0) \n      {\n         if (sign_idx == -1) \n   \
    \      {\n            sign_idx = i;\n         }\n         else if (sign(diffs[i])\
    \ != sign(diffs[sign_idx])) \n         {\n            if (i - sign_idx >= window)\
    \ \n            {\n               idx ~= range(sign_idx, i);\n            }\n\
    \            sign_idx = i;\n         }\n      }\n   }\n   if (diffs.length - sign_id",
  "{\n    foreach (i, element; l) \n    {\n        if (i > 0) \n        {\n      \
    \      if (element < l[i - 1])\n                return false;\n        }\n   \
    \ }\n    return true;\n}\n/*\nRemove consecutive duplicates from the array.\n\
    \    >>> dedup([1L, 2L, 4L, 4L, 20L])\n    [1L, 2L, 4L, 20L]\n*/\nlong[] dedup(long[]\
    \ l) \n{\n    return iota(l.length).filter!(i => l[i] != l[i + 1]).map!(i => l[i]).array;\n\
    }\n/*\nCompute the least common multiple (LCM) of the array elements.\n    >>>\
    \ lcm([1L, 2L, 3L, 4L])\n    12L\n*/\nlong lcm(long[] l) \n{\n    alias cur =\
    \ l[0];\n    for (int i = 1; i < l.length; i++) \n    {\n        cur = cur.lcm(l[i]);\n\
    \    }\n    return cur;\n}\n/*\nCompute the greatest common divisor (GCD) of the\
    \ array elements.\n    >>> gcd([1L, 2L, 3L, 4L])\n    1L\n*/\nlong gcd(long[]\
    \ l) \n{\n    alias cur = l[0];\n    for (int i = 1; i < l.length; i++) \n   \
    \ {\n        cur = cur.gcd(l[i]);\n    }\n    return cur;\n}\n/*\nCompute the\
    \ greatest common divisor (GCD) of the array elements.\n*/\nlong gcd(long[][]\
    \ l) \n{\n    alias cur = gcd(l[0]);\n    for (int i = 1; i < l.length; i++) \n\
    \    {\n        cur = cur.gcd(gcd(l[i]));\n    }\n    return cur;\n}\n/*\nRemove\
    \ all elements from `x` which are not elements of `y`.\n    >>> intersection([1L,\
    \ 2L, 3L, 4L], [3L, 1", "{\n    if (l.length < 2) \n    {\n        return true;\n\
    \    }\n    return l[0] < l[1] ? all!(a => a[0] < a[1])(zip(l[0 .. $ - 1], l[1\
    \ .. $])) : all!(a => a[0] > a[1])(zip(l[0 .. $ - 1], l[1 .. $]));\n}\n/*\nReturn\
    \ true if the given array represents a monotonic clockwise or counterclockwise\
    \ spiral.\n    >>> clockwise_spiral([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n\
    \    true\n    >>> clockwise_spiral([(0, 0), (0, 1), (1, 1), (1, 0), (1, 1)])\n\
    \    false\n*/", "in \n{\n\tassert(l.length > 0);\n}\nbody \n{\n    if (l.length\
    \ <= 1) return true;\n    bool incr = l[0] < l[1];\n    foreach (immutable i,\
    \ ref x; l) {\n        if (incr && x < l[i-1]) return false;\n        if (!incr\
    \ && x > l[i-1]) return false;\n    }\n    return true;\n}", "{\n    return std.array.isSorted(l)\
    \ || std.array.isSorted(l.length, l[0 .. l.length], std.array.Greater{long});\n\
    }\n/*\n    >>> someGreater([1L, 2L, 20L, 4L])\n    false\n    >>> someGreater([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> someGreater([4L, 1L, 0L, -10L])\n    false\n\
    \    \n*/", "in {\n    assert(l.length > 0);\n}\nout (bool result)\n{\n    result\
    \ == forall(i in 0 .. l.length - 2, l[i] < l[i + 1]);\n}", "pure nothrow \nin\
    \ {\n    assert(l.length > 0);\n}\nout (bool result)\n{\n    enum bool decreasing\
    \ = false;\n    enum bool increasing = false;\n    enum bool isMonotonic = false;\n\
    \    long[] lCopy = l.dup;\n    long first = lCopy[0];\n    lCopy = lCopy[1..$];\n\
    \    decreasing = all!((a, b) => a > b)(lCopy);\n    increasing = all!((a, b)\
    \ => a < b)(lCopy);\n    if (decreasing)\n    {\n        isMonotonic = true;\n\
    \    }\n    else if (increasing)\n    {\n        isMonotonic = true;\n    }\n\
    \    else\n    {\n        isMonotonic = false;\n    }\n    return isMonotonic;\n\
    }", "{\n    if (l.length < 2) return true;\n    bool inc = true;\n    bool dec\
    \ = true;\n    for (size_t i = 1; i < l.length; i++) {\n        inc &= l[i] >=\
    \ l[i - 1];\n        dec &= l[i] <= l[i - 1];\n    }\n    return inc || dec;\n\
    }\n/*\nReturn true if a full array is unique.\n    >>> unique([1L, 2L, 4L, 20L])\n\
    \    true\n    >>> unique([1L, 20L, 4L, 10L])\n    false\n    >>> unique([4L,\
    \ 1L, 0L, -10L])\n    true\n    >>> unique([1L, 1L, 0L, -10L])\n    false\n*/",
  "in{\n    assert(l.length > 0);\n}\nbody{\n    if (l.length == 1) return true;\n\
    \    bool increasing = l[1] > l[0];\n    for (int i = 1; i < l.length; i++) {\n\
    \        if (increasing) {\n            if (l[i] < l[i-1]) {\n               \
    \ return false;\n            }\n        } else {\n            if (l[i] > l[i-1])\
    \ {\n                return false;\n            }\n        }\n    }\n    return\
    \ true;\n}", "{\n    bool increasing = l[0] < l[1];\n    foreach (i, e; l)\n \
    \   {\n        if (i+1 >= l.length)\n            break;\n        if (increasing\
    \ && e > l[i+1])\n            return false;\n        if (!increasing && e < l[i+1])\n\
    \            return false;\n    }\n    return true;\n}", "{\n    if (l.length\
    \ == 0) \n    {\n        return true;\n    }\n    auto it = l.byKey();\n    auto\
    \ inc = it.next();\n    auto dec = it.next();\n    if (inc.value < dec.value)\
    \ \n    {\n        inc = it.next();\n        for (int i = inc.key + 1; i < l.length;\
    \ i++) \n        {\n            if (l[i] < l[i - 1]) \n            {\n       \
    \         return false;\n            }\n        }\n    }\n    else \n    {\n \
    \       dec = it.next();\n        for (int i = dec.key + 1; i < l.length; i++)\
    \ \n        {\n            if (l[i] > l[i - 1]) \n            {\n            \
    \    return false;\n            }\n        }\n    }\n    return true;\n}", "{\n\
    \    bool increasing = true;\n    bool decreasing = true;\n    /* ... */\n   \
    \ long[] copy = l.dup;\n    /* ... */\n    long first = copy[0];\n    long last\
    \ = first;\n    /* ... */\n    bool result = true;\n    /* ... */\n    foreach\
    \ (i, n; copy)\n    {\n        if (n > last)\n        {\n            increasing\
    \ = true;\n        }\n        else\n        {\n            increasing = false;\n\
    \        }\n        if (n < last)\n        {\n            decreasing = true;\n\
    \        }\n        else\n        {\n            decreasing = false;\n       \
    \ }\n        last = n;\n    }\n    if (!(increasing || decreasing))\n    {\n \
    \       result = false;\n    }\n    /* ... */\n    return result;\n}\n/*\nReturn\
    \ true iff all array elements are equal.\n    >>> all_equal([1L, 2L, 4L, 20L])\n\
    \    false\n    >>> all_equal([1L, 1L, 1L, 1L])\n    true\n    >>> all_equal([4L,\
    \ 4L, 4L, 4L])\n    true\n*/", "{\n\tbool is_increasing = false;\n\tbool is_decreasing\
    \ = false;\n\tforeach(index, i; l) \n\t{\n\t\tif(i == 0) \n\t\t{\n\t\t\tcontinue;\n\
    \t\t}\n\t\tlong diff = l[index - 1] - l[index];\n\t\tif(diff > 0) \n\t\t{\n\t\t\
    \tis_increasing = true;\n\t\t}\n\t\telse if(diff < 0) \n\t\t{\n\t\t\tis_decreasing\
    \ = true;\n\t\t}\n\t\tif(is_increasing & is_decreasing) \n\t\t{\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n    long[] s = l[].sort();\n   \
    \ bool increasing = s == l;\n    bool decreasing = s == l[].reverse();\n    return\
    \ increasing || decreasing;\n}", "{\n    int length = l.length;\n    bool decrement\
    \ = l[0] > l[length - 1];\n    int value = decrement ? l[0] : l[length - 1];\n\
    \    foreach (i, v; l)\n    {\n        if (decrement)\n        {\n           \
    \ if (v > value)\n                return false;\n        }\n        else\n   \
    \     {\n            if (v < value)\n                return false;\n        }\n\
    \        value = v;\n    }\n    return true;\n}\n/*\nReturn the indices where\
    \ the two input arrays differ.\nIf they are the same return array of length 0.\n\
    \    >>> list_of_differences([0L, 3L, 20L, 5L], [0L, 3L, 10L, 5L])\n    [2L]\n\
    \    >>> list_of_differences([0L, 2L, 20L, 5L], [0L, 3L, 10L, 5L])\n    [1L, 2L]\n\
    \    >>> list_of_differences([0L, 2L, 20L, 5L], [0L, 2L, 20L, 5L])\n    []\n*/\n\
    long[] list_of_differences(long[] in1, long[] in2) \n{\n    long[] l = new long[];\n\
    \    foreach (i, v; in1)\n    {\n        if (v != in2[i])\n            l ~= i;\n\
    \    }\n    return l;\n}\n/*\nReturn indices of consecutive differences in the\
    \ input array.\n    >>> consecutive_differences([0L, 2L, 20L, 5L])\n    [[0L,\
    \ 1L], [2L, 3L]]\n    >>> consecutive_differences([0L, 2L, 20L, 20L])\n    [[0L,\
    \ 1L], [2L, 3L]]\n    >>> consecutive_differences([0L, 2L, 20L, 21L])\n    [[0L,\
    \ 1L], [2L, 3L]]\n    >>> consecutive_differences([0L, 2L, 20L, 20L, 20L])\n \
    \   [[0L, 1L], [2L, 4L]]", "{\n    return l.all!(e => e == l[0] || e == l[0] +\
    \ 1 || e == l[0] - 1);\n}\nstatic assert(monotonic([4L, 4L, 4L, 4L]));", "{\n\
    \    if (l.length < 2) return true;\n    auto cmp = l[1] - l[0];\n    foreach\
    \ (i, ref elem; l[1..$]) {\n        if (cmp * (elem - l[i]) < 0) return false;\n\
    \    }\n    return true;\n}\n/*\nReturn true if array elements are increasing,\
    \ false otherwise.\n    >>> increasing([1L, 2L, 4L, 20L])\n    true\n    >>> increasing([1L,\
    \ 20L, 4L, 10L])\n    false\n*/", "{\n     if(l.length <= 2)\n        return true;\n\
    \    else\n    {\n        long d = l[1] - l[0];\n        foreach(i; 1..l.length-1)\n\
    \        {\n            if(l[i] - l[i-1] != d)\n                return false;\n\
    \        }\n        return true;\n    }\n}\n/*\nis_reversed([1L, 2L, 4L, 20L])\
    \ === false\nis_reversed([1L, 20L, 4L, 10L]) === false\nis_reversed([4L, 1L, 0L,\
    \ -10L]) === true\n*/", "{\n    bool inc = 0;\n    bool dec = 0;\n    foreach(i,\
    \ x; l)\n    {\n        if(i)\n        {\n            if(x > l[i-1])\n       \
    \     {\n                inc = 1;\n            }\n            else if(x < l[i-1])\n\
    \            {\n                dec = 1;\n            }\n        }\n    }\n  \
    \  return inc || dec;\n}", "  { \n  return (l.max-l.min)>=0; \n  }\n//Status:\
    \ Pass", "{\n    bool increasing = true;\n    bool decreasing = true;\n    for\
    \ (int i = 1; i < l.length; i++) {\n        if (l[i] < l[i - 1])\n           \
    \ increasing = false;\n        if (l[i] > l[i - 1])\n            decreasing =\
    \ false;\n    }\n    return increasing || decreasing;\n}\n// Check \"copy\" tag.\n\
    struct Pos(T)\n{\n    T x;\n    T y;\n    this(T x, T y)\n    {\n        this.x\
    \ = x;\n        this.y = y;\n    }\n}", "{\n\tbool incr = true;\n\tif (l.length\
    \ < 2) \n\t{\n\t\treturn incr;\n\t}\n\tforeach (immutable index, item; l) \n\t\
    {\n\t\tif (index > 0) \n\t\t{\n\t\t\tincr = l[index] > l[index - 1];\n\t\t\tif\
    \ (!incr) \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (incr) \n\t{\n\t\
    \treturn incr;\n\t}\n\tforeach (immutable index, item; l) \n\t{\n\t\tif (index\
    \ > 0) \n\t\t{\n\t\t\tincr = l[index] < l[index - 1];\n\t\t\tif (!incr) \n\t\t\
    \t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn incr;\n}\n/*\nReturn true is\
    \ the array contains the given value.\n    >>> contains([1L, 2L, 4L, 20L], 4L)\n\
    \    true\n    >>> contains([1L, 20L, 4L, 10L], 3L)\n    false\n*/", "{\n    bool\
    \ status = true;\n    for (int i = 1; i < l.length; i++)\n    {\n        if (l[i]\
    \ > l[i - 1])\n        {\n            status = true;\n        }\n        else\
    \ if (l[i] < l[i - 1])\n        {\n            status = true;\n        }\n   \
    \     else\n        {\n            status = false;\n            break;\n     \
    \   }\n    }\n    return status;\n}", "{\n    if (l.length<2)\n        return\
    \ true;\n    bool b=l[0]<l[1];\n    foreach(i;2..l.length)\n        if (b!=(l[i-1]<l[i]))\n\
    \            return false;\n    return true;\n}\n/*\nReturn the array of bins\
    \ corresponding to the bins\nof the histogram argument.\n    >>> histogram_bins([3L,\
    \ 5L, 7L, 8L])\n    [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5]\n\
    \    >>> histogram_bins([3L, 5L, 7L, 8L], True)\n    [0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10]\n    >>> histogram_bins([3L, 5L, 7L, 8L], False, 2)\n    [-0.5, 0.5,\
    \ 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5]\n    >>> histogram_bins([3L, 5L,\
    \ 7L, 8L], True, 2)\n    [0, 2, 4, 6, 8, 10]\n    >>> histogram_bins([-3L, -5L,\
    \ -7L, -8L], True, 2)\n    [-10, -8, -6, -4, -2, 0]\n*/\nreal[] histogram_bins(long[]\
    \ h, bool right=false, int width=1)\n{\n    assert(h.length>0);\n    if (right)\n\
    \        return array(iota(h[0]/width, (h[$-1]+1)/width)).map!(x=>x*width);\n\
    \    else\n        return array(iota(h[0]/width-0.5, (h[$-1]+1)/width-0.5)).map!(x=>x*width);\n\
    }\n/*\nReturn the array of counts corresponding to the bins\nof the hist", "{\n\
    \    import std.algorithm;\n    return minElement(l) == l[0] || maxElement(l)\
    \ == l[$-1];\n}\n/*", "{\n\t\n\tauto last = l[0];\n\tbool increasing = true;\n\
    \t\n\tforeach(elem; l)\n\t{\n\t\tif(elem < last)\n\t\t{\n\t\t\tincreasing = false;\n\
    \t\t\tbreak;\n\t\t}\n\t\tlast = elem;\n\t}\n\t\n\tif(increasing)\n\t\treturn true;\n\
    \t\t\n\tlast = l[0];\n\t\n\tforeach(elem; l)\n\t{\n\t\tif(elem > last)\n\t\t{\n\
    \t\t\treturn false;\n\t\t}\n\t\tlast = elem;\n\t}\n\t\n\treturn true;\n}", "{\n\
    \    if (l.length == 0)\n    {\n        return true;\n    }\n    else\n    {\n\
    \        bool isincreasing = l[0] < l[1];\n        auto prev = l[0];\n       \
    \ foreach (cur; l[1..$])\n        {\n            if (cur > prev && !isincreasing)\n\
    \            {\n                return false;\n            }\n            else\
    \ if (cur < prev && isincreasing)\n            {\n                return false;\n\
    \            }\n            prev = cur;\n        }\n        return true;\n   \
    \ }\n}\n/*\nReturn true if elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic_f([1.0, 2.0, 4.0, 20.0])\n    true\n    >>> monotonic_f([1.0,\
    \ 20.0, 4.0, 10.0])\n    false\n    >>> monotonic_f([4.0, 1.0, 0.0, -10.0])\n\
    \    true\n    \n*/", "{\n    if (l.length < 2) \n    {\n        return true;\n\
    \    }\n    auto first = l[0];\n    if (first < l[1]) \n    {\n        for (long\
    \ i = 1; i < l.length; i++) \n        {\n            if (l[i] < l[i - 1]) \n \
    \           {\n                return false;\n            }\n        }\n    }\n\
    \    else \n    {\n        for (long i = 1; i < l.length; i++) \n        {\n \
    \           if (l[i] > l[i - 1]) \n            {\n                return false;\n\
    \            }\n        }\n    }\n    return true;\n}", "in {\n    assert(l.length\
    \ > 0);\n}\nout(result) {\n    assert(result == false || result == true);\n}\n\
    {\n    long h = l[0];\n    bool positive = true;\n    for (long i = 1; i < l.length;\
    \ i++) {\n        if (l[i] < h) {\n            positive = false;\n        }\n\
    \        if (positive && l[i] < h) {\n            return false;\n        }\n \
    \       if (!positive && l[i] > h) {\n            return false;\n        }\n \
    \       h = l[i];\n    }\n    return true;\n}\n/*\nReturn a function that returns\
    \ True if given integer is in the list.\n    >>> isIn([1L, 2L, 4L, 20L])(4L)\n\
    \    true\n    >>> isIn([1L, 2L, 4L, 20L])(5L)\n    false\n    \n*/", "{\n\treturn\
    \ l.isSorted;\n}\n/*\n  Return the number of elements in the array a that are\
    \ greater than the argument v.\n      >>> howManyGreaterThan(2L, [1L, 2L, 5L,\
    \ 7L])\n      2\n      >>> howManyGreaterThan(0L, [])\n      0\n      >>> howManyGreaterThan(4L,\
    \ [4L, 4L, 4L, 4L])\n      0\n*/\nsize_t howManyGreaterThan(long v, long[] a)\
    \ \n{\n    return a.count!(x => x > v);\n}\n/*\n    Return the longest element\
    \ from an array of strings. If the array contains more than one such element,\
    \ return the first.\n        >>> longest(\"The\", \"quick\", \"brown\", \"fox\"\
    )\n        \"quick\"\n        >>> longest(\"The\", \"really quick\", \"brown\"\
    , \"fox\")\n        \"really quick\"\n        >>> longest(\"The\", \"quick\",\
    \ \"brown\", \"fox\", \"jumps\")\n        \"quick\"\n*/\nstring longest(string[]\
    \ a) \n{\n    return a.length ? a.max!(x => x.length) : null;\n}\n/*\n    Return\
    \ the number of vowels in a string.\n        >>> numVowels(\"The quick brown fox\"\
    )\n        5\n        >>> numVowels(\"The quick brown fox jummped over the lazy\
    \ dog\")\n        11\n        >>> numVowels(\"\")\n        0\n*/\nsize_t numVowels(string\
    \ s) \n{\n    return s.length ? s.filter!(x => \"aeiouAEIOU\".canFind(x)).length\
    \ : 0;\n}\n/*\n    Return true if the input string is a palindrome, and false\
    \ otherwise.\n        >>> isPalindrome(\"racecar\")\n        true\n        >>>\
    \ isPalindrome(\"balloon\")\n        false\n        >>> isPalindrome(\"\")\n \
    \       true\n*/", "{\n    bool result;\n    auto n = l.length;\n    if (n < 2)\
    \ \n    {\n        result = true;\n    } \n    else \n    {\n        if (l[0]\
    \ < l[1]) \n        {\n            bool increasing = true;\n            for (size_t\
    \ i = 1; i < n - 1; i++) \n            {\n                if (l[i] > l[i + 1])\
    \ \n                {\n                    increasing = false;\n             \
    \       break;\n                }\n            }\n            result = increasing;\n\
    \        } \n        else \n        {\n            bool decreasing = true;\n \
    \           for (size_t i = 1; i < n - 1; i++) \n            {\n             \
    \   if (l[i] < l[i + 1]) \n                {\n                    decreasing =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       result = decreasing;\n        }\n    }\n    return result;\n}", "{\n \
    \ if (l.length == 0) \n  {\n    return true;\n  }\n  const long threshold = 5;\n\
    \  int long_i_last = l[0];\n  long long_delta_sum = 0;\n  foreach (i, long_i;\
    \ l) \n  {\n    const long long_delta = long_i - long_i_last;\n    long_delta_sum\
    \ += long_delta;\n    if (long_delta_sum > threshold) \n    {\n      return false;\n\
    \    }\n    long_i_last = long_i;\n  }\n  return true;\n}\n/*\nConvert an array\
    \ of uniform samples to an array of quantiles.\n    >>> uniform_to_quantile([0L,\
    \ 0L, 1L, 1L, 1L, 1L, 2L, 3L])\n    [0L, 0L, 0L, 0L, 0L, 0L, 1L, 1L]\n    \n*/\n\
    long[] uniform_to_quantile(long[] u) \n{\n  const long n = u.length;\n  long[]\
    \ q = new long[n];\n  long long_quantile = 0;\n  long long_uniform = u[0];\n \
    \ long long_repetitions = 0;\n  foreach (long_i; u) \n  {\n    if (long_i != long_uniform)\
    \ \n    {\n      for (long j = 0; j < long_repetitions; j++) \n      {\n     \
    \   q[j] = long_quantile;\n      }\n      long_quantile++;\n      long_uniform\
    \ = long_i;\n      long_repetitions = 0;\n    }\n    long_repetitions++;\n  }\n\
    \  for (long j = 0; j < long_repetitions; j++) \n  {\n    q[j] = long_quantile;\n\
    \  }\n  return q;\n}\n/*", "{\n    if(l.length < 2)\n        return true;\n  \
    \  switch(sign(l[1] - l[0])) \n    {\n        case 1: \n            foreach(n;\
    \ l[1..$])\n                if(n < l[$-1])\n                    return false;\n\
    \            break;\n        case -1: \n            foreach(n; l[1..$])\n    \
    \            if(n > l[$-1])\n                    return false;\n            break;\n\
    \        default: \n            foreach(n; l[1..$])\n                if(n != l[$-1])\n\
    \                    return false;\n            break;\n    }\n    return true;\n\
    }", "{\n    return !uniq(sort(l)).empty;\n}\n/*\nReturn a sequence of corresponding\
    \ values from two input sequences.\n    >>> correspondence([1L, 1L, 2L, 2L, 3L,\
    \ 3L], [1L, 2L, 3L, 4L, 5L, 6L])\n    [1L, 2L, 3L]\n    >>> correspondence([10L,\
    \ 9L, 8L, 7L, 6L, 5L], [10L, 10L, 10L, 7L, 7L, 5L])\n    [10L, 10L, 10L, 7L, 7L,\
    \ 5L]\n    >>> correspondence([1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 2L, 2L, 3L, 3L])\n\
    \    [1L, 1L, 2L, 2L, 3L, 3L]\n*/\nlong[] correspondence(long[] x, long[] y) \n\
    {\n    size_t[] idx = sort(zip(y, iota(y.length)), true).map!(t => t[1]).array;\n\
    \    return x[idx];\n}\n/*\nReturn list of indices of values in list that are\
    \ below or equal to threshold.\n    >>> threshold_idx([1L, 2L, 3L, 4L, 5L], 3L)\n\
    \    [0L, 1L, 2L]\n    >>> threshold_idx([1L, 4L, 3L, 4L, 5L], 3L)\n    [0L, 2L]\n\
    \    >>> threshold_idx([5L, 4L, 3L, 2L, 1L], 3L)\n    [4L, 3L, 2L]\n*/\nsize_t[]\
    \ threshold_idx(long[] l, long threshold) \n{\n    return iota(l.length).filter!(i\
    \ => l[i] <= threshold).array;\n}\n/*\nReturn the sum of elements in a sequence.\n\
    \    >>> sum_seq([1L, 2L, 3L, 4L, 5L])\n    15L\n    >>> sum_seq([1L, 1L, 1L,\
    \ 1L, 1L])", "{\n    bool increasing;\n    bool decreasing;\n    if (l.length\
    \ > 1) {\n        increasing = decreasing = true;\n        for (int i = 1; i <\
    \ l.length; i++) {\n            if (l[i - 1] > l[i]) {\n                increasing\
    \ = false;\n            }\n            if (l[i - 1] < l[i]) {\n              \
    \  decreasing = false;\n            }\n        }\n        return increasing ||\
    \ decreasing;\n    }\n    return true;\n}\n/*", "{\n\tbool result = true;\n\t\
    for (long i = 0; i < l.length - 1; i++)\n\t{\n\t\tif (l[i] > l[i + 1])\n\t\t{\n\
    \t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "{\n  \
    \  static assert(l.length >= 2);\n    long[] _l = l.dup;\n    _l.sort;\n    if\
    \ (_l[0] == _l[$-1]) \n    {\n        return true;\n    }\n    else \n    {\n\
    \        return l == _l || l == _l[0..$].reverse;\n    }\n}", "{\n    bool increasing\
    \ = true;\n    foreach (i, n; 2 .. l.length)\n    {\n        if (l[i] < l[i -\
    \ 1])\n        {\n            increasing = false;\n            break;\n      \
    \  }\n    }\n    if (increasing)\n    {\n        return true;\n    }\n    // not\
    \ increasing\n    bool decreasing = true;\n    foreach (i, n; 2 .. l.length)\n\
    \    {\n        if (l[i] > l[i - 1])\n        {\n            decreasing = false;\n\
    \            break;\n        }\n    }\n    return decreasing;\n}\n/*\nReturn the\
    \ index of the first element of the array in which the elements are monotonically\
    \ increasing.\n    >>> monotonic_increase_index([1L, 2L, 4L, 20L])\n    0\n  \
    \  >>> monotonic_increase_index([1L, 20L, 4L, 10L])\n    2\n    >>> monotonic_increase_index([4L,\
    \ 1L, 0L, -10L])\n    3\n*/\nlong monotonic_increase_index(long[] l) \n{\n   \
    \ foreach (i, n; 1 .. l.length)\n    {\n        if (l[i] < l[i - 1])\n       \
    \ {\n            return i;\n        }\n    }\n    return l.length;\n}\n/*\nReturn\
    \ the index of the first element of the array in which the elements are monotonically\
    \ decreasing.\n    >>> monotonic_decrease_index([1L, 2L, 4L, 20L])\n    3\n  \
    \  >>> monotonic_decrease_index([1L, 20L, 4L, 10L])\n    1\n    >>> monotonic_decrease_index([4L,\
    \ 1L, 0L, -10L])\n    0\n*/\nlong monotonic_decrease_index(long[] l) \n{\n   \
    \ foreach (i, n; 1 .. l.length)\n    {\n        if (l[i] > l[i - 1])\n       \
    \ {\n            return i;\n        }\n    }\n    return l.length", "{\n    if(l.length\
    \ < 2) return true;\n    long prev = l[0];\n    long change = 0;\n    for(int\
    \ i = 1; i < l.length; i++) {\n        if(change == 0) {\n            if(l[i]\
    \ > prev)\n                change = 1;\n            else if(l[i] < prev)\n   \
    \             change = -1;\n        } else if(l[i] > prev && change < 0)\n   \
    \         return false;\n        else if(l[i] < prev && change > 0)\n        \
    \    return false;\n        prev = l[i];\n    }\n    return true;\n}", "{\n  \
    \  long n;\n    n = l.length;\n    if (n < 2) \n    {\n        return true;\n\
    \    }\n    if (l[0] < l[1]) \n    {\n        for (size_t i = 1; i < n - 1; i++)\
    \ \n        {\n            if (l[i] > l[i + 1]) \n            {\n            \
    \    return false;\n            }\n        }\n    }\n    else \n    {\n      \
    \  for (size_t i = 1; i < n - 1; i++) \n        {\n            if (l[i] < l[i\
    \ + 1]) \n            {\n                return false;\n            }\n      \
    \  }\n    }\n    return true;\n}", "{\n    int delta = 0;\n    foreach (long x;\
    \ l) {\n        if (delta == 0) {\n            delta = (x - l[$ - 1]);\n     \
    \   } else {\n            if (signbit(delta) != signbit(x - l[$ - 1])) {\n   \
    \             return false;\n            }\n        }\n    }\n    return true;\n\
    }\n//Return true if array elements are monotonically increasing.", "{\n\tbool\
    \ mono = true;\n\tbool mono_increasing = true;\n\tbool mono_decreasing = true;\n\
    \tl = l.sort();\n\tfor (size_t i = 0, j = i + 1; i < l.length; i++, j++)\n\t{\n\
    \t\tif (l[i] > l[j])\n\t\t{\n\t\t\tmono_increasing = false;\n\t\t}\n\t\tif (l[i]\
    \ < l[j])\n\t\t{\n\t\t\tmono_decreasing = false;\n\t\t}\n\t}\n\treturn mono =\
    \ mono_increasing || mono_decreasing;\n}", "    @safe pure nothrow \n{\n    enum\
    \ op = (l[1] > l[0]) ? 1 : -1;\n    size_t i = 1;\n    foreach (int j; l[1..$])\
    \ \n    {\n        if (op * (l[j] - l[j - 1]) < 0) \n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n \n/*\nReturn the bin of the\
    \ given value.\n   >>> bin(10L, [0L, 10L, 20L])\n   0\n   >>> bin(18L, [0L, 10L,\
    \ 20L])\n   1\n   >>> bin(20L, [0L, 10L, 20L])\n   2\n*/\nsize_t bin(long value,\
    \ in long[] values) \n    @safe pure nothrow \n{\n    import std.algorithm : binarySearch;\n\
    \    if (binarySearch(values, value) >= 0)\n    {\n        return binarySearch(values,\
    \ value);\n    }\n    return binarySearch(values, value).anyPos;\n}\n \n/*\nReturns\
    \ an array that contains the sequence: start, start + step, ...\n   >>> arange(1L,\
    \ 10L, 1L)\n   [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]\n   >>> arange(2L, 10L, 2L)\n\
    \   [2L, 4L, 6L, 8L]\n   >>> arange(1L, 10L, 3L)\n   [1L, 4L, 7L]\n*/\nlong[]\
    \ arange(long start, long stop, long step) \n    @safe pure nothrow \n{\n    long[]\
    \ l;\n    l ~= start;\n    if (step == 0)\n    {\n        return l;\n    }\n \
    \   for (; start < stop; start += step)\n    {\n        l ~= start;\n    }\n \
    \   return l;\n}\n \n/*\nReturns a range that contains the sequence: start, start\
    \ + step, ...\n   >>> rarange(1L, 10L, 1", "{\n\tassert(l.length > 1);\n\tbool\
    \ increasing = l[0] < l[1];\n\tfor (long i = 1; i < l.length; i++)\n\t{\n\t\t\
    if (increasing)\n\t\t{\n\t\t\tif (l[i] < l[i - 1])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (l[i] > l[i - 1])\n\t\t\t{\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "{\n    return all(l[i]\
    \ &lt;= l[i+1] for i in 0..l.length-2) || all(l[i] &gt;= l[i+1] for i in 0..l.length-2);\n\
    }\n/*\nGenerate polygon points by finding the intersections of a circle and the\n\
    line L = [x1, y1, x2, y2] (endpoints)\n*/\nTuple!(long[], long[]) polygon_points(long\
    \ x1, long y1, long x2, long y2, long r) \n{\n    enum delta_x = abs(x2 - x1);\n\
    \    enum delta_y = abs(y2 - y1);\n    enum delta_x2 = delta_x * delta_x;\n  \
    \  enum delta_y2 = delta_y * delta_y;\n    enum delta_r2 = r * r;\n    auto a\
    \ = delta_y2 + delta_x2;\n    auto b = -2 * x1 * delta_y2 - 2 * y1 * delta_x2;\n\
    \    auto c = delta_y2 * x1 * x1 + delta_x2 * y1 * y1 - delta_r2 * delta_y2;\n\
    \    double xm = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\n    double xn = (-b\
    \ - sqrt(b * b - 4 * a * c)) / (2 * a);\n    double ym = (delta_r2 - delta_x2\
    \ * xm) / delta_y2;\n    double yn = (delta_r2 - delta_x2 * xn) / delta_y2;\n\
    \    return tuple(long[](xm, ym), long[](xn, yn));\n}\n/*\nGiven x axis endpoints\
    \ P = [x1, y1, x2, y2] (endpoints) and a set of points\nrepresenting the polygon\
    \ S = [x1, y1, x2, y2, x3, y3, x4, y4]\n(clockwise), determine the polygon intersection\
    \ area.\n    >>> polygon_area(", "{\n\tint i = 0;\n\tint j = 0;\n\tbool flag =\
    \ false;\n\tif (l.length == 1) { return true; }\n\tfor (int i = 0; i < l.length\
    \ - 1; i++) {\n\t\tif (l[i] == l[i + 1]) { continue; }\n\t\telse if (l[i] < l[i\
    \ + 1]) {\n\t\t\tif (flag == false) { flag = true; }\n\t\t\telse if (flag == true)\
    \ { continue; }\n\t\t}\n\t\telse if (l[i] > l[i + 1]) {\n\t\t\tif (flag == false)\
    \ { flag = false; }\n\t\t\telse if (flag == true) { return false; }\n\t\t}\n\t\
    }\n\treturn true;\n}", "{\n    enum bool isIncreasing = l[0] < l[1];\n    foreach\
    \ (index, element; l)\n    {\n        if (isIncreasing)\n        {\n         \
    \   if (element < l[index - 1])\n            {\n                return false;\n\
    \            }\n        }\n        else\n        {\n            if (element >\
    \ l[index - 1])\n            {\n                return false;\n            }\n\
    \        }\n    }\n    return true;\n}", "{\n    foreach (e; l[1 .. $])\n    {\n\
    \        if (e < l[0]) \n        {\n            return false;\n        }\n   \
    \     l[0] = e;\n    }\n    return true;\n}\n/*\n    Return true if the given\
    \ sequence is monotonic,\n    that is, if it is strictly increasing or decreasing.\n\
    \    Return false otherwise.\n    >>> monotonic([1L, 2L, 3L, 4L])\n    true\n\
    \    >>> monotonic([2L, 2L, 4L, 10L])\n    true\n    >>> monotonic([4L, 4L, 4L,\
    \ 4L])\n    true\n    >>> monotonic([1L, 2L, -3L, -4L])\n    true\n    >>> monotonic([4L,\
    \ 1L, 10L, 0L])\n    false\n    >>> monotonic([4L, 3L, 2L, 1L])\n    true\n  \
    \  >>> monotonic([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L,\
    \ 15L, 16L, 17L, 18L, 19L, 20L, 21L, 22L, 23L, 24L, 25L, 26L, 27L, 28L, 29L, 30L,\
    \ 31L, 32L, 33L, 34L, 35L, 36L, 37L, 38L, 39L, 40L, 41L, 42L, 43L, 44L, 45L, 46L,\
    \ 47L, 48L, 49L, 50L, 51L, 52L, 53L, 54L, 55L, 56L, 57L, 58L, 59L, 60L, 61L, 62L,\
    \ 63L, 64L, 65L, 66L, 67L, 68L, 69L, 70L, 71L, 72L, 73L, 74L, 75L, 76L, 77L, 78L,\
    \ 79L, 80L, 81L, 82L, 83L, 84L, 85L, 86L, 87L, 88L, 89L, 90L, 91L, 92L, 93L",
  "{\n    if (l.length < 2)\n        return true;\n    auto first = l[0];\n    auto\
    \ inc = 0;\n    foreach (i, el; l) \n    {\n        if (inc == 0) \n        {\n\
    \            inc = el - first;\n            first = el;\n        }\n        else\
    \ if (inc > 0) \n        {\n            if (el - first != inc)\n             \
    \   return false;\n            first = el;\n        }\n        else if (inc <\
    \ 0) \n        {\n            if (el - first != inc)\n                return false;\n\
    \            first = el;\n        }\n    }\n    return true;\n}", "{\n  /*\n \
    \ from std.algorithm:\n    foldLeft(alias binaryFunctor = \"a.opBinary(\\\"+\\\
    \")\", Range)(Range r, in T initial)\n    If Range is an input range, foldLeft\
    \ will iterate through the input range\n    r by repeatedly calling popFront.\
    \ For each iteration, the result value is\n    updated by calling binaryFunctor\
    \ on the result value and the next value\n    from the input range.\n  */\n  return\
    \ [l[i]>l[i+1]?-1L:1L].foldLeft!(\"a*b\")([0L]).array == [-1L,-1L];\n  // this\
    \ is just a test. for the real function use:\n  //std.algorithm.isSorted(l, std.sort.increasing);\n\
    }\n/*\nFind the index of the first element for which predicate is true.\n    >>>\
    \ searchFirst([0L, 1L, 2L, 2L, 2L, 3L, 4L, 5L], (a) => a == 2L)\n    2\n*/\nsize_t\
    \ searchFirst(long[] l, alias pred)\n{\n  return l.find!pred;\n}\n/*\nFind the\
    \ index of the last element for which predicate is true.\n    >>> searchLast([0L,\
    \ 1L, 2L, 2L, 2L, 3L, 4L, 5L], (a) => a == 2L)\n    4\n*/\nsize_t searchLast(long[]\
    \ l, alias pred)\n{\n  return l.rfind!pred;\n}\n/*\nFind the first element in\
    \ the input range that has a value greater than or\nequal to the specified value.\n\
    \    >>> searchLe([0L, 1L, 2L, 2L, 2L, 3L, 4L, 5L], 2L)\n    2\n*/\nsize_t searchLe(long[]\
    \ l, long a)\n{\n  return searchFirst(l, (x)=>a>=x);\n}\n/*\nFind the first element\
    \ in the input range that has a value greater than the\nspecified value.\n   \
    \ >>> searchLt([0L, 1L, 2L, 2L, 2L, 3L, 4L, 5L], 2", "{\n    if (l.length == 0)\
    \ return true;\n    long first = l[0];\n    bool pos = false;\n    foreach (i,\
    \ e; l) {\n        if (i != 0) {\n            if (e > first) pos = true;\n   \
    \         else if (e < first) pos = false;\n            else return false;\n \
    \       }\n        if (i != 0 && ((pos && e < l[i - 1]) || (!pos && e > l[i -\
    \ 1]))) return false;\n    }\n    return true;\n}\n ", "{\n    if (l.length <\
    \ 2) return true;\n    long a = l[0];\n    long b = l[1];\n    if (a == b) return\
    \ monotonic(l[1..$]);\n    return l.reduce!((c, d) => (c == d) || (c < d) == (a\
    \ < b) ? d : c) == l[$ - 1];\n}", "{\n    bool up = false;\n    bool down = false;\n\
    \    for (auto i = 1; i < l.length; i++) \n    {\n        if (l[i] > l[i - 1])\
    \ \n        {\n            up = true;\n        }\n        else if (l[i] < l[i\
    \ - 1]) \n        {\n            down = true;\n        }\n        if (up && down)\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n/*", "{\n\treturn  monoCheck(0L, l[0L], 0L, l.length);\n}", "{\n    long last\
    \ = l[0];\n    bool increasing = true;\n    foreach(i, current; l) {\n       \
    \ if (last > current) {\n            increasing = false;\n            break;\n\
    \        }\n        last = current;\n    }\n    if (increasing) return true;\n\
    \    last = l[0];\n    foreach(i, current; l) {\n        if (last < current) return\
    \ false;\n        last = current;\n    }\n    return true;\n}\n// Ditto, but returns\
    \ a tuple\nTuple!(bool, bool) monotonic2(long[] l) {\n    long last = l[0];\n\
    \    bool increasing = true;\n    bool decreasing = true;\n    foreach(i, current;\
    \ l) {\n        if (last > current) increasing = false;\n        if (last < current)\
    \ decreasing = false;\n        last = current;\n    }\n    return tuple(increasing,\
    \ decreasing);\n}\n/*", "pure nothrow @nogc\n{\n    enum prev = l[0];\n    foreach(current;\
    \ l[1 .. $]) \n    {\n        if(current < prev) \n        {\n            return\
    \ false;\n        }\n        prev = current;\n    }\n    return true;\n}\n/*\n\
    Return true is array elements are monotonically increasing or decreasing.\n  \
    \  >>> monotonic([1, 2, 4, 20])\n    true\n    >>> monotonic([1, 20, 4, 10])\n\
    \    false\n    >>> monotonic([4, 1, 0, -10])\n    true\n    \n*/", "{\n    auto\
    \ is_monotonic = true;\n    for (size_t i = 0, j = i + 1; i < l.length - 1; i++,\
    \ j = i + 1) \n    {\n        if (l[i] > l[j]) \n        {\n            is_monotonic\
    \ = false;\n            break;\n        }\n    }\n    return is_monotonic;\n}\n\
    /*\nReturn n-th prime number.\n    >>> nth_prime(0)\n    2\n    >>> nth_prime(1)\n\
    \    3\n    >>> nth_prime(5)\n    11\n    >>> nth_prime(10)\n    29\n*/\nlong\
    \ nth_prime(long n) \n{\n    long prime = 0L;\n    long count = 0L;\n    long\
    \ num = 2L;\n    while (true) \n    {\n        if (is_prime(num)) \n        {\n\
    \            count += 1L;\n            if (count > n) \n            {\n      \
    \          break;\n            }\n            prime = num;\n        }\n      \
    \  num += 1L;\n    }\n    return prime;\n}\n/*\nReturns the sum of the digits\
    \ of a number.\n    >>> digits_sum(123)\n    6\n    >>> digits_sum(100100)\n \
    \   2\n    >>> digits_sum(12348963)\n    45\n*/\nlong digits_sum(long n) \n{\n\
    \    return sum(digits(n));\n}\n/*\nReturn true if a number is a prime number.\n\
    \    >>> is_prime(2)\n    true\n    >>> is_prime(1)\n    false\n    >>> is_prime(0)\n\
    \    false\n    >>> is_prime(15485863)\n    true\n*/", "    pure nothrow\n{\n\
    \    bool state = true;\n    enum dir = 1;\n    foreach(i, e; l) {\n        if\
    \ (i == 0) {\n            continue;\n        }\n        if (e > l[i - 1]) {\n\
    \            if (dir == -1) {\n                state = false;\n              \
    \  break;\n            }\n            else {\n                dir = 1;\n     \
    \       }\n        }\n        else if (e < l[i - 1]) {\n            if (dir ==\
    \ 1) {\n                state = false;\n                break;\n            }\n\
    \            else {\n                dir = -1;\n            }\n        }\n   \
    \ }\n    return state;\n}", "{\n    bool inc = true;\n    bool dec = true;\n \
    \   for (size_t i = 1; i < l.length; i++) {\n        inc &= l[i] >= l[i - 1];\n\
    \        dec &= l[i] <= l[i - 1];\n    }\n    return inc || dec;\n}", "{\n   \
    \ return l.canFind(i => l[i] > l[i+1]) == l.canFind(i => l[i] < l[i+1]);\n}\n\
    /*\nScales the values of the array elements so that they add up to 1.\n    >>>\
    \ normalize([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n    [0.1, 0.1,\
    \ 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]\n    >>> normalize([-1.0, 1.0, 0.0])\n\
    \    [0.0, 1.0, 0.0]\n*/\ndouble[] normalize(double[] a)\n{\n    return a.map!((double\
    \ f) => f / a.sum)();\n}\n/*\nFor every element in x, return its distance to the\
    \ closest element in y.\n    >>> x = dmd.range(0L, 10L)\n    >>> y = dmd.range(2L,\
    \ 5L)\n    >>> closest(x, y)\n    [2, 1, 0, 0, 0, 1, 2, 3, 4, 4]\n    >>> closest(y,\
    \ x)\n    [2, 2, 1, 0, 0]\n*/\nlong[] closest(long[] x, long[] y)\n{\n    auto\
    \ z = new long[x.length];\n    for (long i = 0; i < x.length; i++) {\n       \
    \ z[i] = (i, i => abs(x[i] - y[i])).min().item1;\n    }\n    return z;\n}\n/*\n\
    Compute the sum of squares of a given array.\n    >>> squared(1..5)\n    55\n\
    */\nlong squared(long[] l) \n{\n    return l.sum!((long n) => n * n)();\n}\n/*\n\
    Returns the consecutive numbers of the largest segment in which all the \nvalues\
    \ are identical.\n    >>> largestSegment([\"a\", \"a\", \"b\", \"c\", \"b", "{\n\
    \    long[] ar = l;\n    long[] ar2 = l;\n    for (int i = 0; i < ar.length; i++)\n\
    \    {\n        if (ar[i] > ar[i+1])\n        {\n            long t = ar[i];\n\
    \            ar[i] = ar[i+1];\n            ar[i+1] = t;\n        }\n    }\n  \
    \  for (int j = 0; j < ar2.length; j++)\n    {\n        if (ar2[j] < ar2[j+1])\n\
    \        {\n            long t = ar2[j];\n            ar2[j] = ar2[j+1];\n   \
    \         ar2[j+1] = t;\n        }\n    }\n    if (ar.equals(l) || ar2.equals(l))\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\n \n/*\nReturn a list of indices where the array breaks monotonicity\n\
    \    >>> monotonic_breaks([1L, 2L, 4L, 20L])\n    []\n    >>> monotonic_breaks([1L,\
    \ 20L, 4L, 10L])\n    [1]\n    >>> monotonic_breaks([4L, 1L, 0L, -10L])\n    [1]\n\
    \    >>> monotonic_breaks([1L, 2L, 20L, 4L, 10L])\n    [2]\n*/\nlong[] monotonic_breaks(long[]\
    \ l) \n{\n    long[] ar = l;\n    long[] ar2 = l;\n    for (int i = 0; i < ar.length;\
    \ i++)\n    {\n        if (ar[i] > ar[i+1])\n        {\n            long t = ar[i];\n\
    \            ar[i] = ar[i+1];\n            ar[i+1] = t;\n        }\n    }\n  \
    \  for (int j = 0; j < ar2.length; j++)\n    {\n        if (ar2[j] < ar2[j+1])\n\
    \        {\n            long t = ar2[j", "{\n    assert(l.length > 0);\n    bool\
    \ increasing = true;\n    foreach(i, e; l) \n    {\n        if (e < l[0]) \n \
    \       {\n            increasing = false;\n            break;\n        }\n  \
    \  }\n    if (increasing) \n    {\n        return true;\n    }\n    else \n  \
    \  {\n        foreach(i, e; l) \n        {\n            if (e > l[0]) \n     \
    \       {\n                return false;\n            }\n        }\n        return\
    \ true;\n    }\n}\n/*\nReturn true if array elements are equal\n    >>> equal([1L,\
    \ 1L, 1L, 1L])\n    true\n    >>> equal([1L, 1L, 2L, 1L])\n    false\n*/", "in\
    \ \n{\n    if(l.length<=1) return true;\n    else return l[0] < l[1] ? isSorted!(\"\
    >=\")(l) : isSorted!(\"<=\")(l);\n}\n/*\n    Provide a recursive way to calculate\
    \ fibonacci\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(0)\n    0\n    >>>\
    \ fibonacci(1)\n    1\n    >>> fibonacci(2)\n    1\n*/\nlong fibonacci(long n)\
    \ \nin\n{\n    if(n==0) return 0;\n    else if(n==1) return 1;\n    else return\
    \ fibonacci(n-1) + fibonacci(n-2);\n}\n/*\n    Provide a recursive way to calculate\
    \ factorial\n    >>> factorial(10)\n    3628800\n    >>> factorial(0)\n    1\n\
    \    >>> factorial(1)\n    1\n    >>> factorial(2)\n    2\n*/\nlong factorial(long\
    \ n) \nin\n{\n    if(n<=1) return 1;\n    else return n * factorial(n-1);\n}\n\
    /*\n    Check if a number is prime or not\n    >>> is_prime(5)\n    true\n   \
    \ >>> is_prime(6)\n    false\n    >>> is_prime(1)\n    false\n    >>> is_prime(2)\n\
    \    true\n*/", "{\n     bool m=true;\n     bool increase=true;\n     \n     if(l.length>1)\n\
    \     {\n        for(int i=0;i<l.length-1;i++)\n        {\n            if(l[i]<l[i+1])\n\
    \            {\n                increase=true;\n            }\n            else\
    \ if(l[i]>l[i+1])\n            {\n                increase=false;\n          \
    \  }\n            else\n            {\n                m=false;\n            \
    \    break;\n            }\n            \n            if(i==0)\n            {\n\
    \                m=true;\n            }\n            else\n            {\n   \
    \             if(increase!=increase[i-1])\n                {\n               \
    \     m=false;\n                    break;\n                }\n            }\n\
    \        }\n     }\n     return m;\n}", "{\n    int i = 1;\n    int size = l.length;\n\
    \    if(size == 1) \n    {\n        return true;\n    }\n    else \n    {\n  \
    \      if(l[i] > l[i - 1]) \n        {\n            while(i < size) \n       \
    \     {\n                if(l[i] < l[i - 1]) \n                {\n           \
    \         return false;\n                }\n                i++;\n           \
    \ }\n        }\n        else \n        {\n            while(i < size) \n     \
    \       {\n                if(l[i] > l[i - 1]) \n                {\n         \
    \           return false;\n                }\n                i++;\n         \
    \   }\n        }\n    }\n    return true;\n}\n// Return true if all elements of\
    \ a are greater than or equal to b.", "{\n    long[] copy = l.dup;\n    copy.sort;\n\
    \    return copy == l || copy == l.reverse;\n}", "{\n    bool isMonotonic;\n \
    \   if(l.length <= 1)\n    {\n        isMonotonic = true;\n    }\n    else\n \
    \   {\n        isMonotonic = true;\n        bool isIncreasing = l[0] < l[1];\n\
    \        foreach(i, elem; l)\n        {\n            if(i < l.length - 1)\n  \
    \          {\n                if(isIncreasing)\n                {\n          \
    \          if(l[i] > l[i + 1])\n                    {\n                      \
    \  isMonotonic = false;\n                        break;\n                    }\n\
    \                }\n                else\n                {\n                \
    \    if(l[i] < l[i + 1])\n                    {\n                        isMonotonic\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return isMonotonic;\n}", "{\n \
    \   bool isAscending = true;\n    bool isDescending = true;\n    for (size_t i\
    \ = 1; i < l.length; i++) {\n        if (l[i] < l[i - 1]) {\n            isAscending\
    \ = false;\n        }\n        if (l[i] > l[i - 1]) {\n            isDescending\
    \ = false;\n        }\n    }\n    return isAscending || isDescending;\n}", "{\n\
    \    if (l.length <= 1)\n    {\n        return true;\n    }\n    return l[0] <\
    \ l[1] ? l[0] < l[$ - 1] : l[0] > l[$ - 1];\n}\n//pure @safe unittest\n//{\n//\
    \    assert(monotonic([1L, 2L, 4L, 20L]));\n//    assert(!monotonic([1L, 20L,\
    \ 4L, 10L]));\n//    assert(monotonic([4L, 1L, 0L, -10L]));\n//}", "{\n    if\
    \ (l.length <= 1)\n        return true;\n    auto increasing = (l[0] < l[1]);\n\
    \    for (size_t i = 1; i < l.length - 1; i++) \n    {\n        if (increasing\
    \ && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i]\
    \ < l[i + 1])\n            return false;\n    }\n    return true;\n}", "{\n  \
    \  bool isIncreasing = true;\n    foreach(ulong i, ref long e1; l)\n    {\n  \
    \      if(e1 != null)\n        {\n            auto e2 = l[i+1];\n            if(e2\
    \ != null)\n            {\n                auto diff = e2 - e1;\n            \
    \    if(!diff) \n                {\n                    continue;\n          \
    \      }\n                else if(diff > 0)\n                {\n             \
    \       if(!isIncreasing)\n                    {\n                        return\
    \ false;\n                    }\n                }\n                else\n   \
    \             {\n                    if(isIncreasing)\n                    {\n\
    \                        isIncreasing = false;\n                    }\n      \
    \          }\n            }\n        }\n    }\n    return true;\n}", "{\n    bool\
    \ is_inc = l[0] < l[1];\n    bool is_dec = l[0] > l[1];\n    foreach (i, n; l[1..$])\n\
    \    {\n        if (l[i] < l[i - 1])\n            is_inc = false;\n        if\
    \ (l[i] > l[i - 1])\n            is_dec = false;\n    }\n    return is_inc ||\
    \ is_dec;\n}\n/*\nReturn true if array elements are monotonically increasing.\n\
    \    >>> increasing([-1L, -2L, -4L, -20L])\n    true\n    >>> increasing([-1L,\
    \ -20L, -4L, -10L])\n    false\n    >>> increasing([0L, 1L, 2L, 4L, 20L])\n  \
    \  true\n*/", "{\n    auto isMonotonic = true;\n    auto sgn = 0;\n    auto l0\
    \ = l.front;\n    for (auto v : l[1 .. $]) \n    {\n        auto sgnNew = sign(v\
    \ - l0);\n        if (sgn && sgn != sgnNew) \n        {\n            isMonotonic\
    \ = false;\n            break;\n        }\n        sgn = sgnNew;\n        l0 =\
    \ v;\n    }\n    return isMonotonic;\n}\n/*\nReturn index of largest value in\
    \ array.\n    >>> maxIdx([1L, 2L, 4L, 20L])\n    3\n    >>> maxIdx([1L, 20L, 4L,\
    \ 10L])\n    1\n    >>> maxIdx([4L, 1L, 0L, -10L])\n    0\n*/\nsize_t maxIdx(long[]\
    \ l) \n{\n    auto maxIdx = 0;\n    auto max = l.front;\n    size_t i = 0;\n \
    \   for (auto v : l) \n    {\n        if (v > max) \n        {\n            max\
    \ = v;\n            maxIdx = i;\n        }\n        i++;\n    }\n    return maxIdx;\n\
    }\n/*\nReturn index of smallest value in array.\n    >>> minIdx([1L, 2L, 4L, 20L])\n\
    \    0\n    >>> minIdx([1L, 20L, 4L, 10L])\n    0\n    >>> minIdx([4L, 1L, 0L,\
    \ -10L])\n    3\n*/\nsize_t minIdx(long[] l) \n{\n    auto minIdx = 0;\n    auto\
    \ min = l.front;\n    size_t i = 0;\n    for (auto v : l) \n    {\n        if\
    \ (v < min) \n        {\n            min = v;\n            minIdx = i;\n     \
    \   }\n        i++;\n    }\n    return minIdx;\n}\n//----------------------------------------------------------------------\n\
    // String operations\n//----------------------------------------------------------------------\n\
    /*\nReturn true if string s has prefix prefix.\n    >>> has", "{\n    bool result\
    \ = true;\n    if (l.length == 1)\n    {\n        return true;\n    }\n    bool\
    \ asc = l[0] < l[1];\n    foreach (int i, long value; l)\n    {\n        if (i\
    \ == 0)\n        {\n            continue;\n        }\n        if (asc)\n     \
    \   {\n            if (l[i] < l[i - 1])\n            {\n                result\
    \ = false;\n                break;\n            }\n        }\n        else\n \
    \       {\n            if (l[i] > l[i - 1])\n            {\n                result\
    \ = false;\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn true if a is a subset of b\n    >>> subset([1L, 2L, 4L],\
    \ [1L, 2L, 4L, 20L])\n    true\n    >>> subset([1L, 4L, 20L], [1L, 2L, 4L])\n\
    \    false\n*/", "{\n    l = l.sort();\n    return true;\n}\n \n/*\nReturn true\
    \ if array elements are monotonically increasing.\n    >>> monotonic_increasing([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L, 20L, 4L, 10L])\n\
    \    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n    false\n*/",
  "{\n    //for(long i=0; i < l.length - 1; i++)\n    //  if(l[i+1] > l[i])\n    //\
    \      return false;\n    //  return true;\n    \n    long first = l[0];\n   \
    \ foreach(i; l[1..$])\n    {\n        if(i < first)\n            return false;\n\
    \        first = i;\n    }\n    return true;\n}", "{\n    if(l.length <= 1)\n\
    \    {\n        return true;\n    }\n    int direction = l[1] - l[0];\n    foreach(int\
    \ i, long element; l)\n    {\n        if((i != 0) && (element - l[i - 1]) * direction\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n/*\n    >>> second(['a', 'b', 'c'])\n    'b'\n    >>> second(['a'])\n    Traceback\
    \ (most recent call last):\n        ...\n    IndexError: list index out of range\n\
    */\nchar second(char[] l)\n{\n    if(l.length < 2)\n    {\n        throw new IndexError(\"\
    list index out of range\");\n    }\n    return l[1];\n}\n/*\n    >>> swap(['a',\
    \ 'b', 'c'])\n    ['b', 'a', 'c']\n    >>> swap(['a'])\n    ['a']\n*/\nchar[]\
    \ swap(char[] l)\n{\n    if(l.length == 0)\n    {\n        return l;\n    }\n\
    \    char[] res = new char[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(i == 0)\n        {\n            res[i] = l[1];\n        }\n\
    \        else if(i == 1)\n        {\n            res[i] = l[0];\n        }\n \
    \       else\n        {\n            res[i] = l[i];\n        }\n    }\n    return\
    \ res;\n}\n/*\n    >>> is_ascending(['a', 'b', 'c'])\n    True\n    >>> is_ascending(['a',\
    \ 'b', 'b'])\n    False\n*/", "{\n    bool increasing;\n    long n = 0L;\n   \
    \ if (l.length == 0) \n    {\n        throw new Exception(\"Cannot calculate monotonicity\
    \ of empty list\");\n    }\n    increasing = l[0] < l[1];\n    foreach (i; 1..l.length)\
    \ \n    {\n        if (l[i - 1] != l[i]) \n        {\n            if (increasing)\
    \ \n            {\n                if (l[i - 1] > l[i]) \n                {\n\
    \                    return false;\n                }\n            }\n       \
    \     else \n            {\n                if (l[i - 1] < l[i]) \n          \
    \      {\n                    return false;\n                }\n            }\n\
    \        }\n        n = n + 1L;\n    }\n    return true;\n}\n/*\nReturn true if\
    \ two lists have the same length and each element is the same.\n    >>> is_same([0,\
    \ 1, 2], [0, 1, 2])\n    true\n    >>> is_same([0, 1, 2], [0, 1, 3])\n    false\n\
    */", "{\n    long[] sign = Array(long)();\n    foreach (i,el; l) \n    {\n   \
    \     if (i > 0) \n        {\n            sign ~= (el - l[i-1L]);\n        }\n\
    \    }\n    return sign.uniq.length == 1L;\n}", "{\n    bool increasing = false;\n\
    \    bool decreasing = false;\n    bool nonIncrease = false;\n    bool nonDecrease\
    \ = false;\n    long current_element = l[0];\n    if (l.length == 1) \n    {\n\
    \        return true;\n    }\n    foreach (element; l[1..$]) \n    {\n       \
    \ if (element > current_element) \n        {\n            increasing = true;\n\
    \            if (nonDecrease)\n            {\n                return false;\n\
    \            }\n        }\n        else if (element < current_element) \n    \
    \    {\n            decreasing = true;\n            if (nonIncrease)\n       \
    \     {\n                return false;\n            }\n        }\n        else\
    \ \n        {\n            if (increasing)\n            {\n                nonIncrease\
    \ = true;\n            }\n            if (decreasing)\n            {\n       \
    \         nonDecrease = true;\n            }\n        }\n        current_element\
    \ = element;\n    }\n    return true;\n}\n/*\nReturn a random permutation of the\
    \ input array.\n*/\nlong[] permutation(long[] l) \n{\n    auto index = new long[l.length];\n\
    \    foreach (i, t; index) \n    {\n        index[i] = i;\n    }\n    shuffle(index);\n\
    \    auto result = new long[l.length];\n    foreach (i, t; index) \n    {\n  \
    \      result[i] = l[index[i]];\n    }\n    return result;\n}\n/*\nMultiply array\
    \ by scalar.\n*/\nlong[] multiply(long[] array, long factor) \n{\n    foreach\
    \ (j, i; array) \n    {\n        array[j] = i * factor;\n    }\n    return array;\n\
    }\n/*\nReturn true if array is sorted low to high.\n*/", "{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length; i++)\
    \ {\n        if (l[i] < l[i - 1]) {\n            increasing = false;\n       \
    \ }\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n       \
    \ }\n    }\n    return increasing || decreasing;\n}", "{\n    if (l.length <=\
    \ 1) \n    {\n        return true;\n    }\n    long first = l[0];\n    long last\
    \ = l[l.length - 1];\n    long[] positive = l.filter!(e => e > 0).array;\n   \
    \ long[] negative = l.filter!(e => e < 0).array;\n    long[] positive_increasing\
    \ = positive.filter!(e => e >= first).array;\n    long[] positive_decreasing =\
    \ positive.filter!(e => e <= first).array;\n    long[] negative_increasing = negative.filter!(e\
    \ => e >= last).array;\n    long[] negative_decreasing = negative.filter!(e =>\
    \ e <= last).array;\n    return positive_increasing.length == positive.length\
    \ || positive_decreasing.length == positive.length || negative_increasing.length\
    \ == negative.length || negative_decreasing.length == negative.length;\n}", "{\n\
    \    bool increasing = true;\n    bool decreasing = true;\n    for (size_t i =\
    \ 1; i < l.length; i++) \n    {\n        if (l[i] < l[i - 1])\n            increasing\
    \ = false;\n        if (l[i] > l[i - 1])\n            decreasing = false;\n  \
    \  }\n    return increasing || decreasing;\n}\n/*\nReturn the largest odd integer\
    \ that is less than x\n    >>> largest_odd(10L)\n    9L\n    >>> largest_odd(9L)\n\
    \    7L\n    >>> largest_odd(6L)\n    5L\n    >>> largest_odd(5L)\n    5L\n  \
    \  >>> largest_odd(4L)\n    3L\n    >>> largest_odd(3L)\n    3L\n*/\nlong largest_odd(long\
    \ x) \n{\n    if (x & 1)\n        return x;\n    else\n        return x - 2;\n\
    }\n/*\nReturn a tuple representing an interval\n    >>> interval(10L, 2L)\n  \
    \  (10L, 2L)\n    >>> interval(10L, 5L)\n    (10L, 5L)\n    >>> interval(10L,\
    \ 10L)\n    (10L, 10L)\n    >>> interval(5L, 10L)\n    (5L, 10L)\n    >>> interval(5L,\
    \ 10L, False)\n    (10L, 5L)\n*/\nTuple!(long, long) interval(long a, long b,\
    \ bool asc = true) \n{\n    if (asc || a == b)\n        return tuple(a, b);\n\
    \    else\n        return tuple(b, a);\n}\n/*\nReturn true if the elements of\
    \ a sequence are unique.\n    >>> unique([1L, 2L, 4L, 6L])\n    true\n    >>>\
    \ unique([1L, 2L, 4L, 6L, 2L])\n    false\n*/", "{\n    immutable(bool) fb = l[0]\
    \ < l[1];\n    foreach(i, ref elt; l[1..$])\n    {\n        if(elt < l[i-1] !=\
    \ fb)\n            return false;\n    }\n    return true;\n}\n/*\nCheck if an\
    \ array is sorted.\n    >>> isSorted([1L, 2L, 4L, 20L])\n    true\n    >>> isSorted([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> isSorted([4L, 1L, 0L, -10L])\n    false\n\
    */", "{\n  if (l.length < 2) return true;\n  int k = l[0] > l[1] ? -1 : 1;\n \
    \ for (size_t i = 2; i < l.length; i++) \n  {\n    if ((k * l[i-1]) < (k * l[i]))\
    \ return false;\n  }\n  return true;\n}", "{\n    if (l.length < 2)\n        return\
    \ true;\n    bool d0 = l[0] < l[1];\n    for (size_t i = 1; i < l.length - 1;\
    \ i++) \n    {\n        bool di = l[i] < l[i + 1];\n        if (di != d0)\n  \
    \          return false;\n    }\n    return true;\n}\n/*\nReturn true if an element\
    \ in array is monotonically increasing or decreasing.\n    >>> monotonicIncreasing([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonicIncreasing([1L, 20L, 4L, 10L])\n \
    \   false\n    >>> monotonicIncreasing([4L, 1L, 0L, -10L])\n    false\n    \n\
    */", "{\n  return monotonic!(\"a < b\")(l);\n}\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n*/", "{\n    if (l.length > 1)\n\
    \    {\n        auto cmp = cmp(i, j);\n        if (cmp == 1)\n        {\n    \
    \        auto temp = l[0];\n            foreach (immutable j, immutable k; l)\n\
    \            {\n                if (temp > k)\n                {\n           \
    \         return false;\n                }\n                temp = k;\n      \
    \      }\n        }\n        else if (cmp == -1)\n        {\n            auto\
    \ temp = l[0];\n            foreach (immutable j, immutable k; l)\n          \
    \  {\n                if (temp < k)\n                {\n                    return\
    \ false;\n                }\n                temp = k;\n            }\n      \
    \  }\n        else\n        {\n            return false;\n        }\n    }\n \
    \   return true;\n}\n/*\nReturn true is array elements are monotonically increasing\
    \ or decreasing.\n    >>> monotonic([1.0, 2.0, 4.0, 20.0])\n    true\n    >>>\
    \ monotonic([1.0, 20.0, 4.0, 10.0])\n    false\n    >>> monotonic([4.0, 1.0, 0.0,\
    \ -10.0])\n    true\n    \n*/", "{\n    if (l.length < 2) return true;\n    bool\
    \ asc = (l[1] - l[0]) > 0;\n    for (int i = 2; i < l.length; i++) {\n       \
    \ bool cur = (l[i] - l[i - 1]) > 0;\n        if (cur != asc) return false;\n \
    \   }\n    return true;\n}", "{\n    if(l.length <= 1) return true;\n    bool\
    \ is_increasing = l[0] < l[1];\n    for(int i = 1; i < l.length - 1; i++)\n  \
    \  {\n        if(is_increasing)\n        {\n            if(l[i] > l[i + 1]) return\
    \ false;\n        }\n        else\n        {\n            if(l[i] < l[i + 1])\
    \ return false;\n        }\n    }\n    return true;\n}\n/*\nReturn a string that\
    \ can be used as either a scalar variable or \nan array variable.\n    >>> make_varname(\"\
    hello\")\n    'hello'\n    >>> make_varname(\"hello[x]\")\n    'hello[x]'\n  \
    \  >>> make_varname(\"hello[1]\")\n    'hello[1]'\n    >>> make_varname(\"hello['1']\"\
    )\n    'hello[\"1\"]'\n    >>> make_varname(\"hello[x[1]]\")\n    'hello[x[1]]'\n\
    \    >>> make_varname(\"hello['x[1]']\")\n    'hello[\"x[1]\"]'\n    >>> make_varname(\"\
    hello['2\\\\'4']\")\n    'hello[\"2\\'4\"]'\n    >>> make_varname(\"hello['2\\\
    \\'4']\")\n    'hello[\"2\\'4\"]'\n*/\nstring make_varname(string s) \n{\n   \
    \ string rs = \"\";\n    auto len = s.length;\n    bool in_quote = false;\n  \
    \  bool can_quote = false;\n    bool must_quote = false;\n    bool needs_escape\
    \ = false;\n    for(int i = 0; i < len; i++)\n    {\n        if(in_quote)\n  \
    \      {\n            if(s[i] == '\\'')\n            {\n                if(s[i\
    \ + 1] == '\\'')\n                {\n                    rs ~= \"\\\\'\";\n  \
    \                  i++;\n                }\n                else\n           \
    \     {\n                    rs ~= '\\'';\n                    in_quote = false;\n\
    \                }\n            }\n            else\n", "{\n    bool direction\
    \ = l[0] < l[1];\n    foreach(i, x; l) \n    {\n        if(i != 0) \n        {\n\
    \            if(x < l[i - 1] == direction)\n                return false;\n  \
    \      }\n    }\n    return true;\n}", "{\n    auto l1 = l[0];\n    auto m = l[0]\
    \ > l[1];\n    foreach(t; l[1..$])\n    {\n        if(m != (l1 > t))\n       \
    \     return false;\n        l1 = t;\n    }\n    return true;\n}\n/*", "{\n  \
    \  return compare(l) == 0L || compare(l) == 1L || compare(l) == -1L;\n}", "{\n\
    \    return sort(l).isSorted;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
