name: HumanEval_133_sum_squares
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYou are given an array of numbers.\n\
  \    You need to return the sum of squared numbers in the given array,\n    round\
  \ each element in the array to the upper int(Ceiling) first.\n    Examples:\n  \
  \  >>> lst([1.0, 2.0, 3.0])\n    14L\n    >>> lst([1.0, 4.0, 9.0])\n    98L\n  \
  \  >>> lst([1.0, 3.0, 5.0, 7.0])\n    84L\n    >>> lst([1.4, 4.2, 0.0])\n    29L\n\
  \    >>> lst([-2.4, 1.0, 1.0])\n    6L\n    \n\n    \n*/\nlong sum_squares(float[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = sum_squares;\n\n    assert(candidate([1.0,\
  \ 2.0, 3.0]) == 14L);\n    assert(candidate([1.0, 2.0, 3.0]) == 14L);\n    assert(candidate([1.0,\
  \ 3.0, 5.0, 7.0]) == 84L);\n    assert(candidate([1.4, 4.2, 0.0]) == 29L);\n   \
  \ assert(candidate([-2.4, 1.0, 1.0]) == 6L);\n    assert(candidate([100.0, 1.0,\
  \ 15.0, 2.0]) == 10230L);\n    assert(candidate([10000.0, 10000.0]) == 200000000L);\n\
  \    assert(candidate([-1.4, 4.6, 6.3]) == 75L);\n    assert(candidate([-1.4, 17.9,\
  \ 18.9, 19.9]) == 1086L);\n    assert(candidate([0.0]) == 0L);\n    assert(candidate([-1.0])\
  \ == 1L);\n    assert(candidate([-1.0, 1.0, 0.0]) == 2L);\n}\nvoid main(){}"
completions: ["{\n    long sum = 0;\n    foreach(i; 0 .. lst.length) \n    {\n   \
    \     sum += ceil(lst[i])*ceil(lst[i]);\n    }\n    return sum;\n}", "{\n    long\
    \ result=0;\n    auto max=ceil(maxElement(lst));\n    auto min=ceil(minElement(lst));\n\
    \    foreach(float x;lst)\n    {\n        result+=cast(long)(x*x);\n    }\n  \
    \  return result;\n}\n/*\nYou are given a positive integer N.\n    You need to\
    \ return the product of all positive integers from 1 to N.\n    Examples:\n  \
    \  >>> product(1)\n    1L\n    >>> product(2)\n    2L\n    >>> product(4)\n  \
    \  24L\n    >>> product(8)\n    40320L\n    >>> product(16)\n    20922789888000L\n\
    \    >>> product(60)\n    8031810176L\n    ", "{\n    long sum=0;\n    float temp;\n\
    \    foreach(var value; lst)\n    {\n        temp=ceil(value);\n        sum+=cast(long)(temp*temp);\n\
    \    }\n    return sum;\n}", "{\n    \n    lst.map!(a => ceil(a)).map!(a => a\
    \ * a).reduce!(a => a + a);\n    long res = 0;\n    foreach(i; lst) \n    {\n\
    \        res += i;\n    }\n    return res;\n}", "{\n    // return std.algorithm.sum!q{x*x}(lst);\n\
    \    long result = 0;\n    foreach(f; lst)\n    {\n        result += long(ceil(f)\
    \ * ceil(f));\n    }\n    return result;\n}", "{\n    long result = 0;\n    foreach(f;\
    \ lst) \n    {\n        result += cast(long)(cast(real)f * cast(real)f);\n   \
    \ }\n    return result;\n}", "{\n    long res = 0;\n    foreach(item; lst)\n \
    \   {\n        res += item * item;\n    }\n    return res;\n}", "{\n    // return\
    \ int(ceil(x));\n    long res = 0;\n    foreach(x;lst)\n    {\n        res +=\
    \ (long)x * (long)x;\n    }\n    return res;\n}", "{\n    long sum = 0;\n    foreach(x;lst)\n\
    \    {\n        x = ceil(x);\n        long xlong = long(x);\n        sum = sum\
    \ + xlong * xlong;\n    }\n    return sum;\n    \n    \n}", "{\n    auto sqr =\
    \ (a) => (long)ceil(a) * (long)ceil(a);\n    return lst.map!sqr.sum;\n}", "{\n\
    \    int s = lst.length;\n    long sum = 0;\n    for (int i = 0; i < s; i++) \n\
    \    {\n        sum += cast(long) ceil(lst[i]) * ceil(lst[i]);\n    }\n    return\
    \ sum;\n}", "{\n    int len = lst.length;\n    int[] lstInt = new int[len];\n\
    \    for (int i = 0; i < len; i++)\n    {\n        lstInt[i] = cast(int)ceil(lst[i]);\n\
    \    }\n    long res = 0;\n    foreach (int i; lstInt) res += cast(long)i * i;\n\
    \    return res;\n}", "{\n  long res = 0;\n  foreach(elem; lst)\n    res += ceil(elem)\
    \ * ceil(elem);\n  return res;\n}", "{\n    long result = 0;\n    foreach(f;lst)\n\
    \    {\n        long temp = std.typecons.Tuple!(int,int)(f).field0;\n        result\
    \ += temp*temp;\n    }\n    return result;\n}", "{\n    float[] lst2 = new float[lst.length];\n\
    \    long res = 0;\n    for (int i = 0; i < lst.length; i++) {\n        lst2[i]\
    \ = ceil(lst[i]);\n        res += (long)pow(lst2[i], 2);\n    }\n    return res;\n\
    }\n/*\nYou are given an array of numbers.\n    You need to return the maximum\
    \ difference between the values of the array,\n    the difference must be bigger\
    \ than 0.\n    Examples:\n    >>> lst([2, 3, 1, 4, 5])\n    4L\n    >>> lst([3,\
    \ 1, 2, 4, 5])\n    4L\n    >>> lst([1, 2, 3, 4, 5])\n    4L\n    >>> lst([5,\
    \ 4, 3, 2, 1])\n    4L\n    >>> lst([1.0, 4.0, 9.0])\n    8L\n    >>> lst([1.0,\
    \ 3.0, 5.0, 7.0])\n    6L\n    >>> lst([-2.4, 1.0, 1.0])\n    3L\n    >>> lst([1.0,\
    \ 2.0, 3.0])\n    2L\n    >>> lst([1.0, 3.0, 5.0, 7.0])\n    6L\n    >>> lst([3.0,\
    \ 2.0, 1.0])\n    2L\n    ", "{\n    long sum = 0;\n    float f;\n    foreach(f;\
    \ lst)\n    {\n        f = ceil(f);\n        sum += cast(long) f * f;\n    }\n\
    \    return sum;\n}", "{\n    return lst.map!ceil.map!((int i) => i*i).sum;\n}",
  "{\n    long result = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n    \
    \    result += cast(long) (ceil(lst[i]) * ceil(lst[i]));\n    }\n    return result;\n\
    }\n/*\nSum digits of a number\n    You need to sum digits of a number, but the\
    \ catch is that you need to sum all the digits present in a number recursively.\n\
    \    Examples:\n    >>> sum_digits(7)\n    7\n    >>> sum_digits(2**2 + 3**2)\n\
    \    13\n    >>> sum_digits(2**4 + 3**4)\n    32\n    >>> sum_digits(2**8 + 3**8)\n\
    \    129\n    >>> sum_digits(2**16 + 3**16)\n    819\n    >>> sum_digits(2**32\
    \ + 3**32)\n    5269\n    >>> sum_digits(2**64 + 3**64)\n    33121\n    >>> sum_digits(2**64)\n\
    \    14\n    >>> sum_digits(2**10000)\n    2\n    ", "{\n    return map!(i =>\
    \ i * i)(map!(i => cast(int) std.math.ceil(i))(lst)).sum;\n}", "{\n    float[]\
    \ r = new float[lst.length];\n    float result = 0.0f;\n    foreach(i, e; lst)\n\
    \    {\n        r[i] = ceil(e);\n        result += r[i] * r[i];\n    }\n    return\
    \ result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
