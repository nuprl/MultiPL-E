name: HumanEval_133_sum_squares
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYou are given an array of numbers.\n\
  \    You need to return the sum of squared numbers in the given array,\n    round\
  \ each element in the array to the upper int(Ceiling) first.\n    Examples:\n  \
  \  >>> lst([1.0, 2.0, 3.0])\n    14L\n    >>> lst([1.0, 4.0, 9.0])\n    98L\n  \
  \  >>> lst([1.0, 3.0, 5.0, 7.0])\n    84L\n    >>> lst([1.4, 4.2, 0.0])\n    29L\n\
  \    >>> lst([-2.4, 1.0, 1.0])\n    6L\n    \n\n    \n*/\nlong sum_squares(float[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = sum_squares;\n\n    assert(candidate([1.0,\
  \ 2.0, 3.0]) == 14L);\n    assert(candidate([1.0, 2.0, 3.0]) == 14L);\n    assert(candidate([1.0,\
  \ 3.0, 5.0, 7.0]) == 84L);\n    assert(candidate([1.4, 4.2, 0.0]) == 29L);\n   \
  \ assert(candidate([-2.4, 1.0, 1.0]) == 6L);\n    assert(candidate([100.0, 1.0,\
  \ 15.0, 2.0]) == 10230L);\n    assert(candidate([10000.0, 10000.0]) == 200000000L);\n\
  \    assert(candidate([-1.4, 4.6, 6.3]) == 75L);\n    assert(candidate([-1.4, 17.9,\
  \ 18.9, 19.9]) == 1086L);\n    assert(candidate([0.0]) == 0L);\n    assert(candidate([-1.0])\
  \ == 1L);\n    assert(candidate([-1.0, 1.0, 0.0]) == 2L);\n}\nvoid main(){}"
completions: ["{\n    long sum = 0;\n    foreach(i; 0 .. lst.length) \n    {\n   \
    \     sum += ceil(lst[i])*ceil(lst[i]);\n    }\n    return sum;\n}", "{\n    long\
    \ result=0;\n    auto max=ceil(maxElement(lst));\n    auto min=ceil(minElement(lst));\n\
    \    foreach(float x;lst)\n    {\n        result+=cast(long)(x*x);\n    }\n  \
    \  return result;\n}\n/*\nYou are given a positive integer N.\n    You need to\
    \ return the product of all positive integers from 1 to N.\n    Examples:\n  \
    \  >>> product(1)\n    1L\n    >>> product(2)\n    2L\n    >>> product(4)\n  \
    \  24L\n    >>> product(8)\n    40320L\n    >>> product(16)\n    20922789888000L\n\
    \    >>> product(60)\n    8031810176L\n    ", "{\n    long sum=0;\n    float temp;\n\
    \    foreach(var value; lst)\n    {\n        temp=ceil(value);\n        sum+=cast(long)(temp*temp);\n\
    \    }\n    return sum;\n}", "{\n    \n    lst.map!(a => ceil(a)).map!(a => a\
    \ * a).reduce!(a => a + a);\n    long res = 0;\n    foreach(i; lst) \n    {\n\
    \        res += i;\n    }\n    return res;\n}", "{\n    // return std.algorithm.sum!q{x*x}(lst);\n\
    \    long result = 0;\n    foreach(f; lst)\n    {\n        result += long(ceil(f)\
    \ * ceil(f));\n    }\n    return result;\n}", "{\n    long result = 0;\n    foreach(f;\
    \ lst) \n    {\n        result += cast(long)(cast(real)f * cast(real)f);\n   \
    \ }\n    return result;\n}", "{\n    long res = 0;\n    foreach(item; lst)\n \
    \   {\n        res += item * item;\n    }\n    return res;\n}", "{\n    // return\
    \ int(ceil(x));\n    long res = 0;\n    foreach(x;lst)\n    {\n        res +=\
    \ (long)x * (long)x;\n    }\n    return res;\n}", "{\n    long sum = 0;\n    foreach(x;lst)\n\
    \    {\n        x = ceil(x);\n        long xlong = long(x);\n        sum = sum\
    \ + xlong * xlong;\n    }\n    return sum;\n    \n    \n}", "{\n    auto sqr =\
    \ (a) => (long)ceil(a) * (long)ceil(a);\n    return lst.map!sqr.sum;\n}", "{\n\
    \    int s = lst.length;\n    long sum = 0;\n    for (int i = 0; i < s; i++) \n\
    \    {\n        sum += cast(long) ceil(lst[i]) * ceil(lst[i]);\n    }\n    return\
    \ sum;\n}", "{\n    int len = lst.length;\n    int[] lstInt = new int[len];\n\
    \    for (int i = 0; i < len; i++)\n    {\n        lstInt[i] = cast(int)ceil(lst[i]);\n\
    \    }\n    long res = 0;\n    foreach (int i; lstInt) res += cast(long)i * i;\n\
    \    return res;\n}", "{\n  long res = 0;\n  foreach(elem; lst)\n    res += ceil(elem)\
    \ * ceil(elem);\n  return res;\n}", "{\n    long result = 0;\n    foreach(f;lst)\n\
    \    {\n        long temp = std.typecons.Tuple!(int,int)(f).field0;\n        result\
    \ += temp*temp;\n    }\n    return result;\n}", "{\n    float[] lst2 = new float[lst.length];\n\
    \    long res = 0;\n    for (int i = 0; i < lst.length; i++) {\n        lst2[i]\
    \ = ceil(lst[i]);\n        res += (long)pow(lst2[i], 2);\n    }\n    return res;\n\
    }\n/*\nYou are given an array of numbers.\n    You need to return the maximum\
    \ difference between the values of the array,\n    the difference must be bigger\
    \ than 0.\n    Examples:\n    >>> lst([2, 3, 1, 4, 5])\n    4L\n    >>> lst([3,\
    \ 1, 2, 4, 5])\n    4L\n    >>> lst([1, 2, 3, 4, 5])\n    4L\n    >>> lst([5,\
    \ 4, 3, 2, 1])\n    4L\n    >>> lst([1.0, 4.0, 9.0])\n    8L\n    >>> lst([1.0,\
    \ 3.0, 5.0, 7.0])\n    6L\n    >>> lst([-2.4, 1.0, 1.0])\n    3L\n    >>> lst([1.0,\
    \ 2.0, 3.0])\n    2L\n    >>> lst([1.0, 3.0, 5.0, 7.0])\n    6L\n    >>> lst([3.0,\
    \ 2.0, 1.0])\n    2L\n    ", "{\n    long sum = 0;\n    float f;\n    foreach(f;\
    \ lst)\n    {\n        f = ceil(f);\n        sum += cast(long) f * f;\n    }\n\
    \    return sum;\n}", "{\n    return lst.map!ceil.map!((int i) => i*i).sum;\n}",
  "{\n    long result = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n    \
    \    result += cast(long) (ceil(lst[i]) * ceil(lst[i]));\n    }\n    return result;\n\
    }\n/*\nSum digits of a number\n    You need to sum digits of a number, but the\
    \ catch is that you need to sum all the digits present in a number recursively.\n\
    \    Examples:\n    >>> sum_digits(7)\n    7\n    >>> sum_digits(2**2 + 3**2)\n\
    \    13\n    >>> sum_digits(2**4 + 3**4)\n    32\n    >>> sum_digits(2**8 + 3**8)\n\
    \    129\n    >>> sum_digits(2**16 + 3**16)\n    819\n    >>> sum_digits(2**32\
    \ + 3**32)\n    5269\n    >>> sum_digits(2**64 + 3**64)\n    33121\n    >>> sum_digits(2**64)\n\
    \    14\n    >>> sum_digits(2**10000)\n    2\n    ", "{\n    return map!(i =>\
    \ i * i)(map!(i => cast(int) std.math.ceil(i))(lst)).sum;\n}", "{\n    float[]\
    \ r = new float[lst.length];\n    float result = 0.0f;\n    foreach(i, e; lst)\n\
    \    {\n        r[i] = ceil(e);\n        result += r[i] * r[i];\n    }\n    return\
    \ result;\n}", "{\n    long result = 0;\n    foreach(var i; lst)\n    {\n    \
    \    result += i*i;\n    }\n    return result;\n}", "{\n    long total = 0;\n\
    \    foreach(f; lst)\n    {\n        total += (long)f.ceil.pow(2);\n    }\n  \
    \  return total;\n}", "{\n    //Ceiling is a method, which returns the smallest\
    \ integer that is greater than\n    //or equal to the specified number.\n    return\
    \ std.map!(a => cast(long)(a * a))(std.map!(a => ceil(a))(lst)).sum;\n}", "{\n\
    \    long r = 0;\n    foreach(e; lst) \n    {\n        r += (long) cast(int) e\
    \ * e;\n    }\n    return r;\n}", "{\n    return lst.map!(x => cast(long)(ceil(x))).map!(x\
    \ => x * x).sum;\n}", "{\n    long sum = 0;\n    foreach(float x; lst)\n    {\n\
    \        sum += (long)std.math.pow(std.math.ceil(x), 2);\n    }\n    return sum;\n\
    }", "{\n    return reduce!q{a + b}(map!q{cast(long)ceil(it) * cast(long)ceil(it)}(lst));\n\
    }", "{\n    return lst.map!(a => (long) a).map!(x => x * x).sum;\n}", "{\n   \
    \ long sum = 0;\n    foreach(item;lst)\n    {\n        //*item = ceil(item);\n\
    \        sum += cast(long)(item*item);\n    }\n    return sum;\n}", "{\n    long\
    \ result = 0;\n    for (auto item : lst)\n    {\n        result += cast(long)item;\n\
    \    }\n    return result;\n}", "{\n    float x=0;\n    foreach(e;lst)\n    {\n\
    \        x+=ceil(e)*ceil(e);\n    }\n    return cast(long)x;\n}\n \n \n/*\nWrite\
    \ a function that takes in two inputs:\n    A string, that represents a word\n\
    \    A number, that represents how many times the word has been repeated\n   \
    \ The function should return a string of the word repeated the number of times,\
    \ however the following rules apply:\n    If the first parameter is not a string,\
    \ return 'not a string'\n    If the second parameter is not a number, return 'not\
    \ a number'\n    If the word is repeated 0 times, return '0'\n    If the word\
    \ is repeated 1 time, return '1'\n    If the word is repeated 2 times, return\
    \ '2'\n    If the word is repeated 3 times, return '3'\n    If the word is repeated\
    \ 4 times, return '4'\n    If the word is repeated 5 times, return '5'\n    If\
    \ the word is repeated 6 times, return '6'\n    If the word is repeated 7 times,\
    \ return '7'\n    If the word is repeated 8 times, return '8'\n    If the word\
    \ is repeated 9 times, return '9'\n    If the word is repeated more than 9 times,\
    \ return the word repeated that number of times\n    Examples:\n    >>> lst(\"\
    Hello\",1)\n    '1'\n    >>> lst(\"Hello\",2)\n    '2'\n    >>> lst(\"Hello\"\
    ,3)\n    '3'\n    >>> lst(\"Hello\",4)\n    '4'\n    >>> lst(\"Hello\",5)\n  \
    \  '5'\n    >>> lst(\"Hello\",6)\n    '6'\n    >>> lst(\"Hello\",7)\n    '7'\n\
    \    >>> lst(\"Hello\",8)\n    '8'\n    >>> lst(\"Hello\",9)\n    '9'\n    >>>\
    \ lst(\"Hello\",10)\n    'HelloHelloHelloHelloHelloHelloHelloHelloHelloHello'\n\
    \    >>> lst(\"Hello\",0)\n    '0'\n    >>> lst(\"Hello\",-2)\n    'not a number'\n\
    \    >>> lst(\"\",-2", "{\n    long sum = 0;\n    foreach(float e; lst)\n    {\n\
    \        sum += (cast(long)ceil(e)) * (cast(long)ceil(e));\n    }\n    return\
    \ sum;\n}", "    long res = 0;\n    foreach(e; lst)\n        res += cast(long)\
    \ ceil(e) * cast(long) ceil(e);\n    return res;\n/*\n    foreach(e; lst)\n  \
    \      writeln(e);\n    return 0;\n*/\n}\n/*\nstatic assert(lst([1.0, 2.0, 3.0])\
    \ == 14L);\nstatic assert(lst([1.0, 4.0, 9.0]) == 98L);\nstatic assert(lst([1.0,\
    \ 3.0, 5.0, 7.0]) == 84L);\nstatic assert(lst([1.4, 4.2, 0.0]) == 29L);\nstatic\
    \ assert(lst([-2.4, 1.0, 1.0]) == 6L);\n*/", "{\n  return reduce!(\"a + b\")(map!(\"\
    a * a\")(map!(\"ceil(a)\")(lst)));\n}", "{\n    long result = 0;\n    foreach(element;\
    \ lst)\n    {\n        auto res = element;\n        //auto res = round(element);\n\
    \        res = res*res;\n        result += res;\n    }\n    return result;\n}",
  "{\n    long res=0;\n    float[] lst1=new float[lst.length];\n    for(int i=0;i<lst.length;i++)\n\
    \    {\n        lst1[i]=ceil(lst[i]);\n    }\n    foreach(x;lst1)\n    {\n   \
    \     res+=x*x;\n    }\n    return res;\n}", "{\n    long sum=0;\n    foreach(i;lst)\n\
    \    {\n        float k=ceil(i);\n        sum+=cast(long)(k*k);\n    }\n    return\
    \ sum;\n}", "{\n    return lst.map!(i => cast(int)Math.ceil(i)).sum!(i => i*i);\n\
    }", "{\n    float[] arr = new float[lst.length];\n    float sum = 0;\n    long\
    \ result = 0;\n    float roundedFloat = 0;\n    float squaredFloat = 0;\n    float\
    \ roundedFloat2 = 0;\n    long i = 0;\n    while (i < lst.length)\n    {\n   \
    \   arr[i] = lst[i];\n      roundedFloat = ceil(arr[i]);\n      squaredFloat =\
    \ roundedFloat * roundedFloat;\n      result += roundedFloat2.to!long;\n     \
    \ i++;\n    }\n    return result;\n}\n/*\n    >>> spiral(0)\n    [[]]\n    >>>\
    \ spiral(1)\n    [[1]]\n    >>> spiral(2)\n    [[1, 2], [4, 3]]\n    >>> spiral(3)\n\
    \    [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n    >>> spiral(4)\n    [[1, 2, 3, 4],\
    \ [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n    >>> spiral(5)\n    [[1,\
    \ 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8],\
    \ [13, 12, 11, 10, 9]]\n    >>> spiral(6)\n    [[1, 2, 3, 4, 5, 6], [20, 21, 22,\
    \ 23, 24, 7], [19, 32, 33, 34, 25, 8], [18, 31, 36, 35, 26, 9], [17, 30, 29, 28,\
    \ 27, 10], [16, 15, 14, 13, 12, 11]]\n*/", "{\n    long sum = 0;\n    foreach(e;\
    \ lst) {\n        sum += std.math.pow(std.typecons.Ceil!float(e), 2);\n    }\n\
    \    return sum;\n}", "{\n    int[] a = new int[lst.length];\n    for (int i =\
    \ 0; i < lst.length; i++)\n    {\n        a[i] = (int) ceil(lst[i]);\n    }\n\
    \    long sum = 0;\n    for (int i = 0; i < a.length; i++)\n    {\n        sum\
    \ += pow(a[i], 2);\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(var\
    \ i; lst) \n    {\n        sum += cast(long)(ceil(i) * ceil(i));\n    }\n    return\
    \ sum;\n}", "{\n    long result = 0;\n    foreach(elem; lst)\n    {\n        int\
    \ ceil;\n        ceil = cast(int)ceil(elem);\n        result += ceil*ceil;\n \
    \   }\n    return result;\n}", "{\n    return lst.map!ceil.map!(a => a*a).reduce!(\"\
    a+b\").ret;\n}\n/*\n    You are given an array of numbers.\n    You need to return\
    \ the sum of squared numbers in the given array,\n    round each element in the\
    \ array to the upper int(Ceiling) first.\n    Examples:\n    >>> lst([1.0, 2.0,\
    \ 3.0])\n    14L\n    >>> lst([1.0, 4.0, 9.0])\n    98L\n    >>> lst([1.0, 3.0,\
    \ 5.0, 7.0])\n    84L\n    >>> lst([1.4, 4.2, 0.0])\n    29L\n    >>> lst([-2.4,\
    \ 1.0, 1.0])\n    6L\n    ", "{\n    int arraySize = lst.length;\n    long sum\
    \ = 0;\n    for (int i = 0; i < arraySize; i++) \n    {\n        float f = lst[i];\n\
    \        sum += cast(int)ceil(f) * cast(int)ceil(f);\n    }\n    return sum;\n\
    }", "{\n    assert(lst.length != 0);\n    long ans = 0;\n    foreach(x; lst)\n\
    \    {\n        ans += pow(ceil(x), 2);\n    }\n    return ans;\n}", "{\n    long\
    \ i = 0;\n    long sum = 0;\n    while (i < lst.length)\n    {\n        sum +=\
    \ cast(long) cast(int) ceil(lst[i] * lst[i]);\n        i += 1;\n    }\n    return\
    \ sum;\n}", "{\n    long result = 0;\n    int i;\n    int n = lst.length;\n  \
    \  for (i = 0; i < n; i++)\n    {\n        result += ceil(lst[i]) * ceil(lst[i]);\n\
    \    }\n    return result;\n}", "{\n    long total = 0;\n    foreach(e; lst)\n\
    \    {\n        total += cast(long)math.pow(std.typecons.Ceil(e), 2);\n    }\n\
    \    return total;\n}", "{\n    long[] b = new long[lst.length];\n    for (int\
    \ i = 0; i < lst.length; i++) {\n        b[i] = cast(long) ceil(lst[i]);\n   \
    \ }\n    return b.map!(a => a * a).sum;\n}", "{\n    long sum = 0;\n    foreach(float\
    \ elem; lst)\n    {\n        sum += int(elem) * int(elem);\n    }\n    return\
    \ sum;\n}", "{ \n    long acc=0;\n    lst.map!(a => cast(long)ceil(a)).each!(a\
    \ => acc += a*a)();\n    return acc;\n}\n// or another", "{\n\tint length = lst.length;\n\
    \tlong result = 0;\n\tforeach(i,element;lst)\n\t{\n\t\tresult += (long)element.ceil\
    \ * (long)element.ceil;\n\t}\n\treturn result;\n}", "{\n    long sum = 0;\n  \
    \  foreach(lst, l => sum += l*l);\n    return sum;\n}", "{\n    long result =\
    \ 0;\n    foreach(val; lst)\n    {\n        val = round(val);\n        result\
    \ += val*val;\n    }\n    return result;\n}", "{\n    long sum = 0;\n    foreach(float\
    \ item; lst)\n    {\n        long upper = (long)ceil(item);\n        sum += upper\
    \ * upper;\n    }\n    return sum;\n}\n/*\nYou are given an array of numbers.\n\
    \    You need to return the sum of squared numbers in the given array,\n    round\
    \ each element in the array to the upper int(Ceiling) first.\n    Examples:\n\
    \    >>> lst([1.0, 2.0, 3.0])\n    14L\n    >>> lst([1.0, 4.0, 9.0])\n    98L\n\
    \    >>> lst([1.0, 3.0, 5.0, 7.0])\n    84L\n    >>> lst([1.4, 4.2, 0.0])\n  \
    \  29L\n    >>> lst([-2.4, 1.0, 1.0])\n    6L\n    ", "{\n    long result = 0;\n\
    \    foreach(var item; lst)\n    {\n        result += cast(long) ceil(item * item);\n\
    \    }\n    return result;\n}", "{\n    float[] float_lst = lst.map!(x => x >\
    \ 0 ? ceil(x) : x);\n    auto squares = float_lst.map!(x => x * x);\n    return\
    \ cast(long)squares.sum;\n}", "{\n    long result = 0;\n    foreach(var v; lst)\n\
    \    {\n        if(v >= 0)\n            result += (long) std.math.ceil(v) * (long)\
    \ std.math.ceil(v);\n        else\n            result += (long) std.math.floor(v)\
    \ * (long) std.math.floor(v);\n    }\n    return result;\n}", "{\n    long sum\
    \ = 0;\n    foreach(float num; lst)\n    {\n        float result = (double) num;\n\
    \        if(result < 0)\n        {\n            result *= -1;\n        }\n   \
    \     result = ceil(result);\n        sum += (long) (result * result);\n    }\n\
    \    return sum;\n}", "{\n  long result=0;\n  foreach(float val; lst)\n  {\n \
    \   if(val<0)\n      result+=cast(long)(ceil(val*-1))*cast(long)(ceil(val*-1));\n\
    \    else\n      result+=cast(long)(ceil(val))*cast(long)(ceil(val));\n  }\n \
    \ return result;\n}", "{\n    immutable float[] r = lst.map!ceil;\n    return\
    \ r.map!pow.sum;\n}", "{\n    long sum = 0;\n    foreach(item; lst)\n    {\n \
    \       sum += item*item;\n    }\n    return sum;\n}", "{\n    long sum = 0;\n\
    \    int a;\n    foreach(float x; lst)\n    {\n        a = cast(int)ceil(x);\n\
    \        sum = sum + a*a;\n    }\n    return sum;\n}", "{\n    long sum = 0;\n\
    \    foreach(e; lst) \n    {\n        sum += cast(long)(ceil(e)) ** 2;\n    }\n\
    \    return sum;\n}", "{\n  float[] rounded = lst.map!(x => x.ceil).array;\n \
    \ float sum = 0.0;\n  foreach( x; rounded)\n  {\n    sum += (x*x);\n  }\n  return\
    \ sum.to!long;\n}", "{\n    float temp = 0.0;\n    long sum = 0L;\n    foreach(f;\
    \ lst)\n    {\n        temp = ceil(f);\n        sum += cast(long)temp*temp;\n\
    \    }\n    return sum;\n}", "{\n    float[] c = lst.map!(a => ceil(a)).array;\n\
    \    long sum = 0;\n    for(int i = 0; i < c.length; i++)\n    {\n        sum\
    \ += c[i] * c[i];\n    }\n    return sum;\n}", "{\n    auto result = 0L;\n   \
    \ foreach(element; lst)\n    {\n        result += cast(long)ceil(element) ** 2;\n\
    \    }\n    return result;\n}\n ", "{\n    long ans = 0;\n    foreach(e;lst)\n\
    \    {\n        float temp = ceil(e);\n        float temp1 = pow(temp,2);\n  \
    \      ans += temp1;\n    }\n    return ans;\n}", "{\n    int[] temp = new int[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        temp[i] = (int)ceil(lst[i]);\n\
    \    }\n    long total = 0;\n    foreach(var v; temp)\n    {\n        total +=\
    \ (long)pow(v, 2);\n    }\n    return total;\n}\n/*\nYou are given a string.\n\
    \    Your task is to print the string and its indices without spaces.\n    Examples:\n\
    \    >>> print_string_and_indices('Hello World')\n    H0e1l2l3o4 5W6o7r8l9d10\n\
    \    >>> print_string_and_indices('Python Exercises')\n    P0y1t2h3o4n5 6E7x8e9r10c11i12s13e14s15\n\
    \    >>> print_string_and_indices('PHP Exercises')\n    P0H1P2 3E4x5e6r7c8i9s10e11s12\n\
    \    >>> print_string_and_indices('Java Exercises')\n    J0a1v2a3 4E5x6e7r8c9i10s11e12s13\n\
    \    >>> print_string_and_indices('C# Exercises')\n    C0#1 2E3x4e5r6c7i8s9e10s11\n\
    \    >>> print_string_and_indices('C# Exercises')\n    C0#1 2E3x4e5r6c7i8s9e10s11\n\
    */\nstring print_string_and_indices(string s)\n{\n    string result = \"\";\n\
    \    int count = 0;\n    foreach(char c; s)\n    {\n        if (c == ' ')\n  \
    \      {\n            result += \" \";\n        }\n        else\n        {\n \
    \           result += c;\n            result += count.to!string;\n           \
    \ count++;\n        }\n    }\n    return result;\n}\n/*\nYou are given an array\
    \ of numbers.", "{\n    int  a = 0;\n    float[] arr = {1.0,2.0,3.0};\n    foreach(float\
    \ x; lst)\n    {\n        a += x;\n    }\n    return a;\n}\n/*", "{\n    import\
    \ std.math : ceil;\n    long sum = 0;\n    foreach(int el; lst)\n    {\n     \
    \   sum += el * el;\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(x;\
    \ lst)\n    {\n        sum += ceil(x) ^^ 2;\n    }\n    return sum;\n}", "{\n\
    \    int tmp = 0;\n    long res = 0;\n    foreach(i; lst)\n    {\n        tmp\
    \ = ceil(i);\n        res += tmp * tmp;\n    }\n    return res;\n}", "{\n    return\
    \ lst.map!(a => ceil(a))\n              .map!(a => a * a)\n              .reduce!((a,\
    \ b) => a + b)(0L);\n}", "{\n\tlong sum = 0;\n    for (float i : lst)\n    {\n\
    \    \tsum = sum + cast(long)(i * i);\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    foreach(float v; lst)\n    {\n        float r = v > 0.0 ? ceil(v)\
    \ : floor(v);\n        sum += cast(long)r * r;\n    }\n    return sum;\n}", "{\n\
    \    long ans = 0;\n    foreach(float v; lst)\n    {\n        ans += (v > 0 ?\
    \ (long)ceil(v) : (long)floor(v)) * (v > 0 ? (long)ceil(v) : (long)floor(v));\n\
    \    }\n    return ans;\n}", "{\n    long result = 0;\n    foreach(elem; lst)\n\
    \    {\n        result += ceil(elem) ** 2;\n    }\n    return result;\n}", "{\n\
    \    return lst.map!(i => cast(long)(ceil(i)) * (long)(ceil(i))).sum;\n}\nlong\
    \ sum_squares(float[] lst) \n{\n    return lst.map!(i => cast(long)(ceil(i)) *\
    \ (long)(ceil(i))).sum;\n}\nlong sum_squares(float[] lst) \n{\n    return lst.map!(i\
    \ => cast(long)(ceil(i)) * (long)(ceil(i))).sum;\n}\nlong sum_squares(float[]\
    \ lst) \n{\n    return lst.map!(i => cast(long)(ceil(i)) * (long)(ceil(i))).sum;\n\
    }\nlong sum_squares(float[] lst) \n{\n    return lst.map!(i => cast(long)(ceil(i))\
    \ * (long)(ceil(i))).sum;\n}\nlong sum_squares(float[] lst) \n{\n    return lst.map!(i\
    \ => cast(long)(ceil(i)) * (long)(ceil(i))).sum;\n}\nlong sum_squares(float[]\
    \ lst) \n{\n    return lst.map!(i => cast(long)(ceil(i)) * (long)(ceil(i))).sum;\n\
    }\nlong sum_squares(float[] lst) \n{\n    return lst.map!(i => cast(long)(ceil(i))\
    \ * (long)(ceil(i))).sum;\n}\nlong sum_squares(float[] lst) \n{\n    return lst.map!(i\
    \ => cast(long)(ceil(i)) * (long)(ceil(i))).sum;\n}\nlong sum_squares(float[]\
    \ lst) \n{\n    return lst.map!(i => cast(long)(ceil(i)) * (long)(ceil(i))).sum;\n\
    }\nlong sum_squares(float[] lst) \n{\n    return lst.map!(i => cast(long)(ceil(i))",
  "{\n    long r=0;\n    foreach(e;lst)\n        r+=cast(long)(ceil(e))*cast(long)(ceil(e));\n\
    \    return r;\n}", "{\n    float temp;\n    long sum = 0;\n    foreach(i;lst)\n\
    \    {\n        temp = ceil(i);\n        sum += temp*temp;\n    }\n    return\
    \ sum;\n}\n/*\n    You are given an array of numbers.\n    You need to return\
    \ the sum of squared numbers in the given array,\n    round each element in the\
    \ array to the upper int(Ceiling) first.\n    Examples:\n    >>> lst([1.0, 2.0,\
    \ 3.0])\n    14L\n    >>> lst([1.0, 4.0, 9.0])\n    98L\n    >>> lst([1.0, 3.0,\
    \ 5.0, 7.0])\n    84L\n    >>> lst([1.4, 4.2, 0.0])\n    29L\n    >>> lst([-2.4,\
    \ 1.0, 1.0])\n    6L\n    */\nlong[] sum_squares1(float[] lst) \n{\n    float\
    \ temp;\n    long []res = new long[2];\n    foreach(i;lst)\n    {\n        temp\
    \ = ceil(i);\n        res[0] += temp*temp;\n        res[1]++;\n    }\n    return\
    \ res;\n}\n/*\n    You are given an array of numbers.\n    You need to return\
    \ the sum of squared numbers in the given array,\n    round each element in the\
    \ array to the upper int(Ceiling) first.\n    Examples:\n    >>> lst([1.0, 2.0,\
    \ 3.0])\n    14L\n    >>> lst([1.0, 4.0, 9.0])\n    98L\n    >>> lst([1.0, 3.0,\
    \ 5.0, 7.0])\n    84L\n    >>> lst([1.4, 4.2, 0.0])\n    29L\n    >>> lst([-2.4,\
    \ 1.0, 1.0])\n    6L\n*/\nauto sum_squares2(float[] lst) \n{\n    float temp;\n\
    \    tuple!(long,int) res;\n    foreach(i", "{\n    int[] arr = new int[lst.length];\n\
    \    long sum = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        arr[i]\
    \ = cast(int)ceil(lst[i]);\n        sum += pow(arr[i], 2);\n    }\n    return\
    \ sum;\n}", "{\n    long result = 0;\n    foreach(float f; lst)\n    {\n     \
    \   result += cast(long)ceil(f) * cast(long)ceil(f);\n    }\n    return result;\n\
    }", "{\n    long sum = 0;\n    foreach(item; lst)\n    {\n        item = ceil(item);\n\
    \        sum += item * item;\n    }\n    return sum;\n}", "{\n    return sum(map!(ceil)(lst).map!(pow)(2L));\n\
    }", "{\n    float[] sum = new float[lst.length];\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        sum[i] = lst[i] * lst[i];\n    }\n    long sum_sum = 0;\n\
    \    for (int i = 0; i < sum.length; i++)\n    {\n        sum_sum += (long)ceil(sum[i]);\n\
    \    }\n    return sum_sum;\n}\n/*\nYou are given an array of numbers.\n    You\
    \ need to return the sum of squared numbers in the given array,\n    round each\
    \ element in the array to the lower int(Floor) first.\n    Examples:\n    >>>\
    \ lst([1.0, 2.0, 3.0])\n    14L\n    >>> lst([1.0, 4.0, 9.0])\n    98L\n    >>>\
    \ lst([1.0, 3.0, 5.0, 7.0])\n    84L\n    >>> lst([1.4, 4.2, 0.0])\n    29L\n\
    \    >>> lst([-2.4, 1.0, 1.0])\n    6L\n    ", "{\n    long res = 0;\n    int\
    \ i = 0;\n    foreach(var item; lst)\n    {\n        res += (long)pow(ceil(item),\
    \ 2);\n    }\n    return res;\n}", "    {\n        // your code here\n       \
    \ \n        //int temp = int.max;\n        int i = 0;\n        long sum = 0;\n\
    \        foreach(f; lst)\n        {\n            int temp = cast(int)ceil(f);\n\
    \            sum += temp * temp;\n            //int sum = 0;\n            i++;\n\
    \        }\n        return sum;\n    }", "{\n    lst = map!(ceil)(lst);\n    auto\
    \ squares = map!(pow)(lst, 2);\n    auto result = reduce!q{a + b}(squares);\n\
    \    return cast(long)result;\n}\n// long sum_squares(float[] lst) \n// {\n//\
    \     lst = map!(ceil)(lst);\n//     return lst.map!(x => x * x).reduce!((a, b)\
    \ => a + b);\n// }", "{\n    long r = 0;\n    foreach(e; lst)\n    {\n       \
    \ int ceil = ceil(e);\n        r += ceil * ceil;\n    }\n    return r;\n}", "{\n\
    \    int n = lst.length;\n    long sum = 0;\n    for (int i = 0; i < n; i++)\n\
    \    {\n        float x = lst[i];\n        float y = ceil(x);\n        sum +=\
    \ cast(long)(y * y);\n    }\n    return sum;\n}", "{\n    ulong r = 0;\n    foreach(x;\
    \ lst)\n    {\n        r += cast(ulong)(cast(float)ceil(x) ** 2);\n    }\n   \
    \ return cast(long)r;\n}", "{\n    long d = 0;\n    foreach(i; lst)\n    {\n \
    \       //debug i;\n        long c = ceil(i);\n        //debug c;\n        long\
    \ b = c * c;\n        //debug b;\n        d += b;\n        //debug d;\n    }\n\
    \    return d;\n}", "{\n    long res=0;\n    foreach(float x; lst) res += cast(long)\
    \ ceil(x) * cast(long) ceil(x);\n    return res;\n}", "{\n    \n    \n    long\
    \ total = 0;\n    foreach(float x; lst)\n    {\n        float r = ceil(x);\n \
    \       float y = r * r;\n        total += cast(long)y;\n    }\n    return total;\n\
    }", "{\n    int[] squares = new int[lst.length];\n    foreach(i, e; lst) \n  \
    \  {\n        squares[i] = cast(int)ceil(e);\n    }\n    return reduce!((a, b)\
    \ => a + b * b)(squares);\n}", "{\n    long sum = 0;\n    float f;\n    foreach(i;\
    \ lst)\n    {\n        f = floor(i);\n        f = (f*f);\n        sum += f;\n\
    \    }\n    return sum;\n}", "{\n    float[] result = lst.map!(floor)();\n   \
    \ return result.map!(x => x*x).sum();\n}", "{\n    //Your code is here\n    lst\
    \ = map!(ceil)(lst);\n    long sum = reduce!((a, b) => a + b^2)(lst);\n    return\
    \ sum;\n}", "{\nlong sum = 0;\nforeach(x;lst)\nsum += int(round(x*x));\nreturn\
    \ sum;\n}\n/*\nYou are given an array of numbers.\n    You need to return the\
    \ sum of squared numbers in the given array,\n    round each element in the array\
    \ to the upper int(Ceiling) first.\n    Examples:\n    >>> lst([1.0, 2.0, 3.0])\n\
    \    14L\n    >>> lst([1.0, 4.0, 9.0])\n    98L\n    >>> lst([1.0, 3.0, 5.0, 7.0])\n\
    \    84L\n    >>> lst([1.4, 4.2, 0.0])\n    29L\n    >>> lst([-2.4, 1.0, 1.0])\n\
    \    6L\n    ", "{\n    long sum = 0;\n    foreach(float a; lst)\n    {\n    \
    \    int b = std.math.ceil(a);\n        sum += b*b;\n    }\n    return sum;\n}",
  "{\n  auto sqrt = ceil(lst);\n  auto result = map!(a => a * a)(sqrt);\n  return\
    \ reduce!((x,y) => x + y)(result);\n}\n/*\n#Task:", "{\n    long sum = 0;\n  \
    \  foreach(e; lst) \n    {\n        auto t = cast(long)std.math.ceil(e);\n   \
    \     sum += t * t;\n    }\n    return sum;\n}", "{\n    return lst.map!(a =>\
    \ int(ceil(a))).map!(a => cast(long)a).map!(a => a*a).reduce!((a,b) => a+b)(0L);\n\
    }\n//long sum_squares(float[] lst) => lst.map!(a => int(ceil(a))).map!(a => cast(long)a).map!(a\
    \ => a*a).reduce!((a,b) => a+b)(0L);", "{\n    auto new_lst = lst.map!(a => float.ceil(a));\n\
    \    return new_lst.map!(a => a * a).reduce!((a, b) => a + b);\n}", "{\n    long\
    \ result = 0;\n    foreach(i;lst)\n    {\n        result += (long)(ceil(i) * ceil(i));\n\
    \    }\n    return result;\n}", "{\n   int[] a = new int[lst.length];\n   foreach(i,inout\
    \ b; azip(a,lst))\n   {\n      b = cast(int)ceil(i);\n   }\n   foreach(b; a)\n\
    \   {\n      b *= b;\n   }\n   long sum = 0;\n   foreach(b; a)\n   {\n      sum\
    \ += b;\n   }\n   return sum;\n}", "    in(lst) out(result)\n{\n    long sum =\
    \ 0;\n    auto tmp = lst.map!(a => cast(int)ceil(a)).array;\n    foreach(item;\
    \ tmp)\n    {\n        sum += item*item;\n    }\n    return sum;\n}", "{\n   \
    \ long result = 0;\n    foreach(val; lst)\n    {\n        auto val_rounded = ceil(val);\n\
    \        result += cast(long)std.math.pow(val_rounded, 2);\n    }\n    return\
    \ result;\n}", "{\n    // your code here\n    long res = 0;\n    foreach(i; lst)\n\
    \    {\n        int tmp = ceil(i);\n        res += tmp*tmp;\n    }\n    return\
    \ res;\n}", "{\n    long sum = 0;\n    foreach(item; lst)\n    {\n        sum\
    \ += cast(long)ceil(item)^2;\n    }\n    return sum;\n}", "{\n    long res = 0;\n\
    \    foreach(element; lst)\n    {\n        res += cast(long)(element*element);\n\
    \    }\n    return res;\n}", "{\n    long result = 0;\n    float[] a = lst.map!(x\
    \ => ceil(x));\n    foreach(x; a)\n    {\n        result += x * x;\n    }\n  \
    \  return result;\n}", "{\n  long sum = 0;\n  foreach(float num; lst)\n  {\n \
    \   sum += cast(long)std.math.ceil(num) * cast(long)std.math.ceil(num);\n  }\n\
    \  return sum;\n}", "{\n  long s = 0;\n  foreach(x; lst)\n    s += cast(long)(std.math.ceil(x))\
    \ ** 2;\n  return s;\n}", "{\n    if (lst.length == 0)\n        return 0;\n  \
    \  if (lst.length == 1)\n        return cast(long)ceil(lst[0] * lst[0]);\n   \
    \ return cast(long)ceil(lst[0] * lst[0]) + sum_squares(lst[1..$]);\n}", "{\n \
    \   long sum = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        sum\
    \ += long((ceil(lst[i]))*(ceil(lst[i])));\n    }\n    return sum;\n}", "{\n  \
    \  long sum;\n    foreach(e; lst)\n    {\n        sum += ceil(e)*ceil(e);\n  \
    \  }\n    return sum;\n}\n/*\n    You are given two arrays. Return the longest\
    \ contiguous subarray\n    of the first array that contains elements of the second\
    \ array.\n    Examples:\n    >>> lst1 = [1,2,3,4,5,6,7,8,9,10]\n    >>> lst2 =\
    \ [1,3,5,7,9]\n    >>> subarray(lst1, lst2)\n    [1,3,5,7,9]\n    >>> lst1 = [1,2,3,4,5,6,7,8,9,10]\n\
    \    >>> lst2 = [1,3,5,7,9,2,4,6,8,10]\n    >>> subarray(lst1, lst2)\n    [1,2,3,4,5,6,7,8,9,10]\n\
    \    >>> lst1 = [1,2,3,4,5,6,7,8,9,10]\n    >>> lst2 = [1,3,5,7,9,11,13,15,17,19]\n\
    \    >>> subarray(lst1, lst2)\n    [1,3,5,7,9]\n*/", "{\n    long sum = 0;\n \
    \   foreach(e; lst)\n    {\n        sum += cast(long) to!int(e * e);\n    }\n\
    \    return sum;\n}\n/*\nYou are given an array of numbers.\n    You need to return\
    \ the sum of squared numbers in the given array,\n    round each element in the\
    \ array to the lower int(Floor) first.\n    Examples:\n    >>> lst([1.0, 2.0,\
    \ 3.0])\n    14L\n    >>> lst([1.0, 4.0, 9.0])\n    100L\n    >>> lst([1.0, 3.0,\
    \ 5.0, 7.0])\n    82L\n    >>> lst([1.4, 4.2, 0.0])\n    28L\n    >>> lst([-2.4,\
    \ 1.0, 1.0])\n    8L\n    ", "{\n    long sum;\n    foreach(l; lst)\n    {\n \
    \       sum += ceil(l) ^^ 2;\n    }\n    return sum;\n}", "{\n    int sum=0;\n\
    \    foreach(float i; lst)\n    {\n        i=ceil(i);\n        i=i*i;\n      \
    \  sum+=i;\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(f;\
    \ lst)\n    {\n        auto x = ceil(f);\n        sum += long(x * x);\n    }\n\
    \    return sum;\n}", "{\n    static immutable long ZERO = 0L;\n    static immutable\
    \ float ZERO = 0.0;\n    static immutable float ONE = 1.0;\n    long ret = 0L;\n\
    \    long sq ;\n    foreach(el; lst)\n    {\n        sq = long(ceil(el));\n  \
    \      ret += (sq * sq);\n    }\n    return ret;\n}\n// END ", "{\n    long sum=0;\n\
    \    foreach(e; lst)\n    {\n        sum+=cast(long)(ceil(e)*ceil(e));\n    }\n\
    \    return sum;\n}", "{\n    int lst_len = lst.length;\n    int i = 0;\n    long\
    \ sum = 0L;\n    while (i < lst_len)\n    {\n        sum += cast(long)(ceil(lst[i])\
    \ * ceil(lst[i]));\n        i++;\n    }\n    return sum;\n}", "{\n    float[]\
    \ t = lst.map!(x => x * x);\n    long result = 0;\n    foreach(i; t)\n    {\n\
    \        result += cast(long)i;\n    }\n    return result;\n}", "{\n    long res\
    \ = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        float val = lst[i];\n\
    \        float pow = val * val;\n        res += ceil(pow);\n    }\n    return\
    \ res;\n}\n/*\nYou have a string and a dictionary.\n    Write a function that\
    \ returns the shortest substring that contains all the items in the dictionary.\n\
    \    Example:\n    >>> lst(\"alcatraz\", [\"a\", \"c\", \"t\"])\n    \"cat\"\n\
    \    >>> lst(\"foobar\", [\"foo\", \"bar\"])\n    \"foobar\"\n    >>> lst(\"aaaaaaaaaaa\"\
    , [\"aa\", \"aaa\", \"aaaa\"])\n    \"aaaaaaaaaaa\"\n    >>> lst(\"foo\", [\"\
    foo\", \"bar\"])\n    \"\"\n    >>> lst(\"foo\", [\"foo\", \"fo\"])\n    \"foo\"\
    \n    >>> lst(\"foobar\", [\"foo\", \"bar\", \"barz\"])\n    \"\"\n    >>> lst(\"\
    foobarfoobarfoobarfoobarfoobarfoobarfoobar\", [\"foo\", \"bar\"])\n    \"foobarfoobarfoobarfoobarfoobarfoobarfoobar\"\
    \n    >>> lst(\"foobarfoobarfoobarfoobarfoobarfoobarfoobar\", [\"foo\", \"bar\"\
    , \"baz\"])\n    \"\"\n    >>> lst(\"barfoobarbar\", [\"foo\", \"bar\"])\n   \
    \ \"barfoobarbar\"\n    >>> lst(\"barfoobarbar\", [\"foo\", \"baz\"])\n    \"\"\
    \n    >>> lst(\"fooaabfoobarbar\", [\"foo\", \"bar\"])\n    \"fooaabfoobarbar\"\
    \n    >>> lst(\"fooaabfoobarbar\", [\"foo\", \"baz\"])\n    \"\"\n    >>> lst(\"\
    the quick brown fox jumps over the lazy dog\", [\"the\", \"quick\", \"fox\", \"\
    jumps\", \"over\", \"the\", \"lazy\", \"dog\"])\n    \"the quick brown fox jumps\
    \ over the lazy dog\"\n    >>> lst(\"the quick brown fox jumps over the lazy dog\"\
    , [\"the\", \"quick\", \"fox\", \"jumps\", \"over\", \"the", "{\n    import std.algorithm.iteration\
    \ : map;\n    import std.range : zip;\n    import std.typecons : tuple;\n    auto\
    \ zipped = zip(lst, lst.map!(a => a*a));\n    return zipped.map!(a => a[1]).reduce!(a\
    \ => a + b).sum;\n    \n    //return zipped.map!(a => a[1]).sum;\n    //return\
    \ zipped.map!(a => a[1]).reduce!(a => a + b).sum;\n    //return lst.map!(a =>\
    \ a*a).reduce!(a => a + b).sum;\n    //return lst.map!(a => a*a).sum;\n    //return\
    \ lst.map!(a => a*a).reduce!(a => a + b).sum;\n    //return lst.map!(a => cast(long)\
    \ a*a).sum;\n}", "{\n    auto res = 0L;\n    foreach(e; lst) res += ceil(e) *\
    \ ceil(e);\n    return res;\n}", "{\n    if (lst.length==0)\n        return 0;\n\
    \    if (lst.length==1)\n        return (long)pow(ceil(lst[0]),2);\n    return\
    \ (long)pow(ceil(lst[0]),2)+sum_squares(lst[1..$]);\n}", "{\n    long res = 0;\n\
    \    foreach(i; lst)\n    {\n        res += ceil(i) * ceil(i);\n    }\n    return\
    \ res;\n}", "{\n    long squaresum = 0;\n    foreach(elem; lst)\n    {\n     \
    \ squaresum += float(ceil(elem)) ** 2;\n    }\n    \n    return squaresum;\n}",
  "{\n    long result = 0;\n    for (int i = 0; i < lst.length; i++) \n    {\n   \
    \     result += cast(long) (lst[i] * lst[i]);\n    }\n    return result;\n}\n\
    /*\nYou are given a sorted array of integers and a number.\n    You need to find\
    \ the index of a number in the given array.\n    If the number doesn't exist,\
    \ you need to return -1.\n    You can assume that the same number exists in the\
    \ array.\n    Input: an array of integers and a number\n    Output: an integer.\n\
    \    Examples:\n    >>> my_index([1, 3, 3, 3, 5], 3)\n    1\n    >>> my_index([1,\
    \ 3, 3, 3, 5], 4)\n    -1\n    >>> my_index([1, 3, 3, 3, 5], 5)\n    4\n    >>>\
    \ my_index([1, 3, 3, 3, 5], 1)\n    0\n    ", "{\n    long sum = 0;\n    foreach(e;\
    \ lst)\n    {\n        sum += (long)std.math.ceil(e) * (long)std.math.ceil(e);\n\
    \    }\n    return sum;\n}\n/*\nReturn the product of the given array elements.\n\
    \    If the array is empty, return None.\n    Examples:\n    >>> product([2, 3,\
    \ 4])\n    24L\n    >>> product([])\n    None\n    >>> product([-2.0, 1.0, 1.0])\n\
    \    -2.0\n    >>> product([10.0, 0.0, 1.0])\n    0.0\n    >>> product([0.0, 0.0,\
    \ 0.0])\n    0.0\n    ", "{\n    lst = lst.map!(Math.ceil)();\n    float square(float\
    \ n) \n    {\n        return n * n;\n    }\n    float total = 0;\n    foreach(a;\
    \ lst)\n    {\n        total += square(a);\n    }\n    return cast(long)total;\n\
    }", "{\n    return lst.map!((x)=>cast(uint)(ceil(x))).map!((x)=>x*x).reduce!((x,y)=>x+y);\n\
    }", "{\n    auto lst2 = lst.map!ceil;\n    long ret = 0;\n    foreach(num; lst2)\n\
    \    {\n        ret += num*num;\n    }\n    return ret;\n}", "{\n    long sum=0;\n\
    \    foreach(var i; lst)\n    {\n        sum+=(long)ceil(i)*(long)ceil(i);\n \
    \   }\n    return sum;\n}\n/*\nYou are given an array of numbers.\n    You need\
    \ to return the sum of squares of the elements in the given array,\n    with a\
    \ twist. The twist is instead of simply squaring the elements you need to multiply\
    \ each element by the element on its right\n    (Note: If the array has an odd\
    \ length the last element should be squa", "{\n    float[] tmp = lst.map!(a =>\
    \ cast(float) ceil(a));\n    long res = 0;\n    for (float elt in tmp)\n    {\n\
    \        res += cast(long) elt * elt;\n    }\n    return res;\n}", "{\n    long\
    \ sum = 0;\n    foreach(e;lst)\n    {\n        if(e<0)\n        {\n          \
    \  e = e.abs;\n        }\n        sum += cast(long)(ceil(e))^2;\n    }\n    return\
    \ sum;\n}", "{\n    long sum=0;\n    for(float elem : lst)\n    {\n        sum\
    \ += Math.pow(Math.ceil(elem),2);\n    }\n    return sum;\n}", "{\n    long sum\
    \ = 0;\n    foreach(float num; lst)\n    {\n        sum += cast(long)std.math.pow(num.ceil,\
    \ 2);\n    }\n    return sum;\n}", "{\n    long result=0;\n    foreach(x;lst)\n\
    \    {\n        result+=ceil(x)*ceil(x);\n    }\n    return result;\n}", "{\n\t\
    long sum = 0;\n\tforeach(item;lst)\n\t{\n\t\tsum += (long)ceil(item)^2;\n\t}\n\
    \treturn sum;\n}", "{\n    long result = 0;\n    foreach(index, item; lst)\n \
    \   {\n        result += cast(long)((ceil(item) * ceil(item)));\n    }\n    return\
    \ result;\n}", "{\n    auto result = long.init;\n    foreach(lst;i) \n    {\n\
    \        result += cast(long)ceil(lst[i]) * cast(long)ceil(lst[i]);\n    }\n \
    \   return result;\n}", "{\n    \n    \n    int[] ceil_arr = lst.map!(a => cast(int)a\
    \ + 1).array;\n    long return_sum = 0;\n    foreach(var x; ceil_arr)\n    {\n\
    \        long sqred = x*x;\n        return_sum += sqred;\n    }\n    return return_sum;\n\
    }", "{\n    auto result = 0;\n    foreach(item; lst)\n    {\n        result +=\
    \ ceil(item) * ceil(item);\n    }\n    return result;\n}", "{\n    long sum =\
    \ 0;\n    foreach(e; lst) {\n        auto ceil = cast(int) std.math.ceil(e);\n\
    \        sum += ceil*ceil;\n    }\n    return sum;\n}", "{\n    long r=0;\n  \
    \  foreach(f; lst)\n    {\n        r += cast(long)(ceil(f))*cast(long)(ceil(f));\n\
    \    }\n    return r;\n}", "{\n    long sum = 0;\n    for (float i : lst)\n  \
    \  {\n        int ceil = cast(int)ceil(i);\n        sum += ceil*ceil;\n    }\n\
    \    return sum;\n}", "{\n    long result = 0;\n    foreach(x; lst)\n    {\n \
    \       result += cast(long)(ceil(x)*ceil(x));\n    }\n    return result;\n}",
  "{\n     long ans = 0;\n     auto t = lst.map!(ceil);\n     foreach(i; t)\n    \
    \     ans += cast(long) i * i;\n     return ans;\n}\n/*\nHackerLand Enterprise\
    \ is adopting a new viral advertising strategy.\nWhen they launch a new product,\
    \ they advertise it to exactly  people on social media.\n    On the first day,\
    \ half of those  people (i.e., ) like the advertisement and each shares it with\
    \  of their friends.\n    At the beginning of the second day,  people receive\
    \ the advertisement.\nEach day,  of the recipients like the advertisement and\
    \ will share it with  friends on the following day.\nAssuming nobody receives\
    \ the advertisement twice, determine how many people have liked the ad by the\
    \ end of a given day, beginning with launch day as day .", "{\n    long sum =\
    \ 0;\n    foreach(i, v; lst)\n    {\n        sum += cast(long)(ceil(v) * ceil(v));\n\
    \    }\n    return sum;\n}", "{\n    float res=0.0;\n    foreach(f;lst) res+=f*f;\n\
    \    return cast(long) ceil(res);\n}", "{\n    long result = 0;\n    foreach(i;\
    \ lst)\n    {\n        auto a = ceil(i);\n        result += a * a;\n    }\n  \
    \  return result;\n}", "{\n    float[] arr = lst.map!(a => a > 0 ? ceil(a) : floor(a)).map!(a\
    \ => a * a).array;\n    return arr.reduce!((prev,curr) => prev + curr)();\n}",
  "{\n   long sum = 0;\n   for(int i = 0; i < lst.length; i++)\n   {\n      sum +=\
    \ cast(long)Math.ceil(lst[i] * lst[i]);\n   }\n   return sum;\n}", "{\n    long\
    \ Result = 0;\n    for (auto elem : lst)\n    {\n        Result += ceil(elem)\
    \ * ceil(elem);\n    }\n    return Result;\n}", "{\n    int i = 0;\n    long res\
    \ = 0;\n    while (i < lst.length) {\n        res += cast(long)(ceil(lst[i]) *\
    \ ceil(lst[i]));\n        i++;\n    }\n    return res;\n}", "{\n    long res =\
    \ 0;\n    foreach(el; lst)\n    {\n        res += (long)pow(ceil(el), 2);\n  \
    \  }\n    return res;\n}", "{\n  long l = 0;\n  foreach(inout x; lst)\n  {\n \
    \   x = std.math.ceil(x);\n    l += x * x;\n  }\n  return l;\n}", "{\n    return\
    \ sum(map!(lst, (x) => (cast(long) ceil(x)) ^^ 2));\n}\n/*\nChoco is a rather\
    \ small chocolate bar consisting of a single row of small cubes.\n    Its size\
    \ is given as the number of these cubes.\n    Choco can be broken down either\
    \ by one break, or by two consecutive breaks,\n    or by three consecutive breaks.\n\
    \    (Two breaks are called consecutive if they are separated by a single cube.)\n\
    \    Your function should return the maximum number of pieces that can be obtained\n\
    \    by breaking the chocolate bar in the given order.\n    Examples:\n    >>>\
    \ choco(5)\n    5\n    >>> choco(8)\n    14\n    >>> choco(19)\n    83\n    >>>\
    \ choco(27)\n    169\n    >>> choco(30)\n    199\n    >>> choco(1)\n    1\n  \
    \  >>> choco(0)\n    0\n*/\nlong choco(long n) \n{\n    long ret = 0;\n    for\
    \ (int i = 0; i < 3; i++)\n    {\n        for (int j = i + 1; j < 4; j++)\n  \
    \      {\n            for (int k = j + 1; k < 5; k++)\n            {\n       \
    \         if (n >= i + j + k)\n                    ret = max(ret, i + j + k);\n\
    \            }\n        }\n    }\n    return ret;\n}\n/*\nYou are given a string\
    \ and a dictionary of words.\n    The given string can be segmented into a sequence\
    \ of one or more dictionary words.\n    You have to give a list of all such possible\
    \ segmentations of the given string.\n    The given string does not contain any\
    \ whitespace characters.\n    Examples:\n    >>> word_break(\"thequickbrownfox\"\
    , [\"the\", \"quick\", \"brown\", \"fox\"])\n    [\"the quick brown fox\"]\n \
    \   >>> word_break(\"bedbathandbeyond\", [\"bed\", \"bath\", \"bedbath\", \"and\"\
    , \"beyond\"])\n    [\"bed bath and beyond\"]\n    >>> word_break(\"ilovetocode\"\
    , [\"i\", \"love\", \"to\", \"code\"])\n    [\"i love to code\"]", "{\n    long\
    \ r = 0;\n    foreach(i; lst)\n    {\n        r += cast(long)(ceil(i) * ceil(i));\n\
    \    }\n    return r;\n}", "{\n    int[long][int] x;\n    int[] foo;\n    foo\
    \ = map!(lst, x => cast(int)x);\n    long sum;\n    sum = reduce!(\"a + b * b\"\
    , foo);\n    return sum;\n}\n// TODO:\n// Check tests:\n// https://www.codewars.com/kata/return-the-sum-of-squares-of-only-the-positive-numbers/train/d",
  "{\n    long result=0;\n    foreach(float f; lst)\n    {\n        float f2=ceil(f);\n\
    \        result+=f2*f2;\n    }\n    return result;\n}", "{\n\treturn lst.map!(a\
    \ => cast(int)a + 1).map!(a => a * a).sum;\n}", "{ \n  auto squaredLst = map!((v)\
    \ => float(ceil(v)))(lst);\n  auto result = reduce!((result, value) => result\
    \ + value * value)(squaredLst);\n  return result;\n}", "{\n    /*\n    return\
    \ sum\n    (map!(x => cast(long)(x*x))\n    (map!(x => ceil(x))(lst)));\n    */\n\
    \    return cast(long)(reduce!((a, b) => a + b)(map!(x => cast(long)(x*x))(map!(x\
    \ => ceil(x))(lst))));\n}\nversion(Oliviers_version)\n{\n    long sum_squares(float[]\
    \ lst) \n    {\n        return cast(long)(reduce!((a, b) => a + b)(map!(x => cast(long)(x*x))(map!(x\
    \ => ceil(x))(lst))));\n    }\n}", "{\n    lst = lst.map!(a => ceil(a)).map!(b\
    \ => b*b).array();\n    return lst.sum;\n}\n/*\nYou are given an array of numbers.\n\
    \    You need to find the smallest possible number that can be formed\n    by\
    \ combining the same index of each array.\n    Examples:\n    >>> lst([[1, 1,\
    \ 1], [2, 2, 2], [3, 3, 3]])\n    1112233L\n    >>> lst([[10, 10, 10], [9, 9,\
    \ 9], [8, 8, 8]])\n    11111112222223333333333L\n    >>> lst([[1, 1, 1], [10,\
    \ 0, 10], [100, 100, 100]])\n    1101010101L\n    >>> lst([[1, 1, 1], [10, 0,\
    \ 10], [100, 100, 100]])\n    1101010101L\n    ", "{\n    int size = lst.length;\n\
    \    long sum = 0;\n    for (int i = 0; i < size; i++)\n    {\n        int item\
    \ = int(ceil(lst[i]));\n        sum += item * item;\n    }\n    return sum;\n}",
  "{\n    long ret = 0;\n    foreach(float elt; lst) {\n        ret += (long) ceil(elt)\
    \ * (long) ceil(elt);\n    }\n    return ret;\n}", "{\n    assert(lst.length >\
    \ 0);\n    long ans = 0;\n    int i = 0;\n    while (i < lst.length)\n    {\n\
    \        int el = ceil(lst[i]);\n        ans += (long)el * el;\n        i += 1;\n\
    \    }\n    return ans;\n}", "{\n    return reduce!(a => a + a, map!(ceil, lst));\n\
    }\n// BEGIN TEMPLATE\nlong lst(float[] lst)\n{\n    return sum_squares(lst);\n\
    }\n// END TEMPLATE", "{\n    long sum = 0;\n    foreach(var n; lst) \n    {\n\
    \        sum += cast(long)(ceil(n) * ceil(n));\n    }\n    return sum;\n}", "{\n\
    \    long res = 0;\n    foreach(var x; lst)\n    {\n        res += cast(long)(x.ceil())\
    \ ^^ 2;\n    }\n    return res;\n}", "{\n    long ret = 0;\n    foreach(e; lst)\n\
    \    {\n        int i = cast(int) std.math.ceil(e);\n        ret += i * i;\n \
    \   }\n    return ret;\n}", "{\n    // your code\n    long sum=0;\n    foreach(v;lst)\n\
    \    {\n        sum+=ceil(v)*ceil(v);\n    }\n    return sum;\n}", "{\n    long\
    \ result = 0;\n    foreach(el; lst)\n    {\n        //result += ceil(el);\n  \
    \      result += cast(long)ceil(el) ^^ 2;\n        //result += pow(cast(long)ceil(el),\
    \ 2);\n    }\n    return result;\n}", "{\n    long sum = 0;\n    foreach(float\
    \ f; lst) \n    {\n        f = ceil(f);\n        sum += cast(long) f * f;\n  \
    \  }\n    return sum;\n}", "{\n    return lst.map!(a => ceil(a)).map!(a => a *\
    \ a).sum;\n}", "{\n    /* your code */\n    long result = 0;\n    foreach(i; lst)\n\
    \    {\n        result += cast(long)(ceil(i))^2;\n    }\n    return result;\n}",
  "{\n    lst = lst.map!(x => ceil(x)).array;\n    lst = lst.map!(x => x * x).array;\n\
    \    long sum = lst.sum;\n    return sum;\n}", "{\n    long result = 0;\n    foreach(i;lst)\n\
    \    {\n        result += i;\n    }\n    return result;\n}", "{\n    // first\
    \ round all the elements in the array to the upper int (ceiling)\n    import std.typecons;\n\
    \    int[] new_lst = [];\n    foreach(number; lst)\n    {\n        import std.math;\n\
    \        float new_number = ceil(number);\n        new_lst ~= cast(int)new_number;\n\
    \    }\n    // then get the sum of the squared elements\n    long total = 0;\n\
    \    foreach(number; new_lst)\n    {\n        total += number*number;\n    }\n\
    \    return total;\n}", "{\n    return lst.map!(x => ln(x) + 1).map!(x => x *\
    \ x).sum();\n}", "{\n    return lst.map!(a => cast(long)(std.math.ceil(a))^2).sum;\n\
    }", "{\n    /*\n    auto map = lst.map!(a => a > 0 ? a.ceil : a.floor);\n    long\
    \ sum = 0;\n    foreach(num; map) \n    {\n        sum += (num ^^ 2);\n    }\n\
    \    return sum;\n    */\n    return lst.map!(a => a > 0 ? a.ceil : a.floor).map!(a\
    \ => a ^^ 2).sum;\n}", "{\n    auto len = lst.length;\n    if (len == 0)\n   \
    \     return 0;\n    else\n    {\n        auto new_lst = new float[len];\n   \
    \     foreach (index, val; lst)\n        {\n            new_lst[index] = ceil(val);\n\
    \        }\n        auto sum = 0;\n        foreach (i; new_lst)\n        {\n \
    \           sum += i*i;\n        }\n        return sum;\n    }\n}", "{\n    lst\
    \ = lst.map!(a => cast(float)ceil(a)).array;\n    return lst.map!(a => a * a).sum;\n\
    }", "{\n    int upper(float f) \n    {\n        return cast(int)ceil(f);\n   \
    \ }\n    long res = 0;\n    foreach(v; lst)\n    {\n        res += v * v;\n  \
    \  }\n    return res;\n}\nfloat[] lst(float[] input)\n{\n    return map!(upper)(input);\n\
    }", "    long res = 0;\n    foreach(elem; lst) \n        res += cast(long) pow(cast(int)\
    \ ceil(elem), 2);\n    return res;\n}\n/*\nYou are given a list/array which contains\
    \ only integers (positive and negative).\n    Your job is to sum only the numbers\
    \ that are the same and consecutive.\n    The result should be one list.\n   \
    \ Extra credit if you solve it in one line.\n    You can asume there is never\
    \ an empty list/array and there will always be an integer.\n    Same meaning:\
    \ 1 == 1\n    1 != -1\n    Examples:\n    >>> lst([1, 4, 4, 4, 0, 4, 3, 3, 1])\n\
    \    [1, 12, 0, 4, 6, 1]\n    >>> lst([1, 1, 7, 7, 3])\n    [2, 14, 3]\n    >>>\
    \ lst([-5, -5, 7, 7, 12, 0])\n    [-10, 14, 12, 0]\n    >>> lst([3, 3, 3, 3, 1])\n\
    \    [12, 1]\n    >>> lst([2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3", "{\n    return lst.map!(a => a*a).reduce!((a,b) => a+b)();\n}", "{\n   \
    \ long res = 0;\n    foreach(idx, v; lst)\n    {\n        lst[idx] = ceil(v);\n\
    \        res += cast(long)lst[idx] * lst[idx];\n    }\n    return res;\n}", "{\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    /*\n    for (float\
    \ x in lst)\n    {\n        x=ceil(x);\n        x=x*x;\n        i+=x;\n    }\n\
    \    */\n    \n    \n    \n    /*\n    foreach(float x; lst)\n    {\n        x=ceil(x);\n\
    \        x=x*x;\n        i+=x;\n    }\n    */\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "{\n    import std.conv\
    \ : to;\n    long acc = 0;\n    foreach(n; lst)\n    {\n        acc += ceil(n)*ceil(n);\n\
    \    }\n    return acc;\n}\n/*\nYou are given two arrays of numbers.\n    Return\
    \ an array where all values are multiplied by the corresponding value in the second\
    \ array.\n    Example:\n    >>> lst([1, 2, 3], [4, 5, 6])\n    [4, 10, 18]\n \
    \   >>> lst([1, 2, 3], [1, 1, 1])\n    [1, 2, 3]\n    >>> lst([1, 2, 3], [2, 3,\
    \ 1])\n    [2, 6, 3]\n    >>> lst([1, 1, 1], [2, 3, 1])\n    [2, 3, 1]\n    >>>\
    \ lst([1, 1, 1], [0, 0, 0])\n    [0, 0, 0]\n    >>> lst([1, 2, 3], [0, 0, 0])\n\
    \    [0, 0, 0]\n    ", "{\n    int last = lst.length - 1;\n    long sum = 0;\n\
    \    // Foreach number in the array\n    foreach(i, value; lst)\n    {\n     \
    \   // take it's absolute value\n        // cast it to an integer\n        //\
    \ square it\n        // add it to the sum\n        value = abs(value);\n     \
    \   sum += cast(long)(ceil(value)) ^^ 2;\n    }\n    return sum;\n}", "{\n  float\
    \ sum = 0;\n  foreach(elem; lst)\n  {\n    sum += cast(int) ceil(elem) * cast(int)\
    \ ceil(elem);\n  }\n  return cast(long) sum;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
