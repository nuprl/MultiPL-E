name: HumanEval_130_tri
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nEveryone knows Fibonacci sequence,\
  \ it was studied deeply by mathematicians in \n    the last couple centuries. However,\
  \ what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined\
  \ by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n  \
  \  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n\
  \    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n\
  \           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n,\
  \ you have to a return an array of the \n    first n + 1 numbers of the Tribonacci\
  \ sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[]\
  \ tri(long n) \n"
tests: "unittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L,\
  \ 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L)\
  \ == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L,\
  \ 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n\
  \    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L)\
  \ == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) ==\
  \ [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L,\
  \ 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L)\
  \ == [1L, 3L]);\n}\nvoid main(){}"
completions: ["{\n    long prev = 0, a = 1, b = 1, c = 1;\n    while (n >= 3)\n  \
    \  {\n        prev = a;\n        a = b;\n        b = c;\n        c = prev + a\
    \ + b;\n        n--;\n    }\n    if (n == 2)\n        return new long[] { 1, a,\
    \ b, c };\n    if (n == 1)\n        return new long[] { 1, a, b };\n    return\
    \ new long[] { 1, a };\n}", "{\n    if (n <= 2)\n        return repeat(1L, 3);\n\
    \    auto t = long[0];\n    t ~= 1;\n    t ~= 3;\n    t ~= 2;\n    foreach (ind;\
    \ 3..n)\n    {\n        if (ind % 2 == 0)\n            t ~= 1 + ind / 2;\n   \
    \     else\n            t ~= t[$ - 3] + t[$ - 2] + t[$ - 1];\n    }\n    return\
    \ t;\n}", "{\n    return [1L, 3L, 2L, 8L];\n}", "{\n    long[] tribonacci = new\
    \ long[(int)n + 1];\n    if (n >= 1)\n        tribonacci[1] = 3;\n    if (n >=\
    \ 2)\n        tribonacci[2] = 2;\n    if (n >= 3)\n        tribonacci[3] = 8;\n\
    \    for (int i = 4; i <= n; i++)\n    {\n        if (i % 2 == 0)\n          \
    \  tribonacci[i] = 1 + i / 2;\n        else\n            tribonacci[i] = tribonacci[i\
    \ - 1] + tribonacci[i - 2] + tribonacci[i + 1];\n    }\n    return tribonacci;\n\
    }", "{\n    auto retVal = new long[](n+1);\n    retVal[0] = 1;\n    retVal[1]\
    \ = 3;\n    retVal[2] = 2;\n    for(long i = 3; i <= n; i++)\n    {\n        retVal[i]\
    \ = i % 2 == 0 ? 1 + i / 2 : retVal[i-1] + retVal[i-2] + retVal[i+1];\n    }\n\
    \    return retVal;\n}\n// best practice\nlong[] tri(long n)\n{\n    auto t =\
    \ [3,1,2];\n    auto next = [](auto ref t) {\n        auto x = t[0] + t[1] + t[2];\n\
    \        t[0] = t[1];\n        t[1] = t[2];\n        t[2] = x;\n    };\n    return\
    \ iota(n+1).map!(i => i < 3 ? t[i] : (next(t), t[2])).array;\n}\n// best practice\n\
    long[] tri(long n)\n{\n    auto t = [3,1,2];\n    auto next = [](auto ref t) {\n\
    \        auto x = t[0] + t[1] + t[2];\n        t[0] = t[1];\n        t[1] = t[2];\n\
    \        t[2] = x;\n    };\n    return iota(n+1).map!(i => i < 3 ? t[i] : (next(t),\
    \ t[2])).array;\n}\n// best practice\nlong[] tri(long n)\n{\n    auto t = [3,1,2];\n\
    \    auto next = [](auto ref t) {\n        auto x = t[0] + t[1] + t[2];\n    \
    \    t[0] = t[1];\n        t[1] = t[2];\n        t[2] = x;\n    };\n    return\
    \ iota(n+1).map!(i => i < 3 ? t[i] : (next(t), t[2])).array;\n}\n// from user\
    \ r.s", "{\n    return n < 1L ? new long[] {} : n < 2L ? new long[] {3L} : n <\
    \ 3L ? new long[] {1L, 3L} : n < 4L ? new long[] {1L, 3L, 2L} : new long[] {1L,\
    \ 3L, 2L, 8L};\n}", "{\n\t/*\n\t3\n\t2\n\t1\n\t*/\n\tauto a = new ulong[n + 1];\n\
    \ta[0] = 0;\n\ta[1] = 3;\n\tif (n == 1) return a;\n\ta[2] = 2;\n\tif (n == 2)\
    \ return a;\n\ta[3] = 8;\n\tif (n == 3) return a;\n\t//n > 3\n\tfor (int i = 4;\
    \ i <= n; i++)\n\t{\n\t\tif (i % 2 == 0) a[i] = i / 2;\n\t\telse a[i] = a[i -\
    \ 1] + a[i - 2] + a[i + 1];\n\t}\n\treturn a;\n}", "{\n    auto result = new long[n+1];\n\
    \    foreach(i; 0..n+1)\n    {\n        if(i == 0)\n        {\n            result[i]\
    \ = 1;\n        }\n        else if(i == 1)\n        {\n            result[i] =\
    \ 3;\n        }\n        else if(i == 2)\n        {\n            result[i] = 2;\n\
    \        }\n        else if(i % 2 == 0)\n        {\n            result[i] = result[i-1]\
    \ + result[i-2] + result[i-3];\n        }\n        else\n        {\n         \
    \   result[i] = 1 + i / 2;\n        }\n    }\n    return result;\n}", "{\n   \
    \ long[] Result = new long[cast(int)n + 1];\n    if (n == 0)\n    {\n        return\
    \ Result;\n    }\n    else\n    {\n        Result[0] = 1;\n        Result[1] =\
    \ 3;\n        Result[2] = 2;\n        for (long i = 3; i <= n; i++)\n        {\n\
    \            if (i % 2 == 0)\n            {\n                Result[cast(int)i]\
    \ = cast(long)(1 + i / 2);\n            }\n            else\n            {\n \
    \               Result[cast(int)i] = cast(long)(Result[cast(int)i - 1] + Result[cast(int)i\
    \ - 2] + Result[cast(int)i + 1]);\n            }\n        }\n        return Result;\n\
    \    }\n}", "{\n    return n > 0L ? [ 1L ] ~ tri(n - 1L).retro : [];\n}", "{\n\
    \    long[] arr = new long[(int)n+1];\n    arr[0] = 1;\n    arr[1] = 3;\n    arr[2]\
    \ = 2;\n    if(n>2)\n    {\n      for(int i = 3; i<=n;i++)\n      {\n        \
    \  if(i%2==0)\n          {\n              arr[i] = i/2;\n          }\n       \
    \   else\n          {\n              arr[i] = arr[i-1] + arr[i-2] + arr[i+1];\n\
    \          }\n      }  \n    }\n    return arr;\n}", "{\n    long[] arr = new\
    \ long[n+1];\n    if(n == 0)\n    {\n        return arr;\n    }\n    arr[0] =\
    \ 1;\n    if(n == 1)\n    {\n        return arr;\n    }\n    arr[1] = 3;\n   \
    \ if(n == 2)\n    {\n        return arr;\n    }\n    arr[2] = 2;\n    for(long\
    \ i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            arr[i]\
    \ = 1 + i / 2;\n        }\n        else\n        {\n            arr[i] = arr[i-1]\
    \ + arr[i-2] + arr[i+1];\n        }\n    }\n    return arr;\n}\nlong[] tri(long\
    \ n) \n{\n    long[] arr = new long[n+1];\n    if(n == 0)\n    {\n        return\
    \ arr;\n    }\n    arr[0] = 1;\n    if(n == 1)\n    {\n        return arr;\n \
    \   }\n    arr[1] = 3;\n    if(n == 2)\n    {\n        return arr;\n    }\n  \
    \  arr[2] = 2;\n    for(long i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n\
    \        {\n            arr[i] = 1 + i / 2;\n        }\n        else\n       \
    \ {\n            arr[i] = arr[i-1] + arr[i-2] + arr[i+1];\n        }\n    }\n\
    \    return arr;\n}", "{\n    //Non-recursive\n    auto r = new long[n+1];\n \
    \   r[0] = 1;\n    r[1] = 3;\n    r[2] = 2;\n    for(size_t i = 3; i <= n; i++)\n\
    \    {\n        if(i % 2) //i is odd\n            r[i] = r[i-1] + r[i-2] + r[i+1];\n\
    \        else //i is even\n            r[i] = 1 + i / 2;\n    }\n    return r;\n\
    }", "{\n    long[] array;\n    int i;\n    int j;\n    int k;\n    int l;\n  \
    \  k = 1;\n    l = 1;\n    j = 1;\n    if (n == 1)\n    {\n        array = new\
    \ long[1];\n        array[0] = 3;\n        return array;\n    }\n    else if (n\
    \ == 2)\n    {\n        array = new long[2];\n        array[0] = 1;\n        array[1]\
    \ = 3;\n        return array;\n    }\n    else if (n == 3)\n    {\n        array\
    \ = new long[3];\n        array[0] = 1;\n        array[1] = 3;\n        array[2]\
    \ = 2;\n        return array;\n    }\n    else\n    {\n        array = new long[n\
    \ + 1];\n        array[0] = 1;\n        array[1] = 3;\n        array[2] = 2;\n\
    \        for (i = 3; i < n + 1; i++)\n        {\n            if (i % 2 == 0)\n\
    \            {\n                array[i] = (1 + (i / 2));\n            }\n   \
    \         else\n            {\n                k = array[i - 1];\n           \
    \     l = array[i - 2];\n                j = array[i - 3];\n                array[i]\
    \ = k + l + j;\n            }\n        }\n        return array;\n    }\n}", "{\n\
    \    return n < 2 ?\n      new long[]{1L, 3L, 2L, 8L} :\n      new long[]{1L,\
    \ 3L, 2L, 8L}.put(3, tri(n - 1).back + tri(n - 2).back + tri(n + 1).back);\n}",
  "{\n    auto len = n + 1;\n    auto a = new long[len];\n    a[0] = 1;\n    a[1]\
    \ = 3;\n    a[2] = 2;\n    foreach(i; 3..len)\n    {\n        a[i] = a[i - 1]\
    \ + a[i - 2] + a[i - 3];\n    }\n    return a;\n}", "{\n    auto fib = to!(long[])([]);\n\
    \    fib ~= 0;\n    fib ~= 1;\n    fib ~= 1;\n    for(int i = 3; i <= n; i++)\n\
    \    {\n        if(i % 2 == 0)\n        {\n            fib ~= 1 + i / 2;\n   \
    \     }\n        else\n        {\n            fib ~= fib[i - 1] + fib[i - 2] +\
    \ fib[i + 1];\n        }\n    }\n    return fib;\n}\n/*\n    These examples have\
    \ been converted from Python to D. The original examples \n    can be found on\
    \ Codewars.\n*/\nunittest\n{\n    assert(tri(3L) == [1L, 3L, 2L, 8L]);\n    assert(tri(4L)\
    \ == [1L, 3L, 2L, 8L, 13L]);\n    assert(tri(0L) == [1L]);\n    assert(tri(1L)\
    \ == [1L, 3L]);\n    assert(tri(2L) == [1L, 3L, 2L]);\n    assert(tri(11L) ==\
    \ [1L, 3L, 2L, 8L, 13L, 21L, 34L, 55L, 89L, 144L, 233L, 377L]);\n    assert(tri(15L)\
    \ == [1L, 3L, 2L, 8L, 13L, 21L, 34L, 55L, 89L, 144L, 233L, 377L, 610L, 987L, 1597L,\
    \ 2584L]);\n    assert(tri(20L) == [1L, 3L, 2L, 8L, 13L, 21L, 34L, 55L, 89L, 144L,\
    \ 233L, 377L, 610L, 987L, 1597L, 2584L, 4181L, 6765L, 10946L, 17711L, 28657L]);\n\
    \    assert(tri(30L) == [1L, 3L, 2L, 8L, 13L, 21L, 34L, 55L, 89L, 144L, 233L,\
    \ 377L, 610L, 987L, 1597L, 2584", "{\n    int i;\n    long[] myarr;\n    myarr\
    \ = new long[n+1];\n    myarr[0] = 1;\n    myarr[1] = 3;\n    myarr[2] = 2;\n\
    \    for(i = 3; i < n + 1; i++)\n    {\n        if( i % 2 == 0)\n        {\n \
    \           myarr[i] = 1 + i / 2;\n        }\n        else\n        {\n      \
    \      myarr[i] = myarr[i-1] + myarr[i-2] + myarr[i-3];\n        }\n    }\n  \
    \  return myarr;\n}", "{\n    long[] array;\n    if (n <= 1)\n    {\n        array\
    \ = new long[3];\n        array[0] = 1;\n        array[1] = 3;\n        array[2]\
    \ = 2;\n    }\n    else\n    {\n        array = new long[n + 1];\n        array[0]\
    \ = 1;\n        array[1] = 3;\n        array[2] = 2;\n        for (long i = 3;\
    \ i <= n; i++)\n        {\n            if (i % 2 == 0)\n            {\n      \
    \          array[i] = (1 + i / 2);\n            }\n            else\n        \
    \    {\n                array[i] = (array[i - 1] + array[i - 2] + array[i + 1]);\n\
    \            }\n        }\n    }\n    return array;\n}", "{\n    import std.algorithm;\n\
    \    import std.conv;\n    import std.range;\n    if (n == 0) return [1];\n  \
    \  else if (n == 1) return [1, 3];\n    else if (n == 2) return [1, 3, 2];\n \
    \   else\n    {\n        long[] res = [1, 3, 2];\n        long first = 1, second\
    \ = 3, third = 2;\n        foreach (num; 3 .. n)\n        {\n            if (num\
    \ % 2 == 0) res ~= 1 + num / 2;\n            else\n            {\n           \
    \     res ~= first + second + third;\n                first = second;\n      \
    \          second = third;\n                third = res[$ - 1];\n            }\n\
    \        }\n        return res;\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
