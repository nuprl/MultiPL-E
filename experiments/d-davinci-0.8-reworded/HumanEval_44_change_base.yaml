name: HumanEval_44_change_base
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nChange numerical base of input\
  \ number x to base.\n    return string representation after the conversion.\n  \
  \  base numbers are less than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n   \
  \ >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L, 2L)\n    \"111\"\
  \n    \n*/\nstring change_base(long x, long base) \n"
tests: "unittest\n{\n    alias candidate = change_base;\n\n    assert(candidate(8L,\
  \ 3L) == \"22\");\n    assert(candidate(9L, 3L) == \"100\");\n    assert(candidate(234L,\
  \ 2L) == \"11101010\");\n    assert(candidate(16L, 2L) == \"10000\");\n    assert(candidate(8L,\
  \ 2L) == \"1000\");\n    assert(candidate(7L, 2L) == \"111\");\n    assert(candidate(2L,\
  \ 3L) == \"2\");\n    assert(candidate(3L, 4L) == \"3\");\n    assert(candidate(4L,\
  \ 5L) == \"4\");\n    assert(candidate(5L, 6L) == \"5\");\n    assert(candidate(6L,\
  \ 7L) == \"6\");\n    assert(candidate(7L, 8L) == \"7\");\n}\nvoid main(){}"
completions: ["{\n    if (x == 0) \n    {\n        return \"0\";\n    }\n    ulong\
    \ y = x;\n    string s = \"\";\n    while (y != 0) \n    {\n        s = ulong.toString(y\
    \ % base) + s;\n        y /= base;\n    }\n    return s;\n}\n/*\nPrints the digits\
    \ of number x in reverse order.\n    >>> print_reverse(123L)\n    321\n    >>>\
    \ print_reverse(0L)\n    0\n    >>> print_reverse(7L)\n    7\n*/", "{\n    immutable\
    \ data = `0 1 2 3 4 5 6 7 8 9`;\n    // https://github.com/ldc-developers/ldc/issues/1365\n\
    \    // This is a bug of DMD 2.079.1\n    // The following code should be used\
    \ in the future.\n    //string data = \"0123456789\";\n    string res = \"\";\n\
    \    while (x > 0) {\n        res = data[(int)(x % base)] ~ res;\n        x /=\
    \ base;\n    }\n    return res;\n}", "{\n    static string[] digits = [\"0\",\
    \ \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n    string\
    \ y = \"\";\n    while (x > 0) \n    {\n        long remainder = x % base;\n \
    \       y = digits[remainder] ~ y;\n        x = x / base;\n    }\n    return y;\n\
    }\n/*\nreturn whether x is a palindrome number.\n    >>> is_palindrome(10001L)\n\
    \    true\n    >>> is_palindrome(10002L)\n    false\n    >>> is_palindrome(100101L)\n\
    \    true\n*/", "{\n    string output = \"\";\n    // x is positive\n    assert(x\
    \ >= 0);\n    // base is positive\n    assert(base > 0);\n    // base is less\
    \ than 10\n    assert(base < 10);\n    int rem;\n    while (x != 0) {\n      \
    \  rem = x % base;\n        x = x / base;\n        output = std.conv.to!string(rem)\
    \ ~ output;\n    }\n    return output;\n}", "{\n    import std.algorithm : joiner;\n\
    \    alias char[] Clist;\n    Clist result = \"\";\n    while (x > 0) \n    {\n\
    \        long remainder = x % base;\n        result ~= to!string(remainder);\n\
    \        x /= base;\n    }\n    return std.algorithm.joiner(result.reversed).join();\n\
    }", "{\n    string ret = \"\";\n    long r = 0L;\n    for (;x;x/=base)\n    {\n\
    \        r = x % base;\n        ret = std.string.toString(r) ~ ret;\n    }\n \
    \   return ret;\n}", "{\n    string res;\n    while (x != 0) {\n        res =\
    \ stringof(x % base) ~ res;\n        x /= base;\n    }\n    return res;\n}\n/*\n\
    Judge whether a string of number is a magic number.\n    A magic number is a number\
    \ whose digits, \n    with any number of additions, \n    can arrive at the number\
    \ 1.\n    >>> is_magic_number(\"8\")\n    True\n    >>> is_magic_number(\"111\"\
    )\n    True\n    >>> is_magic_number(\"123\")\n    False\n*/", "{\n  const string\n\
    \  get_digit(string[10] digits, long base) pure nothrow @nogc\n  {\n    return\
    \ digits[base];\n  }\n  string [10] digits = [\"0\", \"1\", \"2\", \"3\", \"4\"\
    , \"5\", \"6\", \"7\", \"8\", \"9\"];\n  string result = \"\";\n  immutable long\
    \ max_num = 9L;\n  for (;;) {\n    immutable long index = x % base;\n    result\
    \ = get_digit(digits, index) ~ result;\n    x /= base;\n    if (x <= max_num)\
    \ {\n      result = get_digit(digits, x) ~ result;\n      break;\n    }\n  }\n\
    \  return result;\n}\n/*\nChange list of numerical base of input number x to base.\n\
    \    return tuples of (the-power-of-the-base, remainder)\n    >>> change_base_list(8L,\
    \ 3L)\n    [(0L, 2L), (1L, 2L)]\n    >>> change_base_list(8L, 2L)\n    [(0L, 0L),\
    \ (1L, 0L), (2L, 0L), (3L, 1L)]\n    >>> change_base_list(7L, 2L)\n    [(0L, 1L),\
    \ (1L, 1L), (2L, 1L)]\n*/\nauto change_base_list(long x, long base) \n{\n  typeof(return)\
    \ result;\n  immutable long counter = 0L;\n  for (;;) {\n    immutable long remainder\
    \ = x % base;\n    const typeof(return) item = tuple(counter, remainder);\n  \
    \  result ~= item;\n    x /= base;\n    if (x == 0L) break;\n    counter++;\n\
    \  }\n  return result;\n}\n/*\nCalculate remainder of x, base.\n    return the\
    \ remainder.\n    >>> change_base_remainder(8L, 3L)\n    2L\n    >>> change_base_remainder(8L,\
    \ 2L)\n    0L\n    >>> change_base_remainder(7", "{\n    enum result = [];\n \
    \   while (x > 0) \n    {\n        result ~= x % base;\n        x /= base;\n \
    \   }\n    return to!string(result);\n}", "{\n\tstring s = \"\";\n\twhile (x !=\
    \ 0) \n\t{\n\t\ts = to!string(x % base) ~ s;\n\t\tx /= base;\n\t}\n\treturn s;\n\
    }\n/*\nReturn a list that contains digits of a number x.\n    if base is not zero,\
    \ then it is a base of number x.\n    >>> digits(8L, 10L)\n    [8]\n    >>> digits(8L,\
    \ 3L)\n    [2, 2]\n    >>> digits(7L, 2L)\n    [1, 1, 1]\n    \n*/", "{\n    string\
    \ output;\n    while (x != 0) {\n        output ~= to!string(x % base);\n    \
    \    x /= base;\n    }\n    return output;\n}", "{\n    string _buffer;\n    long\
    \ n;\n    n = x;\n    _buffer = \"\";\n    while (n > 0) {\n        _buffer +=\
    \ to!string(n % base);\n        n /= base;\n    }\n    reverse(_buffer);\n   \
    \ return _buffer;\n}", "{\n    string result = null;\n    while (x != 0) \n  \
    \  {\n        if (x % base < 10) \n        {\n            result = result ~ cast(string)(x\
    \ % base);\n        }\n        else \n        {\n            result = result ~\
    \ cast(string)(x % base - 10 + 'A');\n        }\n        x /= base;\n    }\n \
    \   return std.array.array(result).reverse().idup;\n}", "{\n    enum { width =\
    \ sizeof(long) * 8 };\n    string temp = \"\";\n    long p = 1;\n    for (size_t\
    \ i = 0; i < width; i++) \n    {\n        if ((x & (p << i)) != 0) \n        {\n\
    \            temp = temp ~ '1';\n        } \n        else \n        {\n      \
    \      temp = temp ~ '0';\n        }\n    }\n    temp = temp.idup;\n    temp =\
    \ temp.chomp;\n    auto reversed_temp = temp.dup;\n    while (reversed_temp.length)\
    \ \n    {\n        reversed_temp.popFront;\n    }\n    auto L = array(long)(reversed_temp.length);\n\
    \    foreach (i, c; temp) \n    {\n        if (c == '1') \n        {\n       \
    \     L[i] = 1;\n        }\n        else \n        {\n            L[i] = 0;\n\
    \        }\n    }\n    string ret = \"\";\n    long in = reversed_temp.length\
    \ - 1;\n    while (in >= 0) \n    {\n        long t = 0;\n        for (size_t\
    \ i = 0; i <= in; i++) \n        {\n            t = L[i] * pow(2L, in - i) + t;\n\
    \        }\n        in--;\n        long q = t / base;\n        long r = t % base;\n\
    \        if (t == 0) \n        {\n            break;\n        }\n        ret =\
    \ ret ~ to!string(r);\n        if (in == -1) \n        {\n            break;\n\
    \        }\n        for (size_t i = 0; i <= in; i++) \n        {\n           \
    \ L[i] = q % 2;\n            q = q / 2;\n        }\n    }\n    return ret.dup.idup;\n\
    }\n/*\n    return the absolute value of x.\n    >>> abs_plus(-2L)\n    2\n   \
    \ >>> abs_plus(0L)\n    0\n    >>> abs_plus(4L)\n    4\n*/\nlong abs", "{\n  \
    \  immutable base_index = [0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006,\
    \ 0x0007, 0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F, 0x0010,\
    \ 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001A,\
    \ 0x001B, 0x001C, 0x001D, 0x001E, 0x001F, 0x0020, 0x0021, 0x0022, 0x0023, 0x0024,\
    \ 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E,\
    \ 0x002F, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038,\
    \ 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, 0x0040, 0x0041, 0x0042,\
    \ 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C,\
    \ 0x004D, 0x004E, 0x004F, 0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056,\
    \ 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, 0x0060,\
    \ 0x0061, 0x0062, 0x0063, 0x0064, 0", "    in(0..10)\n{\n    import std.conv;\n\
    \    string result;\n    do\n    {\n        result ~= to!string(x % base);\n \
    \       x /= base;\n    } while (x != 0);\n    return result.reverse;\n}", "{\n\
    \    auto c_digit = (x >= 0 ? [](long x)\n    {\n        return char('0' + x);\n\
    \    } : [](long x)\n    {\n        return char('a' + x - 10);\n    });\n    string\
    \ res;\n    long sign = signbit(x);\n    auto remainder = x;\n    if (sign !=\
    \ 0)\n    {\n        remainder = -x;\n    }\n    do \n    {\n        auto remain\
    \ = remainder % base;\n        remainder /= base;\n        res += c_digit(remain);\n\
    \    } while (remainder > 0);\n    if (sign != 0)\n    {\n        res += '-';\n\
    \    }\n    reverse(res);\n    return res;\n}", "{\n\tenum digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n\tauto n = (cast(string)digits[x % base]).dup;\n\twhile (x /= base)\n\t{\n\t\
    \tn ~= (cast(string)digits[x % base]);\n\t}\n\treturn n.reverse;\n}", "{\n   \
    \ char[32] result; // size to hold 32 digits of a 32-bit integer.\n    int y =\
    \ 0; // counter to iterate through the array.\n    for (; x > 0; ++y) \n    {\n\
    \        result[y] = to!char('0' + x % base);\n        x /= base;\n    }\n   \
    \ return result[0..y].idup.reverse;\n}\n/*\nConvert input number (hex string)\
    \ to decimal string representation.\n    >>> hex_to_dec(\"FF\")\n    \"255\"\n\
    \    >>> hex_to_dec(\"FFFFFFF0\")\n    \"4294967280\"\n    >>> hex_to_dec(\"10\"\
    )\n    \"16\"\n    >>> hex_to_dec(\"\")\n    \"0\"\n*/\nstring hex_to_dec(string\
    \ hex) \n{\n    enum hex_index = [ \n\t\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"\
    , \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"\n    ];\n\
    \    long result = 0;\n    for (int i = 0; i < hex.length; ++i) \n    {\n    \
    \    int j = hex_index.indexOf(hex[i]);\n        result += j * (16 ** (hex.length\
    \ - i - 1));\n    }\n    return result.to!string;\n}\n/*\nConvert input number\
    \ (decimal string) to hex string representation.\n    >>> dec_to_hex(\"255\")\n\
    \    \"FF\"\n    >>> dec_to_hex(\"4294967280\")\n    \"FFFFFFF0\"\n    >>> dec_to_hex(\"\
    16\")\n    \"10\"\n    >>> dec_to_hex(\"0\")\n    \"0\"\n    >>> dec_to_hex(\"\
    -255\")\n    \"-FF\"\n*/\nstring dec_to_hex(string dec) \n{\n    long long x =\
    \ to!long(dec);\n    if (x < 0) \n    {\n        x = -x;\n        return \"-\"\
    \ ~ change_base(x, 16);\n    }\n    return change_", "{\n    return base != 10\
    \ ? format(\"%s\", x.change_base(base)) :\n        format(\"%s\", x);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
