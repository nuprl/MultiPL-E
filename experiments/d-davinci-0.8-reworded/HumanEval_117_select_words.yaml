name: HumanEval_117_select_words
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nGiven a string s and a natural\
  \ number n, you have been tasked to implement \n    a function that returns an array\
  \ of all words from string s that contain exactly \n    n consonants, in order these\
  \ words appear in the string s.\n    If the string s is empty then the function\
  \ should return an empty array.\n    Note: you may assume the input string contains\
  \ only letters and spaces.\n    Examples:\n    >>> select_words(\"Mary had a little\
  \ lamb\", 4L)\n    [\"little\"]\n    >>> select_words(\"Mary had a little lamb\"\
  , 3L)\n    [\"Mary\", \"lamb\"]\n    >>> select_words(\"simple white space\", 2L)\n\
  \    []\n    >>> select_words(\"Hello world\", 4L)\n    [\"world\"]\n    >>> select_words(\"\
  Uncle sam\", 3L)\n    [\"Uncle\"]\n    \n*/\nstring[] select_words(string s, long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = select_words;\n\n    assert(candidate(\"\
  Mary had a little lamb\", 4L) == [\"little\"]);\n    assert(candidate(\"Mary had\
  \ a little lamb\", 3L) == [\"Mary\", \"lamb\"]);\n    assert(candidate(\"simple\
  \ white space\", 2L) == []);\n    assert(candidate(\"Hello world\", 4L) == [\"world\"\
  ]);\n    assert(candidate(\"Uncle sam\", 3L) == [\"Uncle\"]);\n    assert(candidate(\"\
  \", 4L) == []);\n    assert(candidate(\"a b c d e f\", 1L) == [\"b\", \"c\", \"\
  d\", \"f\"]);\n}\nvoid main(){}"
completions: ["{\n    string[] arr;\n    if (s.length == 0) \n    {\n        return\
    \ [];\n    }\n    foreach (word; split(s)) \n    {\n        int count = 0;\n \
    \       foreach (letter; word) \n        {\n            if (letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u') \n            {\n\
    \                count += 1;\n            }\n        }\n        if (word.length\
    \ - count == n) \n        {\n            arr ~= word;\n        }\n    }\n    return\
    \ arr;\n}", "{\n\tstring[] splitted = s.split(\" \");\n\tchar[] vowels = {'a',\
    \ 'e', 'i', 'o', 'u', 'y'};\n\tint vowelsCnt = 0;\n\tint consonantsCnt = 0;\n\t\
    int length = 0;\n\tforeach(string word; splitted)\n\t{\n\t\tconsonantsCnt = 0;\n\
    \t\tvowelsCnt = 0;\n\t\tforeach(char c; word)\n\t\t{\n\t\t\tlength = vowels.length;\n\
    \t\t\tforeach(int i = 0; i < length; i++)\n\t\t\t{\n\t\t\t\tif(vowels[i] == c.tolower())\n\
    \t\t\t\t{\n\t\t\t\t\tvowelsCnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconsonantsCnt\
    \ = word.length - vowelsCnt;\n\t\tif(consonantsCnt == n)\n\t\t{\n\t\t\treturn\
    \ [word];\n\t\t}\n\t}\n\treturn [];\n}", "{\n    auto ret = new string[];\n  \
    \  auto ss = s.split(\" \");\n    foreach(i, ss) {\n        //std.stdio.writeln(i);\n\
    \        if(consonants(i) == n)\n            ret ~= i;\n    }\n    return ret;\n\
    }\nlong consonants(string s) \n{\n    import std.range;\n    return s.filter!(a\
    \ => \"aeiouyAEIOUY\".count(a.to!char) == 0).length;\n}\n/*\n// some tests for\
    \ consonants\nunittest\n{\n    //std.stdio.writeln(consonants(\"world\"));\n \
    \   assert(consonants(\"world\") == 3);\n    assert(consonants(\"Mary\") == 2);\n\
    \    assert(consonants(\"Uncle\") == 3);\n    assert(consonants(\"Hello\") ==\
    \ 3);\n    assert(consonants(\"sam\") == 2);\n    assert(consonants(\"little\"\
    ) == 3);\n    assert(consonants(\"lamb\") == 1);\n    assert(consonants(\"\")\
    \ == 0);\n}\n*/\n/*\nunittest\n{\n    assert(select_words(\"Mary had a little\
    \ lamb\", 4L) == [\"little\"]);\n    assert(select_words(\"Mary had a little lamb\"\
    , 3L) == [\"Mary\", \"lamb\"]);\n    assert(select_words(\"simple white space\"\
    , 2L) == []);\n    assert(select_words(\"Hello world\", 4L) == [\"world\"]);\n\
    \    assert(select_words(\"Uncle sam\", 3L) == [\"Uncle\"]);\n}\n*/", "{\n   \
    \ // write your code here\n    auto ret = [\"\"];\n    ret = [];\n    foreach(word;\
    \ s.split)\n    {\n        long count = 0;\n        foreach(char; word)\n    \
    \    {\n            if (char.isUpper())\n            {\n                count++;\n\
    \            }\n        }\n        if (count == n)\n        {\n            ret\
    \ ~= word;\n        }\n    }\n    return ret;\n}\n \n void main()\n {\n    auto\
    \ str = \"Mary had a little lamb\";\n    auto n = 4L;\n    auto str2 = \"simple\
    \ white space\";\n    auto str3 = \"Hello world\";\n    auto str4 = \"Uncle sam\"\
    ;\n    auto result = select_words(str, n);\n    auto result2 = select_words(str2,\
    \ 2L);\n    auto result3 = select_words(str3, 4L);\n    auto result4 = select_words(str4,\
    \ 3L);\n    writeln(result);\n    writeln(result2);\n    writeln(result3);\n \
    \   writeln(result4);\n }", "{\n    string[] arr;\n    string[] cons = [\"b\"\
    , \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"];\n    auto sp = s.split(\"\
    \ \");\n    foreach(word; sp) \n    {\n        int cons_count = 0;\n        foreach(letter;\
    \ word) \n        {\n            if(letter.toLower() in cons) \n            {\n\
    \                cons_count++;\n            }\n        }\n        if(cons_count\
    \ == n) \n        {\n            arr ~= word;\n        }\n    }\n    return arr;\n\
    }", "{ \n    string[] words;\n    words = split(s, \" \");\n    int len = words.length;\n\
    \    int count = 0;\n    int[] result;\n    string[] out;\n    foreach(i, word;\
    \ words)\n    {\n        count = 0;\n        foreach(j, char; word)\n        {\n\
    \            if (char == 'a' || char == 'e' || char == 'i' || char == 'o' || char\
    \ == 'u')\n            {\n                count++;\n            }\n        }\n\
    \        if (count == n)\n        {\n            result ~= i;\n        }\n   \
    \ }\n    foreach(k, num; result)\n    {\n        out ~= words[num];\n    }\n \
    \   return out;\n}", "{\n  import std.array : split;\n  import std.conv : to;\n\
    \  string[] stringArray = s.split(\" \");\n  string[] result = [];\n  foreach(string\
    \ item; stringArray) \n  {\n      long numberOfConsonants = 0;\n      string vowels\
    \ = \"aeiouAEIOU\";\n      foreach(char letter; item) \n      {\n        if(vowels.indexOf(letter)\
    \ == -1) \n          ++numberOfConsonants;\n      }\n      if(numberOfConsonants\
    \ == n) \n        result ~= item;\n  }\n  return result;\n}", "{\n    auto words\
    \ = std.algorithm.split(s, std.predicate!((c) => c == ' '));\n    return words.filter!((w)\
    \ => w.filter!((c) => c.isConsonant).length == n).array;\n}", "{\n    int[] result;\n\
    \    immutable(string)[] words = split(s);\n    // immutable(string)[] words =\
    \ s.split();\n    foreach(immutable(string) word; words)\n    {\n        int sum\
    \ = 0;\n        foreach(immutable(char) c; word)\n        {\n            bool\
    \ isVowel = (\n                c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u'\n            );\n            if (!isVowel)\n            {\n       \
    \         sum++;\n            }\n        }\n        if (sum == n)\n        {\n\
    \            result ~= word;\n        }\n    }\n    return result;\n}", "{\n \
    \   string[] arr = split(s, \" \");\n    immutable(string)[] result = [];\n  \
    \  foreach(it;arr)\n    {\n        if(count(it) == n) result ~= it;\n    }\n \
    \   return result;\n}\nlong count(string s)\n{\n    long consonants = 0;\n   \
    \ foreach(it;s)\n    {\n        if(!isVowel(it)) consonants++;\n    }\n    return\
    \ consonants;\n}", "{\n    return split(s,\" \").filter!(i => numConsonants(i)\
    \ == n).array;\n}", "{\n    enum vowels = \"aeiouAEIOU\";\n    string[] result;\n\
    \    if(s.empty) {\n        return result;\n    }\n    else {\n        string[]\
    \ words = s.split;\n        foreach(word; words) {\n            long count = 0;\n\
    \            foreach(ch; word) {\n                count += vowels.indexOf(ch)\
    \ == -1 ? 1 : 0;\n            }\n            if(count == n) {\n              \
    \  result ~= word;\n            }\n        }\n        return result;\n    }\n\
    }\n/*\n    Calling a function is given a list of std.typecons.Tuple!(long, long)\
    \ coordinates \n    and std.math.Matrix!doubles matrix you have to implement a\
    \ function that \n    returns a value at a matrix element, specified by given\
    \ coordinates. \n    Your function should throw an exception if the coordinates\
    \ are out of range.\n    Example:\n    >>> matrix = [\n            [1, 2, 3],\n\
    \            [4, 5, 6],\n            [7, 8, 9]\n        ];\n    >>> coordinates\
    \ = [\n            Tuple!(long, long)(0, 0),\n            Tuple!(long, long)(1,\
    \ 2),\n            Tuple!(long, long)(2, 2)\n        ];\n    >>> get_elements_at_coordinates(coordinates,\
    \ matrix)\n    [1, 6, 9]\n*/", "{\n    string[] words = split(s);\n    auto res\
    \ = words.filter!(a => getConsonantsCount(a) == n);\n    return res;\n}", "{ \n\
    \  int count;\n  string[] words = split(s);\n  string[] ret;\n  foreach(string\
    \ word; words)\n  {\n    count = 0;\n    foreach(char c; word)\n    {\n      switch(c)\n\
    \      {\n        case 'a':\n        case 'e':\n        case 'i':\n        case\
    \ 'o':\n        case 'u':\n        case 'A':\n        case 'E':\n        case\
    \ 'I':\n        case 'O':\n        case 'U':\n          continue;\n        default:\n\
    \          count++;\n      }\n    }\n    if(count == n)\n      ret ~= word;\n\
    \  }\n  return ret;\n}\n ", "{\n    string[] c = s.split();\n    int consonants_count;\n\
    \    string[] arr;\n    foreach(string word; c) {\n        consonants_count =\
    \ 0;\n        foreach(char ch; word) {\n            if (ch in ['a', 'e', 'i',\
    \ 'o', 'u', 'y']) {\n                ++consonants_count;\n            }\n    \
    \    }\n        if (consonants_count == n) {\n            arr ~= word;\n     \
    \   }\n    }\n    return arr;\n}", "{\n    string[] words = s.split;\n    //string[]\
    \ cons;\n    string[] cons = new string[words.length];\n    int k = 0;\n    foreach(char\
    \ c; words)\n    {\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n        {\n            cons[k] = c;\n            k++;\n        }\n\
    \        else\n        {\n            continue;\n        }\n    }\n    return\
    \ cons;\n}", "{\n    assert(n > 0L);\n    auto words = split(s, ' ');\n    return\
    \ words.filter!(w => w.count!(c => \"aeiouAEIOU\".count(c) == 0) == n);\n}", "{\n\
    \    string[] arr = split(s);\n    string[] res;\n    res.length = 0;\n    foreach(string\
    \ i; arr)\n    {\n        if(consonants_in_string(i) == n)\n        {\n      \
    \      res ~= i;\n        }\n    }\n    return res;\n}\n/*\n    Given a string\
    \ s, return a lowercased string, \n    where all occurrences of the upper case\
    \ letter have been replaced with the lower case version.\n*/\nstring lowercase(string\
    \ s)\n{\n    auto arr = toLower(s);\n    string res;\n    foreach(char i; arr)\n\
    \    {\n        res ~= i;\n    }\n    return res;\n}\n/*\n    Given a string s\
    \ and an array of pairs of indices in the string, \n    return the string with\
    \ all characters in the indices [i, j] replaced by the character at j index.\n\
    \    Examples:\n    >>> replace_indices(\"abacaba\", [[3, 4], [4, 2], [4, 6]])\n\
    \    \"abacacb\"\n    >>> replace_indices(\"a\", [[0, 0], [0, 0]])\n    \"a\"\n\
    \    >>> replace_indices(\"abacaba\", [[0, 1], [0, 1]])\n    \"bacaba\"\n    >>>\
    \ replace_indices(\"abacaba\", [[4, 4], [3, 4]])\n    \"abacaca\"\n*/\nstring\
    \ replace_indices(string s, int[][] indices)\n{\n    string res;\n    foreach(i;\
    \ indices)\n    {\n        s[i[0]] = s[i[1]];\n    }\n    return s;\n}\n/*\n \
    \   Given a string s, return a string where all occurrences of its first char\
    \ have been changed to '*', except do not change the first char itself.\n    You\
    \ may assume that the string is length 1 or more.\n    Examples:\n    >>> fix_start(\"\
    babble\")\n    \"ba**le\"\n    >>> fix_start(\"google\")\n    \"goo*le\"\n   \
    \ >>> fix_start(\"donut\")\n    \"donut\"\n*/\nstring", "{\n    string[] words\
    \ = split(s, \" \");\n    string[] result;\n    foreach(ref string word; words)\n\
    \    {\n        if(countConsonants(word) == n)\n        {\n            result\
    \ ~= word;\n        }\n    }\n    return result;\n}\nlong countConsonants(string\
    \ s)\n{\n    long result = 0;\n    foreach(char c; s)\n    {\n        if(isConsonant(c))\n\
    \        {\n            result += 1;\n        }\n    }\n    return result;\n}",
  "{\n    return filter!(a => countConsonants(a) == n)(split(s, \" \")).array;\n}",
  "{\n    string[] res = null;\n    string[] words = split(s, \" \");\n    foreach(word;\
    \ words)\n    {\n        long consonants = count_consonants(word);\n        if(consonants\
    \ == n)\n        {\n            if(res == null)\n            {\n             \
    \   res = new string[];\n            }\n            res ~= word;\n        }\n\
    \    }\n    return res;\n}\nlong count_consonants(string s)\n{\n    long res =\
    \ 0;\n    foreach(l; s)\n    {\n        char ch = l.toLower();\n        if(!(ch\
    \ == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'))\n        {\n  \
    \          res += 1;\n        }\n    }\n    return res;\n}\n/*\nGiven a natural\
    \ number n, you have been tasked to implement a function \n    that returns an\
    \ array of all positive numbers less than or equal to n, \n    sorted in ascending\
    \ order.\n    Examples:\n    >>> find_numbers(1L)\n    [1]\n    >>> find_numbers(3L)\n\
    \    [1, 2, 3]\n    >>> find_numbers(6L)\n    [1, 2, 3, 4, 5, 6]\n    >>> find_numbers(10L)\n\
    \    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n*/\nlong[] find_numbers(long n)\n{\n   \
    \ long[] res = new long[];\n    for(long i = 1; i <= n; i++)\n    {\n        res\
    \ ~= i;\n    }\n    return res;\n}\n/*\nGiven a natural number n, you have been\
    \ tasked to implement a function \n    that returns an array of all natural numbers\
    \ that are less than or equal to n, \n    sorted in ascending order, with the\
    \ exception of the number 13, which should not be included in the array.\n   \
    \ Examples:\n    >>> find_numbers_without_13(1L)\n    [1]\n    >>> find_numbers_without_13(3L)\n\
    \    [1", "{\n    string[] result = [];\n    int[] consonants = {'b', 'c', 'd',\
    \ 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'z'};\n    string[] words = split(s, ' ');\n    foreach(string word; words)\n\
    \    {\n        auto word_chars = filter!(ch => ch.isalpha)(word);\n        if(count!(consonant\
    \ => in(consonant, consonants))(word_chars) == n)\n        {\n            result\
    \ ~= word;\n        }\n    }\n    return result;\n}", "{\n    string[] words =\
    \ split(s);\n    auto ret = appender!(string[])();\n    foreach(word; words)\n\
    \    {\n        if(n_consonants(word) == n)\n            ret.put(word);\n    }\n\
    \    return ret.data;\n}", "{\n\tauto result =  new string[];\n\tauto words =\
    \ split(s);\n\tforeach(word; words)\n\t{\n\t\tauto vowels = \"aeiouAEIOU\";\n\t\
    \tauto consonants = new long[word.length];\n\t\tforeach(i, ch; word)\n\t\t{\n\t\
    \t\tif(!vowels.canFind(ch))\n\t\t\t\tconsonants[i] = 1;\n\t\t}\n\t\tif(sum(consonants)\
    \ == n)\n\t\t\tresult ~= word;\n\t}\n\treturn result;\n}\n/*\nA student attending\
    \ Programming Fundamentals course in SoftUni\n wants to create a program that\
    \ will calculate the final grade \n of every assignment he has done throughout\
    \ the year. \n The student knows that the final grade for an assignment \n should\
    \ be calculated according to the following table:", "{\n    string[] words = split(s);\n\
    \    string[] result;\n    foreach(string word; words)\n    {\n        immutable\
    \ long consonants = word.count!(!vowel);\n        if(consonants == n)\n      \
    \  {\n            result ~= word;\n        }\n    }\n    return result;\n}", "{\n\
    \    string[] words;\n    int index = 0;\n    foreach(w; split(s))\n    {\n  \
    \      long count = 0;\n        foreach(c; w)\n        {\n            if(c !=\
    \ 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') count++;\n        }\n \
    \       if(count == n)\n        {\n            words ~= w;\n        }\n    }\n\
    \    return words;\n}", "{\n    auto words = s.split;\n    string[] res;\n   \
    \ foreach(word; words)\n    {\n        if(word.filter!c => !\"aeiou\".canFind(c)).length\
    \ == n)\n            res ~= word;\n    }\n    return res;\n}", "{\n    string[]\
    \ arr;\n    string[] result;\n    int count;\n    int i;\n    long idx;\n    int\
    \ size;\n    string word;\n    if(s.length == 0)\n    {\n        return [];\n\
    \    }\n    else\n    {\n        arr = split(s, \" \");\n        foreach(word;\
    \ arr)\n        {\n            count = 0;\n            size = word.length;\n \
    \           foreach(i; 0..size)\n            {\n                idx = to!long(s[i]);\n\
    \                if(idx > 98 && idx < 123)\n                {\n              \
    \      count++;\n                }\n            }\n            if(count == n)\n\
    \            {\n                result ~= word;\n            }\n        }\n  \
    \      return result;\n    }\n}", "{\n    string[] words = s.split();\n    string[]\
    \ res;\n    foreach(word; words)\n    {\n        int cons = 0;\n        foreach(l;\
    \ word)\n        {\n            if(l == 'a' || l == 'e' || l == 'i' || l == 'o'\
    \ || l == 'u')\n            {\n                cons++;\n            }\n      \
    \  }\n        if(cons == n)\n        {\n            res ~= word;\n        }\n\
    \    }\n    return res;\n}", "{\n    import std.container;\n    string[] words\
    \ = s.split(\" \");\n    string[] words_with_n_consonants;\n    foreach(word;\
    \ words)\n    {\n        int count = 0;\n        foreach(char c; word)\n     \
    \   {\n            if(c != 'a' || c != 'e' || c != 'i' || c != 'o' || c != 'u')\n\
    \            {\n                count++;\n            }\n        }\n        if(count\
    \ == n)\n        {\n            append(words_with_n_consonants, word);\n     \
    \   }\n    }\n    return words_with_n_consonants;\n}", "{\n    string[] words\
    \ = split(s);", "{\n    int vowels = 0;\n    int consonants = 0;\n    int letters\
    \ = 0;\n    s = s.toLower();\n    string[] words = s.split();\n    string[] result;\n\
    \    foreach(element; words)\n    {\n        string word = element;\n        foreach(char;\
    \ word)\n        {\n            switch(char)\n            {\n                case\
    \ 'a':\n                case 'e':\n                case 'i':\n               \
    \ case 'o':\n                case 'u':\n                    vowels++;\n      \
    \              break;\n                default:\n                    consonants++;\n\
    \                    break;\n            }\n        }\n        if(consonants ==\
    \ n)\n        {\n            result ~= word;\n        }\n        letters = vowels\
    \ + consonants;\n        consonants = 0;\n        vowels = 0;\n    }\n    return\
    \ result;\n}\n// vim: set sw=4 ts=4 ft=d:", "{ \n    \n    import std.array;\n\
    \    import std.conv;\n    import std.range;\n    import std.string;\n    import\
    \ std.algorithm;\n    import std.stdio;\n    import std.traits;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.ascii;\n    import std.array;\n   \
    \ import std.conv;\n    import std.range;\n    import std.string;\n    import\
    \ std.algorithm;\n    import std.stdio;\n    import std.traits;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.ascii;\n    import std.array;\n   \
    \ import std.conv;\n    import std.range;\n    import std.string;\n    import\
    \ std.algorithm;\n    import std.stdio;\n    import std.traits;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.ascii;\n    import std.array;\n   \
    \ import std.conv;\n    import std.range;\n    import std.string;\n    import\
    \ std.algorithm;\n    import std.stdio;\n    import std.traits;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.ascii;\n    import std.array;\n   \
    \ import std.conv;\n    import std.range;\n    import std.string;\n    import\
    \ std.algorithm;\n    import std.stdio;\n    import std.traits;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.ascii;\n    import std.array;\n   \
    \ import std.conv;\n    import std.range;\n    import std.string;\n    import\
    \ std.algorithm;\n    import std.stdio;\n    import std.traits;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.ascii;\n    import std.array;\n   \
    \ import std.conv;\n    import std.range;\n    import std.string;\n    import\
    \ std.algorithm;\n    import std.stdio;\n    import std.traits", "{\n    string[]\
    \ result = new string[];\n    string[] words = s.split(\" \");\n    foreach(string\
    \ word; words)\n    {\n        long count = 0;\n        foreach(immutable(char)\
    \ letter; word)\n        {\n            if(isConsonant(letter))\n            {\n\
    \                count++;\n            }\n        }\n        if(count == n)\n\
    \        {\n            result ~= word;\n        }\n    }\n    return result;\n\
    }", "{\n    const string vowels = \"aeiou\";\n    auto ls = split(s, ' ');\n \
    \   string[] result;\n    foreach(string word; ls)\n    {\n        int count =\
    \ 0;\n        auto lw = to!string(word);\n        foreach(char c; lw)\n      \
    \  {\n            if(vowels.indexOf(c) == -1)\n                count++;\n    \
    \    }\n        if(count == n)\n            result ~= word;\n    }\n    return\
    \ result;\n}", "{\n    long len = s.length();\n    int[] letters = new int[len];\n\
    \    long count = 0;\n    string[] result = null;\n    for (int i = 0; i < len;\
    \ i++)\n    {\n        if (('A' <= s[i] && s[i] <= 'Z') || ('a' <= s[i] && s[i]\
    \ <= 'z'))\n        {\n            letters[count] = i;\n            count++;\n\
    \        }\n    }\n    letters = letters[0..count];\n    auto words = s.split(\"\
    \ \");\n    count = 0;\n    foreach (word; words)\n    {\n        int lCount =\
    \ 0;\n        foreach (i; word)\n        {\n            if (i != 'a' && i != 'e'\
    \ && i != 'i' && i != 'o' && i != 'u' && i != 'A' && i != 'E' && i != 'I' && i\
    \ != 'O' && i != 'U')\n            {\n                lCount++;\n            }\n\
    \        }\n        if (lCount == n)\n        {\n            count++;\n      \
    \  }\n    }\n    result = new string[count];\n    count = 0;\n    foreach (word;\
    \ words)\n    {\n        int lCount = 0;\n        foreach (i; word)\n        {\n\
    \            if (i != 'a' && i != 'e' && i != 'i' && i != 'o' && i != 'u' && i\
    \ != 'A' && i != 'E' && i != 'I' && i != 'O' && i != 'U')\n            {\n   \
    \             lCount++;\n            }\n        }\n        if (lCount == n)\n\
    \        {\n            result[count] = word;\n            count++;\n        }\n\
    \    }\n    return result;\n}", "{\n    string[] words = s.split(\" \");\n   \
    \ string[] filteredWords = [];\n    foreach(word; words)\n    {\n        if(word.length\
    \ > 0)\n        {\n            size_t count = 0;\n            foreach(char c;\
    \ word)\n            {\n                if(c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u')\n                {\n                    count++;\n   \
    \             }\n            }\n            if(word.length - count == n)\n   \
    \         {\n                filteredWords ~= word;\n            }\n        }\n\
    \    }\n    return filteredWords;\n}\n/*\n    Implement a function called sorted_by_word_length\
    \ that takes an array of strings \n    and returns the array sorted by the length\
    \ of each word in alphabetical order.\n    If two words have the same length,\
    \ order them by the alphabetical order.\n    For example:\n    >>> sorted_by_word_length([\"\
    Hello\", \"Bye\", \"Max\"])\n    [\"Bye\", \"Max\", \"Hello\"]\n    >>> sorted_by_word_length([\"\
    Test\", \"Hello\", \"Bye\", \"Max\"])\n    [\"Bye\", \"Max\", \"Test\", \"Hello\"\
    ]\n*/\nstring[] sorted_by_word_length(string[] s) \n{\n    string[] final = [];\n\
    \    size_t max = 0;\n    foreach(string word; s)\n    {\n        if(word.length\
    \ > max)\n        {\n            max = word.length;\n        }\n    }\n    final\
    \ = new string[max + 1];\n    foreach(string word; s)\n    {\n        if(final[word.length]\
    \ == \"\")\n        {\n            final[word.length] = word;\n        }\n   \
    \     else\n        {\n            if(word[0] < final[word.length][0])\n     \
    \       {\n                final[word.length] = word ~ \" \" ~ final[word.length];\n\
    \            }\n            else\n            {\n                final[word.length]\
    \ = final[word.length] ~ \" \" ~ word;\n            }\n        }\n    }\n    final\
    \ = final", "{\n    auto lst = Appender!(string[])();\n    string[] words = s.split();\n\
    \    foreach(word; words) {\n        if(word.countChar('a', 'e', 'i', 'o', 'u')\
    \ == n) {\n            lst.put(word);\n        }\n    }\n    return lst.data;\n\
    }\n//test", "{\n  string[] words = split(s);\n  string[] newArray;\n  for(int\
    \ i = 0; i < words.length; i++)\n  {\n    if(!(words[i].length < n)){\n      if(((words[i].length\
    \ - length(filter!(\"AEIOUaeiou\".contains)(words[i])))) == n)\n      {\n    \
    \    newArray ~= words[i];\n      }\n    }\n  }\n  return newArray;\n}", "{\n\
    \    static string[] vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    static\
    \ string[] words;\n    foreach(word; words)\n    {\n        uint nconsonants =\
    \ 0;\n        foreach(letter; word)\n        {\n            if(vowels.count(letter)\
    \ == 0)\n            {\n                nconsonants++;\n            }\n      \
    \  }\n        if(nconsonants == n)\n        {\n            yield word;\n     \
    \   }\n    }\n}", "{\n    \n    const string vowels = \"aeiouAEIOU\";\n    //string[]\
    \ words;\n    string[] words = [];\n    while(s.length > 0)\n    {\n        //cut\
    \ words\n        auto token = s.chompLeftWhitespace();\n        token = token.chompLeft(token.findFirstNotOf(\"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n        s = s.dropOne.drop(token.length);\n\
    \        auto consonants = token.count(c => !vowels.canFind(c));\n        if(consonants\
    \ == n)\n        {\n            words ~= token;\n        }\n    }\n    return\
    \ words;\n}\n/*\n    >>> select_words(\"Mary had a little lamb\", 4L)\n    [\"\
    little\"]\n    >>> select_words(\"Mary had a little lamb\", 3L)\n    [\"Mary\"\
    , \"lamb\"]\n    >>> select_words(\"simple white space\", 2L)\n    []\n    >>>\
    \ select_words(\"Hello world\", 4L)\n    [\"world\"]\n    >>> select_words(\"\
    Uncle sam\", 3L)\n    [\"Uncle\"]\n*/\n//For reference. Do not remove.", "{\n\
    \    string[] words = split(s, \" \");\n    string[] result;\n    for(int i =\
    \ 0; i < words.length; i++)\n    {\n        string word = words[i];\n        bool\
    \ isVowel(in char c) \n        {\n            switch(toLower(c))\n           \
    \ {\n                case 'a':\n                case 'e':\n                case\
    \ 'i':\n                case 'o':\n                case 'u':\n               \
    \     return true;\n                default:\n                    return false;\n\
    \            }\n        }\n        long numConsonants = 0;\n        foreach(c;\
    \ word)\n        {\n            if(!isVowel(c))\n            {\n             \
    \   numConsonants++;\n            }\n        }\n        if(numConsonants == n)\n\
    \        {\n            result ~= word;\n        }\n    }\n    return result;\n\
    }", "{\n    string[] words = split(s, \" \");\n    immutable wordsCount = words.length;\n\
    \    string[] result;\n    foreach(int i; 0..wordsCount)\n    {\n        if(countConsonants(words[i])\
    \ == n)\n        {\n            result ~= words[i];\n        }\n    }\n    return\
    \ result;\n}", "{ \n    bool isVowel(char c) {\n        string vowels = \"aeiouAEIOU\"\
    ;\n        return vowels.canFind(c);\n    }\n    // version 1\n    auto words\
    \ = split(s, ' ');\n    words = filter!(w => w.length - w.filter!(c => isVowel(c)).length\
    \ == n)(words);\n    return words;\n    \n    // version 2\n    // return split(s,\
    \ ' ').filter!(w => w.length - w.filter!(c => isVowel(c)).length == n).array;\n\
    }", "{\n    string[] words = s.split;\n    string[] selected = new string[0];\n\
    \    //putting all the strings that match the parameter into an array\n    foreach(word;\
    \ words)\n    {\n        if(word.countConsonants == n)\n        {\n          \
    \  selected ~= word;\n        }\n    }\n    return selected;\n}", "{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.range;\n    import std.conv;\n\
    \    import std.functional;\n    import std.range;\n    import std.typecons;\n\
    \    import std.algorithm;\n    import std.stdio;\n    import std.typecons;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.math;\n    import\
    \ std.typecons;\n    enum vowels = \"aeiou\";\n    string[] words = s.split(\"\
    \ \");\n    auto result = words.filter!(word => word.\n        filter!(c => c.toLower().canFind(vowels)).length\
    \ == n).array;\n    return result;\n}\n/*\nGiven a natural number n, you have\
    \ been tasked to implement a function that\n    returns the count of all numbers\
    \ from 1 to n inclusive that are divisible by 2\n    or divisible by 3.\n    Examples:\n\
    \    >>> count_numbers(3L)\n    3\n    >>> count_numbers(5L)\n    4\n    >>> count_numbers(10L)\n\
    \    7\n    >>> count_numbers(15L)\n    9\n    >>> count_numbers(100L)\n    49\n\
    */\nlong count_numbers(long n) \n{\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.functional;\n   \
    \ import std.range;\n    import std.typecons;\n    import std.algorithm;\n   \
    \ import std.stdio;\n    import std.typecons;\n    import std.algorithm;\n   \
    \ import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.bitmanip;\n    alias selector = bool function(int);\n    selector p1 = (x\
    \ => x % 2 == 0);\n    selector p2 = (x => x % 3 == 0);\n    auto is_divisible\
    \ = (x => (p1(x) || p2(x)));\n    auto count = iota(1, n + 1).filter!is_divisible.count;\n",
  "{\n    string[] words = s.split(\" \");\n    return words.filter!(x => x.countConsonants\
    \ == n).array;\n}\n//", "{\n    string[] words;\n    words = split(s);\n    string[]\
    \ result;\n    for(int i = 0; i < words.length; i++)\n    {\n        if(countConsonants(words[i])\
    \ == n)\n        {\n            result ~= words[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n    return s.split.filter!(w => n == countConsonants(w))();\n\
    }", "{\n    // Write your code here\n    int count;\n    string[] result;\n  \
    \  string[] words = s.split();\n    foreach(item; words)\n    {\n        count\
    \ = 0;\n        foreach(i; item)\n        {\n            if(i == 'a' || i == 'e'\
    \ || i == 'i' || i == 'o' || i == 'u')\n            {\n                continue;\n\
    \            }\n            else\n            {\n                count++;\n  \
    \          }\n        }\n        if(count == n)\n        {\n            result\
    \ ~= item;\n        }\n    }\n    return result;\n}", "{\n    long cons = 0;\n\
    \    string[] res = [];\n    auto tmp = split(s);\n    foreach(i; 0 .. tmp.length)\n\
    \    {\n        foreach(j; 0 .. tmp[i].length)\n        {\n            if(tmp[i][j]\
    \ != 'a' && tmp[i][j] != 'e' && tmp[i][j] != 'i' && tmp[i][j] != 'o' && tmp[i][j]\
    \ != 'u')\n            {\n                cons++;\n            }\n        }\n\
    \        if(cons == n)\n        {\n            res ~= tmp[i];\n        }\n   \
    \     cons = 0;\n    }\n    return res;\n}", "{\n    // write your code here\n\
    \    // we are going to use a couple of libraries\n    import std.algorithm;\n\
    \    import std.string;\n    import std.format;\n    // create a list of the consonants\n\
    \    auto consonants = \"bcdfghjklmnpqrstvwxyz\";\n    // check to see if string\
    \ is empty\n    if (s.empty)\n    {\n        return [];\n    }\n    else \n  \
    \  {\n        // split the string into words\n        auto words = s.split(' ');\n\
    \        // create an array\n        string[] myArray;\n        // loop through\
    \ the words in the array\n        foreach (word; words)\n        {\n         \
    \   // check the number of consonants in the word\n            auto consonant_count\
    \ = word.count !(c => consonants.canFind(c));\n            // add the word if\
    \ it contains the same number of consonants\n            if (consonant_count ==\
    \ n)\n            {\n                myArray ~= word;\n            }\n       \
    \ }\n        return myArray;\n    }\n}", "{\n    import std.regex : regex, substitute,\
    \ regexMatch;\n    auto regex_str = regex(\"[^a-zA-Z]\");\n    string words =\
    \ substitute(s, regex_str, \" \");\n    string[] words_arr = words.split(\" \"\
    );\n    import std.algorithm;\n    import std.range;\n    return words_arr.filter!(w\
    \ => w.countUntil(\"[aeiouAEIOU]\") == n).array;\n}", "{\n    return filter!(word\
    \ => countConsonants(word) == n)\n              (split(s.toLower(), \" \")\n \
    \              .filter!(word => word.length > 0)\n               .map!(word =>\
    \ word.replace(\".\", \"\")\n                                 .replace(\",\",\
    \ \"\")\n                                 .replace(\"'\", \"\")\n            \
    \                     .replace(\"\\\"\", \"\")));\n}", "{\n    string[] words;\n\
    \    string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    long num;\n    string\
    \ temp;\n    foreach(word; split(s))\n    {\n        num = 0;\n        temp =\
    \ word.toLower();\n        foreach(ch; temp)\n        {\n            if(consonants.canFind(ch))\n\
    \                num++;\n        }\n        if(num == n)\n            words ~=\
    \ word;\n    }\n    return words;\n}\n \n/*\n    You are given a string representing\
    \ a number of items to purchase, and a list of dictionaries representing the items\
    \ that are available in stock.\n    Each item has a \"name\" and a \"quantity\"\
    \ field.\n    For each item you are to modify the quantity field in stock to reflect\
    \ the amount of items remaining in stock after your purchase.\n    If the item\
    \ is not in stock then it should not be modified.\n    If there are not enough\
    \ items in stock to cover your purchase then you should leave the quantity unchanged.\n\
    \    You are to return the number of items that were in stock and successfully\
    \ modified.\n    Examples:\n    >>> stock = [\n        {\"name\": \"banana\",\
    \ \"quantity\": 5},\n        {\"name\": \"orange\", \"quantity\": 10},\n     \
    \   {\"name\": \"apple\", \"quantity\": 20},\n        {\"name\": \"cherry\", \"\
    quantity\": 0},\n        {\"name\": \"pear\", \"quantity\": 25},\n    ]\n    >>>\
    \ purchase(\"banana,1,orange,3,apple,5,cherry,0,pear,1\", stock)\n    4\n    >>>\
    \ stock\n    [{\"name\": \"banana\", \"quantity\": 4}, {\"name\": \"orange\",\
    \ \"quantity\": 7}, {\"name\": \"apple\", \"quantity\": 15}, {\"name\": \"cherry\"\
    , \"quantity\": 0}, {\"name\": \"pear\", \"quantity\": 24}]\n    >>> purchase(\"\
    banana,1,orange,3,apple,15,cherry,0,pear,1\", stock)\n    3\n    >>> stock\n \
    \   [{\"name\": \"banana\", \"quantity\": 3}, {\"name\": \"orange\", \"quantity",
  "{\n    import std.array;\n    string[] toReturn = [];\n    string[] splitS = s.split(\"\
    \ \");\n    int l = splitS.length;\n    int i = 0;\n    string curr;\n    int\
    \ consonantsInCurr = 0;\n    while(i < l)\n    {\n        curr = splitS[i];\n\
    \        consonantsInCurr = 0;\n        foreach(char c; curr)\n        {\n   \
    \         if(c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n     \
    \       {\n                consonantsInCurr++;\n            }\n        }\n   \
    \     if(consonantsInCurr == n)\n        {\n            toReturn ~= curr;\n  \
    \      }\n        i++;\n    }\n    return toReturn;\n}", "{\n    //string[] words\
    \ = split(s);\n    //string[] result;\n    //foreach(w; words)\n    //{\n    //\
    \    if(n == count_consonants(w))\n    //    {\n    //        result ~= w;\n \
    \   //    }\n    //}\n    //return result;\n    return split(s).filter!(w => n\
    \ == count_consonants(w)).array;\n}", "{\n    /*\n    \u041E\u043F\u0440\u0435\
    \u0434\u0435\u043B\u044F\u0435\u043C \u043A\u043E\u043D\u0441\u0442\u0430\u043D\
    \u0442\u0443 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0449\u0443\u044E \u043C\
    \u0430\u0441\u0441\u0438\u0432 \u0441\u043E\u0433\u043B\u0430\u0441\u043D\u044B\
    \u0445 \u0431\u0443\u043A\u0432\n    */\n    immutable string[] consonants = [\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"];\n    /*\n    \u0420\
    \u0430\u0437\u0431\u0438\u0432\u0430\u0435\u043C \u0441\u0442\u0440\u043E\u043A\
    \u0443 \u043D\u0430 \u043C\u0430\u0441\u0441\u0438\u0432 \u0441\u043B\u043E\u0432\
    , \u043F\u0440\u0438 \u044D\u0442\u043E\u043C \u043C\u0430\u0441\u0441\u0438\u0432\
    \ \u043D\u0430\u0447\u0438\u043D\u0430\u0435\u0442\u0441\u044F \u0441 \u043D\u0443\
    \u043B\u044F, \n    \u043F\u043E\u044D\u0442\u043E\u043C\u0443 \u043D\u0430\u043C\
    \ \u043D\u0443\u0436\u043D\u043E \u0431\u0443\u0434\u0435\u0442 \u0438\u0437\u043C\
    \u0435\u043D\u0438\u0442\u044C \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\
    \u0432\u043E \u0441\u043E\u0433\u043B\u0430\u0441\u043D\u044B\u0445 \u0431\u0443\
    \u043A\u0432 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430\n    */\n\
    \    string[] words = split(s);\n    /*\n    \u0423\u0441\u0442\u0430\u043D\u0430\
    \u0432\u043B\u0438\u0432\u0430\u0435\u043C \u043F\u0435\u0440\u0435\u043C\u0435\
    \u043D\u043D\u0443\u044E \u0434\u043B\u044F \u0445\u0440\u0430\u043D\u0435\u043D\
    \u0438\u044F \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u0441\u043B\
    \u043E\u0432\n    */\n    string[] res;\n    /*\n    \u0421\u043E\u0437\u0434\u0430\
    \u0435\u043C \u043C\u0430\u0441\u0441\u0438\u0432, \u043A\u043E\u0442\u043E\u0440\
    \u044B\u0439 \u0431\u0443\u0434\u0435\u0442 \u0445\u0440\u0430\u043D\u0438\u0442\
    \u044C \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u043E\
    \u0433\u043B\u0430\u0441\u043D\u044B\u0445 \u0431\u0443\u043A\u0432 \u0432 \u043A\
    \u0430\u0436\u0434\u043E\u043C \u0441\u043B\u043E\u0432\u0435\n    */\n    int[]\
    \ consonantsCount;\n    /*\n    \u0426\u0438\u043A\u043B\u043E\u043C foreach \u043F\
    \u0440\u043E\u0445\u043E\u0434\u0438\u043C \u043F\u043E \u0432\u0441\u0435\u043C\
    \ \u0441\u043B", "{\n    return split(lower(s))\n    .map!(a => a.filter!(isConsonant).length)\n\
    \    .filter!(x => x == n)\n    .enumerate\n    .map!(a => split(lower(s))[a[0]])\n\
    \    .array;\n}", "{\n    string[] words = split(s);\n    string[] result;\n \
    \   foreach(string word; words)\n    {\n        if(countConsonants(word) == n)\n\
    \        {\n            result ~= word;\n        }\n    }\n    return result;\n\
    }", "{\n    string[] words = s.split(' ');\n    string[] s2 = [];\n    foreach(string\
    \ word; words)\n    {\n        if(n == word.count!(char c => 'B' < c < 'Z' ||\
    \ 'b' < c < 'z'))\n        {\n            s2 ~= word;\n        }\n    }\n    return\
    \ s2;\n}\n/*\nWrite a function get_digits that takes a natural number and returns\
    \ an array of its digits.\n    Examples:\n    >>> get_digits(0L)\n    [0]\n  \
    \  >>> get_digits(123L)\n    [1, 2, 3]\n    >>> get_digits(123456789L)\n    [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> get_digits(1L)\n    [1]\n*/\nlong[] get_digits(long\
    \ n)\n{\n    //long[] a = n.to!string().map!(d => d.to!long).array;\n    //return\
    \ a;\n    long[] a = new long[];\n    string s = n.to!string();\n    foreach(immutable\
    \ char c; s)\n    {\n        a ~= c.to!long;\n    }\n    return a;\n}\n/*\nGiven\
    \ an array of ints, a value, and an array of indices, \n    write a function that\
    \ creates an array of the same length as the indices array, \n    and sets the\
    \ values at those indices to be equal to the value.\n    Examples:\n    >>> indices_to_value([0,\
    \ 1, 2, 3, 4, 5], 10, [0, 2, 4])\n    [10, 1, 10, 3, 10, 5]\n    >>> indices_to_value([0,\
    \ 1, 2, 3, 4, 5], 10, [])\n    [0, 1, 2, 3, 4, 5]\n    >>> indices_to_value([0,\
    \ 1, 2, 3, 4, 5], 10, [5, 5, 5])\n    [0, 1, 2, 3, 4, 10]\n    >>> indices_to_value([0,",
  "{\n    return s.split()\n            .filter!(w => w.count!(c => c.isConsonant())\
    \ == n)\n            .array;\n}", "{ \n    // typeof is a keyword in D, not C,\
    \ you are only interested in \n    // the std.typecons.Tuple!(char[],bool) return\
    \ type.\n    // https://dlang.org/spec/typeof.html\n    // https://dlang.org/phobos/std_typecons.html#.Tuple!\n\
    \    typeof(split(s, ' '));\n    string[] all_words = split(s, ' ');\n    return\
    \ all_words\n        .filter!(a => count_consonants(a) == n)\n        .retro();\n\
    }", "{\n    //split the string based on spaces\n    string[] split_str = split(s);\n\
    \    //filter the string array\n    string[] filtered_str = split_str.filter!(splitted_str\
    \ =>\n    {\n       //translate the string to lower case\n       string s_copy\
    \ = toLower(splitted_str);\n       size_t consonant_count = 0;\n       //count\
    \ the number of consonants in the string\n       for(char c : s_copy)\n      \
    \ {\n           if(c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \           {\n               consonant_count += 1;\n           }\n       }\n\
    \       //return true if the consonant count matches the parameter n\n       return\
    \ consonant_count == n;\n    });\n    return filtered_str;\n}", "{\n    string[]\
    \ words = split(s, \" \");\n    string[] result;\n    foreach(i, string word;\
    \ words)\n    {\n        if(count_consonants(word) == n)\n        {\n        \
    \    result ~= word;\n        }\n    }\n    return result;\n}", "{\n    //string[]\
    \ res = new string[];\n    int len = s.length;\n    int start = 0;\n    int end\
    \ = 0;\n    int count = 0;\n    int words = 0;\n    while(start < len)\n    {\n\
    \        //we are looking for consonants\n        //check if char is vowel if\
    \ yes then reset end\n        if(s[start] == 'a' || s[start] == 'e' || s[start]\
    \ == 'i' || s[start] == 'o' || s[start] == 'u')\n        {\n            end =\
    \ start + 1;\n            //we have a vowel move to next char\n            //start++;\n\
    \        }\n        else \n        {\n            //we have consonant increase\
    \ the count\n            count++;\n            end++;\n        }\n        //check\
    \ if we have count number of consonants\n        if(count == n)\n        {\n \
    \           words++;\n            //count is equal to n move to next char\n  \
    \          start++;\n            end = start;\n            count = 0;\n      \
    \  }\n        //check if we have a word\n        if(s[start] == ' ')\n       \
    \ {\n            //this is a word move to next char\n            start++;\n  \
    \          end = start;\n            count = 0;\n        }\n        //check if\
    \ we have the end of the string\n        if(start == len - 1)\n        {\n   \
    \         words++;\n            break;\n        }\n    }\n    if(words == 0)\n\
    \    {\n        return new string[0];\n    }\n    string[] res = new string[words];\n\
    \    int index = 0;\n    start = 0;\n    end = 0;\n    count = 0;\n    int prev\
    \ = 0;\n    while(start < len)\n    {\n        //we are looking for consonants\n\
    \        //check if char is vowel if yes then reset end\n        if(s[start] ==\
    \ 'a' || s[start] == 'e' || s[start] == 'i' || s[start] == 'o' || s[start] ==\
    \ 'u')\n        {\n            end = start + 1;\n            //we have a vowel\
    \ move to next char\n            //start", "{\n    long[string] mapping = [\"\
    a\":\"A\", \"e\":\"E\", \"i\":\"I\", \"o\":\"O\", \"u\":\"U\"];\n    auto arr\
    \ = to!string[](split(s, \" \"));\n    auto ret = new string[];\n    foreach(word;\
    \ arr)\n    {\n        auto count = 0L;\n        foreach(letter; word)\n     \
    \   {\n            if(mapping.byKey(letter) is null)\n            {\n        \
    \        count++;\n            }\n        }\n        if(count == n)\n        {\n\
    \            ret ~= word;\n        }\n    }\n    return ret;\n}", "{\n    string[]\
    \ res;\n    foreach(w;words(s))\n    {\n        static if(is(ElementType!(typeof(w))\
    \ == dchar))\n        {\n            auto consonants = filter!(c => !isAlphaNumeric(c)\
    \ && !isWhitespace(c))(w);\n            if(consonants.length == n)\n         \
    \       res ~= w;\n        }\n        else\n        {\n            auto consonants\
    \ = filter!(c => !isAlphaNumeric(c) && !isWhitespace(c))(w.dup);\n           \
    \ if(consonants.length == n)\n                res ~= w;\n        }\n    }\n  \
    \  return res;\n}", "{\n    int[] indices = new int[];\n    int strIndex = 0;\n\
    \    string[] words = s.split();\n    foreach(string word; words)\n    {\n   \
    \     if(countConsonants(word) == n)\n        {\n            indices ~= strIndex;\n\
    \        }\n        strIndex++;\n    }\n    return words[indices];\n}", "{\n \
    \   return split(s, \" \").filter!(x => countConsonants(x) == n)();\n}", "{\n\
    \    static const char[] vowels = ['a', 'e', 'i', 'o', 'u'];\n    static immutable\
    \ vowels_set = set(vowels);\n    static assert(isInputRange!(vowels_set));\n \
    \   static assert(isForwardRange!(vowels_set));\n    static assert(isRandomAccessRange!(vowels_set));\n\
    \    static assert(!isBidirectionalRange!(vowels_set));\n    static assert(!isInfinite!(vowels_set));\n\
    \    static assert(!isSorted!(vowels_set));\n    static assert(vowels_set.canFind);\n\
    \    static assert(vowels_set.length == 5);\n    static assert(vowels_set.byKey(vowels[0])\
    \ == std.typecons.Tuple!(immutable(char), true)(vowels[0], true));\n    static\
    \ assert(vowels_set.byKey(vowels[0]).tupleof[1] == true);\n    static assert(vowels_set.byKey(vowels[0]).tupleof[0]\
    \ == vowels[0]);\n    static assert(vowels_set.byKey('b') == std.typecons.Tuple!(immutable(char),\
    \ bool)('b', false));\n    static assert(vowels_set.byKey('b').tupleof[1] == false);\n\
    \    static assert(vowels_set.byKey('b').tupleof[0] == 'b');\n    static assert(vowels_set.byKey('b').tupleof[0].sizeof\
    \ == 1);\n    static assert(vowels_set.byKey('b').tupleof[1].sizeof == 1);\n \
    \   static assert(vowels_set.byKey('b').tupleof[0].alignof == 1);\n    static\
    \ assert(vowels_set.byKey('b').tupleof[1].alignof == 1);\n    static assert(vowels_set.byKey('b').tupleof[0].mangleof\
    \ == \"C\");\n    static assert(v", "{\n    string[] words = split(s);\n    uint[]\
    \ word_count = words.map!(word => count_consonants(word));\n    return words[findAll!(i\
    \ => word_count[i] == n)];\n}", "{\n    import std.array;\n    import std.string;\n\
    \    import std.conv;\n    import std.algorithm;\n    import std.range;\n    immutable\
    \ arr = split(s, \" \");\n    immutable arr2 = map!(a => to!int(chomp(a)))(arr);\n\
    \    immutable arr3 = filter!(a => a < 100)(arr2);\n    immutable arr4 = filter!(a\
    \ => a > 5)(arr3);\n    immutable arr5 = map!(a => to!string(a))(arr4);\n    return\
    \ arr5;\n}", "{\n    import std.algorithm;\n    import std.regex;\n    import\
    \ std.typecons;\n    import std.array;\n    import std.string;\n    import std.conv;\n\
    \    import std.format;\n    import std.math;\n    import std.range;\n    import\
    \ std.typecons;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.regex;\n    import std.string;\n    import std.typecons;\n\
    \    import std.range;\n    import std.typecons;\n    import std.array;\n    import\
    \ std.regex;\n    import std.string;\n    import std.typecons;\n    import std.range;\n\
    \    import std.range;\n    import std.string;\n    import std.typecons;\n   \
    \ import std.array;\n    import std.regex;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.range;\n    import std.range;\n    import std.range;\n\
    \    import std.string;\n    import std.array;\n    import std.regex;\n    import\
    \ std.typecons;\n    import std.range;\n    import std.string;\n    import std.typecons;\n\
    \    import std.range;\n    import std.string;\n    import std.array;\n    import\
    \ std.regex;\n    import std.typecons;\n    import std.range;\n    import std.typecons;\n\
    \    import std.array;\n    import std.regex;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.range;\n    import std.string;\n    import std.array;\n\
    \    import std.regex;\n    import std.typecons;\n    import std.range;\n    import\
    \ std.range;\n    import std.string;\n    import std.array;\n    import std.regex;\n\
    \    import std.typecons;\n    import std.range;\n    import std.string;\n   \
    \ import std.typecons;\n    import std.range;\n    import std.string;\n    import\
    \ std.array;\n    import std.regex;", "{\n    if (s == \"\")\n        return [];\n\
    \    int length = s.length();\n    string[] split = split(s);\n    string[] output\
    \ = [];\n    foreach(i; 0..split.length)\n    {\n        int c = 0;\n        foreach(j;\
    \ 0..split[i].length)\n        {\n            if (split[i][j] != 'a' && split[i][j]\
    \ != 'e' && split[i][j] != 'i' && split[i][j] != 'o' && split[i][j] != 'u')\n\
    \                c++;\n        }\n        if (c == n)\n            output ~= split[i];\n\
    \    }\n    return output;\n}", "{\n    int[] consonants = [\n    0xB2, 0xB3,\
    \ 0xB9, 0xBA, 0xBC, 0xBE, 0xC0, 0xC1, 0xC2, 0xC3, 0xC5, 0xC6, 0xC8, 0xC9, 0xCA,\
    \ 0xCB, 0xCC,\n    0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD8,\
    \ 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n    0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\
    \ 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2,\n  \
    \  0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x100,\
    \ 0x101, 0x102, 0x103,\n    0x104, 0x105, 0x106, 0x107, 0x108, 0x109, 0x10A, 0x10B,\
    \ 0x10C, 0x10D, 0x10E, 0x10F, 0x110, 0x111,\n    0x112, 0x113, 0x114, 0x115, 0x116,\
    \ 0x117, 0x118, 0x119, 0x11A, 0x11B, 0x11C, 0x11D, 0x11E, 0x11F,\n    0x120, 0x121,\
    \ 0x122, 0x123, 0x124, 0x125, 0x126, 0x127, 0x128, 0x129, 0x12A, 0x12B, 0x12C,\
    \ 0x12D,", "{\n    string[] temp = split(s);\n    long[] nums = new long[temp.length];\n\
    \    int counter = 0;\n    foreach(val;temp)\n    {\n        nums[counter] = num_consonants(val);\n\
    \        counter++;\n    }\n    temp = temp[];\n    counter = 0;\n    foreach(val;nums)\n\
    \    {\n        if(val == n)\n        {\n            temp ~= temp[counter];\n\
    \        }\n        counter++;\n    }\n    return temp;\n}", "{\n    string[]\
    \ rr;\n    foreach(k,v;s.split())\n    {\n        static if(v.filter!(a=>(a>='a'\
    \ && a<='z')||(a>='A' && a<='Z')).length!=v.length)\n            continue;\n \
    \       if(v.filter!(a=>!(a>='a' && a<='z')&&!(a>='A' && a<='Z')).length==n)\n\
    \            rr~=v;\n    }\n    return rr;\n}", "{\n    string[] words = split(s);\n\
    \    string[] results;\n    foreach(i, w; words)\n    {\n        if(w.countConsonants()\
    \ == n)\n        {\n            results ~= w;\n        }\n    }\n    return results;\n\
    }", "{\n    size_t i, j;\n    string[] words;\n    string[] res;\n    words =\
    \ s.split();\n    foreach(string word; words)\n    {\n        if(word.length ==\
    \ n)\n        {\n            res ~= word;\n        }\n    }\n    return res;\n\
    }", "{\n    string[] words = split(s);\n    /*\n    string[] words = new string[];\n\
    \    foreach(word; split(s))\n    {\n        words ~= word;\n    }\n    */\n \
    \   uint count;\n    string[] selectedWords = new string[];\n    foreach(word;\
    \ words)\n    {\n        count = 0;\n        for(int i = 0; i < word.length; i++)\n\
    \        {\n            if(isConsonant(word[i]))\n            {\n            \
    \    count++;\n            }\n        }\n        if(count == n)\n        {\n \
    \           selectedWords ~= word;\n        }\n    }\n    return selectedWords;\n\
    }", "{\n    string[] words = split(s, \" \");\n    string[] result;\n    foreach(word;\
    \ words) \n    {\n        if(consonantsCount(word) == n) \n        {\n       \
    \     result ~= word;\n        }\n    }\n    return result;\n}", "{\n    return\
    \ [for(w; s.split) if(w.count_if!\"a\".isAlpha) == n.to!size_t];\n}\n// https://gist.github.com/seankross/3e3b5d2cccdb5bd5f7de\n\
    // **********\n// Given a string s and an integer k, you have been tasked to implement\
    \ a function that returns an array of all words from string s that are \n// equal\
    \ to k or more characters in length, in order these words appear in the string\
    \ s. \n// If the string s is empty then the function should return an empty array.\
    \ \n// Note: you may assume the input string contains only letters and spaces.\n\
    // Examples:\n// >>> select_words(\"Mary had a little lamb\", 4L)\n// [\"Mary\"\
    , \"little\"]\n// >>> select_words(\"Mary had a little lamb\", 3L)\n// [\"Mary\"\
    , \"little\", \"lamb\"]\n// >>> select_words(\"simple white space\", 2L)\n// [\"\
    simple\", \"white\", \"space\"]\n// >>> select_words(\"Hello world\", 4L)\n//\
    \ [\"Hello\", \"world\"]\n// >>> select_words(\"Uncle sam\", 3L)\n// [\"Uncle\"\
    , \"sam\"]", "{\n    return s.split(\" \").filter!(a => a.toUpper.count!(b =>\
    \ !\"AEIOU\".count(b)) == n).idup;\n}", "{\n    string[] res;\n    auto sep_words\
    \ = split(s);\n    string vowels = \"aeiouAEIOU\";\n    foreach(sep_words, word;\n\
    \        long counter = 0;\n        foreach(word, ch;\n            if(ch !in vowels)\n\
    \                counter++;\n        )\n        if(counter == n)\n           \
    \ res ~= word;\n    )\n    return res;\n}", "{\n    string[] arr = split(s, \"\
    \ \");\n    string[] res = new string[0];\n    for (auto word : arr)\n    {\n\
    \        if (numConsonants(word) == n)\n        {\n            res ~= word;\n\
    \        }\n    }\n    return res;\n}", "{\n\tauto ret = [];\n\tauto words = split(s);\n\
    \tforeach(word; words)\n\t{\n\t\tif(countConsonants(word) == n)\n\t\t\tret ~=\
    \ word;\n\t}\n\treturn ret;\n}\nlong countConsonants(string s)\n{\n\tlong ret\
    \ = 0;\n\tforeach(c; s)\n\t{\n\t\tif(isConsonant(c))\n\t\t\tret++;\n\t}\n\treturn\
    \ ret;\n}", "{\n    immutable(string)[] words = split(s);\n    string[] cWords;\n\
    \    for(size_t i = 0; i < words.length; i++)\n    {\n        cWords ~= words[i];\n\
    \    }\n    return cWords;\n}", "{ \n    string[] words = split(s, \" \");\n \
    \   string[] res = new string[];\n    foreach(word; words)\n    {\n        string[]\
    \ chars = split(word, \"\");\n        long count = 0;\n        foreach(c; chars)\n\
    \        {\n            if (isConsonant(c)) count++;\n        }\n        if (count\
    \ == n) \n        {\n            res ~= word;\n        }\n    }\n    return res;\n\
    }", "{\n    string[] words = split(s);\n    string[] result;\n    foreach(string\
    \ word; words)\n    {\n        if(word.length != n)\n            continue;\n \
    \       size_t count = 0;\n        foreach(immutable c; word)\n        {\n   \
    \         switch(c)\n            {\n                case 'a':\n              \
    \  case 'e':\n                case 'i':\n                case 'o':\n         \
    \       case 'u':\n                case 'y':\n                    break;\n   \
    \             default:\n                    count++;\n            }\n        }\n\
    \        if(count == n)\n            result ~= word;\n    }\n    return result;\n\
    }", "{\n    if (empty(s))\n        return string[];\n    \n    auto words = map!((word)\
    \ {return trim(word);})(split(s, \" \"));\n    auto fun = (string word) {\n  \
    \      auto vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n        auto cons =\
    \ filter!((char ch) {\n            auto flag = true;\n            foreach (vowel;\
    \ vowels)\n            {\n                if (vowel == ch)\n                {\n\
    \                    flag = false;\n                    break;\n             \
    \   }\n            }\n            return flag;\n        })(word);\n        if\
    \ (cons.length == n)\n            return word;\n        else\n            return\
    \ null;\n    };\n    auto res = filter!((string word) {return word !is null;})(map!fun(words));\n\
    \    return res;\n}", "{ \n    string[] words = s.split(\"\\\\s+\");\n    return\
    \ words.filter!(word => word.filter!(isVowel).length == n).array;\n}", "{\n  \
    \  string[] s_arr;\n    string[] res;\n    long length = 0;\n    long consonants\
    \ = 0;\n    string word;\n    long j = 0;\n    for(long i = 0; i < s.length; i++)\n\
    \    {\n        if(s[i] == ' ')\n        {\n            s_arr ~= word;\n     \
    \       word = \"\";\n            length = 0;\n            consonants = 0;\n \
    \       }\n        else\n        {\n            length++;\n            word ~=\
    \ s[i];\n            if(s[i] != 'a' && s[i] != 'e' && s[i] != 'i' && s[i] != 'o'\
    \ && s[i] != 'u')\n            {\n                consonants++;\n            }\n\
    \        }\n        if(i == s.length - 1)\n        {\n            s_arr ~= word;\n\
    \        }\n    }\n    for(long i = 0; i < s_arr.length; i++)\n    {\n       \
    \ if(s_arr[i].length - consonants == n)\n        {\n            res ~= s_arr[i];\n\
    \        }\n    }\n    return res;\n}", "{\n    auto consonants = ['b', 'c', 'd',\
    \ 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'z'];\n    string[] arr;\n    foreach(i, word; s.split())\n    {\n        int\
    \ cnt=0;\n        foreach(c; word)\n        {\n            if(consonants.find(c)\
    \ != -1)\n                cnt++;\n        }\n        if(cnt == n)\n          \
    \  arr ~= word;\n    }\n    return arr;\n}", "{\n    // We split the string into\
    \ words and then use a filter to get the words\n    // with the number of consonants\
    \ we are looking for.\n    string[] words = s.split();\n    return words.filter!(w\
    \ => w.filter!(c => \"bcdfghjklmnpqrstvwxyz\".canFind(c)).length == n).array;\n\
    }", "{\n    string[] result;\n    foreach(i, word; split(s))\n    {\n        if(word.length\
    \ == n)\n        {\n            result ~= word;\n        }\n    }\n    return\
    \ result;\n}\n/*\nGiven a string s and a positive integer k, you have been tasked\
    \ to implement \n    a function that returns a boolean indicating whether the\
    \ string s contains at least k unique \n    characters. You should implement the\
    \ function so that its execution time is proportional to the \n    size of the\
    \ string s, meaning that you should use an algorithmic technique or data structure\
    \ \n    that can guarantee such time complexity. You may assume that the string\
    \ s contains only \n    lowercase ASCII letters.\n*/", "{\n    string[] words;\n\
    \    words=split(s,\" \");\n    long count;\n    string[] vowels=[\"a\",\"e\"\
    ,\"i\",\"o\",\"u\"];\n    auto result=filter!(x=>\n    {\n        count=0;\n \
    \       foreach(x1;x)\n        {\n            if(!vowels.canFind(x1))\n      \
    \      {\n                count++;\n            }\n        }\n        return count==n;\n\
    \    })(words);\n    return result;\n}", "{\n    string[] v = split(s);\n    foreach(ref\
    \ string i; v)\n    {\n        i = toLower(i);\n    }\n    string[] result;\n\
    \    foreach(string i; v)\n    {\n        if(count(i) == n)\n        {\n     \
    \       result ~= i;\n        }\n    }\n    return result;\n}", "{\n\tauto words\
    \ = split(s);\n\tstring[] result;\n\tforeach(word; words)\n\t{\n\t\tif(consonantsInWord(word)\
    \ == n)\n\t\t{\n\t\t\tresult ~= word;\n\t\t}\n\t}\n\treturn result;\n}", "{\n\
    \    if (s.empty) \n        return [];\n    string[] words = split(s);\n    string[]\
    \ result = [];\n    foreach (immutable word; words) \n    {\n        long vowelCount\
    \ = count_vowels(word);\n        if (word.length - vowelCount == n) \n       \
    \     result ~= word;\n    }\n    return result;\n}\n/*\nCount the number of vowels\
    \ in a string.\n*/\nsize_t count_vowels(string s) \n{\n    size_t result = 0;\n\
    \    foreach (immutable c; s) \n    {\n        c = toLower(c);\n        if (in(c,\
    \ 'a', 'e', 'i', 'o', 'u')) \n            result++;\n    }\n    return result;\n\
    }\n/*\nThere are several fundamental methods in D to work with ranges.\n    We've\
    \ already used the most basic of these methods, namely opApply and front.\n  \
    \  But there are others, too.\n    For example, the take method takes an upper\
    \ bound and returns a range that is the first part of the input range.\n    The\
    \ take method is defined in std.range, so we need to import it.\n    The drop\
    \ method is the opposite of take.\n    It returns a range with the first n elements\
    \ skipped.\n    The take and drop methods are defined in std.range, so we need\
    \ to import them.\n    In the following problem, we will need to use the take\
    \ and drop methods.\n    The problem is to check if the first part of an array\
    \ is equal to the last part of the array.\n    For example, the array [1, 2, 3,\
    \ 4, 1, 2, 3] has equal first and last parts.\n    But the array [1, 2, 3, 4,\
    \ 1, 2, 3, 4] has unequal first and last parts.\n    Examples:\n    >>> has_equal_first_and_last_parts([1,\
    \ 2, 3, 4, 1, 2, 3])\n    true\n    >>> has_equal_first_and_last_parts([1, 2,\
    \ 3, 4, 1, 2, 3, 4])\n    false\n    >>> has_equal_first_and_last_parts", "{\n\
    \    auto input = splitter(s);\n    auto res = (string[])std.algorithm.filter!((string\
    \ x) => std.algorithm.count!((char c)=>c=='c'||c=='C')(x) == n, input);\n    return\
    \ res;\n}", "{\n    string[] res;\n    string word;\n    string[] all = s.split();\n\
    \    foreach(x; all)\n    {\n        word = x;\n        if(count_consonants(word)\
    \ == n)\n        {\n            res ~= word;\n        }\n    }\n    return res;\n\
    }", "{\n    // return [];\n    immutable(char)[] consonants = ['b', 'c', 'd',\
    \ 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'z'];\n    s = \" \" ~ s ~ \" \";\n    immutable(char)[] consonants_set = set(consonants);\n\
    \    string[] words;\n    foreach(w; split(s)) \n    {\n        long consonants_count\
    \ = 0;\n        foreach(c; w) \n        {\n            if(c in consonants_set)\
    \ consonants_count++;\n        }\n        if(consonants_count == n) words ~= w;\n\
    \    }\n    return words;\n}\n/*\n    Enums of type enum can be declared with\
    \ a special syntax, allowing to set the values of the enum. \n    An enum with\
    \ pre-assigned values is called an enum class. The values of an enum class can\
    \ be \n    accessed as properties of the class:\n    \n    Example:\n    >>> enum\
    \ class Day { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday };\n\
    \    enum class Day { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday,\
    \ Sunday };\n    >>> foreach(i; 0 .. 6)\n    ...     writeln(Day(i));\n    Monday\n\
    \    Tuesday\n    Wednesday\n    Thursday\n    Friday\n    Saturday\n    Sunday\n\
    \    >>> import std.typecons;\n    import std.typecons;\n    >>> writeln(typeid(tuple(Day.Monday,\
    \ Day.Tuesday, Day.Wednesday)));\n    Tuple!(Day, Day, Day)\n    >>> writeln(typeid(tuple(Day.Monday,\
    \ Day.Tuesday, tuple(Day.Wednesday, Day.Thursday))));\n    Tuple!(Day, Day, Tuple!(Day,\
    \ Day))\n    >>> writeln(typeid(tuple(Day.Monday, Day.Tuesday, tuple(Day.Wednesday,\
    \ Day.Thursday), Day.Friday)));\n    Tuple!(Day, Day, Tuple!(Day, Day), Day)\n\
    \    >>> writ", "{\n    string[] result;\n    string temp_word;\n    foreach(t;\
    \ 0..s.length)\n    {\n        if(s[t] != ' ')\n        {\n            temp_word\
    \ ~= s[t];\n        }\n        else\n        {\n            result ~= temp_word;\n\
    \            temp_word = \"\";\n        }\n    }\n    if(temp_word != \"\")\n\
    \    {\n        result ~= temp_word;\n    }\n    foreach(w; result)\n    {\n \
    \       if(w.count('a', 'e', 'i', 'o', 'u') != n)\n        {\n            result.remove(w);\n\
    \        }\n    }\n    return result;\n}", "{\n    int nconsonants(string s,int\
    \ idx) pure nothrow @nogc\n    {\n        static immutable string constant = \"\
    aeiouAEIOU\";\n        if(idx == s.length) return 0;\n        return (s[idx] in\
    \ constant)? nconsonants(s,idx+1) : 1 + nconsonants(s,idx+1);\n    }\n    string[]\
    \ select_words_nconsonants(string s, long n, string t)\n    {\n        if(s.length\
    \ == 0) return typeof(return)();\n        string[] tmp;\n        if(nconsonants(s,0)\
    \ == n)\n        {\n            tmp = select_words_nconsonants(s[1..$],n,t~s[0]);\n\
    \            tmp ~= t;\n        }\n        else\n        {\n            tmp =\
    \ select_words_nconsonants(s[1..$],n,t);\n        }\n        return tmp;\n   \
    \ }\n    string[] select_words_nconsonants_inner(string s, long n)\n    {\n  \
    \      s = s.strip;\n        return select_words_nconsonants(s,\"\");\n    }\n\
    \    string[] select_words_nconsonants_inner(string s, long n)\n    {\n      \
    \  s = s.strip;\n        string[] tmp;\n        foreach(i;0..s.length)\n     \
    \   {\n            tmp ~= s[i..$].split;\n        }\n        return tmp.filter!(a\
    \ => nconsonants(a,0) == n);\n    }\n    return select_words_nconsonants_inner(s,n);\n\
    }", "{\n    string[] words = split(s, \" \");\n    string[] selected_words;\n\
    \    foreach(word; words)\n    {\n        if(num_of_consonants(word) == n)\n \
    \       {\n            selected_words ~= word;\n        }\n    }\n    return selected_words;\n\
    }\nlong num_of_consonants(string s)\n{\n    string consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    long counter = 0;\n    foreach(char; s)\n    {\n        if(contains(consonants,\
    \ char))\n        {\n            counter++;\n        }\n    }\n    return counter;\n\
    }\n/*\nGiven a string s and two natural numbers n and m, you have been tasked\
    \ to implement \n    a function that returns true if and only if string s contains\
    \ at least n consonants \n    and at least m vowels.\n    Examples:\n    >>> has_n_consonants_and_m_vowels(\"\
    Hello\", 0L, 0L)\n    true\n    >>> has_n_consonants_and_m_vowels(\"Hello\", 1L,\
    \ 0L)\n    true\n    >>> has_n_consonants_and_m_vowels(\"Hello\", 2L, 0L)\n  \
    \  false\n    >>> has_n_consonants_and_m_vowels(\"Hello\", 0L, 1L)\n    true\n\
    \    >>> has_n_consonants_and_m_vowels(\"Hello\", 0L, 2L)\n    false\n    >>>\
    \ has_n_consonants_and_m_vowels(\"Hello\", 1L, 1L)\n    true\n    >>> has_n_consonants_and_m_vowels(\"\
    Hello\", 2L, 1L)\n    false\n    >>> has_n_consonants_and_m_vowels(\"Hello\",\
    \ 1L, 2L)\n    false\n    >>> has_n_consonants_and_m_vowels(\"Hello\", 2L, 2L)\n\
    \    false\n    >>> has_n_consonants_and_m_vowels(\"", "{\n    auto arr = appender!(string[])();\n\
    \    auto isConsonant = (char c) {\n        return c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u';\n    };\n    auto consonants = 0;\n    for (auto\
    \ word : s.split()) {\n        for (auto letter : word) {\n            if (!isConsonant(letter))\
    \ consonants++;\n        }\n        if (consonants == n) arr.put(word);\n    \
    \    consonants = 0;\n    }\n    return arr.data;\n}", "{\n    import std.algorithm;\n\
    \    import std.array;\n    import std.string;\n    import std.typecons;\n   \
    \ import std.range;\n    import std.math;\n    //Tuple!(string,int)[] words =\
    \ s.split(\" \").map!(a => tuple(a,a.countUntil!((c) => c.isAlpha))).array;\n\
    \    /*\n    auto words = map!(a => tuple(a,a.countUntil!((c) => c.isAlpha)))(s.split(\"\
    \ \"));\n    auto result = words.map!(a => a[1]).filter!(a => a == n).map!(i =>\
    \ words[i][0]).array;\n    return result;\n    */\n    /*\n    //var words = s.split(\"\
    \ \").map!(a => tuple(a,a.countUntil!((c) => c.isAlpha))).array;\n    var words\
    \ = s.split(\" \").map!(a => tuple(a,a.countUntil!((c) => c.isAlpha)));\n    auto\
    \ results = words.filter!(a => a[1] == n).map!(a => a[0]).array;\n    return results;\n\
    \    */\n    auto words = s.split(\" \").map!(a => tuple(a,a.countUntil!((c) =>\
    \ c.isAlpha)));\n    auto results = words.filter!(a => a[1] == n).map!(a => a[0]).array;\n\
    \    return results;\n}", "{\n    // your code goes here\n    string[] temp =\
    \ s.split();\n    string[] result;\n    int count = 0;\n    foreach(w; temp)\n\
    \    {\n        foreach(c; w)\n        {\n            if(c != 'a' || c != 'e'\
    \ || c != 'i' || c != 'o' || c != 'u')\n            {\n                count++;\n\
    \            }\n        }\n        if(count == n)\n        {\n            result\
    \ ~= w;\n        }\n        count = 0;\n    }\n    return result;\n}\n/*\nYou\
    \ have been tasked to write a function that takes a single string parameter, \n\
    \    and returns a string in which all the characters are reversed.\n    Your\
    \ function does not need to preserve the case of the original string.\n    Examples:\n\
    \    >>> reverse_all(\"Hello world\")\n    \"dlrow olleH\"\n    >>> reverse_all(\"\
    \")\n    \"\"\n    >>> reverse_all(\"A sentence.\")\n    \".ecnetnes A\"\n   \
    \ >>> reverse_all(\"Hello, how's it going?\")\n    \"?gnigo ti s'woH ,olleH\"\n\
    \    >>> reverse_all(\"John's, is it John?\")\n    \"?nhoJ ti si ,s'nhoJ\"\n*/\n\
    string reverse_all(string s) \n{\n    // your code goes here\n    string result\
    \ = \"\";\n    foreach(c; s)\n    {\n        result = c ~ result;\n    }\n   \
    \ return result;\n}\n/*\nYou have been tasked to write a function that takes as\
    \ an input a single string, \n    and returns a string with the vowels removed.\n\
    \    Vowels are the letters a, e, i, o, u, and y.\n    Examples:\n    >>> remove_vowels(\"\
    Hello, world!\")\n    \"Hll, wrld!\"\n    >>> remove_vowels(\"John's, is it John?\"\
    )\n    \"Jhn's, s t Jhn?\"\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"\
    Wyatt's torch\")\n    \"Wytt's trch\"\n    >>> remove", "{\n    string[] arr =\
    \ [];\n    if(s.empty)\n        return arr;\n    string[] words = s.split(\" \"\
    );\n    foreach(word; words)\n    {\n        uint count = 0;\n        foreach(ch;\
    \ word)\n        {\n            if(!isAlpha(ch))\n                continue;\n\
    \            if(!isVowel(ch))\n                count++;\n        }\n        if(count\
    \ == n)\n            arr ~= word;\n    }\n    return arr;\n}", "{\n    string[]\
    \ words = split(s, \" \");\n    string[] result;\n    foreach(string word; words)\n\
    \    {\n        if(count_consonants(word) == n)\n        {\n            result\
    \ ~= word;\n        }\n    }\n    return result;\n}\nlong count_consonants(string\
    \ s)\n{\n    long consonants = 0;\n    foreach(char c; s)\n    {\n        if(c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        {\n       \
    \     // do nothing\n        }\n        else\n        {\n            consonants++;\n\
    \        }\n    }\n    return consonants;\n}", "{\n    string[] words = split(s,\
    \ \" \");\n    uint[] count = words.map!(x => x.filter!(y => y.isConsonant).length).array;\n\
    \    return words[count.indexOf(n)];\n}\n ", "{\n    int [] consonants = [\"b\"\
    , \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"];\n    int [] consonantsCount\
    \ = new int[s.length];\n    string [] result = new string[s.length];\n    string\
    \ [] words = s.split;\n    long counter = 0;\n    foreach(word; words)\n    {\n\
    \        if(word.isWhite) continue;\n        foreach(letter; word)\n        {\n\
    \            if(consonants.canFind(letter)) consonantsCount[counter]++;\n    \
    \    }\n        if(consonantsCount[counter] == n) result ~= word;\n        counter++;\n\
    \    }\n    return result;\n}", "{\n    size_t a = 0;\n    size_t b = 0;\n   \
    \ size_t c = 0;\n    size_t count;\n    bool space = false;\n    string[] str\
    \ = [];\n    for(i in s)\n    {\n        if(i == ' ')\n        {\n           \
    \ c = b;\n            count = c - a;\n            a = c + 1;\n            b =\
    \ a;\n            space = true;\n        }\n        else\n        {\n        \
    \    if(isAlpha(i))\n            {\n                b++;\n                if(isVowel(i))\n\
    \                {\n                    count--;\n                }\n        \
    \    }\n        }\n        if(space && count == n)\n        {\n            str\
    \ ~= s[a..b-1];\n            space = false;\n        }\n    }\n    return str;\n\
    }", "{\n    // Regex for one or more consonants\n    auto consonantsRegex = new\
    \ Regex(\"(?i)(?<![aeiou])[aeiou]+\");\n    return s.split()\n            .filter!(x\
    \ => consonantsRegex.matches(x).filter!(y => y.match.length == n).length != 0).array;\n\
    }", "{\n    string[] words;\n    words = s.split(\" \");\n    int i;\n    int\
    \ count = 0;\n    string[] words_out;\n    foreach(string word; words)\n    {\n\
    \        foreach(char ch; word)\n        {\n            if (ch == 'a' || ch ==\
    \ 'e' || ch == 'i' || ch == 'o' || ch == 'u')\n            {\n               \
    \ count += 1;\n            }\n        }\n        if (count == n)\n        {\n\
    \            append(words_out, word);\n        }\n        count = 0;\n    }\n\
    \    return words_out;\n}\n \n/*\nGiven an array of integers a, you have been\
    \ tasked to implement a function \n    that returns a tuple containing the difference\
    \ between the maximum and minimum \n    values in the array and the array index\
    \ of the minimum value.\n    If the array is empty then the function should return\
    \ a tuple with the values \n    (0, 0).\n    Examples:\n    >>> difference_and_index([10,\
    \ 15, 20, 2, 10, 6])\n    (18, 3)\n    >>> difference_and_index([1, 1, 1, 1, 1])\n\
    \    (0, 0)\n    >>> difference_and_index([])\n    (0, 0)\n    >>> difference_and_index([8,\
    \ 8, 2, 3, 2, 6])\n    (6, 2)\n    >>> difference_and_index([20, 1, 1, 2, 3, 10,\
    \ 15])\n    (19, 1)\n    >>> difference_and_index([1, 10, 20, 30, 15, 6])\n  \
    \  (29, 0)\n*/\ntuple(long, long) difference_and_index(int[] a) \n{\n    int min;\n\
    \    int max;\n    int idx;\n    int diff;\n    if (a.length == 0)\n    {\n  \
    \      return tuple(0, 0);\n    }\n    else\n    {\n        min = a[0];\n    \
    \    max = a[0];\n        foreach(i; 0..a.length)\n        {\n            if (a[i]\
    \ < min)\n            {", "{\n    string[] words = s.split(\" \");\n    string[]\
    \ res = [];\n    foreach(inout w; words)\n    {\n        int consonants = 0;\n\
    \        foreach(inout c; w)\n        {\n            if( (c.toLower() in \"bcdfghjklmnpqrstvwxyz\"\
    ) && (c.toLower() !in \"aeiou\") )\n            {\n                consonants++;\n\
    \            }\n        }\n        if(consonants == n)\n        {\n          \
    \  res ~= w;\n        }\n    }\n    return res;\n}", "{\n    string[] words =\
    \ s.split();\n    string[] result;\n    long count = 0;\n    foreach(string word;\
    \ words) {\n        count = 0;\n        foreach(char c; word) {\n            if\
    \ (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n               \
    \ count++;\n        }\n        if (word.length - count == n)\n            result\
    \ ~= word;\n    }\n    return result;\n}", "{\n    string[] words = s.split;\n\
    \    words = words.retain!((w) => w.filter!(c => c != 'a' && c != 'e' && c !=\
    \ 'i' && c != 'o' && c != 'u').length == n);\n    return words;\n}", "{\n    return\
    \ [];\n}", "{\n    string[] words = split(s);\n    string[] consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string[] viebu_vards = new string[];\n    foreach(int i, ref string word;\
    \ words)\n    {\n        int viebu_sk = 0;\n        int consonants_length = consonants.length;\n\
    \        foreach(int j, ref char character; word)\n        {\n            foreach(int\
    \ k, ref char consonant; consonants)\n            {\n                if(character\
    \ == consonant)\n                {\n                    viebu_sk++;\n        \
    \        }\n            }\n        }\n        if(viebu_sk == n)\n        {\n \
    \           viebu_vards ~= word;\n        }\n    }\n    return viebu_vards;\n\
    }\n//string[] select_words(string s, long n) {\n    //string[] words = split(s);\n\
    \    //string[] consonants = \"bcdfghjklmnpqrstvwxyz\";\n    //string[] result\
    \ = new string[];\n    //foreach(int i, ref string word; words)\n    //{\n   \
    \     //int count = 0;\n        //foreach(int j, ref char character; word)\n \
    \       //{\n            //foreach(int k, ref char consonant; consonants)\n  \
    \          //{\n                //if(character == consonant)\n               \
    \ //{\n                    //count++;\n                //}\n            //}\n\
    \        //}\n        //if(count == n)\n        //{\n            //result ~= word;\n\
    \        //}\n    //}\n    //return result;\n//}", "{\n    string[] words = split(s);\n\
    \    string[] result;\n    foreach(idx, word; words)\n    {\n        if(consonants_in_string(word)\
    \ == n)\n        {\n            result ~= word;\n        }\n    }\n    return\
    \ result;\n}\nlong consonants_in_string(string s)\n{\n    long consonants = 0;\n\
    \    foreach(char c; s)\n    {\n        if(c !in ['a', 'e', 'i', 'o', 'u'])\n\
    \        {\n            consonants++;\n        }\n    }\n    return consonants;\n\
    }\n// from the book", "{\n    \n     string[] words = s.split;\n     string[]\
    \ result = [];\n     foreach(string word; words) {\n         long consonants =\
    \ word.countOf(c => !\"aeiou\".contains(c));\n         if(consonants == n)\n \
    \            result ~= word;\n     }\n     return result;\n}", "{\n    string[]\
    \ words = s.split(\" \");\n    return words.filter!(w => w.filter!(c => !\"aeiou\"\
    .contains(c)).length == n).array;\n}", "{\n    auto split = s.split(\" \");\n\
    \    string[] words = [];\n    foreach(word; split)\n    {\n        static string[]\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n        static string[] consonants\
    \ = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\
    \        int count = 0;\n        foreach(letter; word)\n        {\n          \
    \  if(vowels.canFind(letter))\n            {\n                count++;\n     \
    \       }\n        }\n        if(count == n)\n        {\n            words ~=\
    \ word;\n        }\n    }\n    return words;\n}", "{\n    string[] words = s.split(\"\
    \ \");\n    string[] consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    string[] res;\n    foreach(string word; words)\
    \ {\n        long count = 0;\n        foreach(wchar ch; word) {\n            if(consonants.contains(ch.toString().toLower()))\
    \ {\n                count++;\n            }\n        }\n        if(count == n)\
    \ {\n            res ~= word;\n        }\n    }\n    return res;\n}\n/*\nWrite\
    \ a function that calculates a discount price according to the following rules:\n\
    \    - If the cost is $0 or less, the cost remains $0.\n    - If the cost is greater\
    \ than $0 and less than $100, \n        the cost is reduced by 5%.\n    - If the\
    \ cost is $100 or more, the cost is reduced by 15%.\n*/\ndouble discount_price(double\
    \ cost)\n{\n    if(cost <= 0) {\n        return 0;\n    }\n    else if(cost >\
    \ 0 && cost < 100) {\n        return cost * 0.95;\n    }\n    else {\n       \
    \ return cost * 0.85;\n    }\n}\n/*\nDefine a function to concatenate the elements\
    \ of two tuple2s. The first tuple2 can have any type. \n    The second tuple2\
    \ must have elements of the same type as the first tuple2.\n    The return type\
    \ is the same as the first tuple2.\n    Note: you may assume the input will always\
    \ be a valid tuple2.\n    Examples:\n    >>> concat_tuple2(tuple(1, 2), tuple(3,\
    \ 4))\n    tuple(1, 2, 3, 4)\n    >>> concat_tuple2(tuple(\"a\", \"b\"), tuple(\"\
    c\", \"d\"))\n    tuple(\"a\", \"b\", \"c\", \"d\")\n    >>> concat_tuple2(tuple(1,\
    \ \"b\"),", "{\n    string[] result;\n    string word;\n    long consonants;\n\
    \    foreach(s.split)\n    {\n        word = toLower(s);\n        consonants =\
    \ 0;\n        foreach(word.split)\n        {\n            if(s != \"a\" && s !=\
    \ \"e\" && s != \"i\" && s != \"o\" && s != \"u\")\n            {\n          \
    \      consonants++;\n            }\n        }\n        if(consonants == n)\n\
    \        {\n            result ~= word;\n        }\n    }\n    return result;\n\
    }", "{\n    char[] vowels = \"aeiouAEIOU\".dup;\n    int consonants;\n    string[]\
    \ words;\n    string[] result;\n    foreach(word; split(s))\n    {\n        consonants\
    \ = 0;\n        foreach(ch; word)\n        {\n            if(vowels.count(ch)\
    \ == 0)\n            {\n                consonants++;\n            }\n       \
    \ }\n        if(consonants == n)\n        {\n            words ~= word;\n    \
    \    }\n    }\n    return words;\n}", "{\n    string[] words = split(s);\n   \
    \ string[] consonants = [\"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\"\
    , \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\"\
    , \"Y\", \"Z\"];\n    auto result = [];\n    foreach(word; words) \n    {\n  \
    \      long count = 0;\n        foreach(consonant; consonants) \n        {\n \
    \           count += countconsonants(word, consonant);\n        }\n        if(count\
    \ == n) \n        {\n            result ~= word;\n        }\n    }\n    return\
    \ result;\n}", "{\n    string[] res;\n    string[] words = split(s, \" \");\n\
    \    foreach(string word; words)\n    {\n        long numConsonants = 0;\n   \
    \     foreach(char ch; word)\n        {\n            if(!isVowel(ch))\n      \
    \          numConsonants++;\n        }\n        if(numConsonants == n)\n     \
    \       res ~= word;\n    }\n    return res;\n}", "{\n    string[] temp = split(s);\n\
    \    string[] ret;\n    foreach(string ss; temp)\n    {\n        if(countConsonants(ss)\
    \ == n)\n            ret ~= ss;\n    }\n    return ret;\n}", "{ \n    string[]\
    \ words = s.split(' ');\n    string[] result;\n    foreach(i, word; words)\n \
    \   {\n        if(n == consonantsCount(word))\n        {\n            result ~=\
    \ word;\n        }\n    }\n    return result;\n}", "{\n    string[] words = split(s,\
    \ \" \");\n    string[] result;\n    foreach(word; words)\n    {\n        auto\
    \ vowels = nVowels(word);\n        if (word.length - vowels == n)\n        {\n\
    \            result ~= word;\n        }\n    }\n    return result;\n}", "{\n \
    \   assert(n>=0);\n    auto words = split(s);\n    string[] result = [];\n   \
    \ foreach(w; words)\n    {\n        if(count_consonants(w) == n)\n           \
    \ result ~= w;\n    }\n    return result;\n}\nlong count_consonants(string w)\n\
    {\n    import std.algorithm : any;\n    long count = 0;\n    foreach(c; w)\n \
    \   {\n        if(c.isConsonant() && !c.isAny(' ', '\\t', '\\n'))\n          \
    \  count++;\n    }\n    return count;\n}", "{\n    int words = 0;\n    string[]\
    \ result = new string[5];\n    string[] temp = new string[5];\n    int[] num =\
    \ new int[5];\n    string[] s_split = split(s);\n    foreach(index, word; s_split)\n\
    \    {\n        int count = 0;\n        foreach(c; word)\n        {\n        \
    \    if(!is_vowel(c))\n            {\n                count++;\n            }\n\
    \        }\n        if(count == n)\n        {\n            temp[words] = word;\n\
    \            num[words] = count;\n            words++;\n        }\n    }\n   \
    \ words = 0;\n    int index = 0;\n    foreach(i; num)\n    {\n        if(i !=\
    \ 0)\n        {\n            result[index] = temp[words];\n            index++;\n\
    \        }\n        words++;\n    }\n    return result;\n}", "{ \n    string[]\
    \ sarr = s.split(\" \"); \n    string[] nconsonantwords; \n    foreach( word;\
    \ sarr) \n    { \n        if( word.count([\"a\",\"e\",\"i\",\"o\",\"u\",\"A\"\
    ,\"E\",\"I\",\"O\",\"U\"]) == n) \n        { \n            nconsonantwords ~=\
    \ word; \n        } \n    } \n    return nconsonantwords; \n} ", "{\n    static\
    \ immutable string vowels = \"aeiouAEIOU\";\n    auto words = s.split;\n    auto\
    \ consonants = \n        words.map!(a => a.chunks(ch => ch in vowels).filter!q{a.length\
    \ > 0}());\n    auto res = consonants.zip(words).filter!(a => a[0].length == n).map!(a\
    \ => a[1]);\n    return res;\n}", "{\n    bool isConsonant(char c)\n    {\n  \
    \      c = toUpper(c);\n        return c != 'A' && c != 'E' && c != 'I' && c !=\
    \ 'O' && c != 'U';\n    }\n    string[] words = s.split(\" \");\n    string[]\
    \ consonantWords;\n    foreach(word; words)\n    {\n        if(word.chars.filter!isConsonant.length\
    \ == n)\n        {\n            consonantWords ~= word;\n        }\n    }\n  \
    \  return consonantWords;\n}", "{ \n    string[] output = new string[0]; \n  \
    \  string[] words = split(s, \" \");\n    foreach(word; words) \n    { \n    \
    \    long consonants = 0; \n        foreach(letter; word) \n        { \n     \
    \       if (letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' ||\
    \ letter == 'u') \n            { \n                consonants = consonants + 1;\
    \ \n            } \n        } \n        if (consonants == n) \n        { \n  \
    \          output ~= word; \n        } \n    } \n    return output; \n} \n/*\n\
    \ Create a new ubyte[] by inserting the given number of zeros between each element\
    \ of the given array.\n    If the number of zeros is zero, the original array\
    \ is returned.\n    If the number of zeros is greater than zero, the returned\
    \ array is a new array, \n    it doesn't modify the original array.\n    >>> insert_zeros([11,\
    \ 13, 17, 19], 0)\n    [11, 13, 17, 19]\n    >>> insert_zeros([11, 13, 17, 19],\
    \ 2)\n    [11, 0, 0, 13, 0, 0, 17, 0, 0, 19]\n    >>> insert_zeros([11, 13, 17,\
    \ 19], 10)\n    [11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19]\n    >>> insert_zeros([], 5)\n    []\n*/\n\
    ubyte[] insert_zeros(in ubyte[] array, in long number_of_zeros) \n{ \n    if (number_of_zeros\
    \ <= 0) \n    { \n        return array; \n    } \n    ubyte[] output = new ubyte[array.length\
    \ * (number_of_zeros + 1)]; \n    long index = 0; \n    foreach(elem; array) \n\
    \    { ", "{\n    //int a = s.length;\n    int i = 0;\n    string[] words = s.split();\n\
    \    string[] str;\n    int[] arr1 = new int[words.length];\n    //int[] arr2\
    \ = new int[words.length];\n    foreach(string word; words)\n    {\n        //str\
    \ = word.split();\n        int ctr = 0;\n        foreach(char ch; word)\n    \
    \    {\n            if(ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch\
    \ != 'u')\n            {\n                ctr++;\n            }\n        }\n \
    \       arr1[i] = ctr;\n        i++;\n    }\n    //for(i = 0; i < words.length;\
    \ i++)\n    //{\n        //arr2[i] = arr1[i];\n    //}\n    //int l = arr1.length;\n\
    \    //arr1.sort();\n    //int j = 0;\n    //for(i = 0; i < l; i++)\n    //{\n\
    \        //if(arr1[i] == n)\n        //{\n            //arr2[j] = i;\n       \
    \     //j++;\n        //}\n    //}\n    //for(i = 0; i < l; i++)\n    //{\n  \
    \      //if(arr2[i] != 0)\n        //{\n            //writeln(words[arr2[i]]);\n\
    \        //}\n    //}\n    i = 0;\n    foreach(int k; arr1)\n    {\n        if(k\
    \ == n)\n        {\n            //arr2[i] = \n            //str = str~words[i];\n\
    \            str ~= words[i];\n            //i++;\n        }\n        i++;\n \
    \   }\n    return str;\n}", "{\n    import std.algorithm : filter, map;\n    import\
    \ std.array : array;\n    import std.typecons : tuple;\n    import std.conv :\
    \ to;\n    import std.string : split;\n    return s.split(' ').array\n       \
    \ .filter!((string word) => {\n            return word.filter!(ch => !\"aeiou\"\
    .contains(ch)).length == n;\n        })\n        .map!(word => tuple(word, word.length.to!long)).array;\n\
    }", "{\n    const string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    immutable\
    \ long strLen = s.length;\n    string[] result;\n    foreach(i; 0 .. strLen)\n\
    \    {\n        immutable long j = i;\n        immutable long consonantCount =\
    \ 0;\n        while(j < strLen && s[j] != ' ')\n        {\n            if(consonants.canFind(s[j]))\n\
    \                consonantCount++;\n            j++;\n        }\n        if(consonantCount\
    \ == n)\n        {\n            string newWord = s[i .. j];\n            result\
    \ ~= newWord;\n        }\n        i = j;\n    }\n    return result;\n}", "{\n\
    \    string[] words = s.split(\" \");\n    int count;\n    int[] newArr;\n   \
    \ foreach(index, word; words)\n    {\n        count = 0;\n        foreach(char;\
    \ word)\n        {\n            if(((char != 'a') && (char != 'e') && (char !=\
    \ 'i') && (char != 'o') && (char != 'u')) &&\n                ((char != 'A') &&\
    \ (char != 'E') && (char != 'I') && (char != 'O') && (char != 'U')))\n       \
    \     {\n                count++;\n            }\n        }\n        if(count\
    \ == n)\n        {\n            append(newArr, index);\n        }\n    }\n   \
    \ string[] res;\n    foreach(i; newArr)\n    {\n        res ~= words[i];\n   \
    \ }\n    return res;\n}", "{\n    return filter!(a => countConsonants(a) == n)(split(s,\
    \ \" \"));\n}", "{\n    immutable consonants = \"b,c,d,f,g,h,j,k,l,m,n,p,q,r,s,t,v,w,x,z\"\
    ;\n    immutable vowels = \"a,e,i,o,u,y\";\n    immutable word = split(s);\n \
    \   int [] word_count = new int[word.length];\n    int k = 0;\n    for(int i =\
    \ 0; i < word.length; i++)\n    {\n        string w = word[i];\n        foreach(char\
    \ c; w)\n        {\n            if(!consonants.canFind(c))\n            {\n  \
    \              k++;\n            }\n        }\n        if(k == n)\n        {\n\
    \            word_count[i]++;\n        }\n        k = 0;\n    }\n    string[]\
    \ result = new string[word_count.length];\n    k = 0;\n    for(int i = 0; i <\
    \ word_count.length; i++)\n    {\n        if(word_count[i] != 0)\n        {\n\
    \            result[k] = word[i];\n            k++;\n        }\n    }\n    return\
    \ result;\n}", "{\n    string[] v = s.split(\" \");\n    string[] res;\n    foreach(i,\
    \ w; v)\n    {\n        if(vowels(w) == n)\n            res ~= w;\n    }\n   \
    \ return res;\n}\n/*\n    Count the number of consonants in the word.\n*/\nlong\
    \ vowels(string word)\n{\n    string consonants = \"bcdfghjklmnpqrstvwxyz\";\n\
    \    long res = 0;\n    foreach(i, c; word)\n    {\n        foreach(j, char; consonants)\n\
    \        {\n            if(c == char)\n                res += 1;\n        }\n\
    \    }\n    return res;\n}", "{\n    char[] vowels = \"aeiouAEIOU\".dup;\n   \
    \ string[] words = s.split(\" \");\n    string[] output;\n    foreach(string word;\
    \ words)\n    {\n        long nConsonants = 0;\n        foreach(char letter; word)\n\
    \        {\n            if(!letter.canFind(vowels))\n                nConsonants++;\n\
    \        }\n        if(nConsonants == n)\n            output ~= word;\n    }\n\
    \    return output;\n}", "{\n    string[] r=split(s);\n    string[] result;\n\
    \    int j=0;\n    foreach(i;r)\n    {\n        int c=0;\n        foreach(char\
    \ d;i)\n        {\n            if(d=='a'||d=='e'||d=='i'||d=='o'||d=='u')\n  \
    \          {\n                c++;\n            }\n        }\n        if(c==n)\n\
    \        {\n            result[j]=i;\n            j++;\n        }\n    }\n   \
    \ return result;\n}", "{\n    //long consonants = n;\n    string[] array = split(s,\
    \ \" \");\n    string[] new_array;\n    long count = 0;\n    foreach(string x;\
    \ array)\n    {\n        long consonants = 0;\n        foreach(string i; to!string(x))\n\
    \        {\n            if(i == \"b\" || i == \"c\" || i == \"d\" || i == \"f\"\
    \ || i == \"g\" || i == \"h\" || i == \"j\" || i == \"k\" || i == \"l\" || i ==\
    \ \"m\" || i == \"n\" || i == \"p\" || i == \"q\" || i == \"r\" || i == \"s\"\
    \ || i == \"t\" || i == \"v\" || i == \"w\" || i == \"x\" || i == \"y\" || i ==\
    \ \"z\")\n            {\n                consonants++;\n            }\n      \
    \  }\n        if(consonants == n)\n        {\n            new_array ~= x;\n  \
    \      }\n    }\n    return new_array;\n}", "{\n    import std.array;\n    auto\
    \ words = split(s);\n    string[] result;\n    foreach(word; words)\n    {\n \
    \       int count = 0;\n        foreach(c; word)\n        {\n            if( c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y')\n      \
    \      {\n                continue;\n            }\n            count++;\n   \
    \     }\n        if(count == n)\n        {\n            result ~= word;\n    \
    \    }\n    }\n    return result;\n}", "{\n    long nSeq = n;\n    string[] arr;\n\
    \    string[] arrSeq;\n    string sSeq;\n    int nCount;\n    int nCountSeq;\n\
    \    foreach(i,c;s)\n    {\n        if(c==' ')\n        {\n            arr ~=\
    \ arrSeq;\n            nSeq = n;\n            arrSeq = null;\n        }\n    \
    \    else\n        {\n            if(c!='a' && c!='e' && c!='i' && c!='o' && c!='u')\n\
    \            {\n                if(nSeq > 0)\n                {\n            \
    \        arrSeq ~= c;\n                    nSeq--;\n                }\n      \
    \      }\n        }\n    }\n    if(arrSeq.length!=0)\n    {\n        arr ~= arrSeq;\n\
    \    }\n    int nIndex = 0;\n    foreach(i,s;arr)\n    {\n        if(s.length!=n)\n\
    \        {\n            arr[nIndex] = null;\n        }\n        nIndex++;\n  \
    \  }\n    return arr;\n}", "{\n    immutable Consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string[] res = [];\n    auto words = s.split;\n    foreach(ref word; words)\n\
    \    {\n        long count = 0;\n        foreach(l; word)\n        {\n       \
    \     foreach(c; Consonants)\n            {\n                if(c == l)\n    \
    \            {\n                    count += 1;\n                }\n         \
    \   }\n        }\n        if(count == n)\n        {\n            res ~= word;\n\
    \        }\n    }\n    return res;\n}", "{\n    string[] words = split(s);\n \
    \   return words.filter!(\n            (string w) => w.count!((char c) => !\"\
    aeiou\".canFind(c)) == n\n            );\n}", "{\n    string[] words = split(s,\
    \ \" \");\n    auto result = new string[];\n    foreach(w; words)\n    {\n   \
    \     if(std.algorithm.count(w, (c) => !isVowel(c)) == n)\n        {\n       \
    \     result ~= w;\n        }\n    }\n    return result;\n}", "{\n    \n    string[]\
    \ result;\n    string[] buffer = split(s);\n    foreach(string word; buffer)\n\
    \    {\n        if(count_consonants(word) == n)\n        {\n            result\
    \ ~= word;\n        }\n    }\n    return result;\n}", "{\n    string[] words =\
    \ split(s);\n    string[] word_with_n_consonants;\n    foreach(word; words)\n\
    \    {\n        long num_consonants = word.length - word.count(\"aAeEiIoOuUyY\"\
    );\n        if(num_consonants == n)\n        {\n            word_with_n_consonants\
    \ ~= word;\n        }\n    }\n    return word_with_n_consonants;\n}", "{\n   \
    \ string[] words = s.split();\n    return words.filter!(word => check_word(word,\
    \ n));\n}", "{\n    bool[] isVowel(string s){\n        bool[] isVowel = new bool[s.length];\n\
    \        foreach(i, char c; s){\n            isVowel[i] = c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u';\n        }\n        return isVowel;\n \
    \   }\n    string[] words(string s){\n        string[] words = split(s, ' ');\n\
    \        return words;\n    }\n    bool[] isVowelArray = isVowel(s);\n    string[]\
    \ arr = words(s);\n    for(int i = 0; i < isVowelArray.length; i++){\n       \
    \ if(isVowelArray[i]) arr.remove(arr[i]);\n    }\n    string[] consonants = new\
    \ string[arr.length];\n    return consonants;\n}", "{\n  immutable (char[]) vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n  immutable (string[]) words = s.split(' ');\n\
    \  immutable size_t len = words.length;\n  string[] result;\n  foreach(immutable\
    \ string word; words) \n  {\n    immutable size_t consonants = 0;\n    foreach(immutable\
    \ char c; word) \n    {\n      foreach(immutable char v; vowels) \n      {\n \
    \       if(c != v) \n        {\n          consonants++;\n        }\n      }\n\
    \    }\n    if(consonants == n) \n    {\n      result ~= word;\n    }\n  }\n \
    \ return result;\n}", "{\n    string[] words = s.split(\" \");\n    string[] res;\n\
    \    foreach(string w; words)\n    {\n        if(consonants(w) == n)\n       \
    \     res ~= w;\n    }\n    return res;\n}", "{\n    auto words = split(s);\n\
    \    auto consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n',\
    \ 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'];\n    words = words.filter!(word\
    \ => \n        {\n            int count = 0;\n            foreach(letter; word)\
    \ \n            {\n                if(consonants.canFind(letter)) \n         \
    \       {\n                    count++;\n                }\n            }\n  \
    \          return count == n;\n        }\n    );\n    return words;\n}", "{\n\
    \    string[] arr = s.split(\" \");\n    auto words = new string[];\n    long\
    \ i = 0;\n    foreach(str; arr) {\n        if(str.countConsonants == n) {\n  \
    \          words ~= str;\n        }\n    }\n    return words;\n}", "{\n    static\
    \ string[] cons = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"\
    z\"];\n    auto words = split(s);\n    string[] result;\n    foreach(word; words)\n\
    \    {\n        auto count = 0;\n        foreach(c;word)\n        {\n        \
    \    if(cons.canFind(c))\n                count++;\n        }\n        if(count\
    \ == n)\n            result ~= word;\n    }\n    return result;\n}", "{\n  size_t\
    \ i = 0;\n  string word;\n  string[] result;\n  while(i < s.length)\n  {\n   \
    \ if (s[i] != ' ')\n    {\n      word ~= s[i];\n    }\n    else\n    {\n     \
    \ long consonants = 0;\n      foreach(const char c; word)\n      {\n        if(tolower(c)\
    \ != 'a' && tolower(c) != 'e' && tolower(c) != 'i' && tolower(c) != 'o' && tolower(c)\
    \ != 'u')\n        {\n          consonants++;\n        }\n      }\n      if (consonants\
    \ == n)\n      {\n        result ~= word;\n      }\n      word = \"\";\n    }\n\
    \    i++;\n  }\n  if (word != \"\")\n  {\n    long consonants = 0;\n    foreach(const\
    \ char c; word)\n    {\n      if(tolower(c) != 'a' && tolower(c) != 'e' && tolower(c)\
    \ != 'i' && tolower(c) != 'o' && tolower(c) != 'u')\n      {\n        consonants++;\n\
    \      }\n    }\n    if (consonants == n)\n    {\n      result ~= word;\n    }\n\
    \  }\n  return result;\n}", "{\n    long length = s.length;\n    string[] arr\
    \ = new string[];\n    long sum=0;\n    for(long i=0;i<length;i++)\n    {\n  \
    \      if(isLetter(s[i]))\n        {\n            if(isVowel(s[i]))\n        \
    \    {\n                sum=0;\n            }\n            else\n            {\n\
    \                sum++;\n            }\n        }\n        else\n        {\n \
    \           if(sum==n)\n            {\n                arr ~= s[0..i];\n     \
    \       }\n            sum=0;\n        }\n    }\n    return arr;\n}", "{\n  if\
    \ (n < 0L) return null;\n  import std.algorithm : filter, map;\n  immutable words\
    \ = s.split(\" \");\n  return words.filter!(w => w.filter!(ch => ch.isAlpha &&\
    \ ch.isUpperCase).length == n).array;\n}", "{\n    string[] result;\n    immutable\
    \ char[] consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n',\
    \ 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'];\n    int count = 0;\n    string\
    \ word = \"\";\n    foreach(immutable char ch; s)\n    {\n        if(ch == ' ')\n\
    \        {\n            if(count == n)\n            {\n                result\
    \ ~= word;\n            }\n            count = 0;\n            word = \"\";\n\
    \        }\n        else\n        {\n            if(ch in consonants)\n      \
    \      {\n                count++;\n            }\n            word ~= ch;\n \
    \       }\n    }\n    if(count == n)\n    {\n        result ~= word;\n    }\n\
    \    return result;\n}", "{ \n    string[] sArray = split(s); \n    int index\
    \ = 0; \n    foreach(string ss; sArray) \n    { \n        int i = ss.countUntil(\"\
    a\"); \n        while(i > 0) \n        { \n            i = ss.countUntil(\"a\"\
    ,i+1); \n            if(i > 0) \n                ss = ss[0..i-1] ~ ss[i+1..ss.length];\
    \ \n        } \n        i = ss.countUntil(\"e\"); \n        while(i > 0) \n  \
    \      { \n            i = ss.countUntil(\"e\",i+1); \n            if(i > 0) \n\
    \                ss = ss[0..i-1] ~ ss[i+1..ss.length]; \n        } \n        i\
    \ = ss.countUntil(\"i\"); \n        while(i > 0) \n        { \n            i =\
    \ ss.countUntil(\"i\",i+1); \n            if(i > 0) \n                ss = ss[0..i-1]\
    \ ~ ss[i+1..ss.length]; \n        } \n        i = ss.countUntil(\"o\"); \n   \
    \     while(i > 0) \n        { \n            i = ss.countUntil(\"o\",i+1); \n\
    \            if(i > 0) \n                ss = ss[0..i-1] ~ ss[i+1..ss.length];\
    \ \n        } \n        i = ss.countUntil(\"u\"); \n        while(i > 0) \n  \
    \      { \n            i = ss.countUntil(\"u\",i+1); \n            if(i > 0) \n\
    \                ss = ss[0..i-1] ~ ss[i+1..ss.length]; \n        } \n        if(ss.length\
    \ == n) \n            sArray[index++] = ss; \n    } \n    return sArray[0..index-1];\
    \ \n} ", "{\n    if (s.length() == 0) return [];\n    string[] str = s.split();\n\
    \    string[] res = str.filter!(x => find_consonants(x) == n);\n    return res;\n\
    }", "{\n\tauto words = split(s);\n\tbool p;\n\tint i, c;\n\tstring[] result;\n\
    \tforeach(word; words)\n\t{\n\t\ti = 0;\n\t\tc = 0;\n\t\twhile(i < word.length)\n\
    \t\t{\n\t\t\tswitch(word[i])\n\t\t\t{\n\t\t\t\tcase 'a':\n\t\t\t\tcase 'e':\n\t\
    \t\t\tcase 'i':\n\t\t\t\tcase 'o':\n\t\t\t\tcase 'u':\n\t\t\t\t\tp = false;\n\t\
    \t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tp = true;\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t\tif(p) c++;\n\t\t\ti++;\n\t\t}\n\t\tif(c == n) result ~= word;\n\t}\n\treturn\
    \ result;\n}", "{ \n    return split(s, \" \").filter!(w => w.count!(c => 'a'\
    \ <= c && c <= 'z' && !isVowel(c)) == n).array;\n} ", "{\n     return s.split().filter!(w\
    \ => w.consonants.length == n).array;\n}", "{\n    string[] words = split(s, \"\
    \ \");\n    string[] list;\n    foreach(word; words)\n    {\n        if(countConsonants(word)\
    \ == n)\n        {\n            list ~= word;\n        }\n    }\n    return list;\n\
    }", "{\n    string[] vowels = ['a', 'e', 'i', 'o', 'u'];\n    string[] consonants\
    \ = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's',\
    \ 't', 'v', 'w', 'x', 'y', 'z'];\n    s = s.toLower();\n    string[] words = s.split(\"\
    \ \");\n    string[] temp;\n    string[] temp2;\n    for(int i = 0; i < words.length;\
    \ i++)\n    {\n        temp = words[i].split(vowels);\n        temp2 = temp.join('').split(consonants);\n\
    \        if(temp2.length - 1 != n)\n        {\n            temp2.splice(i, 1);\n\
    \        }\n    }\n    return temp2;\n}", "{\n    import std.algorithm;\n    import\
    \ std.range;\n    import std.array;\n    if(s.empty) return new string[0];\n \
    \   auto words = s.split(\" \");\n    auto consonants = ['b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'];\n\
    \    string[] res;\n    foreach(word; words)\n    {\n        ulong consonantCount\
    \ = 0;\n        foreach(letter; word)\n        {\n            if(consonants.canFind(letter))\n\
    \            {\n                consonantCount++;\n            }\n        }\n\
    \        if(consonantCount == n)\n        {\n            res ~= word;\n      \
    \  }\n    }\n    return res;\n}", "{\n    // auto s2 = s.toLower();\n    auto\
    \ arr = s.split;\n    long [] arr2 = arr.map!((x) => x.filter!(x => \"aeiouAEIOU\"\
    .indexOf(x) == -1).length).array;\n    long [] arr3 = arr.map!((x) => x.filter!(x\
    \ => x.isAlpha && x.isLower).length).array;\n    arr2.writeln;\n    arr3.writeln;\n\
    \    long [] arr4 = arr2.zip(arr3).map!((x) => x[0] / x[1]).array;\n    arr4.writeln;\n\
    \    // return arr4.zip(arr).filter!(x => x[0] == n).map!(x => x[1]).array;\n\
    \    return arr4.zip(arr).filter!(x => x[0] == n).map!(x => x[1]).array;\n}",
  "{\n    immutable vowel = \"aeiou\";\n    string[] res = split(s);\n    long len\
    \ = res.length;\n    string[] ret = new string[];\n    int j = 0;\n    foreach(i,\
    \ e; res)\n    {\n        int count = 0;\n        foreach(c; e)\n        {\n \
    \           if(!vowel.canFind(c))\n                count++;\n        }\n     \
    \   if(count == n)\n        {\n            ret ~= e;\n        }\n    }\n    return\
    \ ret;\n}", "{ \n    string[] words;\n    int len;\n    string word;\n    char[]\
    \ vowels = [ 'a', 'e', 'i', 'o', 'u' ];\n    int consonants;\n    string[] result;\n\
    \    words = split(s, \" \");\n    len = words.length;\n    result = [];\n   \
    \ for (int i = 0; i < len; i++) {\n        word = words[i];\n        consonants\
    \ = 0;\n        foreach (char ch; word) {\n            if (!vowels.canFind(ch))\
    \ {\n                consonants++;\n            }\n        }\n        if (consonants\
    \ == n) {\n            result ~= word;\n        }\n    }\n    return result;\n\
    }", "{\n    long letterCount = 0;\n    long wordCount = 0;\n    static if (is(n\
    \ == 1L)) \n    {\n        return s.split(\" \");\n    }\n    else \n    {\n \
    \       string[] words = s.split(\" \");\n        string[] ret = words[0..$];\n\
    \        foreach (index, word; words) \n        {\n            letterCount = 0;\n\
    \            foreach (letter; word) \n            {\n                if (letter.toUpper()\
    \ !in \"AEIOU\") \n                {\n                    letterCount++;\n   \
    \             }\n            }\n            if (letterCount != n) \n         \
    \   {\n                ret[index] = \"\";\n            }\n        }\n        return\
    \ ret.filter!(x => x.length != 0);\n    }\n}", "{\n    string[] words = split(s);\n\
    \    foreach(idx, word; words)\n    {\n        if(count_vowels(word) == n)\n \
    \       {\n            continue;\n        }\n        else\n        {\n       \
    \     words = words[0..idx] ~ words[idx+1..$];\n        }\n    }\n    return words;\n\
    }", "{\n    string[] answer;\n    string[] words = s.split(\" \");\n    foreach(i,\
    \ string word; words)\n    {\n        long num = 0;\n        foreach(char c; word)\n\
    \        {\n            switch(c)\n            {\n                case 'B':\n\
    \                case 'C':\n                case 'D':\n                case 'F':\n\
    \                case 'G':\n                case 'H':\n                case 'J':\n\
    \                case 'K':\n                case 'L':\n                case 'M':\n\
    \                case 'N':\n                case 'P':\n                case 'Q':\n\
    \                case 'R':\n                case 'S':\n                case 'T':\n\
    \                case 'V':\n                case 'W':\n                case 'X':\n\
    \                case 'Y':\n                case 'Z':\n                case 'b':\n\
    \                case 'c':\n                case 'd':\n                case 'f':\n\
    \                case 'g':\n                case 'h':\n                case 'j':\n\
    \                case 'k':\n                case 'l':\n                case 'm':\n\
    \                case 'n':\n                case 'p':\n                case 'q':\n\
    \                case 'r':\n                case 's':\n                case 't':\n\
    \                case 'v':\n                case 'w':\n                case 'x':\n\
    \                case 'y':\n                case 'z':\n                    num++;\n\
    \            }\n        }\n        if(num == n)\n        {\n            answer\
    \ ~= word;\n        }\n    }\n    return answer;\n}\n/*", "{\n    string[] words\
    \ = s.split(' ');\n    long count;\n    string[] result;\n    foreach(string word;\
    \ words)\n    {\n        count = 0;\n        foreach(char ch; word)\n        {\n\
    \            switch(ch)\n            {\n                case 'a': case 'e': case\
    \ 'i': case 'o': case 'u': case 'A': case 'E': case 'I': case 'O': case 'U': break;\n\
    \                default: count++; break;\n            }\n        }\n        if(count\
    \ == n)\n            result ~= word;\n    }\n    return result;\n}", "{\n    if\
    \ (n == 0) \n        return new string[];\n    if (n == 1) \n        return s.words.filter!(x\
    \ => x.countConsonants == 1).array;\n    if (n == 2) \n        return s.words.filter!(x\
    \ => x.countConsonants == 2).array;\n    return s.words.filter!(x => x.countConsonants\
    \ == n).array;\n}\n// void main() {\n//     auto str = \"Mary had a little lamb\"\
    ;\n//     auto res = select_words(str, 4L);\n//     assert(res == [\"little\"\
    ]);\n//     res = select_words(str, 3L);\n//     assert(res == [\"Mary\", \"lamb\"\
    ]);\n//     str = \"simple white space\";\n//     res = select_words(str, 2L);\n\
    //     assert(res == []);\n//     str = \"Hello world\";\n//     res = select_words(str,\
    \ 4L);\n//     assert(res == [\"world\"]);\n//     str = \"Uncle sam\";\n//  \
    \   res = select_words(str, 3L);\n//     assert(res == [\"Uncle\"]);\n// }", "{\n\
    \    import std.string : split;\n    immutable words = s.split(\" \");\n    immutable\
    \ consonants = \"bcdfghjklmnpqrstvwxyz\";\n    string[] result;\n    foreach(word;\
    \ words) \n    {\n        auto numConsonants = 0L;\n        foreach(letter; word)\
    \ \n        {\n            if(consonants.find(toLower(letter)) != -1) \n     \
    \       {\n                numConsonants++;\n            }\n        }\n      \
    \  if(numConsonants == n) \n        {\n            result ~= word;\n        }\n\
    \    }\n    return result;\n}", "{\n    string[] result = [];\n    int index =\
    \ 0;\n    int count = 0;\n    while(index < s.length)\n    {\n        if(s[index]\
    \ != ' ')\n        {\n            count++;\n        }\n        else\n        {\n\
    \            if(count == n)\n            {\n                result ~= s[0..index];\n\
    \            }\n            count = 0;\n            s = s[index+1..$];\n     \
    \       index = 0;\n        }\n        index++;\n    }\n    if(count == n)\n \
    \   {\n        result ~= s;\n    }\n    return result;\n}", "{\n\tstring[] res;\n\
    \tstring[] words;\n\tint num_cons = 0;\n\tif(s.length == 0)\n\t{\n\t\treturn res;\n\
    \t}\n\telse\n\t{\n\t\twords = s.split();\n\t\tforeach(word; words)\n\t\t{\n\t\t\
    \tnum_cons = 0;\n\t\t\tforeach(ch; word)\n\t\t\t{\n\t\t\t\tif(ch != 'a' && ch\
    \ != 'e' && ch != 'i' && ch != 'o' && ch != 'u')\n\t\t\t\t{\n\t\t\t\t\tnum_cons++;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\tif(num_cons == n)\n\t\t\t{\n\t\t\t\tres ~= word;\n\t\
    \t\t}\n\t\t}\n\t\treturn res;\n\t}\n}", "{\n    // We use default to avoid making\
    \ a copy of the elements.\n    string[] result = new string[](0);\n    // Split\
    \ the input string s into words.\n    string[] words = s.split();\n    // Iterate\
    \ over the words.\n    foreach (word; words) \n    {\n        // Count the consonants\
    \ in each word.\n        long count = 0;\n        foreach (c; word) \n       \
    \ {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ \n            {\n                count++;\n            }\n        }\n      \
    \  // Check if the word has n consonants.\n        if (count == n) \n        {\n\
    \            // In this case, save it in the result array.\n            result\
    \ ~= word;\n        }\n    }\n    return result;\n}", "{ \n    import std.algorithm;\n\
    \    import std.range;\n    auto result = [\"\"];\n    auto arr = s.split(\" \"\
    );\n    foreach(ele; arr)\n    {\n        if(ele.filter!(a => isLetter(a)).filter!(a\
    \ => a.tolower().isConsonant).length == n)\n        {\n            result ~= ele;\n\
    \        }\n    }\n    return result[1..$];\n}", "{\n    auto words = split(s,\
    \ ' ');\n    string[] res;\n    foreach(word; words) {\n        if(countConsonants(word)\
    \ == n) {\n            res ~= word;\n        }\n    }\n    return res;\n}", "{\n\
    \    string[] result;\n    int length = s.length;\n    bool[] consonants;\n  \
    \  int consonant_count;\n    string[] words;\n    foreach(w; s.split)\n    {\n\
    \        consonant_count = 0;\n        consonants = [true, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false];\n\
    \        foreach(c; w)\n        {\n            if(consonants[c] == true)\n   \
    \         {\n                consonant_count++;\n            }\n        }\n  \
    \      if(consonant_count == n)\n        {\n            result ~= w;\n       \
    \ }\n    }\n    return result;\n}\n//bool[] consonants = [true, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false];\n//string[] consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\",\
    \ \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n//string[] vowels = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"];", "{\n    string[] words = split(s, \" \");\n    string[] cons = [\"\
    B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"\
    P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    string[]\
    \ consonants = [];\n    string[] vowels = [];\n    string[] result = [];\n   \
    \ foreach(word; words)\n    {\n        consonants = [];\n        foreach(consonant;\
    \ cons)\n        {\n            if(count(word, consonant) != 0)\n            {\n\
    \                consonants ~= consonant;\n            }\n        }\n        if(consonants.length\
    \ == n)\n        {\n            result ~= word;\n        }\n    }\n    return\
    \ result;\n}", "{\n    string[] words = s.split(\"\\\\s+\");\n    string[] newwords\
    \ = []  ;\n    foreach(word; words)\n    {\n        long count = 0;\n        foreach(x;\
    \ word)\n        {\n            if(!(x == 'a' || x == 'e' || x == 'i' || x ==\
    \ 'o' || x == 'u' || x == 'A' || x == 'E' || x == 'I' || x == 'O' || x == 'U'))\n\
    \            {\n                count++;\n            }\n        }\n        if(count\
    \ == n)\n        {\n            newwords ~= word;\n        }\n    }\n    return\
    \ newwords;\n}\n/*\n    Given a string, implement a function that returns the\
    \ string with all spaces and \n    hyphens removed and with each word capitalized.\n\
    \    >>> capitalize(\"capitalize this\")\n    \"CapitalizeThis\"\n    >>> capitalize(\"\
    cApItAliZe ThIs\")\n    \"CapitalizeThis\"\n    >>> capitalize(\"hyphen-ated words\"\
    )\n    \"HyphenatedWords\"\n    >>> capitalize(\"already capitalized\")\n    \"\
    AlreadyCapitalized\"\n    >>> capitalize(\"whoops   spaces\")\n    \"WhoopsSpaces\"\
    \n*/\nstring capitalize(string s) \n{\n    string[] words = s.split(\"\\\\s+\"\
    );\n    string[] newwords = []  ;\n    foreach(word; words)\n    {\n        string\
    \ newword = \"\";\n        foreach(x; word)\n        {\n            if(x == '-')\n\
    \            {\n                continue;\n            }\n            newword\
    \ ~= x;\n        }\n        newwords ~= newword;\n    }\n    return newwords.join.capitalize.replace(\"\
    -\",\"\");\n}\n/*\n    Given an integer n, implement a function that prints the\
    \ first n positive integers \n    whose square roots are integers. For example,\
    \ if n=5, then the output should be:\n    1\n    4\n    9\n    16\n    25\n*/",
  "{\n    import std.array;\n    import std.range;\n    import std.algorithm;\n  \
    \  import std.string;\n    import std.typecons;\n    auto words = s.split(\" \"\
    );\n    //auto res = words.filter!(w => w.count(\"^aeiouAEIOU\") == n);\n    //\
    \ auto res = filter!(w => w.count(\"^aeiouAEIOU\") == n)(words);\n    string[]\
    \ res;\n    foreach(w; words) \n    {\n        if(w.count(\"^aeiouAEIOU\") ==\
    \ n)\n            res ~= w;\n    }\n    return res;\n}", "{\n    string[] words\
    \ = s.split(\" \");\n    immutable long vowels_count = 4;\n    string[] consonants_word\
    \ = [];\n    foreach(word; words)\n    {\n        long consonants_count = 0;\n\
    \        foreach(letter; word)\n        {\n            if (letter != 'a' && letter\
    \ != 'e' && letter != 'i' && letter != 'o' && letter != 'u')\n            {\n\
    \                consonants_count++;\n            }\n        }\n        if (consonants_count\
    \ == n)\n        {\n            consonants_word ~= word;\n        }\n    }\n \
    \   return consonants_word;\n}", "{\n    string[] arr = s.split(\" \");\n    string[]\
    \ res = new string[0];\n    foreach(var word; arr) {\n        string a = word.replace(\"\
    a\", \"\");\n        string e = a.replace(\"e\", \"\");\n        string i = e.replace(\"\
    i\", \"\");\n        string o = i.replace(\"o\", \"\");\n        string u = o.replace(\"\
    u\", \"\");\n        if(u.length == n) {\n            res ~= word;\n        }\n\
    \    }\n    return res;\n}", "{\n    import std.array;\n    import std.algorithm;\n\
    \    import std.range;\n    string[] words = [];\n    string[] consonants = [\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    words\
    \ = s.split(\" \");\n    string[] result = [];\n    foreach(word; words)\n   \
    \ {\n        long numOfConsonants = 0;\n        foreach(letter; word)\n      \
    \  {\n            foreach(consonant; consonants)\n            {\n            \
    \    if(letter == consonant)\n                {\n                    numOfConsonants++;\n\
    \                }\n            }\n        }\n        if(numOfConsonants == n)\n\
    \        {\n            result ~= word;\n        }\n    }\n    return result;\n\
    }", "{\n    string[] words = s.split(\" \");\n    auto consonants = tuple(\"bcdfghjklmnpqrstvwxyz\"\
    d);\n    string[] result;\n    foreach(w; words)\n    {\n        int count = 0;\n\
    \        foreach(c; w)\n        {\n            if(consonants.indexOf(c) != -1)\n\
    \                count++;\n        }\n        if(count == n)\n            result\
    \ ~= w;\n    }\n    return result;\n}\n/*\nGiven two strings s and t, return a\
    \ list of all unique strings in s,\n    that are also substrings of t. For the\
    \ purposes of this challenge,\n    a substring is any contiguous sequence of characters\
    \ within a string.\nExamples:\n>>> intersection(\"abc\", \"aabbc\")\n[\"a\", \"\
    b\", \"c\"]\n>>> intersection(\"def\", \"def\")\n[\"d\", \"e\", \"f\"]\n>>> intersection(\"\
    def\", \"abc\")\n[]\nNote: if an element occurs more than once in s and also in\
    \ t, \n    it should only appear once in the returned list.\n*/\nstring[] intersection(string\
    \ s, string t) \n{\n    string[] result;\n    foreach(c; s)\n    {\n        if(t.indexOf(c)\
    \ != -1 && result.indexOf(c) == -1)\n            result ~= c;\n    }\n    return\
    \ result;\n}\n/*\nGiven a list of integers nums, return a list of integers that\
    \ contain the same \n    digits as nums, but in reverse order.\nExamples:\n>>>\
    \ reverse_nums([1, 2, 3])\n[3, 2, 1]\n>>> reverse_nums([2, 3, 0, 5])\n[5, 0, 3,\
    \ 2]\n>>> reverse_nums([4, 7, 1, 5])\n[5, 1, 7, 4]\n*/\nlong[] reverse_nums(long[]\
    \ nums) \n{\n    long[] result;\n    foreach(n; nums)\n    {\n        result ~=\
    \ n.tostring.reverse.to!long;\n    }\n    return result;\n}\n/*\n", "{\n    string[]\
    \ words = split(s);\n    int count = 0;\n    foreach(word; words)\n    {\n   \
    \     //writeln(word);\n        foreach(c;word)\n        {\n            if(is_consonant(c))\n\
    \            {\n                count++;\n            }\n        }\n        if(count\
    \ != n)\n        {\n            words = words[0..$-1];\n        }\n        count\
    \ = 0;\n    }\n    return words;\n}", "{\n    string[] word_list;\n    word_list\
    \ = split(s);\n    string[] result;\n    foreach(word; word_list) \n    {\n  \
    \      if(word.consonants == n)\n        {\n            result ~= word;\n    \
    \    }\n    }\n    return result;\n}\nstruct Consonants {\n    long value;\n}\n\
    static import std.string;\nConsonants consonants(string s) {\n    string vowels\
    \ = \"aeiou\";\n    long consonants = 0;\n    foreach(character; s) {\n      \
    \  if(vowels.canFind(character)) {\n            consonants++;\n        }\n   \
    \ }\n    return Consonants(consonants);\n}\n/*\nstruct String {\n    String opBinaryRight(string\
    \ op : \"~\")() {\n        string[] result;\n        result ~= to!string;\n  \
    \      return result;\n    }\n}\n*/", "{\n    size_t[] indices_temp;\n    size_t[]\
    \ indices;\n    size_t index;\n    string[] result;\n    auto consonants = ['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    if (s == \"\")\n    {\n        return result;\n  \
    \  }\n    foreach (i; 0 .. s.length)\n    {\n        foreach (j; 0 .. consonants.length)\n\
    \        {\n            if (s[i] == consonants[j])\n            {\n          \
    \      indices_temp ~= i;\n            }\n        }\n    }\n    indices = remove(indices_temp);\n\
    \    foreach (i; 0 .. indices.length)\n    {\n        index = indices[i];\n  \
    \      while(true)\n        {\n            index = index + 1;\n            if\
    \ (s[index] == ' ')\n            {\n                break;\n            }\n  \
    \      }\n        result ~= s[indices[i] .. index];\n    }\n    for (int i = 0;\
    \ i < result.length; i++)\n    {\n        size_t count = 0;\n        for (int\
    \ j = 0; j < result[i].length; j++)\n        {\n            if (result[i][j] ==\
    \ ' ')\n            {\n                result[i] = \"\";\n                break;\n\
    \            }\n            else\n            {\n                if (result[i][j]\
    \ in consonants)\n                {\n                    count++;\n          \
    \      }\n            }\n        }\n        if (count != n)\n        {\n     \
    \       result[i] = \"\";\n        }\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
