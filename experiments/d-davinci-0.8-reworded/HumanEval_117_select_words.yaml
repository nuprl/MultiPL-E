name: HumanEval_117_select_words
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nGiven a string s and a natural\
  \ number n, you have been tasked to implement \n    a function that returns an array\
  \ of all words from string s that contain exactly \n    n consonants, in order these\
  \ words appear in the string s.\n    If the string s is empty then the function\
  \ should return an empty array.\n    Note: you may assume the input string contains\
  \ only letters and spaces.\n    Examples:\n    >>> select_words(\"Mary had a little\
  \ lamb\", 4L)\n    [\"little\"]\n    >>> select_words(\"Mary had a little lamb\"\
  , 3L)\n    [\"Mary\", \"lamb\"]\n    >>> select_words(\"simple white space\", 2L)\n\
  \    []\n    >>> select_words(\"Hello world\", 4L)\n    [\"world\"]\n    >>> select_words(\"\
  Uncle sam\", 3L)\n    [\"Uncle\"]\n    \n*/\nstring[] select_words(string s, long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = select_words;\n\n    assert(candidate(\"\
  Mary had a little lamb\", 4L) == [\"little\"]);\n    assert(candidate(\"Mary had\
  \ a little lamb\", 3L) == [\"Mary\", \"lamb\"]);\n    assert(candidate(\"simple\
  \ white space\", 2L) == []);\n    assert(candidate(\"Hello world\", 4L) == [\"world\"\
  ]);\n    assert(candidate(\"Uncle sam\", 3L) == [\"Uncle\"]);\n    assert(candidate(\"\
  \", 4L) == []);\n    assert(candidate(\"a b c d e f\", 1L) == [\"b\", \"c\", \"\
  d\", \"f\"]);\n}\nvoid main(){}"
completions: ["{\n    string[] arr;\n    if (s.length == 0) \n    {\n        return\
    \ [];\n    }\n    foreach (word; split(s)) \n    {\n        int count = 0;\n \
    \       foreach (letter; word) \n        {\n            if (letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u') \n            {\n\
    \                count += 1;\n            }\n        }\n        if (word.length\
    \ - count == n) \n        {\n            arr ~= word;\n        }\n    }\n    return\
    \ arr;\n}", "{\n\tstring[] splitted = s.split(\" \");\n\tchar[] vowels = {'a',\
    \ 'e', 'i', 'o', 'u', 'y'};\n\tint vowelsCnt = 0;\n\tint consonantsCnt = 0;\n\t\
    int length = 0;\n\tforeach(string word; splitted)\n\t{\n\t\tconsonantsCnt = 0;\n\
    \t\tvowelsCnt = 0;\n\t\tforeach(char c; word)\n\t\t{\n\t\t\tlength = vowels.length;\n\
    \t\t\tforeach(int i = 0; i < length; i++)\n\t\t\t{\n\t\t\t\tif(vowels[i] == c.tolower())\n\
    \t\t\t\t{\n\t\t\t\t\tvowelsCnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconsonantsCnt\
    \ = word.length - vowelsCnt;\n\t\tif(consonantsCnt == n)\n\t\t{\n\t\t\treturn\
    \ [word];\n\t\t}\n\t}\n\treturn [];\n}", "{\n    auto ret = new string[];\n  \
    \  auto ss = s.split(\" \");\n    foreach(i, ss) {\n        //std.stdio.writeln(i);\n\
    \        if(consonants(i) == n)\n            ret ~= i;\n    }\n    return ret;\n\
    }\nlong consonants(string s) \n{\n    import std.range;\n    return s.filter!(a\
    \ => \"aeiouyAEIOUY\".count(a.to!char) == 0).length;\n}\n/*\n// some tests for\
    \ consonants\nunittest\n{\n    //std.stdio.writeln(consonants(\"world\"));\n \
    \   assert(consonants(\"world\") == 3);\n    assert(consonants(\"Mary\") == 2);\n\
    \    assert(consonants(\"Uncle\") == 3);\n    assert(consonants(\"Hello\") ==\
    \ 3);\n    assert(consonants(\"sam\") == 2);\n    assert(consonants(\"little\"\
    ) == 3);\n    assert(consonants(\"lamb\") == 1);\n    assert(consonants(\"\")\
    \ == 0);\n}\n*/\n/*\nunittest\n{\n    assert(select_words(\"Mary had a little\
    \ lamb\", 4L) == [\"little\"]);\n    assert(select_words(\"Mary had a little lamb\"\
    , 3L) == [\"Mary\", \"lamb\"]);\n    assert(select_words(\"simple white space\"\
    , 2L) == []);\n    assert(select_words(\"Hello world\", 4L) == [\"world\"]);\n\
    \    assert(select_words(\"Uncle sam\", 3L) == [\"Uncle\"]);\n}\n*/", "{\n   \
    \ // write your code here\n    auto ret = [\"\"];\n    ret = [];\n    foreach(word;\
    \ s.split)\n    {\n        long count = 0;\n        foreach(char; word)\n    \
    \    {\n            if (char.isUpper())\n            {\n                count++;\n\
    \            }\n        }\n        if (count == n)\n        {\n            ret\
    \ ~= word;\n        }\n    }\n    return ret;\n}\n \n void main()\n {\n    auto\
    \ str = \"Mary had a little lamb\";\n    auto n = 4L;\n    auto str2 = \"simple\
    \ white space\";\n    auto str3 = \"Hello world\";\n    auto str4 = \"Uncle sam\"\
    ;\n    auto result = select_words(str, n);\n    auto result2 = select_words(str2,\
    \ 2L);\n    auto result3 = select_words(str3, 4L);\n    auto result4 = select_words(str4,\
    \ 3L);\n    writeln(result);\n    writeln(result2);\n    writeln(result3);\n \
    \   writeln(result4);\n }", "{\n    string[] arr;\n    string[] cons = [\"b\"\
    , \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"];\n    auto sp = s.split(\"\
    \ \");\n    foreach(word; sp) \n    {\n        int cons_count = 0;\n        foreach(letter;\
    \ word) \n        {\n            if(letter.toLower() in cons) \n            {\n\
    \                cons_count++;\n            }\n        }\n        if(cons_count\
    \ == n) \n        {\n            arr ~= word;\n        }\n    }\n    return arr;\n\
    }", "{ \n    string[] words;\n    words = split(s, \" \");\n    int len = words.length;\n\
    \    int count = 0;\n    int[] result;\n    string[] out;\n    foreach(i, word;\
    \ words)\n    {\n        count = 0;\n        foreach(j, char; word)\n        {\n\
    \            if (char == 'a' || char == 'e' || char == 'i' || char == 'o' || char\
    \ == 'u')\n            {\n                count++;\n            }\n        }\n\
    \        if (count == n)\n        {\n            result ~= i;\n        }\n   \
    \ }\n    foreach(k, num; result)\n    {\n        out ~= words[num];\n    }\n \
    \   return out;\n}", "{\n  import std.array : split;\n  import std.conv : to;\n\
    \  string[] stringArray = s.split(\" \");\n  string[] result = [];\n  foreach(string\
    \ item; stringArray) \n  {\n      long numberOfConsonants = 0;\n      string vowels\
    \ = \"aeiouAEIOU\";\n      foreach(char letter; item) \n      {\n        if(vowels.indexOf(letter)\
    \ == -1) \n          ++numberOfConsonants;\n      }\n      if(numberOfConsonants\
    \ == n) \n        result ~= item;\n  }\n  return result;\n}", "{\n    auto words\
    \ = std.algorithm.split(s, std.predicate!((c) => c == ' '));\n    return words.filter!((w)\
    \ => w.filter!((c) => c.isConsonant).length == n).array;\n}", "{\n    int[] result;\n\
    \    immutable(string)[] words = split(s);\n    // immutable(string)[] words =\
    \ s.split();\n    foreach(immutable(string) word; words)\n    {\n        int sum\
    \ = 0;\n        foreach(immutable(char) c; word)\n        {\n            bool\
    \ isVowel = (\n                c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u'\n            );\n            if (!isVowel)\n            {\n       \
    \         sum++;\n            }\n        }\n        if (sum == n)\n        {\n\
    \            result ~= word;\n        }\n    }\n    return result;\n}", "{\n \
    \   string[] arr = split(s, \" \");\n    immutable(string)[] result = [];\n  \
    \  foreach(it;arr)\n    {\n        if(count(it) == n) result ~= it;\n    }\n \
    \   return result;\n}\nlong count(string s)\n{\n    long consonants = 0;\n   \
    \ foreach(it;s)\n    {\n        if(!isVowel(it)) consonants++;\n    }\n    return\
    \ consonants;\n}", "{\n    return split(s,\" \").filter!(i => numConsonants(i)\
    \ == n).array;\n}", "{\n    enum vowels = \"aeiouAEIOU\";\n    string[] result;\n\
    \    if(s.empty) {\n        return result;\n    }\n    else {\n        string[]\
    \ words = s.split;\n        foreach(word; words) {\n            long count = 0;\n\
    \            foreach(ch; word) {\n                count += vowels.indexOf(ch)\
    \ == -1 ? 1 : 0;\n            }\n            if(count == n) {\n              \
    \  result ~= word;\n            }\n        }\n        return result;\n    }\n\
    }\n/*\n    Calling a function is given a list of std.typecons.Tuple!(long, long)\
    \ coordinates \n    and std.math.Matrix!doubles matrix you have to implement a\
    \ function that \n    returns a value at a matrix element, specified by given\
    \ coordinates. \n    Your function should throw an exception if the coordinates\
    \ are out of range.\n    Example:\n    >>> matrix = [\n            [1, 2, 3],\n\
    \            [4, 5, 6],\n            [7, 8, 9]\n        ];\n    >>> coordinates\
    \ = [\n            Tuple!(long, long)(0, 0),\n            Tuple!(long, long)(1,\
    \ 2),\n            Tuple!(long, long)(2, 2)\n        ];\n    >>> get_elements_at_coordinates(coordinates,\
    \ matrix)\n    [1, 6, 9]\n*/", "{\n    string[] words = split(s);\n    auto res\
    \ = words.filter!(a => getConsonantsCount(a) == n);\n    return res;\n}", "{ \n\
    \  int count;\n  string[] words = split(s);\n  string[] ret;\n  foreach(string\
    \ word; words)\n  {\n    count = 0;\n    foreach(char c; word)\n    {\n      switch(c)\n\
    \      {\n        case 'a':\n        case 'e':\n        case 'i':\n        case\
    \ 'o':\n        case 'u':\n        case 'A':\n        case 'E':\n        case\
    \ 'I':\n        case 'O':\n        case 'U':\n          continue;\n        default:\n\
    \          count++;\n      }\n    }\n    if(count == n)\n      ret ~= word;\n\
    \  }\n  return ret;\n}\n ", "{\n    string[] c = s.split();\n    int consonants_count;\n\
    \    string[] arr;\n    foreach(string word; c) {\n        consonants_count =\
    \ 0;\n        foreach(char ch; word) {\n            if (ch in ['a', 'e', 'i',\
    \ 'o', 'u', 'y']) {\n                ++consonants_count;\n            }\n    \
    \    }\n        if (consonants_count == n) {\n            arr ~= word;\n     \
    \   }\n    }\n    return arr;\n}", "{\n    string[] words = s.split;\n    //string[]\
    \ cons;\n    string[] cons = new string[words.length];\n    int k = 0;\n    foreach(char\
    \ c; words)\n    {\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n        {\n            cons[k] = c;\n            k++;\n        }\n\
    \        else\n        {\n            continue;\n        }\n    }\n    return\
    \ cons;\n}", "{\n    assert(n > 0L);\n    auto words = split(s, ' ');\n    return\
    \ words.filter!(w => w.count!(c => \"aeiouAEIOU\".count(c) == 0) == n);\n}", "{\n\
    \    string[] arr = split(s);\n    string[] res;\n    res.length = 0;\n    foreach(string\
    \ i; arr)\n    {\n        if(consonants_in_string(i) == n)\n        {\n      \
    \      res ~= i;\n        }\n    }\n    return res;\n}\n/*\n    Given a string\
    \ s, return a lowercased string, \n    where all occurrences of the upper case\
    \ letter have been replaced with the lower case version.\n*/\nstring lowercase(string\
    \ s)\n{\n    auto arr = toLower(s);\n    string res;\n    foreach(char i; arr)\n\
    \    {\n        res ~= i;\n    }\n    return res;\n}\n/*\n    Given a string s\
    \ and an array of pairs of indices in the string, \n    return the string with\
    \ all characters in the indices [i, j] replaced by the character at j index.\n\
    \    Examples:\n    >>> replace_indices(\"abacaba\", [[3, 4], [4, 2], [4, 6]])\n\
    \    \"abacacb\"\n    >>> replace_indices(\"a\", [[0, 0], [0, 0]])\n    \"a\"\n\
    \    >>> replace_indices(\"abacaba\", [[0, 1], [0, 1]])\n    \"bacaba\"\n    >>>\
    \ replace_indices(\"abacaba\", [[4, 4], [3, 4]])\n    \"abacaca\"\n*/\nstring\
    \ replace_indices(string s, int[][] indices)\n{\n    string res;\n    foreach(i;\
    \ indices)\n    {\n        s[i[0]] = s[i[1]];\n    }\n    return s;\n}\n/*\n \
    \   Given a string s, return a string where all occurrences of its first char\
    \ have been changed to '*', except do not change the first char itself.\n    You\
    \ may assume that the string is length 1 or more.\n    Examples:\n    >>> fix_start(\"\
    babble\")\n    \"ba**le\"\n    >>> fix_start(\"google\")\n    \"goo*le\"\n   \
    \ >>> fix_start(\"donut\")\n    \"donut\"\n*/\nstring", "{\n    string[] words\
    \ = split(s, \" \");\n    string[] result;\n    foreach(ref string word; words)\n\
    \    {\n        if(countConsonants(word) == n)\n        {\n            result\
    \ ~= word;\n        }\n    }\n    return result;\n}\nlong countConsonants(string\
    \ s)\n{\n    long result = 0;\n    foreach(char c; s)\n    {\n        if(isConsonant(c))\n\
    \        {\n            result += 1;\n        }\n    }\n    return result;\n}",
  "{\n    return filter!(a => countConsonants(a) == n)(split(s, \" \")).array;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
