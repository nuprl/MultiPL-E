name: HumanEval_159_eat
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You're a hungry rabbit,\
  \ and you already have eaten a certain number of carrots,\n    but now you need\
  \ to eat more carrots to complete the day's meals.\n    you should return an array\
  \ of [ total number of eaten carrots after your meals,\n                       \
  \             the number of carrots left after your meals ]\n    if there are not\
  \ enough remaining carrots, you will eat all remaining carrots, but will still be\
  \ hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>>\
  \ eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n   \
  \ >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n\
  \        the number of carrots that you have eaten.\n    @need : integer\n     \
  \   the number of carrots that you need to eat.\n    @remaining : integer\n    \
  \    the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
  \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
  \n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining)\
  \ \n"
tests: "unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
  \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
  \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n  \
  \  assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L)\
  \ == [5L, 0L]);\n}\nvoid main(){}"
completions: ["{\n    // your code here\n    import std.stdio;\n    long[] tuple;\n\
    \    return tuple = [need+number,remaining-need];\n    \n    \n    \n    \n}",
  "{\n    return [min(need, remaining) + number, max(0L, remaining - need)];\n}",
  "{\n    assert(number >= 0 && number <= 1000);\n    assert(need >= 0 && need <=\
    \ 1000);\n    assert(remaining >= 0 && remaining <= 1000);\n    if(remaining ==\
    \ 0)\n        return [number, 0];\n    else if(need > remaining)\n        return\
    \ [number + remaining, 0];\n    else\n        return [number + need, remaining\
    \ - need];\n}", "{\n    long [] result = new long[2];\n    if(need > remaining)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    else\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    return result;\n}", "{\n    if (number > 1000L || need >\
    \ 1000L || remaining > 1000L || number < 0L || need < 0L || remaining < 0L)\n\
    \        throw new Exception(\"Variables should be in this range: [0..1000]\"\
    );\n    if (remaining == 0L)\n        return new long[] {need, remaining};\n \
    \   if (need == 0L)\n        return new long[] {number, remaining};\n    if (remaining\
    \ >= need)\n        return new long[] {number + need, remaining - need};\n   \
    \ return new long[] {number + remaining, 0L};\n}", "{\n    if (need < remaining)\
    \ {\n        return [number + need, remaining - need];\n    }\n    else {\n  \
    \      return [number + remaining, 0];\n    }\n}", "{\n    auto eat= [](auto number,\
    \ auto need, auto remaining) {\n        return tuple(number + min(need, remaining),\
    \ max(remaining - need, 0L));\n    };\n    return unpack(eat(number, need, remaining));\n\
    }", "{\n    // your code\n    auto result = tuple(number + min(need, remaining),\
    \ max(0L, remaining - need));\n    return result.expand;\n}", "{\n    return [\
    \ clamp(need + number, 0L, remaining),\n             max(remaining - need - number,\
    \ 0L) ];\n}", "{\n    auto t = tuple(number + need, remaining - need);\n    if\
    \ (t[1] < 0) {\n        t[0] = t[0] + t[1];\n        t[1] = 0;\n    }\n    return\
    \ t;\n}", "{\n    long total = 0;\n    if (need + number <= remaining) {\n   \
    \     total = need + number;\n        remaining -= total;\n    } else {\n    \
    \    total = remaining;\n        remaining = 0;\n    }\n    return new long[]\
    \ { total, remaining };\n}\n/*\n    First attempt at solution. The code is redundant\
    \ and can probably be\n    written more concisely.\n*/\nlong[] eat(long number,\
    \ long need, long remaining) \n{\n    if (number >= remaining) {\n        return\
    \ new long[] { remaining, 0 };\n    }\n    if (number + need <= remaining) {\n\
    \        return new long[] { number + need, remaining - (number + need) };\n \
    \   }\n    return new long[] { remaining, 0 };\n}\n/*\n    This was my first attempt\
    \ at this code. It was a bit convoluted, and\n    more than likely would not have\
    \ worked.\n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ retVal = new long[2];\n    if (number >= remaining) {\n        return new long[]\
    \ { remaining, 0 };\n    }\n    retVal[0] = (number + need <= remaining) ? number\
    \ + need : remaining;\n    retVal[1] = (number + need <= remaining) ? remaining\
    \ - (number + need) : 0;\n    return retVal;\n}\n/*\n    This was my first attempt\
    \ at this code. It was a bit convoluted, and\n    more than likely would not have\
    \ worked.\n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[]\
    \ retVal = new long[2];\n    retVal[0] = (number + need <= remaining) ? number\
    \ + need : remaining;\n    retVal[1] = (number + need <= remaining) ? remaining\
    \ - (number + need) : 0;\n    return retVal;\n}\n/*\n    This was my first attempt\
    \ at this code. It was a bit convoluted, and\n    more than likely would not have\
    \ worked.\n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long\
    \ total = (number + need <= remaining) ? number + need : remaining;\n    return\
    \ new long[] { total", "{\n    bool isHungry = false;\n    if(remaining < need)\n\
    \    {\n        isHungry = true;\n        need = remaining;\n    }\n    return\
    \ isHungry ? tuple(number + need, 0L) : tuple(number + need, remaining - need);\n\
    }", "{\n    return remaining > 0 ? [c(need, remaining), d(need, remaining)] :\
    \ [remaining, need];\n}\nlong c(long a, long b) => a > b ? a : b;\nlong d(long\
    \ a, long b) => a > b ? a - b : 0;", "{\n    // Your code here\n    long m = number\
    \ + need;\n    if(remaining >= m)\n        return tuple(m, remaining - m);\n \
    \   else\n        return tuple(remaining + number, 0);\n    \n}", "{\n    // eat\
    \ all remaining carrots\n    long leftover = remaining - need;\n    // not enough\
    \ carrots left\n    if (leftover < 0) \n    {\n        return [need, remaining\
    \ - need];\n    }\n    return [number + need, leftover];\n}", "{\n    return need\
    \ <= remaining ? [number + need, remaining - need] : [number + remaining, 0];\n\
    }", "{\n    if (need >= remaining) return [remaining + number, 0L];\n    return\
    \ [need + number, remaining - need];\n}\n```", "{\n    if (need > remaining)\n\
    \        return [ number + remaining, 0 ];\n    else\n        return [ number\
    \ + need, remaining - need ];\n}", "{\n    long count;\n    if (need > remaining)\
    \ \n    {\n        count = need - remaining;\n        return tuple(number + remaining,\
    \ count);\n    }\n    return tuple(number + need, 0L);\n}", "{\n    return [min(need+number,\
    \ remaining), max(0L,remaining-(need+number))];\n}\n```"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
