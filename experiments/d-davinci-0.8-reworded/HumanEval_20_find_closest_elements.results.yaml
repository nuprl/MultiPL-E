language: d
name: HumanEval_20_find_closest_elements
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    double min = double.max;\n    size_t minIndex = 0;\n    size_t len\
    \ = numbers.length;\n    for (size_t i = 0; i < len; i++) \n    {\n        if\
    \ (i + 1 < len) \n        {\n            double newDiff = abs(numbers[i] - numbers[i\
    \ + 1]);\n            if (newDiff < min) \n            {\n                min\
    \ = newDiff;\n                minIndex = i;\n            }\n        }\n    }\n\
    \    return tuple(numbers[minIndex], numbers[minIndex + 1]);\n}\nunittest\n{\n\
    \    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd24my8g3.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e15]

    ??:? void tmpd24my8g3.__unittest_L31_C1() [0x428e81]

    ??:? void tmpd24my8g3.__modtest() [0x42987c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb27]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43235d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43280c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4322e9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da0d]

    ??:? runModuleUnitTests [0x42e8fd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a2d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float[] args = numbers[1..$];\n    float smallest_diff = args[0] -\
    \ numbers[0];\n    float[] smallest_tuple = [numbers[0], args[0]];\n    float\
    \ smallest_diff_abs = abs(smallest_diff);\n    for (size_t i = 0; i < numbers.length\
    \ - 1; i++) \n    {\n        for (size_t j = i + 1; j < numbers.length; j++) \n\
    \        {\n            float diff = numbers[i] - numbers[j];\n            float\
    \ diff_abs = abs(diff);\n            if (diff_abs < smallest_diff_abs) \n    \
    \        {\n                smallest_diff = diff;\n                smallest_diff_abs\
    \ = diff_abs;\n                smallest_tuple = [numbers[i], numbers[j]];\n  \
    \          }\n        }\n    }\n    float[] sorted_tuple = sort(smallest_tuple);\n\
    \    return tuple(sorted_tuple[0], sorted_tuple[1]);\n}\nunittest\n{\n    alias\
    \ candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) ==\
    \ tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0,\
    \ 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvnzy74fa.d(32): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvnzy74fa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float diff = 99999;\n    float lower = 99999;\n    float higher = 99999;\n\
    \    int i = 0;\n    foreach(float x; numbers) \n    {\n        if(i != numbers.length-1)\
    \ \n        {\n            float newdiff = abs(x - numbers[i+1]);\n          \
    \  if(newdiff < diff) \n            {\n                diff = newdiff;\n     \
    \           lower = min(x, numbers[i+1]);\n                higher = max(x, numbers[i+1]);\n\
    \            }\n        }\n        i++;\n    }\n    return tuple(lower, higher);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvk331p4r.d(26): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpvk331p4r.d(27): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvk331p4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float minDist = float.infinity;\n    Tuple!(float, float) result =\
    \ tuple(0.0, 0.0);\n    foreach(i, a; numbers)\n    {\n        foreach(j, b; numbers)\n\
    \        {\n            if(i != j)\n            {\n                float dist\
    \ = abs(a - b);\n                if(dist < minDist)\n                {\n     \
    \               minDist = dist;\n                    result = tuple(min(a, b),\
    \ max(a, b));\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n  \
    \  assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n   \
    \ assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppld7f7oh.d(26): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmppld7f7oh.d(26): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppld7f7oh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    int n = numbers.length;\n    float[]\
    \ distance = new float[n];\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpair48g3b.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpair48g3b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    //asume that numbers is not empty\n    float min = abs(numbers[0] -\
    \ numbers[1]);\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n \
    \   int size = numbers.length;\n    for (int i = 0; i < size - 1; i++)\n    {\n\
    \        for (int j = i + 1; j < size; j++)\n        {\n            float temp\
    \ = abs(numbers[i] - numbers[j]);\n            if (temp < min)\n            {\n\
    \                min = temp;\n                num1 = numbers[i];\n           \
    \     num2 = numbers[j];\n            }\n        }\n    }\n    if (num1 > num2)\n\
    \    {\n        float temp = num1;\n        num1 = num2;\n        num2 = temp;\n\
    \    }\n    return tuple(num1, num2);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmorh7i46.d(18): Error: cannot implicitly convert expression `numbers.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmorh7i46.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    auto diff_max = 1.0e20;\n    auto diff_min = 1.0e20;\n    auto diff_max_min\
    \ = 1.0e20;\n    float num1 = 0.0;\n    float num2 = 0.0;\n    float num1_max\
    \ = 0.0;\n    float num2_max = 0.0;\n    float num1_min = 0.0;\n    float num2_min\
    \ = 0.0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        for (int\
    \ j = 0; j < numbers.length; j++)\n        {\n            if (i != j)\n      \
    \      {\n                diff_max = max(numbers[i], numbers[j]);\n          \
    \      diff_min = min(numbers[i], numbers[j]);\n                if ((diff_max\
    \ - diff_min) < diff_max_min)\n                {\n                    diff_max_min\
    \ = diff_max - diff_min;\n                    num1_max = numbers[i];\n       \
    \             num2_max = numbers[j];\n                    num1_min = numbers[i];\n\
    \                    num2_min = numbers[j];\n                }\n            }\n\
    \        }\n    }\n    return tuple(num1_min, num2_min);\n}\nunittest\n{\n   \
    \ alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr6flcarf.d(29): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpr6flcarf.d(30): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr6flcarf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float small_difference = float.max;\n    float a = 0.0;\n    float\
    \ b = 0.0;\n    foreach(i, num; numbers) \n    {\n        // start at the next\
    \ element, stop when we have looked at all elements\n        foreach_i (j, end)\
    \ \n        {\n            if (j > i) \n            {\n                // for\
    \ each pair of numbers calculate the difference\n                float difference\
    \ = abs(num - numbers[j]);\n                // if this difference is less than\
    \ the previous minimum, update the minimum\n                if (difference < small_difference)\
    \ \n                {\n                    small_difference = difference;\n  \
    \                  a = num;\n                    b = numbers[j];\n           \
    \     }\n            }\n        }\n    }\n    return tuple(a, b);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv3e8q2a8.d(21): Error: found `{` when expecting `;` following statement

    /tmp/tmpv3e8q2a8.d(36): Error: declaration expected, not `return`

    /tmp/tmpv3e8q2a8.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv3e8q2a8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min_distance = 1000000.0;\n    Tuple!(float, float) closest_elements;\n\
    \    foreach(i, number; numbers)\n    {\n        foreach(j, other_number; numbers)\n\
    \        {\n            if(other_number > number)\n            {\n           \
    \     float distance = other_number - number;\n                if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         closest_elements = tuple(number, other_number);\n                }\n\
    \            }\n        }\n    }\n    return closest_elements;\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0elmr1h6.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f2d]

    ??:? void tmp0elmr1h6.__unittest_L33_C1() [0x428edd]

    ??:? void tmp0elmr1h6.__modtest() [0x429994]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ee93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dda2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4326c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dd79]

    ??:? runModuleUnitTests [0x42ec69]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a408]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float closest = 1000;\n    float[] result = null;\n    foreach(float\
    \ element1; numbers)\n    {\n        foreach(float element2; numbers)\n      \
    \  {\n            if(element1 == element2) continue;\n            float distance\
    \ = abs(element1 - element2);\n            if(distance < closest)\n          \
    \  {\n                closest = distance;\n                result = [element1,\
    \ element2];\n            }\n        }\n    }\n    return tuple(result[0], result[1]);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphpgcar_m.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e5d]

    ??:? void tmphpgcar_m.__unittest_L31_C1() [0x428ecd]

    ??:? void tmphpgcar_m.__modtest() [0x4298c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb6f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432854]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432331]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da55]

    ??:? runModuleUnitTests [0x42e945]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a320]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float minDistance = DBL_MAX;\n  \
    \  Tuple!(float, float) result;\n    for (int i = 0; i < numbers.length - 1; i++)\n\
    \    {\n        for (int j = i + 1; j < numbers.length; j++)\n        {\n    \
    \        float dist = abs(numbers[i] - numbers[j]);\n            if (dist < minDistance)\n\
    \            {\n                minDistance = dist;\n                result =\
    \ tuple(numbers[i], numbers[j]);\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n  \
    \  assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n   \
    \ assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnp2sanfa.d(15): Error: undefined identifier `DBL_MAX`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnp2sanfa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float diff;\n    float mindiff = INFINITY;\n    int i = 0;\n    int\
    \ j = 1;\n    for (i = 0; i < numbers.length - 1; i++)\n    {\n        for (j\
    \ = i + 1; j < numbers.length; j++)\n        {\n            diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < mindiff)\n            {\n           \
    \     mindiff = diff;\n            }\n        }\n    }\n    float ret1;\n    float\
    \ ret2;\n    for (i = 0; i < numbers.length - 1; i++)\n    {\n        for (j =\
    \ i + 1; j < numbers.length; j++)\n        {\n            diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff == mindiff)\n            {\n          \
    \      ret1 = numbers[i];\n                ret2 = numbers[j];\n              \
    \  return tuple(ret1, ret2);\n            }\n        }\n    }\n}\nunittest\n{\n\
    \    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwcjv5rz.d(15): Error: undefined identifier `INFINITY`

    /tmp/tmppwcjv5rz.d(12): Error: function `tmppwcjv5rz.find_closest_elements` no
    `return exp;` or `assert(0);` at end of function

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwcjv5rz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    auto closest = tuple(2.0f, 2.0f);\n    foreach(n1; 0 .. numbers.length\
    \ - 1)\n    {\n        foreach(n2; n1 + 1 .. numbers.length)\n        {\n    \
    \        auto diff = abs(numbers[n1] - numbers[n2]);\n            if(abs(closest[0]\
    \ - closest[1]) > diff)\n            {\n                closest = tuple(numbers[n1],\
    \ numbers[n2]);\n            }\n        }\n    }\n    return closest;\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeddcmpgz.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a005]

    ??:? void tmpeddcmpgz.__unittest_L28_C1() [0x428fa9]

    ??:? void tmpeddcmpgz.__modtest() [0x429a6c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f003]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42df12]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432839]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432ce8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4327c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dee9]

    ??:? runModuleUnitTests [0x42edd9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a554]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length>=2);\n    float smaller = numbers[0];\n    float\
    \ larger = numbers[1];\n    float small = abs(numbers[0]-numbers[1]);\n    for(int\
    \ i=0;i<numbers.length;i++)\n    {\n        for(int j=i+1;j<numbers.length;j++)\n\
    \        {\n            if(abs(numbers[i]-numbers[j])<small)\n            {\n\
    \                small = abs(numbers[i]-numbers[j]);\n                smaller\
    \ = numbers[i];\n                larger = numbers[j];\n            }\n       \
    \ }\n    }\n    return tuple(smaller,larger);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn33gofcf.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a001]

    ??:? void tmpn33gofcf.__unittest_L32_C1() [0x428fb9]

    ??:? void tmpn33gofcf.__modtest() [0x4299b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ed13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dc22]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432549]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4324d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dbf9]

    ??:? runModuleUnitTests [0x42eae9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a4c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min = numbers[0];\n    float\
    \ minDiff = 1.0e20;\n    float max = numbers[0];\n    foreach(i, ref e; numbers)\
    \ \n    {\n        if (e < min) \n        {\n            min = e;\n        }\n\
    \        if (e > max) \n        {\n            max = e;\n        }\n        if\
    \ (i > 0) \n        {\n            float diff = abs(e - numbers[i - 1]);\n   \
    \         if (diff < minDiff) \n            {\n                minDiff = diff;\n\
    \            }\n        }\n    }\n    return tuple(min, max);\n}\nunittest\n{\n\
    \    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0jwmq0z8.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f39]

    ??:? void tmp0jwmq0z8.__unittest_L39_C1() [0x428ef5]

    ??:? void tmp0jwmq0z8.__modtest() [0x4298f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec4b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db5a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432481]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432930]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43240d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db31]

    ??:? runModuleUnitTests [0x42ea21]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a3fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min_distance = numbers[1] - numbers[0];\n    float a = numbers[0];\n\
    \    float b = numbers[1];\n    for (size_t i = 1; i < numbers.length; i++)\n\
    \    {\n        float distance = abs(numbers[i] - numbers[i - 1]);\n        if\
    \ (distance < min_distance)\n        {\n            min_distance = distance;\n\
    \            a = numbers[i - 1];\n            b = numbers[i];\n        }\n   \
    \ }\n    return tuple(a, b);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm1j54azu.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e85]

    ??:? void tmpm1j54azu.__unittest_L29_C1() [0x428ef1]

    ??:? void tmpm1j54azu.__modtest() [0x4298ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb97]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42daa6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43287c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432359]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da7d]

    ??:? runModuleUnitTests [0x42e96d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float diff = 0.0;\n    float minDiff = abs(numbers[0] - numbers[1]);\n\
    \    size_t index = 0;\n    for (size_t i = 0; i < numbers.length - 1; i++) \n\
    \    {\n        diff = abs(numbers[i] - numbers[i + 1]);\n        if (diff < minDiff)\
    \ \n        {\n            minDiff = diff;\n            index = i;\n        }\n\
    \    }\n    return tuple(numbers[index], numbers[index + 1]);\n}\nunittest\n{\n\
    \    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvolc038a.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e45]

    ??:? void tmpvolc038a.__unittest_L28_C1() [0x428eb5]

    ??:? void tmpvolc038a.__modtest() [0x4298b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb57]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da66]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43238d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43283c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432319]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da3d]

    ??:? runModuleUnitTests [0x42e92d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a308]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min_difference = std.float.infinity;\n\
    \    int min_difference_index = 0;\n    for (int i = 0; i < numbers.length - 1;\
    \ i++)\n    {\n        float abs_difference = abs(numbers[i] - numbers[i + 1]);\n\
    \        if (abs_difference < min_difference)\n        {\n            min_difference\
    \ = abs_difference;\n            min_difference_index = i;\n        }\n    }\n\
    \    return tuple(numbers[min_difference_index], numbers[min_difference_index\
    \ + 1]);\n}\n \n/*\nFrom a supplied array of strings, remove those that contain\
    \ duplicate characters.\n    >>> remove_duplicate_characters([\"hello\", \"world\"\
    , \"goodbye\", \"mars\"])\n    [\"world\", \"mars\"]\n    >>> remove_duplicate_characters([\"\
    hello\", \"world\", \"goodbye\", \"mars\", \"goodbye\", \"world\"])\n    [\"mars\"\
    ]\n*/\nstring[] remove_duplicate_characters(string[] words)\n{\n    HashSet!(string)\
    \ unique_words = new HashSet!(string)();\n    foreach (word; words)\n    {\n \
    \       unique_words.insert(word);\n    }\n    string[] unique_words_array = unique_words.byKey().array;\n\
    \    for (int i = 0; i < unique_words_array.length; i++)\n    {\n        for (int\
    \ j = 0; j < unique_words_array[i].length; j++)\n        {\n            char char1\
    \ = unique_words_array[i][j];\n            for (int k = j + 1; k < unique_words_array[i].length;\
    \ k++)\n            {\n                char char2 = unique_words_array[i][k];\n\
    \                if (char1 == char2)\n                {\n                    unique_words_array[i]\
    \ = \"\";\n                }\n            }\n        }\n    }\n    return unique_words_array.filter!(a\
    \ => a != \"\");\n}\n \n/*\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqn1yniyg.d(15): Error: identifier expected following `.`, not `float`

    /tmp/tmpqn1yniyg.d(62): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqn1yniyg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    Tuple!(float, float) result;\n    float min_difference = 1e20;\n  \
    \  for (int i = 0; i < numbers.length; i++)\n    {\n        for (int j = i + 1;\
    \ j < numbers.length; j++)\n        {\n            float diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < min_difference)\n            {\n    \
    \            min_difference = diff;\n                result = tuple(numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd34rbw5m.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fd5]

    ??:? void tmpd34rbw5m.__unittest_L30_C1() [0x428f7d]

    ??:? void tmpd34rbw5m.__modtest() [0x429a40]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42efd3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dee2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432809]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432cb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432795]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42deb9]

    ??:? runModuleUnitTests [0x42eda9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a524]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    Tuple!(float, float) output;\n    double temp = 1000000;\n    foreach(i,\
    \ element; numbers)\n    {\n        foreach(j, secondElement; numbers)\n     \
    \   {\n            if(j != i)\n            {\n                if(abs(element -\
    \ secondElement) < temp)\n                {\n                    output = tuple(element,\
    \ secondElement);\n                    temp = abs(element - secondElement);\n\
    \                }\n            }\n        }\n    }\n    return output;\n}\n/*\n\
    Print the elements in the range [low, high).\n>>> print_range(1,4)\n>>> 1 2 3\n\
    */\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp58ovnhz1.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fc5]

    ??:? void tmp58ovnhz1.__unittest_L37_C1() [0x428f6d]

    ??:? void tmp58ovnhz1.__modtest() [0x429a30]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ef4f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42de5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432c34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42de35]

    ??:? runModuleUnitTests [0x42ed25]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a4a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float[] closest;\n    float min_delta = INFINITY;\n    foreach(float\
    \ number1; numbers) \n    {\n        foreach(float number2; numbers) \n      \
    \  {\n            float delta = abs(number1 - number2);\n            if (delta\
    \ < min_delta) \n            {\n                closest = [number1, number2];\n\
    \                min_delta = delta;\n            }\n        }\n    }\n    assert(closest.length\
    \ == 2);\n    return closest[0] < closest[1] ? tuple(closest[0], closest[1]) :\
    \ tuple(closest[1], closest[0]);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg9gwrlv9.d(15): Error: undefined identifier `INFINITY`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg9gwrlv9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    auto diffs = [ numbers[i] - numbers[i\
    \ + 1] for (i = 0 .. numbers.length - 1) ];\n    auto idx = argmin(diffs);\n \
    \   return tuple(min(numbers[idx], numbers[idx + 1]), max(numbers[idx], numbers[idx\
    \ + 1]));\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n  \
    \  assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n   \
    \ assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz4duxq3t.d(15): Error: comma expected separating array initializers,
    not `for`

    /tmp/tmpz4duxq3t.d(15): Error: semicolon expected following auto declaration,
    not `(`

    /tmp/tmpz4duxq3t.d(15): Error: found `..` when expecting `)`

    /tmp/tmpz4duxq3t.d(15): Error: found `numbers` when expecting `;` following statement

    /tmp/tmpz4duxq3t.d(15): Error: found `)` when expecting `;` following statement

    /tmp/tmpz4duxq3t.d(15): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz4duxq3t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tfloat smallest = numbers[0];\n\tfloat closest = abs(numbers[0] - numbers[1]);\n\
    \t\n\tfor (size_t i = 0; i < numbers.length; i++)\n\t{\n\t\tfor (size_t j = 0;\
    \ j < numbers.length; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tif (abs(numbers[i]\
    \ - numbers[j]) < closest)\n\t\t\t\t{\n\t\t\t\t\tclosest = abs(numbers[i] - numbers[j]);\n\
    \t\t\t\t\tsmallest = numbers[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn\
    \ tuple(smallest, smallest + closest);\n}\nunittest\n{\n    alias candidate =\
    \ find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9syqa9ha.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ec5]

    ??:? void tmp9syqa9ha.__unittest_L34_C1() [0x428f31]

    ??:? void tmp9syqa9ha.__modtest() [0x42992c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ebd7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dae6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43240d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4328bc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432399]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dabd]

    ??:? runModuleUnitTests [0x42e9ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a388]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    Tuple!(float, float) tmp, res;\n    res = tuple(numbers[0], numbers[1]);\n\
    \    for (size_t i = 0; i < numbers.length; i++)\n    {\n        for (size_t j\
    \ = i + 1; j < numbers.length; j++)\n        {\n            tmp = tuple(numbers[i],\
    \ numbers[j]);\n            if (abs(tmp[0] - tmp[1]) < abs(res[0] - res[1]))\n\
    \            {\n                res = tmp;\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk3q5opl_.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a0a5]

    ??:? void tmpk3q5opl_.__unittest_L29_C1() [0x429031]

    ??:? void tmpk3q5opl_.__modtest() [0x429b10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f0a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dfb2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4328d9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432d88]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432865]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42df89]

    ??:? runModuleUnitTests [0x42ee79]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a5f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1qtb0kyu.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1qtb0kyu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164325
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tfloat prev = numbers[0];\n\tfloat closest = prev;\n\tfloat closest_prev\
    \ = prev;\n\tfor (size_t i = 1; i < numbers.length; i++) \n\t{\n\t\tfloat diff\
    \ = abs(numbers[i] - prev);\n\t\tif (diff < closest) \n\t\t{\n\t\t\tclosest =\
    \ diff;\n\t\t\tclosest_prev = prev;\n\t\t}\n\t\tprev = numbers[i];\n\t}\n\treturn\
    \ tuple(closest_prev, prev);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk0uh3rk6.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ded]

    ??:? void tmpk0uh3rk6.__unittest_L29_C1() [0x428e5d]

    ??:? void tmpk0uh3rk6.__modtest() [0x429858]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eaff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432335]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4327e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4322c1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42d9e5]

    ??:? runModuleUnitTests [0x42e8d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a2b0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float a = 0.0;\n    float b = 0.0;\n    float min = 99.0;\n    int\
    \ minIndex = 0;\n    foreach(i, num; numbers)\n    {\n        if(i > 0)\n    \
    \    {\n            float diff = abs(num - numbers[i-1]);\n            if(diff\
    \ < min)\n            {\n                min = diff;\n                minIndex\
    \ = i;\n            }\n        }\n    }\n    a = numbers[minIndex-1];\n    b =\
    \ numbers[minIndex];\n    Tuple!(float, float) result = tuple(a, b);\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n  \
    \  assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n   \
    \ assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0fwc_zzo.d(26): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0fwc_zzo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    if (numbers.length == 2)\n      \
    \  return tuple(numbers[0], numbers[1]);\n    \n    float delta = abs(numbers[0]\
    \ - numbers[1]);\n    float minOne = numbers[0];\n    float minTwo = numbers[1];\n\
    \    for (uint i = 0; i < numbers.length - 1; i++) \n    {\n        for (uint\
    \ j = i + 1; j < numbers.length; j++) \n        {\n            float curDelta\
    \ = abs(numbers[i] - numbers[j]);\n            if (curDelta < delta) \n      \
    \      {\n                delta = curDelta;\n                minOne = numbers[i];\n\
    \                minTwo = numbers[j];\n            }\n        }\n    }\n    return\
    \ tuple(minOne, minTwo);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp94paxweb.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a001]

    ??:? void tmp94paxweb.__unittest_L36_C1() [0x428fbd]

    ??:? void tmp94paxweb.__modtest() [0x4299b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ed13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dc22]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432549]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4324d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dbf9]

    ??:? runModuleUnitTests [0x42eae9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a4c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float diff = numbers[1] - numbers[0];\n\
    \    int index1 = 0;\n    int index2 = 1;\n    foreach(int i; 1 .. numbers.length\
    \ - 1) \n    {\n        if(abs(numbers[i] - numbers[i + 1]) < diff) \n       \
    \ {\n            diff = abs(numbers[i] - numbers[i + 1]);\n            index1\
    \ = i;\n            index2 = i + 1;\n        }\n    }\n    return tuple(numbers[index1],\
    \ numbers[index2]);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7iobyuhk.d(18): Error: cannot implicitly convert expression `numbers.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7iobyuhk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float[] sorted_numbers = numbers[].dup.sort;\n    float[] diff = sorted_numbers[0..sorted_numbers.length\
    \ - 1].zip(sorted_numbers[1..sorted_numbers.length]).map!((a, b) => abs(a - b));\n\
    \    float min = diff.min;\n    int min_index = diff.indexOf(min);\n    Tuple!(float,\
    \ float) found_tuple = tuple(sorted_numbers[min_index], sorted_numbers[min_index\
    \ + 1]);\n    return found_tuple;\n}\n \n // From a supplied array of numbers\
    \ (of length at least two) select and return two that are the most distant\n //\
    \ from each other and return them in order (smaller number, larger number).\n\
    \ // >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n // tuple(1.0,\
    \ 5.0)\n \nTuple!(float, float) find_furthest_elements(float[] numbers) \n{\n\
    \    float[] sorted_numbers = numbers[].dup.sort;\n    float[] diff = sorted_numbers[0..sorted_numbers.length\
    \ - 1].zip(sorted_numbers[1..sorted_numbers.length]).map!((a, b) => abs(a - b));\n\
    \    float max = diff.max;\n    int max_index = diff.indexOf(max);\n    Tuple!(float,\
    \ float) found_tuple = tuple(sorted_numbers[max_index], sorted_numbers[max_index\
    \ + 1]);\n    return found_tuple;\n}\n \n \n /*\n In a supplied string, replace\
    \ all punctuation characters with a space. Return the new string.\n >>> replace_punctuation(\"\
    Hello, world!\")\n \"Hello  world \"\n */\n string replace_punctuation(string\
    \ a) \n {\n     string new_string = a.replace(\",.\", \" \");\n     return new_string;\n\
    \ }\n \n /*\n Return the length of the longest word in a supplied string\n >>>\
    \ find\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq7bikh19.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq7bikh19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float mindiff = abs(numbers[0] - numbers[1]);\n    auto minpair = tuple(numbers[0],\
    \ numbers[1]);\n    for (size_t i = 0; i < numbers.length; i++)\n    {\n     \
    \   for (size_t j = i + 1; j < numbers.length; j++)\n        {\n            float\
    \ diff = abs(numbers[i] - numbers[j]);\n            if (diff < mindiff)\n    \
    \        {\n                mindiff = diff;\n                minpair = tuple(numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    return minpair;\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6ooa6yue.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a075]

    ??:? void tmp6ooa6yue.__unittest_L30_C1() [0x42901d]

    ??:? void tmp6ooa6yue.__modtest() [0x429ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f073]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42df82]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4328a9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432d58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432835]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42df59]

    ??:? runModuleUnitTests [0x42ee49]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a5c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    auto r1 = tuple(numbers[0], numbers[1]);\n    float md = abs(numbers[0]\
    \ - numbers[1]);\n    foreach(i, ref a; numbers) \n    {\n        foreach(j, ref\
    \ b; numbers) \n        {\n            if (i == j) \n                continue;\n\
    \            auto d = abs(a - b);\n            if (d < md) \n            {\n \
    \               md = d;\n                r1 = tuple(a, b);\n            }\n  \
    \      }\n    }\n    return r1;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfmz562lz.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a04d]

    ??:? void tmpfmz562lz.__unittest_L32_C1() [0x428ff5]

    ??:? void tmpfmz562lz.__modtest() [0x429ab8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f04b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42df5a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432d30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43280d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42df31]

    ??:? runModuleUnitTests [0x42ee21]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a59c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    if (numbers.length <= 1) \n    {\n        throw new Exception(\"must\
    \ have at least two numbers\");\n    }\n    if (numbers.length == 2) \n    {\n\
    \        return tuple(numbers[0], numbers[1]);\n    }\n    float closest = numbers[1]\
    \ - numbers[0];\n    int index = 0;\n    for (int i = 1; i < numbers.length -\
    \ 1; i++) \n    {\n        float abs = numbers[i + 1] - numbers[i];\n        if\
    \ (abs < closest) \n        {\n            closest = abs;\n            index =\
    \ i;\n        }\n    }\n    return tuple(numbers[index], numbers[index + 1]);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8x3j7soy.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ee5]

    ??:? void tmp8x3j7soy.__unittest_L35_C1() [0x428ec9]

    ??:? void tmp8x3j7soy.__modtest() [0x4298b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eed7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dde6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43270d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432bbc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432699]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ddbd]

    ??:? runModuleUnitTests [0x42ecad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a3a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float m = min(numbers[0], numbers[1]);\n\
    \    float M = max(numbers[0], numbers[1]);\n    float mn = abs(numbers[0] - numbers[1]);\n\
    \    foreach(n; numbers[2..$])\n    {\n        float nn = abs(n - M);\n      \
    \  if (nn < mn) \n        {\n            mn = nn;\n            m = min(n, M);\n\
    \            M = max(n, M);\n        }\n    }\n    return tuple(m, M);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5lf4q70l.d(15): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp5lf4q70l.d(16): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5lf4q70l.d(24): Error: undefined identifier `min`, did you mean variable
    `mn`?

    /tmp/tmp5lf4q70l.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5lf4q70l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    assert(numbers.length % 2 == 0);\n\
    \    assert(numbers[0] <= numbers[1]);\n    auto min_elements = tuple(numbers[0],\
    \ numbers[1]);\n    for (int i = 0; i < numbers.length - 1; i++) \n    {\n   \
    \     if (abs(numbers[i] - numbers[i + 1]) < abs(min_elements[0] - min_elements[1]))\
    \ \n        {\n            min_elements = tuple(numbers[i], numbers[i + 1]);\n\
    \        }\n    }\n    return min_elements;\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpswrb4xff.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a159]

    ??:? void tmpswrb4xff.__unittest_L27_C1() [0x429049]

    ??:? void tmpswrb4xff.__modtest() [0x429b0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f157]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e066]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43298d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432e3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432919]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e03d]

    ??:? runModuleUnitTests [0x42ef2d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a6a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min_diff = float.infinity;\n    float min_1, min_2;\n    float[]\
    \ numbers_copy = numbers[];\n    sort(numbers_copy);\n    foreach( i, n ; numbers_copy\
    \ )\n    {\n        if(i < numbers_copy.length - 1)\n        {\n            float\
    \ diff = abs(numbers_copy[i] - numbers_copy[i+1]);\n            if(diff < min_diff)\n\
    \            {\n                min_diff = diff;\n                min_1 = numbers_copy[i];\n\
    \                min_2 = numbers_copy[i+1];\n            }\n        }\n    }\n\
    \    return tuple(min_1, min_2);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp70ll445m.d(17): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp70ll445m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tassert(numbers.length >= 2);\n\tfloat smallestDistance = float.max;\n\
    \tfloat smallerValue = float.max;\n\tfloat largerValue = float.max;\n\tfor (uint\
    \ i = 0; i < numbers.length - 1; i++)\n\t{\n\t\tfor (uint j = i + 1; j < numbers.length;\
    \ j++)\n\t\t{\n\t\t\tfloat distance = abs(numbers[i] - numbers[j]);\n\t\t\tif\
    \ (distance < smallestDistance)\n\t\t\t{\n\t\t\t\tsmallestDistance = distance;\n\
    \t\t\t\tsmallerValue = min(numbers[i], numbers[j]);\n\t\t\t\tlargerValue = max(numbers[i],\
    \ numbers[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn tuple(smallerValue, largerValue);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7un6mxqy.d(26): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp7un6mxqy.d(27): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7un6mxqy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\timmutable len = numbers.length;\n\tassert(len >= 2);\n\tfloat minDiff\
    \ = numbers[1] - numbers[0];\n\tTuple!(float, float) closestElements = tuple(numbers[0],\
    \ numbers[1]);\n\tfor (int i = 1; i < len - 1; i++)\n\t{\n\t\tfloat diff = numbers[i\
    \ + 1] - numbers[i];\n\t\tif (diff < minDiff)\n\t\t{\n\t\t\tminDiff = diff;\n\t\
    \t\tclosestElements = tuple(numbers[i], numbers[i + 1]);\n\t\t}\n\t}\n\treturn\
    \ closestElements;\n}\n/*\nWrite a function that returns the letter associated\
    \ with a given telephone number.\n    >>> letter_for_number(2)\n    'ABC'\n  \
    \  >>> letter_for_number(3)\n    'DEF'\n    >>> letter_for_number(8)\n    'TUV'\n\
    */\nstring letter_for_number(int number) \n{\n\timmutable char[] letters = ['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\timmutable int n = letters.length;\n\
    \tif (number < 2 || number > 9)\n\t{\n\t\treturn \"\";\n\t}\n\telse\n\t{\n\t\t\
    string ret = \"\";\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tint index =\
    \ (number - 2) * 3 + i;\n\t\t\tret ~= letters[index];\n\t\t}\n\t\treturn ret;\n\
    \t}\n}\n/*\nWrite a function that returns the shortest string in a supplied array\
    \ of strings. If two strings are the same length,\n    then return the first of\
    \ them.\n    >>> shortest_string([\"first\", \"second\", \"third\", \"a\", \"\
    bb\"])\n    \"a\"\n    >>> shortest_string([\"first\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe9z3lakn.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe9z3lakn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length>=2);\n    //T[] xs = numbers;\n    auto ret =\
    \ tuple(numbers[0], numbers[1]);\n    auto min_diff = abs(numbers[0] - numbers[1]);\n\
    \    foreach(i, x; numbers)\n    {\n        foreach(j, y; numbers[i+1..$])\n \
    \       {\n            auto d = abs(x - y);\n            if(d < min_diff)\n  \
    \          {\n                ret = tuple(x, y);\n                min_diff = d;\n\
    \            }\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpocchvtqt.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a139]

    ??:? void tmpocchvtqt.__unittest_L32_C1() [0x42902d]

    ??:? void tmpocchvtqt.__modtest() [0x429af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f137]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e046]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43296d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432e1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4328f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e01d]

    ??:? runModuleUnitTests [0x42ef0d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a688]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n  float currentClosest = 0.0;\n  float currentClosest2 = 0.0;\n  float\
    \ currentDistance = 0.0;\n  float currentDistance2 = 0.0;\n  float smallestDistance\
    \ = 1e6;\n  float smallestDistance2 = 1e6;\n  for (int i = 0; i < numbers.length;\
    \ i++)\n  {\n    for (int j = 0; j < numbers.length; j++)\n    {\n      if (i\
    \ == j)\n      {\n        continue;\n      }\n      currentDistance = abs(numbers[i]\
    \ - numbers[j]);\n      if (currentDistance < smallestDistance)\n      {\n   \
    \     currentClosest = numbers[i];\n        currentClosest2 = numbers[j];\n  \
    \      currentDistance2 = smallestDistance;\n        smallestDistance = currentDistance;\n\
    \      }\n      else if (currentDistance < smallestDistance2)\n      {\n     \
    \   currentDistance2 = currentDistance;\n      }\n    }\n  }\n  if (currentClosest\
    \ < currentClosest2)\n  {\n    return tuple(currentClosest, currentClosest2);\n\
    \  }\n  else\n  {\n    return tuple(currentClosest2, currentClosest);\n  }\n}\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpke_y6yjd.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e95]

    ??:? void tmpke_y6yjd.__unittest_L51_C1() [0x428f05]

    ??:? void tmpke_y6yjd.__modtest() [0x429900]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eba7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dab6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323dd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43288c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432369]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da8d]

    ??:? runModuleUnitTests [0x42e97d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float closest = abs(numbers[0] - numbers[1]);\n    int smallest = 0;\n\
    \    int largest = 1;\n    for (int a = 0; a < numbers.length; a++) \n    {\n\
    \        for (int b = a + 1; b < numbers.length; b++) \n        {\n          \
    \  float dist = abs(numbers[a] - numbers[b]);\n            if (dist < closest)\
    \ \n            {\n                closest = dist;\n                smallest =\
    \ a;\n                largest = b;\n            }\n        }\n    }\n    return\
    \ tuple(numbers[smallest], numbers[largest]);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppsoq14_p.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e55]

    ??:? void tmppsoq14_p.__unittest_L32_C1() [0x428ec1]

    ??:? void tmppsoq14_p.__modtest() [0x4298bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb67]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43239d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43284c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432329]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da4d]

    ??:? runModuleUnitTests [0x42e93d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a318]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float first, second;\n    float diff, min = float.max;\n    foreach(i,\
    \ f; numbers) \n    {\n        if (i != 0) \n        {\n            diff = abs(f\
    \ - numbers[i - 1]);\n            if (diff < min) \n            {\n          \
    \      min = diff;\n                first = numbers[i - 1];\n                second\
    \ = f;\n            }\n        }\n    }\n    return tuple(first, second);\n}\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcewpgaew.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e1d]

    ??:? void tmpcewpgaew.__unittest_L31_C1() [0x428e8d]

    ??:? void tmpcewpgaew.__modtest() [0x429888]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb2f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da3e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432365]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4322f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da15]

    ??:? runModuleUnitTests [0x42e905]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a2e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tassert(numbers.length > 1);\n\t\n\tfloat[] absolute_diffs = [0.0f];\n\
    \t\n\tforeach(n; numbers)\n\t{\n\t\tabsolute_diffs ~= abs(numbers[$-1] - n);\n\
    \t}\n\t\n\tabsolute_diffs.length--;\n\t\n\tint[] min_index = [0];\n\t\n\tforeach(i;\
    \ absolute_diffs)\n\t{\n\t\tif(absolute_diffs[min_index[0]] > absolute_diffs[i])\n\
    \t\t{\n\t\t\tmin_index[0] = i;\n\t\t}\n\t}\n\t\n\treturn tuple(numbers[min_index[0]],\
    \ numbers[min_index[0] + 1]);\n}\n/*\nFrom a supplied array of numbers (of length\
    \ at least two) return the second largest one.\n    >>> find_second_largest([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    4.0\n    >>> find_second_largest([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, -1.0])\n    4.0\n    >>> find_second_largest([1.0, 1.0, 1.0, 1.0,\
    \ 1.0, 1.0])\n    1.0\n*/\nfloat find_second_largest(float[] numbers) \n{\n\t\
    assert(numbers.length > 1);\n\t\n\tfloat[] largest = [float.min];\n\t\n\tforeach(n;\
    \ numbers)\n\t{\n\t\tif(largest[0] < n)\n\t\t{\n\t\t\tlargest[0] = n;\n\t\t}\n\
    \t}\n\t\n\tfloat[] second_largest = [largest[0]];\n\t\n\tforeach(n; numbers)\n\
    \t{\n\t\tif(n != largest[0] && second_largest[0] < n)\n\t\t{\n\t\t\tsecond_largest[0]\
    \ = n;\n\t\t}\n\t}\n\t\n\treturn second_largest[0];\n}\n/*\nReturn the sum of\
    \ the numbers in\nunittest\n{\n    alias candidate = find_closest_elements;\n\n\
    \    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n \
    \   assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp66c5w883.d(72): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp66c5w883.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    Tuple!(float, float) result = tuple(numbers[0],\
    \ numbers[1]);\n    float current_distance = fabs(numbers[0] - numbers[1]);\n\
    \    for (int i = 0; i < numbers.length - 1; i++) \n    {\n        float distance\
    \ = fabs(numbers[i] - numbers[i + 1]);\n        if (distance < current_distance)\
    \ \n        {\n            current_distance = distance;\n            result =\
    \ tuple(numbers[i], numbers[i + 1]);\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeamb21ca.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a0f1]

    ??:? void tmpeamb21ca.__unittest_L28_C1() [0x428ff1]

    ??:? void tmpeamb21ca.__modtest() [0x429aa8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f0ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dffe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432925]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432dd4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4328b1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dfd5]

    ??:? runModuleUnitTests [0x42eec5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a640]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min_distance = INFINITY;\n\
    \    auto i = 0;\n    Tuple!(float, float) closest_numbers;\n    foreach(number;\
    \ numbers) \n    {\n        if (i == 0) \n        {\n            i++;\n      \
    \      continue;\n        }\n        float diff = abs(number - numbers[i - 1]);\n\
    \        if (diff < min_distance) \n        {\n            min_distance = diff;\n\
    \            closest_numbers = tuple(min(number, numbers[i - 1]), max(number,\
    \ numbers[i - 1]));\n        }\n        i++;\n    }\n    return closest_numbers;\n\
    }\n \n/*\n  Given a number n, return the sum of the squares of the first n numbers\
    \ (from 1 to n inclusive)\n  >>> sum_of_squares(10)\n  385\n  >>> sum_of_squares(1)\n\
    \  1\n*/\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3fy0heb0.d(15): Error: undefined identifier `INFINITY`

    /tmp/tmp3fy0heb0.d(29): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp3fy0heb0.d(29): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3fy0heb0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float diff = abs(numbers[0] - numbers[1]);\n\
    \    Tuple!(float, float) tup;\n    tup.field1 = numbers[0];\n    tup.field2 =\
    \ numbers[1];\n    float tup_diff = abs(tup.field1 - tup.field2);\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        for (int j = i + 1; j < numbers.length;\
    \ j++) \n        {\n            diff = abs(numbers[i] - numbers[j]);\n       \
    \     if (diff < tup_diff) \n            {\n                tup_diff = diff;\n\
    \                tup.field1 = numbers[i];\n                tup.field2 = numbers[j];\n\
    \            }\n        }\n    }\n    return tup;\n}\n/*\n * Test case\n *\n */\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfuoou8wq.d(17): Error: no property `field1` for type `Tuple!(float,
    float)`, did you mean `std.typecons.Tuple!(float, float).Tuple.field`?

    /tmp/tmpfuoou8wq.d(18): Error: no property `field2` for type `Tuple!(float, float)`,
    did you mean `std.typecons.Tuple!(float, float).Tuple.field`?

    /tmp/tmpfuoou8wq.d(19): Error: no property `field1` for type `Tuple!(float, float)`,
    did you mean `std.typecons.Tuple!(float, float).Tuple.field`?

    /tmp/tmpfuoou8wq.d(19): Error: no property `field2` for type `Tuple!(float, float)`,
    did you mean `std.typecons.Tuple!(float, float).Tuple.field`?

    /tmp/tmpfuoou8wq.d(28): Error: no property `field1` for type `Tuple!(float, float)`,
    did you mean `std.typecons.Tuple!(float, float).Tuple.field`?

    /tmp/tmpfuoou8wq.d(29): Error: no property `field2` for type `Tuple!(float, float)`,
    did you mean `std.typecons.Tuple!(float, float).Tuple.field`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfuoou8wq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float x = 0.0f;\n    float y = 0.0f;\n    float temp = 0.0f;\n    float\
    \ minDistance = cast(float) INFINITY;\n    float currentDistance = 0.0f;\n   \
    \ foreach(index1, elem1; numbers)\n    {\n        foreach(index2, elem2; numbers)\n\
    \        {\n            if(index1 != index2)\n            {\n                currentDistance\
    \ = abs(elem1 - elem2);\n                if(currentDistance < minDistance)\n \
    \               {\n                    x = elem1;\n                    y = elem2;\n\
    \                    minDistance = currentDistance;\n                }\n     \
    \       }\n        }\n    }\n    return tuple(x, y);\n}\n/*\n From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ closest to each\n    other and return them in order (smaller number, larger\
    \ number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  \
    \  tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
    \    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements_slow(float[]\
    \ numbers) \n{\n    float x = 0.0f;\n    float y = 0.0f;\n    float temp = 0.0f;\n\
    \    float minDistance = cast(float) INFINITY;\n    float currentDistance = 0.0f;\n\
    \    foreach(index1, elem1; numbers)\n    {\n        foreach(index2, elem2; numbers)\n\
    \        {\n            if(index1 != index2)\n            {\n                currentDistance\
    \ = abs(elem1 - elem2);\n                if(currentDistance < minDistance)\n \
    \               {\n                    x = elem1;\n                    y = elem2;\n\
    \                    minDistance = currentDistance;\n                }\n     \
    \       }\n        }\n\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphmtl4a73.d(69): Error: found `unittest` instead of statement

    /tmp/tmphmtl4a73.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphmtl4a73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    import std.algorithm;\n    import std.range;\n    auto smallest_range\
    \ = numbers[1] - numbers[0];\n    auto pair = tuple(numbers[0], numbers[1]);\n\
    \    auto min = minElement(numbers);\n    foreach(n; min.dropOne())\n    {\n \
    \       auto range = n - min.front;\n        if(abs(range) < smallest_range)\n\
    \        {\n            smallest_range = range;\n            pair = tuple(min.front,\
    \ n);\n        }\n    }\n    return pair;\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8c8zqkz_.d(19): Error: template `std.range.dropOne` cannot deduce
    function from argument types `!()(float)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/range/package.d(3180):        `std.range.dropOne(R)(R
    range) if (isInputRange!R)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8c8zqkz_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float[] pair = new float[2];\n    float diff = float.infinity;\n  \
    \  for (size_t i = 0; i < numbers.length; i++)\n    {\n        for (size_t j =\
    \ i + 1; j < numbers.length; j++)\n        {\n            float diff_;\n     \
    \       if ((diff_ = abs(numbers[i] - numbers[j])) < diff)\n            {\n  \
    \              diff = diff_;\n                pair[0] = numbers[i];\n        \
    \        pair[1] = numbers[j];\n            }\n        }\n    }\n    return tuple(pair[0],\
    \ pair[1]);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n\
    \    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n \
    \   assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp907dykyk.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f4d]

    ??:? void tmp907dykyk.__unittest_L31_C1() [0x428fb9]

    ??:? void tmp907dykyk.__modtest() [0x4299b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ee57]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dd66]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432c34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dd3d]

    ??:? runModuleUnitTests [0x42ec2d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a410]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min_diff = DBL_MAX;\n    float a = -1.0;\n    float b = -1.0;\n\
    \    for (size_t i = 0; i < numbers.length; i++)\n    {\n        for (size_t j\
    \ = i + 1; j < numbers.length; j++)\n        {\n            float diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < min_diff)\n            {\n          \
    \      min_diff = diff;\n                a = numbers[i];\n                b =\
    \ numbers[j];\n            }\n        }\n    }\n    assert(a != -1.0 && b != -1.0);\n\
    \    return tuple(a, b);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdl9itc3_.d(14): Error: undefined identifier `DBL_MAX`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdl9itc3_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min = abs(numbers[0] - numbers[1]);\n\
    \    float argMin = numbers[0];\n    float argMin2 = numbers[1];\n    for (int\
    \ i = 0; i < numbers.length - 1; i++)\n    {\n        float k = abs(numbers[i]\
    \ - numbers[i + 1]);\n        if (k < min)\n        {\n            min = k;\n\
    \            argMin = numbers[i];\n            argMin2 = numbers[i + 1];\n   \
    \     }\n    }\n    if (argMin > argMin2)\n    {\n        return tuple(argMin2,\
    \ argMin);\n    }\n    else\n    {\n        return tuple(argMin, argMin2);\n \
    \   }\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi6mpbf4m.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fc1]

    ??:? void tmpi6mpbf4m.__unittest_L37_C1() [0x428f7d]

    ??:? void tmpi6mpbf4m.__modtest() [0x429978]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ecd3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbe2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432509]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432495]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dbb9]

    ??:? runModuleUnitTests [0x42eaa9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a484]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    double d = abs(numbers[0] - numbers[1]);\n    auto closest_pair = tuple(numbers[0],\
    \ numbers[1]);\n    for (uint i = 0; i < numbers.length; i++)\n    {\n       \
    \ for (uint j = i + 1; j < numbers.length; j++)\n        {\n            if (abs(numbers[i]\
    \ - numbers[j]) < d)\n            {\n                d = abs(numbers[i] - numbers[j]);\n\
    \                closest_pair = tuple(numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    return closest_pair;\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg3ypfuij.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a0e5]

    ??:? void tmpg3ypfuij.__unittest_L29_C1() [0x42908d]

    ??:? void tmpg3ypfuij.__modtest() [0x429b50]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f0e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dff2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432919]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432dc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4328a5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dfc9]

    ??:? runModuleUnitTests [0x42eeb9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a634]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float small = numbers[0];\n    float large = numbers[1];\n    float\
    \ distance = large - small;\n    foreach(num; numbers) \n    {\n        float\
    \ smaller = min(num, small);\n        float larger = max(num, small);\n      \
    \  float dist = larger - smaller;\n        if (dist < distance) \n        {\n\
    \            distance = dist;\n            small = smaller;\n            large\
    \ = larger;\n        }\n    }\n    return tuple(small, large);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9mlgu9f_.d(19): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp9mlgu9f_.d(20): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9mlgu9f_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float minDiff = abs(numbers[0] - numbers[1]);\n    Tuple!(float, float)\
    \ closestPair = tuple(numbers[0], numbers[1]);\n    foreach(n1; 1..numbers.length\
    \ - 1)\n    {\n        foreach(n2; n1 + 1..numbers.length)\n        {\n      \
    \      if(abs(numbers[n1] - numbers[n2]) < minDiff)\n            {\n         \
    \       minDiff = abs(numbers[n1] - numbers[n2]);\n                closestPair\
    \ = tuple(numbers[n1], numbers[n2]);\n            }\n        }\n    }\n    return\
    \ closestPair;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmkj9mrc3.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a105]

    ??:? void tmpmkj9mrc3.__unittest_L29_C1() [0x4290ad]

    ??:? void tmpmkj9mrc3.__modtest() [0x429b70]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f103]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e012]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432de8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4328c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dfe9]

    ??:? runModuleUnitTests [0x42eed9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a654]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float first = numbers[0];\n    float\
    \ second = numbers[1];\n    float diff = abs(first - second);\n    foreach(i,\
    \ value; numbers)\n    {\n        foreach(j, value2; numbers)\n        {\n   \
    \         if(j == i) continue;\n            float newDiff = abs(value - value2);\n\
    \            if(newDiff < diff)\n            {\n                first = value;\n\
    \                second = value2;\n                diff = newDiff;\n         \
    \   }\n        }\n    }\n    return tuple(first, second);\n}\nunittest\n{\n  \
    \  alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnoede3yc.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f39]

    ??:? void tmpnoede3yc.__unittest_L34_C1() [0x428ef5]

    ??:? void tmpnoede3yc.__modtest() [0x4298f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec4b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db5a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432481]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432930]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43240d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db31]

    ??:? runModuleUnitTests [0x42ea21]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a3fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    assert(numbers.length>1);\n    float closest = abs(numbers[0]-numbers[1]);\n\
    \    auto a = numbers[0];\n    auto b = numbers[1];\n    foreach(i, float ni;\
    \ numbers)\n    {\n        foreach(j, float nj; numbers)\n        {\n        \
    \    if(i!=j)\n            {\n                auto val = abs(ni-nj);\n       \
    \         if(val<closest)\n                {\n                    closest = val;\n\
    \                    a = ni;\n                    b = nj;\n                }\n\
    \            }\n        }\n    }\n    return tuple(a,b);\n}\nunittest\n{\n   \
    \ alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    Tuple!(float, float) tuple = tuple(numbers[0], numbers[1]);\n    for\
    \ (size_t i = 0; i < numbers.length; i++) \n    {\n        float element = numbers[i];\n\
    \        for (size_t j = 0; j < numbers.length; j++) \n        {\n           \
    \ if (i != j) \n            {\n                float closest = abs(tuple[0] -\
    \ tuple[1]);\n                float compareTo = abs(element - numbers[j]);\n \
    \               if (compareTo < closest) \n                {\n               \
    \     tuple = tuple(min(element, numbers[j]), max(element, numbers[j]));\n   \
    \             }\n            }\n        }\n    }\n    return tuple;\n}\n \n/*\n\
    \ Given an array of user-defined objects (of at least two different types) determine\
    \ the type to which a majority\n    of them belong.\n    >>> class A { }\n   \
    \ >>> class B { }\n    >>> class C { }\n    >>> find_majority_type!A([A(), A(),\
    \ B(), C()])\n    A\n    >>> find_majority_type!A([A(), A(), B(), C(), A()])\n\
    \    A\n    >>> find_majority_type!A([A(), A(), B(), C(), A(), B()])\n    A\n\
    \    >>> find_majority_type!A([A(), A(), B(), C(), A(), B(), B()])\n    B\n  \
    \  >>> find_majority_type!A([A(), A(), B(), C(), A(), B(), B(), C()])\n    B\n\
    \    >>> find_majority_type!A([A(), A(), B(), C(), A(), B(), B(), C(), C()])\n\
    \    C\n*/\nA find_majority_type(A[] objects) \n{\n    TypeInfo[] types = new\
    \ TypeInfo[objects.length];\n    size_t a_count = 0;\n    size_t b_count = 0;\n\
    \    size_t c_count = 0;\n    for (size_t i = 0; i < objects.length; i++) \n \
    \   {\n        TypeInfo info = objects[i].classinfo;\n        if (info == A.class\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpctki_3vc.d(62): Error: identifier expected following `.`, not `class`

    /tmp/tmpctki_3vc.d(63): Error: found `unittest` when expecting `)`

    /tmp/tmpctki_3vc.d(73): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpctki_3vc.d(73): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpctki_3vc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    assert(numbers.length % 2 == 0);\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8noyszlh.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8noyszlh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n  assert(numbers.length >= 2);\n  // we assume the first two are the closest\n\
    \  float n1 = numbers[0];\n  float n2 = numbers[1];\n  float d = abs(n1 - n2);\n\
    \  // iterate through every other number to determine if it's better\n  for (size_t\
    \ i = 2; i < numbers.length; i++)\n  {\n    for (size_t j = i + 1; j < numbers.length;\
    \ j++)\n    {\n      float v = abs(numbers[i] - numbers[j]);\n      if (v < d)\n\
    \      {\n        d = v;\n        n1 = numbers[i];\n        n2 = numbers[j];\n\
    \      }\n    }\n  }\n  return tuple(n1, n2);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3gf_0lmz.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f71]

    ??:? void tmp3gf_0lmz.__unittest_L35_C1() [0x428f2d]

    ??:? void tmp3gf_0lmz.__modtest() [0x429928]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db92]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324b9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432968]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432445]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db69]

    ??:? runModuleUnitTests [0x42ea59]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a434]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float curmin = abs(numbers[0] - numbers[1]);\n\
    \    float a = numbers[0];\n    float b = numbers[1];\n    for (int i = 0; i <\
    \ numbers.length; i++)\n    {\n        for (int j = i+1; j < numbers.length; j++)\n\
    \        {\n            float cur = abs(numbers[i] - numbers[j]);\n          \
    \  if (cur < curmin)\n            {\n                curmin = cur;\n         \
    \       a = numbers[i];\n                b = numbers[j];\n            }\n    \
    \    }\n    }\n    return tuple(a, b);\n}\n \n/*\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph4n43h2k.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph4n43h2k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min = abs(numbers[0] - numbers[1]);\n    Tuple!(float, float)\
    \ closestPair;\n    foreach(index, value1; numbers)\n    {\n        foreach(value2;\
    \ numbers[index+1..$])\n        {\n            if(abs(value1 - value2) < min)\n\
    \            {\n                closestPair = tuple(value1, value2);\n       \
    \         min = abs(value1 - value2);\n            }\n        }\n    }\n    return\
    \ closestPair;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphybuvupp.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a00d]

    ??:? void tmphybuvupp.__unittest_L29_C1() [0x428fb5]

    ??:? void tmphybuvupp.__modtest() [0x429a78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f00b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42df1a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432cf0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4327cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42def1]

    ??:? runModuleUnitTests [0x42ede1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a55c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    return find_closest_elements_rec(numbers, numbers.length);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl2r9l92s.d(14): Error: undefined identifier `find_closest_elements_rec`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl2r9l92s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    if (numbers.length < 2)\n        return tuple(0.0, 0.0);\n    if (numbers.length\
    \ == 2)\n        return tuple(numbers[0], numbers[1]);\n    \n    float smallest_diff\
    \ = abs(numbers[0] - numbers[1]);\n    int smallest_diff_idx1 = 0;\n    int smallest_diff_idx2\
    \ = 1;\n    \n    for (int i = 0; i < numbers.length - 1; i++)\n    {\n      \
    \  for (int j = i + 1; j < numbers.length; j++)\n        {\n            float\
    \ diff = abs(numbers[i] - numbers[j]);\n            if (diff < smallest_diff)\n\
    \            {\n                smallest_diff = diff;\n                smallest_diff_idx1\
    \ = i;\n                smallest_diff_idx2 = j;\n            }\n        }\n  \
    \  }\n    \n    return tuple(numbers[smallest_diff_idx1], numbers[smallest_diff_idx2]);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp670nq_oe.d(15): Error: cannot implicitly convert expression `tuple(0.00000,
    0.00000)` of type `Tuple!(double, double)` to `Tuple!(float, float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp670nq_oe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    //Start with first two numbers in\
    \ array and compare them\n    float[2] diff = [numbers[1] - numbers[0], numbers[1]\
    \ - numbers[0]];\n    foreach(i, number1; numbers)\n    {\n        foreach(j,\
    \ number2; numbers)\n        {\n            //If difference is smaller than current\
    \ smallest difference and both numbers are different, \n            //update smallest\
    \ difference and record which numbers they are.\n            if(abs(number1 -\
    \ number2) < abs(diff[0]) && number1 != number2)\n            {\n            \
    \    diff[0] = number1 - number2;\n                diff[1] = number1;\n      \
    \          diff[2] = number2;\n            }\n        }\n    }\n    //Return smallest\
    \ difference and numbers in order\n    return tuple(min(diff[1], diff[2]), max(diff[1],\
    \ diff[2]));\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n\
    \    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n \
    \   assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqgxtyy9t.d(27): Error: array index 2 is out of bounds `diff[0 ..
    2]`

    /tmp/tmpqgxtyy9t.d(32): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpqgxtyy9t.d(32): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqgxtyy9t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float dmin = float.max;\n    float i_min = 0.0;\n    float j_min =\
    \ 0.0;\n    for (size_t i = 0; i < numbers.length; i++)\n    {\n        for (size_t\
    \ j = i + 1; j < numbers.length; j++)\n        {\n            float d = abs(numbers[i]\
    \ - numbers[j]);\n            if (d < dmin)\n            {\n                dmin\
    \ = d;\n                i_min = numbers[i];\n                j_min = numbers[j];\n\
    \            }\n        }\n    }\n    if (i_min < j_min)\n    {\n        return\
    \ tuple(i_min, j_min);\n    }\n    else\n    {\n        return tuple(j_min, i_min);\n\
    \    }\n}\n \n/*\n \n Given an integer and an array of integers, return the location\
    \ of the integer in the array,\n    or -1 if the integer is not in the array.\n\
    \    >>> find_integer_location(3, [1, 2, 3, 4, 5])\n    2\n    >>> find_integer_location(6,\
    \ [1, 2, 3, 4, 5])\n    -1\n*/\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4g6ebncp.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e5d]

    ??:? void tmp4g6ebncp.__unittest_L49_C1() [0x428ec9]

    ??:? void tmp4g6ebncp.__modtest() [0x4298c4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb6f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432854]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432331]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da55]

    ??:? runModuleUnitTests [0x42e945]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a320]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float closest = abs(numbers[0] -\
    \ numbers[1]);\n    size_t i = 0;\n    size_t j = 1;\n    for (size_t k = 0; k\
    \ < numbers.length; k++) \n    {\n        for (size_t l = k + 1; l < numbers.length;\
    \ l++) \n        {\n            if (abs(numbers[k] - numbers[l]) < closest) \n\
    \            {\n                closest = abs(numbers[k] - numbers[l]);\n    \
    \            i = k;\n                j = l;\n            }\n        }\n    }\n\
    \    return tuple(numbers[i], numbers[j]);\n}\n/*\nRun-length encoding is a simple\
    \ form of data compression in which runs of data are stored as a single data value\
    \ and\ncount.\n>>> rle_encoding([1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5,\
    \ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6,\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdnlxja6k.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdnlxja6k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    if (numbers.length < 2)\n        throw new Exception(\"numbers.length\
    \ < 2\");\n    if (numbers.length == 2)\n        return tuple(numbers[0], numbers[1]);\n\
    \    // sort numbers and find closest elements\n    numbers.sort();\n    auto\
    \ min_pair = tuple(numbers[0], numbers[1]);\n    auto min_diff = abs(numbers[0]\
    \ - numbers[1]);\n    for (size_t i = 1; i < numbers.length - 1; i++) \n    {\n\
    \        if (numbers[i + 1] - numbers[i] < min_diff) \n        {\n           \
    \ min_pair = tuple(numbers[i], numbers[i + 1]);\n            min_diff = numbers[i\
    \ + 1] - numbers[i];\n        }\n    }\n    return min_pair;\n}\nunittest\n{\n\
    \    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp160dd8b4.d(19): Error: no property `sort` for type `float[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp160dd8b4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min = abs(numbers[0] - numbers[1]);\n\
    \    int first = 0;\n    int second = 1;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (int j = i + 1; j < numbers.length; j++)\n        {\n\
    \            float diff = abs(numbers[i] - numbers[j]);\n            if (diff\
    \ < min)\n            {\n                min = diff;\n                first =\
    \ i;\n                second = j;\n            }\n        }\n    }\n    return\
    \ tuple(numbers[first], numbers[second]);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4qo7xnql.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f49]

    ??:? void tmp4qo7xnql.__unittest_L33_C1() [0x428f05]

    ??:? void tmp4qo7xnql.__modtest() [0x429900]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db6a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432491]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432940]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43241d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db41]

    ??:? runModuleUnitTests [0x42ea31]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a40c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tsize_t n = numbers.length;\n\tassert(n > 1);\n\t\n\tfloat min;\n\tfloat\
    \ minp;\n\tfloat minv;\n\t\n\tmin = numbers[1] - numbers[0];\n\tminp = numbers[0];\n\
    \tminv = numbers[1];\n\t\n\tfor (size_t i = 1; i < n; i++) \n\t{\n\t\tfloat diff\
    \ = numbers[i] - numbers[i-1];\n\t\tif (diff < min) \n\t\t{\n\t\t\tmin = diff;\n\
    \t\t\tminp = numbers[i-1];\n\t\t\tminv = numbers[i];\n\t\t}\n\t}\n\t\n\treturn\
    \ tuple(minp, minv);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppc7qq0p4.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f19]

    ??:? void tmppc7qq0p4.__unittest_L38_C1() [0x428ee1]

    ??:? void tmppc7qq0p4.__modtest() [0x4298d0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec07]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43243d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4328ec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4323c9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42daed]

    ??:? runModuleUnitTests [0x42e9dd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a3dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min = numeric_limits!float.infinity;\n\
    \    float a = 0.0;\n    float b = 0.0;\n    for (uint i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (uint j = i + 1; j < numbers.length; j++)\n       \
    \ {\n            if (abs(numbers[i] - numbers[j]) < min)\n            {\n    \
    \            min = abs(numbers[i] - numbers[j]);\n                a = numbers[i];\n\
    \                b = numbers[j];\n            }\n        }\n    }\n    return\
    \ tuple(a, b);\n}\n// / runnable\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkem1qj9x.d(15): Error: template instance `numeric_limits!float`
    template `numeric_limits` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkem1qj9x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    Tuple!(float, float) closest_elements; \n    float min_difference\
    \ = float.infinity; \n    // check each pair \n    for (auto i = 0; i < numbers.length;\
    \ i++) \n    { \n        for (auto j = i + 1; j < numbers.length; j++) \n    \
    \    { \n            float difference = abs(numbers[i] - numbers[j]); \n     \
    \       if (difference < min_difference) \n            { \n                min_difference\
    \ = difference; \n                closest_elements = tuple(numbers[i], numbers[j]);\
    \ \n            } \n        } \n    } \n    return closest_elements; \n} \nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5u9ikr41.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fd5]

    ??:? void tmp5u9ikr41.__unittest_L31_C1() [0x428f7d]

    ??:? void tmp5u9ikr41.__modtest() [0x429a40]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42efd3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dee2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432809]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432cb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432795]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42deb9]

    ??:? runModuleUnitTests [0x42eda9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a524]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    // this code is buggy\n    float\
    \ closest_delta = abs(numbers[0] - numbers[1]);\n    float a = numbers[0];\n \
    \   float b = numbers[1];\n    for (int i = 0; i < numbers.length; i++) \n   \
    \ {\n        for (int j = i + 1; j < numbers.length; j++) \n        {\n      \
    \      float delta = abs(numbers[i] - numbers[j]);\n            if (delta < closest_delta)\
    \ \n            {\n                closest_delta = delta;\n                a =\
    \ numbers[i];\n                b = numbers[j];\n            }\n        }\n   \
    \ }\n    return tuple(a, b);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi9xvi34u.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fa9]

    ??:? void tmpi9xvi34u.__unittest_L34_C1() [0x428f65]

    ??:? void tmpi9xvi34u.__modtest() [0x429960]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ecbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbca]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43247d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dba1]

    ??:? runModuleUnitTests [0x42ea91]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a46c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float minDiff = abs(numbers[0] -\
    \ numbers[1]);\n    int minDiffIndex = 0;\n    for (int i = 0; i < numbers.length\
    \ - 1; i++)\n    {\n        float diff = abs(numbers[i] - numbers[i + 1]);\n \
    \       if (diff < minDiff)\n        {\n            minDiff = diff;\n        \
    \    minDiffIndex = i;\n        }\n    }\n    return tuple(numbers[minDiffIndex],\
    \ numbers[minDiffIndex + 1]);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpptrgdwj9.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f31]

    ??:? void tmpptrgdwj9.__unittest_L28_C1() [0x428ee9]

    ??:? void tmpptrgdwj9.__modtest() [0x4298e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db52]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432479]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432928]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432405]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db29]

    ??:? runModuleUnitTests [0x42ea19]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a3f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float smallestDiff;\n    float smallest1;\n    float smallest2;\n \
    \   float currentDiff;\n    float current1;\n    float current2;\n    //sort the\
    \ list\n    sort(numbers);\n    //set the first pair as the ones to return \n\
    \    current1 = numbers[0];\n    current2 = numbers[1];\n    currentDiff = current2\
    \ - current1;\n    smallest1 = current1;\n    smallest2 = current2;\n    smallestDiff\
    \ = currentDiff;\n    //loop through the rest of the numbers in the list\n   \
    \ for(uint i = 1; i < numbers.length; i++) \n    {\n        current1 = numbers[i];\n\
    \        current2 = numbers[i+1];\n        currentDiff = current2 - current1;\n\
    \        //if the current pair has a smaller difference than the previous smallest,\n\
    \        //set the current pair as the new smallest pair\n        if(currentDiff\
    \ < smallestDiff) \n        {\n            smallest1 = current1;\n           \
    \ smallest2 = current2;\n            smallestDiff = currentDiff;\n        }\n\
    \    }\n    return tuple(smallest1, smallest2);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgivnp59s.d(21): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgivnp59s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min=0.0,max=0.0;\n    if(numbers.length<2)\n        return tuple(min,max);\n\
    \    float diff=abs(numbers[0]-numbers[1]);\n    foreach(a,b; zip(numbers[0..$-1],numbers[1..$]))\n\
    \    {\n        if(abs(a-b)<diff)\n        {\n            diff=abs(a-b);\n   \
    \         min=a;\n            max=b;\n        }\n    }\n    return tuple(min,max);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgbqzff1p.d(18): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgbqzff1p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float minDiff = float.max;\n    float\
    \ minDiffNum1 = 0;\n    float minDiffNum2 = 0;\n    for (uint i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (uint j = i + 1; j < numbers.length; j++)\n       \
    \ {\n            float diff = abs(numbers[i] - numbers[j]);\n            if (diff\
    \ < minDiff)\n            {\n                minDiff = diff;\n               \
    \ minDiffNum1 = numbers[i];\n                minDiffNum2 = numbers[j];\n     \
    \       }\n        }\n    }\n    return tuple(minDiffNum1, minDiffNum2);\n}\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgj17iw22.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f21]

    ??:? void tmpgj17iw22.__unittest_L33_C1() [0x428ed9]

    ??:? void tmpgj17iw22.__modtest() [0x4298d4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db42]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432469]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432918]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4323f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db19]

    ??:? runModuleUnitTests [0x42ea09]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a3e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n  float small = numbers[0];\n  float large = numbers[1];\n  size_t n =\
    \ numbers.length;\n  float distance = abs(large - small);\n  for (size_t i = 0;\
    \ i < n; i++) \n  {\n    for (size_t j = i + 1; j < n; j++) \n    {\n      float\
    \ nd = abs(numbers[j] - numbers[i]);\n      if (nd < distance) \n      {\n   \
    \     small = numbers[i];\n        large = numbers[j];\n        distance = nd;\n\
    \      }\n    }\n  }\n  return tuple(small, large);\n}\nunittest\n{\n    alias\
    \ candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) ==\
    \ tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0,\
    \ 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsqre8ni0.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e7d]

    ??:? void tmpsqre8ni0.__unittest_L33_C1() [0x428eed]

    ??:? void tmpsqre8ni0.__modtest() [0x4298e8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb8f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432874]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432351]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da75]

    ??:? runModuleUnitTests [0x42e965]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a340]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length > 1);\n    float minDifference = INFINITY;\n\
    \    size_t minAIndex = 0;\n    size_t minBIndex = 0;\n    for (size_t i = 0;\
    \ i < numbers.length; i++)\n    {\n        for (size_t j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            float difference = abs(numbers[i] - numbers[j]);\n\
    \            if (difference < minDifference)\n            {\n                minDifference\
    \ = difference;\n                minAIndex = i;\n                minBIndex = j;\n\
    \            }\n        }\n    }\n    return tuple(numbers[minAIndex], numbers[minBIndex]);\n\
    }\n/*\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfv_6c8mr.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfv_6c8mr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float temp;\n    if (numbers.length < 2)\n    {\n        throw new\
    \ Exception(\"Not enough elements\");\n    }\n    float[] closest = [numbers[0],\
    \ numbers[1]];\n    if (numbers[0] > numbers[1])\n    {\n        temp = numbers[0];\n\
    \        numbers[0] = numbers[1];\n        numbers[1] = temp;\n    }\n    for\
    \ (int i = 1; i < numbers.length - 1; i++)\n    {\n        if (abs(numbers[i]\
    \ - numbers[i + 1]) < abs(closest[0] - closest[1]))\n        {\n            closest[0]\
    \ = numbers[i];\n            closest[1] = numbers[i + 1];\n        }\n    }\n\
    \    return tuple(closest[0], closest[1]);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp62hh9j8k.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a125]

    ??:? void tmp62hh9j8k.__unittest_L36_C1() [0x4290fd]

    ??:? void tmp62hh9j8k.__modtest() [0x429af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f13b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e04a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432971]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432e20]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4328fd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e021]

    ??:? runModuleUnitTests [0x42ef11]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a5e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float minDiff = abs(numbers[0] - numbers[1]);\n    int idxA = 0;\n\
    \    int idxB = 1;\n    for (int i = 0; i < numbers.length; i++)\n    {\n    \
    \    for (int j = i + 1; j < numbers.length; j++)\n        {\n            float\
    \ diff = abs(numbers[i] - numbers[j]);\n            if (diff < minDiff)\n    \
    \        {\n                minDiff = diff;\n                idxA = i;\n     \
    \           idxB = j;\n            }\n        }\n    }\n    return tuple(numbers[idxA],\
    \ numbers[idxB]);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprxsg4fna.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e55]

    ??:? void tmprxsg4fna.__unittest_L32_C1() [0x428ec1]

    ??:? void tmprxsg4fna.__modtest() [0x4298bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb67]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43239d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43284c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432329]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da4d]

    ??:? runModuleUnitTests [0x42e93d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a318]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    immutable float min_distance = abs(numbers[0] - numbers[1]);\n    immutable\
    \ float tmp;\n    immutable float num1 = numbers[0];\n    immutable float num2\
    \ = numbers[1];\n    immutable size_t min_index = 0;\n    immutable size_t min_index2\
    \ = 1;\n    for (size_t i = 0; i < numbers.length - 1; i++) \n    {\n        for\
    \ (size_t j = i + 1; j < numbers.length; j++) \n        {\n            tmp = abs(numbers[i]\
    \ - numbers[j]);\n            if (tmp < min_distance) \n            {\n      \
    \          min_distance = tmp;\n                min_index = i;\n             \
    \   min_index2 = j;\n            }\n        }\n    }\n    if (numbers[min_index]\
    \ < numbers[min_index2]) \n    {\n        return tuple(numbers[min_index], numbers[min_index2]);\n\
    \    } \n    else \n    {\n        return tuple(numbers[min_index2], numbers[min_index]);\n\
    \    }\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvhzklja4.d(24): Error: cannot modify `immutable` expression `tmp`

    /tmp/tmpvhzklja4.d(27): Error: cannot modify `immutable` expression `min_distance`

    /tmp/tmpvhzklja4.d(28): Error: cannot modify `immutable` expression `min_index`

    /tmp/tmpvhzklja4.d(29): Error: cannot modify `immutable` expression `min_index2`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvhzklja4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tfloat firstElement = numbers[0];\n\tfloat secondElement = numbers[1];\n\
    \t\n\tfor(int i = 0; i < numbers.length; i++) \n\t{\n\t\tfor(int j = i + 1; j\
    \ < numbers.length; j++) \n\t\t{\n\t\t\tif(abs(numbers[i] - numbers[j]) < abs(firstElement\
    \ - secondElement)) \n\t\t\t{\n\t\t\t\tfirstElement = numbers[i];\n\t\t\t\tsecondElement\
    \ = numbers[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn tuple(firstElement, secondElement);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqqeibzb3.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e5d]

    ??:? void tmpqqeibzb3.__unittest_L30_C1() [0x428ecd]

    ??:? void tmpqqeibzb3.__modtest() [0x4298c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb6f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432854]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432331]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da55]

    ??:? runModuleUnitTests [0x42e945]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a320]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    auto result = tuple(numbers[0], numbers[1]);\n    auto diff = abs(result[0]\
    \ - result[1]);\n    auto n1 = numbers[0];\n    foreach(n; numbers[1..$])\n  \
    \  {\n        auto new_diff = abs(n - n1);\n        if (new_diff < diff)\n   \
    \     {\n            result = tuple(n1, n);\n            diff = new_diff;\n  \
    \      }\n        n1 = n;\n    }\n    return result;\n}\n/*\n From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ farthest from each\n    other and return them in order (smaller number, larger\
    \ number).\n    >>> find_farthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n \
    \   tuple(1.0, 5.0)\n    >>> find_farthest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0])\n    tuple(1.0, 5.0)\n    \n*/\nTuple!(float, float) find_farthest_elements(float[]\
    \ numbers) \n{\n    auto result = tuple(numbers[0], numbers[1]);\n    auto diff\
    \ = abs(result[0] - result[1]);\n    auto n1 = numbers[0];\n    foreach(n; numbers[1..$])\n\
    \    {\n        auto new_diff = abs(n - n1);\n        if (new_diff > diff)\n \
    \       {\n            result = tuple(n1, n);\n            diff = new_diff;\n\
    \        }\n        n1 = n;\n    }\n    return result;\n}\n/*\n From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ closest to each\n    other and return them in order (smaller number, larger\
    \ number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  \
    \  tuple(2.0, 2.2)\n    >>> find\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpthsemzey.d(55): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpthsemzey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164326
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tfloat min_diff = abs(numbers[0] - numbers[1]);\n\tfloat min_diff_number\
    \ = numbers[0];\n\tfloat next_min_diff_number = numbers[1];\n\tfloat current_diff;\n\
    \tfor (int i = 0; i < numbers.length; i++)\n\t{\n\t\tfor (int j = i+1; j < numbers.length;\
    \ j++)\n\t\t{\n\t\t\tcurrent_diff = abs(numbers[i] - numbers[j]);\n\t\t\tif (current_diff\
    \ < min_diff)\n\t\t\t{\n\t\t\t\tmin_diff = current_diff;\n\t\t\t\tmin_diff_number\
    \ = numbers[i];\n\t\t\t\tnext_min_diff_number = numbers[j];\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn tuple(min_diff_number, next_min_diff_number);\n}\nunittest\n{\n  \
    \  alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvu17zo4t.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ebd]

    ??:? void tmpvu17zo4t.__unittest_L33_C1() [0x428f2d]

    ??:? void tmpvu17zo4t.__modtest() [0x429928]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ebcf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dade]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432405]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4328b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432391]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dab5]

    ??:? runModuleUnitTests [0x42e9a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a380]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float[] arr = [float.infinity, float.infinity];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(abs(numbers[i] - numbers[i+1]) <\
    \ abs(arr[0] - arr[1])) \n        {\n            arr[0] = numbers[i];\n      \
    \      arr[1] = numbers[i+1];\n        }\n    }\n    return tuple(arr[0], arr[1]);\n\
    }\n \n/*\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw1owc5g7.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw1owc5g7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    int indexA = 0; \n    int indexB = 1; \n    float smallestDiff = abs(numbers[indexA]\
    \ - numbers[indexB]); \n    foreach (int i, float a; numbers) \n    { \n     \
    \   foreach (int j, float b; numbers) \n        { \n            if (i != j) \n\
    \            { \n                float diff = abs(a - b); \n                if\
    \ (diff < smallestDiff) \n                { \n                    indexA = i;\
    \ \n                    indexB = j; \n                    smallestDiff = diff;\
    \ \n                } \n            } \n        } \n    } \n    return tuple(numbers[indexA],\
    \ numbers[indexB]); \n} \nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8m2zjfaq.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e75]

    ??:? void tmp8m2zjfaq.__unittest_L35_C1() [0x428ee5]

    ??:? void tmp8m2zjfaq.__modtest() [0x4298e0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb87]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43286c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432349]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da6d]

    ??:? runModuleUnitTests [0x42e95d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a338]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    //find closest element\n    auto\
    \ range = numbers[1..$];\n    float dif = abs(numbers[0] - range[0]);\n    float\
    \ j = numbers[0];\n    foreach(num; range)\n    {\n        if(abs(numbers[0] -\
    \ num) < dif)\n        {\n            dif = abs(numbers[0] - num);\n         \
    \   j = num;\n        }\n    }\n    //find second closest element\n    float res1\
    \ = float.max;\n    float res2 = float.max;\n    foreach(num; numbers)\n    {\n\
    \        if(num != j)\n        {\n            if(abs(num - j) < dif)\n       \
    \     {\n                dif = abs(num - j);\n                res1 = num;\n  \
    \              res2 = j;\n            }\n        }\n    }\n    return tuple(res1,\
    \ res2);\n}\n/*\n Given an array of positive numbers, return two that are the\
    \ closest to each other in the order that they\n    appear in the array (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n*/\nTuple!(float, float) find_closest_elements(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 2);\n    //find closest element\n\
    \    auto range = numbers[1..$];\n    float dif = abs(numbers[0] - range[0]);\n\
    \    float j = numbers[0];\n    foreach(num; range)\n    {\n        if(abs(numbers[0]\
    \ - num) < dif)\n        {\n            dif = abs(numbers[0] - num);\n       \
    \     j = num;\n        }\n    }\n    //find second\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpda0fonfq.d(68): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpda0fonfq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    import std.typecons;\n    assert(numbers.length >= 2);\n    float a,\
    \ b;\n    a = numbers[0];\n    b = numbers[1];\n    for (size_t i = 0; i < numbers.length\
    \ - 1; i++) \n    {\n        for (size_t j = i + 1; j < numbers.length; j++) \n\
    \        {\n            if (abs(numbers[i] - numbers[j]) < abs(a - b)) \n    \
    \        {\n                a = numbers[i];\n                b = numbers[j];\n\
    \            }\n        }\n    }\n    return tuple(a, b);\n}\nunittest\n{\n  \
    \  alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu8_ogynh.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f81]

    ??:? void tmpu8_ogynh.__unittest_L32_C1() [0x428f3d]

    ??:? void tmpu8_ogynh.__modtest() [0x429938]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dba2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432978]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432455]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db79]

    ??:? runModuleUnitTests [0x42ea69]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    static assert(numbers.length >= 2);\n    Tuple!(float, float) closest\
    \ = tuple(numbers[0], numbers[1]);\n    float min_diff = abs(closest[0] - closest[1]);\n\
    \    float diff;\n    foreach(i, num1; numbers)\n    {\n        foreach(j, num2;\
    \ numbers[i + 1 .. $])\n        {\n            diff = abs(num1 - num2);\n    \
    \        if (diff < min_diff)\n            {\n                closest = tuple(num1,\
    \ num2);\n                min_diff = diff;\n            }\n        }\n    }\n\
    \    return closest;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpti16xj6m.d(14): Error: variable `numbers` cannot be read at compile
    time

    /tmp/tmpti16xj6m.d(14):        while evaluating: `static assert(numbers.length
    >= 2LU)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpti16xj6m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float[] result = new float[2];\n    float tmp = 0.0;\n    float first\
    \ = numbers[0];\n    float second = numbers[1];\n    float value = abs(first -\
    \ second);\n    for (int i = 0; i < numbers.length; i++)\n    {\n        for (int\
    \ j = i + 1; j < numbers.length; j++)\n        {\n            tmp = abs(numbers[i]\
    \ - numbers[j]);\n            if (tmp < value)\n            {\n              \
    \  value = tmp;\n                first = numbers[i];\n                second =\
    \ numbers[j];\n            }\n        }\n    }\n    result[0] = first;\n    result[1]\
    \ = second;\n    return tuple(result[0], result[1]);\n}\nunittest\n{\n    alias\
    \ candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) ==\
    \ tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0,\
    \ 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4niyuil2.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fad]

    ??:? void tmp4niyuil2.__unittest_L36_C1() [0x429019]

    ??:? void tmp4niyuil2.__modtest() [0x429a14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eeb7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ddc6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4327e5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432c94]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432771]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dd9d]

    ??:? runModuleUnitTests [0x42ec8d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a470]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    // assert(numbers.length >= 2, \"Array length must be at least 2\"\
    ); \n    if (numbers.length < 2) \n        return tuple(0.0, 0.0); \n    auto\
    \ closest_pair = tuple(numbers[0], numbers[1]); \n    float closest_diff = closest_pair[1]\
    \ - closest_pair[0]; \n    foreach (i, a; numbers[0 .. $ - 1]) \n    { \n    \
    \    foreach (j, b; numbers[i + 1 .. $]) \n        { \n            float diff\
    \ = abs(a - b); \n            if (diff < closest_diff) \n            { \n    \
    \            closest_pair = tuple(a, b); \n                closest_diff = diff;\
    \ \n            } \n        } \n    } \n    return closest_pair; \n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppmkgzg1g.d(16): Error: cannot implicitly convert expression `tuple(0.00000,
    0.00000)` of type `Tuple!(double, double)` to `Tuple!(float, float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppmkgzg1g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min = absolute(numbers[0] - numbers[1]);\n    int index = 0;\n\
    \    for (int i = 1; i < numbers.length - 1; i++) \n    {\n        float current\
    \ = absolute(numbers[i] - numbers[i + 1]);\n        if (current < min) \n    \
    \    {\n            min = current;\n            index = i;\n        }\n    }\n\
    \    return tuple(numbers[index], numbers[index + 1]);\n}\nunittest\n{\n    alias\
    \ candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) ==\
    \ tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0,\
    \ 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxalzsok0.d(14): Error: undefined identifier `absolute`

    /tmp/tmpxalzsok0.d(18): Error: undefined identifier `absolute`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxalzsok0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    // O(n^2) time complexity\n    float ret_a, ret_b;\n    double min_diff\
    \ = INFINITY;\n    foreach(a, b; numbers)\n    {\n        foreach(x; numbers)\n\
    \        {\n            float diff = abs(x - a);\n            if (diff < min_diff)\n\
    \            {\n                ret_a = a;\n                ret_b = x;\n     \
    \           min_diff = diff;\n            }\n        }\n    }\n    return tuple(ret_a,\
    \ ret_b);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n  \
    \  assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n   \
    \ assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy0lt8hc5.d(16): Error: undefined identifier `INFINITY`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy0lt8hc5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float previous = numbers[0];\n  \
    \  float current;\n    float smallestDifference = INFINITY;\n    Tuple!(float,\
    \ float) closestTuple = tuple(numbers[0], numbers[1]);\n    for (int i = 1; i\
    \ < numbers.length; i++)\n    {\n        current = numbers[i];\n        float\
    \ difference = abs(current - previous);\n        if (difference < smallestDifference)\n\
    \        {\n            smallestDifference = difference;\n            closestTuple\
    \ = tuple(previous, current);\n        }\n        previous = current;\n    }\n\
    \    return closestTuple;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeh8dvtu8.d(17): Error: undefined identifier `INFINITY`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeh8dvtu8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min = cast(float)INFINITY;\n    Tuple!(float, float) minTuple\
    \ = tuple(0.0, 0.0);\n    foreach(i, v; numbers)\n    {\n        foreach(j, w;\
    \ numbers)\n        {\n            if(i != j)\n            {\n               \
    \ float abs = abs(v - w);\n                if(abs < min)\n                {\n\
    \                    min = abs;\n                    minTuple = tuple(min(v, w),\
    \ max(v, w));\n                }\n            }\n        }\n    }\n    return\
    \ minTuple;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n\
    \    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n \
    \   assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt_ey_ch7.d(14): Error: undefined identifier `INFINITY`

    /tmp/tmpt_ey_ch7.d(26): Error: function expected before `()`, not `min` of type
    `float`

    /tmp/tmpt_ey_ch7.d(26): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt_ey_ch7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    int first, second;\n    float distance, minDistance = INFINITY;\n \
    \   foreach(i, element; numbers)\n    {\n        foreach(j, element2; numbers)\n\
    \        {\n            if(i != j)\n            {\n                distance =\
    \ abs(element - element2);\n                if(distance < minDistance)\n     \
    \           {\n                    minDistance = distance;\n                 \
    \   first = i;\n                    second = j;\n                }\n         \
    \   }\n        }\n    }\n    return tuple(numbers[first], numbers[second]);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3ud1zt64.d(15): Error: undefined identifier `INFINITY`

    /tmp/tmp3ud1zt64.d(26): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp3ud1zt64.d(27): Error: cannot implicitly convert expression `j` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3ud1zt64.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    assert(numbers.length > 1);\n    float smallestDiff = 9999999999;\n\
    \    float first = 0;\n    float second = 0;\n    foreach(index, number; numbers)\n\
    \    {\n        if(index == 0)\n        {\n            first = number;\n     \
    \       second = numbers[index + 1];\n            smallestDiff = abs(first - second);\n\
    \        }\n        else if(index == numbers.length - 1)\n        {\n        \
    \    continue;\n        }\n        else\n        {\n            float diff = abs(number\
    \ - numbers[index + 1]);\n            if(diff < smallestDiff)\n            {\n\
    \                first = number;\n                second = numbers[index + 1];\n\
    \                smallestDiff = diff;\n            }\n        }\n    }\n    Tuple!(float,\
    \ float) result = tuple(first, second);\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm62gk1jw.d(15): Error: cannot implicitly convert expression `9999999999L`
    of type `long` to `float`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm62gk1jw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length > 1);\n    float result1 = 0;\n    float result2\
    \ = 0;\n    float temp = 0;\n    float difference = 10000;\n    //float \n   \
    \ for (int i = 0; i < numbers.length; i++)\n    {\n        for (int j = i+1; j\
    \ < numbers.length; j++)\n        {\n            temp = abs(numbers[i] - numbers[j]);\n\
    \            if (temp < difference)\n            {\n                difference\
    \ = temp;\n                result1 = numbers[i];\n                result2 = numbers[j];\n\
    \            }\n            else if (temp == difference)\n            {\n    \
    \            if (numbers[i] < result1)\n                {\n                  \
    \  result1 = numbers[i];\n                    result2 = numbers[j];\n        \
    \        }\n            }\n        }\n    }\n    return tuple(result1, result2);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpksnzks9x.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fd1]

    ??:? void tmpksnzks9x.__unittest_L43_C1() [0x428f8d]

    ??:? void tmpksnzks9x.__modtest() [0x429988]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ece3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbf2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432519]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4324a5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dbc9]

    ??:? runModuleUnitTests [0x42eab9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    if (numbers.length < 2)\n        throw new Exception(\"array must have\
    \ at least two elements\");\n    size_t i, j;\n    float d, min_d;\n    Tuple!(float,\
    \ float) closest;\n    min_d = abs(numbers[0] - numbers[1]);\n    closest = tuple(numbers[0],\
    \ numbers[1]);\n    for (i = 0; i < numbers.length; i++)\n    {\n        for (j\
    \ = i + 1; j < numbers.length; j++)\n        {\n            d = abs(numbers[i]\
    \ - numbers[j]);\n            if (d < min_d)\n            {\n                min_d\
    \ = d;\n                closest = tuple(numbers[i], numbers[j]);\n           \
    \ }\n        }\n    }\n    return closest;\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpegg4uyjk.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a195]

    ??:? void tmpegg4uyjk.__unittest_L35_C1() [0x4290a5]

    ??:? void tmpegg4uyjk.__modtest() [0x429b68]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f497]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e3a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432ccd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43317c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432c59]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e37d]

    ??:? runModuleUnitTests [0x42f26d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a6e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    auto smallest_diff = numbers[1] - numbers[0];\n    auto output = tuple(numbers[0],\
    \ numbers[1]);\n    foreach(n; numbers) \n    {\n        foreach(m; numbers) \n\
    \        {\n            if (n > m)\n            {\n                auto diff =\
    \ n - m;\n                if (diff < smallest_diff)\n                {\n     \
    \               smallest_diff = diff;\n                    output = tuple(m, n);\n\
    \                }\n            }\n        }\n    }\n    return output;\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5d2m8le9.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f9d]

    ??:? void tmp5d2m8le9.__unittest_L33_C1() [0x428f4d]

    ??:? void tmp5d2m8le9.__modtest() [0x429a04]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ef77]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42de86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4327ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432c5c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432739]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42de5d]

    ??:? runModuleUnitTests [0x42ed4d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a4ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length > 1);\n    float[]   diffs;\n    float   min,\
    \ max;\n    float   tempDiff;\n    float   minDiff;\n    int i,j;\n    // create\
    \ an array of the differences between each number and its neighbour\n    // the\
    \ first and last elements will be ignored, as they have no neighbour\n    diffs\
    \ = new float[numbers.length-1];\n    for (i=0; i<diffs.length; i++)\n    {\n\
    \        diffs[i] = abs(numbers[i] - numbers[i+1]);\n    }\n    // find the smallest\
    \ difference, which will give the two closest numbers\n    minDiff = diffs[0];\n\
    \    for (i=1; i<diffs.length; i++)\n    {\n        if (diffs[i] < minDiff)\n\
    \        {\n            minDiff = diffs[i];\n        }\n    }\n    // find the\
    \ first number in the array of differences that matches the smallest difference\n\
    \    // the index of that number is the index of the smaller number in the original\
    \ array\n    for (i=0; i<diffs.length; i++)\n    {\n        if (diffs[i] == minDiff)\n\
    \        {\n            break;\n        }\n    }\n    // the smaller number is\
    \ in i, the larger number is in i+1\n    return tuple(numbers[i], numbers[i+1]);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw9iteq7t.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a099]

    ??:? void tmpw9iteq7t.__unittest_L48_C1() [0x429051]

    ??:? void tmpw9iteq7t.__modtest() [0x429a4c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42efa3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42deb2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4328d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432d80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43285d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42de89]

    ??:? runModuleUnitTests [0x42ed79]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a55c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length > 1);\n    size_t min_index1 = 0;\n    size_t\
    \ min_index2 = 1;\n    float min_delta = abs(numbers[0] - numbers[1]);\n    for\
    \ (size_t i = 0; i < numbers.length; i++)\n    {\n        for (size_t j = i +\
    \ 1; j < numbers.length; j++)\n        {\n            if (abs(numbers[i] - numbers[j])\
    \ < min_delta)\n            {\n                min_delta = abs(numbers[i] - numbers[j]);\n\
    \                min_index1 = i;\n                min_index2 = j;\n          \
    \  }\n        }\n    }\n    return tuple(numbers[min_index1], numbers[min_index2]);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfvsv3ywa.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fa9]

    ??:? void tmpfvsv3ywa.__unittest_L32_C1() [0x428f65]

    ??:? void tmpfvsv3ywa.__modtest() [0x429960]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ecbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbca]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43247d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dba1]

    ??:? runModuleUnitTests [0x42ea91]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a46c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tTuple!(float, float) ClosestPair;\n\tClosestPair = tuple(numbers[0],\
    \ numbers[1]);\n\tfloat ClosestDifference = abs(ClosestPair[0] - ClosestPair[1]);\n\
    \tfor (int i = 0; i < numbers.length; i++)\n\t{\n\t\tfor (int j = i + 1; j < numbers.length;\
    \ j++)\n\t\t{\n\t\t\tfloat Difference = abs(numbers[i] - numbers[j]);\n\t\t\t\
    if (Difference < ClosestDifference)\n\t\t\t{\n\t\t\t\tClosestDifference = Difference;\n\
    \t\t\t\tClosestPair = tuple(numbers[i], numbers[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\
    return ClosestPair;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv5wj7svj.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a02d]

    ??:? void tmpv5wj7svj.__unittest_L31_C1() [0x428fd5]

    ??:? void tmpv5wj7svj.__modtest() [0x429a98]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f02b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42df3a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432861]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432d10]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4327ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42df11]

    ??:? runModuleUnitTests [0x42ee01]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a57c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float first = numbers[0];\n    float second = numbers[1];\n    float\
    \ minimum = abs(first - second);\n    foreach(n; 1..numbers.length)\n    {\n \
    \       float temp = abs(numbers[n] - numbers[n-1]);\n        if(temp < minimum)\n\
    \        {\n            minimum = temp;\n            first = numbers[n-1];\n \
    \           second = numbers[n];\n        }\n    }\n    return tuple(first, second);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdijlj4dq.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e65]

    ??:? void tmpdijlj4dq.__unittest_L29_C1() [0x428ed1]

    ??:? void tmpdijlj4dq.__modtest() [0x4298cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb77]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43285c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432339]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da5d]

    ??:? runModuleUnitTests [0x42e94d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a328]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    import std.algorithm; \n    //Sort the array\n    numbers.sort;\n\
    \    //Get the length of the array\n    int len = numbers.length;\n    //Create\
    \ a tuple to return\n    auto tuple_to_return = tuple(numbers[0], numbers[1]);\n\
    \    //Current closest value\n    float close_value = abs(numbers[0] - numbers[1]);\n\
    \    //Loop through the array\n    for(int i = 0; i < len; i++)\n    {\n     \
    \   if(i + 1 < len)\n        {\n            //Get the value\n            float\
    \ current_value = abs(numbers[i] - numbers[i + 1]);\n            //If it is less,\
    \ then set it and set the tuple\n            if(current_value < close_value)\n\
    \            {\n                close_value = current_value;\n               \
    \ tuple_to_return = tuple(numbers[i], numbers[i + 1]);\n            }\n      \
    \  }\n    }\n    return tuple_to_return;\n}\n \n/*\n    From a supplied array\
    \ of numbers return only those that are evenly divisible by the supplied divisor.\n\
    \    >>> find_divisible_by_n([3, 4, 5, 6, 7, 8, 9, 10], 2)\n    [4, 6, 8, 10]\n\
    \    >>> find_divisible_by_n([3, 4, 5, 6, 7, 8, 9, 10], 3)\n    [3, 6, 9]\n  \
    \  >>> find_divisible_by_n([3, 4, 5, 6, 7, 8, 9, 10], 5)\n    [5, 10]\n*/\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplzb5hpl2.d(18): Error: cannot implicitly convert expression `numbers.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplzb5hpl2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    static if (numbers.length < 2) {\n        return tuple(numbers[0],\
    \ numbers[0]);\n    }\n    else {\n        float temp_distance = abs(numbers[0]\
    \ - numbers[1]);\n        Tuple!(float, float) closest_elements = tuple(numbers[0],\
    \ numbers[1]);\n        for (int i = 0; i < numbers.length; i++) {\n         \
    \   for (int j = i + 1; j < numbers.length; j++) {\n                if (abs(numbers[i]\
    \ - numbers[j]) < temp_distance) {\n                    temp_distance = abs(numbers[i]\
    \ - numbers[j]);\n                    closest_elements = tuple(numbers[i], numbers[j]);\n\
    \                }\n            }\n        }\n        return closest_elements;\n\
    \    }\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphu1soj07.d(14): Error: variable `numbers` cannot be read at compile
    time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphu1soj07.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min_diff = float.infinity;\n\
    \    float[] min_pair = null;\n    for (float i = 0; i < numbers.length; i++)\
    \ \n    {\n        for (float j = i + 1; j < numbers.length; j++) \n        {\n\
    \            float diff = abs(numbers[i] - numbers[j]);\n            if (diff\
    \ < min_diff) \n            {\n                min_diff = diff;\n            \
    \    min_pair = [numbers[i], numbers[j]];\n            }\n        }\n    }\n \
    \   return tuple(min_pair[0], min_pair[1]);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvp3ycpb8.d(21): Error: cannot implicitly convert expression `i`
    of type `float` to `ulong`

    /tmp/tmpvp3ycpb8.d(21): Error: cannot implicitly convert expression `j` of type
    `float` to `ulong`

    /tmp/tmpvp3ycpb8.d(25): Error: cannot implicitly convert expression `i` of type
    `float` to `ulong`

    /tmp/tmpvp3ycpb8.d(25): Error: cannot implicitly convert expression `j` of type
    `float` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvp3ycpb8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    float min_diff = real.infinity; \n    float a; \n    float b; \n \
    \   foreach (n1; numbers) { \n        foreach (n2; numbers) { \n            if\
    \ (abs(n1 - n2) < min_diff) { \n                min_diff = abs(n1 - n2); \n  \
    \              a = n1; \n                b = n2; \n            } \n        } \n\
    \    } \n    return tuple(a, b); \n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpocxx0d69.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x429dfd]

    ??:? void tmpocxx0d69.__unittest_L28_C1() [0x428e69]

    ??:? void tmpocxx0d69.__modtest() [0x429864]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ea9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42d9aa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4322d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432780]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43225d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42d981]

    ??:? runModuleUnitTests [0x42e871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a24c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min_diff = abs(numbers[0] -\
    \ numbers[1]);\n    float result_a = numbers[0];\n    float result_b = numbers[1];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        for (int j = i +\
    \ 1; j < numbers.length; j++)\n        {\n            float diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < min_diff)\n            {\n          \
    \      min_diff = diff;\n                result_a = numbers[i];\n            \
    \    result_b = numbers[j];\n            }\n        }\n    }\n    return tuple(result_a,\
    \ result_b);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n\
    \    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n \
    \   assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpel9dyddm.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fa9]

    ??:? void tmpel9dyddm.__unittest_L33_C1() [0x428f65]

    ??:? void tmpel9dyddm.__modtest() [0x429960]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ecbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbca]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43247d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dba1]

    ??:? runModuleUnitTests [0x42ea91]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a46c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    // your code here\n    auto closestNumber1 = numbers[0];\n    auto\
    \ closestNumber2 = numbers[1];\n    auto minDiff = abs(closestNumber1 - closestNumber2);\n\
    \    for (auto i = 0; i < numbers.length; i++)\n    {\n        for (auto j = i+1;\
    \ j < numbers.length; j++)\n        {\n            auto diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < minDiff)\n            {\n           \
    \     minDiff = diff;\n                closestNumber1 = numbers[i];\n        \
    \        closestNumber2 = numbers[j];\n            }\n        }\n    }\n    return\
    \ tuple(closestNumber1, closestNumber2);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplr7s10g3.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e65]

    ??:? void tmplr7s10g3.__unittest_L33_C1() [0x428ed5]

    ??:? void tmplr7s10g3.__modtest() [0x4298d0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb77]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43285c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432339]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da5d]

    ??:? runModuleUnitTests [0x42e94d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a328]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float[] differences = new float[numbers.length\
    \ - 1];\n    for (int i = 0; i < numbers.length - 1; i++)\n    {\n        differences[i]\
    \ = abs(numbers[i] - numbers[i + 1]);\n    }\n    int index_min = 0;\n    for\
    \ (int i = 0; i < differences.length; i++)\n    {\n        if (differences[i]\
    \ < differences[index_min])\n        {\n            index_min = i;\n        }\n\
    \    }\n    return tuple(numbers[index_min], numbers[index_min + 1]);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpybswxli6.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fe9]

    ??:? void tmpybswxli6.__unittest_L30_C1() [0x428fa1]

    ??:? void tmpybswxli6.__modtest() [0x42999c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eef3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42de02]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432cd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4327ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ddd9]

    ??:? runModuleUnitTests [0x42ecc9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a4ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    static assert(numbers.length >= 2);\n    float min = abs(numbers[0]\
    \ - numbers[1]);\n    Tuple!(float, float) result = tuple(numbers[0], numbers[1]);\n\
    \    for (uint i = 0; i < numbers.length; i++) \n    {\n        for (uint j =\
    \ i + 1; j < numbers.length; j++) \n        {\n            float cur = abs(numbers[i]\
    \ - numbers[j]);\n            if (cur < min) \n            {\n               \
    \ min = cur;\n                result = tuple(numbers[i], numbers[j]);\n      \
    \      }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7jwpulxw.d(14): Error: variable `numbers` cannot be read at compile
    time

    /tmp/tmp7jwpulxw.d(14):        while evaluating: `static assert(numbers.length
    >= 2LU)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7jwpulxw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    // calculating the closest elements in an array to each other\n   \
    \ float[] array = numbers[];\n    int len = array.length;\n    float diff = array[1]\
    \ - array[0];\n    float a = array[0];\n    float b = array[1];\n    for (int\
    \ i = 0; i < len; i++)\n    {\n        for (int j = i + 1; j < len; j++)\n   \
    \     {\n            if (array[j] - array[i] < diff)\n            {\n        \
    \        a = array[i];\n                b = array[j];\n                diff =\
    \ b - a;\n            }\n        }\n    }\n    return tuple(a, b);\n}\n/*\nFrom\
    \ a supplied array of numbers (of length at least two) select and return two that\
    \ are the farthest from each\nother and return them in order (smaller number,\
    \ larger number).\n>>> find_farthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
    tuple(1.0, 5.0)\n>>> find_farthest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
    tuple(1.0, 5.0)\n*/\nTuple!(float, float) find_farthest_elements(float[] numbers)\
    \ \n{\n    // calculating the farthest elements in an array from each other\n\
    \    float[] array = numbers[];\n    int len = array.length;\n    float diff =\
    \ array[1] - array[0];\n    float a = array[0];\n    float b = array[1];\n   \
    \ for (int i = 0; i < len; i++)\n    {\n        for (int j = i + 1; j < len; j++)\n\
    \        {\n            if (array[j] - array[i] > diff)\n            {\n     \
    \           a = array[i];\n                b = array[j];\n                diff\
    \ = b - a;\n            }\n        }\n    }\n    return tuple(a, b);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiph13xhh.d(16): Error: cannot implicitly convert expression `array.length`
    of type `ulong` to `int`

    /tmp/tmpiph13xhh.d(46): Error: cannot implicitly convert expression `array.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiph13xhh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float minDiff;\n    Tuple!(float, float) result;\n    assert(numbers.length\
    \ > 1);\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe5ja5kkb.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe5ja5kkb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float minDiff = float.max;\n    float\
    \ minA = 0.0;\n    float minB = 0.0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        float n = numbers[i];\n        for (int j = i + 1; j <\
    \ numbers.length; j++)\n        {\n            float m = numbers[j];\n       \
    \     float diff = abs(n - m);\n            if (diff < minDiff)\n            {\n\
    \                minDiff = diff;\n                minA = min(n, m);\n        \
    \        minB = max(n, m);\n            }\n        }\n    }\n    return tuple(minA,\
    \ minB);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n   \
    \ assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppcy1wetb.d(28): Error: undefined identifier `min`, did you mean
    variable `minA`?

    /tmp/tmppcy1wetb.d(29): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppcy1wetb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    return zip(numbers[1..$], numbers[0..$-1])\n\
    \        .map!(pair => (pair[0] - pair[1]).abs)\n        .minIndex\n        .reduce!((prev,\
    \ x) => (prev[0] + x[0], prev[1] + x[1]))\n        .map!(pair => (numbers[pair[0]],\
    \ numbers[pair[1]]))\n        .map!(pair => (min(pair[0], pair[1]), max(pair[0],\
    \ pair[1])))\n        .reduce!((a, b) => a);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcs_2cfcl.d(15): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcs_2cfcl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min = numbers[0];\n    float\
    \ second = numbers[1];\n    if (min > second)\n    {\n        min = numbers[1];\n\
    \        second = numbers[0];\n    }\n    float dist = second - min;\n    for\
    \ (size_t i = 2; i < numbers.length; i++)\n    {\n        float n = numbers[i];\n\
    \        if (n < min)\n        {\n            if (min - n < dist)\n          \
    \  {\n                dist = min - n;\n                second = min;\n       \
    \         min = n;\n            }\n        }\n        else if (n > second)\n \
    \       {\n            if (n - second < dist)\n            {\n               \
    \ dist = n - second;\n                min = second;\n                second =\
    \ n;\n            }\n        }\n        else\n        {\n            if (min -\
    \ n < dist)\n            {\n                dist = min - n;\n                second\
    \ = n;\n            }\n            else if (n - second < dist)\n            {\n\
    \                dist = n - second;\n                min = n;\n            }\n\
    \        }\n    }\n    return tuple(min, second);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp94q9iuc4.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f99]

    ??:? void tmp94q9iuc4.__unittest_L60_C1() [0x428f5d]

    ??:? void tmp94q9iuc4.__modtest() [0x42994c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec87]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43296c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432449]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db6d]

    ??:? runModuleUnitTests [0x42ea5d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a45c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min_delta = abs(numbers[0] - numbers[1]);\n    float a = numbers[0];\n\
    \    float b = numbers[1];\n    for (int i = 0; i < numbers.length; i++) \n  \
    \  {\n        for (int j = i + 1; j < numbers.length; j++) \n        {\n     \
    \       float delta = abs(numbers[i] - numbers[j]);\n            if (delta < min_delta)\
    \ \n            {\n                min_delta = delta;\n                a = numbers[i];\n\
    \                b = numbers[j];\n            }\n        }\n    }\n    return\
    \ tuple(a, b);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkd0c90lm.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x429eb5]

    ??:? void tmpkd0c90lm.__unittest_L32_C1() [0x428f21]

    ??:? void tmpkd0c90lm.__modtest() [0x42991c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ebc7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dad6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4328ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432389]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42daad]

    ??:? runModuleUnitTests [0x42e99d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a378]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    //{   Tuple!(float, float) result;\n    //    float diff=999.0;\n \
    \   //    for(uint i=0; i<numbers.length; ++i)\n    //    {\n    //        for(uint\
    \ j=i+1; j<numbers.length; ++j)\n    //        {\n    //            if(abs(numbers[i]-numbers[j])<diff)\n\
    \    //            {\n    //                diff=abs(numbers[i]-numbers[j]);\n\
    \    //                result=tuple(numbers[i], numbers[j]);\n    //         \
    \   }\n    //        }\n    //    }\n    //    return result;\n    //}\n    float\
    \ n1, n2;\n    float diff=999.0;\n    for(uint i=0; i<numbers.length; ++i)\n \
    \   {\n        for(uint j=i+1; j<numbers.length; ++j)\n        {\n           \
    \ if(abs(numbers[i]-numbers[j])<diff)\n            {\n                diff=abs(numbers[i]-numbers[j]);\n\
    \                n1=numbers[i];\n                n2=numbers[j];\n            }\n\
    \        }\n    }\n    return tuple(n1, n2);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpc7rh2ge1.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e7d]

    ??:? void tmpc7rh2ge1.__unittest_L45_C1() [0x428ee9]

    ??:? void tmpc7rh2ge1.__modtest() [0x4298e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb8f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432874]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432351]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da75]

    ??:? runModuleUnitTests [0x42e965]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a340]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    double difference = 1e40;\n    Tuple!(double, double) closestNumbers\
    \ = Tuple!(double, double)(1e40, 1e40);\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (int j = i+1; j < numbers.length; j++)\n        {\n\
    \            if (abs(numbers[i] - numbers[j]) < difference)\n            {\n \
    \               difference = abs(numbers[i] - numbers[j]);\n                closestNumbers\
    \ = Tuple!(double, double)(numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    return Tuple!(float, float)(cast(float)closestNumbers[0], cast(float)closestNumbers[1]);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsn0lnaff.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a04d]

    ??:? void tmpsn0lnaff.__unittest_L29_C1() [0x429025]

    ??:? void tmpsn0lnaff.__modtest() [0x429ab8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f04b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42df5a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432d30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43280d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42df31]

    ??:? runModuleUnitTests [0x42ee21]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a59c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float minDiff = 9999.0;\n    float[] result = new float[2];\n    foreach(float\
    \ x; numbers)\n    {\n        foreach(float y; numbers)\n        {\n         \
    \   if(x == y)\n                continue;\n            if(abs(x - y) < minDiff)\n\
    \            {\n                minDiff = abs(x - y);\n                result[0]\
    \ = min(x, y);\n                result[1] = max(x, y);\n            }\n      \
    \  }\n    }\n    return tuple(result[0], result[1]);\n}\nunittest\n{\n    alias\
    \ candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) ==\
    \ tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0,\
    \ 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0t17ueuh.d(25): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp0t17ueuh.d(26): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0t17ueuh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    if (numbers.length == 2) \n    {\n        if (numbers[0] < numbers[1])\n\
    \            return tuple(numbers[0], numbers[1]);\n        else\n           \
    \ return tuple(numbers[1], numbers[0]);\n    }\n    else\n    {\n        float\
    \ minNum = numbers[0];\n        float maxNum = numbers[0];\n        for (int i\
    \ = 1; i < numbers.length; i++)\n        {\n            if (numbers[i] < minNum)\
    \ minNum = numbers[i];\n            if (numbers[i] > maxNum) maxNum = numbers[i];\n\
    \        }\n        float delta = maxNum - minNum;\n        for (int i = 0; i\
    \ < numbers.length; i++)\n        {\n            for (int j = i+1; j < numbers.length;\
    \ j++)\n            {\n                float temp = abs(numbers[i] - numbers[j]);\n\
    \                if (temp < delta)\n                {\n                    minNum\
    \ = min(numbers[i], numbers[j]);\n                    maxNum = max(numbers[i],\
    \ numbers[j]);\n                    delta = temp;\n                }\n       \
    \     }\n        }\n        return tuple(minNum, maxNum);\n    }\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpco66p4ae.d(38): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpco66p4ae.d(39): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpco66p4ae.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float[] difference = new float[];\n    foreach(n; numbers)\n    {\n\
    \        difference ~= abs(numbers[0] - n);\n    }\n    size_t min = minIndex(difference);\n\
    \    return tuple(numbers[0], numbers[min]);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbnc92s4c.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `float[]`''s

    /tmp/tmpbnc92s4c.d(19): Error: undefined identifier `minIndex`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbnc92s4c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    float min = 3;\n    float a, b;\n    foreach(i, n; numbers)\n    {\n\
    \        foreach(j, m; numbers)\n        {\n            if(i != j)\n         \
    \   {\n                float diff = abs(n - m);\n                if(diff < min)\n\
    \                {\n                    min = diff;\n                    a = n;\n\
    \                    b = m;\n                }\n            }\n        }\n   \
    \ }\n    return tuple(a, b);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxg7v2e6v.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e05]

    ??:? void tmpxg7v2e6v.__unittest_L34_C1() [0x428e75]

    ??:? void tmpxg7v2e6v.__modtest() [0x429870]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eaa3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42d9b2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4322d9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432788]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432265]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42d989]

    ??:? runModuleUnitTests [0x42e879]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a254]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float first, second;\n    float diff;\n    float diffMin = abs(numbers[0]\
    \ - numbers[1]);\n    float diffTemp;\n    first = numbers[0];\n    second = numbers[1];\n\
    \    foreach(i, e1; numbers)\n    {\n        foreach(e2; numbers[i + 1 .. $])\n\
    \        {\n            diffTemp = abs(e1 - e2);\n            if(diffTemp < diffMin)\n\
    \            {\n                diffMin = diffTemp;\n                first = e1;\n\
    \                second = e2;\n            }\n        }\n    }\n    return tuple(first,\
    \ second);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n \
    \   assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n  \
    \  assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpshp5hn16.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ecd]

    ??:? void tmpshp5hn16.__unittest_L35_C1() [0x428f3d]

    ??:? void tmpshp5hn16.__modtest() [0x429938]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ebdf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42daee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432415]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4328c4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4323a1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dac5]

    ??:? runModuleUnitTests [0x42e9b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a390]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float closestDistance = float.max;\n    float closestNumber = float.max;\n\
    \    float farthestNumber = float.max;\n    for (size_t i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (size_t j = i + 1; j < numbers.length; j++)\n     \
    \   {\n            float difference = abs(numbers[i] - numbers[j]);\n        \
    \    if (difference < closestDistance)\n            {\n                closestDistance\
    \ = difference;\n                closestNumber = min(numbers[i], numbers[j]);\n\
    \                farthestNumber = max(numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    return tuple(closestNumber, farthestNumber);\n}\n/*\n Define\
    \ an immutable struct to represent a complex number (https://en.wikipedia.org/wiki/Complex_number).\n\
    \    * Provide means to add, subtract, multiply, and divide complex numbers.\n\
    \    * Provide means to find the magnitude of a complex number.\n    * Provide\
    \ means to compare complex numbers by magnitude.\n    * Provide a function that\
    \ returns an array of complex numbers each shifted by a random angle\n      (https://en.wikipedia.org/wiki/Complex_number#Polar_form_and_argument)\
    \ of between 0 to 2\u03C0.\n    >>> cnums = random_complex_numbers(4);\n    >>>\
    \ cnums.map!(a => a.magnitude).sum\n    17.0547677036\n    >>> cnums.map!(a =>\
    \ a.magnitude).sum\n    18.0127336899\n    >>> cnums.map!(a => a.magnitude).sum\n\
    \    16.7606296527\n    >>> cnums.map!(a => a.magnitude).sum\n    18.3529853948\n\
    \    >>> cnums.map!(a => a.magnitude).sum\n    16.3336409242\n*/\nstruct Complex\
    \ \n{\n    // https://en.wikipedia.org/wiki/Complex_number#Complex_plane\n   \
    \ public float re, im;\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeagqrs3s.d(65): Error: `}` expected following members in `struct`
    declaration at /tmp/tmpeagqrs3s.d(51)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeagqrs3s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float diff = abs(numbers[0] - numbers[1]);\n\
    \    float a = numbers[0];\n    float b = numbers[1];\n    float curr;\n    float\
    \ curr2;\n    foreach(i; 2..numbers.length)\n    {\n        curr = numbers[i];\n\
    \        curr2 = numbers[i-1];\n        if(abs(curr - curr2) < diff)\n       \
    \ {\n            diff = abs(curr - curr2);\n            a = curr2;\n         \
    \   b = curr;\n        }\n    }\n    return tuple(a, b);\n}\n/*\nArrays with negative\
    \ indices are not allowed, but slicing can be used to achieve a similar behavior.\n\
    \    >>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][-2:]\n    [8, 9]\n    \n*/\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpybbbdeu9.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f89]

    ??:? void tmpybbbdeu9.__unittest_L39_C1() [0x428f45]

    ??:? void tmpybbbdeu9.__modtest() [0x429940]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbaa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432980]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43245d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db81]

    ??:? runModuleUnitTests [0x42ea71]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a44c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float minDistance = float.infinity;\n\
    \    int index = 0;\n    for (int i = 0; i < numbers.length - 1; i++) \n    {\n\
    \        float distance = abs(numbers[i] - numbers[i + 1]);\n        if (distance\
    \ < minDistance) \n        {\n            minDistance = distance;\n          \
    \  index = i;\n        }\n    }\n    return tuple(numbers[index], numbers[index\
    \ + 1]);\n}\n/*\n Given a string S, return the number of syllables it contains.\
    \ Follow the rules below:\n \n    Every 'a', 'e', 'i', 'o', 'u' and 'y' is a vowel.\n\
    \    If there is a 'y' after a consonant, it is a vowel.\n    Two or more consecutive\
    \ vowels form a dipthong.\n    Two or more consecutive consonants form a cluster.\n\
    \    Syllables are separated by one or more vowels.\n    The first and last letters\
    \ of S are always consonants.\n    \n    There will be no invalid cases (the string\
    \ will always be of the correct form).\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1h3qr3ik.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1h3qr3ik.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float first = numbers[0];\n    float second = numbers[1];\n    float\
    \ diff = second - first;\n    foreach(float current; numbers)\n    {\n       \
    \ foreach(float next; numbers)\n        {\n            if(current == next)\n \
    \               continue;\n            if(diff > abs(current - next))\n      \
    \      {\n                diff = abs(current - next);\n                first =\
    \ current;\n                second = next;\n            }\n        }\n    }\n\
    \    return tuple(first, second);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi5tm2wea.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e4d]

    ??:? void tmpi5tm2wea.__unittest_L33_C1() [0x428eb9]

    ??:? void tmpi5tm2wea.__modtest() [0x4298b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb5f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432395]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432844]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432321]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da45]

    ??:? runModuleUnitTests [0x42e935]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a310]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    //sort the array\n    sort(numbers);\n    float best_diff = 2.0;\n\
    \    float best_idx1 = 0.0;\n    float best_idx2 = 0.0;\n    for (int i = 0; i\
    \ < numbers.length - 1; i ++) \n    {\n        float diff = abs(numbers[i] - numbers[i\
    \ + 1]);\n        if (diff < best_diff) \n        {\n            best_diff = diff;\n\
    \            best_idx1 = numbers[i];\n            best_idx2 = numbers[i + 1];\n\
    \        }\n    }\n    return tuple(best_idx1, best_idx2);\n}\nunittest\n{\n \
    \   alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp74m5_v_a.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp74m5_v_a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    Tuple!(float, float) res = tuple(numbers[0],\
    \ numbers[1]);\n    float min_diff =  abs(numbers[0] - numbers[1]);\n    for (int\
    \ i = 0; i < numbers.length - 1; i++)\n    {\n        for (int j = i + 1; j <\
    \ numbers.length; j++)\n        {\n            float diff = abs(numbers[i] - numbers[j]);\n\
    \            if (diff < min_diff)\n            {\n                min_diff = diff;\n\
    \                res = tuple(numbers[i], numbers[j]);\n            }\n       \
    \ }\n    }\n    return res;\n}\n/*\n From a supplied array of numbers (of length\
    \ at least three) select and return three that are the closest to each\n    other\
    \ and return them in order (smallest number, middle number, largest number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2, 3.0)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n \
    \   tuple(2.0, 2.0, 3.0)\n    \n*/\nTuple!(float, float, float) find_closest_elements(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 3);\n    Tuple!(float, float, float)\
    \ res = tuple(numbers[0], numbers[1], numbers[2]);\n    float min_diff =  abs(numbers[0]\
    \ - numbers[1]);\n    for (int i = 0; i < numbers.length - 2; i++)\n    {\n  \
    \      for (int j = i + 1; j < numbers.length - 1; j++)\n        {\n         \
    \   for (int k = j + 1; k < numbers.length; k++)\n            {\n            \
    \    float diff = abs(numbers[i] - numbers[j]) + abs(numbers[j] - numbers[k]);\n\
    \                if (diff\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7zsjqbn1.d(53): Error: found `unittest` when expecting `)`

    /tmp/tmp7zsjqbn1.d(63): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp7zsjqbn1.d(63): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp7zsjqbn1.d(63): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp7zsjqbn1.d(63): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7zsjqbn1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length > 1);\n    float smallest_distance;\n    float\
    \ first_element;\n    float second_element;\n    float first_index;\n    float\
    \ second_index;\n    foreach(index, element; numbers)\n    {\n        for(int\
    \ i = index+1; i < numbers.length; i++)\n        {\n            float distance\
    \ = abs(element - numbers[i]);\n            if (first_element == 0.0f)\n     \
    \       {\n                smallest_distance = distance;\n                first_element\
    \ = element;\n                second_element = numbers[i];\n                first_index\
    \ = index;\n                second_index = i;\n            }\n            else\
    \ if (distance < smallest_distance)\n            {\n                smallest_distance\
    \ = distance;\n                first_element = element;\n                second_element\
    \ = numbers[i];\n                first_index = index;\n                second_index\
    \ = i;\n            }\n        }\n    }\n    if (first_index < second_index)\n\
    \    {\n        return tuple(first_element, second_element);\n    }\n    else\n\
    \    {\n        return tuple(second_element, first_element);\n    }\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppg1d_psv.d(22): Error: cannot implicitly convert expression `index
    + 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppg1d_psv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float smallest_gap = std.float.max;\n    float smallest = 0.0;\n  \
    \  float largest = 0.0;\n    for (int i = 0; i < numbers.length - 1; i++) \n \
    \   {\n        float diff = abs(numbers[i] - numbers[i + 1]);\n        if (diff\
    \ < smallest_gap) \n        {\n            smallest_gap = diff;\n            smallest\
    \ = min(numbers[i], numbers[i + 1]);\n            largest = max(numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    return tuple(smallest, largest);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxgu7y29.d(14): Error: identifier expected following `.`, not `float`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxgu7y29.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min = 1e6;\n    Tuple!(float, float) best_pair = tuple(numbers[0],\
    \ numbers[1]);\n    for (auto n1, n2; zip(numbers[0..$-1], numbers[1..$]))\n \
    \   {\n        float diff = abs(n1 - n2);\n        if (diff < min)\n        {\n\
    \            min = diff;\n            best_pair = tuple(n1, n2);\n        }\n\
    \    }\n    return best_pair;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnwm_3jqq.d(16): Error: no identifier for declarator `n1`

    /tmp/tmpnwm_3jqq.d(16): Error: expression expected, not `,`

    /tmp/tmpnwm_3jqq.d(16): Error: found `n2` when expecting `;` following `for` condition

    /tmp/tmpnwm_3jqq.d(16): Error: expression expected, not `;`

    /tmp/tmpnwm_3jqq.d(16): Error: found `zip` when expecting `)`

    /tmp/tmpnwm_3jqq.d(16): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnwm_3jqq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164327
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    import std.range: max;\n    import std.algorithm: sort;\n    import\
    \ std.algorithm: map;\n    import std.array: array;\n    import std.conv: to;\n\
    \    import std.format: format;\n    import std.math: abs;\n    import std.stdio:\
    \ writeln;\n    auto sorted = numbers.sort().map!(n => n.to!string).array;\n \
    \   auto r = sorted.max();\n    return tuple(r[0], r[1]);\n}\nunittest\n{\n  \
    \  alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpul1vpdji.d(14): Error: module `std.range` import `max` not found

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpul1vpdji.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min = 0.0;\n    float min1 = 0.0;\n    float min2 = 0.0;\n  \
    \  for (int i = 0; i < numbers.length - 1; i++)\n    {\n        if (min > abs(numbers[i]\
    \ - numbers[i + 1]))\n        {\n            min = abs(numbers[i] - numbers[i\
    \ + 1]);\n            min1 = numbers[i];\n            min2 = numbers[i + 1];\n\
    \        }\n    }\n    return tuple(min1, min2);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5fwb3yn_.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e7d]

    ??:? void tmp5fwb3yn_.__unittest_L28_C1() [0x428eed]

    ??:? void tmp5fwb3yn_.__modtest() [0x4298e8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb8f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432874]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432351]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da75]

    ??:? runModuleUnitTests [0x42e965]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a340]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min = infinity;\n    float result1, result2;\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        float diff = abs(numbers[i] -\
    \ numbers[i + 1]);\n        if (diff < min)\n        {\n            min = diff;\n\
    \            result1 = numbers[i];\n            result2 = numbers[i + 1];\n  \
    \      }\n    }\n    return tuple(result1, result2);\n}\n \nTuple!(float, float)\
    \ find_closest_elements2(float[] numbers) \n{\n    import std.algorithm : min,\
    \ max;\n    import std.range : move;\n    float min = infinity;\n    float result1,\
    \ result2;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        float\
    \ diff = abs(numbers[i] - numbers[i + 1]);\n        if (diff < min)\n        {\n\
    \            min = diff;\n            result1 = min(numbers[i], numbers[i + 1]);\n\
    \            result2 = max(numbers[i], numbers[i + 1]);\n        }\n    }\n  \
    \  return tuple(result1, result2);\n}\n \n/*\nSuppose you have a list of numbers\
    \ stored in a file and you want to sort them.\n    Instead of loading them into\
    \ memory you want to sort them in place in the file.\n    Given that you have\
    \ enough memory to hold a set of indices of the values to sort,\n    how would\
    \ you do it?\n    Write a function that receives a filename, a number of numbers\
    \ to sort, and the number of bytes\n    to use for each number.\n*/\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmfu_4j7p.d(14): Error: undefined identifier `infinity`, did you
    mean template `isInfinity(X)(X x) if (isFloatingPoint!X)`?

    /tmp/tmpmfu_4j7p.d(32): Error: module `std.range` import `move` not found, did
    you mean alias `std.array.save`?

    /tmp/tmpmfu_4j7p.d(33): Error: undefined identifier `infinity`, did you mean template
    `isInfinity(X)(X x) if (isFloatingPoint!X)`?

    /tmp/tmpmfu_4j7p.d(33): Error: declaration `tmpmfu_4j7p.find_closest_elements2.min`
    is already defined

    /tmp/tmpmfu_4j7p.d(38): Error: void has no value

    /tmp/tmpmfu_4j7p.d(38): Error: incompatible types for `(diff) < (min(T...)(T args)
    if (T.length >= 2))`: `float` and `void`

    /tmp/tmpmfu_4j7p.d(40): Error: not a property min(T...)(T args) if (T.length >=
    2)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmfu_4j7p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float minimumDiff = abs(numbers[0]\
    \ - numbers[1]);\n    int[] idx = [0, 1];\n    for (int i = 0; i < numbers.length;\
    \ i++) \n    {\n        for (int j = i + 1; j < numbers.length; j++) \n      \
    \  {\n            float currDiff = abs(numbers[i] - numbers[j]);\n           \
    \ if (currDiff < minimumDiff) \n            {\n                minimumDiff = currDiff;\n\
    \                idx = [i, j];\n            }\n        }\n    }\n    return tuple(numbers[idx[0]],\
    \ numbers[idx[1]]);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpakw_rdr_.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a269]

    ??:? void tmpakw_rdr_.__unittest_L31_C1() [0x429225]

    ??:? void tmpakw_rdr_.__modtest() [0x429c20]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f15f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e06e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432995]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432e44]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432921]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e045]

    ??:? runModuleUnitTests [0x42ef35]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a72c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float smallestDiff = float.max;\n    float num1 = numbers[0];\n   \
    \ float num2 = numbers[1];\n    foreach(i, a; numbers)\n    {\n        foreach(j,\
    \ b; numbers)\n        {\n            if(i != j)\n            {\n            \
    \    float diff = abs(a - b);\n                if(diff < smallestDiff)\n     \
    \           {\n                    num1 = a;\n                    num2 = b;\n\
    \                    smallestDiff = diff;\n                }\n            }\n\
    \        }\n    }\n    return tuple(num1, num2);\n}\nunittest\n{\n    assert(find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp181_dpwa.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ff5]

    ??:? void tmp181_dpwa.__unittest_L35_C1() [0x428ee5]

    ??:? void tmp181_dpwa.__modtest() [0x429a58]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ed07]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dc16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43253d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329ec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4324c9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dbed]

    ??:? runModuleUnitTests [0x42eadd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a4b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    double firstElement = numbers[0];\n    double secondElement = numbers[1];\n\
    \    double minDistance = abs(firstElement - secondElement);\n    int length =\
    \ numbers.length;\n    for (int i = 0; i < length; i++)\n    {\n        for (int\
    \ j = i + 1; j < length; j++)\n        {\n            double currentDistance =\
    \ abs(numbers[i] - numbers[j]);\n            if (currentDistance < minDistance)\n\
    \            {\n                minDistance = currentDistance;\n             \
    \   firstElement = numbers[i];\n                secondElement = numbers[j];\n\
    \            }\n        }\n    }\n    return tuple(firstElement, secondElement);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbgv8pe2h.d(17): Error: cannot implicitly convert expression `numbers.length`
    of type `ulong` to `int`

    /tmp/tmpbgv8pe2h.d(31): Error: cannot implicitly convert expression `tuple(firstElement,
    secondElement)` of type `Tuple!(double, double)` to `Tuple!(float, float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbgv8pe2h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n    @safe pure nothrow\n{\n    assert(numbers.length >= 2);\n    float minDistance\
    \ = abs(numbers[0] - numbers[1]);\n    float first = numbers[0];\n    float second\
    \ = numbers[1];\n    for (int i = 0; i < numbers.length; i++) {\n        for (int\
    \ j = i + 1; j < numbers.length; j++) {\n            float distance = abs(numbers[i]\
    \ - numbers[j]);\n            if (distance < minDistance) {\n                minDistance\
    \ = distance;\n                first = numbers[i];\n                second = numbers[j];\n\
    \            }\n        }\n    }\n    return tuple(first, second);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqui9q6ga.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fa9]

    ??:? void tmpqui9q6ga.__unittest_L31_C1() [0x428f65]

    ??:? void tmpqui9q6ga.__modtest() [0x429960]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ecbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbca]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43247d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dba1]

    ??:? runModuleUnitTests [0x42ea91]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a46c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    auto start = 0;\n    auto end = 1;\n    auto closest = abs(numbers[start]\
    \ - numbers[end]);\n    for (auto i = 0; i < numbers.length - 1; i++)\n    {\n\
    \        for (auto j = i + 1; j < numbers.length; j++)\n        {\n          \
    \  auto diff = abs(numbers[i] - numbers[j]);\n            if (diff < closest)\n\
    \            {\n                start = i;\n                end = j;\n       \
    \         closest = diff;\n            }\n        }\n    }\n    return tuple(numbers[start],\
    \ numbers[end]);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphdtdfknh.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e65]

    ??:? void tmphdtdfknh.__unittest_L32_C1() [0x428ed1]

    ??:? void tmphdtdfknh.__modtest() [0x4298cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb77]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43285c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432339]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da5d]

    ??:? runModuleUnitTests [0x42e94d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a328]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    auto minDistance = numbers[1] - numbers[0];\n\
    \    auto minTuple = tuple(numbers[0], numbers[1]);\n    foreach(int i; 1..numbers.length\
    \ - 1)\n    {\n        auto distance = numbers[i+1] - numbers[i];\n        if(distance\
    \ < minDistance)\n        {\n            minDistance = distance;\n           \
    \ minTuple = tuple(numbers[i], numbers[i+1]);\n        }\n    }\n    return minTuple;\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq813bmzp.d(17): Error: cannot implicitly convert expression `numbers.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq813bmzp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    size_t t = numbers.length;\n    assert(t >= 2);\n    float m_diff =\
    \ abs(numbers[0] - numbers[1]);\n    Tuple!(float, float) m_closest = tuple(numbers[0],\
    \ numbers[1]);\n    for (size_t i = 0; i < t - 1; i++) \n    {\n        for (size_t\
    \ j = i + 1; j < t; j++) \n        {\n            float diff = abs(numbers[i]\
    \ - numbers[j]);\n            if (diff < m_diff) \n            {\n           \
    \     m_diff = diff;\n                m_closest = tuple(numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    return m_closest;\n}\nunittest\n{\n    alias\
    \ candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) ==\
    \ tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0,\
    \ 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphs_xywec.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a169]

    ??:? void tmphs_xywec.__unittest_L32_C1() [0x429059]

    ??:? void tmphs_xywec.__modtest() [0x429b1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f167]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e076]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43299d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432e4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432929]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e04d]

    ??:? runModuleUnitTests [0x42ef3d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a6b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n\tfloat a, b;\n\ta = b = numbers[0];\n\tfloat diff = a - b;\n\tforeach(i,\
    \ e; numbers)\n\t{\n\t\tfloat temp = numbers[i] - numbers[i+1];\n\t\tif(temp <\
    \ diff)\n\t\t{\n\t\t\ta = numbers[i];\n\t\t\tb = numbers[i+1];\n\t\t\tdiff = temp;\n\
    \t\t}\n\t}\n\treturn tuple(a, b);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp_y80lu9y.d(19): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x429e86]

    ??:? std.typecons.Tuple!(float, float).Tuple tmp_y80lu9y.find_closest_elements(float[])
    [0x428cf7]

    ??:? void tmp_y80lu9y.__unittest_L29_C1() [0x428e0e]

    ??:? void tmp_y80lu9y.__modtest() [0x429840]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eac3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42d9d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4322f9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4327a8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432285]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42d9a9]

    ??:? runModuleUnitTests [0x42e899]

    ??:? void rt.dmain2._d_ru'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    auto copy = numbers[];\n    sort(copy);\n    float mindiff = copy[1]\
    \ - copy[0];\n    for (int i = 1; i < copy.length - 1; i++)\n    {\n        auto\
    \ diff = copy[i + 1] - copy[i];\n        if (diff < mindiff)\n        {\n    \
    \        mindiff = diff;\n        }\n    }\n    Tuple!(float, float) output =\
    \ tuple(0.0, 0.0);\n    for (int i = 0; i < copy.length - 1; i++)\n    {\n   \
    \     auto diff = copy[i + 1] - copy[i];\n        if (diff == mindiff)\n     \
    \   {\n            output = tuple(copy[i], copy[i + 1]);\n        }\n    }\n \
    \   return output;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq4mwwx3c.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4mwwx3c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    import std.range;\n    // Find the smallest difference between two\
    \ items in a range\n    auto smallestDifference = (a, b) => a - b;\n    float\
    \ smallest = smallestDifference(numbers[0], numbers[1]);\n    // Store the pair\
    \ of numbers to return\n    float[] result;\n    foreach (index, item; numbers.skip(1))\
    \ \n    {\n        if (float difference = smallestDifference(item, numbers[index\
    \ - 1]);\n            abs(difference) < abs(smallest)) \n        {\n         \
    \   smallest = difference;\n            result ~= item;\n            result ~=\
    \ numbers[index - 1];\n        }\n    }\n    return tuple(min(result[0], result[1]),\
    \ max(result[0], result[1]));\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7kneadgo.d(22): Error: found `;` when expecting `)`

    /tmp/tmp7kneadgo.d(23): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7kneadgo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    return find_closest_elementsImpl(numbers);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbss6dwdc.d(15): Error: undefined identifier `find_closest_elementsImpl`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbss6dwdc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float a = numbers[0];\n    float\
    \ b = numbers[1];\n    float diff = abs(a - b);\n    foreach(i, value; numbers)\
    \ \n    {\n        if (i == 0) \n        {\n            continue;\n        }\n\
    \        float candidate = abs(value - numbers[i - 1]);\n        if (candidate\
    \ < diff) \n        {\n            a = numbers[i - 1];\n            b = value;\n\
    \            diff = candidate;\n        }\n    }\n    return tuple(a, b);\n}\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4l8gco55.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f49]

    ??:? void tmp4l8gco55.__unittest_L34_C1() [0x428f01]

    ??:? void tmp4l8gco55.__modtest() [0x4298fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db6a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432491]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432940]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43241d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db41]

    ??:? runModuleUnitTests [0x42ea31]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a40c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    enum minDist = DBL_MAX; \n    size_t index1, index2; \n    for (size_t\
    \ i = 0; i < numbers.length; i++) \n    { \n        for (size_t j = i + 1; j <\
    \ numbers.length; j++) \n        { \n            float dist = abs(numbers[i] -\
    \ numbers[j]); \n            if (dist < minDist) \n            { \n          \
    \      minDist = dist; \n                index1 = i; \n                index2\
    \ = j; \n            } \n        } \n    } \n    return tuple(numbers[index1],\
    \ numbers[index2]); \n} \n \nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphnwnvqum.d(14): Error: undefined identifier `DBL_MAX`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphnwnvqum.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    if (numbers.length < 2) return tuple();\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11au14m2.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11au14m2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min = 1.0e32;\n    int index1 = 0;\n    int index2 = 0;\n   \
    \ for (int i = 0; i < numbers.length - 1; i++)\n    {\n        for (int j = i\
    \ + 1; j < numbers.length; j++)\n        {\n            float dif = abs(numbers[i]\
    \ - numbers[j]);\n            if (dif < min)\n            {\n                min\
    \ = dif;\n                index1 = i;\n                index2 = j;\n         \
    \   }\n        }\n    }\n    return tuple(numbers[index1], numbers[index2]);\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the furthest from each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_furthest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(1.0, 5.0)\n    >>> find_furthest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(1.0, 5.0)\n*/\nTuple!(float, float) find_furthest_elements(float[]\
    \ numbers) \n{\n    float max = -1.0e32;\n    int index1 = 0;\n    int index2\
    \ = 0;\n    for (int i = 0; i < numbers.length - 1; i++)\n    {\n        for (int\
    \ j = i + 1; j < numbers.length; j++)\n        {\n            float dif = abs(numbers[i]\
    \ - numbers[j]);\n            if (dif > max)\n            {\n                max\
    \ = dif;\n                index1 = i;\n                index2 = j;\n         \
    \   }\n        }\n    }\n    return tuple(numbers[index1], numbers[index2]);\n\
    }\n/*\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiqmjkjs_.d(60): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiqmjkjs_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float small, large;\n    small =\
    \ large = numbers[0];\n    foreach(n; numbers)\n    {\n        if(n < small)\n\
    \            small = n;\n        if(n > large)\n            large = n;\n    }\n\
    \    return tuple(small, large);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp587x6zcs.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e31]

    ??:? void tmp587x6zcs.__unittest_L26_C1() [0x428df5]

    ??:? void tmp587x6zcs.__modtest() [0x4297e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb1f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da2e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432355]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432804]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4322e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da05]

    ??:? runModuleUnitTests [0x42e8f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a2f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tauto n = numbers.length;\n\tauto minDist = abs(numbers[1] - numbers[0]);\n\
    \tauto p = tuple(numbers[0], numbers[1]);\n\tfor (auto i = 0; i < n; i++)\n\t\
    {\n\t\tfor (auto j = i + 1; j < n; j++)\n\t\t{\n\t\t\tauto dist = abs(numbers[i]\
    \ - numbers[j]);\n\t\t\tif (dist < minDist)\n\t\t\t{\n\t\t\t\tp = tuple(numbers[i],\
    \ numbers[j]);\n\t\t\t\tminDist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7wuv6ipt.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a065]

    ??:? void tmp7wuv6ipt.__unittest_L31_C1() [0x42900d]

    ??:? void tmp7wuv6ipt.__modtest() [0x429ad0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f063]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42df72]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432899]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432d48]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432825]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42df49]

    ??:? runModuleUnitTests [0x42ee39]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a5b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float d_min = numeric_limits!float.infinity;\n    float a = numbers[0];\n\
    \    float b = numbers[1];\n    foreach(int i, float m; numbers) \n    {\n   \
    \     foreach(int j, float n; numbers) \n        {\n            if (i != j) \n\
    \            {\n                float d = abs(m - n);\n                if (d <\
    \ d_min) \n                {\n                    d_min = d;\n               \
    \     a = m;\n                    b = n;\n                }\n            }\n \
    \       }\n    }\n    return tuple(a, b);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc1qe_ysm.d(14): Error: template instance `numeric_limits!float`
    template `numeric_limits` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc1qe_ysm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length > 1);\n    float minimum = abs(numbers[0] - numbers[1]);\n\
    \    int idx = 0;\n    for (int i = 0; i < numbers.length - 1; i++)\n    {\n \
    \       auto c = abs(numbers[i] - numbers[i + 1]);\n        if (c < minimum)\n\
    \        {\n            minimum = c;\n            idx = i;\n        }\n    }\n\
    \    return tuple(numbers[idx], numbers[idx + 1]);\n}\nunittest\n{\n    alias\
    \ candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) ==\
    \ tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0,\
    \ 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2i5tsbyw.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f31]

    ??:? void tmp2i5tsbyw.__unittest_L28_C1() [0x428eed]

    ??:? void tmp2i5tsbyw.__modtest() [0x4298e8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db52]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432479]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432928]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432405]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db29]

    ??:? runModuleUnitTests [0x42ea19]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a3f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length > 1);\n    float min_diff = numbers[1] - numbers[0];\n\
    \    float min_val1 = numbers[0];\n    float min_val2 = numbers[1];\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        for (int j = i + 1; j < numbers.length;\
    \ j++) \n        {\n            float diff = abs(numbers[i] - numbers[j]);\n \
    \           if (diff < min_diff) \n            {\n                min_diff = diff;\n\
    \                min_val1 = numbers[i];\n                min_val2 = numbers[j];\n\
    \            }\n        }\n    }\n    return tuple(min_val1, min_val2);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsyhdoelk.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f91]

    ??:? void tmpsyhdoelk.__unittest_L33_C1() [0x428f4d]

    ??:? void tmpsyhdoelk.__modtest() [0x429948]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eca3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbb2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324d9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432988]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432465]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db89]

    ??:? runModuleUnitTests [0x42ea79]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a454]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float closestDiff = float.max;\n    float closestPair = tuple(0, 0);\n\
    \    foreach(i, ref n; numbers)\n    {\n        float n1 = n;\n        foreach(j,\
    \ ref m; numbers)\n        {\n            float n2 = m;\n            if (i !=\
    \ j)\n            {\n                float diff = abs(n1 - n2);\n            \
    \    if (diff < closestDiff)\n                {\n                    closestDiff\
    \ = diff;\n                    closestPair = tuple(n1, n2);\n                }\n\
    \            }\n        }\n    }\n    return closestPair;\n}\nunittest\n{\n  \
    \  alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmv7_q2cp.d(15): Error: cannot implicitly convert expression `tuple(0,
    0)` of type `Tuple!(int, int)` to `float`

    /tmp/tmpmv7_q2cp.d(28): Error: cannot implicitly convert expression `tuple(n1,
    n2)` of type `Tuple!(float, float)` to `float`

    /tmp/tmpmv7_q2cp.d(33): Error: cannot implicitly convert expression `closestPair`
    of type `float` to `Tuple!(float, float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmv7_q2cp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    auto len = numbers.length;\n    assert(len >= 2);\n    immutable diff\
    \ = abs(numbers[0] - numbers[1]);\n    immutable lhs = numbers[0];\n    immutable\
    \ rhs = numbers[1];\n    foreach(i; 1..len)\n    {\n        foreach(j; i..len)\n\
    \        {\n            auto tmp = abs(numbers[i] - numbers[j]);\n           \
    \ if(tmp < diff)\n            {\n                diff = tmp;\n               \
    \ lhs = numbers[i];\n                rhs = numbers[j];\n            }\n      \
    \  }\n    }\n    return tuple(lhs, rhs);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa_r0uq2_.d(26): Error: cannot modify `immutable` expression `diff`

    /tmp/tmpa_r0uq2_.d(27): Error: cannot modify `immutable` expression `lhs`

    /tmp/tmpa_r0uq2_.d(28): Error: cannot modify `immutable` expression `rhs`

    /tmp/tmpa_r0uq2_.d(32): Error: cannot implicitly convert expression `tuple(lhs,
    rhs)` of type `Tuple!(immutable(float), immutable(float))` to `Tuple!(float, float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa_r0uq2_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    auto smallerNumber = numbers[0];\n    auto largerNumber = numbers[1];\n\
    \    float dif = largerNumber - smallerNumber;\n    auto c;\n    foreach(i,num;\
    \ numbers)\n    {\n        for(auto n = i+1; n < numbers.length; n++)\n      \
    \  {\n            if (numbers[n] - num < dif)\n            {\n               \
    \ smallerNumber = num;\n                largerNumber = numbers[n];\n         \
    \       dif = largerNumber - smallerNumber;\n            }\n        }\n    }\n\
    \    return tuple(smallerNumber, largerNumber);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpphyr3llz.d(17): Error: no identifier for declarator `c`

    /tmp/tmpphyr3llz.d(17): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpphyr3llz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    float closest = numbers[1] - numbers[0]; \n    Tuple!(float, float)\
    \ ret; \n    foreach (i, v; numbers) \n    { \n        foreach (j, w; numbers[i+1..$])\
    \ \n        { \n            float temp = w - v; \n            if (temp < closest)\
    \ \n            { \n                closest = temp; \n                ret = tuple(v,\
    \ w); \n            } \n        } \n    } \n    return ret; \n}\n/*\n Make a string\
    \ from the first and last two letters of a string, swapping the letters in each\
    \ word if they are the same.\n    If the string is less than two characters return\
    \ an empty string. If the string is exactly two characters return it.\n    >>>\
    \ make_string(\"Alphabet\")\n    \"Aabtle\"\n    >>> make_string(\"s\")\n    \"\
    \"\n    >>> make_string(\"hello\")\n    \"heol\"\n*/\nstring make_string(string\
    \ s)\n{\n\tif(s.length < 2)\n\t\treturn \"\";\n\telse if(s.length == 2)\n\t\t\
    return s;\n\telse\n\t{\n\t\tstring first = s[0..1];\n\t\tstring last = s[s.length-2..$];\n\
    \t\tif(first[0] == first[1])\n\t\t\tfirst = first[1..0];\n\t\tif(last[0] == last[1])\n\
    \t\t\tlast = last[1..0];\n\t\treturn first ~ last;\n\t}\n}\n/*\n Given a positive\
    \ int n, return an int array of length n+1 where each element is the sum of the\
    \ previous two elements.\n    If the result array has two elements, they should\
    \ be 1, 1.\n    >>> fibonacci(2)\n    [1, 1, 2]\n    >>> fibonacci(3)\n    [1,\
    \ 1, 2, 3]\n    >>> fibonacci(7)\n    [1, 1, 2, 3, 5, 8, 13, 21]\n*/\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpx2pg8w2h.d(71): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a155]

    ??:? void tmpx2pg8w2h.__unittest_L67_C1() [0x429105]

    ??:? void tmpx2pg8w2h.__modtest() [0x429bbc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f277]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e186]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432965]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432e14]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4328f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e15d]

    ??:? runModuleUnitTests [0x42f04d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a6a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min_distance = max_float;\n\
    \    Tuple!(float, float) closest_elements;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (int j = i + 1; j < numbers.length; j++)\n        {\n\
    \            float distance = abs(numbers[i] - numbers[j]);\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               closest_elements = tuple(numbers[i], numbers[j]);\n          \
    \  }\n        }\n    }\n    return closest_elements;\n}\n/*\n Remove from string\
    \ the middle character if it has even length. If it has odd length remove the\
    \ two middle ones.\n    >>> remove_middle_characters(\"abc\")\n    \"abc\"\n \
    \   >>> remove_middle_characters(\"abcde\")\n    \"ae\"\n    >>> remove_middle_characters(\"\
    abcdeg\")\n    \"abeg\"\n*/\nstring remove_middle_characters(string s)\n{\n  \
    \  import std.array;\n    s = s.dup;\n    if (s.length % 2 == 0)\n    {\n    \
    \    int middle = s.length / 2;\n        s = s[0 .. middle] ~ s[middle + 1 ..\
    \ $];\n    }\n    else\n    {\n        int middle = s.length / 2;\n        s =\
    \ s[0 .. middle - 1] ~ s[middle + 1 .. $];\n    }\n    return s;\n}\n// Write\
    \ a function that returns the number of occurrences of value in the array.\nuint\
    \ number_of_occurrences(int[] arr, int value)\n{\n    uint count = 0;\n    foreach\
    \ (int elem; arr)\n    {\n        if (elem == value)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbnnmprgl.d(15): Error: undefined identifier `max_float`

    /tmp/tmpbnnmprgl.d(46): Error: cannot implicitly convert expression `s.length
    / 2LU` of type `ulong` to `int`

    /tmp/tmpbnnmprgl.d(51): Error: cannot implicitly convert expression `s.length
    / 2LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbnnmprgl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    //sort numbers to eliminate some comparisons\n    sort(numbers);\n\
    \    float smallestDiff = numbers[1] - numbers[0];\n    int pos = 0;\n    //grab\
    \ first two elements as benchmark\n    float num1 = numbers[0];\n    float num2\
    \ = numbers[1];\n    //for each element, compare to previous element and replace\
    \ if smaller difference\n    for (int i = 1; i < numbers.length; i++)\n    {\n\
    \        float diff = numbers[i] - numbers[i-1];\n        if (diff < smallestDiff)\n\
    \        {\n            smallestDiff = diff;\n            num1 = numbers[i-1];\n\
    \            num2 = numbers[i];\n        }\n    }\n    return tuple(num1, num2);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmoh3mscm.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmoh3mscm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float minDiff = 100;\n    float min1, min2;\n    float diff;\n    foreach(i,\
    \ float n1; numbers) \n    {\n        float n2 = numbers[i + 1];\n        if (i\
    \ + 1 > numbers.length) \n        {\n            break;\n        }\n        else\
    \ \n        {\n            diff = abs(n1 - n2);\n            if (diff < minDiff)\
    \ \n            {\n                minDiff = diff;\n                min1 = n1;\n\
    \                min2 = n2;\n            }\n        }\n    }\n    return tuple(min1,\
    \ min2);\n}\n/*\n From a supplied array of numbers (of length at least two) select\
    \ and return two that are the furthest from each\n    other and return them in\
    \ order (smaller number, larger number).\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(1.0, 5.0)\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(1.0, 5.0)\n    \n*/\nTuple!(float, float)\
    \ find_furthest_elements(float[] numbers) \n{\n    float maxDiff = 0;\n    float\
    \ max1, max2;\n    float diff;\n    foreach(i, float n1; numbers) \n    {\n  \
    \      float n2 = numbers[i + 1];\n        if (i + 1 > numbers.length) \n    \
    \    {\n            break;\n        }\n        else \n        {\n            diff\
    \ = abs(n1 - n2);\n            if (diff > maxDiff) \n            {\n         \
    \       maxDiff = diff;\n                max1 = n1;\n                max2 = n2;\n\
    \            }\n        }\n    }\n    return tuple(max1, max2);\n}\n/*\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz4844jwq.d(71): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz4844jwq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float[] result;\n    float best = 100.0f;\n    foreach(index, num;\
    \ numbers)\n    {\n        foreach(index2, num2; numbers)\n        {\n       \
    \     if(abs(num - num2) < best && num != num2)\n            {\n             \
    \   best = abs(num - num2);\n                result = tuple(num, num2);\n    \
    \        }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqcl7y8_.d(23): Error: cannot implicitly convert expression `tuple(num,
    num2)` of type `Tuple!(float, float)` to `float[]`

    /tmp/tmpvqcl7y8_.d(27): Error: cannot implicitly convert expression `result` of
    type `float[]` to `Tuple!(float, float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqcl7y8_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length>=2, \"numbers must be length of at least 2\"\
    );\n    float tmp = -1;\n    float min = -1;\n    Tuple!(float, float) t = tuple(-1,-1);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        for(int j = i+1;\
    \ j < numbers.length; j++)\n        {\n            tmp = abs(numbers[i] - numbers[j]);\n\
    \            if (min == -1 || tmp < min)\n            {\n                min =\
    \ tmp;\n                t = tuple(numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    return t;\n}\n/*\nselect and return the element of the array\
    \ that is the furthest from its average.\n    >>> average_distance([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n    1.0\n    >>> average_distance([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0])\n    5.0\n*/\nfloat average_distance(float[] numbers) \n{\n    assert(numbers.length>=2,\
    \ \"numbers must be length of at least 2\");\n    float tmp = -1;\n    float max\
    \ = -1;\n    float max_element = -1;\n    float average = sum(numbers) / numbers.length;\n\
    \    foreach(e; numbers)\n    {\n        tmp = abs(e - average);\n        if (max\
    \ == -1 || tmp > max)\n        {\n            max = tmp;\n            max_element\
    \ = e;\n        }\n    }\n    return max_element;\n}\n/*\nselect and return the\
    \ element of the array that is the furthest from its median.\n    >>> median_distance([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    5.0\n    >>> median_distance([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    5.0\n*/\nfloat median_distance(float[] numbers)\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkwt0vuid.d(65): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkwt0vuid.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    static assert(numbers.length > 1);\n    float minimumDifference = numbers[1]\
    \ - numbers[0];\n    float resultNumber1 = numbers[0];\n    float resultNumber2\
    \ = numbers[1];\n    foreach(index, number; numbers) \n    {\n        if (index\
    \ == 0) continue;\n        float difference = abs(number - numbers[index - 1]);\n\
    \        if (difference < minimumDifference) \n        {\n            minimumDifference\
    \ = difference;\n            resultNumber1 = numbers[index - 1];\n           \
    \ resultNumber2 = number;\n        }\n    }\n    return tuple(resultNumber1, resultNumber2);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp809yq35i.d(14): Error: variable `numbers` cannot be read at compile
    time

    /tmp/tmp809yq35i.d(14):        while evaluating: `static assert(numbers.length
    > 1LU)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp809yq35i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float \n        minDiff = FLT_MAX, \n        diff = 0.0, \n       \
    \ a = numbers[0], \n        b = numbers[1];\n    \n    foreach (n, num; numbers)\
    \ \n    {\n        if (n == 0) \n            continue;\n        diff = abs(num\
    \ - numbers[n - 1]);\n        if (diff < minDiff) \n        {\n            minDiff\
    \ = diff;\n            a = numbers[n - 1];\n            b = num;\n        }\n\
    \    }\n    return tuple(a, b);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp123xpezb.d(15): Error: undefined identifier `FLT_MAX`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp123xpezb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n  float n1, n2;\n  n1 = numbers[0];\n  n2 = numbers[1];\n  float dif =\
    \ abs(n1 - n2);\n  for (int i = 0; i < numbers.length; i++) \n  {\n    for (int\
    \ j = i+1; j < numbers.length; j++) \n    {\n      float dif_cur = abs(numbers[i]\
    \ - numbers[j]);\n      if (dif_cur < dif) \n      {\n        dif = dif_cur;\n\
    \        n1 = numbers[i];\n        n2 = numbers[j];\n      }\n    }\n  }\n  return\
    \ tuple(n1, n2);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkqwgdhvg.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e85]

    ??:? void tmpkqwgdhvg.__unittest_L33_C1() [0x428ef1]

    ??:? void tmpkqwgdhvg.__modtest() [0x4298ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb97]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42daa6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4323cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43287c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432359]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da7d]

    ??:? runModuleUnitTests [0x42e96d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    int minIndex1 = 0;\n    int minIndex2 = 1;\n    float minDistance =\
    \ numbers[minIndex1] - numbers[minIndex2];\n    float tmpDistance;\n    float\
    \ tmpNum1;\n    float tmpNum2;\n    int n = numbers.length;\n    assert(n >= 2);\n\
    \    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n\
    \        {\n            tmpDistance = numbers[i] - numbers[j];\n            if\
    \ (abs(tmpDistance) < abs(minDistance))\n            {\n                minDistance\
    \ = tmpDistance;\n                minIndex1 = i;\n                minIndex2 =\
    \ j;\n            }\n        }\n    }\n    return tuple(numbers[minIndex1], numbers[minIndex2]);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmaar5qh0.d(20): Error: cannot implicitly convert expression `numbers.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmaar5qh0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    int index = 0;\n    float smalldiff = 1000.0;\n    float bigdiff =\
    \ -1.0;\n    float small = -1.0;\n    float big = 1000.0;\n    float temp = 0.0;\n\
    \    while(index < numbers.length)\n    {\n        //numbers[index];\n       \
    \ if(index + 1 < numbers.length)\n        {\n            temp = abs(numbers[index\
    \ + 1] - numbers[index]);\n        }\n        if(temp < smalldiff)\n        {\n\
    \            smalldiff = temp;\n            small = numbers[index];\n        \
    \    big = numbers[index + 1];\n        }\n        index++;\n    }\n    return\
    \ tuple(small, big);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwhqcu9_w.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e3d]

    ??:? void tmpwhqcu9_w.__unittest_L37_C1() [0x428ea9]

    ??:? void tmpwhqcu9_w.__modtest() [0x4298a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb4f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432385]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432834]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432311]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da35]

    ??:? runModuleUnitTests [0x42e925]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a300]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164329
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length > 1);\n    float c = numbers[0];\n    float d\
    \ = numbers[1];\n    float a = c;\n    float b = d;\n    float current = abs(c\
    \ - d);\n    float min;\n    for (int i = 0; i < numbers.length; i++) \n    {\n\
    \        for (int j = i+1; j < numbers.length; j++) \n        {\n            min\
    \ = abs(numbers[i] - numbers[j]);\n            if (min < current) \n         \
    \   {\n                current = min;\n                a = numbers[i];\n     \
    \           b = numbers[j];\n            }\n        }\n    }\n    if (a > b) return\
    \ tuple(b, a);\n    return tuple(a, b);\n}\nunittest\n{\n    alias candidate =\
    \ find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn8llvk5g.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fa9]

    ??:? void tmpn8llvk5g.__unittest_L37_C1() [0x428f65]

    ??:? void tmpn8llvk5g.__modtest() [0x429960]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ecbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbca]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4324f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43247d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dba1]

    ??:? runModuleUnitTests [0x42ea91]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a46c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164329
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    import std.algorithm.comparison : min;\n    import std.array : minIndex;\n\
    \    import std.math : abs;\n    import std.typecons : tuple;\n    return tuple(\n\
    \        numbers[minIndex!(a => abs(a - numbers[numbers.minIndex]))(numbers[1\
    \ .. $])],\n        numbers[minIndex!(a => abs(a - numbers[numbers.minIndex]))(numbers[0\
    \ .. $ - 1])]\n    );\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpif8zzhb3.d(15): Error: module `std.array` import `minIndex` not
    found

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpif8zzhb3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float d = abs(numbers[0] - numbers[1]);\n\
    \    size_t ind0 = 0;\n    size_t ind1 = 1;\n    for (size_t i = 0; i < numbers.length;\
    \ i++) \n    {\n        for (size_t j = i + 1; j < numbers.length; j++) \n   \
    \     {\n            float tmp = abs(numbers[i] - numbers[j]);\n            if\
    \ (tmp < d) \n            {\n                d = tmp;\n                ind0 =\
    \ i;\n                ind1 = j;\n            }\n        }\n    }\n    return tuple(numbers[ind0],\
    \ numbers[ind1]);\n}\n/*\n    From a supplied array of numbers (of length at least\
    \ one) select and return two numbers that\n    maximise their difference.\n  \
    \  >>> find_max_difference([2.0, 1.0, 5.0, 8.0, 5.0, 2.0])\n    tuple(1.0, 8.0)\n\
    \    >>> find_max_difference([2.0, 2.0, 2.0, 2.0, 2.0, 2.0])\n    tuple(2.0, 2.0)\n\
    \    >>> find_max_difference([2.0])\n    tuple(2.0, 2.0)\n    >>> find_max_difference([2.0,\
    \ 3.0])\n    tuple(2.0, 3.0)\n*/\nTuple!(float, float) find_max_difference(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 1);\n    float max = numbers[0];\n\
    \    float min = numbers[0];\n    for (size_t i = 1; i < numbers.length; i++)\
    \ \n    {\n        if (numbers[i] > max)\n            max = numbers[i];\n    \
    \    if (numbers[i] < min)\n            min = numbers[i];\n    }\n    return tuple(min,\
    \ max);\n}\n/*\n    From a supplied array of numbers (of length at least three)\
    \ select and return two numbers that\n    maximise their difference\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpndjqrykg.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpndjqrykg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float closest_distance = max_float;\n    Tuple!(float, float) closest_numbers;\n\
    \    foreach (i, n1; numbers)\n    {\n        foreach (j, n2; numbers)\n     \
    \   {\n            if (i != j)\n            {\n                float d = abs(n1\
    \ - n2);\n                if (d < closest_distance)\n                {\n     \
    \               closest_distance = d;\n                    closest_numbers = tuple(min(n1,\
    \ n2), max(n1, n2));\n                }\n            }\n        }\n    }\n   \
    \ return closest_numbers;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqdsc0sc6.d(14): Error: undefined identifier `max_float`

    /tmp/tmpqdsc0sc6.d(26): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpqdsc0sc6.d(26): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqdsc0sc6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    import std.algorithm;\n    assert(numbers.length >= 2);\n    float\
    \ min = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    foreach(i, index1; numbers)\n\
    \    {\n        foreach(j, index2; numbers)\n        {\n            if (index1\
    \ != index2)\n            {\n                float temp = abs(i - j);\n      \
    \          if (temp < min || min == 0.0)\n                {\n                \
    \    min = temp;\n                    a = i;\n                    b = j;\n   \
    \             }\n            }\n        }\n    }\n    return tuple(a, b);\n}\n\
    /*\n    From a supplied array of numbers (of length at least two) and a boolean\
    \ array of length equal to the\n    supplied array, select and return the two\
    \ numbers which are closest to each other, such that their\n    corresponding\
    \ boolean element is true.\n    >>> find_closest_elements_boolean([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2], [true, false, true, false, true, true])\n    tuple(2.0, 2.2)\n\
    \    >>> find_closest_elements_boolean([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], [true,\
    \ false, true, false, true, true])\n    tuple(2.0, 2.0)\n*/\nTuple!(float, float)\
    \ find_closest_elements_boolean(float[] numbers, bool[] boolean) \n{\n    import\
    \ std.algorithm;\n    assert(numbers.length >= 2);\n    assert(boolean.length\
    \ == numbers.length);\n    float min = 0.0;\n    float a = 0.0;\n    float b =\
    \ 0.0;\n    foreach(i, index1; numbers)\n    {\n        foreach(j, index2; numbers)\n\
    \        {\n            if (index1 != index2 && boolean[index1] && boolean[index2])\n\
    \            {\n                float temp = abs(i - j);\n                if (temp\
    \ < min || min == 0\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpex5twq07.d(62): Error: found `unittest` when expecting `)`

    /tmp/tmpex5twq07.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpex5twq07.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpex5twq07.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpex5twq07.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpex5twq07.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n  float first = numbers[0];\n  float second = numbers[1];\n  float closest_pair\
    \ = abs(first - second);\n  // FIXME: Need to make sure length is at least 2\n\
    \  foreach (current; numbers[2..$])\n  {\n    float difference = abs(first - current);\n\
    \    if (difference < closest_pair)\n    {\n      closest_pair = difference;\n\
    \      second = current;\n    }\n  }\n  return tuple(first, second);\n}\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvojyo_ja.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x429e0d]

    ??:? void tmpvojyo_ja.__unittest_L29_C1() [0x428e79]

    ??:? void tmpvojyo_ja.__modtest() [0x429874]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb1f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da2e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432355]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432804]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4322e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42da05]

    ??:? runModuleUnitTests [0x42e8f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a2d0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164329
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n  auto index = 0;\n  auto min = abs(numbers[0] - numbers[1]);\n  auto min_index\
    \ = tuple(0, 1);\n  foreach(i, e; numbers) \n  {\n    if (i + 1 < numbers.length)\
    \ \n    {\n      auto temp = abs(e - numbers[i + 1]);\n      if (temp < min) \n\
    \      {\n        min = temp;\n        min_index = tuple(i, i + 1);\n      }\n\
    \    }\n  }\n  return tuple(numbers[min_index[0]], numbers[min_index[1]]);\n}\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp95izgapz.d(25): Error: template `std.typecons.Tuple!(int, int).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(ulong, ulong))`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(int,
    int).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp95izgapz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tassert(numbers.length > 1);\n\treturn numbers.sorted.tupleOf[2];\n}\n\
    /*\n Given an array of numbers and an index, return the product of the array,\
    \ except for the element at the index.\n \n    >>> product_of_others([1.0, 2.0,\
    \ 3.0, 4.0, 5.0], 2)\n    120.0\n    >>> product_of_others([1.0, 2.0, 3.0, 4.0,\
    \ 5.0], 1)\n    120.0\n    >>> product_of_others([1.0, 2.0, 3.0, 4.0, 5.0], 0)\n\
    \    120.0\n    >>> product_of_others([1.0, 2.0, 3.0, 4.0, 5.0], 3)\n    60.0\n\
    \    >>> product_of_others([1.0, 2.0, 3.0, 4.0, 5.0], 4)\n    30.0\n*/\nfloat\
    \ product_of_others(float[] numbers, size_t index) \n{\n\tassert(numbers.length\
    \ > 1);\n\tfloat sum = 1;\n\tfor(auto number; numbers)\n\t{\n\t\tif(number !=\
    \ numbers[index])\n\t\t\tsum *= number;\n\t}\n\treturn sum;\n}\n/*\n Given an\
    \ array of numbers, and an index, return a tuple containing the products of all\
    \ numbers excluding those at the\n    index.\n    >>> products_of_others([1.0,\
    \ 2.0, 3.0, 4.0, 5.0], 2)\n    tuple(60.0, 30.0, 120.0, 20.0, 12.0)\n    >>> products_of_others([1.0,\
    \ 2.0, 3.0, 4.0, 5.0], 1)\n    tuple(60.0, 120.0, 40.0, 30.0, 15.0)\n    >>> products_of_others([1.0,\
    \ 2.0, 3.0, 4.0, 5.0], 0)\n    tuple(120.0, 60.0,\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxo2nb7jc.d(35): Error: no identifier for declarator `number`

    /tmp/tmpxo2nb7jc.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxo2nb7jc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float num1, num2;\n    int index1, index2;\n    float min = abs(numbers[0]\
    \ - numbers[1]);\n    index1 = 0;\n    index2 = 1;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (int j = 0; j < numbers.length; j++)\n        {\n \
    \           if (i != j)\n            {\n                if (abs(numbers[i] - numbers[j])\
    \ < min)\n                {\n                    min = abs(numbers[i] - numbers[j]);\n\
    \                    index1 = i;\n                    index2 = j;\n          \
    \      }\n            }\n        }\n    }\n    num1 = numbers[index1];\n    num2\
    \ = numbers[index2];\n    if (num1 > num2)\n    {\n        float tmp = num1;\n\
    \        num1 = num2;\n        num2 = tmp;\n    }\n    return tuple(num1, num2);\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4jys2rqh.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x429f0d]

    ??:? void tmp4jys2rqh.__unittest_L44_C1() [0x428f79]

    ??:? void tmp4jys2rqh.__modtest() [0x429974]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ec1f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42db2e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432455]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432904]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4323e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42db05]

    ??:? runModuleUnitTests [0x42e9f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a3d0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164329
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    if (numbers.length < 2)\n        throw new Exception(\"List must have\
    \ at least two numbers\");\n    auto closest = tuple(numbers[0], numbers[1]);\n\
    \    auto pair = tuple(numbers[0], numbers[1]);\n    auto start = numbers[0];\n\
    \    auto last = numbers[1];\n    foreach (i, element; numbers)\n    {\n     \
    \   if (element == start)\n            continue;\n        if (element == last)\n\
    \            continue;\n        if (abs(start - element) < abs(closest[0] - closest[1]))\n\
    \        {\n            closest = tuple(start, element);\n        }\n        start\
    \ = element;\n    }\n    return closest;\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu3kt9utv.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a165]

    ??:? void tmpu3kt9utv.__unittest_L34_C1() [0x429071]

    ??:? void tmpu3kt9utv.__modtest() [0x429b34]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f467]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e376]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432c9d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43314c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432c29]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e34d]

    ??:? runModuleUnitTests [0x42f23d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a6b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164329
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float minDist = float.max;\n    Tuple!(float, float) minPair;\n   \
    \ foreach(i, a; numbers)\n    {\n        foreach(j, b; numbers[i+1..])\n     \
    \   {\n            if(abs(a-b) < minDist)\n            {\n                minDist\
    \ = abs(a-b);\n                minPair = tuple(a, b);\n            }\n       \
    \ }\n    }\n    return minPair;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qe70odx.d(18): Error: expression expected, not `]`

    /tmp/tmp6qe70odx.d(18): Error: found `)` when expecting `,`

    /tmp/tmp6qe70odx.d(26): Error: found `}` when expecting `,`

    /tmp/tmp6qe70odx.d(27): Error: expression expected, not `return`

    /tmp/tmp6qe70odx.d(27): Error: found `minPair` when expecting `,`

    /tmp/tmp6qe70odx.d(27): Error: expression expected, not `;`

    /tmp/tmp6qe70odx.d(28): Error: found `}` when expecting `,`

    /tmp/tmp6qe70odx.d(29): Error: expression expected, not `unittest`

    /tmp/tmp6qe70odx.d(30): Error: found `{` when expecting `,`

    /tmp/tmp6qe70odx.d(31): Error: expression expected, not `alias`

    /tmp/tmp6qe70odx.d(31): Error: found `candidate` when expecting `,`

    /tmp/tmp6qe70odx.d(31): Error: expression expected, not `=`

    /tmp/tmp6qe70odx.d(31): Error: found `find_closest_elements` when expecting `,`

    /tmp/tmp6qe70odx.d(31): Error: expression expected, not `;`

    /tmp/tmp6qe70odx.d(33): Error: found `assert` when expecting `,`

    /tmp/tmp6qe70odx.d(33): Error: found `;` when expecting `,`

    /tmp/tmp6'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    Tuple!(float, float) min(cast(float) 1.0e100,cast(float) 1.0e100);\n\
    \    foreach(index1,i; numbers)\n    {\n        foreach(index2,j; numbers)\n \
    \       {\n            if(index1!=index2)\n            {\n                if(min.length>abs(i-j))\n\
    \                {\n                    min.length=abs(i-j);\n               \
    \     min.first=min(i,j);\n                    min.second=max(i,j);\n        \
    \        }\n            }\n        }\n    }\n    return min;\n}\nunittest\n{\n\
    \    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7drlypkf.d(14): Error: found `min` when expecting `;` following
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7drlypkf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length > 1);\n    //float[] difference = new float[numbers.length];\n\
    \    float[] difference;\n    float[] distance = new float[numbers.length];\n\
    \    float smallest_num;\n    float largest_num;\n    float closest;\n    int\
    \ i = 0;\n    foreach(number1; numbers) \n    {\n        if(i >= 1) \n       \
    \ {\n            //difference[i] = abs(number1 - number2);\n            difference\
    \ ~= abs(number1 - numbers[i-1]);\n            distance[i] = difference[i-1];\n\
    \        }\n        i++;\n    }\n    difference = difference[1..$];\n    assert(distance.length\
    \ == difference.length);\n    //writefln(\"%s\",distance);\n    //writefln(\"\
    %s\",difference);\n    smallest_num = min(difference);\n    largest_num = max(difference);\n\
    \    int smallest_index = difference.indexOf(smallest_num);\n    //writefln(\"\
    %s\", smallest_index);\n    closest = distance[smallest_index];\n    //smallest_num\
    \ = numbers[smallest_index];\n    //writefln(\"%s\", smallest_num);\n    //largest_num\
    \ = numbers[smallest_index + 1];\n    largest_num = numbers[smallest_index];\n\
    \    //writefln(\"%s\", largest_num);\n    writefln(\"%s\", closest);\n    return\
    \ tuple(smallest_num, largest_num);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp69vlocw0.d(36): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp69vlocw0.d(37): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp69vlocw0.d(38): Error: no property `indexOf` for type `float[]`

    /tmp/tmp69vlocw0.d(46): Error: `writefln` is not defined, perhaps `import std.stdio;`
    is needed?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp69vlocw0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    if (numbers.length < 2)\n        return tuple(0.0, 0.0);\n    if (numbers.length\
    \ == 2)\n        return tuple(numbers[0], numbers[1]);\n    float min = min(numbers[0],\
    \ numbers[1]), max = max(numbers[0], numbers[1]);\n    float diff = abs(min -\
    \ max);\n    for (int i = 0; i < numbers.length; i++) \n    {\n        for (int\
    \ j = i + 1; j < numbers.length; j++) \n        {\n            float d = abs(numbers[i]\
    \ - numbers[j]);\n            if (d < diff) \n            {\n                min\
    \ = min(numbers[i], numbers[j]);\n                max = max(numbers[i], numbers[j]);\n\
    \                diff = d;\n            }\n        }\n    }\n    return tuple(min,\
    \ max);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy9wd4ydy.d(18): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpy9wd4ydy.d(18): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpy9wd4ydy.d(27): Error: function expected before `()`, not `min` of type
    `float`

    /tmp/tmpy9wd4ydy.d(28): Error: function expected before `()`, not `max` of type
    `float`

    /tmp/tmpy9wd4ydy.d(15): Error: cannot implicitly convert expression `tuple(0.00000,
    0.00000)` of type `Tuple!(double, double)` to `Tuple!(float, float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy9wd4ydy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    auto min_difference = abs(numbers[0]\
    \ - numbers[1]);\n    Tuple!(float, float) min_pair = tuple(numbers[0], numbers[1]);\n\
    \    foreach (i, number; numbers)\n    {\n        foreach (j, another_number;\
    \ numbers[i+1..$])\n        {\n            auto difference = abs(number - another_number);\n\
    \            if (difference < min_difference)\n            {\n               \
    \ min_difference = difference;\n                min_pair = tuple(number, another_number);\n\
    \            }\n        }\n    }\n    return min_pair;\n}\nunittest\n{\n    alias\
    \ candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) ==\
    \ tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0,\
    \ 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2g4uquz8.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a139]

    ??:? void tmp2g4uquz8.__unittest_L31_C1() [0x42902d]

    ??:? void tmp2g4uquz8.__modtest() [0x429af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f137]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e046]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43296d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432e1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4328f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e01d]

    ??:? runModuleUnitTests [0x42ef0d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a688]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164329
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min = infinity;\n    Tuple!(float,\
    \ float) minTuple = Tuple!(float, float)(-1, -1);\n    foreach(i, item; numbers)\n\
    \    {\n        foreach(j, elem; numbers)\n        {\n            if(i != j)\n\
    \            {\n                if(abs(item - elem) < min)\n                {\n\
    \                    min = abs(item - elem);\n                    minTuple = Tuple!(float,\
    \ float)(item, elem);\n                }\n            }\n        }\n    }\n  \
    \  return minTuple;\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvwpq2lyy.d(15): Error: undefined identifier `infinity`, did you
    mean template `isInfinity(X)(X x) if (isFloatingPoint!X)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvwpq2lyy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n\tassert(numbers.length >= 2);\n\tfloat min_diff = abs(numbers[0] - numbers[1]);\n\
    \tfloat n1 = numbers[0];\n\tfloat n2 = numbers[1];\n\tfor (size_t i = 0; i < numbers.length;\
    \ i++)\n\t{\n\t\tfor (size_t j = i + 1; j < numbers.length; j++)\n\t\t{\n\t\t\t\
    float diff = abs(numbers[i] - numbers[j]);\n\t\t\tif (diff < min_diff)\n\t\t\t\
    {\n\t\t\t\tmin_diff = diff;\n\t\t\t\tn1 = numbers[i];\n\t\t\t\tn2 = numbers[j];\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn tuple(n1, n2);\n}\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptsx3n0x8.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429fb9]

    ??:? void tmptsx3n0x8.__unittest_L33_C1() [0x428f75]

    ??:? void tmptsx3n0x8.__modtest() [0x429970]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eccb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dbda]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x432501]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4329b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43248d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dbb1]

    ??:? runModuleUnitTests [0x42eaa1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a47c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164329
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{ \n    if (numbers.length &lt; 2) \n    { \n        throw new Exception(\"\
    There must be at least two elements in the array.\"); \n    } \n    float smallestDifference\
    \ = numbers[0] - numbers[1]; \n    auto result = tuple(numbers[0], numbers[1]);\
    \ \n    foreach (number; numbers) \n    { \n        foreach (anotherNumber; numbers)\
    \ \n        { \n            if (number == anotherNumber) continue; \n        \
    \    float diff = number - anotherNumber; \n            if (abs(diff) &lt; abs(smallestDifference))\
    \ \n            { \n                smallestDifference = diff; \n            \
    \    result = tuple(min(number, anotherNumber), max(number, anotherNumber)); \n\
    \            } \n        } \n    } \n    return result; \n} \nunittest \n{ \n\
    \    assert(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0,\
    \ 2.2)); \n    assert(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) ==\
    \ tuple(2.0, 2.0)); \n}\n</code>\n\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9s0s3ffo.d(14): Error: found `;` when expecting `)`

    /tmp/tmp9s0s3ffo.d(14): Error: found `)` when expecting `;` following statement

    /tmp/tmp9s0s3ffo.d(26): Error: found `;` when expecting `)`

    /tmp/tmp9s0s3ffo.d(26): Error: found `)` when expecting `;` following statement

    /tmp/tmp9s0s3ffo.d(40): Error: declaration expected, not `<`

    /tmp/tmp9s0s3ffo.d(46): Error: declaration expected, not `assert`

    /tmp/tmp9s0s3ffo.d(47): Error: declaration expected, not `assert`

    /tmp/tmp9s0s3ffo.d(48): Error: declaration expected, not `assert`

    /tmp/tmp9s0s3ffo.d(49): Error: declaration expected, not `assert`

    /tmp/tmp9s0s3ffo.d(50): Error: declaration expected, not `assert`

    /tmp/tmp9s0s3ffo.d(51): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9s0s3ffo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float closest_pair_distance = abs(numbers[0]\
    \ - numbers[1]);\n    Tuple!(float, float) closest_pair = tuple(numbers[0], numbers[1]);\n\
    \    foreach (number_index_1, number_1; numbers)\n    {\n        foreach (number_index_2,\
    \ number_2; numbers[number_index_1 + 1 .. $])\n        {\n            float distance\
    \ = abs(number_1 - number_2);\n            if (distance < closest_pair_distance)\n\
    \            {\n                closest_pair_distance = distance;\n          \
    \      closest_pair = tuple(number_1, number_2);\n            }\n        }\n \
    \   }\n    return closest_pair;\n}\n \n /*\n  From a supplied string (s) return\
    \ a new string which is the same as s, except that all the letters of s are now\
    \ in\n    reverse order (i.e. with the first letter of s now being the last letter,\
    \ the second letter of s now being the\n    second last letter, etc.).\n    >>>\
    \ reverse_string(\"abcdefg\")\n    \"gfedcba\"\n    >>> reverse_string(\"\")\n\
    \    \"\"\n */\nstring reverse_string(string s) \n{\n    string reverse_s = \"\
    \";\n    foreach (index, character; s[s.length - 1 .. -1])\n    {\n        reverse_s\
    \ ~= character;\n    }\n    return reverse_s;\n}\n \n /*\n  From a supplied string\
    \ (s) return a new string which is the same as s, except that all vowels are changed\
    \ to 'X'.\n    >>> remove_vowels(\"abcdefg\")\n    \"XbcdXfg\"\n    >>> remove_vowels(\"\
    \")\n    \"\"\n */\nstring remove_vowels(string s) \n{\n    string without_vowels\
    \ = \"\";\n    foreach (character; s)\n    {\n        if (character.isAlpha &&\
    \ character.toLower.in(\"aeiou\"))\n        {\n            without_vowels ~= \"\
    X\";\n        }\n        else\n        {\n            without_vowels ~\nunittest\n\
    {\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk7an7zzk.d(63): Error: identifier expected following `.`, not `in`

    /tmp/tmpk7an7zzk.d(70): Error: expression expected, not `unittest`

    /tmp/tmpk7an7zzk.d(71): Error: found `{` when expecting `;` following statement

    /tmp/tmpk7an7zzk.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpk7an7zzk.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk7an7zzk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n    nogc pure nothrow @nogc \n{\n    // find closest match from numbers, \n\
    \    // \n    // we search for a value that is either to the left or to the right\
    \ of the current position\n    // and at distance less than the current distance\n\
    \    float temp = 9999999.9f; // initialize to something bigger than any difference\
    \ we can find\n    float smallest_difference = 0.0f; // value of the smallest\
    \ difference\n    float first = 0.0f; // the first smallest difference number\n\
    \    float second = 0.0f; // the second smallest difference number\n    int numbers_len\
    \ = numbers.length;\n    int i; // array index\n    for (i = 0; i < numbers_len;\
    \ i++) \n    {\n        // go to the right\n        if (i < numbers_len - 1) \n\
    \        {\n            temp = numbers[i + 1] - numbers[i];\n            if (smallest_difference\
    \ == 0.0f || temp < smallest_difference) \n            {\n                smallest_difference\
    \ = temp;\n                first = numbers[i];\n                second = numbers[i\
    \ + 1];\n            }\n        }\n        // go to the left\n        if (i >\
    \ 0) \n        {\n            temp = numbers[i] - numbers[i - 1];\n          \
    \  if (smallest_difference == 0.0f || temp < smallest_difference) \n         \
    \   {\n                smallest_difference = temp;\n                first = numbers[i\
    \ - 1];\n                second = numbers[i];\n            }\n        }\n    }\n\
    \    return tuple(first, second);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp38zd_2rx.d(13): Error: semicolon expected following function declaration

    /tmp/tmp38zd_2rx.d(13): Error: no identifier for declarator `nogc`

    /tmp/tmp38zd_2rx.d(25): Error: declaration expected, not `for`

    /tmp/tmp38zd_2rx.d(25): Error: no identifier for declarator `i`

    /tmp/tmp38zd_2rx.d(25): Error: declaration expected, not `<`

    /tmp/tmp38zd_2rx.d(25): Error: no identifier for declarator `i`

    /tmp/tmp38zd_2rx.d(25): Error: declaration expected, not `++`

    /tmp/tmp38zd_2rx.d(31): Error: declaration expected, not `if`

    /tmp/tmp38zd_2rx.d(34): Error: no identifier for declarator `first`

    /tmp/tmp38zd_2rx.d(34): Error: declaration expected, not `=`

    /tmp/tmp38zd_2rx.d(35): Error: no identifier for declarator `second`

    /tmp/tmp38zd_2rx.d(35): Error: declaration expected, not `=`

    /tmp/tmp38zd_2rx.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp38zd_2rx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float min = numbers[0] - numbers[1];\n\
    \    float minIndex = 0;\n    float maxIndex = 1;\n    for (float i = 0; i < numbers.length\
    \ - 1; i++)\n    {\n        float num = numbers[i] - numbers[i + 1];\n       \
    \ if (abs(num) < abs(min)) \n        {\n            min = num;\n            minIndex\
    \ = i;\n            maxIndex = i + 1;\n        }\n    }\n    return tuple(numbers[minIndex],\
    \ numbers[maxIndex]);\n}\n//---------------------------------------------------------------\n\
    unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjoee99cz.d(20): Error: cannot implicitly convert expression `i`
    of type `float` to `ulong`

    /tmp/tmpjoee99cz.d(20): Error: cannot implicitly convert expression `i + 1.00000F`
    of type `float` to `ulong`

    /tmp/tmpjoee99cz.d(28): Error: cannot implicitly convert expression `minIndex`
    of type `float` to `ulong`

    /tmp/tmpjoee99cz.d(28): Error: cannot implicitly convert expression `maxIndex`
    of type `float` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjoee99cz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    return tuple(2.0, 2.0);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe9z0bn5m.d(14): Error: cannot implicitly convert expression `tuple(2.00000,
    2.00000)` of type `Tuple!(double, double)` to `Tuple!(float, float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe9z0bn5m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float diff = 100000.0f;\n    float first;\n    float second;\n    foreach(int\
    \ i; 0..numbers.length-1)\n    {\n        if( abs(numbers[i] - numbers[i+1]) <\
    \ diff)\n        {\n            diff = abs(numbers[i] - numbers[i+1]);\n     \
    \       first = numbers[i];\n            second = numbers[i+1];\n        }\n \
    \   }\n    return tuple(first, second);\n}\nunittest\n{\n    alias candidate =\
    \ find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wtiu_fk.d(17): Error: cannot implicitly convert expression `numbers.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wtiu_fk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float minDelta = min(abs(numbers[0]\
    \ - numbers[1]), abs(numbers[1] - numbers[2]));\n    int minIndex = 1;\n    for\
    \ (int i = 2; i < numbers.length - 1; i++)\n    {\n        float delta = abs(numbers[i]\
    \ - numbers[i+1]);\n        if (delta < minDelta)\n        {\n            minDelta\
    \ = delta;\n            minIndex = i;\n        }\n    }\n    return tuple(numbers[minIndex],\
    \ numbers[minIndex+1]);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm8f3mr3c.d(15): Error: undefined identifier `min`, did you mean
    function `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm8f3mr3c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float diff = abs(numbers[0] - numbers[1]);\n\
    \    auto p = tuple(numbers[0], numbers[1]);\n    if (diff == 0) return p;\n \
    \   foreach (x; numbers[2..$])\n    {\n        float d = abs(x - numbers[$-1]);\n\
    \        if (d < diff) \n        {\n            diff = d;\n            p = tuple(numbers[$-1],\
    \ x);\n        }\n    }\n    return p;\n}\nTuple!(float, float) find_closest_elements_sorted(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 2);\n    float diff = abs(numbers[0]\
    \ - numbers[1]);\n    auto p = tuple(numbers[0], numbers[1]);\n    if (diff ==\
    \ 0) return p;\n    for (int i = 2; i < numbers.length; i++)\n    {\n        float\
    \ d = abs(numbers[i] - numbers[i-1]);\n        if (d < diff) \n        {\n   \
    \         diff = d;\n            p = tuple(numbers[i-1], numbers[i]);\n      \
    \  }\n    }\n    return p;\n}\n/*\nGiven an array of numbers (of length at least\
    \ two) find the pair of numbers such that they are the farthest apart\n    and\
    \ return them in order (smaller number, larger number).\n    >>> find_farthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(1.0, 5.0)\n    >>> find_farthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(1.0, 5.0)\n*/\nTuple!(float, float) find_farthest_elements(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 2);\n    float diff = abs(numbers[0]\
    \ - numbers[1]);\n    auto p = tuple(numbers[0], numbers[\nunittest\n{\n    alias\
    \ candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) ==\
    \ tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0,\
    \ 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa706sm3l.d(59): Error: expression expected, not `unittest`

    /tmp/tmpa706sm3l.d(60): Error: found `{` when expecting `,`

    /tmp/tmpa706sm3l.d(61): Error: expression expected, not `alias`

    /tmp/tmpa706sm3l.d(61): Error: found `candidate` when expecting `,`

    /tmp/tmpa706sm3l.d(61): Error: expression expected, not `=`

    /tmp/tmpa706sm3l.d(61): Error: found `find_closest_elements` when expecting `,`

    /tmp/tmpa706sm3l.d(61): Error: expression expected, not `;`

    /tmp/tmpa706sm3l.d(63): Error: found `assert` when expecting `,`

    /tmp/tmpa706sm3l.d(63): Error: found `;` when expecting `,`

    /tmp/tmpa706sm3l.d(64): Error: found `;` when expecting `,`

    /tmp/tmpa706sm3l.d(65): Error: found `;` when expecting `,`

    /tmp/tmpa706sm3l.d(66): Error: found `;` when expecting `,`

    /tmp/tmpa706sm3l.d(67): Error: found `;` when expecting `,`

    /tmp/tmpa706sm3l.d(68): Error: expression expected, not `}`

    /tmp/tmpa706sm3l.d(69): Error: found `void` when expecting `,`

    /tmp/tmpa706sm3l.d(69): Error: found `{` when expecting `,`

    /tmp/tmpa706sm3l.'
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    return tuple(numbers[0], numbers[1]);\n\
    }\n/*\n    From a supplied array of numbers (of length at least two) select and\
    \ return two that are the furthest away\n    from each other and return them in\
    \ order (smaller number, larger number).\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(1.0, 5.0)\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(1.0, 5.0)\n*/\nTuple!(float, float) find_furthest_elements(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 2);\n    return tuple(numbers[0],\
    \ numbers[1]);\n}\n/*\n    From a supplied array of numbers (of length at least\
    \ two) select and return two that are the furthest away\n    from each other and\
    \ return them in order (smaller number, larger number).\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(1.0, 5.0)\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(1.0, 5.0)\n*/\nTuple!(float, float) find_furthest_elements2(float[]\
    \ numbers) \n{\n    assert(numbers.length >= 2);\n    return tuple(numbers[0],\
    \ numbers[1]);\n}\n/*\n    From a supplied array of numbers (of length at least\
    \ two) select and return two that are the furthest away\n    from each other and\
    \ return them in order (smaller number, larger number).\n    >>> find_furthest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(1.0, 5.0\nunittest\n{\n    alias candidate\
    \ = find_closest_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
    \ == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0,\
    \ 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n \
    \   assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpinj8g7o7.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpinj8g7o7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    float min = numbers[0] + numbers[1];\n    float index = 0;\n    for\
    \ (int i = 0; i < numbers.length - 1; i++)\n    {\n        float newmin = numbers[i]\
    \ + numbers[i + 1];\n        if (abs(min) > abs(newmin))\n        {\n        \
    \    min = newmin;\n            index = i;\n        }\n    }\n    return tuple(numbers[index],\
    \ numbers[index + 1]);\n}\nunittest\n{\n    alias candidate = find_closest_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw0r9__xe.d(25): Error: cannot implicitly convert expression `index`
    of type `float` to `ulong`

    /tmp/tmpw0r9__xe.d(25): Error: cannot implicitly convert expression `index + 1.00000F`
    of type `float` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw0r9__xe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164328
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    double currentClosest = numbers[1]\
    \ - numbers[0];\n    Tuple!(float, float) currentClosestTwo = tuple(numbers[0],\
    \ numbers[1]);\n    for (int i = 0; i < numbers.length; i++)\n    {\n        for\
    \ (int j = i + 1; j < numbers.length; j++)\n        {\n            if (abs(numbers[i]\
    \ - numbers[j]) < currentClosest)\n            {\n                currentClosest\
    \ = abs(numbers[i] - numbers[j]);\n                currentClosestTwo = tuple(numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    return currentClosestTwo;\n\
    }\nunittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == tuple(2.2, 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy3i_odnd.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a1a9]

    ??:? void tmpy3i_odnd.__unittest_L30_C1() [0x42909d]

    ??:? void tmpy3i_odnd.__modtest() [0x429b60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f1a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42e0b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4329dd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432e8c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432969]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42e08d]

    ??:? runModuleUnitTests [0x42ef7d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a6f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164329
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    assert(numbers.length >= 2);\n    float minDistance = cast(float)abs(numbers[0]\
    \ - numbers[1]);\n    float a = numbers[0];\n    float b = numbers[1];\n    for\
    \ (int i = 0; i < numbers.length; i++) \n    {\n        for (int j = i + 1; j\
    \ < numbers.length; j++) \n        {\n            float distance = cast(float)abs(numbers[i]\
    \ - numbers[j]);\n            if (distance < minDistance) \n            {\n  \
    \              minDistance = distance;\n                a = numbers[i];\n    \
    \            b = numbers[j];\n            }\n        }\n    }\n    return tuple(a,\
    \ b);\n}\n/*\nWrite a function that takes a list of strings, and returns a string\
    \ that is a combination of all the strings,\n    with a \"/\" inserted between\
    \ each. The string should not have a trailing slash.\n    >>> join_slash_strings([\"\
    one\", \"two\", \"three\"])\n    \"one/two/three\"\n*/\nstring join_slash_strings(string[]\
    \ words)\n{\n    string result = \"\";\n    for (int i = 0; i < words.length;\
    \ i++)\n    {\n        result ~= words[i];\n        if (i != words.length - 1)\n\
    \        {\n            result ~= \"/\";\n        }\n    }\n    return result;\n\
    }\n/*\nWrite a function that generates a dictionary where the keys are the numbers\
    \ between 0 and 100 inclusive,\n    and the values are the squares of the corresponding\
    \ keys.\n    >>> generate_dictionary_of_squares()\n    [0: 0, 1: 1, 2: 4, 3: 9,\
    \ 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100, ...]\n*/\nunittest\n{\n \
    \   alias candidate = find_closest_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\
    \ == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == tuple(2.2,\
    \ 3.1));\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphrsk9jq5.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a0b1]

    ??:? void tmphrsk9jq5.__unittest_L58_C1() [0x42906d]

    ??:? void tmphrsk9jq5.__modtest() [0x429a68]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42edc3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42dcd2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4325f9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x432aa8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x432585]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42dca9]

    ??:? runModuleUnitTests [0x42eb99]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a574]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164329
