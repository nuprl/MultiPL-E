name: HumanEval_155_even_odd_count
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nGiven an integer. return a tuple\
  \ that has the number of even and odd digits respectively.\n\n     Example:\n  \
  \  >>> even_odd_count(-12L)\n    tuple(1L, 1L)\n    >>> even_odd_count(123L)\n \
  \   tuple(1L, 2L)\n    \n*/\nTuple!(long, long) even_odd_count(long num) \n"
tests: "unittest\n{\n    alias candidate = even_odd_count;\n\n    assert(candidate(7L)\
  \ == tuple(0L, 1L));\n    assert(candidate(-78L) == tuple(1L, 1L));\n    assert(candidate(3452L)\
  \ == tuple(2L, 2L));\n    assert(candidate(346211L) == tuple(3L, 3L));\n    assert(candidate(-345821L)\
  \ == tuple(3L, 3L));\n    assert(candidate(-2L) == tuple(1L, 0L));\n    assert(candidate(-45347L)\
  \ == tuple(2L, 3L));\n    assert(candidate(0L) == tuple(1L, 0L));\n}\nvoid main(){}"
completions: ["{\n    Tuple!(long, long) result;\n    if (num == 0)\n    {\n     \
    \   result[0] = 1;\n        result[1] = 0;\n        return result;\n    }\n  \
    \  long even_num = 0;\n    long odd_num = 0;\n    long abs_num = abs(num);\n \
    \   while (abs_num > 0)\n    {\n        long div = abs_num % 10;\n        if (div\
    \ % 2 == 0)\n        {\n            even_num++;\n        }\n        else\n   \
    \     {\n            odd_num++;\n        }\n        abs_num /= 10;\n    }\n  \
    \  result[0] = even_num;\n    result[1] = odd_num;\n    return result;\n}", "{\n\
    \tlong even = 0L;\n\tlong odd = 0L;\n\tbool isNegative = false;\n\tif (num < 0L)\
    \ \n\t{\n\t\tisNegative = true;\n\t\tnum = -num;\n\t}\n\twhile (num > 0L) \n\t\
    {\n\t\tif (num & 1L)\n\t\t\todd++;\n\t\telse\n\t\t\teven++;\n\t\tnum >>= 1L;\n\
    \t}\n\tif (isNegative)\n\t\todd++;\n\treturn tuple(even, odd);\n}", "{\n\tlong\
    \ even_count = 0;\n\tlong odd_count = 0;\n\tlong n = num;\n\tif (n < 0) n = -n;",
  "{\n    import std.algorithm;\n    import std.array;\n    import std.conv;\n   \
    \ import std.range;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typetuple;\n    long[] digits = to!(long[])(to!string(num).byText.filter!q{a\
    \ => a >= '0' && a <= '9'}.map!q{a => to!long(a)}).array;\n    auto counts = reduce!q{a,\
    \ b => a[b%2]++}.counts(digits.length);\n    return tuple(counts[0], counts[1]);\n\
    }", "{\n    long num_even = 0;\n    long num_odd = 0;\n    while (num != 0)\n\
    \    {\n        long digit = num % 10;\n        if (digit % 2 == 0)\n        {\n\
    \            num_even++;\n        }\n        else\n        {\n            num_odd++;\n\
    \        }\n        num /= 10;\n    }\n    return tuple(num_even, num_odd);\n}",
  "{\n  long even = 0;\n  long odd = 0;\n  while (num != 0)\n  {\n    if (modulo(num,\
    \ 10) % 2 == 0)\n    {\n      even++;\n    }\n    else\n    {\n      odd++;\n\
    \    }\n    num /= 10;\n  }\n  return tuple(even, odd);\n}", "{\n    long evenCount\
    \ = 0L;\n    long oddCount = 0L;\n    long iterNum = abs(num);\n    for (; iterNum\
    \ != 0L;) \n    {\n        iterNum = iterNum / 10L;\n        if (evenCount ==\
    \ 0L) \n        {\n            evenCount = iterNum;\n        }\n        else \n\
    \        {\n            oddCount = iterNum;\n        }\n    }\n    return tuple(evenCount,\
    \ oddCount);\n}\n/*", "{\n    return tuple(num / 10 + (num % 2 == 0 ? 1 : 0),\
    \ num / 10 + (num % 2 == 1 ? 1 : 0));\n}", "    long abs_num = abs(num);\n   \
    \ long even = 0;\n    long odd = 0;\n    do \n    {\n        long digit = abs_num\
    \ % 10;\n        if (digit % 2 == 0) \n            even++;\n        else \n  \
    \          odd++;\n        abs_num /= 10;\n    } while (abs_num > 0);\n    return\
    \ tuple(even, odd);\n}", "{\n    long even = 0L;\n    long odd = 0L;\n    long\
    \ absNum = abs(num);\n    long temp;\n    for (temp = absNum; temp != 0L; temp\
    \ /= 10L) \n    {\n        long digit = temp % 10L;\n        if (digit % 2L ==\
    \ 0L)\n            even++;\n        else\n            odd++;\n    }\n    return\
    \ tuple(even, odd);\n}", "{\n    long count_even = 0L;\n    long count_odd = 0L;\n\
    \    bool is_negative = false;\n    if (num < 0L) {\n        is_negative = true;\n\
    \        num = -num;\n    }\n    long rem = 0L;\n    long rev = 0L;\n    long\
    \ i = 0L;\n    while (num != 0L) {\n        rem = num % 10L;\n        rev = rev\
    \ * 10L + rem;\n        num /= 10L;\n    }\n    while (rev != 0L) {\n        rem\
    \ = rev % 10L;\n        if (rem % 2L == 0L) {\n            count_even++;\n   \
    \     }\n        else {\n            count_odd++;\n        }\n        rev /= 10L;\n\
    \    }\n    if (is_negative) {\n        count_odd++;\n    }\n    return tuple(count_even,\
    \ count_odd);\n}", "{\n    // your code goes here \n    import std.conv;\n   \
    \ if (num<0L)\n    {\n        num = -num;\n    }\n    string s = to!string(num);\n\
    \    long n = s.length;\n    long odd=0, even=0;\n    for (int i=0; i<n; i++)\n\
    \    {\n        if (int(s[i])%2==0)\n        {\n            even++;\n        }\n\
    \        else\n        {\n            odd++;\n        }\n    }\n    return tuple(even,\
    \ odd);\n}\n \n/*\nwrite a function that will return a tuple, with the first element\
    \ being the\nnumber of occurrences of the search character in the input string\
    \ and the second\nbeing the number of occurrences of the search character in the\
    \ input string, ignoring\ncase.", "{\n    long even, odd;", "{\n    long odd=0,\
    \ even=0;\n    foreach(long d; 0 .. num.stringof.length)\n    {\n        if(cast(long)num.stringof[d]\
    \ % 2 == 0)\n            even++;\n        else\n            odd++;\n    }\n  \
    \  return tuple(even, odd);\n}", "{\n    long[] number = num.to!(string).split(\"\
    \").map!(to!long);\n    long even = 0;\n    long odd = 0;\n    foreach(digit;\
    \ number)\n    {\n        if(digit % 2 == 0)\n        {\n            even++;\n\
    \        }\n        else\n        {\n            odd++;\n        }\n    }\n  \
    \  return tuple(even, odd);\n}", "{\n\tlong odd = 0;\n\tlong even = 0;\n\tforeach(n;\
    \ num.to!string)\n\t{\n\t\tif (n.to!long % 2 == 0)\n\t\t\teven++;\n\t\telse\n\t\
    \t\todd++;\n\t}\n\treturn tuple(even, odd);\n}", "{\n    enum even = 0;\n    enum\
    \ odd = 1;\n    return Tuple!(long, long)(0, 0).tupleof[even] = count!(a => a\
    \ % 2 == 0)( num.tostring()).to!long(), \n        .tupleof[odd] = count!(a =>\
    \ a % 2 == 1)( num.tostring()).to!long();\n}", "{\n    Tuple!(long, long) res\
    \ = tuple(0L, 0L);\n    if (num < 0) \n    {\n        num = -num;\n    }\n   \
    \ while (num > 0) \n    {\n        if (num % 2 == 0) \n        {\n           \
    \ res[0]++;\n        }\n        else \n        {\n            res[1]++;\n    \
    \    }\n        num /= 10;\n    }\n    return res;\n}", "{\n    import std.range;\n\
    \    long evenCount = 0;\n    long oddCount = 0;\n    long n = num;\n    n.popFront();\n\
    \    int digit = n.front;\n    foreach(i; n)\n    {\n        if(digit % 2 == 0)\n\
    \        {\n            evenCount++;\n        }\n        else\n        {\n   \
    \         oddCount++;\n        }\n        n.popFront();\n        digit = n.front;\n\
    \    }\n    return tuple(evenCount, oddCount);\n}\n/*\n    Given a 4 element array\
    \ of ints. Return true iff the array contains two elements\n    with the same\
    \ value, and two elements with the same value but different from the\n    two\
    \ other elements. \n    \n    Example:\n    \n    [3, 2, 3, 2]\n    true\n   \
    \ \n    [3, 2, 3, 2, 5]\n    false\n    \n    [1, 1, 2, 2]\n    true\n    \n \
    \   [1, 1, 2, 2, 5]\n    false\n    \n    [1, 2, 1, 2]\n    false\n*/", "{\n \
    \   long  countEven = 0;\n    long  countOdd = 0;\n    long digit;\n    long sign\
    \ = 1;\n    if (num < 0)\n    {\n        sign = -1;\n        num = -num;\n   \
    \ }\n    while (num > 0)\n    {\n        digit = num % 10;\n        if (digit\
    \ % 2 == 0)\n        {\n            countEven++;\n        }\n        else\n  \
    \      {\n            countOdd++;\n        }\n        num /= 10;\n    }\n    return\
    \ tuple(countEven, countOdd);\n}", "{\n    auto even = 0L;\n    auto odd = 0L;\n\
    \    auto digit = 0L;\n    auto isNegative = 0L;\n    num = abs(num);\n    while\
    \ (num > 0) \n    {\n        digit = num % 10;\n        if (digit % 2 == 0) even++;\n\
    \        else odd++;\n        num /= 10;\n    }\n    return tuple(even, odd);\n\
    }", "{\n    long even_count = 0;\n    long odd_count = 0;\n    if (num < 0)\n\
    \        num = -num;\n    \n    foreach(val; num.digits)\n    {\n        if (val\
    \ % 2 == 0)\n            even_count++;\n        else\n            odd_count++;\n\
    \    }\n    return tuple(even_count, odd_count);\n}", "{\n    auto abs_num = abs(num);\n\
    \    auto even = 0L;\n    auto odd = 0L;\n    foreach(digit; abs_num.digits) \n\
    \    {\n        if(digit % 2 == 0) \n        {\n            even += 1;\n     \
    \   }\n        else \n        {\n            odd += 1;\n        }\n    }\n   \
    \ return tuple(even, odd);\n}\n/*\nWrite a function that takes a 2-dimensional\
    \ array and returns a transposed array. \n    Example:\n    >>> transpose([[1,\
    \ 2, 3], [4, 5, 6]])\n    [[1, 4], [2, 5], [3, 6]]\n*/\nauto transpose(T)(T arr)\
    \ \n{\n    auto rows = arr.length;\n    auto cols = arr[0].length;\n    auto result\
    \ = new T[rows][cols];\n    foreach(row; 0..rows) \n    {\n        foreach(col;\
    \ 0..cols) \n        {\n            result[col][row] = arr[row][col];\n      \
    \  }\n    }\n    return result;\n}\n/*\nWrite a function that takes a 2-dimensional\
    \ array and returns a flattened array.", "{\n    long even=0, odd=0;\n    while(num\
    \ != 0) \n    {\n        if(num % 2 == 0) \n        {\n            even++;\n \
    \       } \n        else \n        {\n            odd++;\n        }\n        num\
    \ /= 10;\n    }\n    return tuple(even, odd);\n}", "{\n    long even = 0;\n  \
    \  long odd = 0;\n    while (num != 0)\n    {\n        if ((num % 10) % 2 == 0)\n\
    \            even++;\n        else\n            odd++;\n        num /= 10;\n \
    \   }\n    return tuple(even, odd);\n}", "in \n{\n    assert(num >= 0L);\n}\n\
    body \n{\n    if (num < 10L) \n    {\n        return tuple(num % 2L, 1L - num\
    \ % 2L);\n    } \n    else \n    {\n        long lastDigit = num % 10L;\n    \
    \    Tuple!(long, long) recursiveResult = even_odd_count(num / 10L);\n       \
    \ long newOdd = recursiveResult[1] + (lastDigit % 2L);\n        long newEven =\
    \ recursiveResult[0] + (1L - lastDigit % 2L);\n        return tuple(newEven, newOdd);\n\
    \    }\n}\n/*\nGiven a string.\nreturn true if the string is a palindrome, i.e.\
    \ the same forwards and backwards, ignoring spaces, punctuation and case.\nFor\
    \ example, \"Madam Im Adam\" is a palindrome.\nHint: think recursively. \n   \
    \ \n    Example:\n    >>> is_palindrome(\"aabaa\")\n    true\n    >>> is_palindrome(\"\
    abca\")\n    false\n*/", "    if (num == null)\n{\n    long nEven, nOdd;\n   \
    \ while (num != 0) \n    {\n        if (num % 2 == 0) \n        {\n          \
    \  nEven += 1;\n        } \n        else \n        {\n            nOdd += 1;\n\
    \        }\n        num /= 10;\n    }\n    return tuple(nEven, nOdd);\n}", "{\n\
    \    long even = 0;\n    long odd = 0;\n    int negative = 0;\n    if (num < 0)\n\
    \    {\n        negative = 1;\n        num = abs(num);\n    }\n    while (num\
    \ > 0)\n    {\n        if ((num % 10) % 2 == 0) even++;\n        else odd++;\n\
    \        num /= 10;\n    }\n    return tuple(even, odd);\n}\n ", "{\n\tlong even,\
    \ odd;\n\teven = odd = 0;\n\twhile (num != 0)\n\t{\n\t\tif ((num % 10) % 2 ==\
    \ 0)\n\t\t\teven++;\n\t\telse\n\t\t\todd++;\n\t\tnum /= 10;\n\t}\n\treturn tuple(even,\
    \ odd);\n}", "{\n    long num_even = 0;\n    long num_odd = 0;\n    if (num <\
    \ 0) \n    {\n        num = -num;\n    }\n    while (num != 0) \n    {\n     \
    \   auto digit = num % 10;\n        if (digit % 2 == 0) \n        {\n        \
    \    num_even++;\n        }\n        else \n        {\n            num_odd++;\n\
    \        }\n        num /= 10;\n    }\n    return tuple(num_even, num_odd);\n}",
  "{\n\tlong oddCount = 0;\n\tlong evenCount = 0;\n\twhile (num != 0)\n\t{\n\t\tlong\
    \ x = num % 10;\n\t\tnum /= 10;\n\t\tif (x % 2 == 0)\n\t\t\tevenCount++;\n\t\t\
    else\n\t\t\toddCount++;\n\t}\n\treturn tuple(evenCount, oddCount);\n}", "{\n \
    \   auto even = 0L;\n    auto odd = 0L;\n    auto negative = num < 0;\n    num\
    \ = abs(num);\n    while (num) \n    {\n        if (num & 1) \n        {\n   \
    \         odd++;\n        } \n        else \n        {\n            even++;\n\
    \        }\n        num /= 10;\n    }\n    if (negative) \n    {\n        odd++;\n\
    \    }\n    return tuple(even, odd);\n}", "{\n    Tuple!(long, long) result =\
    \ tuple(0L, 0L);\n    if (num < 0)\n    {\n        num = -num;\n    }\n    while\
    \ (num != 0)\n    {\n        if (num % 2 == 0)\n        {\n            result[0]++;\n\
    \        }\n        else\n        {\n            result[1]++;\n        }\n   \
    \     num /= 10;\n    }\n    return result;\n}", "{\n    Tuple!(long, long) even_odd;\n\
    \    even_odd.init(0L, 0L);\n    long x = abs(num);\n    while (x > 0) {\n   \
    \     if (x % 2 == 0)\n            even_odd.tupleof[0] += 1;\n        else\n \
    \           even_odd.tupleof[1] += 1;\n        x /= 10;\n    }\n    return even_odd;\n\
    }\nstatic assert(even_odd_count(-12L) == tuple(1L, 1L));\nstatic assert(even_odd_count(123L)\
    \ == tuple(1L, 2L));\n \n \n \n/*\nGiven a list of integer. return the first index(zero\
    \ based) of the list that sum of digits of the element is odd.", "{\n    /*\n\
    \    going from abs(num) to num is by design. \n    The algorithm is the same\
    \ but this way we can preserve the sign of num\n    */\n    long oddCount = 0;\n\
    \    long evenCount = 0;\n    long numAbs = num;\n    long numAbsAbs = numAbs;\n\
    \    if (num < 0)\n    {\n        numAbs = -numAbs;\n        numAbsAbs = -numAbsAbs;\n\
    \    }\n    while (numAbs != 0)\n    {\n        long numAbsMod10 = numAbsAbs %\
    \ 10;\n        if (numAbsMod10 % 2 == 0)\n        {\n            evenCount +=\
    \ 1;\n        }\n        else\n        {\n            oddCount += 1;\n       \
    \ }\n        numAbsAbs /= 10;\n    }\n    return tuple(evenCount, oddCount);\n\
    }\n \n/*\nGiven a positive integer. Return a new integer that has the digits reversed.",
  "{\n    auto even_count = 0L;\n    auto odd_count = 0L;\n    if (num == 0) {\n \
    \       return tuple(0L, 0L);\n    }\n    while (num != 0) {\n        if (abs(num\
    \ % 10) % 2 == 0) {\n            even_count += 1;\n        } else {\n        \
    \    odd_count += 1;\n        }\n        num /= 10;\n    }\n    return tuple(even_count,\
    \ odd_count);\n}", "{\n    long _even = 0;\n    long _odd = 0;\n    long _digits\
    \ = 0;\n    num = std.math.abs(num);\n    while (num != 0)\n    {\n        _digits\
    \ = num % 10;\n        if (_digits % 2 == 0)\n        {\n            _even++;\n\
    \        }\n        else\n        {\n            _odd++;\n        }\n        num\
    \ /= 10;\n    }\n    return std.typecons.tuple(_even, _odd);\n}", "{\n    long\
    \ evenCount = 0;\n    long oddCount = 0;\n    foreach(digit; num.toString())\n\
    \    {\n        if(digit.to!long & 1)\n            oddCount++;\n        else\n\
    \            evenCount++;\n    }\n    return tuple(evenCount, oddCount);\n}",
  "{\n    long even, odd;\n    even = odd = 0;\n    while (num != 0) \n    {\n   \
    \     auto temp = abs(num % 10);\n        if (temp & 1)\n            odd++;\n\
    \        else\n            even++;\n        num /= 10;\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n\tlong even = 0L;\n\tlong odd = 0L;\n\t\n\tif (num == 0L)\n\t\
    {\n\t\teven = 1L;\n\t\treturn tuple(even, odd);\n\t}\n\t\n\tif (num < 0L)\n\t\
    {\n\t\tnum = -num;\n\t}\n\t\n\twhile (num != 0L)\n\t{\n\t\tif (num % 2L == 0L)\n\
    \t\t{\n\t\t\teven++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\todd++;\n\t\t}\n\t\tnum /=\
    \ 10L;\n\t}\n\t\n\treturn tuple(even, odd);\n}", "{\n    long even_count=0L;\n\
    \    long odd_count=0L;\n    int k=10;\n    for(long i=num;i>0;i/=k) \n    {\n\
    \        if((i%k)%2==0) even_count++;\n        else odd_count++;\n    }\n    return\
    \ tuple(even_count, odd_count);\n}", "{\n    long even = 0;\n    long odd = 0;\n\
    \    int mod;\n    num = abs(num);\n    while (num > 0)\n    {\n        mod =\
    \ num % 10;\n        if (mod % 2 == 0) even++;\n        else odd++;\n        num\
    \ /= 10;\n    }\n    return tuple(even, odd);\n}", "{\n\tlong even, odd;\n\tlong\
    \ digit;\n\teven = odd = 0;\n\twhile (num != 0) \n\t{\n\t\tdigit = num % 10;\n\
    \t\tif (digit % 2 == 0) \n\t\t{\n\t\t\teven += 1;\n\t\t}\n\t\telse \n\t\t{\n\t\
    \t\todd += 1;\n\t\t}\n\t\tnum /= 10;\n\t}\n\treturn tuple(even, odd);\n}\n/*\n\
    Given a point P and other n points, find k points out of the n points which are\
    \ nearest to P.", "{\n    Tuple!(long, long) res = tuple(0L, 0L);\n    if (num\
    \ < 0) num = -num;\n    for (auto d; num > 0) {\n        if (d % 2 == 0) res[0]++;\n\
    \        else res[1]++;\n        num /= 10;\n    }\n    return res;\n}", "{\n\
    \    long odd_count = 0;\n    long even_count = 0;\n    while (num != 0) \n  \
    \  {\n        int digit = abs(num % 10);\n        if (digit % 2 == 0) \n     \
    \   {\n            even_count += 1;\n        } \n        else \n        {\n  \
    \          odd_count += 1;\n        }\n        num /= 10;\n    }\n    return tuple(even_count,\
    \ odd_count);\n}", "{\n\tint even = 0;\n\tint odd = 0;\n\twhile (num) \n\t{\n\t\
    \tif (abs(num) % 2 == 0)\n\t\t\teven++;\n\t\telse\n\t\t\todd++;\n\t\tnum /= 10;\n\
    \t}\n\treturn tuple(even, odd);\n}\n/*\nGiven a string, split it into a tuple\
    \ containing two strings. The first string contains the first N/2 characters,\
    \ and the second string contains the last N/2 characters. The length of the string\
    \ is guaranteed to be even.", "{\n    if (num == 0)\n        return tuple(0L,\
    \ 0L);\n    long evenCount = 0;\n    long oddCount = 0;\n    long r = 0;\n   \
    \ if (num < 0) \n    {\n        num = -num;\n    }\n    while (num > 0) \n   \
    \ {\n        r = num % 10;\n        if (r % 2 == 0) \n        {\n            evenCount\
    \ += 1;\n        } \n        else \n        {\n            oddCount += 1;\n  \
    \      }\n        num /= 10;\n    }\n    return tuple(evenCount, oddCount);\n}",
  "{\n    long odds = 0;\n    long evens = 0;\n    auto s = to!string(num);\n    foreach(c;\
    \ s)\n    {\n        auto ci = to!int(c);\n        if(ci & 1) odds++;\n      \
    \  else evens++;\n    }\n    return tuple(evens, odds);\n}", "{\n    if (num <\
    \ 0)\n        num = -num;\n    long even = 0;\n    long odd = 0;\n    while (num\
    \ > 0) \n    {\n        if (num % 2 == 0)\n            even++;\n        else\n\
    \            odd++;\n        num /= 10;\n    }\n    return tuple(even, odd);\n\
    }\n ", "{\n    long even = 0L;\n    long odd = 0L;\n    bool negative = num <\
    \ 0L;\n    num = abs(num);\n    foreach(i; 0L .. num.countDigits()) \n    {\n\
    \        long digit = num.modPow10(i);\n        if (digit.isEven) \n        {\n\
    \            even++;\n        }\n        else \n        {\n            odd++;\n\
    \        }\n    }\n    if (negative) \n    {\n        odd++;\n    }\n    return\
    \ tuple(even, odd);\n}\nstatic assert(even_odd_count(-12L) == tuple(1L, 1L));\n\
    static assert(even_odd_count(123L) == tuple(1L, 2L));", "{\n    long even = 0L;\n\
    \    long odd = 0L;\n    num = abs(num);\n    for (long digit; num > 0L; num /=\
    \ 10L) \n    {\n        digit = num % 10L;\n        if (digit % 2L == 0L) \n \
    \       {\n            even += 1L;\n        }\n        else \n        {\n    \
    \        odd += 1L;\n        }\n    }\n    return tuple(even, odd);\n}", "{\n\
    \     long even_count = 0;\n     long odd_count = 0;\n    \n     foreach(n; num.to!(string))\n\
    \     {\n         if(n.to!long % 2 == 0)\n             even_count++;\n       \
    \  else\n             odd_count++;\n     }\n    \n     return tuple(even_count,\
    \ odd_count);\n}", "{\n    long even = 0L;\n    long odd = 0L;\n    long num_abs\
    \ = abs(num);\n    while (num_abs > 0L) \n    {\n        long digit = num_abs\
    \ % 10L;\n        if (digit % 2L == 0L) \n        {\n            even += 1L;\n\
    \        } \n        else \n        {\n            odd += 1L;\n        }\n   \
    \     num_abs /= 10L;\n    }\n    return tuple(even, odd);\n}", "{\n    int even\
    \ = 0;\n    int odd = 0;\n    foreach(d; num.to!string) \n    {\n        if (d.to!int\
    \ & 1)\n            odd++;\n        else\n            even++;\n    }\n    return\
    \ tuple(even, odd);\n}", "{\n    long even = 0;\n    long odd = 0;\n    while\
    \ (num != 0)\n    {\n        if ((num & 1) == 0)\n            even++;\n      \
    \  else\n            odd++;\n        num >>= 1;\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    auto a = tuple(0L, 0L);\n    while (num != 0) \n    {\n \
    \       if (abs(num % 10) % 2 == 0) \n        {\n            ++a[0];\n       \
    \ } \n        else \n        {\n            ++a[1];\n        }\n        num /=\
    \ 10;\n    }\n    return a;\n}", "{\n    long even = 0;\n    long odd = 0;\n \
    \   long digit;\n    if (num < 0)\n        num = -num;\n    while (num > 0)\n\
    \    {\n        digit = num % 10;\n        if (digit % 2 == 0)\n            even\
    \ += 1;\n        else\n            odd += 1;\n        num /= 10;\n    }\n    return\
    \ tuple(even, odd);\n}", "{\n    long odd_count = 0L;\n    long even_count = 0L;\n\
    \    if (num < 0L) \n    {\n        num = -num;\n    }\n    long t;\n    while\
    \ (num != 0L) \n    {\n        t = num % 10L;\n        if (t % 2L == 0L) \n  \
    \      {\n            even_count++;\n        }\n        else \n        {\n   \
    \         odd_count++;\n        }\n        num /= 10L;\n    }\n    return tuple(even_count,\
    \ odd_count);\n}\n// Computing the product of the digits, given a number", "{\n\
    \    long odd = 0;\n    long even = 0;\n    long temp;\n    foreach(i; 0 .. abs(num))\
    \ {\n        temp = (num / (pow(10, i)) % 10);\n        if(temp % 2 == 0)\n  \
    \          even++;\n        else\n            odd++;\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    long even = 0L;\n    long odd = 0L;\n    long mod = 0L;\n\
    \    long mod_res = 0L;\n    if (num > 0L) \n    {\n        num = num * -1L;\n\
    \    }\n    else \n    {\n        num = num * -1L;\n    }\n    mod = num % 10L;\n\
    \    mod_res = mod % 2L;\n    if (mod_res == 0L) \n    {\n        even += 1L;\n\
    \    }\n    else \n    {\n        odd += 1L;\n    }\n    while (num != 0L) \n\
    \    {\n        num = num / 10L;\n        mod = num % 10L;\n        mod_res =\
    \ mod % 2L;\n        if (mod_res == 0L) \n        {\n            even += 1L;\n\
    \        }\n        else \n        {\n            odd += 1L;\n        }\n    }\n\
    \    return tuple(even, odd);\n}", "{\n    // Count the odds\n    size_t numOdds\
    \ = 0;\n    while (num > 0)\n    {\n        if (num % 2 != 0)\n            numOdds++;\n\
    \        num /= 10;\n    }\n    return tuple(numOdds, (num.to!string.length -\
    \ numOdds));\n}", "{\n    auto even_count = 0L;\n    auto odd_count = 0L;\n  \
    \  while (num != 0) \n    {\n        auto digit = num % 10;\n        if (digit\
    \ % 2 == 0) \n        {\n            even_count++;\n        }\n        else \n\
    \        {\n            odd_count++;\n        }\n        num /= 10;\n    }\n \
    \   return tuple(even_count, odd_count);\n}", "{\n\t//check the negative\n\tif\
    \ (num < 0)\n\t{\n\t\tnum = -num;\n\t}\n\tlong odd_counter = 0;\n\tlong even_counter\
    \ = 0;\n\twhile (num > 0)\n\t{\n\t\tlong digit = num % 10;\n\t\tif (digit % 2\
    \ == 0)\n\t\t{\n\t\t\teven_counter++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\todd_counter++;\n\
    \t\t}\n\t\tnum /= 10;\n\t}\n\treturn tuple(even_counter, odd_counter);\n}", "{\n\
    \    long even = 0;\n    long odd = 0;\n    while (num != 0)\n    {\n        if\
    \ (abs(num % 10) % 2 == 0)\n            even++;\n        else\n            odd++;\n\
    \        num /= 10;\n    }\n    return tuple(even, odd);\n}", "{\n    // your\
    \ code goes here\n    long even, odd;\n    even = odd = 0;\n    while(num) {\n\
    \        if(num % 2) odd++;\n        else even++;\n        num /= 10;\n    }\n\
    \    return tuple(even, odd);\n}", "{\n    long evenCount = 0L;\n    long oddCount\
    \ = 0L;\n    long absNum = abs(num);\n    while (absNum > 0L) \n    {\n      \
    \  long digit = absNum % 10L;\n        if (digit & 1L) \n        {\n         \
    \   oddCount += 1L;\n        }\n        else \n        {\n            evenCount\
    \ += 1L;\n        }\n        absNum /= 10L;\n    }\n    return tuple(evenCount,\
    \ oddCount);\n}", "{\n    auto even, odd;\n    for (; num != 0; num /= 10) \n\
    \    {\n        if (num % 2 == 0) \n        {\n            even += 1;\n      \
    \  }\n        else \n        {\n            odd += 1;\n        }\n    }\n    return\
    \ tuple(even, odd);\n}", "{\n    // Cast num to int, since we only want to count\
    \ the digits, not their\n    // sign.\n    int n = abs(int(num));\n    // Keep\
    \ track of the number of even and odd digits.\n    int even, odd;\n    // Until\
    \ there are no more digits.\n    while (n != 0) {\n        // If the last digit\
    \ is even.\n        if (n % 2 == 0) {\n            even++;\n        } else {\n\
    \            odd++;\n        }\n        // Move on to the next digit.\n      \
    \  n /= 10;\n    }\n    // Construct a tuple from even and odd.\n    return tuple(even,\
    \ odd);\n}", "{\n    \n    long evenCount = 0L;\n    long oddCount = 0L;\n   \
    \ if (num == 0L)\n    {\n        evenCount++;\n    }\n    else\n    {\n      \
    \  if (num < 0L)\n        {\n            num = abs(num);\n        }\n        while\
    \ (num != 0L)\n        {\n            if (num % 2L == 0L)\n            {\n   \
    \             evenCount++;\n            }\n            else\n            {\n \
    \               oddCount++;\n            }\n            num /= 10L;\n        }\n\
    \    }\n    return tuple(evenCount, oddCount);\n}", "{\n    long even = 0L;\n\
    \    long odd = 0L;\n    while (num != 0L) \n    {\n        long a = num % 10L;\n\
    \        if (a % 2L == 0L) \n        {\n            even++;\n        }\n     \
    \   else \n        {\n            odd++;\n        }\n        num /= 10L;\n   \
    \ }\n    return tuple(even, odd);\n}", "{\n    auto t = tuple(0L, 0L);\n    while\
    \ (num != 0) \n    {\n        if (abs(num % 10) % 2 == 0) \n        {\n      \
    \      t[0]++;\n        } \n        else \n        {\n            t[1]++;\n  \
    \      }\n        num /= 10;\n    }\n    return t;\n}", "    long evenCount =\
    \ 0;\n    long oddCount = 0;\n    do {\n        if (num % 2 == 0) {\n        \
    \    evenCount++;\n        } else {\n            oddCount++;\n        }\n    \
    \    num /= 10;\n    } while (num != 0);\n    return tuple(evenCount, oddCount);\n\
    }", "{\n    import std.conv : to;\n    import std.typecons : tuple;\n    int even\
    \ = 0;\n    int odd = 0;\n    int digit = 0;\n    string s = num.to!string;\n\
    \    foreach(d; s)\n    {\n        digit = d.to!int;\n        if(digit % 2 ==\
    \ 0)\n        {\n            even++;\n        }\n        else\n        {\n   \
    \         odd++;\n        }\n    }\n    return tuple(even, odd);\n}", "{\n   \
    \ import std.algorithm : filter, length;\n    import std.conv : to;\n    import\
    \ std.range : zip;\n    import std.array : array;\n    import std.typecons : tuple;\n\
    \    auto digits = num.to!string.array.map!(a => a.to!long);\n    auto evens =\
    \ digits.filter!(a => a % 2 == 0).length;\n    auto odds = digits.filter!(a =>\
    \ a % 2 != 0).length;\n    return tuple(evens, odds);\n}", "{\n    Tuple!(long,\
    \ long) t;\n    t[0] = 0;\n    t[1] = 0;\n    int count = 0;\n    for (; num !=\
    \ 0; num /= 10) \n    {\n        int digit = num % 10;\n        if (digit % 2\
    \ == 0)\n            t[0]++;\n        else\n            t[1]++;\n    }\n    return\
    \ t;\n}", "{\n    if (num == 0)\n        return tuple(0L, 0L);\n    long even\
    \ = 0L;\n    long odd = 0L;\n    long tnum = num;\n    while (tnum != 0) \n  \
    \  {\n        if (tnum % 2 == 0)\n            even++;\n        else\n        \
    \    odd++;\n        tnum /= 10;\n    }\n    return tuple(even, odd);\n}", "{\n\
    \    long evenCount=0;\n    long oddCount=0;\n    foreach(digit;to!string(num))\n\
    \    {\n        if(digit.to!long()%2==0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    return tuple(evenCount,oddCount);\n}", "{\n    long evenCount = 0;\n    long\
    \ oddCount = 0;\n    if (num < 0)\n    {\n        num = -num;\n    }\n    while\
    \ (num > 0)\n    {\n        if (num % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    \
    \    num /= 10;\n    }\n    return tuple(evenCount, oddCount);\n}", "{\n    int\
    \ even, odd;\n    even = odd = 0;\n    num = abs(num);\n    while (num > 0) {\n\
    \        if (num % 2 == 0) {\n            even++;\n        } else {\n        \
    \    odd++;\n        }\n        num /= 10;\n    }\n    return tuple(even, odd);\n\
    }\n ", "{\n    long ev_count = 0;\n    long od_count = 0;\n    long divisor =\
    \ 1;\n    while (num/divisor != 0) {\n        if (((num/divisor) % 2) == 0) {\n\
    \            ev_count++;\n        } else {\n            od_count++;\n        }\n\
    \        divisor = divisor * 10;\n    }\n    return tuple(ev_count, od_count);\n\
    }", "{\n    long even = 0;\n    long odd = 0;\n    while (num != 0) \n    {\n\
    \        long digit = num % 10;\n        if (digit & 1)\n            odd++;\n\
    \        else\n            even++;\n        num /= 10;\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    auto m = makeTuple(0L, 0L);\n    while (num != 0) \n    {\n\
    \        auto lastDigit = num % 10;\n        if (lastDigit % 2 == 0) \n      \
    \  {\n            m[0]++;\n        }\n        else \n        {\n            m[1]++;\n\
    \        }\n        num /= 10;\n    }\n    return m;\n}", "{\n\tauto even = 0;\n\
    \tauto odd = 0;\n\t\n\tforeach(ch; num.to!string)\n\t{\n\t\tif(ch.to!int % 2 ==\
    \ 0)\n\t\t\teven++;\n\t\telse\n\t\t\todd++;\n\t}\n\t\n\treturn tuple(even, odd);\n\
    }", "{\n    return tuple( \n        countIf!((d) => d % 2 == 0, num.toString.map!(to!int)),\n\
    \        countIf!((d) => d % 2 == 1, num.toString.map!(to!int))\n    );\n}", "{\n\
    \    long even_cnt = 0;\n    long odd_cnt = 0;\n    if (num < 0)\n        num\
    \ = -num;\n    while (num > 0)\n    {\n        long digit = num % 10;\n      \
    \  if (digit % 2 == 0)\n            even_cnt += 1;\n        else\n           \
    \ odd_cnt += 1;\n        num /= 10;\n    }\n    return tuple(even_cnt, odd_cnt);\n\
    }", "{\n    long even = 0;\n    long odd = 0;\n    if (num < 0) \n    {\n    \
    \    num = -num;\n    }\n    while (num != 0) \n    {\n        auto n = num %\
    \ 10;\n        if (n % 2 == 0) \n        {\n            even++;\n        } \n\
    \        else \n        {\n            odd++;\n        }\n        num /= 10;\n\
    \    }\n    return tuple(even, odd);\n}", "{\n    int oddCount = 0;\n    int evenCount\
    \ = 0;\n    foreach(i, v; num.to!string)\n    {\n        if(to!int(v) % 2 == 0)\n\
    \        {\n            evenCount++;\n        }\n        else\n        {\n   \
    \         oddCount++;\n        }\n    }\n    return tuple(evenCount, oddCount);\n\
    }", "{\n    long oddCount = 0L;\n    long evenCount = 0L;\n    bool isNegative\
    \ = false;\n    if (num < 0L) \n    {\n        isNegative = true;\n        num\
    \ = abs(num);\n    }\n    while (num > 0L) \n    {\n        long digit = num %\
    \ 10L;\n        if (digit % 2L == 0L) \n        {\n            evenCount++;\n\
    \        }\n        else \n        {\n            oddCount++;\n        }\n   \
    \     num /= 10L;\n    }\n    return tuple(evenCount, oddCount);\n}", "{\n   \
    \ int evenCount=0;\n    int oddCount=0;\n    while(num != 0)\n    {\n        int\
    \ digit = num % 10;\n        if (digit % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    \
    \    num = num / 10;\n    }\n    return tuple(evenCount, oddCount);\n}\n/*\nGiven\
    \ a list of integers, return a tuple that has the number of positive and negative\
    \ numbers respectively.", "{\n    long even = 0;\n    long odd = 0;\n    if (num\
    \ < 0) \n    {\n        num = -num;\n    }\n    while (num > 0) \n    {\n    \
    \    if (num % 2 == 0) \n        {\n            even++;\n        } \n        else\
    \ \n        {\n            odd++;\n        }\n        num /= 10;\n    }\n    return\
    \ tuple(even, odd);\n}\n \n /*\n You are given a string. Return tuple of length\
    \ of shortest word and longest word.\n \n     Example:\n    >>> word_lengths(\"\
    The quick brown fox jumps over the lazy dog\")\n    tuple(3L, 6L)\n    >>> word_lengths(\"\
    I love Python\")\n    tuple(1L, 6L)\n */\nTuple!(long, long) word_lengths(string\
    \ s) \n{\n    return tuple(map!(a => a.length)(s.split()).min, map!(a => a.length)(s.split()).max);\n\
    }\n/*\nGiven an array of ints, return a tuple of (max, min) of the array.", "{\n\
    \    Tuple!(long, long) res = tuple(0L, 0L);\n    while (num != 0) {\n       \
    \ if ((num % 10) % 2 == 0) {\n            res[0] += 1;\n        }\n        else\
    \ {\n            res[1] += 1;\n        }\n        num /= 10;\n    }\n    return\
    \ res;\n}\n/*\nGiven an integer. return a tuple that has the number of even and\
    \ odd digits respectively.", "{\n    long even = 0;\n    long odd = 0;\n    long\
    \ n = abs(num);\n    while (n != 0) \n    {\n        if (n % 2 == 0) \n      \
    \  {\n            even++;\n        }\n        else \n        {\n            odd++;\n\
    \        }\n        n /= 10;\n    }\n    return tuple(even, odd);\n}", " {\n \
    \ auto t = tuple(0L, 0L);\n  if (num < 0) num = -num;\n  while (num > 0) {\n \
    \   auto x = num % 10;\n    num /= 10;\n    if (x % 2 == 0) t[0] += 1;\n    else\
    \ t[1] += 1;\n  }\n  return t;\n}", "{\n    int evenCount = 0;\n    int oddCount\
    \ = 0;\n    int currentDigit;\n    long absNum = num < 0 ? -num : num;\n    while\
    \ (absNum > 0)\n    {\n        currentDigit = int(absNum % 10);\n        if (currentDigit\
    \ % 2 == 0)\n        {\n            evenCount++;\n        }\n        else\n  \
    \      {\n            oddCount++;\n        }\n        absNum /= 10;\n    }\n \
    \   return tuple(evenCount, oddCount);\n}", "in\n{\n    assert(num != long.min);\n\
    }\nbody\n{\n    long num_even = 0;\n    long num_odd = 0;\n    if (num < 0)\n\
    \    {\n        num = -num;\n    }\n    while (num != 0)\n    {\n        if (num\
    \ % 2 == 0)\n        {\n            num_even++;\n        }\n        else\n   \
    \     {\n            num_odd++;\n        }\n        num /= 10;\n    }\n    return\
    \ tuple(num_even, num_odd);\n}", "{\n\talias N = typeof(num);\n\tstatic if(is(N\
    \ == short))\n\t{\n\t\tnum = abs(num);\n\t\tlong oddCnt = 0L;\n\t\tlong evenCnt\
    \ = 0L;\n\t\twhile(num > 0)\n\t\t{\n\t\t\tlong val = num % 10;\n\t\t\tif(val %\
    \ 2) oddCnt++;\n\t\t\telse evenCnt++;\n\t\t\tnum /= 10;\n\t\t}\n\t\treturn tuple(evenCnt,\
    \ oddCnt);\n\t}\n\telse static if(is(N == int))\n\t{\n\t\tnum = abs(num);\n\t\t\
    long oddCnt = 0L;\n\t\tlong evenCnt = 0L;\n\t\twhile(num > 0)\n\t\t{\n\t\t\tlong\
    \ val = num % 10;\n\t\t\tif(val % 2) oddCnt++;\n\t\t\telse evenCnt++;\n\t\t\t\
    num /= 10;\n\t\t}\n\t\treturn tuple(evenCnt, oddCnt);\n\t}\n\telse static if(is(N\
    \ == long))\n\t{\n\t\tnum = abs(num);\n\t\tlong oddCnt = 0L;\n\t\tlong evenCnt\
    \ = 0L;\n\t\twhile(num > 0)\n\t\t{\n\t\t\tlong val = num % 10;\n\t\t\tif(val %\
    \ 2) oddCnt++;\n\t\t\telse evenCnt++;\n\t\t\tnum /= 10;\n\t\t}\n\t\treturn tuple(evenCnt,\
    \ oddCnt);\n\t}\n\telse static if(is(N == ulong))\n\t{\n\t\tlong oddCnt = 0L;\n\
    \t\tlong evenCnt = 0L;\n\t\twhile(num > 0)\n\t\t{\n\t\t\tlong val = num % 10;\n\
    \t\t\tif(val % 2) oddCnt++;\n\t\t\telse evenCnt++;\n\t\t\tnum /= 10;\n\t\t}\n\t\
    \treturn tuple(evenCnt, oddCnt);\n\t}\n\telse static if(is(N == long))\n\t{\n\t",
  "{\n\tlong evens = 0L;\n\tlong odds = 0L;\n\t\n\twhile (num > 0L) \n\t{\n\t\tlong\
    \ digit = num % 10L;\n\t\tif (digit % 2L == 0L) \n\t\t{\n\t\t\tevens++;\n\t\t\
    } \n\t\telse \n\t\t{\n\t\t\todds++;\n\t\t}\n\t\tnum /= 10L;\n\t}\n\treturn tuple(evens,\
    \ odds);\n}", "{\n    long even=0;\n    long odd=0;\n    while(num>0)\n    {\n\
    \        auto digit=num%10;\n        if(digit%2==0) even++;\n        else odd++;\n\
    \        num/=10;\n    }\n    return tuple(even,odd);\n}", "{\n\tTuple!(long,\
    \ long) result;\n\tresult[0] = 0;\n\tresult[1] = 0;\n\tlong abs = num < 0 ? -num\
    \ : num;\n\tlong pow = (long)log10(abs);\n\tlong val;\n\twhile (pow >= 0)\n\t\
    {\n\t\tval = (abs / (long)pow10(pow)) % 10;\n\t\tif (val % 2 == 0)\n\t\t\tresult[0]++;\n\
    \t\telse\n\t\t\tresult[1]++;\n\t\tpow--;\n\t}\n\treturn result;\n}\n/*\nGiven\
    \ an integer. return a tuple that has the number of even and odd digits respectively.",
  "{\n    long even = 0L;\n    long odd = 0L;\n    if (num < 0L) \n    {\n       \
    \ num = -num;\n    }\n    while (num > 0L) \n    {\n        long digit = num %\
    \ 10L;\n        if (digit % 2L == 0L) \n        {\n            even = even + 1L;\n\
    \        }\n        else \n        {\n            odd = odd + 1L;\n        }\n\
    \        num = num / 10L;\n    }\n    return tuple(even, odd);\n}\n/*\nYou are\
    \ given a sequence of integers, as well as an integer. Remove all instances of\
    \ the given integer from the sequence.", "{\n    long _even = 0;\n    long _odd\
    \ = 0;\n    long _absNum = abs(num);\n    while (_absNum)\n    {\n        if (_absNum\
    \ % 2 == 0)\n            _even++;\n        else\n            _odd++;\n       \
    \ \n        _absNum /= 10;\n    }\n    return tuple(_even, _odd);\n}", "{\n\t\
    auto count = tuple(0L, 0L);\n\tif (num == 0) \n\t{\n\t\tcount[0]++;\n\t\treturn\
    \ count;\n\t}\n\tlong i = 0;\n\tauto signs = tuple(0L, 0L);\n\twhile (num != 0)\
    \ \n\t{\n\t\tif (num < 0) \n\t\t{\n\t\t\tsigns[1]++;\n\t\t\tnum = abs(num);\n\t\
    \t}\n\t\telse \n\t\t{\n\t\t\tsigns[0]++;\n\t\t}\n\t\ti = num % 10;\n\t\tif (i\
    \ % 2 == 0) \n\t\t{\n\t\t\tcount[0]++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tcount[1]++;\n\
    \t\t}\n\t\tnum /= 10;\n\t}\n\tif (signs[1] % 2 != 0) \n\t{\n\t\tcount[1]++;\n\t\
    }\n\treturn count;\n}\nstatic assert(even_odd_count(-12L) == tuple(1L, 1L));\n\
    static assert(even_odd_count(123L) == tuple(1L, 2L));", "{\n    if (num < 0)\n\
    \        num = -num;\n    long even = 0, odd = 0;\n    for (auto dig; num != 0;\
    \ num /= 10)\n    {\n        dig = num % 10;\n        if (dig % 2 == 0)\n    \
    \        even++;\n        else\n            odd++;\n    }\n    return tuple(even,\
    \ odd);\n}\n/*\nGiven an integer. return a tuple that has the number of digits\
    \ and the sum of the digits respectively.", "{\n    if (num < 0) num = -num;\n\
    \    long even = 0, odd = 0;\n    while (num > 0) \n    {\n        if (num % 2\
    \ == 0)\n            even++;\n        else\n            odd++;\n        num /=\
    \ 10;\n    }\n    return tuple(even, odd);\n}", "{\n    int odd = 0;\n    int\
    \ even = 0;\n    if (num < 0)\n        num = -num;\n    \n    while (num != 0)\n\
    \    {\n        int tmp = num % 10;\n        if (tmp % 2 == 0)\n            even++;\n\
    \        else\n            odd++;\n        num /= 10;\n    }\n    return tuple(even,\
    \ odd);\n}\n/*\nGiven an integer num. return whether it can be represented as\
    \ the sum of 2 squares.\n     Example:\n    >>> is_sum_of_squares(5L)\n    false\n\
    \    >>> is_sum_of_squares(20L)\n    true\n    >>> is_sum_of_squares(41L)\n  \
    \  true\n    \n*/", "{\n    import std.math;\n    // init result variables\n \
    \   long odd = 0L;\n    long even = 0L;\n    bool first = true;\n    if (num <\
    \ 0L) \n    {\n        first = false;\n        num = -num;\n    }\n    do \n \
    \   {\n        auto digit = num % 10L;\n        if (first) \n        {\n     \
    \       first = false;\n            // decrement digits because of the case of\
    \ negative numbers\n            --digit;\n        }\n        if (digit & 1L) \n\
    \        {\n            ++odd;\n        }\n        else \n        {\n        \
    \    ++even;\n        }\n        num /= 10L;\n    } while (num);\n    return tuple(even,\
    \ odd);\n}\n \nlong sum_of_digits(long num) \n{\n    long result = 0L;\n    do\
    \ \n    {\n        result += num % 10L;\n        num /= 10L;\n    } while (num);\n\
    \    return result;\n}\n \nlong reverse_num(long num) \n{\n    long reversed =\
    \ 0L;\n    do \n    {\n        reversed = reversed * 10L + num % 10L;\n      \
    \  num /= 10L;\n    } while (num);\n    return reversed;\n}\n \n/*\nGiven an integer.\n\
    returns a tuple of:\n- the number of times the digit 1 appears in the decimal\
    \ representation of the integer.\n- the number of times the digit 0 appears in\
    \ the decimal representation of the integer.\n- the number of times the digit\
    \ 2 appears in the decimal representation of the integer.\n     Example:\n   \
    \ >>> representation_triplet(1210)\n    tuple(1L, 1L, 1L)\n    >>> representation_triplet(20001)\n\
    \    tuple(0L, 3L, 1L)\n    \n*/\nTuple!(long, long, long) representation_triplet(long\
    \ n) \n{\n    long n0 = 0L;\n    long n1 = 0L;\n    long n2 = 0L;\n    do \n \
    \   {\n        auto num = n % 10L;\n        if (num == 0L)", "{\n    long even=0,\
    \ odd=0;\n    if(num < 0)\n        num = -num;\n    \n    while(num > 0)\n   \
    \ {\n        if(num%2 == 0)\n            even++;\n        else\n            odd++;\n\
    \        \n        num /= 10;\n    }\n    \n    return tuple(even, odd);\n}",
  "{\n    Tuple!(long, long) res = tuple(0L, 0L);\n    long numAbs = abs(num);\n \
    \   while (numAbs > 0) {\n        if (numAbs % 2 == 0)\n            res[0]++;\n\
    \        else\n            res[1]++;\n        numAbs /= 10;\n    }\n    return\
    \ res;\n}\nstatic assert(even_odd_count(-12L) == tuple(1L, 1L));\nstatic assert(even_odd_count(123L)\
    \ == tuple(1L, 2L));\nstatic assert(even_odd_count(0L) == tuple(0L, 0L));", "{\n\
    \    Tuple!(long, long) result;\n    result[0] = 0;\n    result[1] = 0;\n    num\
    \ = abs(num);\n    int n;\n    for (n = num; n != 0; n /= 10) \n    {\n      \
    \  if (n % 2 == 0) \n        {\n            result[0] += 1;\n        }\n     \
    \   else \n        {\n            result[1] += 1;\n        }\n    }\n    return\
    \ result;\n}", "{\n\tlong even, odd;\n\t// Fill the even and odd variables using\
    \ a for loop and comparison\n\tif (num < 0)\n\t\tnum = -num;\n\tforeach (digit;\
    \ num.to!string())\n\t{\n\t\tif (long(digit) & 1)\n\t\t\t++odd;\n\t\telse\n\t\t\
    \t++even;\n\t}\n\treturn tuple(even, odd);\n}", "{\n    int evenCount = 0;\n \
    \   int oddCount = 0;\n    int temp;\n    bool neg = false;\n    if (num < 0)\
    \ {\n        neg = true;\n        num = -num;\n    }\n    while (num != 0) {\n\
    \        temp = num % 10;\n        if (temp % 2 == 0)\n            evenCount++;\n\
    \        else\n            oddCount++;\n        num = num / 10;\n    }\n    return\
    \ tuple(evenCount, oddCount);\n}", "{\n    long abs_num = abs(num);\n    long\
    \ even_count = 0L;\n    long odd_count = 0L;\n    for (; abs_num > 0L; abs_num\
    \ /= 10L) \n    {\n        if (abs_num % 2L == 0L) \n        {\n            even_count++;\n\
    \        }\n        else \n        {\n            odd_count++;\n        }\n  \
    \  }\n    return tuple(even_count, odd_count);\n}", "{\n    assert(num >= 0);\n\
    \    Tuple!(long, long) result;\n    result[0] = 0;\n    result[1] = 0;\n    if\
    \ (num == 0)\n    {\n        result[0] = 1;\n        return result;\n    }\n \
    \   else if (num > 0)\n    {\n        while (num > 0)\n        {\n           \
    \ long dig = num % 10;\n            if (dig % 2 == 0)\n            {\n       \
    \         result[0] += 1;\n            }\n            else\n            {\n  \
    \              result[1] += 1;\n            }\n            num /= 10;\n      \
    \  }\n    }\n    else if (num < 0)\n    {\n        num = num * -1;\n        while\
    \ (num > 0)\n        {\n            long dig = num % 10;\n            if (dig\
    \ % 2 == 0)\n            {\n                result[0] += 1;\n            }\n \
    \           else\n            {\n                result[1] += 1;\n           \
    \ }\n            num /= 10;\n        }\n    }\n    return result;\n}", "{\n  \
    \  long odd = 0;\n    long even = 0;\n    while (num != 0)\n    {\n        if\
    \ (num % 2 == 0)\n        {\n            even++;\n        }\n        else\n  \
    \      {\n            odd++;\n        }\n        num /= 10;\n    }\n    return\
    \ tuple(even, odd);\n}", "{\n    long even, odd;\n    even = odd = 0;\n    long\
    \ digit;\n    do\n    {\n\t    digit = num % 10;\n\t    if (digit % 2 == 0)\n\t\
    \t    even += 1;\n\t    else\n\t\t    odd += 1;\n\t    num /= 10;\n    } while\
    \ (num != 0);\n    return tuple(even, odd);\n}", "{\n    long even = 0;\n    long\
    \ odd = 0;\n    long val = abs(num);\n    while (val > 0) \n    {\n        if\
    \ ((val % 10) % 2 == 0) \n        {\n            even += 1;\n        } \n    \
    \    else \n        {\n            odd += 1;\n        }\n        val /= 10;\n\
    \    }\n    return tuple(even, odd);\n}", "{\n    Tuple!(long, long) evenOddCount\
    \ = tuple(0L, 0L);\n    if (num < 0)\n    {\n        num = -num;\n    }\n    while\
    \ (num > 0)\n    {\n        if (num % 2L == 0L)\n        {\n            evenOddCount[0]++;\n\
    \        }\n        else\n        {\n            evenOddCount[1]++;\n        }\n\
    \        num /= 10L;\n    }\n    return evenOddCount;\n}\nstatic assert(even_odd_count(-12L)\
    \ == tuple(1L, 1L));\nstatic assert(even_odd_count(123L) == tuple(1L, 2L));",
  "{\n    bool isOdd = true;\n    long oddCount = 0;\n    long evenCount = 0;\n  \
    \  while (num != 0) \n    {\n        if (num % 2 == 0) \n        {\n         \
    \   evenCount++;\n        }\n        else \n        {\n            oddCount++;\n\
    \        }\n        num /= 10;\n    }\n    return tuple(evenCount, oddCount);\n\
    }", "  { \n    long e=0L, o=0L;\n    auto sign = signbit(num);\n    num = abs(num);\n\
    \    while(num!=0L)\n    {\n        auto d = num%10L;\n        if(d%2==0)\n  \
    \          e++;\n        else\n            o++;\n        num/=10L;\n    }\n  \
    \  return tuple(e,o);\n  }\n  void main() \n  {\n    auto a = even_odd_count(-12L);\n\
    \    writeln(a[0], \" \", a[1]);\n  }\n```", "{\n    long even = 0;\n    long\
    \ odd = 0;\n    long rem;\n    if (num < 0) num = -num;\n    do {\n        rem\
    \ = num % 10;\n        if (rem % 2 == 0) {\n            even++;\n        } else\
    \ {\n            odd++;\n        }\n        num /= 10;\n    } while (num != 0);\n\
    \    return tuple(even, odd);\n}", "{\n    long odd = 0L;\n    long even = 0L;\n\
    \    foreach(i,n; num.abs.digits)\n    {\n        if(n%2==0) \n            even\
    \ += 1L;\n        else \n            odd += 1L;\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    assert(num >= 0L);\n    long even=0L, odd=0L;\n    while\
    \ (num != 0L) {\n        if (num%2L == 0L)\n            even++;\n        else\n\
    \            odd++;\n        num/=10L;\n    }\n    return tuple(even, odd);\n}",
  "{\n    long even_count = 0;\n    long odd_count = 0;\n    foreach(i; 0 .. int.sizeof\
    \ * 8)\n    {\n        if((num >> i) & 1)\n        {\n            odd_count++;\n\
    \        }\n        else\n        {\n            even_count++;\n        }\n  \
    \  }\n    return tuple(even_count, odd_count);\n}\n/*\nGiven an integer. return\
    \ a tuple that has the number of even and odd digits respectively.", "{\n\tint\
    \ even = 0;\n\tint odd = 0;\n\tbool is_negative = num < 0;\n\tif (is_negative)\n\
    \t\tnum = -num;\n\twhile (num > 0)\n\t{\n\t\tif (num % 2 == 0)\n\t\t\teven++;\n\
    \t\telse\n\t\t\todd++;\n\t\tnum /= 10;\n\t}\n\treturn tuple(even, odd);\n}", "{\n\
    \    long even = 0L;\n    long odd = 0L;\n    if (num == 0L)\n    {\n        return\
    \ tuple(even, odd);\n    }\n    else\n    {\n        num = abs(num);\n       \
    \ while (num > 0L)\n        {\n            long cur = num % 10L;\n           \
    \ if (cur % 2L == 0L)\n            {\n                even += 1L;\n          \
    \  }\n            else\n            {\n                odd += 1L;\n          \
    \  }\n            num /= 10L;\n        }\n        return tuple(even, odd);\n \
    \   }\n}", "{\n    long even = 0;\n    long odd = 0;\n    if (num < 0)\n     \
    \   num = -num;\n    while (num != 0) \n    {\n        if (num % 2 == 0)\n   \
    \         even += 1;\n        else\n            odd += 1;\n        num /= 10;\n\
    \    }\n    return tuple(even, odd);\n}\nstatic assert(even_odd_count(-12L) ==\
    \ tuple(1L, 1L));\nstatic assert(even_odd_count(123L) == tuple(1L, 2L));", " \
    \   if (num > 0) \n{\n    long even = 0;\n    long odd = 0;\n    foreach (digit;\
    \ \"\".by_length(unchecked_math.abs(num)).representation[0..$ - 1])\n    {\n \
    \       if (digit % 2)\n            odd++;\n        else\n            even++;\n\
    \    }\n    return tuple(even, odd);\n}", "{\n\tlong evens = 0;\n\tlong odds =\
    \ 0;\n\twhile (num != 0)\n\t{\n\t\tlong remainder = num % 10;\n\t\tif (remainder\
    \ % 2 == 0)\n\t\t{\n\t\t\tevens += 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\todds += 1;\n\
    \t\t}\n\t\tnum /= 10;\n\t}\n\treturn tuple(evens, odds);\n}", "{\n    long even\
    \ = 0;\n    long odd = 0;\n    foreach(n; num.abs)\n    {\n        if (n % 2)\n\
    \            odd++;\n        else\n            even++;\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    auto isOdd = (num % 2 != 0);\n    if (num == 0)\n    {\n\
    \        return tuple(0L, 0L);\n    }\n    else\n    {\n        auto t = even_odd_count(num\
    \ / 10);\n        return tuple(isOdd ? t[0] : t[0] + 1, isOdd ? t[1] + 1 : t[1]);\n\
    \    }\n}\nstatic assert(even_odd_count(-12L) == tuple(1L, 1L));\nstatic assert(even_odd_count(123L)\
    \ == tuple(1L, 2L));\n \n/*\nGiven a string. return the longest substring that\
    \ has the same number of vowels and consonants.\nIf there are several substrings\
    \ that have the same number of vowels and consonants. return the one that appears\
    \ first.", "{\n    long evenCount = 0;\n    long oddCount = 0;\n    long curr;\n\
    \    long remainder;\n    while (num > 0)\n    {\n        remainder = num % 10;\n\
    \        if (remainder % 2 == 0)\n        {\n            evenCount++;\n      \
    \  }\n        else\n        {\n            oddCount++;\n        }\n        num\
    \ = num / 10;\n    }\n    return tuple(evenCount, oddCount);\n}", "{\n\tassert(num\
    \ > 0L);\n\tauto evenCount = 0L;\n\tauto oddCount = 0L;\n\t\n\twhile(num != 0L)\
    \ \n\t{\n\t\tif(num % 2L == 0L)\n\t\t\tevenCount++;\n\t\telse\n\t\t\toddCount++;\n\
    \t\tnum /= 10L;\n\t}\n\treturn tuple(evenCount, oddCount);\n}", "{\n    long e\
    \ = 0L;\n    long o = 0L;\n    foreach(d; 0 .. num.countDigits) \n    {\n    \
    \    auto digit = num.getDigit!10(d);\n        if(isEven(digit)) e++;\n      \
    \  else o++;\n    }\n    return tuple(e, o);\n}\n/*\nGiven an integer N and a\
    \ long L, return an array that has N integers that are the first N odd digits\
    \ of the long L.", "in \n{\n\tassert(num <= long.max);\n\tassert(num >= long.min);\n\
    }\nout(even, odd)\n{\n\tassert(even + odd == num.digits);\n}\nbody\n{\n\tlong\
    \ even = 0L;\n\tlong odd = 0L;\n\tlong temp = num;\n\tlong div = 10L;\n\twhile(temp\
    \ > 0L)\n\t{\n\t\tif(temp % div % 2L == 0L)\n\t\t{\n\t\t\teven++;\n\t\t}\n\t\t\
    else\n\t\t{\n\t\t\todd++;\n\t\t}\n\t\ttemp /= div;\n\t}\n\treturn tuple(even,\
    \ odd);\n}", "{\n    int even = 0;\n    int odd = 0;\n    if (num < 0)\n     \
    \   num = -num;\n    while (num > 0)\n    {\n        if (num % 2 == 0)\n     \
    \       even++;\n        else\n            odd++;\n        num /= 10;\n    }\n\
    \    return tuple(even, odd);\n}\n/*\n Given a string of comma separated numbers.\
    \ return the sum of it's elements", "{\n  long oddNum = 0L;\n  long evenNum =\
    \ 0L;\n  long absNum = abs(num);\n  while (absNum) \n  {\n    if (absNum % 2L)\
    \ \n    {\n      oddNum += 1L;\n    }\n    else \n    {\n      evenNum += 1L;\n\
    \    }\n    absNum /= 10L;\n  }\n  return tuple(evenNum, oddNum);\n}", "{\n  \
    \  // a tuple that has the number of even and odd digits respectively.\n    auto\
    \ t = tuple(0L, 0L);\n    auto is_even = true;\n    while (num != 0) \n    {\n\
    \        if (is_even) \n        {\n            t[0] += 1;\n        }\n       \
    \ else \n        {\n            t[1] += 1;\n        }\n        is_even = !is_even;\n\
    \        num /= 10;\n    }\n    return t;\n}\n/*\nGiven an integer. return a tuple\
    \ that has the number of even and odd digits respectively.", "{\n    long evens\
    \ = 0L;\n    long odds = 0L;\n    while (num != 0L) \n    {\n        if (abs(num\
    \ % 10L) % 2L == 0L)\n            evens++;\n        else\n            odds++;\n\
    \        num /= 10L;\n    }\n    return tuple(evens, odds);\n}", "{\n    static\
    \ long abs(long val) \n    {\n        if (val < 0) \n        {\n            return\
    \ -val;\n        }\n        return val;\n    }\n    long even, odd;\n    even\
    \ = odd = 0;\n    long n = abs(num);\n    foreach (digit; n.to!string) \n    {\n\
    \        if (digit.to!long % 2 == 0) \n        {\n            even += 1;\n   \
    \     }\n        else \n        {\n            odd += 1;\n        }\n    }\n \
    \   return tuple(even, odd);\n}", "{\n    long even = 0;\n    long odd = 0;\n\
    \    long rem = 0;\n    while (num != 0)\n    {\n        rem = num % 10;\n   \
    \     if (rem % 2 == 0) \n        {\n            even++;\n        }\n        else\
    \ \n        {\n            odd++;\n        }\n        num /= 10;\n    }\n    return\
    \ tuple(even, odd);\n}", "{\n    long even = 0;\n    long odd = 0;\n    //enter\
    \ code here\n    long digit = 0;\n    while (num != 0) {\n        digit = num\
    \ % 10;\n        num /= 10;\n        if (digit % 2 == 0) even++;\n        else\
    \ odd++;\n    }\n    return tuple(even, odd);\n}", "{\n    long even_count = 0;\n\
    \    long odd_count = 0;\n    while (num != 0) \n    {\n        auto digit = num\
    \ % 10;\n        if (digit % 2 == 0)\n            even_count++;\n        else\n\
    \            odd_count++;\n        num /= 10;\n    }\n    return tuple(even_count,\
    \ odd_count);\n}", "{\n\tlong odd_count = 0;\n\tlong even_count = 0;\n\tauto abs_num\
    \ = abs(num);\n\twhile (abs_num > 0) \n\t{\n\t\tif (abs_num % 2 == 0) \n\t\t{\n\
    \t\t\teven_count++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\todd_count++;\n\t\t}\n\t\t\
    abs_num /= 10;\n\t}\n\treturn tuple(even_count, odd_count);\n}", "{\n    long\
    \ evenCount = 0;\n    long oddCount = 0;\n    while (num > 0)\n    {\n       \
    \ if (num % 2 == 0)\n        {\n            evenCount++;\n        }\n        else\n\
    \        {\n            oddCount++;\n        }\n        num /= 10;\n    }\n  \
    \  return tuple(evenCount, oddCount);\n}", "{\n    \n    \n    \n    \n    long\
    \ evens = 0L;\n    long odds = 0L;\n    while (num != 0L)\n    {\n        if (num\
    \ % 2L == 0L)\n        {\n            evens += 1L;\n        }\n        else\n\
    \        {\n            odds += 1L;\n        }\n        num /= 10L;\n    }\n \
    \   return tuple(evens, odds);\n}", "{\n    long evenCount = 0;\n    long oddCount\
    \ = 0;\n    while (num != 0) \n    {\n        if (abs(num % 10) % 2 == 0)\n  \
    \          evenCount++;\n        else\n            oddCount++;\n        num /=\
    \ 10;\n    }\n    return tuple(evenCount, oddCount);\n}\nstatic assert(even_odd_count(-12345L)\
    \ == tuple(3L, 2L));", "{\n    long evenCount = 0L;\n    long oddCount = 0L;\n\
    \    if (num < 0L)\n    {\n        num = abs(num);\n    }\n    while (num > 0L)\n\
    \    {\n        auto digit = num % 10L;\n        if (digit % 2L == 0L)\n     \
    \   {\n            evenCount++;\n        }\n        else\n        {\n        \
    \    oddCount++;\n        }\n        num /= 10L;\n    }\n    return tuple(evenCount,\
    \ oddCount);\n}", "{\n    auto evens = 0L;\n    auto odds = 0L;\n    do \n   \
    \ {\n        auto digit = num % 10;\n        if (digit % 2 == 0) \n        {\n\
    \            evens++;\n        }\n        else \n        {\n            odds++;\n\
    \        }\n        num /= 10;\n    } while (num != 0);\n    return tuple(evens,\
    \ odds);\n}\n ", "{\n    Tuple!(long, long) t(0L, 0L);\n    // to prevent looping\
    \ on negative numbers\n    num = abs(num);\n    while (num != 0) \n    {\n   \
    \     if ((num % 10) % 2 == 0) \n        {\n            t[0]++;\n        }\n \
    \       else \n        {\n            t[1]++;\n        }\n        num /= 10;\n\
    \    }\n    return t;\n}", "{\n    // Count digits.\n    long ndigits = num <\
    \ 0 ? int.max(1, cast(long)log10(-num) + 1) : int.max(1, cast(long)log10(num)\
    \ + 1);\n    auto digits = new long[];", "{\n    import std.algorithm.iteration;\n\
    \    import std.algorithm.mutation;\n    import std.string;\n    import std.conv;\n\
    \    import std.range;\n    import std.typecons;\n    auto res = Tuple!(long,\
    \ long)(0L, 0L);\n    auto nums = num.to!string;\n    foreach(i; 0..nums.length)\n\
    \    {\n        auto n = nums[i..i+1].to!long;\n        if(isEven(n))\n      \
    \  {\n            res[0] += 1L;\n        }\n        else\n        {\n        \
    \    res[1] += 1L;\n        }\n    }\n    return res;\n}", "{\n    auto num_abs\
    \ = abs(num);\n    auto even_count = 0L;\n    auto odd_count = 0L;\n    while\
    \ (num_abs != 0)\n    {\n        auto curr_digit = num_abs % 10;\n        if (curr_digit\
    \ % 2 == 0)\n        {\n            even_count += 1;\n        }\n        else\n\
    \        {\n            odd_count += 1;\n        }\n        num_abs /= 10;\n \
    \   }\n    return tuple(even_count, odd_count);\n}", "{\n    long a, b;\n    a\
    \ = b = 0;\n    while (num != 0) \n    {\n        if (num % 2 == 0) \n       \
    \ {\n            a++;\n        } \n        else \n        {\n            b++;\n\
    \        }\n        num /= 10;\n    }\n    return tuple(a, b);\n}", "{\n    Tuple!(long,\
    \ long) result = tuple(0L, 0L);\n    foreach(i; 0 .. abs(num).to!string.length)\n\
    \    {\n        auto v = num.to!string[i];\n        if(v.isEven)\n           \
    \ result[0]++;\n        else\n            result[1]++;\n    }\n    return result;\n\
    }\n ", "{\n    int odd = 0;\n    int even = 0;\n    foreach(i; 0 .. abs(num).to!long.digits)\n\
    \    {\n        int digit = num.digit(i);\n        if(digit % 2 == 0)\n      \
    \  {\n            even += 1;\n        }\n        else\n        {\n           \
    \ odd += 1;\n        }\n    }\n    return tuple(even, odd);\n}\n/*\n Given a list\
    \ of integers. Return a new list with the same integers but in a reversed order.",
  "{\n  auto res = tuple(0L, 0L);\n  num = abs(num);\n  do {\n    if(num % 2 == 0)\
    \ res[0]++;\n    else res[1]++;\n    num /= 10;\n  } while(num > 0);\n  return\
    \ res;\n}", "{\n\tlong evens = 0L;\n\tlong odds = 0L;\n\tnum = abs(num);\n\twhile\
    \ (num > 0L) \n\t{\n\t\tauto digit = num % 10L;\n\t\tif (digit % 2L == 0L)\n\t\
    \t\tevens++;\n\t\telse\n\t\t\todds++;\n\t\tnum /= 10L;\n\t}\n\treturn tuple(evens,\
    \ odds);\n}", "{\n    int odd = 0;\n    int even = 0;\n    num = abs(num);\n \
    \   while (num > 0) {\n        if (num % 2 == 0)\n            even++;\n      \
    \  else\n            odd++;\n        num /= 10;\n    }\n    return tuple(even,\
    \ odd);\n}", "in {\n    assert(num >= 0);\n}\nbody {\n    auto res = tuple(0L,\
    \ 0L);\n    while (num > 0) {\n        auto digit = num % 10;\n        if (digit\
    \ % 2 == 0)\n            res[0]++;\n        else\n            res[1]++;\n    \
    \    num /= 10;\n    }\n    return res;\n}", "{\n    long res = 0L;\n    long\
    \ odd = 0L;\n    long rem = 0L;\n    while (num > 0L) {\n        rem = num % 10L;\n\
    \        if (rem % 2L == 0L) {\n            res++;\n        } else {\n       \
    \     odd++;\n        }\n        num /= 10L;\n    }\n    return tuple(res, odd);\n\
    }", "{\n    long evenDigits = 0L;\n    long oddDigits = 0L;\n    long digit;\n\
    \    while (num != 0L) \n    {\n        digit = num % 10L;\n        num /= 10L;\n\
    \        (digit % 2L == 0L) ? ++evenDigits : ++oddDigits;\n    }\n    return tuple(evenDigits,\
    \ oddDigits);\n}", "{\n    long evenCount = 0;\n    long oddCount = 0;\n    foreach(\
    \ digit; to!string(num)) \n    {\n        int digitNo = to!int(digit);\n     \
    \   if(digitNo % 2 == 0) \n        {\n            evenCount++;\n        }\n  \
    \      else \n        {\n            oddCount++;\n        }\n    }\n    return\
    \ tuple(evenCount, oddCount);\n}\n// long even_odd_count(long num) {\n//   long\
    \ evenCount = 0;\n//   long oddCount = 0;\n//   foreach(digit; to!string(num))\
    \ {\n//     int digitNo = to!int(digit);\n//     if(digitNo % 2 == 0) {\n//  \
    \     evenCount++;\n//     } else {\n//       oddCount++;\n//     }\n//   }\n\
    //   return tuple(evenCount, oddCount);\n// }", "{\n\tlong mod;\n\tlong even =\
    \ 0;\n\tlong odd = 0;\n\t\n\tif (num == 0)\n\t{\n\t\teven = 1;\n\t\todd = 0;\n\
    \t}\n\telse\n\t{\n\t\twhile (num != 0)\n\t\t{\n\t\t\tmod = num % 10;\n\t\t\tif\
    \ (mod % 2 == 0)\n\t\t\t{\n\t\t\t\teven++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\
    \t\todd++;\n\t\t\t}\n\t\t\tnum = num / 10;\n\t\t}\n\t}\n\treturn tuple(even, odd);\n\
    }", "{\n    Tuple!(long, long) counter = tuple(0L, 0L);\n    ulong abs_num = abs(num);\n\
    \    while (abs_num != 0)\n    {\n        if (abs_num % 2 == 0)\n            counter[0]++;\n\
    \        else\n            counter[1]++;\n        abs_num /= 10;\n    }\n    return\
    \ counter;\n}\n/*\nGiven a string and a character. return the character's index\
    \ in the string. If it doesn't exist, return -1.", "{\n\tlong even, odd;\n\teven\
    \ = odd = 0;\n\tif (num == 0) return tuple(even, odd);\n\twhile (num != 0)\n\t\
    {\n\t\tlong rem = num % 10;\n\t\tif (rem % 2 == 0)\n\t\t\teven++;\n\t\telse\n\t\
    \t\todd++;\n\t\tnum /= 10;\n\t}\n\treturn tuple(even, odd);\n}\n//assignment 5\n\
    /*\nImplement a function that performs integer exponentiation operation. \nUse\
    \ the following algorithm: Divide the exponent by 2. \nEach time, square the base\
    \ and if the exponent is even, compute the next base and exponent pair and repeat,\
    \ \nif the exponent is odd, we must also include the extra base that was squared\
    \ in the previous step. \nThe result will be the product of all the bases that\
    \ were squared, including the last base that was squared before the exponent became\
    \ zero.\nExample:", "{\n    long even_count = 0;\n    long odd_count = 0;\n  \
    \  // default value of long = 0 (on calculation)\n    // so we don't need to initialize\
    \ like so:\n    // even_count = 0;\n    // odd_count = 0;\n    // always initiliaze\
    \ before use\n    num = abs(num);\n    for (; num > 0; num /= 10) \n    {\n  \
    \      auto digit = num % 10;\n        if (digit % 2 == 0)\n            even_count++;\n\
    \        else\n            odd_count++;\n    }\n    return tuple(even_count, odd_count);\n\
    }\n ", "{\n    long even = 0;\n    long odd = 0;\n    long len = 0;\n    while\
    \ (num != 0)\n    {\n        len = num % 10;\n        if (len % 2 == 0)\n    \
    \    {\n            even++;\n        }\n        else\n        {\n            odd++;\n\
    \        }\n        num /= 10;\n    }\n    return tuple(even, odd);\n}", "{\n\
    \    // your code goes here\n    long even = 0;\n    long odd = 0;\n    while(num\
    \ != 0)\n    {\n        if((num % 10) % 2 == 0) even++;\n        else odd++;\n\
    \        num /= 10;\n    }\n    return tuple(even, odd);\n}", "{\n    /*\n   \
    \ // Solution 1:\n    long even = 0;\n    long odd = 0;\n    foreach(digit; num.toString())\n\
    \    {\n        if (digit.to!long % 2 == 0)\n            even++;\n        else\n\
    \            odd++;\n    }\n    return tuple(even, odd);\n    */\n    \n    //\
    \ Solution 2:\n    long even = 0;\n    long odd = 0;\n    while (num != 0)\n \
    \   {\n        if (num % 2 == 0)\n            even++;\n        else\n        \
    \    odd++;\n        num /= 10;\n    }\n    return tuple(even, odd);\n}\n ", "{\n\
    \tlong even = 0L;\n\tlong odd = 0L;\n\tauto abs_num = abs(num);\n\tforeach(i;0..floor(log10(abs_num))+1)\n\
    \t{\n\t\tlong digit = abs_num % 10L;\n\t\tif(digit % 2L == 0L)\n\t\t{\n\t\t\t\
    even++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\todd++;\n\t\t}\n\t\tabs_num /= 10L;\n\t\
    }\n\treturn tuple(even, odd);\n}", "{\n    auto even = 0L;\n    auto odd = 0L;\n\
    \    auto n = abs(num);\n    while (n > 0) \n    {\n        auto m = n % 10;\n\
    \        if (m % 2 == 0) \n        {\n            even++;\n        } \n      \
    \  else \n        {\n            odd++;\n        }\n        n /= 10;\n    }\n\
    \    return tuple(even, odd);\n}\n \n ", "{\n    auto evenCount = 0L;\n    auto\
    \ oddCount = 0L;\n    if (num < 0)\n    {\n        num = -num;\n    }\n    while\
    \ (num > 0)\n    {\n        if (num % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    \
    \    num /= 10;\n    }\n    return tuple(evenCount, oddCount);\n}\n \n/*\nGiven\
    \ a tuple of integers. Returns the sum of the elements that are multiples of n.",
  "{\n    Tuple!(long, long) res;\n    if (num == 0) \n    {\n        res[0] = 1;\n\
    \        res[1] = 0;\n        return res;\n    }\n    int even = 0;\n    int odd\
    \ = 0;\n    foreach (val; num.abs.digits) \n    {\n        if (val % 2 == 0)\n\
    \            even++;\n        else\n            odd++;\n    }\n    res[0] = even;\n\
    \    res[1] = odd;\n    return res;\n}", "{\n    long even = 0;\n    long odd\
    \ = 0;\n    while (num > 0)\n    {\n        auto rem = num % 10;\n        if (rem\
    \ % 2 == 0)\n            even++;\n        else\n            odd++;\n        num\
    \ /= 10;\n    }\n    return tuple(even, odd);\n}", "{\n    auto s = num < 0L ?\
    \ -num : num;\n    long evens = 0L;\n    long odds = 0L;\n    while (s > 0L) \n\
    \    {\n        if (s % 2L == 0L)\n            evens++;\n        else\n      \
    \      odds++;\n        s /= 10L;\n    }\n    return tuple(evens, odds);\n}\n\
    /*", "{\n    auto result = tuple(0L, 0L);\n    if (num < 0) \n    {\n        num\
    \ = -num;\n    }\n    while (num > 0) \n    {\n        if (num % 2 == 0) \n  \
    \      {\n            result[0]++;\n        }\n        else \n        {\n    \
    \        result[1]++;\n        }\n        num /= 10;\n    }\n    return result;\n\
    }", "{\n    long even, odd;\n    even = odd = 0;\n    foreach(digit; num.to!string)\
    \ \n    {\n        long d = digit.to!long;\n        d % 2 ? odd += 1 : even +=\
    \ 1;\n    }\n    return tuple(even, odd);\n}", "{\n     long even = 0;\n     long\
    \ odd = 0;\n     while (num != 0) \n     {\n         auto digit = abs(num % 10);\n\
    \         if (digit % 2 == 0) \n         {\n             even += 1;\n        \
    \ } \n         else \n         {\n             odd += 1;\n         }\n       \
    \  num /= 10;\n     }\n    return tuple(even, odd);\n}", "{\n\tauto evenCount\
    \ = 0L;\n\tauto oddCount = 0L;\n\tif (num < 0) num = -num;\n\t\n\twhile (num !=\
    \ 0)\n\t{\n\t\tif (num % 2 == 0) evenCount++;\n\t\telse oddCount++;\n\t\tnum /=\
    \ 10;\n\t}\n\treturn tuple(evenCount, oddCount);\n}\n/*\nhttps://www.dlang.org/phobos/std_typecons.html#.Tuple\n\
    */", "{\n    import std.algorithm;", "{\n    Tuple!(long, long) result;\n    if\
    \ (num < 0) num = -num;\n    while (num > 0) \n    {\n        if ((num % 10) %\
    \ 2 == 0) \n        {\n            result[0]++;\n        } \n        else \n \
    \       {\n            result[1]++;\n        }\n        num /= 10;\n    }\n  \
    \  return result;\n}", "{\n    Tuple!(long, long) res(0L, 0L);\n    if (num <\
    \ 0L) \n    {\n        num = -num;\n    }\n    while (num != 0L) \n    {\n   \
    \     if (num % 2L == 0L) \n        {\n            res[0] += 1L;\n        }\n\
    \        else \n        {\n            res[1] += 1L;\n        }\n        num /=\
    \ 10L;\n    }\n    return res;\n}\n/*\nGiven an integer. return a tuple that has\
    \ the sum of even and odd digits respectively.", "{\n    long num_len = num.length;\n\
    \    long even = 0;\n    long odd = 0;\n    while (num != 0) \n    {\n       \
    \ if ((num % 10) % 2 == 0) \n        {\n            even++;\n        }\n     \
    \   else \n        {\n            odd++;\n        }\n        num /= 10;\n    }\n\
    \    return tuple(even, odd);\n}", "{\n    long even = 0;\n    long odd = 0;\n\
    \    long absNum = abs(num);\n    while (absNum > 0)\n    {\n        if (absNum\
    \ % 2 == 0)\n        {\n            even++;\n        }\n        else\n       \
    \ {\n            odd++;\n        }\n        absNum /= 10;\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    long even = 0L;\n    long odd = 0L;\n    while (num != 0L)\
    \ \n    {\n        long remain = num % 10L;\n        if (remain & 1L) odd++;\n\
    \        else even++;\n        num /= 10L;\n    }\n    return tuple(even, odd);\n\
    }\n/*\nWrite a function that takes a list of numbers and gives the total as a\
    \ sum.", "{\n    return std.typecons.Tuple!(long, long)(num.length, num.length);\n\
    }", "{\n    long even;\n    long odd;\n    even = 0;\n    odd = 0;\n    if (num\
    \ < 0) \n    {\n        num = -num;\n    }\n    while (num > 0) \n    {\n    \
    \    long digit;\n        digit = num % 10;\n        if (digit % 2 == 0) \n  \
    \      {\n            even = even + 1;\n        }\n        else \n        {\n\
    \            odd = odd + 1;\n        }\n        num = num / 10;\n    }\n    return\
    \ tuple(even, odd);\n}", "{\n    auto num_str = to!string(num);\n    long odd_count\
    \ = 0;\n    long even_count = 0;\n    foreach(digit; num_str)\n    {\n       \
    \ if(digit.to!long() % 2 == 0)\n        {\n            even_count++;\n       \
    \ }\n        else\n        {\n            odd_count++;\n        }\n    }\n   \
    \ return tuple(even_count, odd_count);\n}", "{\n    long evenCount = 0L;\n   \
    \ long oddCount = 0L;\n    long digit;\n    while (num != 0L) {\n        digit\
    \ = num % 10L;\n        if (digit % 2L == 0L)\n            evenCount++;\n    \
    \    else\n            oddCount++;\n        num /= 10L;\n    }\n    return tuple(evenCount,\
    \ oddCount);\n}", "{\n\tlong even_count = 0L;\n\tlong odd_count = 0L;\n\t\n\t\
    // evens\n\tforeach(dig; 0L .. 10L)\n\t{\n\t\tif (dig % 2L == 0L)\n\t\t{\n\t\t\
    \teven_count += count(num, dig);\n\t\t}\n\t}\n\t\n\t// odds\n\tforeach(dig; 0L\
    \ .. 10L)\n\t{\n\t\tif (dig % 2L == 1L)\n\t\t{\n\t\t\todd_count += count(num,\
    \ dig);\n\t\t}\n\t}\n\t\n\treturn tuple(even_count, odd_count);\n}", "{\n\tlong\
    \ even_cnt = 0L;\n\tlong odd_cnt = 0L;\n\tif (num > 0L) \n\t{\n\t\tlong num_cop\
    \ = num;\n\t\twhile (num_cop > 0L) \n\t\t{\n\t\t\tauto digit = num_cop % 10L;\n\
    \t\t\tif (digit % 2L == 0L) \n\t\t\t{\n\t\t\t\teven_cnt++;\n\t\t\t} \n\t\t\telse\
    \ \n\t\t\t{\n\t\t\t\todd_cnt++;\n\t\t\t}\n\t\t\tnum_cop /= 10L;\n\t\t}\n\t} \n\
    \telse if (num < 0L) \n\t{\n\t\tlong num_cop = abs(num);\n\t\twhile (num_cop >\
    \ 0L) \n\t\t{\n\t\t\tauto digit = num_cop % 10L;\n\t\t\tif (digit % 2L == 0L)\
    \ \n\t\t\t{\n\t\t\t\teven_cnt++;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\todd_cnt++;\n\
    \t\t\t}\n\t\t\tnum_cop /= 10L;\n\t\t}\n\t} \n\telse \n\t{\n\t\treturn tuple(even_cnt,\
    \ odd_cnt);\n\t}\n\treturn tuple(even_cnt, odd_cnt);\n}", "{\n    long even =\
    \ 0;\n    long odd = 0;\n    auto negative = num < 0;\n    num = abs(num);\n \
    \   while (num > 0) \n    {\n        if (num % 2 == 0) \n        {\n         \
    \   even++;\n        }\n        else \n        {\n            odd++;\n       \
    \ }\n        num /= 10;\n    }\n    return tuple(even, odd);\n}", "{\n    long\
    \ even = 0L;\n    long odd = 0L;\n    num = abs(num);\n    while (num != 0L) \n\
    \    {\n        num /= 10L;\n        if (num % 2L == 0L) \n        {\n       \
    \     even++;\n        }\n        else \n        {\n            odd++;\n     \
    \   }\n    }\n    return tuple(even, odd);\n}", "{\n    long evenCount = 0;\n\
    \    long oddCount = 0;\n    bool isEven = isIntegerEven(num);\n    bool isNegative\
    \ = num < 0;\n    num = abs(num);\n    while (num > 0)\n    {\n        if (isEven)\n\
    \        {\n            evenCount++;\n        }\n        else\n        {\n   \
    \         oddCount++;\n        }\n        num /= 10;\n        isEven = !isEven;\n\
    \    }\n    if (isNegative)\n    {\n        oddCount++;\n    }\n    return tuple(evenCount,\
    \ oddCount);\n}", "{\n    long even = 0L;\n    long odd = 0L;\n    long digits\
    \ = 0L;\n    long temp = 0L;\n    if (num < 0L)\n    {\n        num = abs(num);\n\
    \    }\n    temp = num;\n    do \n    {\n        digits++;\n        temp /= 10L;\n\
    \    } while (temp != 0L);\n    for (int i = 0; i < digits; i++)\n    {\n    \
    \    long last = num % 10L;\n        if (last % 2L == 0L)\n        {\n       \
    \     even++;\n        }\n        else\n        {\n            odd++;\n      \
    \  }\n        num /= 10L;\n    }\n    return tuple(even, odd);\n}", "{\n\t \n\
    \    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while (num)\n\
    \    {\n        if (num % 2 == 0)\n            even++;\n        else\n       \
    \     odd++;\n        num /= 10;\n    }\n    return tuple(even, odd);\n}\n ",
  "{\n    /*\n    \n     Algorithm:\n     \n     1. Check if the number is negative\
    \ and if so, convert it to positive.\n     2. For each digit in the number:\n\
    \         1. Convert digit to string.\n         2. Check if digit is even or odd.\n\
    \         3. Increment even or odd count accordingly.\n     \n    */\n    long\
    \ evenCount = 0;\n    long oddCount = 0;\n    long currentDigit;\n    if (num\
    \ < 0) \n    {\n        num = -num;\n    }\n    while (num > 0) \n    {\n    \
    \    currentDigit = num % 10;\n        if (currentDigit % 2 == 0) \n        {\n\
    \            evenCount++;\n        }\n        else \n        {\n            oddCount++;\n\
    \        }\n        num /= 10;\n    }\n    return tuple(evenCount, oddCount);\n\
    }", "{\n    long odd = 0;\n    long even = 0;\n    do\n    {\n        auto digit\
    \ = num % 10;\n        if(digit % 2)\n            odd++;\n        else\n     \
    \       even++;\n        num /= 10;\n    }\n    while(num != 0);\n    return tuple(even,\
    \ odd);\n}", "{\n    long even = 0;\n    long odd = 0;\n    foreach(immutable\
    \ d; num.to!string)\n    {\n        if(d.to!long % 2 == 0)\n            even +=\
    \ 1;\n        else\n            odd += 1;\n    }\n    return tuple(even, odd);\n\
    }", "{\n    long evenCount = 0L;\n    long oddCount = 0L;\n    long absNum = abs(num);\n\
    \    while (absNum != 0L) {\n        long digit = absNum % 10L;\n        if (digit\
    \ % 2L == 0L) {\n            evenCount++;\n        } else {\n            oddCount++;\n\
    \        }\n        absNum /= 10L;\n    }\n    return tuple(evenCount, oddCount);\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
