name: HumanEval_155_even_odd_count
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nGiven an integer. return a tuple\
  \ that has the number of even and odd digits respectively.\n\n     Example:\n  \
  \  >>> even_odd_count(-12L)\n    tuple(1L, 1L)\n    >>> even_odd_count(123L)\n \
  \   tuple(1L, 2L)\n    \n*/\nTuple!(long, long) even_odd_count(long num) \n"
tests: "unittest\n{\n    alias candidate = even_odd_count;\n\n    assert(candidate(7L)\
  \ == tuple(0L, 1L));\n    assert(candidate(-78L) == tuple(1L, 1L));\n    assert(candidate(3452L)\
  \ == tuple(2L, 2L));\n    assert(candidate(346211L) == tuple(3L, 3L));\n    assert(candidate(-345821L)\
  \ == tuple(3L, 3L));\n    assert(candidate(-2L) == tuple(1L, 0L));\n    assert(candidate(-45347L)\
  \ == tuple(2L, 3L));\n    assert(candidate(0L) == tuple(1L, 0L));\n}\nvoid main(){}"
completions: ["{\n    Tuple!(long, long) result;\n    if (num == 0)\n    {\n     \
    \   result[0] = 1;\n        result[1] = 0;\n        return result;\n    }\n  \
    \  long even_num = 0;\n    long odd_num = 0;\n    long abs_num = abs(num);\n \
    \   while (abs_num > 0)\n    {\n        long div = abs_num % 10;\n        if (div\
    \ % 2 == 0)\n        {\n            even_num++;\n        }\n        else\n   \
    \     {\n            odd_num++;\n        }\n        abs_num /= 10;\n    }\n  \
    \  result[0] = even_num;\n    result[1] = odd_num;\n    return result;\n}", "{\n\
    \tlong even = 0L;\n\tlong odd = 0L;\n\tbool isNegative = false;\n\tif (num < 0L)\
    \ \n\t{\n\t\tisNegative = true;\n\t\tnum = -num;\n\t}\n\twhile (num > 0L) \n\t\
    {\n\t\tif (num & 1L)\n\t\t\todd++;\n\t\telse\n\t\t\teven++;\n\t\tnum >>= 1L;\n\
    \t}\n\tif (isNegative)\n\t\todd++;\n\treturn tuple(even, odd);\n}", "{\n\tlong\
    \ even_count = 0;\n\tlong odd_count = 0;\n\tlong n = num;\n\tif (n < 0) n = -n;",
  "{\n    import std.algorithm;\n    import std.array;\n    import std.conv;\n   \
    \ import std.range;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typetuple;\n    long[] digits = to!(long[])(to!string(num).byText.filter!q{a\
    \ => a >= '0' && a <= '9'}.map!q{a => to!long(a)}).array;\n    auto counts = reduce!q{a,\
    \ b => a[b%2]++}.counts(digits.length);\n    return tuple(counts[0], counts[1]);\n\
    }", "{\n    long num_even = 0;\n    long num_odd = 0;\n    while (num != 0)\n\
    \    {\n        long digit = num % 10;\n        if (digit % 2 == 0)\n        {\n\
    \            num_even++;\n        }\n        else\n        {\n            num_odd++;\n\
    \        }\n        num /= 10;\n    }\n    return tuple(num_even, num_odd);\n}",
  "{\n  long even = 0;\n  long odd = 0;\n  while (num != 0)\n  {\n    if (modulo(num,\
    \ 10) % 2 == 0)\n    {\n      even++;\n    }\n    else\n    {\n      odd++;\n\
    \    }\n    num /= 10;\n  }\n  return tuple(even, odd);\n}", "{\n    long evenCount\
    \ = 0L;\n    long oddCount = 0L;\n    long iterNum = abs(num);\n    for (; iterNum\
    \ != 0L;) \n    {\n        iterNum = iterNum / 10L;\n        if (evenCount ==\
    \ 0L) \n        {\n            evenCount = iterNum;\n        }\n        else \n\
    \        {\n            oddCount = iterNum;\n        }\n    }\n    return tuple(evenCount,\
    \ oddCount);\n}\n/*", "{\n    return tuple(num / 10 + (num % 2 == 0 ? 1 : 0),\
    \ num / 10 + (num % 2 == 1 ? 1 : 0));\n}", "    long abs_num = abs(num);\n   \
    \ long even = 0;\n    long odd = 0;\n    do \n    {\n        long digit = abs_num\
    \ % 10;\n        if (digit % 2 == 0) \n            even++;\n        else \n  \
    \          odd++;\n        abs_num /= 10;\n    } while (abs_num > 0);\n    return\
    \ tuple(even, odd);\n}", "{\n    long even = 0L;\n    long odd = 0L;\n    long\
    \ absNum = abs(num);\n    long temp;\n    for (temp = absNum; temp != 0L; temp\
    \ /= 10L) \n    {\n        long digit = temp % 10L;\n        if (digit % 2L ==\
    \ 0L)\n            even++;\n        else\n            odd++;\n    }\n    return\
    \ tuple(even, odd);\n}", "{\n    long count_even = 0L;\n    long count_odd = 0L;\n\
    \    bool is_negative = false;\n    if (num < 0L) {\n        is_negative = true;\n\
    \        num = -num;\n    }\n    long rem = 0L;\n    long rev = 0L;\n    long\
    \ i = 0L;\n    while (num != 0L) {\n        rem = num % 10L;\n        rev = rev\
    \ * 10L + rem;\n        num /= 10L;\n    }\n    while (rev != 0L) {\n        rem\
    \ = rev % 10L;\n        if (rem % 2L == 0L) {\n            count_even++;\n   \
    \     }\n        else {\n            count_odd++;\n        }\n        rev /= 10L;\n\
    \    }\n    if (is_negative) {\n        count_odd++;\n    }\n    return tuple(count_even,\
    \ count_odd);\n}", "{\n    // your code goes here \n    import std.conv;\n   \
    \ if (num<0L)\n    {\n        num = -num;\n    }\n    string s = to!string(num);\n\
    \    long n = s.length;\n    long odd=0, even=0;\n    for (int i=0; i<n; i++)\n\
    \    {\n        if (int(s[i])%2==0)\n        {\n            even++;\n        }\n\
    \        else\n        {\n            odd++;\n        }\n    }\n    return tuple(even,\
    \ odd);\n}\n \n/*\nwrite a function that will return a tuple, with the first element\
    \ being the\nnumber of occurrences of the search character in the input string\
    \ and the second\nbeing the number of occurrences of the search character in the\
    \ input string, ignoring\ncase.", "{\n    long even, odd;", "{\n    long odd=0,\
    \ even=0;\n    foreach(long d; 0 .. num.stringof.length)\n    {\n        if(cast(long)num.stringof[d]\
    \ % 2 == 0)\n            even++;\n        else\n            odd++;\n    }\n  \
    \  return tuple(even, odd);\n}", "{\n    long[] number = num.to!(string).split(\"\
    \").map!(to!long);\n    long even = 0;\n    long odd = 0;\n    foreach(digit;\
    \ number)\n    {\n        if(digit % 2 == 0)\n        {\n            even++;\n\
    \        }\n        else\n        {\n            odd++;\n        }\n    }\n  \
    \  return tuple(even, odd);\n}", "{\n\tlong odd = 0;\n\tlong even = 0;\n\tforeach(n;\
    \ num.to!string)\n\t{\n\t\tif (n.to!long % 2 == 0)\n\t\t\teven++;\n\t\telse\n\t\
    \t\todd++;\n\t}\n\treturn tuple(even, odd);\n}", "{\n    enum even = 0;\n    enum\
    \ odd = 1;\n    return Tuple!(long, long)(0, 0).tupleof[even] = count!(a => a\
    \ % 2 == 0)( num.tostring()).to!long(), \n        .tupleof[odd] = count!(a =>\
    \ a % 2 == 1)( num.tostring()).to!long();\n}", "{\n    Tuple!(long, long) res\
    \ = tuple(0L, 0L);\n    if (num < 0) \n    {\n        num = -num;\n    }\n   \
    \ while (num > 0) \n    {\n        if (num % 2 == 0) \n        {\n           \
    \ res[0]++;\n        }\n        else \n        {\n            res[1]++;\n    \
    \    }\n        num /= 10;\n    }\n    return res;\n}", "{\n    import std.range;\n\
    \    long evenCount = 0;\n    long oddCount = 0;\n    long n = num;\n    n.popFront();\n\
    \    int digit = n.front;\n    foreach(i; n)\n    {\n        if(digit % 2 == 0)\n\
    \        {\n            evenCount++;\n        }\n        else\n        {\n   \
    \         oddCount++;\n        }\n        n.popFront();\n        digit = n.front;\n\
    \    }\n    return tuple(evenCount, oddCount);\n}\n/*\n    Given a 4 element array\
    \ of ints. Return true iff the array contains two elements\n    with the same\
    \ value, and two elements with the same value but different from the\n    two\
    \ other elements. \n    \n    Example:\n    \n    [3, 2, 3, 2]\n    true\n   \
    \ \n    [3, 2, 3, 2, 5]\n    false\n    \n    [1, 1, 2, 2]\n    true\n    \n \
    \   [1, 1, 2, 2, 5]\n    false\n    \n    [1, 2, 1, 2]\n    false\n*/", "{\n \
    \   long  countEven = 0;\n    long  countOdd = 0;\n    long digit;\n    long sign\
    \ = 1;\n    if (num < 0)\n    {\n        sign = -1;\n        num = -num;\n   \
    \ }\n    while (num > 0)\n    {\n        digit = num % 10;\n        if (digit\
    \ % 2 == 0)\n        {\n            countEven++;\n        }\n        else\n  \
    \      {\n            countOdd++;\n        }\n        num /= 10;\n    }\n    return\
    \ tuple(countEven, countOdd);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
