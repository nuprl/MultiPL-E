language: d
name: HumanEval_25_factorize
results:
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] res = [];\n\tlong d = 2;\n\twhile (d*d <= n)\n\t{\n\t\twhile (n\
    \ % d == 0)\n\t\t{\n\t\t\tres ~= d;\n\t\t\tn /= d;\n\t\t}\n\t\td += 1;\n\t}\n\t\
    if (n > 1)\n\t\tres ~= n;\n\treturn res;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\t long[] primes = new long[1];\n\t long p = 2;\n\t long fCount = 0;\n\t\
    \ long i = 0;\n\t \n\t \n\t foreach(long i; 0 ..^  n)\n\t {\n\t\t if(n % p ==\
    \ 0)\n\t\t {\n\t\t\t primes[i] = p;\n\t\t\t p = 2;\n\t\t\t i++;\n\t\t\t fCount++;\n\
    \t\t }\n\t\t else\n\t\t {\n\t\t\tp++;\n\t\t }\n\t }\n\treturn primes;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpey2__dqk.d(23): Error: expression expected, not `^`

    /tmp/tmpey2__dqk.d(23): Error: found `n` when expecting `)`

    /tmp/tmpey2__dqk.d(23): Error: found `)` instead of statement

    /tmp/tmpey2__dqk.d(32): Error: declaration expected, not `else`

    /tmp/tmpey2__dqk.d(35): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpey2__dqk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factorArray = new long[0];\n    long j = 2;\n    if (n <= 2)\n\
    \    {\n        factorArray = new long[1];\n        factorArray[0] = n;\n    \
    \    return factorArray;\n    }\n    if (n % 2 == 0)\n    {\n        factorArray\
    \ = new long[1];\n        factorArray[0] = 2;\n        return factorArray ~ factorize(n\
    \ / 2);\n    }\n    else\n    {\n        for (long i = 3; i <= cast(long)ceil(sqrt(n));\
    \ i += 2)\n        {\n            if (n % i == 0)\n            {\n           \
    \     factorArray = new long[1];\n                factorArray[0] = i;\n      \
    \          return factorArray ~ factorize(n / i);\n            }\n        }\n\
    \    }\n    factorArray = new long[1];\n    factorArray[0] = n;\n    return factorArray;\n\
    }\n/*\n * Return the minimal number of integer factors that contain all of the\
    \ prime factors that are in given integer.\n *\n * >>> bestSubset(3L)\n * [3L]\n\
    \ * >>> bestSubset(6L)\n * [2L, 3L]\n * >>> bestSubset(7L)\n * [7L]\n * >>> bestSubset(70L)\n\
    \ * [5L, 7L]\n * >>> bestSubset(45L)\n * [3L, 5L]\n * >>> bestSubset(140L)\n *\
    \ [2L, 5L, 7L]\n * >>> bestSubset(132L)\n * [2L, 3L, 11L]\n * >>> bestSubset(1096L)\n\
    \ * [2L, 4L, 7L, 13L]\n * >>> bestSubset(3125L)\n * [5L, 5L, 5L, 5L]\n * >>> bestSubset(24L)\n\
    \ * [2L, 2L, 2L, 3L]\n *\n */\nlong[] bestSubset(long n)\n{\n    long[] array\
    \ = new long[0];\n    long[] factorArray = factorize(n);\n    foreach (i; 0\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxfdcgct6.d(77): Error: found `unittest` when expecting `)`

    /tmp/tmpxfdcgct6.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxfdcgct6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res;\n    bool isPrime = false;\n    foreach(factor; res)\n\
    \    {\n        if(n % factor == 0)\n        {\n            n = n / factor;\n\
    \            res ~= factor;\n        }\n        else\n        {\n            isPrime\
    \ = true;\n        }\n    }\n    if(isPrime)\n    {\n        res ~= n;\n    }\n\
    \    return res;\n}\n \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwlbspj5.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285f5]

    ??:? void tmpkwlbspj5.__unittest_L38_C1() [0x427f7e]

    ??:? void tmpkwlbspj5.__modtest() [0x428374]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cfef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42be82]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d84]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430861]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be59]

    ??:? runModuleUnitTests [0x42cdc5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a44]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    foreach(prime; Primes()) \n    {\n       \
    \ while(n % prime == 0) \n        {\n            result ~= prime;\n          \
    \  n /= prime;\n        }\n        if(n == 1) \n        {\n            break;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp701y4rmz.d(18): Error: undefined identifier `Primes`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp701y4rmz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    int i = 2;\n    long[] result = new long[];\n    while (n != 1)\n \
    \   {\n        if (n % i == 0)\n        {\n            n /= i;\n            result\
    \ ~= i;\n        }\n        else\n        {\n            i += 1;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3jmrohp1.d(18): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3jmrohp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    import std.math;\n    import std.typecons;\n    long[] factors;\n \
    \   if (n < 2)\n        return new long[](0);\n    foreach (i; 2 .. sqrt(n) +\
    \ 1)\n    {\n        while (n % i == 0)\n        {\n            n /= i;\n    \
    \        factors ~= i;\n        }\n    }\n    if (n > 1)\n        factors ~= n;\n\
    \    return factors;\n}\nlong[] factorize(long n)\n{\n    import std.math;\n \
    \   import std.typecons;\n    long[] factors;\n    if (n < 2)\n        return\
    \ new long[](0);\n    while (n % 2 == 0)\n    {\n        n /= 2;\n        factors\
    \ ~= 2;\n    }\n    foreach (i; 3 .. sqrt(n) + 1)\n    {\n        while (n % i\
    \ == 0)\n        {\n            n /= i;\n            factors ~= i;\n        }\n\
    \    }\n    if (n > 1)\n        factors ~= n;\n    return factors;\n}\nlong[]\
    \ factorize(long n)\n{\n    import std.math;\n    import std.typecons;\n    long[]\
    \ factors;\n    if (n < 2)\n        return new long[](0);\n    while (n % 2 ==\
    \ 0)\n    {\n        n /= 2;\n        factors ~= 2;\n    }\n    foreach (i; 3\
    \ .. isqrt(n) + 1, 2)\n    {\n        while (n % i == 0)\n        {\n        \
    \    n /= i;\n            factors ~= i;\n        }\n    }\n    if (n > 1)\n  \
    \      factors ~= n;\n    return factors;\n}\nlong[] factorize(long n)\n{\n  \
    \  import std.math;\n    import std.typecons;\n    long[] factors;\n    if (n\
    \ < 2)\n        return new long[](0);\n    while (n % 2 == 0)\n    {\n       \
    \ n /= 2;\n        factors ~= 2;\n    }\n    foreach (i;\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpillx2826.d(95): Error: expression expected, not `unittest`

    /tmp/tmpillx2826.d(96): Error: found `{` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpillx2826.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    auto f = new long[](0);\n    for (int i = 2; i < sqrt(n); i++)\n  \
    \  {\n        auto j = 0;\n        while (n % i == 0)\n        {\n           \
    \ j++;\n            n /= i;\n        }\n        f = f ~ repeat(i, j);\n    }\n\
    \    return f;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpacsa_e1s.d(18): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    /tmp/tmpacsa_e1s.d(26): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpacsa_e1s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    if (n < 0) \n    {\n        result ~= -1;\n\
    \        n = -n;\n    }\n    while (n > 1) \n    {\n        long div = 2;\n  \
    \      while (n % div != 0) \n        {\n            div++;\n        }\n     \
    \   result ~= div;\n        n /= div;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    long[] primes = [2L, 3L, 5L, 7L, 11L, 13L,\
    \ 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L,\
    \ 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L, 149L, 151L,\
    \ 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L, 223L, 227L,\
    \ 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L, 283L, 293L,\
    \ 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L, 373L, 379L,\
    \ 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L, 449L, 457L,\
    \ 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L, 541L, 547L,\
    \ 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L, 617L, 619L,\
    \ 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L, 701L, 709L,\
    \ 719L, 727L, 733L, 739L, 743L, 751L, 757L, 761L, 769L, 773L, 787L, 797L, 809L,\
    \ 811L, 821L, 823L, 827L, 829L, 839L\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8mle76u4.d(19): Error: comma expected separating array initializers,
    not `unittest`

    /tmp/tmp8mle76u4.d(20): Error: semicolon expected, not `{`

    /tmp/tmp8mle76u4.d(32): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8mle76u4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [];\n    foreach(i; 2 .. n)\n    {\n        while(n %\
    \ i == 0)\n        {\n            res ~= i;\n            n /= i;\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz3yaosw9.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285bd]

    ??:? void tmpz3yaosw9.__unittest_L28_C1() [0x427f46]

    ??:? void tmpz3yaosw9.__modtest() [0x42833c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cfb7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42be4a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43089d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430829]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be21]

    ??:? runModuleUnitTests [0x42cd8d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a0c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [2L];\n    long i = 3L;\n    long last = 2L;\n    long[]\
    \ primes = [2L];\n    while (n % 2L == 0L) \n    {\n        n /= 2L;\n    }\n\
    \    while (i * i <= n) \n    {\n        if (n % i == 0L) \n        {\n      \
    \      while (n % i == 0L) \n            {\n                n /= i;\n        \
    \    }\n            last = i;\n            primes ~= i;\n        }\n        i\
    \ += 2L;\n    }\n    if (n > 1L) \n    {\n        last = n;\n        primes ~=\
    \ n;\n    }\n    return primes;\n}\n/*\n    Return the number of divisors of the\
    \ given integer.\n    >>> numDivisors(1L)\n    1\n    >>> numDivisors(4L)\n  \
    \  3\n    >>> numDivisors(12L)\n    6\n    >>> numDivisors(70L)\n    8\n    \n\
    */\nlong numDivisors(long n) \n{\n    if (n == 1L) \n    {\n        return 1L;\n\
    \    }\n    return product(map!\"a.second + 1L\"(enumerate(factorize(n))));\n\
    }\n/*\n    Return an array of prime factors of given integer in the order from\
    \ smallest to largest.\n    The array should be filled as much as possible with\
    \ prime factors,\n    and remaining space in the array should be filled with -1.\n\
    \    If n is 1, return an array of length 1 with -1.\n    >>> primeFactors(1L)\n\
    \    [-1L]\n    >>> primeFactors(4L)\n    [2L, -1L]\n    >>> primeFactors(12L)\n\
    \    [2L, 2L, 3L]\n    >>> primeFactors(70L)\n    [2L, 5L, 7L, -1L]\n    \n*/\n\
    long[] primeFactors(long n) \n{\n    if (n == 1L) \n    {\n        return [-1L];\n\
    \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpje6gcnxz.d(86): Error: found `unittest` instead of statement

    /tmp/tmpje6gcnxz.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpje6gcnxz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] array;\n    for (long i = 2; i <= n; i++)\n    {\n\tif (n %\
    \ i == 0)\n\t{\n\t    n /= i;\n\t    array ~= i;\n\t    i--;\n\t}\n    }\n   \
    \ return array;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163163
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] res;\n\t\n\twhile(n % 2 == 0)\n\t{\n\t\tn /= 2;\n\t\tres ~= 2;\n\
    \t}\n\t\n\tfor(long i = 3; i * i <= n; i += 2)\n\t{\n\t\twhile(n % i == 0)\n\t\
    \t{\n\t\t\tn /= i;\n\t\t\tres ~= i;\n\t\t}\n\t}\n\t\n\tif(n > 2)\n\t\tres ~= n;\n\
    \t\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n  if (n<2) return [n];\n  long[] factors;\n  foreach(x; [2L, 3L, 5L, 7L,\
    \ 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L,\
    \ 73L, 79L, 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L,\
    \ 149L, 151L, 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L,\
    \ 223L, 227L, 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L,\
    \ 283L, 293L, 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L,\
    \ 373L, 379L, 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L,\
    \ 449L, 457L, 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L,\
    \ 541L, 547L, 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L,\
    \ 617L, 619L, 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L,\
    \ 701L, 709L, 719L, 727L, 733L, 739L, 743L, 751L, 757L, 761L, 769L, 773L, 787L,\
    \ 797L, 809L, 811L, 821L, 823L,\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoyydzkkj.d(20): Error: expression expected, not `unittest`

    /tmp/tmpoyydzkkj.d(21): Error: found `{` when expecting `,`

    /tmp/tmpoyydzkkj.d(22): Error: expression expected, not `alias`

    /tmp/tmpoyydzkkj.d(22): Error: found `candidate` when expecting `,`

    /tmp/tmpoyydzkkj.d(22): Error: expression expected, not `=`

    /tmp/tmpoyydzkkj.d(22): Error: found `factorize` when expecting `,`

    /tmp/tmpoyydzkkj.d(22): Error: expression expected, not `;`

    /tmp/tmpoyydzkkj.d(24): Error: found `assert` when expecting `,`

    /tmp/tmpoyydzkkj.d(24): Error: found `;` when expecting `,`

    /tmp/tmpoyydzkkj.d(25): Error: found `;` when expecting `,`

    /tmp/tmpoyydzkkj.d(26): Error: found `;` when expecting `,`

    /tmp/tmpoyydzkkj.d(27): Error: found `;` when expecting `,`

    /tmp/tmpoyydzkkj.d(28): Error: found `;` when expecting `,`

    /tmp/tmpoyydzkkj.d(29): Error: found `;` when expecting `,`

    /tmp/tmpoyydzkkj.d(30): Error: found `;` when expecting `,`

    /tmp/tmpoyydzkkj.d(31): Error: found `;` when expecting `,`

    /tmp/tmpoyydzkkj.d(32): Error: e'
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] res = [];\n\tforeach(i;iota(2L,n/2L+1L))\n\t{\n\t\twhile(!mod(n,i))\n\
    \t\t{\n\t\t\tn /= i;\n\t\t\tres ~= i;\n\t\t}\n\t}\n\tassert(product(res) == n);\n\
    \treturn res;\n}\n/*\n Same as above, but should use function primes() returning\
    \ a lazy list of all primes.\n    >>> factorize2(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize2(25L)\n    [5L, 5L]\n    >>> factorize2(70L)\n    [2L, 5L, 7L]\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprgqzsg47.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprgqzsg47.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] array = new long[0];\n\tfor (long i = 2; i < n; i++)\n\t{\n\t\t\
    if (n % i == 0)\n\t\t{\n\t\t\tarray = array ~ array(i);\n\t\t\tn = n / i;\n\t\t\
    \ti = 1;\n\t\t}\n\t}\n\treturn array;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ss8l9ih.d(22): Error: function expected before `()`, not `array`
    of type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ss8l9ih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long[] factors = new long[0];\n    foreach(p; primes(n + 1L)) \n \
    \   { \n        while (n % p == 0) \n        { \n            n /= p; \n      \
    \      factors ~= p; \n        } \n    } \n    return factors; \n} \n// since\
    \ we use factorize() to test for primeness, there is no need for caching\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa7qhdx74.d(18): Error: undefined identifier `primes`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa7qhdx74.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    long prime = 2L;\n    long power = 0L;\n \
    \   long sqrtN = cast(long)Math.sqrt(n);\n    while (n &gt; 1 &amp;&amp; prime\
    \ &lt;= sqrtN) \n    {\n        while (n % prime == 0) \n        {\n         \
    \   n /= prime;\n            power++;\n        }\n        if (power &gt; 0) \n\
    \        {\n            result ~= repeat(prime, power);\n            power = 0;\n\
    \        }\n        prime++;\n    }\n    if (n &gt; 1) \n    {\n        result\
    \ ~= n;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkoaxr5eu.d(21): Error: found `;` when expecting `)`

    /tmp/tmpkoaxr5eu.d(21): Error: found `&` instead of statement

    /tmp/tmpkoaxr5eu.d(21): Error: found `=` instead of statement

    /tmp/tmpkoaxr5eu.d(28): Error: declaration expected, not `if`

    /tmp/tmpkoaxr5eu.d(28): Error: declaration expected, not `0`

    /tmp/tmpkoaxr5eu.d(31): Error: no identifier for declarator `power`

    /tmp/tmpkoaxr5eu.d(31): Error: declaration expected, not `=`

    /tmp/tmpkoaxr5eu.d(32): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkoaxr5eu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors;\n    while (n % 2 == 0) \n    {\n        n /= 2;\n\
    \        factors ~= 2;\n    }\n    for (long i = 3; i <= sqrt(n); i += 2) \n \
    \   {\n        while (n % i == 0) \n        {\n            n /= i;\n         \
    \   factors ~= i;\n        }\n    }\n    if (n > 2) \n    {\n        factors ~=\
    \ n;\n    }\n    return factors;\n}\n/*\n Return all divisors of given integer\n\
    \    >>> divisors(8L)\n    [1L, 2L, 4L, 8L]\n    >>> divisors(7L)\n    [1L, 7L]\n\
    */\nlong[] divisors(long n) \n{\n    long[] factors = factorize(n);\n    return\
    \ generateDivisors(factors, n);\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdgtnw59z.d(23): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    /tmp/tmpdgtnw59z.d(47): Error: undefined identifier `generateDivisors`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdgtnw59z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    // write your code here\n    long[] list = new long[100];\n    long[]\
    \ result = new long[100];\n    int i = 0;\n    while(n % 2 == 0)\n    {\n    \
    \    list[i] = 2;\n        n = n / 2;\n        i++;\n    }\n    for(long j = 3;\
    \ j <= sqrt(n); j = j + 2)\n    {\n        while(n % j == 0)\n        {\n    \
    \        list[i] = j;\n            n = n / j;\n            i++;\n        }\n \
    \   }\n    if(n > 2)\n    {\n        list[i] = n;\n        i++;\n    }\n    result\
    \ = list[0..i];\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppqfgdits.d(27): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppqfgdits.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    static long[] factorize(long n, long d)\n    {\n        if (n % d ==\
    \ 0)\n        {\n            auto factors = factorize(n / d, d);\n           \
    \ return [d] ~ factors;\n        }\n        else if (d * d > n)\n        {\n \
    \           return [n];\n        }\n        else\n        {\n            return\
    \ factorize(n, d + 1);\n        }\n    }\n    return factorize(n, 2);\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv8j4lb_h.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x428615]

    ??:? void tmpv8j4lb_h.__unittest_L35_C1() [0x427fa2]

    ??:? void tmpv8j4lb_h.__modtest() [0x428398]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c76b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5fe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430649]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430af8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4305d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5d5]

    ??:? runModuleUnitTests [0x42c541]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [2L,2L,2L];\n    return res;\n}\n \n/*\n Return the first\
    \ item from given range that matches the predicate.\n If no item matches the predicate\
    \ then None is returned\n \n    >>> first(10 .. 20, (i => i > 20))\n    None\n\
    \    >>> first(5 .. 15, (i => i % 3 == 0))\n    Some(6)\n*/\nauto first(R, alias\
    \ pred) (R r, pred) \n{\n    foreach (i; r) \n    {\n        if (pred(i)) \n \
    \       {\n            return Some(i);\n        }\n    }\n    return None;\n}\n\
    \ \n/*\n Determine how many items from the given range match the predicate\n \n\
    \    >>> count(10 .. 15, (i => i % 3 == 0))\n    2\n    >>> count(0 .. 100, (i\
    \ => i % 5 == 0))\n    20\n*/\nsize_t count(R, alias pred) (R r, pred) \n{\n \
    \   size_t res = 0;\n    foreach (i; r) \n    {\n        if (pred(i)) \n     \
    \   {\n            res += 1;\n        }\n    }\n    return res;\n}\n \n/*\n Return\
    \ set of items from given range that match the predicate\n \n    >>> filter(5\
    \ .. 20, (i => i % 3 == 0))\n    [6, 9, 12, 15, 18]\n    >>> filter(0 .. 100,\
    \ (i => i % 5 == 0))\n    [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65,\
    \ 70, 75, 80, 85, 90, 95, 100]\n*/\nR filter(R, alias pred) (R r, pred) \n{\n\
    \    R res;\n    foreach (i; r) \n    {\n        if (pred(i)) \n        {\n  \
    \          res ~= i;\n        }\n    }\n    return res;\n}\n \n/*\n Return array\
    \ of fibonacci sequence numbers of the given length\n    Numbers in array should\
    \ start from the 1st item and go\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjoamz7ri.d(84): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjoamz7ri.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] factors = new long[0];\n\tlong i = 2;\n\twhile (i * i <= n) \n\
    \t{\n\t\tif (n % i == 0) \n\t\t{\n\t\t\tfactors ~= i;\n\t\t\tn /= i;\n\t\t}\n\t\
    \telse \n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\tfactors ~= n;\n\treturn factors;\n}\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[];\n    while(n%2 == 0)\n    {\n        factors\
    \ ~= 2;\n        n = n/2;\n    }\n    long i = 3;\n    while(i <= n)\n    {\n\
    \        if(n%i == 0)\n        {\n            factors ~= i;\n            n = n/i;\n\
    \        }\n        else\n        {\n            i += 2;\n        }\n    }\n \
    \   return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz0j6n9hs.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz0j6n9hs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [];\n    if (n <= 0) return res;\n    res ~= 1;\n    foreach\
    \ (i; 2..sqrt(n)+1) \n    {\n        while (n % i == 0) \n        {\n        \
    \    res ~= i;\n            n /= i;\n        }\n    }\n    if (n > 1) res ~= n;\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2r20e8y4.d(20): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2r20e8y4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] results;\n    long i;\n    long count;\n    long rem;\n    for\
    \ (i = 2; i <= n; i++)\n    {\n        rem = n % i;\n        count = 0;\n    \
    \    while (rem == 0)\n        {\n            count = count + 1;\n           \
    \ n = n / i;\n            rem = n % i;\n        }\n        if (count != 0)\n \
    \       {\n            results ~= repeat(i, count);\n        }\n    }\n    return\
    \ results;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo3lwkw_g.d(33): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo3lwkw_g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long i = 2;\n    long[] result = new long[0];\n    long[] temp = new\
    \ long[0];\n    foreach(k; 2..n+1)\n    {\n        if(n%k == 0)\n        {\n \
    \           result ~= k;\n            n = n/k;\n            --k;\n        }\n\
    \    }\n    temp = result[0..$-1];\n    int count = 0;\n    while(result[$-1]\
    \ == temp[$-1])\n    {\n        temp = temp[0..$-1];\n        ++count;\n    }\n\
    \    long[] res = new long[0];\n    foreach(n; 0..count)\n    {\n        res ~=\
    \ result[$-1];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_xhy208z.d(37): Error: variable `n` is shadowing variable `tmp_xhy208z.factorize.n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_xhy208z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    assert(n > 0L);\n    auto factors = [];\n    foreach(i; 2L .. ceil(sqrt(n))\
    \ + 1L)\n    {\n        while(n % i == 0L)\n        {\n            n /= i;\n \
    \           factors ~= i;\n        }\n    }\n    if(n > 1L)\n        factors ~=\
    \ n;\n    return factors;\n}\n/*\n    Return array of prime factors of the given\
    \ integer.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    The method should return\
    \ a tuple containing the prime factors and their multiplicities\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorizeWithCount(8L)\n\
    \    [(2L, 3L)]\n    >>> factorizeWithCount(25L)\n    [(5L, 2L)]\n    >>> factorizeWithCount(70L)\n\
    \    [(2L, 1L), (5L, 1L), (7L, 1L)]\n*/\ntuple!(long, long)[] factorizeWithCount(long\
    \ n) \n{\n    assert(n > 0L);\n    auto factors = [];\n    foreach(i; 2L .. ceil(sqrt(n))\
    \ + 1L)\n    {\n        auto count = 0L;\n        while(n % i == 0L)\n       \
    \ {\n            n /= i;\n            count++;\n        }\n        if(count >\
    \ 0L)\n            factors ~= tuple(i, count);\n    }\n    if(n > 1L)\n      \
    \  factors ~= tuple(n, 1L);\n    return factors;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpse7wx8ty.d(43): Error: `tuple!(long, long)` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpse7wx8ty.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n <= 1L) return [n];\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptdrb48sx.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptdrb48sx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] res = [];\n\tforeach(long i; [2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])\n\t{\n\t\t\
    if(n % i == 0)\n\t\t{\n\t\t\tres ~= i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\tif(n != 1)\n\
    \t\tres ~= n;\n\treturn res;\n}\n/*\n    Test if given int is a prime\n    >>>\
    \ isPrime(8L)\n    false\n    >>> isPrime(3L)\n    true\n*/\nunittest\n{\n   \
    \ alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvnwpwam4.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpvnwpwam4.__unittest_L37_C1() [0x42818a]

    ??:? void tmpvnwpwam4.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d17b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42c00e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430a61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430f10]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4309ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bfe5]

    ??:? runModuleUnitTests [0x42cf51]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [];\n    foreach(i; 2..n) {\n        while(n % i == 0)\
    \ {\n            res ~= i;\n            n /= i;\n        }\n    }\n    return\
    \ res;\n}\n/*\n    Primes\n    ======\n    By listing the first six prime numbers:\
    \ 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\n    What is the\
    \ 10001st prime number?\n*/\nauto primes(size_t n)\n{\n    // return the nth prime\
    \ number\n    // \n    long min = 1, max = 1000000;\n    long step = 1;\n    if(n\
    \ > 10000) {\n        step = 10;\n        if(n > 100000) {\n            step =\
    \ 100;\n            if(n > 1000000) {\n                step = 1000;\n        \
    \    }\n        }\n    }\n    int i = 0;\n    for(size_t i = 1; ; i += step) {\n\
    \        // check all numbers between min and max\n        for(long j = min; j\
    \ < max; j++) {\n            long[] fac = factorize(j);\n            if(fac.length\
    \ == 1) {\n                if(fac[0] == j) {\n                    n--;\n     \
    \               if(n == 0) {\n                        return j;\n            \
    \        }\n                }\n            }\n        }\n        min = max;\n\
    \        max = min + step * 1000;\n    }\n}\n/*\n    Distinct primes factors\n\
    \    =======================\n    The first two consecutive numbers to have two\
    \ distinct prime factors are:\n    14 = 2 \xD7 7\n    15 = 3 \xD7 5\n    The first\
    \ three consecutive numbers to have three distinct prime factors are:\n    644\
    \ = 2\xB2 \xD7 7 \xD7 23\n    645 = 3 \xD7 5 \xD7 43\n    646 = 2 \xD7 17 \xD7\
    \ 19.\n    Find the first four consecutive integers to have four distinct prime\
    \ factors. What is the first of these numbers?\n*/\nauto dpf(size_t n)\n{\n  \
    \  long max = 2000000;\n    long step = 1;\n    if(n > 10000) {\n        step\
    \ = 10;\n        if\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp1x7ndxe.d(84): Error: found `unittest` when expecting `(`

    /tmp/tmpp1x7ndxe.d(97): Error: found `void` when expecting `)`

    /tmp/tmpp1x7ndxe.d(97): Error: found `{` when expecting `;` following statement

    /tmp/tmpp1x7ndxe.d(97): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp1x7ndxe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n==1) return [1L];\n    long[] factors = [];\n    while (n % 2\
    \ == 0) \n    {\n        factors ~= 2L;\n        n /= 2;\n    }\n    for (long\
    \ i = 3; i <= n; i += 2) \n    {\n        while (n % i == 0) \n        {\n   \
    \         factors ~= i;\n            n /= i;\n        }\n    }\n    return factors;\n\
    }\nassert(factorize(8L) == [2L, 2L, 2L]);\nassert(factorize(25L) == [5L, 5L]);\n\
    assert(factorize(70L) == [2L, 5L, 7L]);\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp73re67so.d(34): Error: declaration expected, not `assert`

    /tmp/tmp73re67so.d(35): Error: declaration expected, not `assert`

    /tmp/tmp73re67so.d(36): Error: declaration expected, not `assert`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp73re67so.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong n2 = n;\n\tint nn = int(sqrt(n));\n\tint[] prim = new int[nn];\n\
    \tint k = 1;\n\tprim[0] = 2;\n\tfor (int i = 3; i < nn; i += 2)\n\t{\n\t\tbool\
    \ ok = true;\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tif (i % prim[j] ==\
    \ 0)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok)\n\
    \t\t{\n\t\t\tprim[k] = i;\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\tlong[] fct = new long[10];\n\
    \tint ct = 0;\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tif (n2 % prim[i] == 0)\n\
    \t\t{\n\t\t\twhile (n2 % prim[i] == 0)\n\t\t\t{\n\t\t\t\tn2 /= prim[i];\n\t\t\t\
    \tfct[ct] = prim[i];\n\t\t\t\tct++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n2 != 1)\n\t{\n\
    \t\tfct[ct] = n2;\n\t\tct++;\n\t}\n\treturn fct[0..ct];\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeh1yjfm4.d(18): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeh1yjfm4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    auto factors = [];\n    foreach(i; 2 .. ceil(sqrt(n)) + 1)\n    {\n\
    \        while(n % i == 0)\n        {\n            n /= i;\n            factors\
    \ ~= i;\n        }\n    }\n    if(n != 1)\n        factors ~= n;\n    return factors;\n\
    }\n/*\n    Return tuple (p, q, g, x, y) such that\n    p = g**x mod q and g**y\
    \ mod q = p**-1 mod q.\n    >>> generate_keypair(420L)\n    (311L, 431L, 7L, 5L,\
    \ 103L)\n    >>> (g, p, q, x, y) = generate_keypair(420L)\n    >>> g**x % q\n\
    \    311L\n    >>> g**y % q\n    311L\n*/\nTuple!(long, long, long, long, long)\
    \ generate_keypair(long x)\n{\n    //x = phi(n)\n    auto primes = factorize(x);\n\
    \    auto p = min(primes);\n    auto q = x / p;\n    foreach(i; 1 .. x)\n    {\n\
    \        if(i.powmod(x, p * q) != 1)\n        {\n            return tuple(i.powmod(x,\
    \ p), i.powmod(x, q), i, x, x);\n        }\n    }\n    return tuple(0L, 0L, 0L,\
    \ 0L, 0L);\n}\n/*\n    Return tuple (p, q, g, x, y) such that\n    p = g**x mod\
    \ q and g**y mod q = p**-1 mod q.\n    >>> generate_keypair(420L)\n    (311L,\
    \ 431L, 7L, 5L, 103L)\n    >>> (g, p, q, x, y) = generate_keypair(420L)\n    >>>\
    \ g**x % q\n    311L\n    >>> g**y % q\n    311L\n*/\nTuple!(long, long, long,\
    \ long, long) generate_keypair(long p, long\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmput_ze7ta.d(68): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmput_ze7ta.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163163
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors;\n    while (n != 1)\n    {\n        long[] pair = factorize(n);\n\
    \        if (pair[0] == 0)\n        {\n            factors ~= pair[1];\n     \
    \       n /= pair[1];\n        }\n        else\n        {\n            long[]\
    \ smaller = factorize(pair[0]);\n            factors ~= smaller;\n           \
    \ n /= pair[0];\n        }\n    }\n    return factors;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164118
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    while(n % 2 == 0) \n    {\n        factors\
    \ ~= 2;\n        n /= 2;\n    }\n    // Now n is odd.\n    while(n > 1) \n   \
    \ {\n        bool found = false;\n        foreach(p; take(1000, primes(3, n /\
    \ 2))) \n        {\n            if(n % p == 0) \n            {\n             \
    \   factors ~= p;\n                n /= p;\n                found = true;\n  \
    \              break;\n            }\n        }\n        if(!found) \n       \
    \ {\n            // We've exhausted the list of primes, no factor found.\n   \
    \         // Must be a prime, itself.\n            factors ~= n;\n           \
    \ break;\n        }\n    }\n    return factors;\n}\n// https://stackoverflow.com/questions/5250500/how-to-implement-string-replace-in-dlang/5250520#5250520\n\
    string replace(string input, string find, string replace)\n{\n    string[] parts\
    \ = input.split(find);\n    return parts.join(replace);\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptnpfpf8n.d(27): Error: undefined identifier `take`, did you mean
    function `tan`?

    /tmp/tmptnpfpf8n.d(50): Error: no property `split` for type `string`

    /tmp/tmptnpfpf8n.d(51): Error: no property `join` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptnpfpf8n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tauto res = new Appender!(long[])();\n\t\n\tforeach(prime; primeFactorize(n))\
    \ {\n\t\tauto occurences = 0;\n\t\twhile(n % prime == 0) {\n\t\t\tn /= prime;\n\
    \t\t\toccurences++;\n\t\t}\n\t\tres.put(repeat(prime, occurences));\n\t}\n\treturn\
    \ res.data;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0xd0zi_r.d(17): Error: template instance `Appender!(long[])` template
    `Appender` is not defined

    /tmp/tmp0xd0zi_r.d(19): Error: undefined identifier `primeFactorize`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0xd0zi_r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tauto result = new long[](0);\n\twhile(n % 2 == 0) \n\t{\n\t\tresult ~=\
    \ 2;\n\t\tn /= 2;\n\t}\n\tfor(long i = 3; i <= n; i += 2) \n\t{\n\t\twhile(n %\
    \ i == 0) \n\t\t{\n\t\t\tresult ~= i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\n    isPrime function returns true if given integer is prime, otherwise\
    \ returns false.\n    >>> isPrime(5L)\n    true\n    >>> isPrime(13L)\n    true\n\
    \    >>> isPrime(15L)\n    false\n*/\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    auto primes = sieve(n); \n    long[] factors; \n    foreach(factor;\
    \ primes) \n    { \n        while(!(n % factor)) \n        { \n            n /=\
    \ factor; \n            factors ~= factor; \n        } \n    } \n    return factors;\
    \ \n}\n/*\nThe most efficient way to sieve all primes below N is using the sieve\
    \ of Eratosthenes \nwhich uses a wheel to reduce memory useage. \nThe wheel is\
    \ a cyclic list of \"spokes\" consisting of the first few prime numbers. \nThe\
    \ wheel has 6 spokes, consisting of the primes 2, 3, 5, 7, 11, and 13. \nThe wheel\
    \ is a cycle because it is periodic. \nFor example, the wheel contains 6*1, 6*2,\
    \ 6*3, ..., 6*6, and then starts over with 6*1. \nIn other words, it contains\
    \ 2, 3, 5, 7, 11, 13, 2, 3, 5, 7, 11, 13, 2, 3, 5, 7, 11, 13, ..., \nand so on.\
    \ You can see that after the wheel covers the first multiples of the prime numbers\
    \ \nthat are its spokes, the wheel starts over and re-covers the same multiples.\
    \ \nFor example, the wheel re-covers all the multiples of 13, even though 13 is\
    \ a prime. \nThe wheel contains only the multiples of the primes that are its\
    \ spokes. \nThus, we can use the wheel to sieve the multiples of 13 without sieving\
    \ multiples of any other primes. \nThe wheel is very useful because it is smaller\
    \ than the primes being sieved. \nFor example, the wheel contains only 6 numbers,\
    \ even though it is used to sieve the first \nmultiples of 6 primes (2, 3, 5,\
    \ 7, 11, and 13). \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnjwslldj.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnjwslldj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n  long[] factors = [];\n  long f = 2;\n  while (n > 1)\n  {\n    while\
    \ (n % f == 0)\n    {\n      factors ~= f;\n      n /= f;\n    }\n    f++;\n \
    \ }\n  return factors;\n}\n \n/*\n Returns a list of prime factors of a given\
    \ integer\n*/\nlong[] primeFactors(long n)\n{\n  long[] factors = [];\n  long\
    \ f = 2;\n  while (n > 1)\n  {\n    while (n % f == 0)\n    {\n      factors ~=\
    \ f;\n      n /= f;\n    }\n    f++;\n  }\n  return factors;\n}\n \n/*\nReturns\
    \ a list of all factors of a given integer\n*/\nlong[] allFactors(long n)\n{\n\
    \  long[] factors = [];\n  for (long f = 1; f <= n; f++)\n  {\n    if (n % f ==\
    \ 0)\n    {\n      factors ~= f;\n    }\n  }\n  return factors;\n}\n \n/*\nReturn\
    \ True if input number is a prime\n*/\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    if (n < 2) \n    {\n        return [n];\n\
    \    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9yn0alwr.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9yn0alwr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.bigint;\n    import std.conv;\n    import std.typecons;\n    import\
    \ std.math;\n    auto sieve = new bool[cast(int)(n)];\n    for (size_t i = 0;\
    \ i < n; i++)\n        sieve[i] = true;\n    sieve[0] = false;\n    sieve[1] =\
    \ false;\n    for (long i = 2; i * i < n; i++)\n    {\n        if (sieve[i])\n\
    \        {\n            for (long j = i * i; j < n; j += i)\n                sieve[j]\
    \ = false;\n        }\n    }\n    auto primes = new long[][2]().init;\n    for\
    \ (long i = 0; i < n; i++)\n    {\n        if (sieve[i])\n            primes ~=\
    \ [i, 0];\n    }\n    auto mutable new_n = n;\n    foreach (i; 0 .. primes.length)\n\
    \    {\n        while (new_n % primes[i][0] == 0)\n        {\n            new_n\
    \ /= primes[i][0];\n            primes[i][1]++;\n        }\n    }\n    auto mutable\
    \ fac = new long[]().init;\n    foreach (i; 0 .. primes.length)\n    {\n     \
    \   for (int j = 0; j < primes[i][1]; j++)\n            fac ~= primes[i][0];\n\
    \    }\n    return fac;\n}\n/*\n Return next higher permutation of passed in array\n\
    \    >>> permutation([1, 2, 3])\n    [1, 3, 2]\n    >>> permutation([1, 3, 2])\n\
    \    [2, 1, 3]\n    >>> permutation([3, 2, 1])\n    [1, 2, 3]\n    \n*/\nlong[]\
    \ permutation(long[] A) \n{\n    import std.algorithm;\n    import std.array;\n\
    \    auto mutable i = A.length - 1;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprt1i92x9.d(75): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprt1i92x9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] factors = new long[];\n\tlong i = 2;\n\twhile (i <= n)\n\t{\n\t\
    \tif (n % i == 0)\n\t\t{\n\t\t\tfactors ~= i;\n\t\t\tn /= i;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn factors;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeepgixhf.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeepgixhf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long[] result = new long[];\n    while (n % 2 == 0) \n    { \n   \
    \     result ~= 2; \n        n = n / 2; \n    } \n    for (long i = 3; i <= sqrt(n);\
    \ i = i + 2) \n    { \n        while (n % i == 0) \n        { \n            result\
    \ ~= i; \n            n = n / i; \n        } \n    } \n    if (n > 2) \n     \
    \   result ~= n; \n    return result; \n}\n \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpedx3q_cf.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpedx3q_cf.d(23): Error: `std.math.sqrt` called with argument types `(long)`
    matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedx3q_cf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors;\n    factors.length = 0;\n    foreach(long i; 2 ..\
    \ sqrt(n)) \n    {\n        while(n % i == 0) \n        {\n            n /= i;\n\
    \            factors ~= i;\n        }\n    }\n    if(n != 1) \n    {\n       \
    \ factors ~= n;\n    }\n    return factors;\n}\n// \"Dart is an object-oriented\
    \ language with C-style syntax which can optionally transcompile into JavaScript.\"\
    \ \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpznnyllsu.d(19): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpznnyllsu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result;\n    foreach(prime; PrimePrimes) \n    {\n        size_t\
    \ count = 0;\n        while(n % prime == 0) \n        {\n            n /= prime;\n\
    \            count++;\n        }\n        if(count)\n            result ~= PrimeTuple!(prime,\
    \ count);\n    }\n    return result;\n}\n/*\n    Return number of disjoint subsets\
    \ of integers [1..n] with given sum\n    >>> countSubsets(5, 6)\n    1\n    >>>\
    \ countSubsets(5, 7)\n    0\n    >>> countSubsets(5, 10)\n    2\n    >>> countSubsets(10,\
    \ 10)\n    1\n    >>> countSubsets(10, 20)\n    12\n    >>> countSubsets(100,\
    \ 100)\n    242\n    >>> countSubsets(1000, 1000)\n    2438\n*/\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7d5g2rh0.d(18): Error: undefined identifier `PrimePrimes`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7d5g2rh0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long factor = 2L;\n    long[] factors = new long[0];\n    while (n\
    \ > 1)\n    {\n        //while(n % factor == 0)\n        foreach(i; 0 .. iota(n/factor+1))\n\
    \        {\n            if(n % factor == 0)\n            {\n                n\
    \ /= factor;\n                factors ~= factor;\n            }\n            else\n\
    \            {\n                factor++;\n                break;\n          \
    \  }\n        }\n    }\n    return factors;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi20mzrpu.d(22): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi20mzrpu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] b = [];\n    long d = 2;\n    while (n > 1) \n    {\n      \
    \  while (n % d == 0) \n        {\n            b ~= d;\n            n /= d;\n\
    \        }\n        d += 1;\n    }\n    return b;\n}\n/*\n Return the sum of all\
    \ given numbers.\n >>> sum(1, 2, 3)\n 6\n */\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164103
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    import std.algorithm;\n    import std.math;\n    import std.typecons;\n\
    \    long[] res = [];\n    long d = 2;\n    while (n > 1) \n    {\n        while\
    \ ((n % d) == 0) \n        {\n            res ~= d;\n            n /= d;\n   \
    \     }\n        d++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] ret = null;\n\tif (n<=3) \n\t{\n\t\tret = new long[1];\n\t\tret[0]\
    \ = n;\n\t\treturn ret;\n\t}\n\tlong d = 2;\n\tlong[] nums = new long[128];\n\t\
    long num = 0;\n\twhile (n > 1) \n\t{\n\t\tlong count = 0;\n\t\twhile (n % d ==\
    \ 0) \n\t\t{\n\t\t\tcount++;\n\t\t\tn /= d;\n\t\t}\n\t\tif (count != 0)\n\t\t\
    {\n\t\t\tif (count == 1) \n\t\t\t{\n\t\t\t\tnums[num] = d;\n\t\t\t\tnum++;\n\t\
    \t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnums[num] = d;\n\t\t\t\tnums[num+1] = count;\n\
    \t\t\t\tnum += 2;\n\t\t\t}\n\t\t}\n\t\td++;\n\t}\n\tret = new long[num];\n\tfor\
    \ (long i = 0; i < num; i++)\n\t\tret[i] = nums[i];\n\treturn ret;\n}\n/*\n\t\
    Binary exponentiation is a method of calculating an exponent by repeatedly squaring.\n\
    \t\t>>> bpow(2L, 5L)\n\t\t32L\n\t\t>>> bpow(5L, 5L)\n\t\t3125L\n\t\t>>> bpow(5L,\
    \ 10L)\n\t\t9765625L\n*/\nlong bpow(long a, long n) \n{\n\tlong res = 1;\n\twhile\
    \ (n > 0) \n\t{\n\t\tif (n & 1)\n\t\t\tres *= a;\n\t\ta *= a;\n\t\tn >>= 1;\n\t\
    }\n\treturn res;\n}\n/*\n\tReturn the period of the rational number with numerator\
    \ N and denominator D (as a pair, e.g. (1, 2)). \n\tIf the period is too long\
    \ to store as an array, return an empty array.\n\tA rational\nunittest\n{\n  \
    \  alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc0aoeeu0.d(77): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc0aoeeu0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n  long[] ret = new long[];\n  \n  foreach(immutable p; factorialPrime(n))\n\
    \  {\n    foreach(immutable i; iota(0, p.count))\n    {\n      ret ~= p.value;\n\
    \    }\n  }\n  \n  return ret;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqsggy6od.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpqsggy6od.d(19): Error: undefined identifier `factorialPrime`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsggy6od.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] primes = new long[0];\n    long[] result = new long[0];\n  \
    \  foreach(i; 2 .. ceil(sqrt(n)))\n    {\n        long r = 0;\n        while(n\
    \ % i == 0)\n        {\n            n /= i;\n            r++;\n        }\n   \
    \     if(r != 0)\n        {\n            primes ~= i;\n            result ~= r;\n\
    \        }\n    }\n    if(n != 1)\n    {\n        primes ~= n;\n        result\
    \ ~= 1;\n    }\n    return primes.zip(result).map!(a => a[0]^a[1]).array;\n}\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1kj7dueb.d(19): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    /tmp/tmp1kj7dueb.d(38): Error: no property `zip` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1kj7dueb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] factors = [];\n\tfor (long i = 2; i <= sqrt(n); i++) \n\t{\n\t\
    \twhile (n % i == 0) \n\t\t{\n\t\t\tfactors ~= i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\
    \tif (n > 1) \n\t{\n\t\tfactors ~= n;\n\t}\n\treturn factors;\n}\n/*\n Return\
    \ tuple of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be tuple element number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    (2L, 2L, 2L)\n\
    \    >>> factorize(25L)\n    (5L, 5L)\n    >>> factorize(70L)\n    (2L, 5L, 7L)\n\
    \    \n*/\nTuple!(long[]) factorize2(long n) \n{\n\tlong[] factors = [];\n\tfor\
    \ (long i = 2; i <= sqrt(n); i++) \n\t{\n\t\twhile (n % i == 0) \n\t\t{\n\t\t\t\
    factors ~= i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\tif (n > 1) \n\t{\n\t\tfactors ~= n;\n\
    \t}\n\treturn tuple(factors);\n}\n/*\n Return set of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be set\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    {2L, 2L, 2L}\n    >>> factorize(25L)\n    {5L, 5L}\n    >>> factorize(70L)\n\
    \    {2L, 5L, 7L}\n    \n*/\nSet!(long) factorize3(long n) \n{\n\tlong[] factors\
    \ = [];\n\tfor (long i = 2; i <= sqrt(n); i++) \n\t\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppw839l5e.d(78): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppw839l5e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    for (long i = 2; i <= n; ++i)\n    {\n  \
    \      if(isPrime(i))\n        {\n            auto t = tuple(i, 0);\n        \
    \    while(n % i == 0)\n            {\n                n /= i;\n             \
    \   t[1]++;\n            }\n            if(t[1] != 0)\n            {\n       \
    \         append(factors, replicate(t[0], t[1]));\n            }\n        }\n\
    \    }\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ey7vs33.d(20): Error: undefined identifier `isPrime`

    /tmp/tmp8ey7vs33.d(30): Error: undefined identifier `append`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ey7vs33.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res;\n    long[] cur;\n    long[] primeFactors;\n    int j;\n\
    \    bool[] arr;\n    cur = [n];\n    res = [];\n    primeFactors = [];\n    arr\
    \ = [];\n    if (n <= 1L)\n    {\n        return [n];\n    }\n    else\n    {\n\
    \        while (true)\n        {\n            cur = new long[](cur.length / 2\
    \ + 1);\n            j = 0;\n            for (int i = 0; i < cur.length; i++)\n\
    \            {\n                if (cur[i] != 1L)\n                {\n       \
    \             cur[j] = cur[i];\n                    j++;\n                }\n\
    \            }\n            if (j == 0)\n            {\n                break;\n\
    \            }\n            cur = cur[0 .. j];\n            for (int i = 0; i\
    \ < cur.length; i++)\n            {\n                if (isPrime(cur[i]))\n  \
    \              {\n                    primeFactors ~= cur[i];\n              \
    \      for (int k = 0; k < arr.length; k++)\n                    {\n         \
    \               if (arr[k] && cur[i] % k == 0)\n                        {\n  \
    \                          for (int a = 0; a < primeFactors.length; a++)\n   \
    \                         {\n                                if (primeFactors[a]\
    \ == k)\n                                {\n                                 \
    \   primeFactors.remove(a);\n                                    break;\n    \
    \                            }\n                            }\n              \
    \          }\n                    }\n                    arr[cur[i]] = true;\n\
    \                }\n            }\n            cur = primeFactors;\n         \
    \   primeFactors = [];\n        }\n        primeFactors = [1L];\n        for (int\
    \ i = 0; i < cur.length; i++)\n        {\n            primeFactors ~= cur[i];\n\
    \            for (int k = 0; k < primeFactors.length; k++)\n            {\n  \
    \              if (primeFactors[k] % cur[i] == 0)\n                {\n       \
    \             primeFactors.remove(k);\n                    break;\n          \
    \      }\n            }\n        }\n        return primeFactors;\n    }\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpku3kcfqk.d(51): Error: undefined identifier `isPrime`

    /tmp/tmpku3kcfqk.d(62): Error: no property `remove` for type `long[]`

    /tmp/tmpku3kcfqk.d(82): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpku3kcfqk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long divisor = 2L;\n    long[] factors = [];\n    while (n > 1L) \n\
    \    {\n        if (n % divisor == 0L) \n        {\n            factors ~= divisor;\n\
    \            n /= divisor;\n        } \n        else \n        {\n           \
    \ divisor += 1L;\n        }\n    }\n    return factors;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[0];\n    if (n <= 3) \n    {\n        result\
    \ ~= n;\n        return result;\n    }\n    long i = 2;\n    while (n != 1) \n\
    \    {\n        while (n % i == 0) \n        {\n            result ~= i;\n   \
    \         n /= i;\n        }\n        ++i;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    foreach(factor; std.numeric.factorize(n))\n\
    \    {\n        foreach(i; 0 .. factor.numTimes)\n        {\n            factors\
    \ ~= factor.value;\n        }\n    }\n    return factors;\n}\nunittest\n{\n  \
    \  alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpes9prcdx.d(18): Error: undefined identifier `numeric` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpes9prcdx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res;\n    int sqrt = cast(int) sqrt(n);\n    res ~= div(n, 1L);\n\
    \    foreach(i; 2..sqrt)\n    {\n        while(n % i == 0)\n        {\n      \
    \      res ~= div(n, i);\n            n /= i;\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    assert(factorize(70L) == [2L, 5L, 7L]);\n    assert(factorize(25L)\
    \ == [5L, 5L]);\n    assert(factorize(10L) == [2L, 5L]);\n    assert(factorize(8L)\
    \ == [2L, 2L, 2L]);\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7n02yxrt.d(18): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    /tmp/tmp7n02yxrt.d(19): Error: undefined identifier `div`

    /tmp/tmp7n02yxrt.d(24): Error: undefined identifier `div`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7n02yxrt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    n = n.abs;\n    long[] res = [];\n    long[] primes = sievePrimes(min(n,1000L));\n\
    \    foreach(i; 0..primes.length)\n    {\n        if(n%primes[i] == 0)\n     \
    \   {\n            res ~= primes[i];\n            n /= primes[i];\n          \
    \  i--;\n        }\n    }\n    if(n == 1)\n        return res;\n    else\n   \
    \     return [n];\n}\nunittest\n{\n    assert(factorize(8L) == [2L, 2L, 2L]);\n\
    \    assert(factorize(25L) == [5L, 5L]);\n    assert(factorize(70L) == [2L, 5L,\
    \ 7L]);\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdid79e69.d(19): Error: undefined identifier `sievePrimes`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdid79e69.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n == 0L)\n        return typeof(return).init;\n    long[] ret =\
    \ new long[n];\n    size_t i = 0;\n    while (n % 2L == 0L) \n    {\n        ret[i]\
    \ = 2L;\n        n /= 2L;\n        i++;\n    }\n    foreach (p; iota(3L, cast(long)sqrt(n)\
    \ + 1L, 2L)) \n    {\n        while (n % p == 0L) \n        {\n            ret[i]\
    \ = p;\n            n /= p;\n            i++;\n        }\n    }\n    if (n > 2L)\
    \ \n    {\n        ret[i] = n;\n        i++;\n    }\n    return ret[0 .. i];\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphatwy_d6.d(27): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphatwy_d6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    long max = floor(sqrt(n));\n    foreach(i;\
    \ iota(2L, max + 1L)) {\n        while(n % i == 0) {\n            factors ~= i;\n\
    \            n /= i;\n        }\n    }\n    if(n > 1) factors ~= n;\n    return\
    \ factors;\n}\n/*\n    Function to generate a random number in the range of n\
    \ using Seed as input\n*/\nsize_t randomize(size_t Seed, size_t n) \n{\n    uint\
    \ r = uniform(0u, Seed, Seed);\n    return r % n;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw7o2o5gt.d(18): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    /tmp/tmpw7o2o5gt.d(19): Error: undefined identifier `iota`

    /tmp/tmpw7o2o5gt.d(33): Error: undefined identifier `uniform`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7o2o5gt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    static assert(n > 0L);\n    static assert(isProbablePrime(n) == false);\n\
    \    long[] result;\n    long x = n;\n    for (int i = 2; i <= cast(int)n; i++)\
    \ \n    {\n        if (x % i == 0) \n        {\n            auto factor = factorize(i);\n\
    \            foreach (y; factor) \n            {\n                result ~= y;\n\
    \            }\n            x /= i;\n            i--;\n        }\n    }\n    return\
    \ result;\n}\n \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjg9smb5v.d(17): Error: variable `n` cannot be read at compile time

    /tmp/tmpjg9smb5v.d(17):        while evaluating: `static assert(n > 0L)`

    /tmp/tmpjg9smb5v.d(18): Error: undefined identifier `isProbablePrime`

    /tmp/tmpjg9smb5v.d(18):        while evaluating: `static assert(isProbablePrime(n)
    == false)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjg9smb5v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long i;\n    long[] m=new long[2];\n    m[0]=1;\n    m[1]=n;\n   \
    \ n=n-1;\n    while(n>1)\n    {\n        while(m[1]%n==0)\n        {\n       \
    \     m[0]=n;\n            m[1]=m[1]/n;\n        }\n        n=n-1;\n    }\n  \
    \  return m;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdyubgruz.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428665]

    ??:? void tmpdyubgruz.__unittest_L33_C1() [0x427fee]

    ??:? void tmpdyubgruz.__modtest() [0x4283e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c743]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430861]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d10]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4307ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5ad]

    ??:? runModuleUnitTests [0x42c519]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b28]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] result = new long[];\n\tif (n <= 1) \n\t{\n\t\treturn result;\n\
    \t}\n\twhile (n % 2 == 0) \n\t{\n\t\tn /= 2;\n\t\tresult ~= 2;\n\t}\n\t\n\tlong\
    \ divisor = 3;\n\twhile (n != 1) \n\t{\n\t\tif (n % divisor == 0) \n\t\t{\n\t\t\
    \tn /= divisor;\n\t\t\tresult ~= divisor;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tdivisor\
    \ += 2;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfyymgxil.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfyymgxil.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n  long[] result = new long[0];\n  if (n <= 1) \n  {\n    return result;\n\
    \  }\n  //assert(n > 1);\n  long div = 2;\n  while (n > 1) \n  {\n    if (n %\
    \ div == 0) \n    {\n      result ~= div;\n      n /= div;\n    }\n    else \n\
    \    {\n      ++div;\n    }\n  }\n  return result;\n}\n/*\nReturn the sum of the\
    \ numbers in the array, returning 0 for an empty array. Except the number 13 is\
    \ very unlucky, so it does not count and numbers that come immediately after a\
    \ 13 also do not count.\n    >>> sum13([1, 2, 2, 1])\n    6\n    >>> sum13([1,\
    \ 1])\n    2\n    >>> sum13([1, 2, 2, 1, 13])\n    6\n    >>> sum13([1, 2, 13,\
    \ 2, 1, 13])\n    4\n    >>> sum13([13, 1, 2, 13, 2, 1, 13])\n    3\n    >>> sum13([])\n\
    \    0\n    >>> sum13([13])\n    0\n    >>> sum13([13, 13])\n    0\n    >>> sum13([13,\
    \ 0, 13])\n    0\n    >>> sum13([13, 1, 13])\n    0\n    >>> sum13([5, 7, 2])\n\
    \    14\n    >>> sum13([5, 13, 2])\n    5\n    >>> sum13([0])\n    0\n    >>>\
    \ sum13([13, 0])\n    0\n*/\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = new long[];\n    int i = 2;\n    while (i <= n) \n   \
    \ {\n        if (n % i == 0) \n        {\n            res ~= i;\n            n\
    \ /= i;\n        } \n        else \n        {\n            i++;\n        }\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfd36v66e.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfd36v66e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long[] res = [];\n    if (n % 2 == 0) \n    { \n        res ~= 2;\
    \ \n        n = n / 2; \n    } \n    for (long i = 3; i <= sqrt(n); i = i + 2)\
    \ \n    { \n        if (n % i == 0) \n        { \n            res ~= i; \n   \
    \         n = n / i; \n        } \n    } \n    if (n > 2) res ~= n;\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9asv3moy.d(23): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9asv3moy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [];\n    long i = 2;\n    while (n > 1)\n    {\n     \
    \   while (n % i == 0)\n        {\n            res ~= i;\n            n /= i;\n\
    \        }\n        i += 1;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors;\n    foreach(p; primes(n+1))\n    {\n        if(n%p==0)\n\
    \        {\n            //n=n/p;\n            n/=p;\n            factors~=p;\n\
    \        }\n    }\n    return factors;\n}\n//Example of applyng n=n/p (p=3)\n\
    //n=6/3=2;\n \n//return primes from 0 to n in array \nlong[] primes(long n)\n\
    {\n    long[] primes;\n    foreach(i;2..n)\n    {\n        if(isPrime(i))\n  \
    \      {\n            primes~=i;\n        }\n    }\n    return primes;\n}\n \n\
    /*\n    Examples of applyng factorize\n    >>> factorize(100L)\n    [2L, 2L, 5L,\
    \ 5L]\n    >>> factorize(101L)\n    [101L]\n    >>> factorize(12L)\n    [2L, 2L,\
    \ 3L]\n*/\n \n//check if number is prime \nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmsitlmad.d(38): Error: undefined identifier `isPrime`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmsitlmad.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    return n==1? new long[0] : \n           n<=3? new long[]{n} : \n  \
    \         typeof(n).primes.takeWhile!(a=>a<=n).filter!(a=>n%a==0L).map!(a=>a~(factorize(n/a))).array();\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm6zn8uao.d(18): Error: found `{` when expecting `:`

    /tmp/tmpm6zn8uao.d(18): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmpm6zn8uao.d(18): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm6zn8uao.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tint i = 2;\n\tint[] arr = new int[64];\n\tint j = 0;\n\twhile(n>1)\n\t\
    {\n\t\tif(n%i==0)\n\t\t{\n\t\t\tarr[j] = i;\n\t\t\tj++;\n\t\t\tn = n/i;\n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn arr;\n}\nunittest\n{\n  \
    \  alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqsor5ya8.d(33): Error: cannot implicitly convert expression `arr`
    of type `int[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsor5ya8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    n = n.abs;\n    long[] factors = [];\n    foreach(q; iota(2L, n+1))\n\
    \    {\n        if(n%q == 0)\n        {\n            while(n%q == 0)\n       \
    \     {\n                factors ~= q;\n                n /= q;\n            }\n\
    \        }\n    }\n    return factors;\n}\nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp61fj1k_n.d(19): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61fj1k_n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] primeFactors;\n    foreach(factor; iota(2L, n + 1L).array())\n\
    \    {\n        if (isPrime(factor) && n % factor == 0)\n        {\n         \
    \   auto times = n % factor == 0;\n            primeFactors ~= factor;\n     \
    \       n /= factor;\n        }\n    }\n    return primeFactors;\n}\n/*\n Return\
    \ number of prime factors of given integer.\n Input number should be equal to\
    \ the product of all factors\n >>> primeFactorsNumber(8L)\n 3\n >>> primeFactorsNumber(25L)\n\
    \ 2\n >>> primeFactorsNumber(70L)\n 3\n */\nlong primeFactorsNumber(long n) \n\
    {\n    long primeFactorsNumber = 0;\n    foreach(factor; iota(2L, n + 1L).array())\n\
    \    {\n        if (isPrime(factor) && n % factor == 0)\n        {\n         \
    \   primeFactorsNumber++;\n            n /= factor;\n        }\n    }\n    return\
    \ primeFactorsNumber;\n}\n/*\n Return greatest prime factor of given integer.\n\
    \ Input number should be equal to the product of all factors\n >>> greatestPrimeFactor(8L)\n\
    \ 2\n >>> greatestPrimeFactor(25L)\n 5\n >>> greatestPrimeFactor(70L)\n 7\n */\n\
    long greatestPrimeFactor(long n) \n{\n    long greatestPrimeFactor = 0;\n    foreach(factor;\
    \ iota(2L, n + 1L).array())\n    {\n        if (isPrime(factor) && n % factor\
    \ == 0)\n        {\n            greatestPrimeFactor = factor;\n            n /=\
    \ factor;\n        }\n    }\n    return greatestPrimeFactor;\n}\n/*\n Return array\
    \ of prime numbers up to given integer in ascending order.\n >>> primes(10L)\n\
    \ [2L, 3L, 5L, 7L]\n >>> primes(13L)\n [2L, 3L, 5L, 7L, 11L, 13L]\n >>> primes(2L)\n\
    \ [2L]\n >>> primes(1L)\n []\n >>> primes(0L)\n []\n */\nlong[] primes(long n)\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp223zqcif.d(89): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp223zqcif.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[];\n    while (n > 1) \n    {\n        foreach\
    \ (long i; 2..n + 1) \n        {\n            if (n % i == 0) \n            {\n\
    \                factors ~= i;\n                n /= i;\n                break;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n    >>> new Tree!(int)([1,2,[3,[4,5,6],7,8],9,[10,11,12]])\n\
    \         \u250C\u2500\u2500 1\n         \u2502\n         \u2514\u2500\u2500 2\n\
    \             \u2502\n             \u251C\u2500\u2500 3\n             \u2502 \
    \  \u2502\n             \u2502   \u251C\u2500\u2500 4\n             \u2502   \u2502\
    \n             \u2502   \u251C\u2500\u2500 5\n             \u2502   \u2502\n \
    \            \u2502   \u2514\u2500\u2500 6\n             \u2502\n            \
    \ \u251C\u2500\u2500 7\n             \u2502\n             \u251C\u2500\u2500 8\n\
    \             \u2502\n             \u2514\u2500\u2500 9\n                 \u2502\
    \n                 \u251C\u2500\u2500 10\n                 \u2502\n          \
    \       \u251C\u2500\u2500 11\n                 \u2502\n                 \u2514\
    \u2500\u2500 12\n*/\n/*\n    >>> string(new Tree!(int)([1,2,[3,[4,5,6],7,8],9,[10,11,12]]))\n\
    \    \"\u250C\u2500\u2500 1\\n\u2502\\n\u2514\u2500\u2500 2\\n    \u2502\\n  \
    \  \u251C\u2500\u2500 3\\n    \u2502   \u2502\\n    \u2502   \u251C\u2500\u2500\
    \ 4\\n    \u2502   \u2502\\n    \u2502   \u251C\u2500\u2500 5\\n    \u2502   \u2502\
    \\n    \u2502   \u2514\u2500\u2500 6\\n    \u2502\\n    \u251C\u2500\u2500 7\\\
    n    \u2502\\n    \u251C\u2500\u2500 8\\n    \u2502\\n    \u2514\u2500\u2500 9\\\
    n        \u2502\\n        \u251C\u2500\u2500 10\\n        \u2502\\n        \u251C\
    \u2500\u2500 11\\n        \u2502\\n        \u2514\u2500\u2500 12\"\n*/\nstruct\
    \ Tree(T)\n{\n    private T val;\n    private Tree!(T)[] children;\n    alias\
    \ val this;\n    this(T value, Tree!(T)[] children)\n    {\n        this.val =\
    \ value;\n        this.children = children;\n    }\n    this(T[] value)\n    {\n\
    \        this.val = value[0];\n        this.children = value[1..$].map!(sub =>\
    \ new Tree!(T)(sub\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5n9va13e.d(76): Error: found `unittest` when expecting `,`

    /tmp/tmp5n9va13e.d(89): Error: found `void` when expecting `,`

    /tmp/tmp5n9va13e.d(89): Error: found `{` when expecting `,`

    /tmp/tmp5n9va13e.d(89): Error: expression expected, not `}`

    /tmp/tmp5n9va13e.d(89): Error: found `End of File` when expecting `,`

    /tmp/tmp5n9va13e.d(89): Error: found `End of File` when expecting `)`

    /tmp/tmp5n9va13e.d(89): Error: found `End of File` when expecting `)` following
    template argument list

    /tmp/tmp5n9va13e.d(89): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmp5n9va13e.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp5n9va13e.d(89): Error: `}` expected following members in `struct` declaration
    at /tmp/tmp5n9va13e.d(62)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5n9va13e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n  long[] res = new long[];\n  while (n%2 == 0) \n  {\n    res ~= 2;\n \
    \   n /= 2;\n  }\n  long p = 3;\n  while (p <= n) \n  {\n    if (n%p == 0) \n\
    \    {\n      res ~= p;\n      n /= p;\n    }\n    else \n    {\n      p += 2;\n\
    \    }\n  }\n  return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo1b9z82t.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo1b9z82t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res;\n    long[] prime_factors = getPrimeFactors(n);\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfdvt3tym.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfdvt3tym.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] primes = new long[64];\n\tint ind = 0;\n\t\n\tforeach(i; 0 ..\
    \ 15) \n\t{\n\t\tif (n % ((long)i) == 0) \n\t\t{\n\t\t\tprimes[ind] = i;\n\t\t\
    \tind++;\n\t\t}\n\t}\n\t\n\treturn primes[0 .. ind];\n}\n/*\n    Implement the\
    \ function that returns a n-th char of the given string if it exists, and throws\
    \ a custom exception if it does not.\n    >>> getChar(\"abc\", 1)\n    'b'\n \
    \   >>> getChar(\"abc\", 2)\n    'c'\n    >>> import std.conv;\n    >>> try getChar(\"\
    abc\", 3) catch(StringIndexOutOfBoundsException e) writeln(e.msg)\n    String\
    \ index out of bounds\n*/\nchar getChar(string s, int index) \n{\n\tint len =\
    \ s.length;\n\tif (index >= len)\n\t\tthrow new StringIndexOutOfBoundsException(\"\
    String index out of bounds\");\n\treturn s[index];\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnzfphi0_.d(22): Error: C style cast illegal, use `cast(long)i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnzfphi0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result;\n    long m = n;\n    int i;\n    foreach(i; 2..(int)sqrt(n))\
    \ \n    {\n        if(n % i == 0) \n        {\n            n /= i;\n         \
    \   m /= i;\n            if(m == 1)\n                break;\n            result\
    \ ~= i;\n            i = 1;\n        }\n    }\n    if(m > 1)\n        result ~=\
    \ m;\n    return result;\n}\n/*\n Given an array of integers print out all combinations\
    \ of 3 numbers that sum to 0.\n    Examples:\n    >>> getZeroSum([-1, 1, 2, 3,\
    \ 4, 5, -5, -2, -3, -4])\n    [[-1, 1, 0], [-1, 3, -2], [-5, 2, 3], [-5, -3, 4],\
    \ [-2, -3, 5]]\n    >>> getZeroSum([1, 2, 3, 4, 5])\n    []\n    \n*/\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1qkti68w.d(20): Error: C style cast illegal, use `cast(int)sqrt(n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1qkti68w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    int[] res;\n    if (n % 2 == 0) \n    {\n        res ~= 2;\n      \
    \  n /= 2;\n    }\n    if (n % 2 == 0) \n    {\n        res ~= 2;\n        n /=\
    \ 2;\n    }\n    long factor = 3;\n    while (factor * factor <= n) \n    {\n\
    \        if (n % factor == 0) \n        {\n            res ~= factor;\n      \
    \      n /= factor;\n        }\n        else \n        {\n            factor +=\
    \ 2;\n        }\n    }\n    if (n > 1) \n    {\n        res ~= n;\n    }\n   \
    \ return res;\n}\n/*\n#2\nSum of the elements of matrix\n*/\nlong sum_of_matrix(long[][]\
    \ matrix) \n{\n    long sum = 0;\n    foreach (item; matrix) \n    {\n       \
    \ sum += item.sum;\n    }\n    return sum;\n}\n/*\n#3\nCheck if given number is\
    \ a prime\n*/\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6koatq0g.d(33): Error: cannot append type `long` to type `int[]`

    /tmp/tmp6koatq0g.d(43): Error: cannot append type `long` to type `int[]`

    /tmp/tmp6koatq0g.d(45): Error: cannot implicitly convert expression `res` of type
    `int[]` to `long[]`

    /tmp/tmp6koatq0g.d(56): Error: no property `sum` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6koatq0g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = new long[];\n    if (n == 1)\n    {\n        return res;\n\
    \    }\n    long d = 2;\n    for (; d <= n; ++d)\n    {\n        if (n % d ==\
    \ 0)\n        {\n            break;\n        }\n    }\n    if (d == n)\n    {\n\
    \        res ~= n;\n    }\n    else\n    {\n        res ~= d;\n        res ~=\
    \ factorize(n / d);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplauncoyi.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplauncoyi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    assert(n > 0);\n    long[] result = [];\n    long nextFactor = 2;\n\
    \    while (n > 1) \n    {\n        int count = 0;\n        while (n % nextFactor\
    \ == 0) \n        {\n            n /= nextFactor;\n            count++;\n    \
    \    }\n        result ~= repeat(nextFactor, count);\n        nextFactor++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_0hzu_4j.d(28): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_0hzu_4j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    int i = 2;\n    while (n > 1) \n    {\n \
    \       if (n % i == 0) \n        {\n            n /= i;\n            factors\
    \ ~= i;\n        }\n        else\n        {\n            i++;\n        }\n   \
    \ }\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [n];\n    long[] res;\n    foreach(i; 2..n) \n   \
    \ {\n        if (n % i == 0)\n        {\n            factors ~= factorize(i);\n\
    \            factors ~= factorize(n / i);\n            break;\n        }\n   \
    \ }\n    if (factors.length == 1)\n    {\n        res = [n];\n    }\n    else\n\
    \    {\n        res = sort(uniq(factors));\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr59jhp2j.d(34): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr59jhp2j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = long[];\n    bool[] sieve = new bool[n];\n    foreach(i;\
    \ 0..n)\n        sieve[i] = true;\n    sieve[0] = false;\n    sieve[1] = false;\n\
    \    for(int i = 2; i < n; i++)\n    {\n        if(sieve[i])\n        {\n    \
    \        while(n % i == 0)\n            {\n                factors ~= i;\n   \
    \             n /= i;\n            }\n            for(int j = i; j < n; j += i)\n\
    \                sieve[j] = false;\n        }\n    }\n    return factors;\n}\n\
    \ \n/*\n    Converts tuple to string\n    >>> tupleToString((1,2,3))\n    \"(1,\
    \ 2, 3)\"\n    >>> tupleToString((1,))\n    \"(1,)\"\n    >>> tupleToString(())\n\
    \    \"()\"\n*/\nstring tupleToString(T...)(T a) \n{\n    auto tmp = Tuple!T(a);\n\
    \    return tupleToString(tmp);\n}\n \nstring tupleToString(T...)(Tuple!T a) \n\
    {\n    string res = \"(\";\n    foreach(i, v; a)\n    {\n        if(i != 0)\n\
    \            res ~= \", \";\n        res ~= v.to!string;\n    }\n    res ~= \"\
    )\";\n    return res;\n}\n \n/*\n    Converts tuple to array\n    >>> tupleToArray((1,2,3))\n\
    \    [1, 2, 3]\n    >>> tupleToArray((1,))\n    [1]\n    >>> tupleToArray(())\n\
    \    []\n*/\nT[] tupleToArray(T...)(Tuple!T a) \n{\n    T[] res = new T[a.length];\n\
    \    foreach(i, v; a)\n        res[i] = v;\n    return res;\n}\n \n/*\n    Converts\
    \ tuple to array\n    >>> tupleToArray(3, (1,2,3))\n    [1, 2, 3]\n    >>>\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpde8eu3gn.d(17): Error: found `[` when expecting `.` following long

    /tmp/tmpde8eu3gn.d(17): Error: found `]` when expecting identifier following `long`.

    /tmp/tmpde8eu3gn.d(84): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde8eu3gn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    /*\n    int i, j, k;\n    int ans = 0;\n    int[] ans_arr = [];\n\
    \    int[] ans_arr2 = [];\n    int check = 0;\n    */\n    int count = 0;\n  \
    \  long[] result = [];\n    while(n % 2 == 0) \n    { \n        //System.out.print(2\
    \ + \" \"); \n        result ~= 2;\n        n /= 2; \n    } \n    for (long i\
    \ = 3; i <= sqrt(n); i+= 2) \n    { \n        // While i divides n, print i and\
    \ divide n \n        while (n % i == 0) \n        { \n            //System.out.print(i\
    \ + \" \"); \n            result ~= i;\n            n /= i; \n        } \n   \
    \ } \n    // This condition is to handle the case when n  \n    // is a prime\
    \ number greater than 2 \n    if (n > 2) \n        //System.out.print(n); \n \
    \       result ~= n;\n    \n    return result;\n} \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq8ely3e8.d(32): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8ely3e8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    import std.range;\n    long [] arr = [];\n    for (long i = 2; i <=\
    \ n / i; i++) \n    { \n        while (n % i == 0) \n        { \n            n\
    \ /= i; \n            arr ~= i;\n        } \n    } \n    if (n > 1) arr ~= n;\n\
    \    return arr;\n} \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    static import std.math : sqrt;\n    static import std.algorithm : takeWhile,\
    \ map, reduce;\n    static import std.array : replicate;\n    static import std.conv\
    \ : to;\n    static import std.range : iota;\n    static import std.typecons :\
    \ tuple;\n    static import std.algorithm.iteration : chunkBy;\n    static import\
    \ std.algorithm.comparison : equal;\n    static import std.meta : AliasSeq;\n\
    \    static import std.typecons : Tuple;\n    struct S\n    {\n        long n;\n\
    \        static ref ref S opCall(in ref S s)()\n        {\n            s.n +=\
    \ 2;\n            return s;\n        }\n        bool opEquals(ref const(S) s)\n\
    \        {\n            return s.n == n;\n        }\n        long opCast(alias\
    \ T)()\n        {\n            return n;\n        }\n    }\n    static ref S opCall(in\
    \ ref S s)()\n    {\n        s.n += 2;\n        return s;\n    }\n    static bool\
    \ opEquals(ref const(S) a, in ref S b)\n    {\n        return a.n == b.n;\n  \
    \  }\n    static long opCast(alias T)(ref const(S) a)\n    {\n        return a.n;\n\
    \    }\n    static ref S opCall(in ref S s,long n)()\n    {\n        s.n += n;\n\
    \        return s;\n    }\n    static bool opEquals(ref const(S) a, ref const(S)\
    \ b)\n    {\n        return a.n == b.n;\n    }\n    static long opCast(alias T)(ref\
    \ const(S) a)\n    {\n        return a.n;\n    }\n    static S s = S(3);\n   \
    \ static struct F\n    {\n        static void opCall(long n, ref long count)\n\
    \        {\n            ++count;\n        }\n    }\n    static void opCall(long\
    \ n, ref long count)\n    {\n        ++count;\n    }\n    static long f(long n)\n\
    \   \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wawmg0z.d(17): Error: static import `std` cannot have an import
    bind list

    /tmp/tmp6wawmg0z.d(18): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(18): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(18): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(19): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(20): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(21): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(22): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(23): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(24): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(25): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(26): Error: static import `std` cannot have an import bind
    list

    /tmp/tmp6wawmg0z.d(30): Erro'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [ 2L ];\n    long[] res = [];\n    long i = 1;\n \
    \   long count = 0;\n    while (n > 1)\n    {\n        while (n % factors[i] ==\
    \ 0)\n        {\n            count++;\n            n /= factors[i];\n        }\n\
    \        if (count > 0)\n        {\n            res ~= replicate(count, factors[i]);\n\
    \            count = 0;\n        }\n        else\n        {\n            i++;\n\
    \            factors ~= factors[i-1] + 1;\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvv8f2mfx.d(30): Error: undefined identifier `replicate`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvv8f2mfx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    auto ret = long[];\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcotorl0t.d(17): Error: found `[` when expecting `.` following long

    /tmp/tmpcotorl0t.d(17): Error: found `]` when expecting identifier following `long`.

    /tmp/tmpcotorl0t.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcotorl0t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    /*\n    Prime numbers are numbers greater than 1 and without positive\
    \ divisors except 1 and itself.\n    For example, 2, 3, 5, 7 and 11 are prime\
    \ numbers.\n    */\n    /*\n    In the future this task can be optimized by using\
    \ a Sieve of Eratosthenes.\n    */\n    /*\n    static if(is(typeof(n)) == long)\n\
    \    {\n        long[long] dict = new long[long];\n    }\n    else\n    {\n  \
    \      long[int] dict = new long[int];\n    }\n    */\n    long[long] dict = new\
    \ long[long];\n    long[long] primes;\n    long temp = n;\n    while(n > 1)\n\
    \    {\n        foreach(i; 0 .. primes.length)\n        {\n            if(n %\
    \ primes[i] == 0)\n            {\n                dict[primes[i]]++;\n       \
    \         n /= primes[i];\n                break;\n            }\n        }\n\
    \    }\n    long[] toReturn;\n    foreach(i; dict.byKey)\n    {\n        foreach(j;\
    \ 0 .. dict[i])\n        {\n            toReturn ~= i;\n        }\n    }\n   \
    \ assert(reduce!(\"a * b\")(toReturn) == temp);\n    return toReturn;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6g4ff1cy.d(34): Error: need size of rightmost array, not type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6g4ff1cy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] pf = [2L];\n    while (n > 1) \n    {\n        foreach (long\
    \ divisor; pf) \n        {\n            if (n % divisor == 0) \n            {\n\
    \                n /= divisor;\n                pf ~= divisor;\n             \
    \   break;\n            }\n        }\n    }\n    return pf;\n}\n/*\nreturns a\
    \ tuple of the sum of the squares of the numbers from 1 to n inclusive and the\
    \ sum of the numbers from 1 to n inclusive\n    >>> sum_of_squares_and_sum(4)\n\
    \    Tuple!(int, int)(30, 10)\n*/\nTuple!(int, int) sum_of_squares_and_sum(int\
    \ n)\n{\n    int sum = n * (n + 1) / 2;\n    int sum_of_squares = n * (n + 1)\
    \ * (2 * n + 1) / 6;\n    return Tuple!(int, int)(sum_of_squares, sum);\n}\n/*\n\
    returns a tuple containing the array of the integers from 1 to n inclusive and\
    \ the sum of the squares of the numbers from 1 to n inclusive\n    >>> sum_of_squares_and_array(4)\n\
    \    Tuple!(int[], int)([1, 2, 3, 4], 30)\n*/\nTuple!(int[], int) sum_of_squares_and_array(int\
    \ n)\n{\n    int[] array = [1..n];\n    int sum_of_squares = n * (n + 1) * (2\
    \ * n + 1) / 6;\n    return Tuple!(int[], int)(array, sum_of_squares);\n}\n/*\n\
    Change one element in the array so that the sum of the elements of the array will\
    \ increase by 1\n    >>> change_array([1, 2, 3])\n    [1, 2, 4]\n    >>> change_array([5,\
    \ 2, 3])\n    [5, 2, 4]\n    >>> change_array([5, 6, 3])\n    [5, 7, 3]\n    >>>\
    \ change_array([5, 6,\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_vrp723l.d(50): Error: comma expected separating array initializers,
    not `..`

    /tmp/tmp_vrp723l.d(50): Error: semicolon expected, not `n`

    /tmp/tmp_vrp723l.d(50): Error: found `]` when expecting `;` following statement

    /tmp/tmp_vrp723l.d(50): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp_vrp723l.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_vrp723l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] res;\n\tint x = 0;\n\tint y = 0;\n\tlong[] temp = [1L];\n\tif\
    \ (n == 1L)\n\t{\n\t\treturn [1L];\n\t}\n\telse\n\t{\n\t\t\n\t\twhile (n % 2L\
    \ == 0L)\n\t\t{\n\t\t\tres ~= 2L;\n\t\t\tn /= 2L;\n\t\t}\n\t\twhile (n % 3L ==\
    \ 0L)\n\t\t{\n\t\t\tres ~= 3L;\n\t\t\tn /= 3L;\n\t\t}\n\t\tfor (y = 5; y <= sqrt(n);\
    \ y+= 6)\n\t\t{\n\t\t\tif (n % y == 0L)\n\t\t\t{\n\t\t\t\tres ~= y;\n\t\t\t\t\
    n /= y;\n\t\t\t}\n\t\t\tif (n % (y + 2L) == 0L)\n\t\t\t{\n\t\t\t\tres ~= y + 2L;\n\
    \t\t\t\tn /= y + 2L;\n\t\t\t}\n\t\t}\n\t\tif (n > 2L)\n\t\t{\n\t\t\tres ~= n;\n\
    \t\t}\n\t\treturn res;\n\t}\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n) \n{\n\tlong[] res;\n\tint\
    \ x = 0;\n\tint y = 0;\n\tlong[] temp = [1L];\n\tif (n == 1L)\n\t{\n\t\treturn\
    \ [1L];\n\t}\n\telse\n\t{\n\t\t\n\t\twhile (n % 2\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn426oufh.d(84): Error: found `unittest` when expecting `)`

    /tmp/tmpn426oufh.d(97): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpn426oufh.d(97): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn426oufh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result;\n    foreach(prime; primes(n))\n    {\n        while(n\
    \ % prime == 0)\n        {\n            result ~= prime;\n            n /= prime;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpem575k0u.d(18): Error: undefined identifier `primes`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpem575k0u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    import std.conv;\n    import std.range;\n    import std.stdio;\n  \
    \  import std.math;\n    import std.typecons;\n    import std.algorithm;\n   \
    \ import std.array;\n    import std.numeric;\n    import std.string;\n    import\
    \ std.algorithm;\n    import std.algorithm.iteration;\n    import std.algorithm.comparison;\n\
    \    import std.math.prime;\n    import std.bigint;\n    import std.exception;\n\
    \    import std.math.bigint;\n    import std.typecons;\n    import std.traits;\n\
    \    import std.array;\n    import std.algorithm;\n    import std.range;\n   \
    \ import std.algorithm.iteration;\n    import std.typecons;\n    import std.bigint;\n\
    \    import std.exception;\n    import std.math.bigint;\n    import std.typecons;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.algorithm.iteration;\n\
    \    import std.algorithm.comparison;\n    import std.bigint;\n    import std.math.bigint;\n\
    \    import std.typecons;\n    import std.exception;\n    import std.string;\n\
    \    import std.range;\n    import std.array;\n    import std.algorithm;\n   \
    \ import std.algorithm.iteration;\n    import std.algorithm.comparison;\n    import\
    \ std.algorithm.sorting;\n    import std.math.prime;\n    import std.bigint;\n\
    \    import std.math.bigint;\n    import std.typecons;\n    import std.exception;\n\
    \    import std.math.bigint;\n    import std.typecons;\n    import std.string;\n\
    \    import std.range;\n    import std.array;\n    import std.algorithm;\n   \
    \ import std.algorithm.iteration;\n    import std.algorithm.comparison;\n    import\
    \ std.algorithm.sorting;\n    import std.math.prime;\n    import std.bigint;\n\
    \    import std.math.bigint;\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ini7fxw.d(76): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ini7fxw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long[] result; \n    long[] factors; \n    long[] pow; \n    int i;\
    \ \n    int j; \n    bool found; \n    long d; \n \n    // factorize n \n    d\
    \ = 2; \n    factors = new long[]; \n    pow = new long[]; \n    while (n > 1)\
    \ \n    { \n        if (n % d == 0) \n        { \n            // divisible \n\
    \            found = false; \n            for (i = 0; i < factors.length; i++)\
    \ \n            { \n                if (factors[i] == d) \n                { \n\
    \                    pow[i]++; \n                    found = true; \n        \
    \            break; \n                } \n            } \n            if (!found)\
    \ \n            { \n                factors ~= d; \n                pow ~= 1;\
    \ \n            } \n            n /= d; \n        } \n        else \n        {\
    \ \n            d++; \n        } \n    } \n \n    // build result \n    result\
    \ = new long[]; \n    for (i = 0; i < factors.length; i++) \n    { \n        for\
    \ (j = 0; j < pow[i]; j++) \n        { \n            result ~= factors[i]; \n\
    \        } \n    } \n    return result; \n} \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph4tv0k45.d(27): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmph4tv0k45.d(28): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmph4tv0k45.d(58): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph4tv0k45.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    import std.algorithm : while;\n    import std.math : ceil, log2;\n\
    \    import std.range : generate;\n    import std.range : while;\n    import std.typecons\
    \ : tuple;\n    auto primes = iota(2L, cast(long)ceil(log2(n)) + 1L).\n      \
    \  filter!(x => n % x == 0).\n        generate!(() => tuple(x, x)).\n        while!(p\
    \ => n % p[0] == 0).\n        map!(p => p[1]);\n    return primes;\n}\n/*\n Function\
    \ that calculates multiplication table of given prime numbers.\n    Table should\
    \ be represented as a list of lists containing number in table cells.\n    All\
    \ numbers except from the primes should be equal to 0.\n    Examples:\n    >>>\
    \ mul_table([2, 3, 5])\n    [[0, 0, 0, 0, 0, 0],\n     [0, 2, 3, 5, 6, 10],\n\
    \     [0, 3, 6, 9, 10, 15],\n     [0, 5, 9, 15, 15, 25],\n     [0, 6, 10, 15,\
    \ 18, 30],\n     [0, 10, 15, 25, 30, 50]]\n    \n    >>> mul_table([5, 7, 11])\n\
    \    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n     [0, 5, 7, 11, 14, 21, 25, 35,\
    \ 37, 55, 49, 77],\n     [0, 7, 14, 22, 28, 42, 49, 70, 77, 111, 98, 154],\n \
    \    [0, 11, 22, 33, 44, 66, 77, 110, 121, 165, 143, 231],\n     [0, 14, 28, 44,\
    \ 56, 84, 98, 140, 154, 222, 196, 308],\n     [0, 21, 42, 66, 84, 126, 147, 210,\
    \ 231, 333, 294, 462],\n     [0, 25, 49, 77, 98, 147, 175, 250, 275, 413, 350,\
    \ 550],\n     [0, 35, 70, 110, 140,\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw_wfuaxr.d(17): Error: identifier expected following `:`

    /tmp/tmpw_wfuaxr.d(17): Error: `;` expected

    /tmp/tmpw_wfuaxr.d(17): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpw_wfuaxr.d(20): Error: identifier expected following `:`

    /tmp/tmpw_wfuaxr.d(20): Error: `;` expected

    /tmp/tmpw_wfuaxr.d(20): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpw_wfuaxr.d(25): Error: identifier expected following `.`, not `while`

    /tmp/tmpw_wfuaxr.d(25): Error: semicolon expected following auto declaration,
    not `!`

    /tmp/tmpw_wfuaxr.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw_wfuaxr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long i;\n    long[] result = [];\n    for (i = 2; i <= n / i; i++)\
    \ \n    { \n        while (n % i == 0) \n        { \n            result ~= i;\
    \ \n            n /= i; \n        } \n    } \n    if (n > 1) \n    {\n       \
    \ result ~= n; \n    }\n    return result;\n}\n/*\n    Return number of unique\
    \ factors of given integer.\n    Note: 1 is a non-unique factor\n    >>> number_of_factors(8L)\n\
    \    2L\n    >>> number_of_factors(25L)\n    2L\n    >>> number_of_factors(70L)\n\
    \    3L\n*/\nlong number_of_factors(long n) \n{ \n    long i;\n    long count\
    \ = 0;\n    for (i = 2; i <= n / i; i++) \n    { \n        while (n % i == 0)\
    \ \n        { \n            count++; \n            n /= i; \n        } \n    }\
    \ \n    if (n > 1) \n    {\n        count++; \n    }\n    return count;\n}\n/*\n\
    \    Return a tuple of integers from interval [start, end], inclusively.\n   \
    \ >>> create_interval(2L, 5L)\n    (2L, 3L, 4L, 5L)\n*/\ntuple(long, long, long,\
    \ long) create_interval(long start, long end) \n{ \n    return tuple(start, start\
    \ + 1, start + 2, end);\n}\n/*\n    Return tuple of tuples, which describe all\
    \ unique factors of given integer (tuples of prime factors).\n    Note: 1 is a\
    \ non-unique factor\n    >>> unique_factors(8L)\n    ((2L,), (2L, 2L), (2L, 2L,\
    \ 2L))\n    >>> unique_factors(25L)\n    ((5L,), (5L, 5L))\n    >>> unique_factors(70L)\n\
    \    ((2L,), (2L, 5L), (\nunittest\n{\n    alias candidate = factorize;\n\n  \
    \  assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n  \
    \  assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfmrz3_g3.d(66): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpfmrz3_g3.d(66): Error: no identifier for declarator `tuple(long, long,
    long, long)`

    /tmp/tmpfmrz3_g3.d(66): Error: semicolon expected following function declaration

    /tmp/tmpfmrz3_g3.d(66): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpfmrz3_g3.d(67): Error: no identifier for declarator `create_interval(long
    start, long end)`

    /tmp/tmpfmrz3_g3.d(70): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfmrz3_g3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    auto f = new long[];\n    for (size_t i = 2; i <= n; i++) \n    {\n\
    \        while (n % i == 0) \n        {\n            f ~= i;\n            n /=\
    \ i;\n        }\n    }\n    return f;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0x3stob9.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0x3stob9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] ret = [];\n    for (long i = 2; i * i <= n; i++) \n    {\n \
    \       while (n % i == 0) \n        {\n            ret ~= i;\n            n /=\
    \ i;\n        }\n    }\n    if (n > 1) \n    {\n        ret ~= n;\n    }\n   \
    \ return ret;\n}\n/*\nConcatenate all elements of the argument array of arrays\
    \ into one array.\n    Input array may be empty or null\n    >>> flatten([])\n\
    \    []\n    >>> flatten([[2L, 3L], [4L, 5L]])\n    [2L, 3L, 4L, 5L]\n    >>>\
    \ flatten([[[1L, 2L]], [[3L, 4L]]])\n    [1L, 2L, 3L, 4L]\n*/\nT[] flatten(T)(T[][]\
    \ array)\n{\n    import std.array;\n    return array.assumeSorted.flatten;\n}\n\
    /*\n    Calculate the sum of integer elements in the array\n    >>> sum([2L, 3L,\
    \ 4L])\n    9L\n    >>> sum([])\n    0L\n*/\nlong sum(long[] array)\n{\n    long\
    \ sum = 0;\n    foreach (i; array) \n    {\n        sum += i;\n    }\n    return\
    \ sum;\n}\n/*\n    Check whether given string is a palindrome\n    >>> isPalindrome(\"\
    abba\")\n    true\n    >>> isPalindrome(\"madam\")\n    true\n    >>> isPalindrome(\"\
    aa\")\n    true\n    >>> isPalindrome(\"ab\")\n    false\n    >>> isPalindrome(\"\
    \")\n    true\n*/\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    if (n <= 1)\n    {\n        factors ~= n;\n\
    \        return factors;\n    }\n    while (n % 2 == 0)\n    {\n        factors\
    \ ~= 2;\n        n /= 2;\n    }\n    for (long i = 3; i <= ceil(sqrt(n)); i +=\
    \ 2)\n    {\n        while (n % i == 0)\n        {\n            factors ~= i;\n\
    \            n /= i;\n        }\n    }\n    if (n > 2)\n    {\n        factors\
    \ ~= n;\n    }\n    return factors;\n}\n/*\n    Array of prime factors of given\
    \ integer from smallest to largest.\n    If a factor is repeated, the number of\
    \ times it appears is omitted.\n    Input number should be equal to the product\
    \ of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n\
    \    [5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n*/\nlong[] factorize2(long\
    \ n) \n{\n    long[] factors = [];\n    if (n <= 1)\n    {\n        factors ~=\
    \ n;\n        return factors;\n    }\n    while (n % 2 == 0)\n    {\n        factors\
    \ ~= 2;\n        n /= 2;\n    }\n    for (long i = 3; i <= ceil(sqrt(n)); i +=\
    \ 2)\n    {\n        if (n % i == 0)\n        {\n            factors ~= i;\n \
    \           n /= i;\n        }\n    }\n    if (n > 2)\n    {\n        factors\
    \ ~= n;\n    }\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsqzbf8gu.d(28): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    /tmp/tmpsqzbf8gu.d(66): Error: `std.math.sqrt` called with argument types `(long)`
    matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsqzbf8gu.d", "-I/tm'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    enum int c = 0;\n    enum long[] res = new long[16];\n    while(n %\
    \ 2 == 0)\n    {\n        res[c] = 2;\n        c++;\n        n /= 2;\n    }\n\
    \    for(long i = 3; i * i <= n; i += 2)\n    {\n        while(n % i == 0)\n \
    \       {\n            res[c] = i;\n            c++;\n            n /= i;\n  \
    \      }\n    }\n    if(n > 2)\n    {\n        res[c] = n;\n        c++;\n   \
    \ }\n    return res[0..c];\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc8ihxyv5.d(21): Error: cannot modify constant `[0L, 0L, 0L, 0L,
    0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L][c]`

    /tmp/tmpc8ihxyv5.d(22): Error: cannot modify constant `0`

    /tmp/tmpc8ihxyv5.d(29): Error: cannot modify constant `[0L, 0L, 0L, 0L, 0L, 0L,
    0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L][c]`

    /tmp/tmpc8ihxyv5.d(30): Error: cannot modify constant `0`

    /tmp/tmpc8ihxyv5.d(36): Error: cannot modify constant `[0L, 0L, 0L, 0L, 0L, 0L,
    0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L][c]`

    /tmp/tmpc8ihxyv5.d(37): Error: cannot modify constant `0`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc8ihxyv5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    // result contains unique prime factors and their exponents\n    auto\
    \ result = long[];\n    auto prime = long.init;\n    // find prime factorization\
    \ for n\n    for (prime = 2; n > 1; ++prime)\n    {\n        // exponent of prime\
    \ factor\n        auto exp = long.init;\n        // divide n by prime as long\
    \ as it divides evenly\n        for (; n % prime == 0; n /= prime)\n         \
    \   ++exp;\n        // prime factor is found, add it to result\n        if (exp\
    \ > 0)\n            result ~= repeat(prime, exp);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz9u6cd5r.d(18): Error: found `[` when expecting `.` following long

    /tmp/tmpz9u6cd5r.d(18): Error: found `]` when expecting identifier following `long`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz9u6cd5r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    foreach(i; 2 .. isqrt(n) + 1)\n    {\n   \
    \     long j = i;\n        while(n % j == 0)\n        {\n            result ~=\
    \ i;\n            n /= j;\n        }\n    }\n    if(n > 1)\n        result ~=\
    \ n;\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt7p47p4t.d(18): Error: undefined identifier `isqrt`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt7p47p4t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n  if (n <= 0) \n  {\n    throw new IllegalArgumentException(\"n should\
    \ be positive number\");\n  }\n  auto factors = new long[];\n  foreach (i; 1 ..\
    \ sqrt(n) + 1) \n  {\n    if (n % i == 0) \n    {\n      if (i * i == n) \n  \
    \    {\n        factors ~= i;\n      } \n      else \n      {\n        factors\
    \ ~= i;\n        factors ~= n / i;\n      }\n    }\n  }\n  factors.sort;\n  return\
    \ factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1n0g9wzx.d(19): Error: undefined identifier `IllegalArgumentException`

    /tmp/tmp1n0g9wzx.d(21): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmp1n0g9wzx.d(22): Error: `std.math.sqrt` called with argument types `(long)`
    matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1n0g9wzx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tif (n == 0L)\n\t{\n\t\treturn [0L];\n\t}\n\tlong[] factors = [1L];\n\t\
    int i = 2;\n\twhile (n > 1)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tn /= i;\n\t\
    \t\tfactors ~= i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti += 1;\n\t\t}\n\t}\n\treturn\
    \ factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr36dnfv1.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285e5]

    ??:? void tmpr36dnfv1.__unittest_L37_C1() [0x427f72]

    ??:? void tmpr36dnfv1.__modtest() [0x428368]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cfdf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42be72]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430851]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be49]

    ??:? runModuleUnitTests [0x42cdb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a34]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tassert(n >= 1);\n\tauto result = new long[](0);\n\t\n\tforeach(d; 2 ..\
    \ n + 1) \n\t{\n\t\twhile(n % d == 0) \n\t\t{\n\t\t\tresult ~= d;\n\t\t\tn /=\
    \ d;\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [];\n    while (n % 2 == 0) \n    {\n        res ~= 2;\n\
    \        n /= 2;\n    }\n    long factor = 3;\n    while (factor <= sqrt(n)) \n\
    \    {\n        if (n % factor == 0) \n        {\n            res ~= factor;\n\
    \            n /= factor;\n        }\n        else \n        {\n            factor\
    \ += 2;\n        }\n    }\n    if (n > 1)\n        res ~= n;\n    return res;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphjxs9pnn.d(24): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphjxs9pnn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n == 0L)\n        return [0L];\n    if (n == 1L)\n        return\
    \ [1L];\n    if (n == 2L)\n        return [2L];\n    if (n == 3L)\n        return\
    \ [3L];\n    if (n == 4L)\n        return [2L, 2L];\n    if (n == 5L)\n      \
    \  return [5L];\n    if (n == 6L)\n        return [2L, 3L];\n    if (n == 7L)\n\
    \        return [7L];\n    if (n == 8L)\n        return [2L, 2L, 2L];\n    if\
    \ (n == 9L)\n        return [3L, 3L];\n    if (n == 10L)\n        return [2L,\
    \ 5L];\n    if (n == 11L)\n        return [11L];\n    if (n == 12L)\n        return\
    \ [2L, 2L, 3L];\n    if (n == 13L)\n        return [13L];\n    if (n == 14L)\n\
    \        return [2L, 7L];\n    if (n == 15L)\n        return [3L, 5L];\n    if\
    \ (n == 16L)\n        return [2L, 2L, 2L, 2L];\n    if (n == 17L)\n        return\
    \ [17L];\n    if (n == 18L)\n        return [2L, 3L, 3L];\n    if (n == 19L)\n\
    \        return [19L];\n    if (n == 20L)\n        return [2L, 2L, 5L];\n    if\
    \ (n == 21L)\n        return [3L, 7L];\n    if (n == 22L)\n        return [2L,\
    \ 11L];\n    if (n == 23L)\n        return [23L];\n    if (n == 24L)\n       \
    \ return [2L, 2L, 2L, 3L];\n    if (n == 25L)\n        return [5L, 5L];\n    if\
    \ (n == 26L)\n        return [2L, 13L];\n    if (n ==\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpky07prur.d(72): Error: expression expected, not `unittest`

    /tmp/tmpky07prur.d(73): Error: found `{` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpky07prur.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n <= 0L) \n    {\n        throw new Error(\"n must be positive\"\
    );\n    }\n    const long MAX = cast(long) sqrt(n);\n    long[] fact = new long[][]\
    \ {};\n    while (n % 2L == 0L) \n    {\n        fact ~= 2L;\n        n /= 2L;\n\
    \    }\n    long p = 3L;\n    while (p <= MAX) \n    {\n        while (n % p ==\
    \ 0L) \n        {\n            fact ~= p;\n            n /= p;\n        }\n  \
    \      p += 2L;\n    }\n    if (n > 1L) \n    {\n        fact ~= n;\n    }\n \
    \   return fact;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp32z9t7bm.d(22): Error: semicolon expected, not `{`

    /tmp/tmp32z9t7bm.d(22): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp32z9t7bm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] primeFactors = [];\n    for (long i = 2; i <= sqrt(n); i++)\
    \ \n    {\n        if (n % i == 0) \n        {\n            n /= i;\n        \
    \    primeFactors ~= i;\n            i = 1;\n        }\n    }\n    primeFactors\
    \ ~= n;\n    return primeFactors;\n}\n/*\n Return dict of prime factors of given\
    \ integer.\n    Each key of the dict is a prime factor, value is how many times\
    \ it apperas in factorization.\n    Input number should be equal to the product\
    \ of all factors.\n    >>> factors(8L)\n    [2L: 3,]\n    >>> factors(25L)\n \
    \   [5L: 2,]\n    >>> factors(70L)\n    [2L: 1, 5L: 1, 7L: 1,]\n*/\nimmutable(long[long])\
    \ factors(long n) \n{\n    auto primeFactors = factorize(n);\n    auto numFactors\
    \ = sort(primeFactors);\n    return tuple(numFactors[0], numFactors.count(numFactors[0]));\n\
    }\n/*\n Return list of prime numbers that are less than given integer.\n    >>>\
    \ [2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L,\
    \ 59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L,\
    \ 131L, 137L, 139L, 149L, 151L, 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L,\
    \ 197L, 199L, 211L, 223L, 227L, 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L,\
    \ 271L, 277L, 281L, 283L, 293L, 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L,\
    \ 353L, 359L, 367L,\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwj1srghg.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwj1srghg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    int i = 2;\n    long[] result = new long[0];\n    auto iter = new int(0);\n\
    \    while (i <= n / i) \n    {\n        auto temp = new long[0];\n        if\
    \ (n % i == 0) \n        {\n            auto j = new int(0);\n            temp\
    \ ~= i;\n            n /= i;\n            while (n % i == 0) \n            {\n\
    \                n /= i;\n                temp ~= i;\n            }\n        \
    \    result ~= temp;\n        }\n        i++;\n    }\n    if (n > 1)\n       \
    \ result ~= n;\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] primeFactors = [];\n\twhile (n % 2 == 0) \n\t{\n\t\tprimeFactors\
    \ ~= 2;\n\t\tn /= 2;\n\t}\n\tfor (int i = 3; i <= sqrt(n); i += 2) \n\t{\n\t\t\
    while (n % i == 0) \n\t\t{\n\t\t\tprimeFactors ~= i;\n\t\t\tn /= i;\n\t\t}\n\t\
    }\n\tif (n > 2)\n\t\tprimeFactors ~= n;\n\treturn primeFactors;\n}\n/*\n\tGiven\
    \ an integer, return true if and only if it is a prime number.\n\t>>> isPrime(2)\n\
    \ttrue\n\t>>> isPrime(5)\n\ttrue\n\t>>> isPrime(9)\n\tfalse\n*/\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppculpaib.d(23): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppculpaib.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\t\n\tlong[] result = new long[];\n\tif (n==0L)\n\t\tresult = [0L];\n\t\
    \n\tif (n==1L)\n\t\tresult = [1L];\n\t\n\t\n\twhile(n!=1L) \n\t{\n\t\tforeach(num;\
    \ [2L..n])\n\t\t{\n\t\t\tif(n%num==0L)\n\t\t\t{\n\t\t\t\tresult ~= num;\n\t\t\t\
    \tn = n/num;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphgs7byzw.d(28): Error: found `..` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphgs7byzw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    return [i for (i=2L..n) if ((n%i)==0L)]\n        .map!(m => iota(1L,n/m).reduce!((x,y)\
    \ => x*y)==n?m:0L)\n        .filter!(m => m != 0L);\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp63xhteh8.d(17): Error: found `for` when expecting `,`

    /tmp/tmp63xhteh8.d(17): Error: found `..` when expecting `)`

    /tmp/tmp63xhteh8.d(17): Error: found `n` when expecting `,`

    /tmp/tmp63xhteh8.d(17): Error: expression expected, not `)`

    /tmp/tmp63xhteh8.d(17): Error: found `if` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp63xhteh8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    while (n % 2 == 0) \n    {\n        factors\
    \ ~= 2;\n        n /= 2;\n    }\n    long i = 3;\n    while (i * i <= n) \n  \
    \  {\n        while (n % i == 0) \n        {\n            factors ~= i;\n    \
    \        n /= i;\n        }\n        i += 2;\n    }\n    if (n > 1) \n    {\n\
    \        factors ~= n;\n    }\n    return factors;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long[] result = new long[0]; \n    long[] tmp = new long[1]; \n  \
    \  long sqrt = (long)sqrt(n); \n    //for(size_t i = 2; i <= n; i++) \n    for(size_t\
    \ i = 2; i <= sqrt; i++) \n    { \n        if(n % i == 0) \n        { \n     \
    \       tmp[0] = i; \n            result ~= tmp; \n            //std.stdio.writeln(i);\
    \ \n            //std.stdio.writeln(result); \n            result ~= factorize(n\
    \ / i); \n            break; \n        } \n    } \n    if(result.length == 0)\
    \ \n    { \n        tmp[0] = n; \n        result ~= tmp; \n    } \n    return\
    \ result; \n} \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzuo9tzx4.d(19): Error: C style cast illegal, use `cast(long)sqrt(n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzuo9tzx4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] a = new long[3];\n    long d = 2;\n    long i = 0;\n    while\
    \ (n > 1) \n    {\n        if (n % d == 0) \n        {\n            a[i] = d;\n\
    \            i++;\n            n /= d;\n        } \n        else\n        {\n\
    \            d++;\n        }\n    }\n    return a[0..i];\n}\nunittest\n{\n   \
    \ alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpnqzld8sm.d(24): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428686]

    ??:? long[] tmpnqzld8sm.factorize(long) [0x427e89]

    ??:? void tmpnqzld8sm.__unittest_L35_C1() [0x4280bf]

    ??:? void tmpnqzld8sm.__modtest() [0x428354]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b546]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43075d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b51d]

    ??:? runModuleUnitTests [0x42c489]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n  import std.algorithm : find, map, copy;\n  long[] fact;\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ubd6bg8.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ubd6bg8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] arr;\n    int index = 0;\n    foreach(f; primes(n)) {\n    \
    \    if(n % f == 0) {\n            n /= f;\n            arr ~= f;\n        }\n\
    \    }\n    return arr;\n}\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfjd_zo96.d(19): Error: undefined identifier `primes`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfjd_zo96.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\treturn [].init;\n}\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2u5fs4ou.d(17): Error: cannot implicitly convert expression `null`
    of type `void[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2u5fs4ou.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    if (n <= 1) \n        return new long[0]; \n    else \n    { \n  \
    \      long p = 2; \n        while (p <= n) \n        { \n            if (n %\
    \ p == 0) \n            { \n                long[] f = factorize(n / p); \n  \
    \              f ~= p; \n                return f; \n            } \n        \
    \    else \n                p++; \n        } \n    } \n    return new long[0];\
    \ \n} \n/*\n Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n    Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n    Input number\
    \ should be equal to the product of all factors\n    >>> factorize(8L)\n    [2L,\
    \ 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L,\
    \ 5L, 7L]\n    \n*/\nlong[] factorize(long n) \n{ \n    if (n <= 1) \n       \
    \ return new long[0]; \n    else \n    { \n        long p = 2; \n        while\
    \ (p <= n) \n        { \n            if (n % p == 0) \n            { \n      \
    \          long[] f = factorize(n / p); \n                f ~= p; \n         \
    \       return f; \n            } \n            else \n                p++; \n\
    \        } \n    } \n    return new long[0]; \n} \n/*\n This function will be\
    \ called to test your solution. \n    >>> build_hash(8L)\n    {2L: 3L}\n    >>>\
    \ build_hash(25L)\n    {5L: 2L}\n    >>> build_hash(70L)\n    {2L: 1L, 5L: 1L,\
    \ 7L: 1L}\n    >>> build_hash(16L)\n    {2L: 4L}\n    >>> build_hash(12L)\n  \
    \  {2L: 2L, 3L: 1L}\n   \nunittest\n{\n    alias candidate = factorize;\n\n  \
    \  assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n  \
    \  assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpogvhl85m.d(69): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogvhl85m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    int size = 0;\n    long[] temp = null;\n    while (n%2 == 0)\n    {\n\
    \        n = n/2;\n        size = size + 1;\n        temp = temp ~ 2L;\n    }\n\
    \    foreach (i; 3 .. sqrt(n) + 1 by 2)\n    {\n        while (n%i == 0)\n   \
    \     {\n            n = n/i;\n            size = size + 1;\n            temp\
    \ = temp ~ i;\n        }\n    }\n    if (n > 2)\n    {\n        size = size +\
    \ 1;\n        temp = temp ~ n;\n    }\n    long[] res = new long[size];\n    res[]\
    \ = temp[];\n    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaz62sfs9.d(25): Error: found `by` when expecting `)`

    /tmp/tmpaz62sfs9.d(25): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaz62sfs9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    for (long i = 2; i <= n; ++i) \n    {\n \
    \       if (n % i == 0) \n        {\n            factors ~= i;\n            n\
    \ /= i;\n            i -= 1;\n        }\n    }\n    return factors;\n}\n/*\n Given\
    \ a matrix and a pair of indices, the function should return true, if the elements\
    \ of the indices are equal, and false otherwise.\n    >>> isequal([\"a\", \"b\"\
    , \"c\"], 0, 1)\n    false\n    >>> isequal([\"a\", \"b\", \"c\"], 0, 0)\n   \
    \ true\n    >>> isequal([[\"a\", \"c\"], [\"b\", \"d\"]], 1, 1)\n    true\n  \
    \  \n*/\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] factors;\n\tlong factor;\n\t\n\tassert(n > 0);\n\t\n\tfactors\
    \ = [];\n\t\n\twhile(n > 1) \n\t{\n\t\tfactor = 2;\n\t\t\n\t\twhile(true) \n\t\
    \t{\n\t\t\tassert(factor <= n);\n\t\t\t\n\t\t\tif (n % factor == 0)\n\t\t\t{\n\
    \t\t\t\tfactors ~= factor;\n\t\t\t\tn /= factor;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\
    \tfactor += 1;\n\t\t}\n\t}\n\t\n\treturn factors;\n}\n/*\n    Return next prime\
    \ number after given one.\n    >>> next_prime(5L)\n    7L\n    >>> next_prime(8L)\n\
    \    11L\n    >>> next_prime(14L)\n    17L\n    >>> next_prime(15L)\n    17L\n\
    */\nlong next_prime(long n) \n{\n\tassert(n > 0);\n\t\n\tif (n == 1)\n\t{\n\t\t\
    return 2;\n\t}\n\t\n\tn += 1 + n % 2;\n\t\n\twhile(true) \n\t{\n\t\tbool is_prime\
    \ = true;\n\t\t\n\t\tforeach(long i; 2..sqrt(n) + 1) \n\t\t{\n\t\t\tif (n % i\
    \ == 0) \n\t\t\t{\n\t\t\t\tis_prime = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t\t\n\t\tif (is_prime)\n\t\t{\n\t\t\treturn n;\n\t\t}\n\t\t\n\t\tn += 2;\n\t\
    }\n}\n//\n//  \u0412\u044B\u0447\u0438\u0441\u043B\u044F\u0435\u0442 \u0441\u0443\
    \u043C\u043C\u0443 \u043F\u0440\u043E\u0441\u0442\u044B\u0445 \u0447\u0438\u0441\
    \u0435\u043B \u043E\u0442 1 \u0434\u043E n (\u0447\u0438\u0441\u043B\u043E \u043F\
    \u0440\u043E\u0441\u0442\u043E\u0435, \u0435\u0441\u043B\u0438 \u043E\u043D\u043E\
    \ \u0434\u0435\u043B\u0438\u0442\u0441\u044F \u0442\u043E\u043B\u044C\u043A\u043E\
    \ \u043D\u0430 1 \u0438 \u043D\u0430 \u0441\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjuzvpgo5.d(70): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjuzvpgo5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] ret;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp07pj8rhb.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp07pj8rhb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[];\n    long temp = n;\n    long i = 2;\n\
    \    for ( ; i < n; ++i) \n    {\n        if (temp % i == 0) \n        {\n   \
    \         factors ~= i;\n            temp /= i;\n            --i;\n        }\n\
    \    }\n    if (i == n) \n    {\n        factors ~= i;\n    }\n    return factors;\n\
    }\n/*\n    Given a list of integers return the sum of the first prime numbers.\n\
    \    Exclude the prime numbers that are greater than 100.\n    >>> sum_of_first_primes([1,2,3,4,5,6,7,8,9,10])\n\
    \    17\n    >>> sum_of_first_primes([5, 2, 8, 100, 14, 2, 9, 5, 10, 11, 9, 5,\
    \ 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9,\
    \ 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11,\
    \ 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10,\
    \ 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5,\
    \ 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9,\
    \ 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2,\
    \ 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2,\nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp93m89q1m.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp93m89q1m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res;\n    foreach(i; 2 .. n + 1) \n    {\n        while(n %\
    \ i == 0) \n        {\n            res ~= i;\n            n /= i;\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    // TODO: implement\n}\n/*\n Return array of prime numbers in the given\
    \ range.\n    >>> prime_numbers(10L, 15L)\n    [11L, 13L]\n    >>> prime_numbers(10L,\
    \ 11L)\n    [11L]\n    >>> prime_numbers(10L, 10L)\n    []\n*/\nlong[] prime_numbers(long\
    \ start, long end) \n{\n    // TODO: implement\n}\n/*\n Return the number of real\
    \ roots of a quadratic equation with given coeficients.\n    Use complex roots\
    \ to check if they are real.\n    >>> num_real_roots(1L, 2L, 1L)\n    1\n    >>>\
    \ num_real_roots(1L, 1L, 1L)\n    0\n    >>> num_real_roots(1L, -2L, 1L)\n   \
    \ 2\n    >>> num_real_roots(1L, 0L, 0L)\n    2\n*/\nlong num_real_roots(long a,\
    \ long b, long c) \n{\n    // TODO: implement\n}\n/*\n Return square root of a\
    \ given positive real number (cannot use .sqrt()).\n    >>> square_root(4L)\n\
    \    2L\n    >>> square_root(2L)\n    1L\n    >>> square_root(0L)\n    0L\n  \
    \  >>> square_root(25L)\n    5L\n*/\nlong square_root(long n) \n{\n    // TODO:\
    \ implement\n}\n/*\n Return an array of the square roots of a given positive real\
    \ number (cannot use .sqrt()).\n    >>> square_roots(81L)\n    [3L, 9L]\n    >>>\
    \ square_roots(1L)\n    [1L]\n    >>> square_roots(10L)\n    [1L, 10L]\n    >>>\
    \ square_roots(100L)\n    [1L, 10L, 100L]\n*/\nlong[] square_roots(long n) \n\
    {\n    // TODO: implement\n}\n/*\n Return true if the given array of sorted numbers\
    \ contains a given number.\n    >>> binary_search([],\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9k145e20.d(78): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9k145e20.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] divisors = new long[0];\n    while (n % 2 == 0) \n    {\n  \
    \      n = n / 2;\n        divisors ~= 2;\n    }\n    // n is odd now\n    for\
    \ (long i = 3; i <= n; i += 2) \n    {\n        while (n % i == 0) \n        {\n\
    \            n = n / i;\n            divisors ~= i;\n        }\n    }\n    return\
    \ divisors;\n}\n/*\n Create list of tuples of prime factor and its exponent.\n\
    \ Input number should be equal to the product of all factors.\n >>> prime_factor_exponent(8L)\n\
    \ [(2L, 3L)]\n >>> prime_factor_exponent(25L)\n [(5L, 2L)]\n >>> prime_factor_exponent(70L)\n\
    \ [(2L, 1L), (5L, 1L), (7L, 1L)]\n*/\nTuple!(long,long)[] prime_factor_exponent(long\
    \ n) \n{\n    Tuple!(long,long)[] factor_exponent = new Tuple!(long,long)[0];\n\
    \    long[] divisors = factorize(n);\n    for (size_t i = 0; i < divisors.length;\
    \ ++i) \n    {\n        if (i == 0) \n        {\n            factor_exponent ~=\
    \ tuple(divisors[i], 1);\n        } \n        else if (divisors[i] == divisors[i\
    \ - 1]) \n        {\n            factor_exponent[$ - 1].exponent++;\n        }\
    \ \n        else \n        {\n            factor_exponent ~= tuple(divisors[i],\
    \ 1);\n        }\n    }\n    return factor_exponent;\n}\n/*\n Create list of all\
    \ prime numbers smaller than or equal to n.\n >>> prime_sieve(25L)\n [2L, 3L,\
    \ 5L, 7L, 11L, 13L, 17L, 19L, 23L]\n*/\nlong[] prime_sieve(long n) \n{\n    long[]\
    \ primes = new\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw7jyrgfp.d(73): Error: basic type expected, not `unittest`

    /tmp/tmpw7jyrgfp.d(73): Error: semicolon expected, not `unittest`

    /tmp/tmpw7jyrgfp.d(73): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7jyrgfp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [];\n    for (long d = 2; d <= n; d++)\n    {\n      \
    \  int ntimes = 0;\n        while (n % d == 0)\n        {\n            n /= d;\n\
    \            ntimes++;\n        }\n        if (ntimes > 0) res ~= repeat(d, ntimes);\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxsr29kcy.d(26): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxsr29kcy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    auto factors = [];\n    while (n % 2 == 0) {\n        factors ~= 2;\n\
    \        n /= 2;\n    }\n    foreach (d; 3..n / 2 + 1) {\n        while (n % d\
    \ == 0) {\n            factors ~= d;\n            n /= d;\n        }\n    }\n\
    \    if (n > 1)\n        factors ~= n;\n    return factors;\n}\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2om9sud0.d(19): Error: cannot append type `int` to type `void[]`

    /tmp/tmp2om9sud0.d(24): Error: cannot append type `long` to type `void[]`

    /tmp/tmp2om9sud0.d(29): Error: cannot append type `long` to type `void[]`

    /tmp/tmp2om9sud0.d(30): Error: cannot implicitly convert expression `factors`
    of type `void[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2om9sud0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long[] res = new long[];\n    while (n % 2 == 0) \n    { \n      \
    \  res ~= 2; \n        n = n / 2; \n    } \n    for (long i = 3; i <= sqrt(n);\
    \ i = i + 2) \n    { \n        while (n % i == 0) \n        { \n            res\
    \ ~= i; \n            n = n / i; \n        } \n    } \n    if (n > 2) \n     \
    \   res ~= n; \n    return res; \n} \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpebxnt176.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpebxnt176.d(23): Error: `std.math.sqrt` called with argument types `(long)`
    matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpebxnt176.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n == 0)\n    {\n        return new long[0];\n    }\n    else if\
    \ (n == 1)\n    {\n        return new long[1];\n    }\n    else\n    {\n     \
    \   long[] primeFactors = new long[20];\n        long[] primes = {2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71};\n        int\
    \ i = 0;\n        while (n > 1)\n        {\n            while (n % primes[i] ==\
    \ 0)\n            {\n                primeFactors[i] = primes[i];\n          \
    \      n /= primes[i];\n            }\n            i++;\n        }\n        return\
    \ primeFactors.filter!(a => a != 0).array;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnm6trsgc.d(28): Error: a struct is not a valid initializer for
    a `long[]`

    /tmp/tmpnm6trsgc.d(39): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnm6trsgc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [];\n    foreach(i; 2..n + 1)\n    {\n        if (n %\
    \ i == 0)\n        {\n            while (n % i == 0)\n            {\n        \
    \        res ~= i;\n                n /= i;\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    while (n % 2 == 0) \n    {\n        factors\
    \ ~= 2;\n        n /= 2;\n    }\n    long i = 3;\n    long max = cast(long)sqrt(n);\n\
    \    while (i <= max) \n    {\n        while (n % i == 0) \n        {\n      \
    \      factors ~= i;\n            n /= i;\n        }\n        i += 2;\n    }\n\
    \    if (n > 1) \n    {\n        factors ~= n;\n    }\n    return factors;\n}\n\
    /*\nReturn two points of the line in the form (a, b) where a is the slope and\
    \ b is the y-intercept.\n>>line = linePoints((3, 2), (7, 8))\n>>assert(line ==\
    \ (1, 2))\n*/\nTuple!(real, real) linePoints(Tuple!(real, real) point1, Tuple!(real,\
    \ real) point2)\n{\n    real a = (point2[1] - point1[1]) / (point2[0] - point1[0]);\n\
    \    real b = point1[1] - a * point1[0];\n    return tuple(a, b);\n}\n/*\nReturn\
    \ the sum of the digits of the given integer.\n>>> sumDigits(12)\n3\n>>> sumDigits(12345)\n\
    15\n*/\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsqqag8v4.d(24): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsqqag8v4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    // Your code goes here \n    long[] factors=new long[100];\n    long[]\
    \ res=new long[100];\n    int k=0;\n    int c=0;\n    int i=0;\n    long p=2;\n\
    \    long mul=1;\n    for(long j=2;j<=n;j++)\n    {\n        if(n%j==0)\n    \
    \    {\n            factors[k]=j;\n            k++;\n        }\n    }\n    while(i<k)\n\
    \    {\n        p=factors[i];\n        while(factors[i]==p)\n        {\n     \
    \       c++;\n            i++;\n        }\n        mul=pow(p,c);\n        res[i]=mul;\n\
    \        c=0;\n    }\n    long[] rres=new long[k];\n    for(int u=0;u<k;u++)\n\
    \    {\n        rres[u]=res[u];\n    }\n    return rres;\n} \nunittest\n{\n  \
    \  alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxsf89wfn.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x4287dd]

    ??:? void tmpxsf89wfn.__unittest_L52_C1() [0x4280ce]

    ??:? void tmpxsf89wfn.__modtest() [0x42855c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c8bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b74e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4309d9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430e88]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430965]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b725]

    ??:? runModuleUnitTests [0x42c691]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ca0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [2];\n    long[] powers = [0];\n    long prime = 2;\n\
    \    long power = 0;\n    while (n != 1) \n    {\n        while (n % prime ==\
    \ 0) \n        {\n            power++;\n            n /= prime;\n        }\n \
    \       if (power != 0) \n        {\n            factors ~= prime;\n         \
    \   powers ~= power;\n        }\n        prime++;\n        power = 0;\n    }\n\
    \    long[] result = [];\n    for (int i = 0; i < factors.length; i++) \n    {\n\
    \        for (int j = 0; j < powers[i]; j++) \n        {\n            result ~=\
    \ factors[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    // TODO: Implement\n    long[] prime_factors;\n    return prime_factors;\n\
    }\n/*\n    Print n prime numbers\n    >>> primes(10)\n    2 3 5 7 11 13 17 19\
    \ 23 29\n*/\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwpsd7xvp.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x42851d]

    ??:? void tmpwpsd7xvp.__unittest_L26_C1() [0x427ea6]

    ??:? void tmpwpsd7xvp.__modtest() [0x42829c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c52b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3be]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430551]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a00]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b395]

    ??:? runModuleUnitTests [0x42c301]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42896c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[0];\n    foreach(factor; primeFactors(n))\n\
    \    {\n        foreach(i; 0 .. factor.count)\n        {\n            result ~=\
    \ factor.prime;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpootvbo41.d(18): Error: undefined identifier `primeFactors`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpootvbo41.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] res;\n\tlong x = n;\n\tforeach(i;2..n)\n\t{\n\t\twhile(x%i==0)\n\
    \t\t{\n\t\t\tres ~= i;\n\t\t\tx/=i;\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4xfd9npn.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285ad]

    ??:? void tmp4xfd9npn.__unittest_L29_C1() [0x427f36]

    ??:? void tmp4xfd9npn.__modtest() [0x42832c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cfa7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42be3a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43088d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430819]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be11]

    ??:? runModuleUnitTests [0x42cd7d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    import std.algorithm;\n    import std.conv;\n    import std.array;\n\
    \    import std.math;\n    import std.typecons;\n    import std.math : isPrime;\n\
    \    import std.traits : isIntegral;\n    enum isPrime = n.isPrime;\n    // writeln(n,\
    \ \"is prime: \", isPrime);\n    // writeln(n, \"isIntegral: \", isIntegral!(typeof(n)));\n\
    \    static if (isIntegral!(typeof(n)))\n    {\n        static if (isPrime)\n\
    \        {\n            return [n];\n        }\n        else\n        {\n    \
    \        // long[] factors = [1, n];\n            auto primers = iota(2, n.sqrt.ceil).filter!(n.isPrime).array;\n\
    \            long[] factors = [];\n            foreach (x; primers)\n        \
    \    {\n                while (n % x == 0)\n                {\n              \
    \      factors ~= x;\n                    n /= x;\n                }\n       \
    \     }\n            if (n == 1)\n            {\n                return factors;\n\
    \            }\n            else\n            {\n                return factors\
    \ ~ [n];\n            }\n        }\n    }\n    else \n    {\n        return [];\n\
    \    }\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvhoicvli.d(22): Error: module `std.math` import `isPrime` not found

    /tmp/tmpvhoicvli.d(24): Error: declaration `tmpvhoicvli.factorize.isPrime` is
    already defined

    /tmp/tmpvhoicvli.d(36): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvhoicvli.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131,\
    \ 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,\
    \ 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,\
    \ 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\
    \ 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\
    \ 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613,\
    \ 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,\
    \ 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827,\
    \ 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\
    \ 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033,\
    \ 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117,\
    \ 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201,\nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1jo7p26b.d(18): Error: expression expected, not `unittest`

    /tmp/tmp1jo7p26b.d(19): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmp1jo7p26b.d(31): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmp1jo7p26b.d(31): Error: semicolon expected, not `main`

    /tmp/tmp1jo7p26b.d(31): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1jo7p26b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    assert(n>1);\n    long[] result;\n    long tmp = n;\n    foreach(i;2..sqrt(n))\n\
    \    {\n        if(tmp%i==0)\n        {\n            result~=i;\n            tmp/=i;\n\
    \        }\n    }\n    if(tmp!=1) result~=tmp;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3gyhma6h.d(20): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3gyhma6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res;\n    long f;\n    while (n > 1L)\n    {\n        f = smallestPrimeFactor(n);\n\
    \        res ~= f;\n        n /= f;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptid7kwvk.d(21): Error: undefined identifier `smallestPrimeFactor`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptid7kwvk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    import std.math;\n    import std.typecons;\n    long[] factors;\n \
    \   foreach(p; PrimeGenerator.primesUpTo(cast(long)sqrt(n))) \n    {\n       \
    \ while(n % p == 0) \n        {\n            n /= p;\n            factors ~= p;\n\
    \        }\n    }\n    if(n > 1) \n    {\n        factors ~= n;\n    }\n    return\
    \ factors;\n}\n/*\n Given n, return the alphabetized list of n-letter words.\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0h8ytr57.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0h8ytr57.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    auto factors = [];\n    long i = 2;\n    long remainder = n;\n    while\
    \ (i <= remainder) \n    {\n        if (remainder % i == 0) \n        {\n    \
    \        // odd number of factors\n            if ((remainder / i) % i == 0) \n\
    \            {\n                factors ~= i*i;\n                remainder /=\
    \ i*i;\n            }\n            else \n            {\n                factors\
    \ ~= i;\n                remainder /= i;\n            }\n        }\n        else\
    \ \n        {\n            ++i;\n        }\n    }\n    return factors;\n}\nstruct\
    \ Point(T) \n{\n    T x;\n    T y;\n}\n/*\n Computes the distance from the origin\
    \ to the point\n >>> getDistance(Point!int(1, 1))\n 2.0\n */\nauto getDistance(Point!T)(Point!T\
    \ p)\n{\n    return sqrt(p.x * p.x + p.y * p.y);\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg5tch9gm.d(53): Error: identifier expected for template value parameter

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg5tch9gm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    assert(n > 0);\n    long[] result = null;\n    foreach(i; 2 .. trunc(sqrt(n)))\n\
    \    {\n        if (n % i == 0)\n        {\n            long[] cur = factorize(n\
    \ / i);\n            if (cur.length > 0)\n            {\n                result\
    \ = cur;\n                break;\n            }\n        }\n    }\n    if (result\
    \ == null)\n    {\n        result = [n];\n    }\n    else\n    {\n        result\
    \ ~= 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7134b3rm.d(19): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7134b3rm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [];\n    foreach(p; takeWhile!(a => a < ceil(sqrt(n)),\
    \ primes)) \n    {\n        size_t count = 0;\n        while(n % p == 0) \n  \
    \      {\n            count++;\n            n /= p;\n        }\n        if(count\
    \ > 0) \n        {\n            long[] arr = replicate(count, p);\n          \
    \  res ~= arr;\n        }\n    }\n    if(n > 1) \n    {\n        long[] arr =\
    \ replicate(1, n);\n        res ~= arr;\n    }\n    return res;\n}\nassert(factorize(8L)\
    \ == [2L, 2L, 2L]);\nassert(factorize(25L) == [5L, 5L]);\nassert(factorize(70L)\
    \ == [2L, 5L, 7L]);\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbvo7yy1n.d(39): Error: declaration expected, not `assert`

    /tmp/tmpbvo7yy1n.d(40): Error: declaration expected, not `assert`

    /tmp/tmpbvo7yy1n.d(41): Error: declaration expected, not `assert`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbvo7yy1n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tauto res = new long[];\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdfurjptz.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdfurjptz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long sq = (long)sqrt(n);\n    ulong p = 2;\n    while (p <= sq)\n \
    \   {\n      while (n % p == 0)\n      {\n        n /= p;\n        writeln(p);\n\
    \      }\n      p++;\n    }\n    if (n != 1)\n    {\n      writeln(n);\n    }\n\
    \    return [1,1,1];\n}\nunittest\n{\n    alias candidate = factorize;\n\n   \
    \ assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n   \
    \ assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ybvc3_o.d(17): Error: C style cast illegal, use `cast(long)sqrt(n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ybvc3_o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n == 1) return [1];\n    auto primes = generatePrimes(n);\n   \
    \ import std.algorithm;\n    auto result = [].init;\n    foreach (p; primes)\n\
    \    {\n        while (n % p == 0)\n        {\n            result ~= p;\n    \
    \        n /= p;\n        }\n    }\n    return result;\n}\n \nlong[] generatePrimes(long\
    \ n)\n{\n    auto primes = [2].init;\n    foreach (i; 2..n + 1)\n    {\n     \
    \   foreach (p; primes)\n        {\n            if (i % p == 0) break;\n     \
    \       if (p * p > i)\n            {\n                primes ~= i;\n        \
    \        break;\n            }\n        }\n    }\n    return primes;\n}\n \n//test\n\
    assert(factorize(8L) == [2L, 2L, 2L]);\nassert(factorize(25L) == [5L, 5L]);\n\
    assert(factorize(70L) == [2L, 5L, 7L]);\n \nunittest\n{\n    import std.algorithm;\n\
    \    import std.stdio;\n    long[] results = [\n        [1],\n        [2],\n \
    \       [2, 2],\n        [2, 3],\n        [2, 2, 2],\n        [3, 3],\n      \
    \  [2, 5],\n        [2, 2, 3],\n        [2, 7],\n        [2, 2, 2, 2],\n     \
    \   [3, 5],\n        [2, 2, 7],\n        [2, 3, 3],\n        [2, 2, 2, 3],\n \
    \       [2, 2, 5],\n        [2, 11],\n        [2, 2, 2, 2, 2],\n        [3, 3,\
    \ 3],\n        [2, 2, 13],\n        [2, 17],\n        [2, 2, 2, 2, 3],\n     \
    \   [2, 19],\n        [2, 2, 2, 5],\n        [2, 3, 7],\n        [2, 2, 2, 2,\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpadthy586.d(51): Error: declaration expected, not `assert`

    /tmp/tmpadthy586.d(52): Error: declaration expected, not `assert`

    /tmp/tmpadthy586.d(53): Error: declaration expected, not `assert`

    /tmp/tmpadthy586.d(85): Error: expression expected, not `unittest`

    /tmp/tmpadthy586.d(86): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpadthy586.d(98): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpadthy586.d(98): Error: comma expected separating array initializers, not
    `main`

    /tmp/tmpadthy586.d(98): Error: semicolon expected, not `(`

    /tmp/tmpadthy586.d(98): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpadthy586.d(98): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpadthy586.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result;\n    int i = 2;\n    while (n > 1) \n    {\n       \
    \ if (n % i == 0) \n        {\n            result ~= i;\n            n /= i;\n\
    \        }\n        else \n        {\n            i++;\n        }\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n <= 1L)\n        return [n];\n    else if (n%2L == 0L)\n     \
    \   return [2L] ~ factorize(n/2L);\n    else if (n%3L == 0L)\n        return [3L]\
    \ ~ factorize(n/3L);\n    else\n    {\n        long p = 5L;\n        while (p*p\
    \ <= n)\n        {\n            if (n%p == 0L)\n                return [p] ~ factorize(n/p);\n\
    \            p += 2L;\n            if (n%p == 0L)\n                return [p]\
    \ ~ factorize(n/p);\n            p += 4L;\n        }\n        return [n];\n  \
    \  }\n}\n/*\n    Return array of prime numbers from 2 to n.\n    >>> sieve(10L)\n\
    \    [2L, 3L, 5L, 7L]\n*/\nlong[] sieve(long n)\n{\n    import std.conv;\n   \
    \ import std.math;\n    import std.algorithm;\n    import std.array;\n    import\
    \ std.typecons;\n    import std.range;\n    import std.bitmanip;\n    import std.meta;\n\
    \    import std.bitmanip;\n    // Generate list of numbers: 2, 3, 4, ..., n\n\
    \    Tuple!(long[], uint[]) t = tuple(iota(n - 1L).array, repeat(1u, n - 1L).array);\n\
    \    // Eliminate all multiples of 2\n    t[1][2L] = 0u;\n    long i = 3L;\n \
    \   long mul = 2L;\n    long m = n/2L;\n    // Eliminate all odd multiples of\
    \ all primes <= n\n    while (i <= m)\n    {\n        // Skip all even multiples\n\
    \        if (t[1][i] == 1u)\n        {\n            mul = 2L;\n            //\
    \ Eliminate all odd multiples\n            foreach (j; iota(i*mul, n, i*2L))\n\
    \                t[1][j] = 0u;\n        }\n        i\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprv7fxxe8.d(73): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmprv7fxxe8.d(86): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmprv7fxxe8.d(86): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprv7fxxe8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    int i = 0;\n    long[] result;\n    int j = 0;\n    foreach(d; iota(2,\
    \ n).front.takeWhile!((i) => (i * i <= n))) \n    {\n        while(n % d == 0)\
    \ \n        {\n            n /= d;\n            result[j] = d;\n            j++;\n\
    \        }\n    }\n    if(n > 1) \n    {\n        result[j] = n;\n    }\n    return\
    \ result;\n}\n/*\n Given a list of words and a string S, find all starting indices\
    \ in S which are anagrams of words in the given list.\n    >>> findAnagrams(\"\
    abxaba\", [\"ab\", \"ba\", \"abx\", \"xab\", \"axb\"])\n    [0, 3, 4]\n*/\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgrevngz5.d(20): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgrevngz5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n < 2) \n        return [n];\n    long[] factors = [2], \n    \
    \    total = [],\n        factorIdx = 0;\n    while (n > 1) \n    {\n        if\
    \ (n % factors[factorIdx] == 0) \n        {\n            n /= factors[factorIdx];\n\
    \            total ~= factors[factorIdx];\n        }\n        else \n        {\n\
    \            // Need to find the next factor, but only search up to the square\
    \ root of n.\n            // If we search any higher, then it's either n or a\
    \ factor that we've already accounted for.\n            // If a factor is found,\
    \ then it will be added to the factors array and factorIdx will be incremented.\n\
    \            long upperBound = cast(long)sqrt(n);\n            foreach (i; 2..upperBound)\
    \ \n            {\n                if (n % i == 0) \n                {\n     \
    \               factors ~= i;\n                    factorIdx++;\n            \
    \        break;\n                }\n            }\n            // If no factor\
    \ was found, then that means that n is prime and doesn't have any more factors.\n\
    \            if (i == upperBound) \n            {\n                factors ~=\
    \ n;\n                total ~= n;\n                break;\n            }\n   \
    \     }\n    }\n    return total;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp09q1lig_.d(21): Error: cannot implicitly convert expression `0`
    of type `int` to `long[]`

    /tmp/tmp09q1lig_.d(24): Error: cannot implicitly convert expression `factorIdx`
    of type `long[]` to `ulong`

    /tmp/tmp09q1lig_.d(26): Error: cannot implicitly convert expression `factorIdx`
    of type `long[]` to `ulong`

    /tmp/tmp09q1lig_.d(27): Error: cannot implicitly convert expression `factorIdx`
    of type `long[]` to `ulong`

    /tmp/tmp09q1lig_.d(34): Error: `std.math.sqrt` called with argument types `(long)`
    matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    /tmp/tmp09q1lig_.d(40): Error: `factorIdx` is not a scalar, it is a `long[]`

    /tmp/tmp09q1lig_.d(45): Error: undefined identif'
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result;\n    long i = 2;\n    while (i <= n)\n    {\n      \
    \  if (n % i == 0)\n        {\n            result ~= i;\n            n /= i;\n\
    \        }\n        else\n        {\n            i++;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] primes = new long[0L];\n    long[] factors = new long[0L];\n\
    \    for (long i = 2L; i < n; i++) \n    {\n        if (n % i == 0L) \n      \
    \  {\n            bool isPrime = true;\n            foreach (prime; primes) \n\
    \            {\n                if (i % prime == 0L) \n                {\n   \
    \                 isPrime = false;\n                    break;\n             \
    \   }\n            }\n            if (isPrime) \n            {\n             \
    \   factors ~= i;\n                n /= i;\n                i--;\n           \
    \ }\n        }\n    }\n    return factors;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6035x74_.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x428625]

    ??:? void tmp6035x74_.__unittest_L42_C1() [0x427fae]

    ??:? void tmp6035x74_.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d07b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bf0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430a59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430f08]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4309e5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bee5]

    ??:? runModuleUnitTests [0x42ce51]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a74]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    assert(n >= 2L);\n    import std.algorithm : filter, sort, uniq;\n\
    \    import std.math : isPrime;\n    import std.range : iota;\n    import std.conv\
    \ : to;\n    import std.typecons : tuple;\n    import std.array : appender;\n\
    \    import std.array : empty;\n    import std.array : array;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.internal.math.fp_utils\
    \ : pow;\n    import std.math : pow;\n    import std.range : zip;\n    import\
    \ std.typecons : tuple;\n    auto a = appender!(long[])();\n    foreach(p; 2L..n+1L)\n\
    \    {\n        if(n % p == 0L)\n        {\n            a.put(p);\n          \
    \  n /= p;\n        }\n    }\n    a.put(n);\n    return a.data;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe6dv__3s.d(19): Error: module `std.math` import `isPrime` not found

    /tmp/tmpe6dv__3s.d(28): Error: module `fp_utils` is in file ''std/internal/math/fp_utils.d''
    which cannot be read

    import path[0] = /tmp

    import path[1] = /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos

    import path[2] = /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe6dv__3s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    \n    static import std.algorithm.searching : all;\n    static import\
    \ std.array : array;\n    static import std.math : floor;\n    static import std.algorithm.sorting\
    \ : sort;\n    static import std.container : appender;\n    static import std.conv\
    \ : to;\n    static import std.range : iterate;\n    static import std.bitmanip\
    \ : setBit;\n    static import std.range : retro;\n    static import std.algorithm.iteration\
    \ : map;\n    static import std.range : cycle;\n    static import std.algorithm.comparison\
    \ : equal;\n    static import std.algorithm.searching : find;\n    static import\
    \ std.math : log2;\n    static import std.array : repeat;\n    static import std.algorithm.mutation\
    \ : pushFront;\n    static import std.algorithm.mutation : popFront;\n    static\
    \ import std.algorithm.mutation : popBack;\n    static import std.algorithm.mutation\
    \ : popBack;\n    static import std.algorithm.mutation : pushBack;\n    static\
    \ import std.typecons : tuple;\n    static import std.typecons : Tuple;\n    static\
    \ import std.array : append;\n    static import std.algorithm.mutation : splice;\n\
    \    static import std.algorithm.mutation : insert;\n    static import std.algorithm.mutation\
    \ : remove;\n    static import std.algorithm.mutation : insert;\n    static import\
    \ std.range : take;\n    static import std.range : takeExactly;\n    static import\
    \ std.algorithm.mutation : remove;\n    static import std.algorithm.mutation :\
    \ remove;\n    static import std.range : retro;\n    static import std.algorithm.mutation\
    \ : swap;\n    static import std.internal.math.primitive : ilog2;\n    static\
    \ import std.range : cycle;\n    static import std.range : only;\n    static import\
    \ std.algorithm.mutation : popFront;\n    static import std.range : take;\n  \
    \  static import std.array : array;\n    static import std.algorithm.mutation\
    \ : splice;\n    static import std\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx0_hvznj.d(18): Error: static import `std` cannot have an import
    bind list

    /tmp/tmpx0_hvznj.d(19): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(20): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(21): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(22): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(23): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(24): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(25): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(26): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(27): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(28): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(29): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0_hvznj.d(30): Erro'
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\t\n\tlong[] factors = [];\n\twhile (n % 2 == 0) \n\t{\n\t\tfactors ~=\
    \ 2;\n\t\tn /= 2;\n\t}\n\tfor (int i = 3; i <= n; i += 2) \n\t{\n\t\twhile (n\
    \ % i == 0) \n\t\t{\n\t\t\tfactors ~= i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\treturn\
    \ factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] r = new long[];\n    while (n % 2 == 0) \n    {\n        r ~=\
    \ 2;\n        n /= 2;\n    }\n    long i = 3;\n    while (i * i <= n) \n    {\n\
    \        while (n % i == 0) \n        {\n            r ~= i;\n            n /=\
    \ i;\n        }\n        i += 2;\n    }\n    if (n > 1)\n        r ~= n;\n   \
    \ return r;\n}\n/*\n    Return greatest common divisor\n    >>> gcd(12L, 18L)\n\
    \    6L\n    >>> gcd(6L, 18L)\n    6L\n    >>> gcd(6L, 12L)\n    6L\n    >>> gcd(3L,\
    \ 5L)\n    1L\n*/\nlong gcd(long a, long b) \n{\n    while (b != 0) \n    {\n\
    \        long tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return\
    \ a;\n}\n/*\n    Return least common multiple\n    >>> lcm(12L, 18L)\n    36L\n\
    \    >>> lcm(6L, 18L)\n    18L\n    >>> lcm(6L, 12L)\n    12L\n    >>> lcm(3L,\
    \ 5L)\n    15L\n*/\nlong lcm(long a, long b) \n{\n    return a * b / gcd(a, b);\n\
    }\n/*\n    Return a set of all the divisors of the given number \n    >>> divisors(36L)\n\
    \    [1L, 2L, 3L, 4L, 6L, 9L, 12L, 18L, 36L]\n    >>> divisors(9L)\n    [1L, 3L,\
    \ 9L]\n    >>> divisors(1L)\n    [1L]\n*/\nlong[] divisors(long n) \n{\n    long[]\
    \ r = new long[];\n    foreach (i; 1L .. n + 1L) \n    {\n        if (n % i ==\
    \ 0\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyizc0d4d.d(88): Error: found `unittest` when expecting `)`

    /tmp/tmpyizc0d4d.d(101): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpyizc0d4d.d(101): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyizc0d4d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long i; \n    bool[] is_prime = new bool[n + 1]; \n    for (i = 2;\
    \ i <= n; i++) { \n        is_prime[i] = true; \n    } \n    for (i = 2; i * i\
    \ <= n; i++) { \n        if (is_prime[i]) { \n            for (long j = i * i;\
    \ j <= n; j += i) { \n                is_prime[j] = false; \n            } \n\
    \        } \n    } \n    long[] primes = new long[n + 1]; \n    long len = 0;\
    \ \n    for (i = 2; i <= n; i++) { \n        if (is_prime[i]) { \n           \
    \ primes[len] = i; \n            len++; \n        } \n    } \n    long tmp = n;\
    \ \n    long[] res = new long[len]; \n    long len_res = 0; \n    for (i = 0;\
    \ i < len; i++) { \n        while (tmp % primes[i] == 0) { \n            res[len_res]\
    \ = primes[i]; \n            len_res++; \n            tmp /= primes[i]; \n   \
    \     } \n    } \n    return res[0..len_res]; \n} \n/*\n    Return array of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be arrayed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n    >>> factorize_2(8L)\n    [2L, 2L, 2L]\n    >>> factorize_2(25L)\n\
    \    [5L, 5L]\n    >>> factorize_2(70L)\n    [2L, 5L, 7L]\n*/\nlong[] factorize_2(long\
    \ n)\n{\n    auto primes = sieve_prime(n);\n    long tmp = n;\n    long[] res\
    \ = new long[primes.length];\n    long len_res = 0;\n    foreach(\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3drxr4b.d(67): Error: basic type expected, not `unittest`

    /tmp/tmph3drxr4b.d(67): Error: no identifier for declarator `_error_`

    /tmp/tmph3drxr4b.d(67): Error: found `unittest` when expecting `;`

    /tmp/tmph3drxr4b.d(80): Error: found `void` when expecting `)`

    /tmp/tmph3drxr4b.d(80): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3drxr4b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] ret;\n\tforeach(prime; PrimeSieve!(long)(sqrt(n) + 1L))\n\t{\n\
    \t\tif(n % prime == 0)\n\t\t{\n\t\t\tret ~= prime;\n\t\t\tn /= prime;\n\t\t}\n\
    \t}\n\treturn ret;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjpxycvpn.d(18): Error: template instance `PrimeSieve!long` template
    `PrimeSieve` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjpxycvpn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    import std.math;\n    auto factors = appender!(long[])();\n    auto\
    \ chkFactor = appender!(long[])();\n    long i = 2;\n    while (n > 1) \n    {\n\
    \        while (n % i == 0) \n        {\n            factors.put(i);\n       \
    \     n /= i;\n        }\n        i++;\n    }\n    return chkFactor.data;\n}\n\
    //def factorize(n):\n    //import math\n    //factors = []\n    //for i in range(2,\
    \ int(math.sqrt(n) + 1)):\n        //while n % i == 0:\n            //factors.append(i)\n\
    \            //n //= i\n    //if n > 1:\n        //factors.append(n)\n    //return\
    \ factors\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp9k3l852.d(18): Error: template instance `appender!(long[])` template
    `appender` is not defined

    /tmp/tmpp9k3l852.d(19): Error: template instance `appender!(long[])` template
    `appender` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp9k3l852.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n     /*\n         * Take a number and divide it by two until the remainder\
    \ is 0\n         * */\n    long[] primes = new long[100]; \n    int count = 0;\n\
    \    \n    while (n % 2 == 0) \n    { \n        primes[count] = 2; \n        count++;\n\
    \        n = n / 2; \n    } \n  \n    /* n must be odd at this point.  So we can\
    \ skip  \n       one element (Note i = i +2) */\n    for (long i = 3; i <= sqrt(n);\
    \ i = i + 2) \n    { \n        // While i divides n, print i and divide n \n \
    \       while (n % i == 0) \n        { \n            primes[count] = i; \n   \
    \         count++;\n            n = n / i; \n        } \n    } \n  \n    // This\
    \ condition is to handle the case when n  \n    // is a prime number greater than\
    \ 2 \n    if (n > 2) \n    {\n        primes[count] = n; \n        count++;\n\
    \    } \n    \n    primes = primes[0..count];\n    \n    return primes;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg38mlqg3.d(32): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg38mlqg3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    bool[] isPrime = new bool[n + 1];\n    for (size_t i = 0; i < isPrime.length;\
    \ i++)\n    {\n        isPrime[i] = true;\n    }\n    isPrime[0] = false;\n  \
    \  isPrime[1] = false;\n    for (size_t i = 2; i < isPrime.length; i++)\n    {\n\
    \        if (isPrime[i])\n        {\n            for (size_t j = i * i; j < isPrime.length;\
    \ j += i)\n            {\n                isPrime[j] = false;\n            }\n\
    \        }\n    }\n    bool[] isComp = new bool[n + 1];\n    for (size_t i = 0;\
    \ i < isComp.length; i++)\n    {\n        isComp[i] = false;\n    }\n    for (size_t\
    \ i = 2; i < isComp.length; i++)\n    {\n        if (isPrime[i])\n        {\n\
    \            for (size_t j = i * i; j < isComp.length; j += i)\n            {\n\
    \                isComp[j] = true;\n            }\n        }\n    }\n    bool[]\
    \ isSquare = new bool[n + 1];\n    for (size_t i = 0; i < isSquare.length; i++)\n\
    \    {\n        isSquare[i] = false;\n    }\n    for (size_t i = 2; i < isSquare.length;\
    \ i++)\n    {\n        if (isPrime[i])\n        {\n            for (size_t j =\
    \ i * i; j < isSquare.length; j += i * i)\n            {\n                isSquare[j]\
    \ = true;\n            }\n        }\n    }\n    long[] factors = [];\n    while\
    \ (isSquare[n])\n    {\n        factors ~= n;\n        n /= n;\n    }\n    while\
    \ (isComp[n])\n    {\n        for (size_t i = 2; i < isPrime.length; i++)\n  \
    \      {\n            if (isPrime[i] && n % i == 0)\n            {\n         \
    \       factors ~=\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ryhxggj.d(77): Error: expression expected, not `unittest`

    /tmp/tmp8ryhxggj.d(78): Error: found `{` when expecting `;` following statement

    /tmp/tmp8ryhxggj.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp8ryhxggj.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp8ryhxggj.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ryhxggj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    assert(n > 0);\n    if (n == 1) return new long[0];\n    long[] result\
    \ = new long[];\n    while (n % 2 == 0) {\n        result ~= 2;\n        n /=\
    \ 2;\n    }\n    while (n % 3 == 0) {\n        result ~= 3;\n        n /= 3;\n\
    \    }\n    while (n % 5 == 0) {\n        result ~= 5;\n        n /= 5;\n    }\n\
    \    long i = 7;\n    // Any composite number should be able to expressed as:\
    \ n = p*k with p a prime, k < n\n    //      Therefore, each composite number\
    \ has at least one prime factor < sqrt(n)\n    //      Therefore, for each factor\
    \ which is >= sqrt(n), if we find there is no such prime, n must be prime\n  \
    \  //      Therefore, there is no need to check for potential prime factors greater\
    \ than sqrt(n)\n    //      But we still need to check for the potential prime\
    \ factors less than sqrt(n)\n    while (i*i <= n) {\n        while (n % i == 0)\
    \ {\n            result ~= i;\n            n /= i;\n        }\n        i += 4;\n\
    \        while (n % i == 0) {\n            result ~= i;\n            n /= i;\n\
    \        }\n        i += 2;\n        while (n % i == 0) {\n            result\
    \ ~= i;\n            n /= i;\n        }\n        i += 4;\n        while (n % i\
    \ == 0) {\n            result ~= i;\n            n /= i;\n        }\n        i\
    \ += 2;\n        while (n % i == 0) {\n            result ~= i;\n            n\
    \ /= i;\n        }\n        i += 4;\n        while (n % i == 0) {\n          \
    \  result ~= i;\n            n /= i;\n        }\n        i += 6;\n        while\
    \ (n % i == 0) {\n            result ~= i;\n            n /= i;\n        }\n \
    \       i += 2;\n        while (n % i == 0) {\n            result ~=\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp25q8hzpc.d(76): Error: expression expected, not `unittest`

    /tmp/tmp25q8hzpc.d(77): Error: found `{` when expecting `;` following statement

    /tmp/tmp25q8hzpc.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp25q8hzpc.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp25q8hzpc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[0];\n    long d = 2;\n    while (n > 1) \n\
    \    {\n        int cnt = 0;\n        while (n % d == 0) \n        {\n       \
    \     cnt++;\n            n /= d;\n        }\n        if (cnt != 0)\n        \
    \    result ~= repeat(d, cnt);\n        d++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn0w2p37t.d(28): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn0w2p37t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n < 2) return new long[0];\n    import std.math;\n    auto divisors\
    \ = new long[100];\n    size_t size = 0;\n    foreach (prime; iota(2, sqrt(n)))\n\
    \    {\n        while (n % prime == 0)\n        {\n            divisors[size++]\
    \ = prime;\n            n /= prime;\n        }\n    }\n    divisors[size++] =\
    \ n;\n    return divisors[0 .. size];\n}\nsize_t[] factorize(size_t n) {\n   \
    \ if (n < 2) return new size_t[0];\n    import std.math;\n    auto divisors =\
    \ new size_t[100];\n    size_t size = 0;\n    foreach (prime; iota(2, sqrt(n)))\n\
    \    {\n        while (n % prime == 0)\n        {\n            divisors[size++]\
    \ = prime;\n            n /= prime;\n        }\n    }\n    divisors[size++] =\
    \ n;\n    return divisors[0 .. size];\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdq41z4ea.d(21): Error: undefined identifier `iota`

    /tmp/tmpdq41z4ea.d(37): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdq41z4ea.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    n = n.abs;\n    long[] result = null;\n    long[] prime;\n    ulong[]\
    \ bitP;\n    if (n < 2)\n    {\n        return [1L];\n    }\n    bitP = [0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,\
    \ 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\
    \ 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146,\
    \ 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162,\
    \ 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178,\
    \ 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,\
    \ 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210,\
    \ 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnrim43bl.d(26): Error: found `unittest` when expecting `,`

    /tmp/tmpnrim43bl.d(39): Error: found `void` when expecting `,`

    /tmp/tmpnrim43bl.d(39): Error: found `{` when expecting `,`

    /tmp/tmpnrim43bl.d(39): Error: expression expected, not `}`

    /tmp/tmpnrim43bl.d(39): Error: found `End of File` when expecting `,`

    /tmp/tmpnrim43bl.d(25): Error: found `End of File` when expecting `]`

    /tmp/tmpnrim43bl.d(39): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpnrim43bl.d(39): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnrim43bl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    \n    auto factors = new long[];\n    int p = 2;\n    while (p <= sqrt(n))\
    \ \n    {\n        while (n % p == 0) \n        {\n            factors ~= p;\n\
    \            n /= p;\n        }\n        p += 1;\n    }\n    if (n > 1) \n   \
    \ {\n        factors ~= n;\n    }\n    return factors;\n}\n/*\n    Return the\
    \ largest prime factor of given integer\n    >>> primeFactor(4L)\n    2L\n   \
    \ >>> primeFactor(9L)\n    3L\n    >>> primeFactor(31L)\n    31L\n*/\nlong primeFactor(long\
    \ n) \n{\n    return factorize(n).back;\n}\n/*\n    >>> triangular(1)\n    1\n\
    \    >>> triangular(3)\n    6\n    >>> triangular(6)\n    21\n    >>> triangular(10)\n\
    \    55\n    >>> triangular(15)\n    120\n*/\nlong triangular(long n) \n{\n  \
    \  return n * (n + 1) / 2;\n}\n/*\n>>> nthTriangular(1)\n1\n>>> nthTriangular(2)\n\
    3\n>>> nthTriangular(5)\n15\n>>> nthTriangular(10)\n55\n>>> nthTriangular(15)\n\
    120\n*/\nlong nthTriangular(long n) \n{\n    return triangular(n);\n}\n/*\n>>>\
    \ numDivisors(1)\n1\n>>> numDivisors(3)\n2\n>>> numDivisors(6)\n4\n>>> numDivisors(10)\n\
    4\n>>> numDivisors(15)\n4\n>>> numDivisors(21)\n4\n>>> numDivisors(28)\n6\n*/\n\
    long numDivisors(long n) \n{\n    auto factors = factorize(n);\n    auto ret =\
    \ 1;\n    for (int i = 0; i < factors.length; i++) \n    {\n        ret *= factors[i].count;\n\
    \    }\n    return ret;\n}\n/*\n>>> triangularNumberWithOverNDivisors(5)\n28\n\
    >>>\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeq0e1904.d(106): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeq0e1904.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long i=2;\n    auto f;\n    while(i*i<=n)\n    {\n        if(n%i==0)\n\
    \        {\n            f~=i;\n            n/=i;\n        }\n        else\n  \
    \          i++;\n    }\n    if(n>1)\n        f~=n;\n    return f;\n}\n/*\n   \
    \ Find number of divisors of given integer\n    >>> divisors(8L)\n    4\n    >>>\
    \ divisors(25L)\n    3\n    >>> divisors(70L)\n    8\n    I changed the original\
    \ to allow return of the list of divisors as well.\n*/\nTuple!(int,Tuple!(int[]))\
    \ divisors(ulong n)\n{\n    auto divs = [1];\n    ulong i=2;\n    while(i*i<=n)\n\
    \    {\n        if(n%i==0)\n        {\n            divs~=i;\n            divs~=n/i;\n\
    \        }\n        i++;\n    }\n    if(i*i==n)\n        divs~=i;\n    return\
    \ tuple(divs.length,divs);\n}\n/*\n    Given integer number n, return the greatest\
    \ odd divisor of n\n    >>> greatest_odd_divisor(8L)\n    1\n    >>> greatest_odd_divisor(25L)\n\
    \    25\n    >>> greatest_odd_divisor(70L)\n    35\n*/\nulong greatest_odd_divisor(ulong\
    \ n)\n{\n    ulong k=1;\n    ulong i=3;\n    while(i*i<=n)\n    {\n        if(n%i==0)\n\
    \            k=i;\n        i+=2;\n    }\n    if(k==1)\n        return n;\n   \
    \ return k;\n}\n/*\n    Given integer number n, return the smallest odd divisor\
    \ of n\n    >>> smallest_odd_divisor(8L)\n    1\n    >>> smallest_odd_divisor(25L)\n\
    \    5\n    >>> smallest_\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmwlnvtvn.d(18): Error: no identifier for declarator `f`

    /tmp/tmpmwlnvtvn.d(18): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpmwlnvtvn.d(83): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmwlnvtvn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong[] result = new long[]; \n\tfor (long i = 2; i <= n; ++i) \n\t{\n\
    \t\twhile (n % i == 0) \n\t\t{\n\t\t\tresult ~= i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\n Return a tuple (gcd,x,y) where gcd is the greatest common\
    \ divisor of a and b, and x,y are such that ax+by=gcd.\n    The number of iterations\
    \ should be no more than a few dozen.\n    >>> gcd(48,18)\n    (6L, 2L, -1L)\n\
    */\nTuple!(long,long,long) gcd(long a, long b) \n{\n\tif (a % b == 0)\n\t\treturn\
    \ tuple(b, 0, 1);\n\telse \n\t{\n\t\tauto r = gcd(b, a % b);\n\t\treturn tuple(r[0],\
    \ r[2], r[1] - r[2] * (a / b));\n\t}\n}\n/*\n Return a tuple (gcd,x,y) where gcd\
    \ is the greatest common divisor of a and b, and x,y are such that ax+by=gcd.\n\
    \    The number of iterations should be no more than a few dozen.\n    >>> gcd(48,18)\n\
    \    (6L, 2L, -1L)\n*/\nTuple!(long,long,long) gcd(long a, long b) \n{\n\t// http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \t// http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n\twhile (b !=\
    \ 0) \n\t{\n\t\tlong c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn tuple(a,\
    \ 0, 1);\n}\n/*\n Return a tuple (x,y) such that x*a+y*b=gcd(a,b)\n    >>> egcd(48,18)\n\
    \    (2L, -1\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzv8_sblu.d(62): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzv8_sblu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    import std.algorithm.comparison : min;\n \
    \   import std.math;\n    if (n == 0)\n        return [0L];\n    while (n != 1)\n\
    \    {\n        ulong p = primes(n, 2L);\n        result ~= p;\n        n /= p;\n\
    \    }\n    return result;\n}\n/*\n Given a list of prime factors of a positive\
    \ integer. \n Return a list of lists of factors, where each list corresponds to\
    \ a prime factor.\n Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    >>> partition(0)\n    [[0]]\n\
    \    >>> partition(1)\n    [[1]]\n    >>> partition(2)\n    [[2]]\n    >>> partition(4)\n\
    \    [[2, 2]]\n    >>> partition(5)\n    [[5]]\n    >>> partition(8)\n    [[2,\
    \ 2, 2]]\n    >>> partition(25)\n    [[5, 5]]\n    >>> partition(70)\n    [[2,\
    \ 5, 7]]\n    >>> partition(1000)\n    [[2, 2, 2, 5, 5, 5]]\n*/\nlong[][] partition(long\
    \ n)\n{\n    long[] factors = factorize(n);\n    import std.algorithm.comparison\
    \ : min;\n    import std.math;\n    import std.algorithm.comparison : min;\n \
    \   import std.math;\n    if (n == 0)\n        return [[0L]];\n    long[][] result\
    \ = [];\n    long[] primes = factors[];\n    long prime = factors[0];\n    long[]\
    \ p = [];\n    import std.algorithm.comparison : min;\n    import std.math;\n\
    \    if (n == 0)\n        return [[0L]];\n    long[][] result = [];\n    long[]\
    \ primes = factors[];\n    long prime = factors[0];\n    long[] p = [];\n    foreach\
    \ (x; factors)\n    {\n        if (x == prime)\n            p ~= x;\n        else\n\
    \        {\n            result ~= p;\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpht6rpwt6.d(82): Error: found `unittest` instead of statement

    /tmp/tmpht6rpwt6.d(95): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpht6rpwt6.d(95): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpht6rpwt6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    // 1 is not a prime number\n    if (n == 1) return new long[](0);\n\
    \    // 2 is the only even prime number\n    if (n == 2) return new long[](1)\
    \ ~= 2;\n    // else, iterate throught odd numbers\n    long[] primes = new long[](0);\n\
    \    for (long i = 3; i <= n / 2; i += 2)\n    {\n        if (n % i == 0)\n  \
    \      {\n            long[] temp = factorize(i);\n            foreach (a; temp)\n\
    \                primes ~= a;\n            n /= i;\n            temp = factorize(n);\n\
    \            foreach (a; temp)\n                primes ~= a;\n            break;\n\
    \        }\n    }\n    return primes;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt52ai_p9.d(20): Error: `new long[](1LU)` is not an lvalue and cannot
    be modified

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt52ai_p9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    \n    long[] out = [];\n    while (n%2 == 0) \n    { \n        out\
    \ ~= 2; \n        n = n/2; \n    } \n    for (long i = 3; i <= sqrt(n); i = i+2)\
    \ \n    { \n        while (n%i == 0) \n        { \n            out ~= i; \n  \
    \          n = n/i; \n        } \n    } \n    if (n > 2) \n        out ~= n; \n\
    \    return out;\n} \n    \nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw5cewlen.d(18): Error: no identifier for declarator `long[]`

    /tmp/tmpw5cewlen.d(18): Error: found `out` instead of statement

    /tmp/tmpw5cewlen.d(21): Error: found `out` instead of statement

    /tmp/tmpw5cewlen.d(28): Error: found `out` instead of statement

    /tmp/tmpw5cewlen.d(33): Error: found `out` instead of statement

    /tmp/tmpw5cewlen.d(34): Error: expression expected, not `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw5cewlen.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    static long[] factorizeR(long n, long i) \n    {\n        if (n <=\
    \ 1)\n            return [ ];\n        if (n % i == 0)\n            return [i]\
    \ ~ factorizeR(n / i, i);\n        return factorizeR(n, i + 1);\n    }\n    static\
    \ assert(isPrime(3));\n    static assert(!isPrime(4));\n    static assert(isPrime(5));\n\
    \    static assert(!isPrime(6));\n    static assert(isPrime(7));\n    static assert(!isPrime(8));\n\
    \    static assert(!isPrime(9));\n    static assert(!isPrime(10));\n    static\
    \ assert(isPrime(11));\n    static assert(!isPrime(12));\n    static assert(isPrime(13));\n\
    \    static assert(!isPrime(14));\n    static assert(!isPrime(15));\n    static\
    \ assert(!isPrime(16));\n    static assert(isPrime(17));\n    static assert(!isPrime(18));\n\
    \    static assert(isPrime(19));\n    static assert(!isPrime(20));\n    static\
    \ assert(isPrime(29));\n    static assert(isPrime(31));\n    static assert(isPrime(37));\n\
    \    static assert(isPrime(41));\n    static assert(isPrime(43));\n    static\
    \ assert(isPrime(47));\n    static assert(isPrime(53));\n    static assert(isPrime(59));\n\
    \    static assert(isPrime(61));\n    static assert(isPrime(67));\n    static\
    \ assert(isPrime(71));\n    static assert(isPrime(73));\n    static assert(isPrime(79));\n\
    \    static assert(isPrime(83));\n    static assert(isPrime(89));\n    static\
    \ assert(isPrime(97));\n    static assert(isPrime(101));\n    static assert(isPrime(103));\n\
    \    static assert(isPrime(107));\n    static assert(isPrime(109));\n    static\
    \ assert(isPrime(113));\n    static assert(isPrime(127));\n    static assert(isPrime(131));\n\
    \    static assert(isPrime(137));\n    static assert\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm7am_hpi.d(68): Error: found `unittest` when expecting `(`

    /tmp/tmpm7am_hpi.d(81): Error: found `void` when expecting `)`

    /tmp/tmpm7am_hpi.d(81): Error: found `main` when expecting `;`

    /tmp/tmpm7am_hpi.d(81): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpm7am_hpi.d(81): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm7am_hpi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] ret;\n    long i;\n    while(n % 2 == 0)\n    {\n        ret\
    \ ~= 2;\n        n /= 2;\n    }\n    for(i = 3; i <= n; i += 2)\n    {\n     \
    \   while(n % i == 0)\n        {\n            ret ~= i;\n            n /= i;\n\
    \        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[];\n    if (n == 1) \n    {\n        return\
    \ factors;\n    }\n    else \n    {\n        while (n % 2 == 0) \n        {\n\
    \            factors ~= 2;\n            n /= 2;\n        }\n        long f = 3;\n\
    \        while (f * f <= n) \n        {\n            if (n % f == 0) \n      \
    \      {\n                factors ~= f;\n                n /= f;\n           \
    \ }\n            else \n            {\n                f += 2;\n            }\n\
    \        }\n        if (n != 1) \n        {\n            factors ~= n;\n     \
    \   }\n        return factors;\n    }\n}\n/*\n    Compute the sum of all positive\
    \ integers up to and including n, that are\n    divisible by either a or b.\n\
    \    >>> sumDivisibleBy(6, 3)\n    9\n    >>> sumDivisibleBy(10, 3)\n    18\n\
    \    >>> sumDivisibleBy(10, 5)\n    15\n    >>> sumDivisibleBy(10, 5)\n    15\n\
    \    >>> sumDivisibleBy(5, 5)\n    5\n    >>> sumDivisibleBy(7, 11)\n    0\n \
    \   >>> sumDivisibleBy(11, 7)\n    0\n*/\nlong sumDivisibleBy(long n, long a,\
    \ long b) \n{\n    long sum = 0;\n    for (long i = 0; i <= n; i++) \n    {\n\
    \        if (i % a == 0 || i % b == 0) \n        {\n            sum += i;\n  \
    \      }\n    }\n    return sum;\n}\n/*\n    Given a string, return a string that\
    \ is made of the first 2 chars (if present), however include first char only if\
    \ it is 'o' and include the second only if it is 'z', so \"ozymandias\" yields\
    \ \"oz\".\n    >>> startOz(\"ozymandias\")\n    \"oz\"\n    >>> startOz(\"bzoo\"\
    )\n    \"z\"\n    >>> startOz(\"oxx\")\n    \"o\"\n    >>> startOz(\"ounce\")\n\
    \    \"o\"\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpesfxfm6r.d(79): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpesfxfm6r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9_qiuowl.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9_qiuowl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = {};\n    long[] primes = sieve(n);\n    long i = 0;\n\
    \    foreach(long prime; primes) \n    {\n        long factor = 0;\n        while\
    \ (n % prime == 0) \n        {\n            n /= prime;\n            factor++;\n\
    \        }\n        if (factor > 0) \n        {\n            factors = factors\
    \ ~ tuple(prime, factor);\n        }\n    }\n    long[] result = {};\n    foreach(tuple!(long,\
    \ long) factor; factors) \n    {\n        result = result ~ repeat(factor[0],\
    \ factor[1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9qv76c5i.d(17): Error: a struct is not a valid initializer for
    a `long[]`

    /tmp/tmp9qv76c5i.d(18): Error: undefined identifier `sieve`

    /tmp/tmp9qv76c5i.d(30): Error: cannot implicitly convert expression `tuple(prime,
    factor).opBinaryRight(factors)` of type `Tuple!(long[], long, long)` to `long[]`

    /tmp/tmp9qv76c5i.d(33): Error: a struct is not a valid initializer for a `long[]`

    /tmp/tmp9qv76c5i.d(34): Error: `tuple!(long, long)` is used as a type

    /tmp/tmp9qv76c5i.d(36): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9qv76c5i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    if (n <= 1) \n    {\n        return factors;\n\
    \    }\n    long x = 2;\n    while (n >= x * x) \n    {\n        if (n % x ==\
    \ 0) \n        {\n            factors ~= x;\n            n /= x;\n        } \n\
    \        else \n        {\n            x++;\n        }\n    }\n    factors ~=\
    \ n;\n    return factors;\n}\n/*\n Take array of numbers and return their product.\n\
    \    >>> product([1L, 2L, 3L])\n    6L\n    >>> product([0L, 2L, 3L])\n    0L\n\
    \    >>> product([100L, 200L, 300L])\n    6000000L\n    >>> product([1L, 2L, 0L,\
    \ 3L])\n    0L\n*/\nlong product(long[] numbers) \n{\n    long result = 1;\n \
    \   foreach (num; numbers) \n    {\n        result *= num;\n    }\n    return\
    \ result;\n}\n \n/*\n Take list of numbers and return sum of their squares.\n\
    \    >>> squareSum([1L, 2L, 2L])\n    9L\n    >>> squareSum([0L, 3L, 4L, 5L])\n\
    \    50L\n*/\nlong squareSum(long[] numbers) \n{\n    long result = 0;\n    foreach\
    \ (num; numbers) \n    {\n        result += num * num;\n    }\n    return result;\n\
    }\n \n/*\n Take a list of numbers and return true if first and last number are\
    \ same.\n    >>> isSame([])\n    True\n    >>> isSame([1L])\n    True\n    >>>\
    \ isSame([1L, 2L, 3L])\n    False\n    >>> isSame([1L, 2L, 1L])\n    True\n*/\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\tlong i;\n\ti = 2;\n\tlong[] res = new long[0];\n\twhile (n > 1) \n\t\
    {\n\t\tif (n % i == 0) \n\t\t{\n\t\t\tres ~= i;\n\t\t\tn /= i;\n\t\t} \n\t\telse\
    \ \n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    int i = 2;\n    while (n != 1) \n    {\n \
    \       while (n % i == 0) \n        {\n            result ~= i;\n           \
    \ n /= i;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n  long[] factors = [];\n  while (n % 2 == 0) \n  { \n    factors ~= 2;\
    \ \n    n = n/2; \n  } \n  \n  for (long i = 3; i <= sqrt(n); i = i + 2) \n  {\
    \ \n    while (n % i == 0) \n    { \n      factors ~= i; \n      n = n/i; \n \
    \   } \n  } \n  \n  if (n > 2) \n    factors ~= n; \n  return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfanl0r9k.d(24): Error: `std.math.sqrt` called with argument types
    `(long)` matches both:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1848):     `std.math.sqrt(float
    x)`

    and:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(1854):     `std.math.sqrt(real
    x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfanl0r9k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    foreach(i; 2..sqrt(n)+1) \n    {\n       \
    \ if(n % i == 0) \n        {\n            auto times = 0;\n            while(n\
    \ % i == 0) \n            {\n                n /= i;\n                times++;\n\
    \            }\n            result ~= repeat(i, times);\n        }\n    }\n  \
    \  if(n > 1) result ~= [n];\n    return result;\n}\n// test\nunittest \n{\n  \
    \  assert(factorize(8L) == [2L, 2L, 2L]);\n    assert(factorize(25L) == [5L, 5L]);\n\
    \    assert(factorize(70L) == [2L, 5L, 7L]);\n}\n \n \n \n \n \n/*\n     1) count\
    \ number of characters in input string.\n        - exclude newline character\n\
    \        - get the number by calling length method on string\n    2) count number\
    \ of words in input string.\n        - words are separated by whitespace(newline,\
    \ tab, space)\n        - use split function (returns immutable(value) array)\n\
    \        - get the number by calling length method on array\n    3) count number\
    \ of lines in input string.\n        - lines are separated by newline\n      \
    \  - use splitLines method (returns immutable(value) array)\n        - get the\
    \ number by calling length method on array\n    4) replace consecutive whitespace\
    \ with single space\n        - use replace function with regex and replace by\
    \ single space. \n        - start with newline and tab then a space, to catch\
    \ all whitespace (except newline)\n    5) create a list of words in input string\n\
    \        - use split function (returns immutable(value) array)\n        - use\
    \ foreach loop to output each word on a new line (or use writeln)\n    6) create\
    \ a list of lines in input string\n        - use splitLines method (returns immutable(value)\
    \ array)\n        - use foreach loop to output each line on a new line (or use\
    \ writeln)\n    7) split the input string into words and count each word.\n  \
    \      - use split function (returns immutable(value)\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsmf354sm.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsmf354sm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\treturn factorize(n, n);\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5p1obuc8.d(17): Error: function `tmp5p1obuc8.factorize(long n)`
    is not callable using argument types `(long, long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5p1obuc8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    if (n <= 0L) \n        throw new Error(\"factorize: n should be positive\"\
    );\n    if (n == 1L) \n        return typeof(this).init;\n    static long[] primes;\n\
    \    static long[] primeFactors;\n    static bool[] isComposite;\n    static if\
    \ (!primes) \n    {\n        enum \n        {\n            maxn = 1_000_000L\n\
    \        };\n        primes = new long[maxn / log(maxn) + 5];\n        primeFactors\
    \ = new long[maxn];\n        isComposite = new bool[maxn];\n        isComposite[0]\
    \ = true;\n        isComposite[1] = true;\n        foreach (immutable i; 2 ..\
    \ maxn) \n        {\n            if (!isComposite[i]) \n            {\n      \
    \          primes ~= i;\n                primeFactors[i] = i;\n            }\n\
    \            foreach (immutable j; 0 .. primes.length) \n            {\n     \
    \           immutable p = primes[j];\n                if (p * i >= maxn) \n  \
    \                  break;\n                isComposite[p * i] = true;\n      \
    \          primeFactors[p * i] = p;\n                if (i % p == 0) \n      \
    \              break;\n            }\n        }\n    }\n    long factor;\n   \
    \ long[] res;\n    while (n > 1L) \n    {\n        factor = primeFactors[n];\n\
    \        res ~= factor;\n        while (n % factor == 0L) \n            n /= factor;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1amrmnv_.d(29): Deprecation: use `{ }` for an empty statement,
    not `;`

    /tmp/tmp1amrmnv_.d(20): Error: `this` is not in a class or struct scope

    /tmp/tmp1amrmnv_.d(20): Error: `this` is only defined in non-static member functions,
    not `factorize`

    /tmp/tmp1amrmnv_.d(24): Error: static variable `primes` cannot be read at compile
    time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1amrmnv_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n\t\tlong i,d, reslen=0;\n\t\tlong[] res = new long[reslen];\n\t\td=2;\n\
    \t\twhile(n>1)\n\t\t{\n\t\t\tif(n%d==0)\n\t\t\t{\n\t\t\t\tres[reslen]=d;\n\t\t\
    \t\treslen++;\n\t\t\t\tn=n/d;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\td++;\n\t\t\
    \t}\n\t\t}\n\t\treturn res;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpopv7kgd2.d(24): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428666]

    ??:? long[] tmpopv7kgd2.factorize(long) [0x427e8a]

    ??:? void tmpopv7kgd2.__unittest_L35_C1() [0x427ee3]

    ??:? void tmpopv7kgd2.__modtest() [0x428338]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c693]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b526]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307b1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43073d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4fd]

    ??:? runModuleUnitTests [0x42c469]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164105
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{ \n    long[] res = new long[0];\n    long i = 2;\n    while (n > 1) \n \
    \   { \n        while (n % i == 0) \n        { \n            n /= i; \n      \
    \      res ~= i;\n        } \n        i++; \n    } \n    return res;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    auto result = [];\n    for (long i = 2; i <= n; i++) \n    {\n    \
    \    long k = 0;\n        while (n % i == 0) \n        {\n            n /= i;\n\
    \            k++;\n        }\n        result ~= replicate(i, k);\n    }\n    return\
    \ result;\n}\n/*\n    Given 3 array of integers.\n    Find 3 points(indexes of\
    \ arrays) with min distance between them.\n    We have to return the distance.\n\
    \    The test check that the distance is as small as possible.\n    >>> min_distance([1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1])\n    0\n    >>> min_distance([1, 2, 3], [1, 2,\
    \ 3], [1, 2, 3])\n    0\n    >>> min_distance([1, 3, 4], [2, 1, 5], [3, 2, 6])\n\
    \    1\n    >>> min_distance([1, 4, 5], [2, 3, 3], [3, 3, 2])\n    2\n    >>>\
    \ min_distance([3, 3, 3], [3, 3, 3], [3, 3, 3])\n    0\n    >>> min_distance([5,\
    \ 4, 3], [1, 1, 4], [1, 1, 5])\n    1\n    >>> min_distance([1, 1, 5], [1, 1,\
    \ 4], [5, 4, 3])\n    1\n*/\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpygq4dp_s.d(26): Error: undefined identifier `replicate`

    /tmp/tmpygq4dp_s.d(28): Error: cannot implicitly convert expression `result` of
    type `void[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpygq4dp_s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[];\n    while (n%2==0) \n    {\n        result\
    \ ~= 2;\n        n /= 2;\n    }\n    long p = 3;\n    while (n != 1) \n    {\n\
    \        while (n%p == 0) \n        {\n            result ~= p;\n            n\
    \ /= p;\n        }\n        p += 2;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfk1whpe3.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfk1whpe3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long result[];\n    long cnt = n;\n    long k;\n    while (cnt % 2\
    \ == 0)\n    {\n        result ~= 2;\n        cnt /= 2;\n    }\n    for (long\
    \ i = 3; i * i <= cnt; i += 2)\n    {\n        while (cnt % i == 0)\n        {\n\
    \            result ~= i;\n            cnt /= i;\n        }\n    }\n    if (cnt\
    \ > 2)\n        result ~= cnt;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: '/tmp/tmpu68jg4wx.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] result`

    /tmp/tmpu68jg4wx.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] result`

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] ret = new long[];\n    long p = 2;\n    while (n > 1) \n   \
    \ {\n        if (n % p == 0) \n        {\n            ret ~= p;\n            n\
    \ /= p;\n        } \n        else\n            p++;\n    }\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu0vwkdjk.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu0vwkdjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    auto result = new long[];\n    ulong k = cast(ulong)n;\n    while ((k\
    \ & 1) == 0) \n    {\n        result ~= 2;\n        k >>= 1;\n    }\n    foreach\
    \ (i; 3 .. (ulong)sqrt(n) + 1 by 2) \n    {\n        while (k % i == 0) \n   \
    \     {\n            result ~= i;\n            k /= i;\n        }\n    }\n   \
    \ if (k > 1)\n        result ~= k;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8bsvdcze.d(24): Error: C style cast illegal, use `cast(ulong)sqrt(n)`

    /tmp/tmp8bsvdcze.d(24): Error: found `by` when expecting `)`

    /tmp/tmp8bsvdcze.d(24): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8bsvdcze.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n  if (n <= 1) return new long[0];\n  long[] ans = [];\n  long i = 2;\n\
    \  while (n > 1) \n  {\n    if (n % i == 0) \n    {\n      ans ~= i;\n      n\
    \ /= i;\n    }\n    else \n    {\n      i += 1;\n    }\n  }\n  return ans;\n}\n\
    /*\nCheck whether given tuple is a pair of amicable numbers\n    Input should\
    \ be a tuple of two integers\n    >>> is_amicable(220L, 284L)\n    True\n    >>>\
    \ is_amicable(1184L, 1210L)\n    True\n    >>> is_amicable(10L, 20L)\n    False\n\
    */\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    import std.algorithm.sorting : sort;\n    import std.range : take;\n\
    \    import std.math : isOdd;\n    import std.typecons : tuple;\n    long[] res;\n\
    \    if(n <= 1) \n    {\n        res ~= n;\n        return res;\n    }\n    foreach(t;\
    \ take(primeFactors(n), isOdd(n))) \n    {\n        if(t[0] == 0) \n        {\n\
    \            break;\n        }\n        res ~= t[0];\n    }\n    sort(res);\n\
    \    return res;\n}\n/*\n Returns a list of tuples containing prime number and\
    \ power of it in the factorization of input number\n    >>> primeFactors(8L)\n\
    \    [(2L, 3L)]\n    >>> primeFactors(25L)\n    [(5L, 2L)]\n    >>> primeFactors(70L)\n\
    \    [(2L, 1L), (5L, 1L), (7L, 1L)]\n*/\ntuple!(long, long)[] primeFactors(long\
    \ n) \n{\n    import std.range : take;\n    import std.math : sqrt;\n    import\
    \ std.typecons : tuple;\n    if(n <= 1) \n    {\n        return [];\n    }\n \
    \   tuple!(long, long)[] res;\n    foreach(t; take(primes(), sqrt(n).ceil + 1L))\
    \ \n    {\n        long power = 0L;\n        while(n % t == 0) \n        {\n \
    \           n /= t;\n            power++;\n        }\n        if(power != 0) \n\
    \        {\n            res ~= tuple(t, power);\n        }\n    }\n    if(n !=\
    \ 1) \n    {\n        res ~= tuple(n, 1L);\n    }\n    return res;\n}\n// Returns\
    \ a lazy evaluated list of prime numbers\nlazy long[] primes() \n{\n    import\
    \ std.range : take;\n    long[] primes;\n    primes ~= 2L;\n    while(true) \n\
    \    {\n        long next\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp04dw1etj.d(77): Error: declaration expected, not `lazy`

    /tmp/tmp04dw1etj.d(81): Error: no identifier for declarator `primes`

    /tmp/tmp04dw1etj.d(81): Error: declaration expected, not `~=`

    /tmp/tmp04dw1etj.d(82): Error: declaration expected, not `while`

    /tmp/tmp04dw1etj.d(89): Error: declaration expected, not `assert`

    /tmp/tmp04dw1etj.d(90): Error: declaration expected, not `assert`

    /tmp/tmp04dw1etj.d(91): Error: declaration expected, not `assert`

    /tmp/tmp04dw1etj.d(92): Error: declaration expected, not `assert`

    /tmp/tmp04dw1etj.d(93): Error: declaration expected, not `assert`

    /tmp/tmp04dw1etj.d(94): Error: declaration expected, not `assert`

    /tmp/tmp04dw1etj.d(95): Error: declaration expected, not `assert`

    /tmp/tmp04dw1etj.d(96): Error: declaration expected, not `assert`

    /tmp/tmp04dw1etj.d(97): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp04dw1etj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res;\n    long f = n;\n    for (long i = 2; i < f + 1; i++)\n\
    \    {\n        if (f % i == 0)\n        {\n            res ~= i;\n          \
    \  while (f % i == 0)\n            {\n                f /= i;\n            }\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpa__4s7dh.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285b5]

    ??:? void tmpa__4s7dh.__unittest_L32_C1() [0x427fb9]

    ??:? void tmpa__4s7dh.__modtest() [0x428338]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cfaf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42be42]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430895]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d44]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430821]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be19]

    ??:? runModuleUnitTests [0x42cd85]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a04]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
