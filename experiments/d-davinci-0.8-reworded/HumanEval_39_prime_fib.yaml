name: HumanEval_39_prime_fib
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    prime_fib returns n-th\
  \ number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1L)\n\
  \    2L\n    >>> prime_fib(2L)\n    3L\n    >>> prime_fib(3L)\n    5L\n    >>> prime_fib(4L)\n\
  \    13L\n    >>> prime_fib(5L)\n    89L\n    \n*/\nlong prime_fib(long n) \n"
tests: "unittest\n{\n    alias candidate = prime_fib;\n\n    assert(candidate(1L)\
  \ == 2L);\n    assert(candidate(2L) == 3L);\n    assert(candidate(3L) == 5L);\n\
  \    assert(candidate(4L) == 13L);\n    assert(candidate(5L) == 89L);\n    assert(candidate(6L)\
  \ == 233L);\n    assert(candidate(7L) == 1597L);\n    assert(candidate(8L) == 28657L);\n\
  \    assert(candidate(9L) == 514229L);\n    assert(candidate(10L) == 433494437L);\n\
  }\nvoid main(){}"
completions: ["{ \n    long a = 0L; \n    long b = 1L; \n    long c = a + b; \n  \
    \  long i = 3L; \n    while (i <= n) \n    { \n        if ((c % 2L) != 0L) \n\
    \        { \n            if (is_prime(c)) \n            { \n                if\
    \ (i == n) \n                { \n                    return c; \n            \
    \    } \n                i = i + 1L; \n            } \n        } \n        a =\
    \ b; \n        b = c; \n        c = a + b; \n    } \n    return 0L; \n} \n/*",
  "    pure @safe nothrow {\n    import std.typecons;\n    import std.math;\n    immutable\
    \ Tuple!(long, long) zero = tuple(0L, 1L);\n    immutable int is_prime = 0;\n\
    \    immutable int is_fib = 1;\n    auto fib_pred = (Tuple!(long, long) a) =>\
    \ a[is_fib] == n;\n    auto fib_succ = (Tuple!(long, long) a) => tuple(a[is_fib],\
    \ a[is_fib] + a[is_prime]);\n    auto fib = iterate!(zero, fib_succ).find!(fib_pred);\n\
    \    auto prime_pred = (long a) => a.isPrime;\n    return fib.find!(prime_pred);\n\
    }", "{\n\tlong q0 = 2;\n\tlong q1 = 3;\n\tlong i = 3;\n\tlong q = 0;\n\twhile\
    \ (i <= n) \n\t{\n\t\tq = q0 + q1;\n\t\tif (isPrime(q))\n\t\t{\n\t\t\t++i;\n\t\
    \t}\n\t\tq0 = q1;\n\t\tq1 = q;\n\t}\n\treturn q;\n}", "{\n\tlong n1 = 2L;\n\t\
    long n2 = 3L;\n\tlong counter = 2L;\n\twhile (counter < n) {\n\t\tauto t = n1\
    \ + n2;\n\t\tif (isPrime(t)) {\n\t\t\tn1 = n2;\n\t\t\tn2 = t;\n\t\t\tcounter +=\
    \ 1L;\n\t\t} else {\n\t\t\tn2 = t;\n\t\t}\n\t}\n\treturn n1;\n}\n/*", "{\n   \
    \ long a = 0L;\n    long b = 1L;\n    long result = 1L;\n    long fib_num = 2L;\n\
    \    foreach (i; 0 .. n)\n    {\n        result = a + b;\n        b = a;\n   \
    \     a = result;\n        if (isPrime(result))\n        {\n            fib_num\
    \ += 1L;\n        }\n    }\n    return result;\n}\n/*", "{\n    auto is_prime(long\
    \ n) \n    {\n        if (n < 2) return false;\n        if (n == 2) return true;\n\
    \        if (n % 2 == 0) return false;\n        return all!\"a <= n && n %% a\
    \ != 0\"(iota(3L, cast(long)sqrt(n) + 1, 2));\n    }\n    auto fib = fibonacci!\"\
    n + m\"(0L, 1L);\n    long r = 0L;\n    long i = 0L;\n    while (i < n) \n   \
    \ {\n        r = fib();\n        if (is_prime(r)) \n        {\n            i++;\n\
    \        }\n    }\n    return r;\n}\n/*", "{ \n    long fib1 = 1L;\n    long fib2\
    \ = 1L;\n    long next_fib = 0L;\n    long i = 1L;\n    while (i != n) \n    {\n\
    \        next_fib = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = next_fib;\n\
    \        if (is_prime(next_fib)) \n        {\n            i++;\n        }\n  \
    \  }\n    return next_fib;\n}", "{ \n    auto primes = cache!(isPrime)(); \n \
    \   auto fibs = lazyFib(); \n    return takeWhile!(primes)(fibs).takeExactly(n).back;\
    \ \n} \n/*", "in\n{\n    import std.range;\n    import std.math;\n    //unittest\n\
    \    assert(n > 0);\n}\nbody\n{\n    // implementation\n    int i = 1;\n    long\
    \ pf = 0;\n    foreach(F; fibonacci()) {\n        if(isPrime(F)) {\n         \
    \   if(i == n) {\n                pf = F;\n                break;\n          \
    \  }\n            i++;\n        }\n    }\n    return pf;\n}", "{\n    long i =\
    \ 3L;\n    long prev = 2L;\n    long curr = 3L;\n    long fib = 5L;\n    for (;\
    \ i < n; ++i) {\n        prev = curr;\n        curr = fib;\n        fib = prev\
    \ + curr;\n        if (fib.isPrime()) {\n            ++i;\n        }\n    }\n\
    \    return fib;\n}", "{ \n  long f1 = 1;\n  long f2 = 1;\n  long f = 1;\n  long\
    \ i = 2;\n  long t = 2;\n  if (n == 1) {\n    return 2;\n  }\n  else if (n ==\
    \ 2) {\n    return 3;\n  }\n  while (true) {\n    f = f1 + f2;\n    f1 = f2;\n\
    \    f2 = f;\n    if (f > 1023456789) {\n      if (is_prime(f)) {\n        i++;\n\
    \        if (i == n) {\n          return f;\n        }\n      }\n    }\n    else\
    \ {\n      t++;\n      if (is_prime(t)) {\n        i++;\n        if (i == n) {\n\
    \          return t;\n        }\n      }\n    }\n  }\n}\n/*", "{\n    long prev_fib\
    \ = 0L;\n    long fib = 1L;\n    long prime_fib = 2L;\n    long fib_index = 1L;\n\
    \    long prime_index = 1L;\n    tuple[long prev_fib, long fib, long fib_index]\
    \ res;\n    while(prime_index <= n)\n    {\n        if(is_prime(fib))\n      \
    \  {\n            prime_fib = fib;\n            prime_index += 1L;\n        }\n\
    \        res = update_fib(prev_fib, fib, fib_index);\n        prev_fib = res[0];\n\
    \        fib = res[1];\n        fib_index = res[2];\n    }\n    return prime_fib;\n\
    }", "{\n    import std.range, std.algorithm, std.conv, std.math, std.stdio;\n\
    \    import std.array, std.typecons;\n    static long[] a = [2L, 3L];\n    static\
    \ long currentIndex = 0L;\n    static long currentSize = 2L;\n    static long\
    \ currentAdd = 0L;\n    static long currentPrime = 2L;\n    static long currentPrimeIndex\
    \ = 0L;\n    static long[] primes = [2L, 3L];\n    static long lastPrime = 0L;\n\
    \    static long lastPrimeIndex = 0L;\n    static long[] factors = new long[2];\n\
    \    static long[] factors2 = new long[2];\n    static long[] temp = new long[2];\n\
    \    static long maxPrime = 0L;\n    static bool isPrime = true;\n    static long[]\
    \ tempfactors = new long[2];\n    static long[] primefibs = new long[2];\n   \
    \ static long currentPrimeFib = 2L;\n    static long currentPrimeFibIndex = 0L;\n\
    \    static long[] tempPrimeFibs = new long[2];\n    static long[] tempPrimeFibs2\
    \ = new long[2];\n    static long[] tempPrimeFibs3 = new long[2];\n    static\
    \ long[] tempPrimeFibs4 = new long[2];\n    static long[] tempPrimeFibs5 = new\
    \ long[2];\n    static long[] tempPrimeFibs6 = new long[2];\n    static long[]\
    \ tempPrimeFibs7 = new long[2];\n    static long[] tempPrimeFibs8 = new long[2];\n\
    \    static long[] tempPrimeFibs9 = new long[2];\n    static long[] tempPrimeFibs10\
    \ = new long[2];\n    static long[] tempPrimeFibs11 = new long[2];\n    static\
    \ long[] tempPrimeFibs12 = new long[2];\n    static long[] tempPrimeFibs13 = new\
    \ long[2];\n    static long[] tempPrimeFibs14 = new long[2];\n    static long[]\
    \ tempPrimeFibs15 = new long[2];\n    static long[] tempPrimeF", "{ \n    long\
    \ a = 2L; \n    long b = 3L; \n    long c = 5L; \n    long i = 5L; \n    long\
    \ x = 0L; \n  \n    if (n < 1L) \n        return 0L; \n    if (n == 1L) \n   \
    \     return 2L; \n    if (n == 2L) \n        return 3L; \n    if (n == 3L) \n\
    \        return 5L; \n    while (true) \n    { \n        x = a + b; \n       \
    \ a = b; \n        b = c; \n        c = x; \n        i += 1L; \n        if (i\
    \ == n) \n            return x; \n    } \n}\n/*", "{\n    import std.math;", "{\
    \ \n    if (n < 1L) \n    {\n        return n;\n    } \n    auto last = tuple(0L,\
    \ 1L); \n    foreach (i; 1L .. n) \n    { \n        last = tuple(last[1], last[0]\
    \ + last[1]); \n        if (isPrime(last[1])) \n        {\n            n--; \n\
    \        } \n    } \n    return last[1]; \n}\n ", "{\n    ", "{\n\t\n\tlong a\
    \ = 0L;\n\tlong b = 1L;\n\tlong c = 1L;\n\tlong i = 0L;\n\tauto prime = new PrimeNumbers();\n\
    \twhile (i < n) \n\t{\n\t\tif (isPrime(c)) \n\t\t{\n\t\t\ti += 1L;\n\t\t}\n\t\t\
    c = a + b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn c;\n\t\n}", "{\n    long a =\
    \ 0L;\n    long b = 1L;\n    long c = a + b;\n    long len = 1L;\n    while (true)\
    \ \n    {\n        if (len == n) \n        {\n            return c;\n        }\n\
    \        a = b;\n        b = c;\n        c = a + b;\n        if (c.isPrime) \n\
    \        {\n            len++;\n        }\n    }\n    return -1L;\n}\n/*", "{\n\
    \    long fibn = fibonacci!(long)(n);\n    return isPrime(fibn) ? fibn : prime_fib(n\
    \ + 1L);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
