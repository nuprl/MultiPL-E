name: HumanEval_39_prime_fib
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    prime_fib returns n-th\
  \ number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1L)\n\
  \    2L\n    >>> prime_fib(2L)\n    3L\n    >>> prime_fib(3L)\n    5L\n    >>> prime_fib(4L)\n\
  \    13L\n    >>> prime_fib(5L)\n    89L\n    \n*/\nlong prime_fib(long n) \n"
tests: "unittest\n{\n    alias candidate = prime_fib;\n\n    assert(candidate(1L)\
  \ == 2L);\n    assert(candidate(2L) == 3L);\n    assert(candidate(3L) == 5L);\n\
  \    assert(candidate(4L) == 13L);\n    assert(candidate(5L) == 89L);\n    assert(candidate(6L)\
  \ == 233L);\n    assert(candidate(7L) == 1597L);\n    assert(candidate(8L) == 28657L);\n\
  \    assert(candidate(9L) == 514229L);\n    assert(candidate(10L) == 433494437L);\n\
  }\nvoid main(){}"
completions: ["{ \n    long a = 0L; \n    long b = 1L; \n    long c = a + b; \n  \
    \  long i = 3L; \n    while (i <= n) \n    { \n        if ((c % 2L) != 0L) \n\
    \        { \n            if (is_prime(c)) \n            { \n                if\
    \ (i == n) \n                { \n                    return c; \n            \
    \    } \n                i = i + 1L; \n            } \n        } \n        a =\
    \ b; \n        b = c; \n        c = a + b; \n    } \n    return 0L; \n} \n/*",
  "    pure @safe nothrow {\n    import std.typecons;\n    import std.math;\n    immutable\
    \ Tuple!(long, long) zero = tuple(0L, 1L);\n    immutable int is_prime = 0;\n\
    \    immutable int is_fib = 1;\n    auto fib_pred = (Tuple!(long, long) a) =>\
    \ a[is_fib] == n;\n    auto fib_succ = (Tuple!(long, long) a) => tuple(a[is_fib],\
    \ a[is_fib] + a[is_prime]);\n    auto fib = iterate!(zero, fib_succ).find!(fib_pred);\n\
    \    auto prime_pred = (long a) => a.isPrime;\n    return fib.find!(prime_pred);\n\
    }", "{\n\tlong q0 = 2;\n\tlong q1 = 3;\n\tlong i = 3;\n\tlong q = 0;\n\twhile\
    \ (i <= n) \n\t{\n\t\tq = q0 + q1;\n\t\tif (isPrime(q))\n\t\t{\n\t\t\t++i;\n\t\
    \t}\n\t\tq0 = q1;\n\t\tq1 = q;\n\t}\n\treturn q;\n}", "{\n\tlong n1 = 2L;\n\t\
    long n2 = 3L;\n\tlong counter = 2L;\n\twhile (counter < n) {\n\t\tauto t = n1\
    \ + n2;\n\t\tif (isPrime(t)) {\n\t\t\tn1 = n2;\n\t\t\tn2 = t;\n\t\t\tcounter +=\
    \ 1L;\n\t\t} else {\n\t\t\tn2 = t;\n\t\t}\n\t}\n\treturn n1;\n}\n/*", "{\n   \
    \ long a = 0L;\n    long b = 1L;\n    long result = 1L;\n    long fib_num = 2L;\n\
    \    foreach (i; 0 .. n)\n    {\n        result = a + b;\n        b = a;\n   \
    \     a = result;\n        if (isPrime(result))\n        {\n            fib_num\
    \ += 1L;\n        }\n    }\n    return result;\n}\n/*", "{\n    auto is_prime(long\
    \ n) \n    {\n        if (n < 2) return false;\n        if (n == 2) return true;\n\
    \        if (n % 2 == 0) return false;\n        return all!\"a <= n && n %% a\
    \ != 0\"(iota(3L, cast(long)sqrt(n) + 1, 2));\n    }\n    auto fib = fibonacci!\"\
    n + m\"(0L, 1L);\n    long r = 0L;\n    long i = 0L;\n    while (i < n) \n   \
    \ {\n        r = fib();\n        if (is_prime(r)) \n        {\n            i++;\n\
    \        }\n    }\n    return r;\n}\n/*", "{ \n    long fib1 = 1L;\n    long fib2\
    \ = 1L;\n    long next_fib = 0L;\n    long i = 1L;\n    while (i != n) \n    {\n\
    \        next_fib = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = next_fib;\n\
    \        if (is_prime(next_fib)) \n        {\n            i++;\n        }\n  \
    \  }\n    return next_fib;\n}", "{ \n    auto primes = cache!(isPrime)(); \n \
    \   auto fibs = lazyFib(); \n    return takeWhile!(primes)(fibs).takeExactly(n).back;\
    \ \n} \n/*", "in\n{\n    import std.range;\n    import std.math;\n    //unittest\n\
    \    assert(n > 0);\n}\nbody\n{\n    // implementation\n    int i = 1;\n    long\
    \ pf = 0;\n    foreach(F; fibonacci()) {\n        if(isPrime(F)) {\n         \
    \   if(i == n) {\n                pf = F;\n                break;\n          \
    \  }\n            i++;\n        }\n    }\n    return pf;\n}", "{\n    long i =\
    \ 3L;\n    long prev = 2L;\n    long curr = 3L;\n    long fib = 5L;\n    for (;\
    \ i < n; ++i) {\n        prev = curr;\n        curr = fib;\n        fib = prev\
    \ + curr;\n        if (fib.isPrime()) {\n            ++i;\n        }\n    }\n\
    \    return fib;\n}", "{ \n  long f1 = 1;\n  long f2 = 1;\n  long f = 1;\n  long\
    \ i = 2;\n  long t = 2;\n  if (n == 1) {\n    return 2;\n  }\n  else if (n ==\
    \ 2) {\n    return 3;\n  }\n  while (true) {\n    f = f1 + f2;\n    f1 = f2;\n\
    \    f2 = f;\n    if (f > 1023456789) {\n      if (is_prime(f)) {\n        i++;\n\
    \        if (i == n) {\n          return f;\n        }\n      }\n    }\n    else\
    \ {\n      t++;\n      if (is_prime(t)) {\n        i++;\n        if (i == n) {\n\
    \          return t;\n        }\n      }\n    }\n  }\n}\n/*", "{\n    long prev_fib\
    \ = 0L;\n    long fib = 1L;\n    long prime_fib = 2L;\n    long fib_index = 1L;\n\
    \    long prime_index = 1L;\n    tuple[long prev_fib, long fib, long fib_index]\
    \ res;\n    while(prime_index <= n)\n    {\n        if(is_prime(fib))\n      \
    \  {\n            prime_fib = fib;\n            prime_index += 1L;\n        }\n\
    \        res = update_fib(prev_fib, fib, fib_index);\n        prev_fib = res[0];\n\
    \        fib = res[1];\n        fib_index = res[2];\n    }\n    return prime_fib;\n\
    }", "{\n    import std.range, std.algorithm, std.conv, std.math, std.stdio;\n\
    \    import std.array, std.typecons;\n    static long[] a = [2L, 3L];\n    static\
    \ long currentIndex = 0L;\n    static long currentSize = 2L;\n    static long\
    \ currentAdd = 0L;\n    static long currentPrime = 2L;\n    static long currentPrimeIndex\
    \ = 0L;\n    static long[] primes = [2L, 3L];\n    static long lastPrime = 0L;\n\
    \    static long lastPrimeIndex = 0L;\n    static long[] factors = new long[2];\n\
    \    static long[] factors2 = new long[2];\n    static long[] temp = new long[2];\n\
    \    static long maxPrime = 0L;\n    static bool isPrime = true;\n    static long[]\
    \ tempfactors = new long[2];\n    static long[] primefibs = new long[2];\n   \
    \ static long currentPrimeFib = 2L;\n    static long currentPrimeFibIndex = 0L;\n\
    \    static long[] tempPrimeFibs = new long[2];\n    static long[] tempPrimeFibs2\
    \ = new long[2];\n    static long[] tempPrimeFibs3 = new long[2];\n    static\
    \ long[] tempPrimeFibs4 = new long[2];\n    static long[] tempPrimeFibs5 = new\
    \ long[2];\n    static long[] tempPrimeFibs6 = new long[2];\n    static long[]\
    \ tempPrimeFibs7 = new long[2];\n    static long[] tempPrimeFibs8 = new long[2];\n\
    \    static long[] tempPrimeFibs9 = new long[2];\n    static long[] tempPrimeFibs10\
    \ = new long[2];\n    static long[] tempPrimeFibs11 = new long[2];\n    static\
    \ long[] tempPrimeFibs12 = new long[2];\n    static long[] tempPrimeFibs13 = new\
    \ long[2];\n    static long[] tempPrimeFibs14 = new long[2];\n    static long[]\
    \ tempPrimeFibs15 = new long[2];\n    static long[] tempPrimeF", "{ \n    long\
    \ a = 2L; \n    long b = 3L; \n    long c = 5L; \n    long i = 5L; \n    long\
    \ x = 0L; \n  \n    if (n < 1L) \n        return 0L; \n    if (n == 1L) \n   \
    \     return 2L; \n    if (n == 2L) \n        return 3L; \n    if (n == 3L) \n\
    \        return 5L; \n    while (true) \n    { \n        x = a + b; \n       \
    \ a = b; \n        b = c; \n        c = x; \n        i += 1L; \n        if (i\
    \ == n) \n            return x; \n    } \n}\n/*", "{\n    import std.math;", "{\
    \ \n    if (n < 1L) \n    {\n        return n;\n    } \n    auto last = tuple(0L,\
    \ 1L); \n    foreach (i; 1L .. n) \n    { \n        last = tuple(last[1], last[0]\
    \ + last[1]); \n        if (isPrime(last[1])) \n        {\n            n--; \n\
    \        } \n    } \n    return last[1]; \n}\n ", "{\n    ", "{\n\t\n\tlong a\
    \ = 0L;\n\tlong b = 1L;\n\tlong c = 1L;\n\tlong i = 0L;\n\tauto prime = new PrimeNumbers();\n\
    \twhile (i < n) \n\t{\n\t\tif (isPrime(c)) \n\t\t{\n\t\t\ti += 1L;\n\t\t}\n\t\t\
    c = a + b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn c;\n\t\n}", "{\n    long a =\
    \ 0L;\n    long b = 1L;\n    long c = a + b;\n    long len = 1L;\n    while (true)\
    \ \n    {\n        if (len == n) \n        {\n            return c;\n        }\n\
    \        a = b;\n        b = c;\n        c = a + b;\n        if (c.isPrime) \n\
    \        {\n            len++;\n        }\n    }\n    return -1L;\n}\n/*", "{\n\
    \    long fibn = fibonacci!(long)(n);\n    return isPrime(fibn) ? fibn : prime_fib(n\
    \ + 1L);\n}", "{\n    /+\n    +/\n    long a = 2L;\n    long b = 3L;\n    long\
    \ c = 5L;\n    long count = 5L;\n    while(true) {\n        if (is_prime(c)) {\n\
    \            count += 1L;\n            if (count == n) {\n                return\
    \ c;\n            }\n        }\n        a = b;\n        b = c;\n        c = a\
    \ + b;\n    }\n}", "{\n    long fibs(Range)(long start, long end) if (start >=\
    \ end) \n    {\n        immutable int SIZE = 500;\n        typeof(return) fibs\
    \ = new typeof(return)(SIZE);\n        long fib1 = 1, fib2 = 2;\n        long\
    \ pos = 0;\n        while (fib2 <= end) \n        {\n            if (fib2 >= start)\
    \ \n            {\n                if (pos >= SIZE) \n                {\n    \
    \                SIZE *= 2;\n                    fibs.length = SIZE;\n       \
    \         }\n                fibs[pos] = fib2;\n                pos++;\n     \
    \       }\n            long t = fib1 + fib2;\n            fib1 = fib2;\n     \
    \       fib2 = t;\n        }\n        fibs.length = pos;\n        return fibs;\n\
    \    }", "{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "{\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    ", "{\n    n -= 1L;\n    long k = n;\n    long\
    \ a = 0L;\n    long b = 1L;\n    while (k > 0L) \n    {\n        long c = a +\
    \ b;\n        if (isPrime(c)) \n        {\n            k -= 1L;\n        }\n \
    \       a = b;\n        b = c;\n    }\n    return a;\n}\n/*", "{\n    size_t count=0;\n\
    \    long fibonacci=1;\n    long previous=0;\n    long sum=0;\n    while(count<n)\n\
    \    {\n        sum=fibonacci+previous;\n        previous=fibonacci;\n       \
    \ fibonacci=sum;\n        if (isPrime(fibonacci))\n        {\n            count++;\n\
    \        }\n    }\n    return fibonacci;\n}\n/*\n    prime_fib_gen returns a lazy\
    \ infinite generator of numbers that are Fibonacci numbers and they're also prime.\n\
    \    >>> import std.range;\n    >>> int[] xs = take(10, prime_fib_gen);\n    >>>\
    \ xs\n    [2L, 3L, 5L, 13L, 89L, 233L, 1597L, 28657L, 514229L, 433494437L]\n*/\n\
    auto prime_fib_gen() \n{\n    import std.algorithm : iterate;\n    import std.range\
    \ : cycle;\n    return cycle([0L, 1L]).iterate!(a => a[0] + a[1])\n        .filter!(a\
    \ => isPrime(a[1]));\n}\n//+BEGIN_FOLD\nauto isPrime(long n)\n{\n    if (n <=\
    \ 1) return false;\n    else if (n <= 3) return true;\n    else if (n % 2 == 0\
    \ || n % 3 == 0) return false;\n    long i = 5;\n    while (i * i <= n) {\n  \
    \      if (n % i == 0 || n % (i + 2) == 0) return false;\n        i += 6;\n  \
    \  }\n    return true;\n}\n//+END_FOLD\n//+BEGIN_FOLD Tests {\nunittest\n{\n \
    \   assert(prime_fib(1L) == 2L);\n    assert(prime_fib(2L) == 3L);\n    assert(prime_fib(3L)\
    \ == 5L);\n    assert(prime_fib(4L) == 13L);\n    assert(prime_fib(5L) == 89L);\n\
    \    import std", "{ \n    if (n < 2L) \n    { \n        return 2L; \n    } \n\
    \    else \n    { \n        auto fib = tuple(2L, 3L); \n        long i = 2L; \n\
    \        while (i < n) \n        { \n            fib = tuple(fib[1], fib[0] +\
    \ fib[1]); \n            if (isPrime(fib[1])) \n            { \n             \
    \   i += 1L; \n            } \n        } \n        return fib[1]; \n    } \n} ",
  "{\n    //\n    long current_index = 2L;\n    long prime_index = 1L;\n    long prev_fib\
    \ = 1L;\n    long fib = 2L;\n    //\n    while (true) \n    {\n        if (n ==\
    \ prime_index)\n        {\n            return fib;\n        }\n        //\n  \
    \      long temp = fib;\n        fib += prev_fib;\n        prev_fib = temp;\n\
    \        current_index += 1L;\n        //\n        if (is_prime(fib))\n      \
    \  {\n            prime_index += 1L;\n        }\n    }\n}\n// helper functions",
  "{\n    if (n == 1L) \n    {\n        return 2L;\n    }\n    if (n == 2L) \n   \
    \ {\n        return 3L;\n    }\n    Tuple!(ulong, ulong) prev = tuple(2UL, 3UL);\n\
    \    Tuple!(ulong, ulong) curr = tuple(3UL, 5UL);\n    for (long i = 3L; i < n;\
    \ i++) \n    {\n        curr = tuple(curr[1], curr[0] + curr[1]);\n        while\
    \ (isPrime(curr[0]) && curr[0] < curr[1]) \n        {\n            prev = tuple(curr[0],\
    \ curr[1]);\n            curr = tuple(curr[1], curr[0] + curr[1]);\n        }\n\
    \    }\n    return cast(long)prev[1];\n}", "{\n    /*\n        fibonacci takes\
    \ a long as a param and returns a long \n        it returns the n-th Fibonacci\
    \ number\n        >>> fibonacci(1L)\n        1L\n        >>> fibonacci(2L)\n \
    \       1L\n        >>> fibonacci(3L)\n        2L\n        >>> fibonacci(4L)\n\
    \        3L\n        >>> fibonacci(5L)\n        5L\n        >>> fibonacci(6L)\n\
    \        8L\n        >>> fibonacci(7L)\n        13L\n        >>> fibonacci(8L)\n\
    \        21L\n        >>> fibonacci(9L)\n        34L\n        >>> fibonacci(10L)\n\
    \        55L\n        >>> fibonacci(11L)\n        89L\n        >>> fibonacci(12L)\n\
    \        144L\n        >>> fibonacci(13L)\n        233L\n        >>> fibonacci(14L)\n\
    \        377L\n        >>> fibonacci(15L)\n        610L\n        >>> fibonacci(16L)\n\
    \        987L\n        >>> fibonacci(17L)\n        1597L\n        >>> fibonacci(18L)\n\
    \        2584L\n        >>> fibonacci(19L)\n        4181L\n        >>> fibonacci(20L)\n\
    \        6765L\n        >>> fibonacci(21L)\n        10946L\n        >>> fibonacci(22L)\n\
    \        17711L\n        >>> fibonacci(23L)\n        28657L\n        >>> fibonacci(24L)\n\
    \        46368L\n        >>> fibonacci(25L)\n        75025L\n        >>> fibonacci(26L)\n\
    \        121393L\n        >>> fibonacci(27L)\n        196418L\n        >>> fibonacci(28L)\n\
    \        317811L\n        >>> fibonacci(29L)\n        514229L\n        >>> fibonacci(30L)\n\
    \        832040L\n        >>> fibonacci(31L)\n        1346269L\n        >>> fibonacci(32L)\n\
    \        2178309L\n        >>> fibonacci(33", "{\n    pragma(msg, \"returning\
    \ \" ~ to!string(n) ~ \"-th prime fib number\");\n    return n == 1L ? 2L : n\
    \ == 2L ? 3L : n == 3L ? 5L : n == 4L ? 13L : 89L;\n}", "{\n\tsize_t i = 2;\n\t\
    size_t j = 3;\n\tsize_t temp = 0;\n\tsize_t count = 0;\n\twhile (1) \n\t{\n\t\t\
    if (isPrime(i)) \n\t\t{\n\t\t\tcount++;\n\t\t\tif (count == n) \n\t\t\t{\n\t\t\
    \t\treturn i;\n\t\t\t}\n\t\t}\n\t\ttemp = i;\n\t\ti = j;\n\t\tj = temp + j;\n\t\
    }\n}\nstatic assert(prime_fib(1L) == 2L);\nstatic assert(prime_fib(2L) == 3L);\n\
    static assert(prime_fib(3L) == 5L);\nstatic assert(prime_fib(4L) == 13L);\nstatic\
    \ assert(prime_fib(5L) == 89L);", "in\n{\n    assert(n >= 1L);\n}\nbody\n{\n \
    \   alias Num = Tuple!(long, long);\n    long a = 0L;\n    long b = 1L;\n    long\
    \ c = a + b;\n    long count = 0L;\n    for (; ; c = a + b)\n    {\n        a\
    \ = b;\n        b = c;\n        if (isPrime(c))\n        {\n            count++;\n\
    \            if (count == n)\n            {\n                return c;\n     \
    \       }\n        }\n    }\n}", "{\n    long i = 1L; \n    long j = 1L;\n   \
    \ long count = 0L;\n    long k = 0L;\n    while (true) {\n        k = i + j;\n\
    \        if (isPrime(k)) {\n            count = count + 1L;\n        }\n     \
    \   if (count == n) {\n            return k;\n        }\n        i = j;\n    \
    \    j = k;\n    }\n}", "{\n    // Some constants we're going to use.\n    real\
    \ phi = (sqrt(5.0) + 1.0) / 2.0;\n    real minus_phi = (sqrt(5.0) - 1.0) / 2.0;\n\
    \    auto fib = (long)floor(pow(phi, n) / sqrt(5.0) + 0.5);", "{\n    long tmp1\
    \ = 0;\n    long tmp2 = 1;\n    long index = 1;\n    while (index < n) \n    {\n\
    \        auto t = tmp1 + tmp2;\n        tmp1 = tmp2;\n        tmp2 = t;\n    \
    \    if (isPrime(tmp2)) \n        {\n            index++;\n        }\n    }\n\
    \    return tmp2;\n}", "{\n    int i;\n    long n_prime = 0;\n    long a = 1;\n\
    \    long b = 1;\n    long tmp;\n    foreach(i; 0 .. n)\n    {\n        tmp =\
    \ a;\n        a = b;\n        b = tmp + b;\n        if(isPrime(a))\n        {\n\
    \            n_prime++;\n        }\n        if(n_prime == n)\n        {\n    \
    \        return a;\n        }\n    }\n    return -1;\n}", "{\n    if (n == 1L)\n\
    \        return 2L;\n    else if (n == 2L)\n        return 3L;\n    else if (n\
    \ == 3L)\n        return 5L;\n    else if (n == 4L)\n        return 13L;\n   \
    \ else if (n == 5L)\n        return 89L;\n    else if (n == 6L)\n        return\
    \ 233L;\n    else if (n == 7L)\n        return 1597L;\n    else if (n == 8L)\n\
    \        return 28657L;\n    else if (n == 9L)\n        return 514229L;\n    else\
    \ if (n == 10L)\n        return 433494437L;\n    else if (n == 11L)\n        return\
    \ 2971215073L;\n    else if (n == 12L)\n        return 99194853094755497L;\n \
    \   else if (n == 13L)\n        return 1066340417491710595814572169L;\n    else\
    \ if (n == 14L)\n        return 19134702400093278081449423917L;\n    else if (n\
    \ == 15L)\n        return 225851433717L;\n    else if (n == 16L)\n        return\
    \ 26863810024485359386146727202142923967616609318986952340123175997617981700247881689338369654483356564191827856161443356312976673642210350324634850410377680367334151172899169723197082763985615764450078474174626L;\n\
    \    else if (n == 17L)\n        return 2658455991569831745807614120560689472L;\n\
    \    else if (n == 18L)\n        return 2658455991569831745807614120560689472L;\n\
    \    else if (n == 19L)\n        return 2658455991569831745807614120560689472L;\n\
    \    else if (n == 20L)\n        return 26584559915698317458076141205", "{\n \
    \   if (n<1L)\n    {\n        return 0L;\n    }\n    if (n==1L)\n    {\n     \
    \   return 2L;\n    }\n    long x = 2L;\n    long y = 3L;\n    long cnt = 2L;\n\
    \    for (; cnt < n; )\n    {\n        auto z = x + y;\n        x = y;\n     \
    \   y = z;\n        if (cast(bool)std.math.isPrime(y))\n        {\n          \
    \  cnt++;\n        }\n    }\n    return y;\n}\n/*", "{\n    long i = 1;\n    long\
    \ count = 0;\n    while (count != n) \n    {\n        if (is_prime(fib(i))) \n\
    \        {\n            count++;\n        }\n        i++;\n    }\n    return fib(i\
    \ - 1);\n}\n/*", "{\n    if (n == 1L) \n    {\n        return 2L;\n    }\n   \
    \ else if (n == 2L) \n    {\n        return 3L;\n    }\n    else \n    {\n   \
    \     auto t = tuple(2L, 3L);\n        long count = 3L;\n        long value =\
    \ 5L;\n        while (count < n) \n        {\n            t[0L] = t[1L];\n   \
    \         t[1L] = value;\n            value = t[0L] + t[1L];\n            if (is_prime(value))\
    \ \n            {\n                count++;\n            }\n        }\n      \
    \  return value;\n    }\n}", "{\n    long result = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long last_prime = 0;\n    long nth_prime = 0;\n    long nth_prime_counter\
    \ = 0;\n    bool is_prime = false;\n    while (nth_prime_counter < n) \n    {\n\
    \        a = b;\n        b = result;\n        result = a + b;\n        if (result\
    \ > last_prime) \n        {\n            is_prime = true;\n            for (long\
    \ i = 2; i <= sqrt(result); i++) \n            {\n                if (result %\
    \ i == 0) \n                {\n                    is_prime = false;\n       \
    \             break;\n                }\n            }\n            if (is_prime)\
    \ \n            {\n                last_prime = result;\n                nth_prime_counter\
    \ += 1;\n                nth_prime = result;\n            }\n        }\n    }\n\
    \    return nth_prime;\n}\nlong max_num_generated(long n) \n{\n    return to!long(pow(10,\
    \ n));\n}\nlong is_prime(long n) \n{\n    return n < 2 ? false : !any!(i => n\
    \ % i == 0)(iota(2, cast(int)sqrt(n)));\n}\nlong num_distinct_digits(long n) \n\
    {\n    /*\n        >>> num_distinct_digits(123L)\n        3L\n        >>> num_distinct_digits(134L)\n\
    \        3L\n        >>> num_distinct_digits(1344L)\n        3L\n        >>> num_distinct_digits(13445L)\n\
    \        4L\n        >>> num_distinct_digits(134456L)\n        5L\n        >>>\
    \ num_distinct_digits(1344444444L)\n        4L\n    */\n    long min_num = cast(long)pow(10,\
    \ cast(int)log10(n));\n    long max_num = min_num * 10;\n    auto digits = to!(HashSet)();\n\
    \    while (min_num > 0)", "{\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.math;\n    import std.typetuple;\n    import\
    \ std.typecons;\n    import std.conv;\n    // Use Fibonacci numbers with a guaranteed\
    \ generator\n    // Use a sliding window to check for primes of the form 6n \xB1\
    \ 1\n    uint [3] fibs = [1, 1, 2];\n    uint [] primes = [2];\n    uint primeCount\
    \ = 1;\n    while (primeCount < n) \n    {\n        fibs[0] = fibs[1];\n     \
    \   fibs[1] = fibs[2];\n        fibs[2] += fibs[0];\n        // primality check\n\
    \        auto isPrime = false;\n        auto root = cast(long) ceil(sqrt(fibs[2]));\n\
    \        // loop by the prime window size\n        foreach (immutable k; 0 ..\
    \ fibs[2].stringof.length + 1) \n        {\n            auto test = fibs[2] -\
    \ 6 * k;\n            if (test <= 3) \n            {\n                isPrime\
    \ = test.odd && fibs[2] != 5;\n                break;\n            }\n       \
    \     if (test > root) \n            {\n                isPrime = true;\n    \
    \            break;\n            }\n            // find index of prime nearest\
    \ test\n            auto index = cast(long) (lower_bound(primes, test).ptr - primes.ptr);\n\
    \            if (primes[index] < test) \n            {\n                ++index;\n\
    \            }\n            auto near = primes[index - 1];\n            if (near.even)\
    \ \n            {\n                --near;\n            }\n            auto delta\
    \ = test - near;\n            if (delta % 6 != 0) \n            {\n          \
    \      isPrime = true;\n                break;\n            }\n            //\
    \ test primes in the window of 6n \xB1 1\n            foreach (immutable prime;\
    \ near .. near + 6) \n            {\n                if (test % prime == 0) \n\
    \                {\n                    isPrime = false;\n                   \
    \ break;\n                }\n", "{\n    long a = 2;\n    long b = 3;\n    long\
    \ c = 5;\n    long i = 3;\n    while (i < n) {\n        a = b;\n        b = c;\n\
    \        c = a + b;\n        if (isPrime(c)) i += 1;\n    }\n    return c;\n}\n\
    /*", "{\n    size_t i = 1;\n    foreach(immutable long x; PrimeFibonacci()) \n\
    \    {\n        if (i == n) \n        {\n            return x;\n        }\n  \
    \      i++;\n    }\n    assert(false);\n}\n/*", "{ \n    long f1 = 1; \n    long\
    \ f2 = 1; \n    long f3 = 0; \n    long count = 1; \n    for (; ;) { \n      \
    \  f3 = f1 + f2; \n        f1 = f2; \n        f2 = f3; \n        if (f3 > (1L\
    \ << 62)) \n            break; \n        if (isPrime(f3)) \n            count++;\
    \ \n        if (count == n) \n            return f3; \n    } \n    return -1;\
    \ \n} \n/*", "{\n    if (n <= 0L) return 0L;\n    long pp = 1L;\n    long p =\
    \ 1L;\n    long c = 2L;\n    long cnt = 0L;\n    for (; ; c += p) {\n        if\
    \ (is_prime(c)) {\n            cnt++;\n            if (cnt == n) return c;\n \
    \       }\n        c = p;\n        p = pp;\n        pp = c;\n    }\n    return\
    \ 0L;\n}\n/*", "{\n    if (n == 1L) \n    {\n        return 2L;\n    }\n    else\
    \ if (n == 2L) \n    {\n        return 3L;\n    }\n    else \n    {\n        long\
    \ prev_prev = 2L;\n        long prev = 3L;\n        long curr = 5L;\n        long\
    \ cnt = 3L;\n        while (cnt < n) \n        {\n            curr = prev + prev_prev;\n\
    \            if (is_prime(curr)) \n            {\n                cnt += 1L;\n\
    \            }\n            prev_prev = prev;\n            prev = curr;\n    \
    \    }\n        return curr;\n    }\n}", "{ \n  bool is_prime(long n) {\n    if\
    \ (n == 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return\
    \ false;\n    foreach (i; 2..ceil(sqrt(n)))\n    {\n      if (n % i == 0) return\
    \ false;\n    }\n    return true;\n  }\n  \n  auto fib = tuple(1L, 2L);\n  long\
    \ counter = 1L;\n  while (counter < n) {\n    fib[0] = fib[1];\n    fib[1] +=\
    \ fib[0];\n    if (is_prime(fib[1])) counter++;\n  }\n  return fib[1];\n}", "{\n\
    \    long f0 = 2L;\n    long f1 = 3L;\n    long tmp;\n    long nth = 2L;\n   \
    \ while (nth < n) \n    {\n        tmp = f1;\n        f1 = f0 + f1;\n        f0\
    \ = tmp;\n        if (is_prime(f1))\n            nth += 1L;\n    }\n    return\
    \ f1;\n}\n/*", "{ \n    long f1 = 2L;\n    long f2 = 3L;\n    long i = 2L;\n \
    \   while (i < n) {\n        long f3 = f1 + f2;\n        if (isPrime(f3)) i++;\n\
    \        f1 = f2;\n        f2 = f3;\n    }\n    return f2;\n}", "{\n    if (n\
    \ == 1L)\n    {\n        return 2L;\n    }\n    else if (n == 2L)\n    {\n   \
    \     return 3L;\n    }\n    else\n    {\n        import std.math : isPrime;\n\
    \        long max = 5L, len = 2L;\n        for (long a = 1L, b = 1L, tmp = 0L;\
    \ len < n; b = tmp)\n        {\n            tmp = max;\n            max = a +\
    \ b;\n            a = tmp;\n            if (isPrime(max))\n            {\n   \
    \             len++;\n            }\n        }\n        return max;\n    }\n}\n\
    /*", "{\n    long result = 0L;\n    long i = 1L;\n    long fib_prev = 1L;\n  \
    \  long fib_curr = 1L;\n    long fib_next = 0L;\n    while (i <= n) {\n      \
    \  fib_next = fib_prev + fib_curr;\n        if (is_prime(fib_next)) {\n      \
    \      result = fib_next;\n            i += 1L;\n        }\n        fib_prev =\
    \ fib_curr;\n        fib_curr = fib_next;\n    }\n    return result;\n}", "{\n\
    \    long prime_fib_in(long n)\n    {\n        if (n < 1L)\n        {\n      \
    \      return -1L;\n        }\n        if (n == 1L)\n        {\n            return\
    \ 2L;\n        }\n        long last = 2L;\n        long count = 1L;\n        long\
    \ fib = 3L;\n        long swap = 0L;\n        for (;;)\n        {\n          \
    \  if (count == n)\n            {\n                return fib;\n            }\n\
    \            if (isPrime(fib))\n            {\n                count++;\n    \
    \        }\n            swap = fib;\n            fib += last;\n            last\
    \ = swap;\n        }\n    }\n    return prime_fib_in(n);\n}", "{\n    long tmp;\n\
    \    long f_n = 2L;\n    long f_n_1 = 1L;\n    long i = 1L;\n    while (i < n)\
    \ \n    {\n        tmp = f_n + f_n_1;\n        f_n_1 = f_n;\n        f_n = tmp;\n\
    \        ++i;\n    }\n    return f_n;\n}\n/*", "{\n    enum max_prime = 1000000;\n\
    \    static bool isPrime[max_prime];\n    static long prime[max_prime];\n    static\
    \ bool isReady = false;\n    static long count = 0;\n    static long last = 0;\n\
    \    static long f1 = 1;\n    static long f2 = 1;\n    static long f3 = 0;\n \
    \   if (!isReady) \n    {\n        isReady = true;\n        prime.length = 0;\n\
    \        isPrime[0] = false;\n        isPrime[1] = false;\n        isPrime[2]\
    \ = true;\n        count = 2;\n        for (int i = 3; i < max_prime; i++) \n\
    \        {\n            if (i & 1) \n            {\n                if (isPrime[i])\
    \ \n                {\n                    for (int j = i + i; j < max_prime;\
    \ j += i) \n                    {\n                        isPrime[j] = false;\n\
    \                    }\n                    count++;\n                    prime.length\
    \ = count;\n                    prime[count - 1] = i;\n                }\n   \
    \         }\n            else \n            {\n                isPrime[i] = false;\n\
    \            }\n        }\n    }\n    if (n < 0) \n    {\n        return 0;\n\
    \    }\n    if (n == 1) \n    {\n        return 2;\n    }\n    if (n == 2) \n\
    \    {\n        return 3;\n    }\n    if (n == 3) \n    {\n        return 5;\n\
    \    }\n    if (n <= last) \n    {\n        return prime[n - 1];\n    }\n    last\
    \ = n;\n    while (true) \n    {\n        f3 = f1 + f2;\n        long i = 0;\n\
    \        while (true) \n        {\n            if (f3 % prime[i] == 0) \n    \
    \        {\n                break;\n            }\n            if (prime[i] *\
    \ prime[i] > f3) \n            {\n                prime.length = count;\n    \
    \            prime[count - 1] = f3;\n                last = count;\n         \
    \       count++;\n               ", "{\n    long cnt = 0L;\n    long fib2 = 0L;\n\
    \    long fib1 = 1L;\n    while (cnt < n) \n    {\n        long f = fib1 + fib2;\n\
    \        if (isPrime(f)) \n        {\n            cnt += 1L;\n        }\n    \
    \    fib2 = fib1;\n        fib1 = f;\n    }\n    return fib1;\n}\n/*", "{\n  \
    \  // It's a Fibonacci number.\n    import std.algorithm.iteration: find, filter,\
    \ map;\n    // It's a prime number.\n    import std.algorithm.searching: all;\n\
    \    import std.math: isPrime;\n    import std.range: iota;\n    import std.typecons:\
    \ tuple;\n    // Index-th element in Fibonacci sequence.\n    auto fib = n =>\
    \ nth_fib(n).back;\n    auto fib_numbers = iota(1L, n);\n    auto prime_fib_numbers\
    \ = fib_numbers.map!fib.filter!isPrime;\n    return prime_fib_numbers.back;\n}",
  "{\n    long i = 0;\n    long res = 0;\n    long a = 0;\n    long b = 1;\n    long\
    \ c = 0;\n    while (true) {\n        i = i + 1;\n        c = a + b;\n       \
    \ a = b;\n        b = c;\n        if (isPrime(c)) {\n            res = res + 1;\n\
    \            if (res == n) {\n                return c;\n            }\n     \
    \   }\n    }\n}\n/*", "{\n    long fi = 1L;\n    long se = 1L;\n    long res =\
    \ 0L;\n    long cnt = 2L;\n    if (n < 2L)\n    {\n        return n + 1L;\n  \
    \  }\n    while (cnt < n)\n    {\n        res = fi + se;\n        fi = se;\n \
    \       se = res;\n        if (is_prime(res))\n        {\n            cnt++;\n\
    \        }\n    }\n    return res;\n}\n/*", "{\n    long res = 0L;\n    long a\
    \ = 1L;\n    long b = 1L;\n    long c = 0L;\n    long limit = 1L << 32L;\n   \
    \ long count = 0L;\n    while (count < n) {\n        c = a + b;\n        if (c\
    \ > limit) {\n            c = 0L;\n            break;\n        }\n        if (is_prime(c))\
    \ {\n            res = c;\n            count += 1L;\n        }\n        a = b;\n\
    \        b = c;\n    }\n    return res;\n}", "{\n    size_t counter = 0;\n   \
    \ long i = 1L;\n    long j = 1L;\n    long temp;\n    while (true) \n    {\n \
    \       temp = i + j;\n        i = j;\n        j = temp;\n        if (isPrime(j))\
    \ \n        {\n            counter++;\n            if (counter == n) \n      \
    \      {\n                return j;\n            }\n        }\n    }\n}\n/*",
  "{\n    /*\n        fibonacci numbers\n    */\n    struct fibonacci\n    {\n   \
    \     long n;\n        long v;\n        alias n this;\n        bool opEquals(fibonacci\
    \ x) \n        {\n            return n == x.n;\n        }\n        bool opEquals(long\
    \ x) \n        {\n            return n == x;\n        }\n        fibonacci opAssign(fibonacci\
    \ x) \n        {\n            n = x.n;\n            v = x.v;\n            return\
    \ this;\n        }\n        int opCmp(fibonacci x) \n        {\n            return\
    \ n - x.n;\n        }\n        int opCmp(long x) \n        {\n            return\
    \ n - x;\n        }\n        auto opSlice() \n        {\n            return tuple(n,\
    \ v);\n        }\n        string toString() \n        {\n            return format(\"\
    (%d, %d)\", n, v);\n        }\n    }\n    /*\n        our cache class\n    */\n\
    \    struct fibonacci_cache \n    {\n        private\n        {\n            //\
    \ cache of fibonacci numbers\n            SortedRange!(fibonacci) cache;\n   \
    \         // current largest fibonacci number and its index\n            fibonacci!(long,\
    \ long) current;\n            // helper function.\n            long fib(long n)\
    \ \n            {\n                if (n < 2)\n                    return n;\n\
    \                if (cache.empty)\n                    cache.insert(fibonacci(2,\
    \ 1));\n                long a = 0;\n                long b = 1;\n           \
    \     for (long i = 2; i <= n; i++) \n                {\n                    auto\
    \ t = a + b;\n                    a = b;\n                    b = t;\n       \
    \         }\n                return b;\n            }\n        }\n        // returns\
    \ n-th fibonacci number\n        long fibonacci(long n) \n        {\n        \
    \    if (current.n == n)\n                return current.v;\n            if (n\
    \ < current.n)\n                return cache[n].v;\n            for (; current.n\
    \ <", "{\n    auto isPrime = [] (int n) {\n        if (n == 2) {\n           \
    \ return true;\n        }\n        else if (n % 2 == 0) {\n            return\
    \ false;\n        }\n        else {\n            for (long i = 3; i <= sqrt(n);\
    \ i += 2) {\n                if (n % i == 0) {\n                    return false;\n\
    \                }\n            }\n            return true;\n        }\n    };\n\
    \    auto fib = [] (int n) {\n        auto pair = tuple(1, 1);\n        for (long\
    \ i = 1; i < n; i++) {\n            pair = tuple(pair[1], pair[0] + pair[1]);\n\
    \        }\n        return pair[1];\n    };\n    long i = 1;\n    long x = 2;\n\
    \    do {\n        x = fib(i);\n        i++;\n    } while (!isPrime(x));\n   \
    \ while (i < n) {\n        x = fib(i);\n        if (isPrime(x)) {\n          \
    \  n--;\n        }\n        i++;\n    }\n    return x;\n}", "{\n    // Iterator\
    \ over Fibonacci numbers.\n    struct Fib {\n      long a;\n      long b;\n  \
    \    bool empty;\n      @property Fib moveFront() { return @(this.b, this.a +\
    \ this.b, false); }\n    }\n    auto fib_numbers() { \n      long a = 0;\n   \
    \   long b = 1;\n      return Fib(a, b, false);\n    }\n    // Iterator over prime\
    \ numbers.\n    auto prime_numbers() { \n      return primeRange(2L);\n    }\n\
    \    // Iterator over prime Fibonacci numbers.\n    struct PrimeFib {\n      Fib\
    \ fib;\n      PrimeRange primes;\n      bool empty;\n      @property PrimeFib\
    \ moveFront() { \n        auto next = this.fib.moveFront;\n        while (next.b\
    \ % this.primes.front) {\n          this.primes.moveFront;\n        }\n      \
    \  return @(next, this.primes, false);\n      }\n    }\n    auto prime_fib_numbers()\
    \ { \n      return PrimeFib(fib_numbers(), prime_numbers(), false);\n    }\n \
    \   // Iterator over n-th element of iterator.\n    struct Nth {\n      Range\
    \ r;\n      long c;\n      bool empty;\n      @property Nth moveFront() { \n \
    \       this.r.moveFront;\n        return @(this.r, this.c-1, this.c == 0);\n\
    \      }\n    }\n    auto nth(Range r, long n) { \n      return Nth(r, n, n ==\
    \ 0);\n    }\n    // Use the above iterators to get the n-th Fibonacci prime number.\n\
    \    return nth(prime_fib_numbers(), n-1).front;\n}\n/*", "{\n    return fibonacci!(isPrime)(n);\n\
    }", "{\n    long a = 0L;\n    long b = 1L;\n    long c = 0L;\n    long i = 0L;\n\
    \    while (i < n) {\n        c = a + b;\n        a = b;\n        b = c;\n   \
    \     if (is_prime(b)) {\n            i = i + 1L;\n        }\n    }\n    return\
    \ b;\n}\n/*", "    pure nothrow @safe @nogc{\n    \n    if (n < 1L) \n       \
    \ throw new Exception(\"Invalid input!\");\n    \n    if (n == 1L) \n        return\
    \ 2L;\n    \n    if (n == 2L) \n        return 3L;\n    \n    long a = 1L;\n \
    \   long b = 1L;\n    long c = 0L;\n    size_t count = 2L;\n    \n    while (count\
    \ < n) {\n        c = a + b;\n        a = b;\n        b = c;\n        if (isPrime(c))\n\
    \            count++;\n    }\n    \n    return c;\n}", "{\n    import std.math\
    \ : isPrime;\n    import std.range : iota;\n    import std.algorithm : filter;\n\
    \    import std.conv : to;\n    import std.traits : Unqual;\n    Unqual!(typeof(n))\
    \ i = 0;\n    long fib = 0;\n    foreach (fib2; iota(1L, n + 1L).map!((n) => fibonacci(n)).filter!((n)\
    \ => isPrime(n))) {\n        i++;\n        fib = fib2;\n    }\n    return fib;\n\
    }", "{\n    long cnt = 1L;\n    long fn = 1L;\n    long fn1 = 2L;\n    for (long\
    \ i = 2L; i < n; i++, cnt++) {\n        long fn0 = fn;\n        fn = fn1;\n  \
    \      fn1 = fn0 + fn1;\n        if (isPrime(fn1)) {\n            cnt++;\n   \
    \     }\n    }\n    return fn1;\n}\n/*", "{\n    long term1 = 0L;\n    long term2\
    \ = 1L;\n    long temp = 0L;\n    long count = 1L;\n    while (count < n) \n \
    \   {\n        temp = term1 + term2;\n        term1 = term2;\n        term2 =\
    \ temp;\n        if (temp.isPrime) \n        {\n            count++;\n       \
    \ }\n    }\n    return temp;\n}\n/*", "{\n    static Tuple!(long, long) f1 = tuple(2L,\
    \ 3L);\n    static Tuple!(long, long) f2 = tuple(3L, 5L);\n    static int cnt\
    \ = 0;\n    if (cnt == 0) {\n        cnt++;\n        return f1[0];\n    }\n  \
    \  if (cnt == 1) {\n        cnt++;\n        return f2[0];\n    }\n    while (cnt\
    \ < n) {\n        long next = f1[1] + f2[1];\n        if (isPrime(next)) {\n \
    \           f1 = f2;\n            f2 = tuple(f2[1], next);\n            cnt++;\n\
    \        }\n    }\n    return f2[0];\n}", "{\n    /* your code */\n    long a\
    \ = 2L;\n    long b = 3L;\n    long c = 5L;\n    long count = 5L;\n    long m;\n\
    \    if (n == 1L)\n    {\n        return a;\n    }\n    else if (n == 2L)\n  \
    \  {\n        return b;\n    }\n    else if (n == 3L)\n    {\n        return c;\n\
    \    }\n    else if (n == 4L)\n    {\n        return 13L;\n    }\n    else\n \
    \   {\n        for (int i = 0; i < n - 4; i++)\n        {\n            m = a +\
    \ b + c;\n            a = b;\n            b = c;\n            c = m;\n       \
    \     if (isPrime(m))\n            {\n                count++;\n            }\n\
    \            if (count == n)\n            {\n                return m;\n     \
    \       }\n        }\n    }\n    return 0L;\n}", "{\n    auto p = tuple(0L, 1L);\n\
    \    long m = 1L;\n    long count = 0L;\n    while (count < n) \n    {\n     \
    \   if (isPrime(m)) \n        {\n            count++;\n        }\n        p =\
    \ std.typecons.tuple(p[1], p[0] + p[1]);\n        m = p[1];\n    }\n    return\
    \ m;\n}", "{ \n    long s = 0;\n    size_t i = 1;\n    int j = 0;\n    while (s\
    \ != n)\n    {\n        if (isFib(i) && isPrime(i))\n        {\n            s++;\n\
    \        }\n        i++;\n    }\n    return i - 1;\n}", "{\n    long result =\
    \ 2L;\n    long count = 1L;\n    long prev = 0L;\n    long curr = 1L;\n    while\
    \ (count < n) {\n        long next = curr + prev;\n        if (std.math.isPrime(next))\
    \ {\n            result = next;\n            count += 1L;\n        }\n       \
    \ prev = curr;\n        curr = next;\n    }\n    return result;\n}\nlong lessThen(long\
    \ x, long y) {\n    return (x < y) ? 1L : 0L;\n}\nlong isPrime(long n) {\n   \
    \ return (n <= 1L) ? 0L :\n        (n <= 3L) ? 1L :\n        ((n % 2L == 0L) ||\
    \ (n % 3L == 0L)) ? 0L :\n        isPrimeImpl(n, 5L, (long)(sqrt((double)n)));\n\
    }\nlong isPrimeImpl(long n, long i, long m) {\n    return (i > m) ? 1L :\n   \
    \     ((n % i == 0L) || (n % (i + 2L) == 0L)) ? 0L :\n        isPrimeImpl(n, i\
    \ + 6L, m);\n}\ntemplate isPalindrome(T)(T n) {\n    return isPalindromeImpl(n,\
    \ reverse(n));\n}", "{\n    import std.algorithm;\n    import std.array;\n   \
    \ import std.conv;\n    import std.range;\n    import std.algorithm : filter,\
    \ takeExactly;\n    import std.math : isPrime;\n    import std.typecons : tuple;\n\
    \    auto fib_primes = zip(fibonacci, iota).filter!((n) => n[0].isPrime).takeExactly(n);\n\
    \    return fib_primes[$-1][0];\n}", "{\n    auto it = Pair!(BigInt, BigInt)(1,\
    \ 1);\n    long count = 0;\n    while (true) \n    {\n        it = Pair!(BigInt,\
    \ BigInt)(it.tupleof[1], it.tupleof[0] + it.tupleof[1]);\n        if (it.tupleof[1].isPrime)\n\
    \            count++;\n        if (count == n)\n            return cast(long)it.tupleof[1];\n\
    \    }\n}", "{ \n  long f1 = 2L; \n  long f2 = 3L; \n  long f3 = 5L; \n  long\
    \ i = 3L; \n  while (i < n) \n  { \n    f1 = f2; \n    f2 = f3; \n    f3 = f1\
    \ + f2; \n    if (isPrime(f3)) \n    { \n      i = i + 1L; \n    } \n  } \n  return\
    \ f3; \n}\n/*", "{\n    static typeof(asArray(2L, 3L)) _cache = asArray(2L, 3L);\n\
    \    foreach(i; 0 .. n - _cache.length) \n    {\n        auto next = _cache[$\
    \ - 1] + _cache[$ - 2];\n        if (isPrime(next)) \n        {\n            _cache\
    \ ~= next;\n        }\n    }\n    return _cache[$ - 1];\n}\n/*", "{\n    long\
    \ a = 2L;\n    long b = 3L;\n    long c = 5L;\n    long i = 1L;\n    for (; n\
    \ > i; n--) \n    {\n        tuple!(long, long, long)(tuple(a, b, c));\n     \
    \   a = b;\n        b = c;\n        c = a + b;\n        while (!isPrime(c)) \n\
    \        {\n            c = a + b;\n            tuple!(long, long, long)(tuple(a,\
    \ b, c));\n            a = b;\n            b = c;\n        }\n        i++;\n \
    \   }\n    return a;\n}\n/*", "{\n    bool prime(long x)\n    {\n        if (x\
    \ < 2) return false;\n        if (x < 4) return true;\n        if (x % 2 == 0)\
    \ return false;\n        if (x < 9) return true;\n        if (x % 3 == 0) return\
    \ false;\n        if (x < 25) return true;\n        long a = 0;\n        while\
    \ (a * a <= x) {\n            a += 6;\n            if (x % (a - 1) == 0) return\
    \ false;\n            if (x % (a + 1) == 0) return false;\n        }\n       \
    \ return true;\n    }\n    assert(n > 0);\n    long prev = 1;\n    long prevprev\
    \ = 1;\n    long res = 2;\n    long counter = 2;\n    while (true) {\n       \
    \ long newres = prev + prevprev;\n        if (prime(newres)) {\n            res\
    \ = newres;\n            counter++;\n        }\n        if (counter == n) {\n\
    \            return res;\n        }\n        prevprev = prev;\n        prev =\
    \ newres;\n    }\n}\n/*", "{\n    long fib = 1L;\n    long prev_fib = 1L;\n  \
    \  long tmp;\n    long count = 0L;\n    while (count < n) {\n        tmp = fib;\n\
    \        fib += prev_fib;\n        prev_fib = tmp;\n        if (is_prime(fib))\
    \ {\n            count++;\n        }\n    }\n    return fib;\n}", "{\n    long\
    \ i = 2;\n    long prev = 1;\n    long curr = 1;\n    long f = 0;\n    while (i\
    \ != n) {\n        f = curr + prev;\n        prev = curr;\n        curr = f;\n\
    \        if (isPrime(f)) {\n            i++;\n        }\n    }\n    return f;\n\
    }", "{\n    int k = 0;\n    long f_prev = 1;\n    long f_current = 1;\n    while\
    \ (k != n) \n    {\n        long new_f = f_prev + f_current;\n        f_prev =\
    \ f_current;\n        f_current = new_f;\n        if (is_prime(f_current))\n \
    \           k++;\n    }\n    return f_current;\n}\n/*", "    @safe pure nothrow\
    \ @nogc\n{\n    if (n < 1L) \n    {\n        return n;\n    }", "{\n    int res;\n\
    \    int i;\n    int fib_i;\n    i = 1;\n    fib_i = 1;\n    foreach (tmp; iterate!prime_numbers())\
    \ \n    {\n        if (i >= n) \n        {\n            break;\n        }\n  \
    \      fib_i = fib_i.isPrime ? fib_i : fib(i);\n        i = fib_i.isPrime ? i\
    \ + 1 : i;\n        res = fib_i;\n    }\n    return res;\n}", "{ \n    long[2]\
    \ fibo = [0L, 1L];\n    long nth_fibo = 2L;\n    long index = 0L;\n    foreach(i;\
    \ 1 .. n)\n    {\n        while(!isPrime(nth_fibo))\n        {\n            nth_fibo\
    \ = fibo[0] + fibo[1];\n            fibo[0] = fibo[1];\n            fibo[1] =\
    \ nth_fibo;\n        }\n        index = i;\n        nth_fibo = fibo[0] + fibo[1];\n\
    \        fibo[0] = fibo[1];\n        fibo[1] = nth_fibo;\n    }\n    return nth_fibo;\n\
    }", "{\n    long k = 0L;\n    long i = 1L;\n    long j = 2L;\n    while(k != n)\
    \ \n    {\n        long aux = i + j;\n        i = j;\n        j = aux;\n     \
    \   if(prime(j))\n            k += 1L;\n    }\n    return j;\n}\n/*", "{\n   \
    \ if (n < 1L) \n    {\n        return Error.range;\n    }\n    long a = 2L;\n\
    \    long b = 3L;\n    long result = 0L;\n    long counter = 1L;\n    while (counter\
    \ < n) \n    {\n        result = a + b;\n        b = a;\n        a = result;\n\
    \        if (isPrime(result)) \n        {\n            counter++;\n        }\n\
    \    }\n    return result;\n}\nlong main() \n{\n    return prime_fib(long.parse(args[1]));\n\
    }", "{\n    long a = 0L;\n    long b = 1L;\n    long p = 0L;\n    for (long i\
    \ = 0L; i < n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n\
    \        while (c > 1L && !(c % 2L != 0L && is_prime(c))) {\n            c--;\n\
    \        }\n        p = c;\n    }\n    return p;\n}", "{\n    struct fib_with_count_and_value\n\
    \    {\n        long count;\n        long value;\n    };\n    alias fib_with_count_and_value\
    \ = tuple!(long, long);\n    static auto fib_with_count = (Tuple)(long, long)(long\
    \ a, long b)\n    {\n        static if (is(Tuple != Tuple!(long, long)))\n   \
    \     {\n            static assert(false, \"The given tuple must be fib_with_count_and_value\"\
    );\n        }\n        else\n        {\n            return fib_with_count_and_value(a\
    \ + b, b);\n        }\n    };\n    auto is_prime = (long candidate)\n    {\n \
    \       static if (is(typeof(candidate) == long))\n        {\n            if (candidate\
    \ < 2L)\n            {\n                return false;\n            }\n       \
    \     long i = 2L;\n            long stop = sqrt(candidate);\n            while\
    \ (i <= stop)\n            {\n                if (candidate % i == 0L)\n     \
    \           {\n                    return false;\n                }\n        \
    \        i++;\n            }\n            return true;\n        }\n        else\n\
    \        {\n            static assert(false, \"The given candidate must be long\"\
    );\n        }\n    };\n    static assert(is(typeof(n) == long), \"n must be long\"\
    );\n    static assert(n > 0L, \"n must be positive\");\n    long fibonacci_count\
    \ = 1L;\n    long result = 0L;\n    foreach (fib; iterate(fib_with_count_and_value(2L,\
    \ 1L), fib_with_count))\n    {\n        if (is_prime(fib[1]))\n        {\n   \
    \         if (fibonacci_count == n)\n            {\n                result = fib[1];\n\
    \                break;\n            }\n            fibonacci_count++;\n     \
    \   }\n    }\n    return result;\n}", "{\n    long a = 0L;\n    long b = 1L;\n\
    \    long c = 0L;\n    long counter = 0L;\n    while (counter < n) {\n       \
    \ c = a + b;\n        if (c.isPrime) counter++;\n        a = b;\n        b = c;\n\
    \    }\n    return c;\n}\n/*", "{\n    if (n < 1L) {\n        throw new Error(\"\
    n must be greater than 0\");\n    }", "{\n    if (n <= 1L)\n    {\n        return\
    \ n + 1L;\n    }\n    long i = 1L;\n    long cur = 2L;\n    long prev = 1L;\n\
    \    long tmp = 0L;\n    for (; i < n; i++)\n    {\n        tmp = cur;\n     \
    \   cur = cur + prev;\n        prev = tmp;\n        while (!isPrime(cur))\n  \
    \      {\n            tmp = cur;\n            cur = cur + prev;\n            prev\
    \ = tmp;\n        }\n    }\n    return cur;\n}", "{ \n    long count = 0; \n \
    \   long a = 0, b = 1, c = 0; \n    while (count < n) \n    { \n        c = a\
    \ + b; \n        a = b; \n        b = c; \n        if (is_prime(c)) \n       \
    \     count++; \n    } \n    return c; \n} \n/*", "{\n    const int maxn = 1000000;\n\
    \    static int[int] primes = Sieve(maxn).primes();\n    static long[] fib = fibonacci(100,\
    \ 1, 2);\n    int i = 0;\n    int j = 0;\n    while (i < n) {\n        if (j >=\
    \ fib.length) return -1;\n        if (binarySearch(primes, fib[j]) >= 0) i++;\n\
    \        j++;\n    }\n    return fib[j - 1];\n}\n/*", "{ \n    static long prev_prime\
    \ = 1L; \n    static long curr_prime = 2L; \n    static long i = 2L; \n    while\
    \ (i < n) \n    { \n        auto next_prime = prev_prime + curr_prime; \n    \
    \    prev_prime = curr_prime; \n        curr_prime = next_prime; \n        if\
    \ (isPrime(curr_prime)) \n            i += 1L; \n    } \n    return curr_prime;\
    \ \n}\n/*", "{\n\tlong i, j, a, b, c;\n\tbool is_prime;\n\tstatic tuple!(long,\
    \ long) fib = tuple(1L, 2L);\n\tstatic long index = 2L;\n\tif (n == 1L) \n\t{\n\
    \t\treturn 2L;\n\t}\n\twhile (index < n) \n\t{\n\t\ta = fib[0];\n\t\tb = fib[1];\n\
    \t\tc = a + b;\n\t\tfib = tuple(b, c);\n\t\tis_prime = true;\n\t\tfor (i = 2L;\
    \ i <= sqrt(c); i += 1L) \n\t\t{\n\t\t\tif (c % i == 0L) \n\t\t\t{\n\t\t\t\tis_prime\
    \ = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (is_prime) \n\t\t{\n\t\t\t\
    index += 1L;\n\t\t}\n\t}\n\treturn fib[1];\n}\n/*", "{ \n    auto fibs = iota(1L).map!(x\
    \ => fibonacci(x)).filter!(x => isPrime(x));\n    return fibs[n - 1];\n}", "{\n\
    \    static struct PrimeFibs\n    {\n        dlong fib;\n        long counter;\n\
    \        PrimeFibs() \n        {\n            fib = 1;\n            counter =\
    \ 1;\n        }\n    } \n    primeFibs;\n    while (n > primeFibs.counter) \n\
    \    {\n        primeFibs.fib = fibonacci(primeFibs.counter);\n        primeFibs.counter\
    \ += 1;\n        if (isPrime(primeFibs.fib)) \n        {\n            n -= 1;\n\
    \        }\n    }\n    return to!long(primeFibs.fib);\n}\n/*", "{\n    import\
    \ std.array;\n    import std.math;\n    import std.range;\n    import std.numeric;\n\
    \    import std.algorithm;\n    import std.typecons;\n    static long[] a = new\
    \ long[6];\n    static long[] b = new long[6];\n    static long[] p = new long[6];\n\
    \    static long[] q = new long[6];\n    bool flag = false;\n    long i = 0;\n\
    \    long l = 0;\n    long limit = 30;\n    a[0] = 2;\n    a[1] = 3;\n    a[2]\
    \ = 5;\n    a[3] = 13;\n    a[4] = 89;\n    a[5] = 233;\n    b[0] = 2;\n    b[1]\
    \ = 5;\n    b[2] = 13;\n    b[3] = 89;\n    b[4] = 233;\n    b[5] = 1597;\n  \
    \  p[0] = 1;\n    p[1] = 1;\n    p[2] = 2;\n    p[3] = 3;\n    p[4] = 5;\n   \
    \ p[5] = 8;\n    q[0] = 1;\n    q[1] = 2;\n    q[2] = 3;\n    q[3] = 5;\n    q[4]\
    \ = 8;\n    q[5] = 13;\n    if (n < 6)\n    {\n        return a[n - 1];\n    }\n\
    \    long m = 0;\n    for (m = 2; m <= n - 4; m++)\n    {\n        if (n % 6 ==\
    \ 0)\n        {\n            break;\n        }\n    }\n    if (n % 6 == 0)\n \
    \   {\n        n = n / m;\n        limit = limit * m;\n    }\n    else\n    {\n\
    \        flag = true;\n    }\n    long s = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long t = 0;\n    long k = 0;\n    long f = 0;\n    for (i = 0; i < limit",
  "{\n    Tuple!(ulong, ulong) fib = fibonacci(1UL, 1UL);\n    ulong count = 0UL;\n\
    \    foreach(prime; take(fib, n)) {\n        if(isPrime(prime)) {\n          \
    \  count++;\n        }\n        if(count == n) {\n            return prime;\n\
    \        }\n    }\n    return 0L;\n}", "{\n    long res = 0L;\n    long fib1 =\
    \ 1L;\n    long fib2 = 1L;\n    long cnt = 0L;\n    while (cnt < n) {\n      \
    \  if (is_prime(fib2)) {\n            ++cnt;\n            res = fib2;\n      \
    \  }\n        long t = fib1;\n        fib1 = fib2;\n        fib2 += t;\n    }\n\
    \    return res;\n}", "{\n    long res;\n    long f;\n    ulong i;\n    res =\
    \ 0L;\n    f = 0L;\n    i = 0UL;\n    for (;;) {\n        if (i == n) {\n    \
    \        break;\n        }\n        if (f == 0L) {\n            f = 1L;\n    \
    \    } else {\n            res = f;\n            f = f + res;\n        }\n   \
    \     if (__intrinsic_isprime(f)) {\n            i = i + 1UL;\n        }\n   \
    \ }\n    return res;\n}", "{ \n    long previousPrime = 0;\n    long currentPrime\
    \ = 1;\n    long temp;\n    long fib = 0;\n    long primeCounter = 0;\n    while\
    \ (primeCounter < n) \n    {\n        if (currentPrime > fib) \n        {\n  \
    \          temp = previousPrime;\n            previousPrime = currentPrime;\n\
    \            currentPrime = temp + currentPrime;\n            if (currentPrime.isPrime()\
    \ && currentPrime > fib) \n            {\n                primeCounter++;\n  \
    \              fib = currentPrime;\n            }\n        } \n        else \n\
    \        {\n            temp = previousPrime;\n            previousPrime = currentPrime;\n\
    \            currentPrime = temp + currentPrime;\n            if (currentPrime.isPrime())\
    \ \n            {\n                primeCounter++;\n                fib = currentPrime;\n\
    \            }\n        }\n    }\n    return fib;\n}", "{\n    long f = 2L;\n\
    \    long g = 3L;\n    while (n > 0L) {\n        long t = g;\n        g = g +\
    \ f;\n        f = t;\n        if (is_prime(g)) {\n            n = n - 1L;\n  \
    \      }\n    }\n    return f;\n}", "{\n    nassert(n > 0);\n    auto counter\
    \ = 1L;\n    auto fibo = tuple(1L, 2L);\n    auto sum = fibo[0] + fibo[1];\n \
    \   while (true) \n    {\n        if (isPrime(sum)) \n        {\n            if\
    \ (++counter == n) \n            {\n                return sum;\n            }\n\
    \        }\n        fibo = tuple(fibo[1], sum);\n        sum = fibo[0] + fibo[1];\n\
    \    }\n}", "{\n    void[] fibs = new void[][](10L);\n    auto p = tuple(2L, 1L);\n\
    \    long res = 0L;\n    long i = 1L;\n    while (res < n) {\n        if (p.right\
    \ % 2L == 0L) {\n            fibs ~= p;\n            res = res + 1L;\n       \
    \ }\n        p = tuple(p.left + p.right, p.left);\n        i = i + 1L;\n    }\n\
    \    return fibs[res - 1L].left;\n}\n/*", "    if (isIntegral!long)\n{\n    import\
    \ std.conv;\n    immutable Fibonacci fib = new Fibonacci();\n    int len = 0;\n\
    \    foreach(num; fib.takeWhile!(i => i <= cast(int) max(n * log(n) * log(log(n)),\
    \ 1.0)))\n    {\n        if (isPrime(num))\n        {\n            len++;\n  \
    \          if (len == n)\n            {\n                return num;\n       \
    \     }\n        }\n    }\n    return 0;\n}", "{\n    int count = 0;\n    long\
    \ index = 2;\n    long fn1 = 1;\n    long fn2 = 1;\n    long fn;\n    foreach(i;\
    \ 1 .. n + 1)\n    {\n        if(i <= 2)\n        {\n            fn = 1;\n   \
    \     }\n        else\n        {\n            fn = fn1 + fn2;\n            fn1\
    \ = fn2;\n            fn2 = fn;\n        }\n        if(isPrime(fn))\n        {\n\
    \            count += 1;\n            if(count == n)\n            {\n        \
    \        index = fn;\n            }\n        }\n    }\n    return index;\n}\n\
    /*", "{\n    long a = 2;\n    long b = 3;\n    long i = 1;\n    while (i < n)\
    \ \n    {\n        auto t = a + b;\n        a = b;\n        b = t;\n        if\
    \ (isPrime(t)) \n        {\n            i += 1;\n        }\n    }\n    return\
    \ a;\n}\n/*", "{\n    auto init = std.typecons.Tuple!(\n        long, \n     \
    \   long, \n        ulong\n    )(2L, 3L, 3L);\n    return init.recurrence!(\n\
    \        init, \n        (a, b) => std.typecons.Tuple!(\n            long, \n\
    \            long, \n            ulong\n        )(b, a + b, a + b), \n       \
    \ a => std.math.isPrime(a.length)\n    )[n].item2;\n}", "{ \n    long a = 0L;\n\
    \    long b = 1L;\n    long t = 0L;\n    long count = 0L;\n    while (count <\
    \ n) \n    {\n        t = a + b;\n        a = b;\n        b = t;\n        if (isPrime(t))\
    \ \n        {\n            count += 1L;\n        }\n    }\n    return t;\n}\n ",
  "{\n    switch (n) {\n        case 1L: return 2L;\n        case 2L: return 3L;\n\
    \        case 3L: return 5L;\n        case 4L: return 13L;\n        case 5L: return\
    \ 89L;\n        default: \n        {\n            return __unittest_switch_default;\n\
    \        }\n    }\n}", "{\n    long x, y, z;\n    x = 1L;\n    y = 1L;\n    long\
    \ i = 1L;\n    foreach(z; take(n + 1L, fibonacci())) \n    {\n        if (is_prime(z))\
    \ \n        {\n            x = y;\n            y = z;\n            i++;\n    \
    \    }\n    }\n    return x;\n}\n/*", "{\n    long a = 2L;\n    long b = 3L;\n\
    \    long c = 5L;\n    long cnt = 3L;\n    while (true) \n    {\n        if (isPrime(c))\
    \ \n        {\n            cnt += 1L;\n            if (cnt == n) \n          \
    \  {\n                return c;\n            }\n        }\n        a = b;\n  \
    \      b = c;\n        c = a + b;\n    }\n    return -1L;\n}\n/*", "{\n    auto\
    \ check_prime(bool p) \n    {\n        if (p) \n        {\n            return\
    \ tuple(true, uint.max);\n        }\n        else \n        {\n            return\
    \ tuple(false, 2u);\n        }\n    }\n    auto check_fib(uint a, uint b) \n \
    \   {\n        return (check_prime((a+b).isPrime), a, b);\n    }\n    auto check_index(uint\
    \ i, uint a, uint b) \n    {\n        if (i >= n) \n        {\n            return\
    \ a;\n        }\n        else \n        {\n            return check_index(i+1,\
    \ b, a+b);\n        }\n    }\n    return check_index(2u, 1u, 1u);\n}\n ", "{\n\
    \    long current_fib = 1L;\n    long past_fib = 1L;\n    long future_fib = 1L;\n\
    \    long fib_counter = 1L;\n    long prime_counter = 0L;\n    while (prime_counter\
    \ < n) {\n        future_fib = current_fib + past_fib;\n        past_fib = current_fib;\n\
    \        current_fib = future_fib;\n        fib_counter += 1L;\n        if (prime(current_fib))\
    \ {\n            prime_counter += 1L;\n        }\n    }\n    return current_fib;\n\
    }", "{ \n    tuple!(long, long) p = tuple(1L, 2L);\n    int i = 1;\n    while\
    \ (i < n) \n    {\n        p.swap();\n        p[0] += p[1];\n        if (isPrime(p[0]))\n\
    \            i++;\n    }\n    return p[0];\n}\n/*", "in {\n    assert(n > 0L);\n\
    }\nout(result) {\n    assert(result > 0L);\n}\nbody {\n    long counter = 0L;\n\
    \    long i = 0L;\n    long v = 0L;\n    long fib = 0L;\n    for (; (counter <\
    \ n);) {\n        i += 1L;\n        v = fibonacci(i);\n        if (is_prime(v))\
    \ {\n            counter += 1L;\n            fib = v;\n        }\n    }\n    return\
    \ fib;\n}\n/*", "{\n    long a = 0L;\n    long b = 1L;\n    long p = 2L;\n   \
    \ while (n > 0L) \n    {\n        std.typecons.Tuple!(long, long) tmp = std.math.fibonacci!(std.math.Fibonacci.fib_iter,\
    \ a, b);\n        b = tmp.field0;\n        a = tmp.field1;\n        if (std.math.isPrime(a))\
    \ \n        {\n            p = a;\n            n -= 1L;\n        }\n    }\n  \
    \  return p;\n}", "{\n    static bool[] sieve = new bool[0];\n    static long[]\
    \ fibs = new long[0];\n    static long[] pfibs = new long[0];\n    static long\
    \ nfibs = 0;\n    static long nprimes = 0;\n    long i;\n    long fib;\n    long\
    \ pfib;\n    if (n == 1L) \n    {\n        return 2L;\n    }\n    if (n == 2L)\
    \ \n    {\n        return 3L;\n    }\n    if (n == 3L) \n    {\n        return\
    \ 5L;\n    }\n    if (nfibs < n + 1L) \n    {\n        sieve = primeSieve(sieve,\
    \ (1000000L * n) / ln(1000000L * n));\n        fibs = new long[n + 1L];\n    \
    \    pfibs = new long[n + 1L];\n        pfibs[0L] = 2L;\n        pfibs[1L] = 3L;\n\
    \        pfibs[2L] = 5L;\n        fibs[0L] = 0L;\n        fibs[1L] = 1L;\n   \
    \     fibs[2L] = 1L;\n        fibs[3L] = 2L;\n        fibs[4L] = 3L;\n       \
    \ fibs[5L] = 5L;\n        nfibs = 6L;\n        nprimes = 3L;\n        for (i =\
    \ 6L; i <= n; i++) \n        {\n            fib = fibs[i - 1L] + fibs[i - 2L];\n\
    \            fibs[i] = fib;\n            if (sieve[fib]) \n            {\n   \
    \             pfibs[nprimes] = fib;\n                nprimes++;\n            }\n\
    \            nfibs++;\n        }\n    }\n    return pfibs[n - 1L];\n}\n/*", "{\n\
    \    static Pair!(long, long) prime_fib_accum(long n) {\n        if (n <= 1L)\
    \ {\n            return Pair!(long, long)(0L, 2L);\n        } else {\n       \
    \     auto p = prime_fib_accum(n - 1L);\n            long q = p.a + p.b;\n   \
    \         while (true) {\n                if (isPrime(q)) {\n                \
    \    return Pair!(long, long)(p.b, q);\n                }\n                q +=\
    \ p.a;\n            }\n        }\n    }\n    auto p = prime_fib_accum(n);\n  \
    \  return p.b;\n}\n/*", "{\n    auto fib = tuple(0L, 1L);\n    long res = -1L;\n\
    \    long i = 2L;\n    while (n > 0L) \n    {\n        fib[0] = fib[1];\n    \
    \    fib[1] = fib[0] + fib[1];\n        if (isPrime(fib[1])) \n        {\n   \
    \         --n;\n            res = fib[1];\n        }\n        ++i;\n    }\n  \
    \  return res;\n}", "{ \n    long a = 0, b = 1, c = 1;\n    long x = 1;\n    while\
    \ (n > x) {\n        if (isPrime(c)) {\n            x++;\n        }\n        c\
    \ = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n/*", "{\n\
    \    static int[] fibs = new int[60000];\n    static bool[] notprime = new bool[60000];\n\
    \    static int count = 0;\n    if (count == 0) \n    {\n        fibs[0] = 1;\n\
    \        fibs[1] = 2;\n        count = 2;\n        int k = 2;\n        while (k\
    \ < sqrt(notprime.length)) \n        {\n            for (int i = 2 * k; i < notprime.length;\
    \ i += k) \n            {\n                notprime[i] = true;\n            }\n\
    \            ++k;\n            while (k < notprime.length && notprime[k]) \n \
    \           {\n                ++k;\n            }\n        }\n        for (int\
    \ i = 0; i < fibs.length; ++i) \n        {\n            if (i >= 2) \n       \
    \     {\n                fibs[i] = fibs[i - 1] + fibs[i - 2];\n            }\n\
    \            if (fibs[i] >= notprime.length) \n            {\n               \
    \ break;\n            }\n            if (!notprime[fibs[i]]) \n            {\n\
    \                ++count;\n            }\n        }\n    }\n    if (n > count)\
    \ \n    {\n        throw new Exception(\"n-th prime fibonacci number doesn't exist\"\
    );\n    }\n    int pos = 0;\n    while (n > 0) \n    {\n        if (!notprime[fibs[pos]])\
    \ \n        {\n            --n;\n        }\n        ++pos;\n    }\n    return\
    \ fibs[pos - 1];\n}\n/*", "{\n    if (n < 1L) \n    {\n        return -1L;\n \
    \   }\n    else if (n == 1L) \n    {\n        return 2L;\n    }\n    else if (n\
    \ == 2L) \n    {\n        return 3L;\n    }\n    else \n    {\n        int i =\
    \ 3;\n        long prev = 2L;\n        long curr = 3L;\n        while (i < n)\
    \ \n        {\n            long next = prev + curr;\n            prev = curr;\n\
    \            curr = next;\n            if (curr.isPrime) \n            {\n   \
    \             i++;\n            }\n        }\n        return curr;\n    }\n}\n\
    /*", "{\n    auto v = tuple(2L, 3L);\n    long k = 2L;\n    long p = 5L;\n   \
    \ while (k < n) {\n        p += v[0];\n        v[0] = v[1];\n        v[1] = p;\n\
    \        if (isPrime(p)) {\n            k += 1L;\n        }\n    }\n    return\
    \ p;\n}\n// Nannoukaikan found this solution (https://github.com/Nannoukaikan/Euler-30-days/blob/main/Day%204/euler4.d)",
  "{\n    long c = 0;\n    Tuple!(ulong, ulong) fibonacci = tuple(1, 1);\n    while\
    \ (c < n) \n    {\n        ulong a = fibonacci[0];\n        ulong b = fibonacci[1];\n\
    \        fibonacci = tuple(b, a + b);\n        if (isPrime(fibonacci[1])) \n \
    \       {\n            c++;\n        }\n    }\n    return cast(long)fibonacci[1];\n\
    }", "{\n    if (n < 1L) {\n        throw new Exception(\"prime_fib(): argument\
    \ must be non-negative.\");\n    }\n    if (n == 1L) {\n        return 2L;\n \
    \   }\n    if (n == 2L) {\n        return 3L;\n    }\n    long a = 2L;\n    long\
    \ b = 3L;\n    long n_prime_fib = 2L;\n    while (true) {\n        long a_tmp\
    \ = a;\n        a = b;\n        b = a_tmp + b;\n        if (a.isPrime()) {\n \
    \           n_prime_fib += 1L;\n            if (n_prime_fib == n) {\n        \
    \        return a;\n            }\n        }\n    }\n}\n/*", "{\n    long a =\
    \ 0L;\n    long b = 1L;\n    long result = 0L;\n    long counter = 0L;\n    while\
    \ (counter < n) {\n        result = a + b;\n        a = b;\n        b = result;\n\
    \        if (is_prime(result)) {\n            counter++;\n        }\n    }\n \
    \   return result;\n}", "{\n    int x = 2;\n    long a = 1L;\n    long b = 2L;\n\
    \    long c = 0L;\n    int count = 2;\n    if (n <= 1) {\n        return 1L;\n\
    \    }\n    while (x <= n) {\n        c = a + b;\n        if (isPrime(c)) {\n\
    \            count++;\n        }\n        if (count == n) {\n            return\
    \ c;\n        }\n        a = b;\n        b = c;\n        x++;\n    }\n    return\
    \ c;\n}\n/*", "{\n    long a = 2L;\n    long b = 3L;\n    long i = 2L;\n    long\
    \ f = 1L;\n    long x = 2L;\n    long y = 3L;\n    long z = 5L;\n    long m =\
    \ 0L;\n    long result = 0L;\n    long dummy = 0L;\n    long j = 0L;\n    long\
    \ k = 0L;\n    long l = 0L;\n    long h = 0L;\n    long c = 0L;\n    int cmp =\
    \ 0;\n    auto cmp_func = (long a, long b) {\n        auto res = a < b;\n    \
    \    return res;\n    };\n    auto g = std.functional.map(cmp_func);\n    auto\
    \ p = g.item;\n    auto q = g.rest;\n    int t = 0;\n    int s = 0;\n    auto\
    \ res = tuple(x, y, z);\n    int not_prime = 0;\n    long number = 0L;\n    if\
    \ (n == 1L) \n    {\n        return 2L;\n    }\n    if (n == 2L) \n    {\n   \
    \     return 3L;\n    }\n    i = 3L;\n    while (i < n) \n    {\n        f = x\
    \ + y;\n        x = y;\n        y = z;\n        z = f;\n        i = i + 1L;\n\
    \    }\n    z = z - y;\n    y = y - x;\n    x = z - y;\n    result = z;\n    if\
    \ (n > 4L) \n    {\n        a = 2L;\n        b = 3L;\n        while (a < (z /\
    \ 2L)) \n        {\n            dummy = 2L;\n            while (dummy < (b / 2L))\
    \ \n            {\n                if ((b % dummy) == 0L) \n                {\n\
    \                    not_prime = 1;\n                }\n                dummy\
    \ = dummy + 1L;\n            }\n            if (not_prime == 0) \n           \
    \ {\n                if ((z % b) == 0L) \n                {\n                \
    \    c = z", "{\n    long res = 0;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 2;\n    long count = 0;\n    while (count < n) \n    {\n        if (isPrime(c))\
    \ \n        {\n            count++;\n            res = c;\n        }\n       \
    \ a = b;\n        b = c;\n        c = a + b;\n    }\n    return res;\n}\n/*",
  "{\n    // check if n is positive\n    // check if n is positive\n    if (n < 1L)\n\
    \    {\n        throw new std.Exception(\"n < 1L\");\n    }\n    // the first\
    \ two Fibonacci numbers are both primes,\n    // so we need to check for them\
    \ specifically\n    if (n == 1L)\n    {\n        return 2L;\n    }\n    if (n\
    \ == 2L)\n    {\n        return 3L;\n    }\n    // initialize the counter and\
    \ the last two Fibonacci numbers\n    long prime_fib_counter = 2L;\n    long last_fib\
    \ = 3L;\n    long last_last_fib = 2L;\n    while (true)\n    {\n        // compute\
    \ the next Fibonacci number\n        long next_fib = last_fib + last_last_fib;\n\
    \        // if the next Fibonacci number is prime, increment the counter\n   \
    \     if (is_prime(next_fib))\n        {\n            prime_fib_counter += 1L;\n\
    \        }\n        // if the counter has reached n, return the next Fibonacci\
    \ number\n        if (prime_fib_counter == n)\n        {\n            return next_fib;\n\
    \        }\n        // move the next Fibonacci number to last Fibonacci number\n\
    \        // and move the last Fibonacci number to last last Fibonacci number\n\
    \        last_last_fib = last_fib;\n        last_fib = next_fib;\n    }\n}\n/*",
  "{\n    long f0 = 0L;\n    long f1 = 1L;\n    long f2 = 1L;\n    long i = 2L;\n\
    \    foreach(long fib; take(n, zip(cycle(f0, f1), cycle(f1, f2)))) \n    {\n \
    \       if(isPrime(fib)) \n        {\n            i += 1L;\n        }\n      \
    \  f0 = f1;\n        f1 = f2;\n        f2 = f0 + f1;\n    }\n    return (i);\n\
    }", "{\n    long pfib(long f0, long f1, long n, long i) \n    {\n        return\
    \ (i > n) ? f0 : pfib(f1, f0 + f1, n, i + 1L);\n    }\n    return pfib(0L, 1L,\
    \ n, 1L);\n}\n/*", "{\n    long f,f1,f2;\n    long i,numprimes;\n    numprimes\
    \ = 0;\n    f1 = 1;\n    f2 = 1;\n    for (i = 1; i < n; i++) {\n        f = f1\
    \ + f2;\n        f1 = f2;\n        f2 = f;\n        if (is_prime(f)) {\n     \
    \       numprimes++;\n            if (numprimes == n) {\n                return\
    \ f;\n            }\n        }\n    }\n    return -1;\n}", "{\n    // NUmber of\
    \ Fibonacci numbers to pregenerate\n    const int fib_cache_size = 50;\n    //\
    \ Pregenerate fibonacci numbers\n    immutable double phi = (1.0 + sqrt(5.0))\
    \ / 2.0;\n    immutable double psi = 1.0 - phi;\n    immutable double tmp = pow(phi,\
    \ cast(double) fib_cache_size);\n    double fib[fib_cache_size];\n    foreach\
    \ (i, ref e; fib)\n    {\n        e = cast(double) fib_cache_size * pow(psi, cast(double)\
    \ i) / sqrt(5.0);\n    }\n    // Local function that returns true if provided\
    \ number is a Fibonacci number\n    bool is_fib(long x)\n    {\n        if (x\
    \ > tmp)\n        {\n            return false;\n        }\n        foreach (ref\
    \ e; fib)\n        {\n            if (e > x)\n            {\n                return\
    \ false;\n            }\n            if (cast(long) e == x)\n            {\n \
    \               return true;\n            }\n        }\n        return false;\n\
    \    }\n    // Use sieve of Eratosthenes to generate prime numbers\n    // this\
    \ is not the most efficient implementation\n    // but we can assume that provided\
    \ n won't be too big\n    long limit = cast(long) sqrt(cast(double) n) + 3;\n\
    \    bool[] sieve = new bool[limit];\n    sieve[0] = true;\n    sieve[1] = true;\n\
    \    foreach (i, ref e; sieve)\n    {\n        if (e)\n        {\n           \
    \ continue;\n        }\n        for (long j = i * i; j < limit; j += i)\n    \
    \    {\n            sieve[j] = true;\n        }\n    }\n    // Local function\
    \ that returns true if provided number is prime\n    bool is_prime(long x)\n \
    \   {\n        if (x < limit)\n        {\n            return !sieve[x];\n    \
    \    }\n        foreach (e; sieve)\n        {\n            if (x % e == 0)", "{\n\
    \    long result = 0L;\n    long a = 1L;\n    long b = 1L;\n    long i = 2L;\n\
    \    while (i <= n) \n    {\n        if (a % 2L == 0L) \n        {\n         \
    \   if (is_prime(a)) \n            {\n                result = a;\n          \
    \      i = i + 1L;\n            }\n        }\n        auto tmp = a;\n        a\
    \ = b;\n        b = b + tmp;\n    }\n    return result;\n}", "{\n    long c =\
    \ 1;\n    long a = 1;\n    long b = 2;\n    long p = 1;\n    static if(n >= 1)\n\
    \    {\n        for(long i = 3; i <= n; i++)\n        {\n            c = a + b;\n\
    \            a = b;\n            b = c;\n            if(c % 2 == 0)\n        \
    \    {\n                while(c % 2 == 0)\n                {\n               \
    \     c /= 2;\n                }\n            }\n            if(c % 3 == 0)\n\
    \            {\n                while(c % 3 == 0)\n                {\n       \
    \             c /= 3;\n                }\n            }\n            if(c % 5\
    \ == 0)\n            {\n                while(c % 5 == 0)\n                {\n\
    \                    c /= 5;\n                }\n            }\n            if(c\
    \ % 7 == 0)\n            {\n                while(c % 7 == 0)\n              \
    \  {\n                    c /= 7;\n                }\n            }\n        \
    \    p = c;\n        }\n    }\n    return p;\n}", "{ \n    assert(n >= 1); \n\
    \    auto fib = tuple(1L, 1L); \n    long cnt = 1; \n    while (cnt < n) \n  \
    \  { \n        fib = tuple(fib[1], fib[0] + fib[1]); \n        if (fib[1].isPrime)\
    \ \n            cnt++; \n    } \n    return fib[1]; \n}", "{\n    long i = 2L;\n\
    \    long prime_count = 0L;\n    while (prime_count < n) {\n        if (is_prime(i)\
    \ && is_fib(i)) {\n            prime_count++;\n        }\n        i++;\n    }\n\
    \    return i - 1L;\n}\n/*", "    in(n,1,50)\n    out(p)\n    ensure(p>1)\n{\n\
    \    typeof(return) p;\n    long v = 0;\n    long f1 = 1;\n    long f2 = 1;\n\
    \    long fn = 1;\n    while (true)\n    {\n        fn = f1 + f2;\n        f1\
    \ = f2;\n        f2 = fn;\n        if (is_prime(fn))\n        {\n            v++;\n\
    \            if (v == n)\n            {\n                p = fn;\n           \
    \     break;\n            }\n        }\n    }\n    return p;\n}", "{\n    static\
    \ struct Fibo {\n        long f0;\n        long f1;\n        long n;\n       \
    \ this(long x, long y, long k) {\n            f0 = x;\n            f1 = y;\n \
    \           n = k;\n        }\n    }\n    // fib sequence is the sequence of (f0,\
    \ f1, n)\n    const fib_sequence = tuple(2L, 3L, 1L);\n    // create a DSUtil.Sequence\
    \ to make a continuous fibonacci sequence\n    auto fibo = DSUtil.Sequence(fib_sequence,\
    \ (Fibo fib) {\n        auto f2 = fib.f0 + fib.f1;\n        auto newFibo = Fibo(fib.f1,\
    \ f2, fib.n + 1);\n        return newFibo;\n    });\n    while (fibo.front.n <\
    \ n)\n        fibo.popFront();\n    if (fibo.front.n == n)\n        return fibo.front.f1;\n\
    \    else\n        return 2L;\n}\n/*", "{\n    long fib = 1L;\n    long fib_old\
    \ = 1L;\n    long prime_fib = 0L;\n    long counter = 0L;\n    while (counter\
    \ < n) \n    {\n        fib_old = fib;\n        fib = fib + prime_fib;\n     \
    \   prime_fib = fib_old;\n        if (is_prime(fib)) counter++;\n    }\n    return\
    \ fib;\n}\n/*", "{\n    long a = 2L;\n    long b = 3L;\n    long r = 5L;\n   \
    \ long i = 3L;\n    while (true) {\n        if (isPrime(r)) {\n            n--;\n\
    \            if (n == 0L) {\n                return r;\n            }\n      \
    \  }\n        a = b;\n        b = r;\n        r = a + b;\n        i++;\n    }\n\
    \    return -1L;\n}", "{\n    assert(n >= 1L);\n    long fibonacci = 2L;\n   \
    \ long fibonacci_2 = 1L;\n    long counter = 1L;\n    while (counter < n) {\n\
    \        long temp = fibonacci;\n        fibonacci += fibonacci_2;\n        fibonacci_2\
    \ = temp;\n        if (fibonacci % 2L == 0L)\n            continue;\n        if\
    \ (is_prime(fibonacci))\n            counter += 1L;\n    }\n    return fibonacci;\n\
    }", "{\n    long i = 1L;\n    long c = 0L;\n    long f = 1L;\n    long f2 = 1L;\n\
    \    long f1 = 2L;\n    while (c < n) \n    {\n        if (std.math.isPrime(f1))\
    \ \n        {\n            c++;\n        }\n        i++;\n        f = f1 + f2;\n\
    \        f2 = f1;\n        f1 = f;\n    }\n    return f1;\n}\n/*", "{\n    auto\
    \ gen = lazyPrimeGen();\n    auto f = (0L, 1L);\n    while (--n > 0) \n    {\n\
    \        while (!gen.nextPrime(f[1]) || !isFibonacci(f[1])) \n        {\n    \
    \        f[1]++;\n        }\n        f = f[1], f[0] + f[1];\n    }\n    return\
    \ f[0];\n}", "{\n    auto fib = [](ulong n) { \n        // phi = (1 + sqrt(5))\
    \ / 2\n        // fn = (phi^n - (1 - phi)^n) / sqrt(5)\n        auto phi = (1.0\
    \ + sqrt(5.0)) / 2.0;\n        return cast(long)((pow(phi, n) - pow(1.0 - phi,\
    \ n)) / sqrt(5.0));\n    };\n    auto is_prime = [](long n) { \n        if (n\
    \ < 0) return false;\n        if (n < 4) return true;\n        for (long i = 2;\
    \ i <= trunc(sqrt(n)); i++) {\n            if (n % i == 0) return false;\n   \
    \     }\n        return true;\n    };\n    long i = 1L;\n    long f = 1L;\n  \
    \  while (i < n) {\n        f += 1L;\n        if (is_prime(fib(f))) {\n      \
    \      i += 1L;\n        }\n    }\n    return fib(f);\n}\n/*", "    if (isSomeString!n)\
    \ {\n    import std.conv;\n    n = to!long(n);\n}", "{\n    long num_primes =\
    \ 1L;\n    long a = 1L;\n    long b = 1L;\n    long c = a + b;\n    auto swap\
    \ = std.typecons.Tuple!(long, long)(a, b);\n    while (true) \n    {\n       \
    \ if (isPrime(c)) \n        {\n            ++num_primes;\n            if (num_primes\
    \ == n) \n            {\n                return c;\n            }\n        }\n\
    \        a = swap[0];\n        b = swap[1];\n        c = a + b;\n        swap[0]\
    \ = b;\n        swap[1] = c;\n    }\n}", "{\n    long count = 0L;\n    long prime_fib_result\
    \ = 0L;\n    long fib_minus_2 = 0L;\n    long fib_minus_1 = 1L;\n    long fib\
    \ = 0L;\n    long tmp = 0L;\n    long is_prime = 0L;\n    for (long i = 0L; i\
    \ < n; i++) \n    {\n        fib = fib_minus_1 + fib_minus_2;\n        if (fib\
    \ <= 1L) \n        {\n            is_prime = 0L;\n        }\n        else \n \
    \       {\n            if (fib == 2L) \n            {\n                is_prime\
    \ = 1L;\n            }\n            else \n            {\n                is_prime\
    \ = 1L;\n                tmp = sqrt(fib);\n                for (long j = 2L; j\
    \ <= tmp; j++) \n                {\n                    if (fib % j == 0L) \n\
    \                    {\n                        is_prime = 0L;\n             \
    \           break;\n                    }\n                }\n            }\n\
    \        }\n        if (is_prime) \n        {\n            count++;\n        \
    \    prime_fib_result = fib;\n        }\n        fib_minus_2 = fib_minus_1;\n\
    \        fib_minus_1 = fib;\n    }\n    return prime_fib_result;\n}\n/*", "{\n\
    \    long a = 2L;\n    long b = 3L;\n    long f = 5L;\n    long i = 5L;\n    while\
    \ (true) \n    {\n        if (is_prime(f)) \n        {\n            n -= 1L;\n\
    \            if (n == 0L) \n            {\n                return f;\n       \
    \     }\n        }\n        a = b;\n        b = f;\n        f = a + b;\n     \
    \   i += 1L;\n    }\n    return -1L;\n}\n/*", "{\n    long i = 1L;\n    long c\
    \ = 0L;\n    long a = 0L;\n    long b = 1L;\n    while (c < n)\n    {\n      \
    \  auto temp = a;\n        a = b;\n        b = temp + b;\n        if (is_prime(a))\n\
    \        {\n            c = c + 1L;\n        }\n        i = i + 1L;\n    }\n \
    \   return a;\n}\n/*", "{\n    int pos = 0;\n    int f1 = 0;\n    int f2 = 1;\n\
    \    int i = 0;\n    // n-th number that is a Fibonacci number and it's also prime\n\
    \    // 1L -> 2L\n    // 2L -> 3L\n    // 3L -> 5L\n    // 4L -> 13L\n    // 5L\
    \ -> 89L\n    while (pos < n) \n    {\n        i = f1 + f2;\n        if (isPrime(i))\
    \ pos++;\n        f1 = f2;\n        f2 = i;\n    }\n    return i;\n}\n/*", "{\n\
    \    auto t = tuple!(Tuple, long, long)(1L, 2L);\n    long index = 2L;\n    long\
    \ result = 2L;\n    while (index < n) {\n        t = tuple(t[1], t[0] + t[1]);\n\
    \        index++;\n        if (isPrime(t[1])) {\n            result = t[1];\n\
    \            index++;\n        }\n    }\n    return result;\n}\n/*", "{\n    if\
    \ (n < 1L)\n    {\n        throw new Exception(\"Input must be greater than zero!\"\
    );\n    }\n    if (n < 3L)\n    {\n        return n + 1L;\n    }\n    auto p =\
    \ (long)(sqrt(5.0) * (long)pow(1.618033988749894848, n)) + 1L;\n    p += p % 2L;\n\
    \    if (p < 5L)\n    {\n        p = 5L;\n    }\n    auto left = new long[1L];\n\
    \    left[0L] = 3L;\n    auto right = new long[1L];\n    right[0L] = p;\n    if\
    \ (0L == Sieve.is_prime(2L, left, right))\n    {\n        return 2L;\n    }\n\
    \    if (0L == Sieve.is_prime(3L, left, right))\n    {\n        return 3L;\n \
    \   }\n    auto f1 = 2L;\n    auto f2 = 3L;\n    auto f3 = 5L;\n    long prime\
    \ = 0L;\n    long i = 3L;\n    while (true)\n    {\n        if (0L == Sieve.is_prime(f3,\
    \ left, right))\n        {\n            prime = f3;\n            i++;\n      \
    \      if (i == n)\n            {\n                break;\n            }\n   \
    \     }\n        f1 = f2;\n        f2 = f3;\n        f3 = f1 + f2;\n    }\n  \
    \  return prime;\n}", "{\n    alias Fibonacci=Tuple!(long, long);\n    return\
    \ unfold!((fib) {\n            if ( isPrime(fib[0]) )\n                return\
    \ tuple(fib[1], fib[0] + fib[1]);\n            else\n                return tuple(fib[1],\
    \ fib[0] + fib[1]);\n        })(Fibonacci(1L, 2L))[n - 1L];\n}", "{\n    long\
    \ a=1, b=1, c=1;\n    long count=1;\n    while(count<n)\n    {\n        c=a+b;\n\
    \        a=b;\n        b=c;\n        if(isPrime(c))\n            count++;\n  \
    \  }\n    return c;\n}", "{\n    assert(n >= 1L);\n    if (n == 1L)\n    {\n \
    \       return 2L;\n    }\n    if (n == 2L)\n    {\n        return 3L;\n    }\n\
    \    long[] fib = new long[1L];\n    fib[0L] = 2L;\n    long cnt = 1L;\n    long\
    \ a = 1L;\n    long b = 1L;\n    for (long i = 0L; i < (n - 2L); i++)\n    {\n\
    \        long c = a + b;\n        a = b;\n        b = c;\n        while (c % fib[0L]\
    \ == 0L)\n        {\n            fib = fib[1L..$];\n        }", "{ \n    // generate\
    \ prime numbers using Eratosthenes sieve \n    Tuple!(size_t[], size_t[]) primes\
    \ = generate_primes_eratosthenes(n * 100);\n    immutable size_t[] prime_seq =\
    \ primes[0];\n    immutable size_t[] is_prime = primes[1];\n    // generate fibonacci\
    \ numbers\n    long[] fibs = generate_fibs(n * 100);\n    // combine them\n  \
    \  int count = 0;\n    for (size_t i = 0; i < prime_seq.length; i++)\n    {\n\
    \        if (fibs.canFind(prime_seq[i]))\n        {\n            count++;\n  \
    \          if (count == n)\n            {\n                return prime_seq[i];\n\
    \            }\n        }\n    }\n    return 0;\n}", "{\n    static long[] result\
    \ = [2L, 3L, 5L, 13L, 89L];\n    assert(n > 0L);\n    if (n < result.length)\n\
    \        return result[n - 1L];\n    else \n    {\n        long a = result[$ -\
    \ 1L];\n        long b = result[$ - 2L];\n        long i = result.length;\n  \
    \      while (i < n) \n        {\n            auto c = a + b;\n            if\
    \ (isPrime(c)) \n            {\n                result ~= c;\n               \
    \ i += 1L;\n            }\n            a = b;\n            b = c;\n        }\n\
    \        return result[$ - 1L];\n    }\n}\n/*", "{\n    return to!long(std.math.primeFibonacci(n));\n\
    }", "{\n    // fibonacci numbers :\n    // f1 = 1\n    // f2 = 1\n    // fn =\
    \ fn-1 + fn-2\n    // \n    // The prime factors of F(n) are 2, 3, 5, 13, 89,\
    \ 233, 1597, 28657, 514229, ... \n    // Each of these is prime, aside from 1597\
    \ which is prime-exponent composite. \n    // It is generally conjectured that\
    \ the prime factors of F(n) must always be prime.\n    // \n    // The prime factors\
    \ of F(n) are the only primes between F(n-1) and F(n). \n    // Thus the prime\
    \ factors of F(n) are less than or equal to F(n) and greater than F(n-1).\n  \
    \  // \n    // F(n) is a Fibonacci prime if and only if 5*F(n)^2 + 4 or 5*F(n)^2\
    \ \u2013 4 is prime.\n    //\n    // F(n) is a Fibonacci prime if and only if\
    \ one, and therefore both, of (5*F(n) +- 1) are prime.\n    //\n    // F(n) is\
    \ a Fibonacci prime if and only if F(n) is a prime and F(n-1) is 1 or 2 (mod 5).\n\
    \    //\n    // For example:\n    // F(4) = 3 is a Fibonacci prime, because F(3)\
    \ = 2 is a prime and F(2) = 1 is 1 (mod 5)\n    // F(5) = 5 is a Fibonacci prime,\
    \ because F(4) = 3 is a prime and F(3) = 2 is 2 (mod 5)\n    // F(6) = 8 is not\
    \ a Fibonacci prime, because F(5) = 5 is not a prime\n    //\n    // F(11) = 89\
    \ is a Fibonacci prime, because F(10) = 55 is a prime and F(9) = 34 is 4 (mod\
    \ 5)\n    // F(12) = 144 is not a Fibonacci prime, because F(11) = 89 is not a\
    \ prime\n    //\n    // F(16) = 987 is a", "{\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.numeric;\n    import std.math;\n    import std.typecons;\n\
    \    auto is_prime = (l) {\n        if (l < 2) return false;\n        if (l ==\
    \ 2) return true;\n        if (l % 2 == 0) return false;\n        auto is_odd\
    \ = (l) { return l % 2 == 1; };\n        auto is_divisible = (x) { return l %\
    \ x == 0; };\n        return !(2.iota().dropWhile!(is_odd).takeWhile!(is_odd).any!(is_divisible));\n\
    \    };\n    auto fib = iota(1, 100_000L).map!(a => a.product).drop(2).take(100_000L).filter!(is_prime).take(100_000L);\n\
    \    return fib[n - 1L];\n}", "{\n    if (n <= 0L) {\n        return n;\n    }\n\
    \    tuple!(int, int, int) f(int n, int a, int b) {\n        return tuple(n, b,\
    \ a + b);\n    }\n    return tuple_expand!(int, int, int)(iota(n)\n        .map!(a\
    \ => f(a, 0, 1))\n        .filter!(a => (a[1] != 0L) && isPrime(a[1]))\n     \
    \   .front)[1];\n}\n/*", "{\n    auto f = fibonacci ! \"a, b => b, a + b\"(2L,\
    \ 3L);\n    while (true) \n    {\n        n--;\n        if (n == 0L) \n      \
    \  {\n            return f[0];\n        }\n        if (isPrime(f[1])) \n     \
    \   {\n            n--;\n            if (n == 0L) \n            {\n          \
    \      return f[1];\n            }\n        }\n    }\n}", "{\n    struct PrimeFibonacci\
    \ \n    {\n        bool prime(ulong n) \n        {\n            static if (n ==\
    \ 2 || n == 3) \n            {\n                return true;\n            }\n\
    \            else if (n < 2 || n % 2 == 0 || n % 3 == 0) \n            {\n   \
    \             return false;\n            }\n            else \n            {\n\
    \                foreach (i; 5 .. cast(ulong)isqrt(n) + 1) \n                {\n\
    \                    if (n % i == 0 || n % (i + 2) == 0) \n                  \
    \  {\n                        return false;\n                    }\n         \
    \       }\n                return true;\n            }\n        }\n        //\
    \ Fibonacci generator\n        Tuple!(ulong, ulong) fibonacci() \n        {\n\
    \            ulong i = 1, j = 0;\n            while (true) \n            {\n \
    \               auto result = Tuple!(ulong, ulong)(i, j);\n                j =\
    \ i + j;\n                i = j - i;\n                yield result;\n        \
    \    }\n        }\n    } pf;\n    long counter = 0;\n    foreach (pf.fibonacci;\
    \ pf.fibonacci()) \n    {\n        if (pf.prime(pf.fibonacci[0])) \n        {\n\
    \            counter++;\n            if (counter == n) \n            {\n     \
    \           return pf.fibonacci[0];\n            }\n        }\n    }\n    return\
    \ 0;\n}", "{\n    long prime_fib_helper(long n, long f0, long f1) \n    {\n  \
    \      if (n == 1L)\n            return f0;\n        else if (isPrime!long(f1)\
    \ && (f1 % f0) == 0L)\n            return prime_fib_helper(n - 1L, f1, f1 + f0);\n\
    \        else\n            return prime_fib_helper(n, f1, f1 + f0);\n    }\n \
    \   return prime_fib_helper(n, 2L, 3L);\n}\n/*", "{ \n    size_t count = 1; \n\
    \    long prev = 0, curr = 2; \n    while (count < n) \n    { \n        // Calculate\
    \ the next term \n        long next = prev + curr; \n  \n        // Check if the\
    \ next term is a prime number \n        if (isPrime(next)) \n            count++;\
    \ \n  \n        // Update values of prev and curr \n        prev = curr; \n  \
    \      curr = next; \n    } \n    return curr; \n} \n  \n// Function to check\
    \ if a number is prime or not ", "{\n  import std.math : isPrime;\n  long fib\
    \ = 2;\n  long prev1 = 1;\n  long prev2 = 2;\n  n -= 1;\n  while (true) \n  {\n\
    \    if (n == 0 && isPrime(fib)) \n    {\n      return fib;\n    }\n    else if\
    \ (isPrime(fib)) \n    {\n      n -= 1;\n    }\n    prev2 = prev1;\n    prev1\
    \ = fib;\n    fib = prev1 + prev2;\n  }\n}", "{\n    int num = 1;\n    int i =\
    \ 0;\n    long fib_num = 0;\n    while (i < n)\n    {\n        fib_num = fibonacci(num);\n\
    \        if (is_prime(fib_num))\n        {\n            i++;\n        }\n    \
    \    num++;\n    }\n    return fib_num;\n}", "{\n    long i = 1;\n    long j =\
    \ 1;\n    long t = 1;\n    long p = 0;\n    long count = 0;\n    while (count\
    \ != n) \n    {\n        t = i + j;\n        i = j;\n        j = t;\n        if\
    \ (isPrime(t)) \n        {\n            count++;\n            p = t;\n       \
    \ }\n    }\n    return p;\n}\n/*", "{ \n    long elem=0L;\n    long j=1L;\n  \
    \  while(n) \n    { \n        if(is_prime(elem))\n        {\n            n-=1L;\n\
    \            j=elem;\n        }\n        elem=fib(j);\n        j+=1L;\n    } \n\
    \    return elem;\n}\nlong fib(long n)\n{\n    return (pow(1.6180339887498948L,n)-pow(-0.6180339887498948L,n))/2.2360679774997896L;\n\
    }", "{\n    struct tup { long fib; long prime; } i = {0L, 1L};\n    auto j = 0L;\n\
    \    auto f = Fibonacci!long();\n    while (true) {\n        i.fib = f.front;\n\
    \        i.prime = isPrime!long(i.fib);\n        f.popFront();\n        if (i.prime)\
    \ {\n            ++j;\n            if (j == n) {\n                return i.fib;\n\
    \            }\n        }\n    }\n}", "{\n    auto primes = take(n, filter!((i)\
    \ => isPrime(i))(iota(1L, 20000L)));\n    auto fibonacci = new LazyList!(ulong)(0L,\
    \ 1L, (i, j) => i + j);\n    return fibonacci.filter!((i) => binarySearch(i, primes)\
    \ != -1).take(n).front;\n}", "{\n    return A(n).n;\n}\n/*", "{\n    /* \n   \
    \     First, just find the n-th Fibonacci number.\n    */\n    long[] fib_nums\
    \ = [ 1L, 1L ];\n    while (fib_nums.length <= n) \n    {\n        fib_nums ~=\
    \ fib_nums[$ - 1] + fib_nums[$ - 2];\n    }\n    /*\n        Now, iterate over\
    \ all numbers in the list and return n-th prime number.\n    */\n    long i =\
    \ 0L;\n    long counter = 0L;\n    while (counter < n) \n    {\n        if (is_prime(fib_nums[i]))\
    \ \n        {\n            counter += 1L;\n        }\n        i += 1L;\n    }\n\
    \    return fib_nums[i - 1L];\n}\n/*\n    is_prime returns true if n is prime,\
    \ false otherwise.\n    >>> is_prime(7L)\n    true\n    >>> is_prime(12L)\n  \
    \  false\n*/", "{\n    long result = 0L;\n    long next = 1L;\n    long counter\
    \ = 0L;\n    while (counter < n) \n    {\n        long tmp = next;\n        next\
    \ = result + next;\n        result = tmp;\n        if (next.isPrime)\n       \
    \ {\n            counter++;\n        }\n    }\n    return next;\n}\n/*", "{\n\
    \    if (n == 1L) \n    {\n        return 2L;\n    }\n    import std.math : isPrime;\n\
    \    if (n == 2L) \n    {\n        return 3L;\n    }\n    long fn = 5L;\n    long\
    \ pn = 2L;\n    for (; pn < n;) \n    {\n        import std.math : isPrime;\n\
    \        if (isPrime(fn)) \n        {\n            ++pn;\n        }\n        import\
    \ std.math : fibonacci;\n        fn = fibonacci(fn);\n    }\n    return fn;\n\
    }\n/*", "{\n    auto current = tuple(2L, 3L);\n    long counter = 2L;\n    while\
    \ (counter < n) \n    {\n        current = tuple(current[1], current[0] + current[1]);\n\
    \        if (isPrime(current[1])) \n        {\n            counter++;\n      \
    \  }\n    }\n    return current[1];\n}\n/*", "{\n    nthPrimeFibonacci!(isPrime!long)(n);\n\
    }", "{\n    int i = 1;\n    long f1 = 1L;\n    long f2 = 1L;\n    while (i < n)\
    \ {\n        auto tmp = f1 + f2;\n        f1 = f2;\n        f2 = tmp;\n      \
    \  if (isPrime(f2)) {\n            i += 1;\n        }\n    }\n    return f2;\n\
    }", "in\n{\n    assert(n > 0L);\n}\nbody\n{\n    return (() =>\n    {\n      \
    \  long fib = 1L;\n        long prev = 0L;\n        long counter = 0L;\n     \
    \   long i = 0L;\n        for (; n > counter; n--)\n        {\n            fib\
    \ = fib + prev;\n            prev = fib - prev;\n            if (isPrime(fib))\n\
    \            {\n                counter++;\n            }\n        }\n       \
    \ return fib;\n    })();\n}", "{\n    long last = 0L;\n    long current = 1L;\n\
    \    long answer = 0L;\n    long q = 0L;\n    foreach (i; 0L .. n - 1L)\n    {\n\
    \        q = current + last;\n        last = current;\n        current = q;\n\
    \        if (isPrime(current))\n        {\n            answer = current;\n   \
    \     }\n    }\n    return answer;\n}\n ", "{\n    assert(n >= 1L);\n    long\
    \ i = 1L;\n    long f = 1L;\n    long p = 1L;\n    while (i < n) {\n        long\
    \ tf = f;\n        long tp = p;\n        f = tp + tf;\n        if (isPrime(f))\
    \ {\n            i += 1L;\n            p = f;\n        }\n    }\n    return p;\n\
    }\n/*", "{\n    static long r = 1L;\n    static long p = 0L;\n    static long\
    \ q = 1L;\n    static long c = 0L;\n    foreach(i; 3 .. n + 1)\n    {\n      \
    \  r = p + q;\n        p = q;\n        q = r;\n        while (r % 2 == 0 || isPrime(r)\
    \ == false)\n        {\n            r = p + q;\n            p = q;\n         \
    \   q = r;\n        }\n        c = r;\n    }\n    return c;\n}\n/*", "{\n    long\
    \ first = 0L;\n    long second = 1L;\n    long fib = 0L;\n    long _n = 0L;\n\
    \    bool is_prime = false;\n    for (;;) \n    {\n        fib = first + second;\n\
    \        first = second;\n        second = fib;\n        if (fib > 1L) \n    \
    \    {\n            is_prime = true;\n            for (long i = 2L; i < fib; i++)\
    \ \n            {\n                if (fib % i == 0L) \n                {\n  \
    \                  is_prime = false;\n                    break;\n           \
    \     }\n            }\n            if (is_prime) \n            {\n          \
    \      _n += 1L;\n                if (_n == n) \n                {\n         \
    \           return fib;\n                }\n            }\n        }\n    }\n\
    }\n/*", "{\n    long count = 0L;\n    long f = 1L;\n    long f1 = 0L;\n    long\
    \ f2 = 1L;\n    foreach (a; 2 .. n + 2) \n    {\n        f = f1 + f2;\n      \
    \  f1 = f2;\n        f2 = f;\n        static if (std.algorithm.all!(a => a ==\
    \ 0L)(iota(2L, ceil(sqrt(f)) + 1L).map!(i => f % i)) && std.algorithm.all!(a =>\
    \ a == 0L)(iota(2L, ceil(sqrt(f1)) + 1L).map!(i => f1 % i)))\n        {\n    \
    \        count++;\n            if (count == n)\n            {\n              \
    \  return f;\n            }\n        }\n    }\n    return 0L;\n}", "in\n{\n  \
    \  long i, j, k, c, r;\n    assert(n >= 1L);\n    for (i = 0L, j = 1L, k = 2L,\
    \ c = 1L; c < n; c = (c + 1L)) \n    {\n        while (!is_prime(k)) \n      \
    \  {\n            r = i + j;\n            i = j;\n            j = r;\n       \
    \     k = k + 1L;\n        }\n        r = i + j;\n        i = j;\n        j =\
    \ r;\n        k = k + 1L;\n    }\n    return k - 1L;\n}", "{\n    long a = 2L;\n\
    \    long b = 3L;\n    long c = 5L;\n    long i = 3L;\n    long p = 0L;\n    do\
    \ \n    {\n        p = c;\n        c = a + b;\n        a = b;\n        b = c;\n\
    \        i++;\n    } while (c.isPrime() && i != n);\n    return p;\n}", "{ \n\
    \  long res = 0L;\n  long x = 1L;\n  long y = 1L;\n  int cnt = 2;\n  while (cnt\
    \ <= n) {\n    const long newx = x + y;\n    const long newy = x;\n    x = newx;\n\
    \    y = newy;\n    if (x % 2L == 0L) {\n      ++cnt;\n      res = x;\n    }\n\
    \  }\n  return res;\n}\n/*", "{\n    return 0;\n}\n \n/*", "{\n    long result\
    \ = 2L;\n    long f = 2L;\n    long f2 = 1L;\n    long k = 1L;\n    while (k <\
    \ n) {\n        long f3 = f + f2;\n        if (isPrime(f3)) {\n            result\
    \ = f3;\n            k++;\n        }\n        f2 = f;\n        f = f3;\n    }\n\
    \    return result;\n}\n \n/*", "{\n    long counter = 0L;\n    long res = 0L;\n\
    \    long current = 0L;\n    long next = 1L;\n    while (true) \n    {\n     \
    \   res = current + next;\n        current = next;\n        next = res;\n    \
    \    if (is_prime(res))\n        {\n            counter++;\n            if (counter\
    \ == n)\n            {\n                return res;\n            }\n        }\n\
    \    }\n}", "{\n    if (n == 1L)\n    {\n        return 2L;\n    }\n    else if\
    \ (n == 2L)\n    {\n        return 3L;\n    }\n    else if (n == 3L)\n    {\n\
    \        return 5L;\n    }\n    else if (n == 4L)\n    {\n        return 13L;\n\
    \    }\n    else if (n == 5L)\n    {\n        return 89L;\n    }\n    else\n \
    \   {\n        long index = 5L;\n        long fib = 89L;\n        long back1 =\
    \ 13L;\n        long back2 = 5L;\n        while (true)\n        {\n          \
    \  long temp = fib;\n            fib = fib + back1;\n            back1 = back2;\n\
    \            back2 = temp;\n            if (isPrime(fib))\n            {\n   \
    \             index = index + 1L;\n                if (index == n)\n         \
    \       {\n                    return fib;\n                }\n            }\n\
    \        }\n    }\n}", "{\n    // For some reason, the array element access for\
    \ a negative index\n    // does not throw a RangeError. Instead, some internal\
    \ runtime error\n    // occurs. This is a bug or a feature?\n    assert(n > 0L);"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
