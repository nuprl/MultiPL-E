name: HumanEval_56_correct_bracketing
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"<\"\
  \ and \">\".\n    return true if every opening bracket has a corresponding closing\
  \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
  <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
  ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n"
tests: "unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
  <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
  <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\")\
  \ == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
  ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
  <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
  <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n    assert(candidate(\"\
  <><><<><>><>>><>\") == false);\n}\nvoid main(){}"
completions: ["{\n    string opening = \"<\";\n    string closing = \">\";\n    int\
    \ length = brackets.length;\n    Stack!(string) s = Stack!(string)();\n    for\
    \ (int i = 0; i < length; i++) \n    {\n        if (brackets[i] == '<') \n   \
    \     {\n            s.push(opening);\n        }\n        else if (brackets[i]\
    \ == '>') \n        {\n            if (s.empty) \n            {\n            \
    \    return false;\n            }\n            else \n            {\n        \
    \        s.pop();\n            }\n        }\n    }\n    return s.empty;\n}", "{\
    \ \n    auto last_lt = find(brackets, '<');\n    foreach(int i, char c; last_lt\
    \ .. brackets.length) {\n        if (c == '>')\n            last_lt = i;\n   \
    \     else if (c == '<')\n            return false;\n    }\n    return true;\n\
    }", "{\n    int opening_n = 0;\n    int closing_n = 0;\n    foreach(char c; brackets)\n\
    \    {\n        if(c == '<')\n        {\n            opening_n += 1;\n       \
    \ }\n        else\n        {\n            closing_n += 1;\n        }\n       \
    \ if(closing_n > opening_n)\n        {\n            return false;\n        }\n\
    \    }\n    if(opening_n == closing_n)\n    {\n        return true;\n    }\n \
    \   else\n    {\n        return false;\n    }\n}", "{\n    Stack!char stk;\n \
    \   foreach(c; brackets)\n    {\n        if(c == '<')\n            stk.push(c);\n\
    \        else if(c == '>')\n        {\n            //if stack is empty and we\
    \ see a closing bracket, then its not correct\n            if(stk.empty)\n   \
    \             return false;\n            //pop out the last bracket.\n       \
    \     stk.pop();\n        }\n    }\n    //if no opening bracket is left, then\
    \ its correct\n    return stk.empty;\n}", "{\n    uint counter = 0;\n    for (size_t\
    \ i = 0; i < brackets.length; i++) \n    {\n        switch (brackets[i]) \n  \
    \      {\n            case '<':\n                counter++;\n                break;\n\
    \            case '>':\n                counter--;\n                break;\n \
    \       }\n        if (counter < 0) \n        {\n            return false;\n \
    \       }\n    }\n    return counter == 0;\n}", "{\n    void decrement_char(inout\
    \ char[] s, size_t i)\n    {\n        if (s[i] == '>')\n            s[i] = '<';\n\
    \        else\n            s[i] = '>';\n    }\n    char[] s = brackets;\n    decrement_char(s,\
    \ 0);\n    decrement_char(s, s.length - 1);\n    return s.all!(c => c == '<');\n\
    }", "{\n    //@./correct_bracketing.dnl\n    return true;\n}", "{\n    stack!int\
    \ s;\n    foreach(char c; brackets) {\n        if (c == '<')\n            s.push(1);\n\
    \        else if (c == '>') {\n            if (s.empty) return false;\n      \
    \      s.pop();\n        }\n    }\n    return s.empty;\n}", "{\n    int open =\
    \ 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n        if (brackets[i]\
    \ == '<')\n        {\n            open++;\n        }\n        else\n        {\n\
    \            if (open == 0)\n            {\n                return false;\n  \
    \          }\n            open--;\n        }\n    }\n    return open == 0;\n}",
  "{\n    int open = 0;\n    int close = 0;\n    foreach(int i;0..brackets.length)\n\
    \    {\n        if(brackets[i] == '<')\n        {\n            open += 1;\n  \
    \      }\n        else\n        {\n            close += 1;\n        }\n      \
    \  if(close > open)\n        {\n            return false;\n        }\n    }\n\
    \    if(open == close)\n    {\n        return true;\n    }\n    else\n    {\n\
    \        return false;\n    }\n}", "{\n    int i = 0;\n    while (brackets[i]\
    \ != '\\0') {\n        switch (brackets[i]) {\n            case '<':\n       \
    \         i++;\n                break;\n            case '>':\n              \
    \  i--;\n                break;\n        }\n        if (i < 0)\n            return\
    \ false;\n    }\n    return i == 0;\n}", "{\n  // size_t no = brackets.length();\n\
    \  int open = 0;\n  for (auto c : brackets) {\n    if (c == '<') {\n      open++;\n\
    \    } else {\n      if (open == 0) {\n        return false;\n      }\n      open--;\n\
    \    }\n  }\n  return open == 0;\n}", "{\n    int count = 0;\n    foreach(c; brackets)\n\
    \    {\n        if(c == '<')\n            count++;\n        else if(c == '>')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    bool bRet = true;\n    int nLen = brackets.length;\n\
    \    if (0 == nLen)\n    {\n        return bRet;\n    }\n    else if (1 == nLen)\n\
    \    {\n        if (brackets[0] == '<')\n        {\n            bRet = false;\n\
    \        }\n    }\n    else\n    {\n        Stack!int nStack = new Stack!int;\n\
    \        foreach (nIdx, cChar; brackets)\n        {\n            if (cChar ==\
    \ '<')\n            {\n                nStack.push(cChar);\n            }\n  \
    \          else\n            {\n                if (nStack.empty)\n          \
    \      {\n                    bRet = false;\n                    break;\n    \
    \            }\n                else\n                {\n                    nStack.pop();\n\
    \                }\n            }\n        }\n        if (!nStack.empty)\n   \
    \     {\n            bRet = false;\n        }\n    }\n    return bRet;\n}\n/*\n\
    \    >>> swap_case(\"aBc\")\n    \"AbC\"\n    >>> swap_case(\"\")\n    \"\"\n\
    \    >>> swap_case(\"aBcD\")\n    \"AbCd\"\n*/\nstring swap_case(string str)\n\
    {\n    string strRet = \"\";\n    foreach (cChar; str)\n    {\n        strRet\
    \ ~= to!string(cChar).swapcase;\n    }\n    return strRet;\n}\n/*\n    >>> num_digits(0)\n\
    \    1\n    >>> num_digits(12345)\n    5\n    >>> num_digits(-12345)\n    5\n\
    \    >>> num_digits(100000000000000000000000000)\n    24\n*/", "{\n    int count_open\
    \ = 0;\n    int count_close = 0;\n    foreach(char c; brackets)\n    {\n     \
    \   switch(c)\n        {\n            case '<':\n                count_open++;\n\
    \                break;\n            case '>':\n                count_close++;\n\
    \                break;\n        }\n        if(count_close > count_open)\n   \
    \         return false;\n    }\n    return count_open == count_close;\n}", "{\n\
    \tuint count = 0;\n\tforeach(char c; brackets)\n\t{\n\t\tif(c == '<')\n\t\t\t\
    count++;\n\t\telse if(c == '>')\n\t\t\tcount--;\n\t\tif(count == 0)\n\t\t\treturn\
    \ false;\n\t}\n\treturn true;\n}", "{\n    int left = 0;\n    foreach(c; brackets)\
    \ {\n        if (c == '<') {\n            left++;\n        } else {\n        \
    \    if (left == 0) {\n                return false;\n            }\n        \
    \    left--;\n        }\n    }\n    return left == 0;\n}\n/*\n    >>> swap_left_right([\"\
    a\", \"b\", \"c\"])\n    [\"c\", \"b\", \"a\"]\n    >>> swap_left_right([\"a\"\
    , [\"b\", \"c\"], \"d\"])\n    [\"d\", [\"b\", \"c\"], \"a\"]\n    >>> swap_left_right([\"\
    a\", [\"b\", [\"c\", \"d\"], \"e\"], \"f\"])\n    [\"f\", [\"b\", [\"c\", \"d\"\
    ], \"e\"], \"a\"]\n    \n*/\nS swap_left_right(S)(S s) \n{\n    import std.algorithm\
    \ : swapFront;\n    return swapFront(s);\n}\n/*\n    >>> split_digits(123)\n \
    \   [1, 2, 3]\n    >>> split_digits(0)\n    [0]\n    >>> split_digits(6624)\n\
    \    [6, 6, 2, 4]\n    \n*/", "{\n    auto stack = new Stack!(char)();\n    foreach(char\
    \ c; brackets)\n    {\n        if(c == '<')\n        {\n            stack.push(c);\n\
    \        }\n        else if(c == '>')\n        {\n            if(stack.empty)\n\
    \            {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}", "{\n    uint<> open_count = 0;\n\
    \    uint<> close_count = 0;\n    for (uint<> i = 0; i < brackets.length; i++)\
    \ \n    {\n        if (brackets[i] == '<')\n        {\n            open_count++;\n\
    \        }\n        else\n        {\n            close_count++;\n        }\n \
    \       if (close_count > open_count)\n        {\n            return false;\n\
    \        }\n    }\n    if (open_count == close_count)\n    {\n        return true;\n\
    \    }\n    else\n    {\n        return false;\n    }\n}", "{\n    bool flag=true;\n\
    \    int m=0;\n    while(flag==true)\n    {\n        if(brackets.find(\"<>\")==-1)\n\
    \        {\n            flag=false;\n        }\n        else\n        {\n    \
    \        m=brackets.find(\"<>\");\n            brackets.erase(m,2);\n        }\n\
    \    }\n    if(brackets==\"\")\n    {\n        return true;\n    }\n    else\n\
    \    {\n        return false;\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
