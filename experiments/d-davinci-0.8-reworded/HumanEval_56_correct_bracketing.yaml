name: HumanEval_56_correct_bracketing
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"<\"\
  \ and \">\".\n    return true if every opening bracket has a corresponding closing\
  \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
  <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
  ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n"
tests: "unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
  <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
  <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\")\
  \ == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
  ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
  <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
  <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n    assert(candidate(\"\
  <><><<><>><>>><>\") == false);\n}\nvoid main(){}"
completions: ["{\n    string opening = \"<\";\n    string closing = \">\";\n    int\
    \ length = brackets.length;\n    Stack!(string) s = Stack!(string)();\n    for\
    \ (int i = 0; i < length; i++) \n    {\n        if (brackets[i] == '<') \n   \
    \     {\n            s.push(opening);\n        }\n        else if (brackets[i]\
    \ == '>') \n        {\n            if (s.empty) \n            {\n            \
    \    return false;\n            }\n            else \n            {\n        \
    \        s.pop();\n            }\n        }\n    }\n    return s.empty;\n}", "{\
    \ \n    auto last_lt = find(brackets, '<');\n    foreach(int i, char c; last_lt\
    \ .. brackets.length) {\n        if (c == '>')\n            last_lt = i;\n   \
    \     else if (c == '<')\n            return false;\n    }\n    return true;\n\
    }", "{\n    int opening_n = 0;\n    int closing_n = 0;\n    foreach(char c; brackets)\n\
    \    {\n        if(c == '<')\n        {\n            opening_n += 1;\n       \
    \ }\n        else\n        {\n            closing_n += 1;\n        }\n       \
    \ if(closing_n > opening_n)\n        {\n            return false;\n        }\n\
    \    }\n    if(opening_n == closing_n)\n    {\n        return true;\n    }\n \
    \   else\n    {\n        return false;\n    }\n}", "{\n    Stack!char stk;\n \
    \   foreach(c; brackets)\n    {\n        if(c == '<')\n            stk.push(c);\n\
    \        else if(c == '>')\n        {\n            //if stack is empty and we\
    \ see a closing bracket, then its not correct\n            if(stk.empty)\n   \
    \             return false;\n            //pop out the last bracket.\n       \
    \     stk.pop();\n        }\n    }\n    //if no opening bracket is left, then\
    \ its correct\n    return stk.empty;\n}", "{\n    uint counter = 0;\n    for (size_t\
    \ i = 0; i < brackets.length; i++) \n    {\n        switch (brackets[i]) \n  \
    \      {\n            case '<':\n                counter++;\n                break;\n\
    \            case '>':\n                counter--;\n                break;\n \
    \       }\n        if (counter < 0) \n        {\n            return false;\n \
    \       }\n    }\n    return counter == 0;\n}", "{\n    void decrement_char(inout\
    \ char[] s, size_t i)\n    {\n        if (s[i] == '>')\n            s[i] = '<';\n\
    \        else\n            s[i] = '>';\n    }\n    char[] s = brackets;\n    decrement_char(s,\
    \ 0);\n    decrement_char(s, s.length - 1);\n    return s.all!(c => c == '<');\n\
    }", "{\n    //@./correct_bracketing.dnl\n    return true;\n}", "{\n    stack!int\
    \ s;\n    foreach(char c; brackets) {\n        if (c == '<')\n            s.push(1);\n\
    \        else if (c == '>') {\n            if (s.empty) return false;\n      \
    \      s.pop();\n        }\n    }\n    return s.empty;\n}", "{\n    int open =\
    \ 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n        if (brackets[i]\
    \ == '<')\n        {\n            open++;\n        }\n        else\n        {\n\
    \            if (open == 0)\n            {\n                return false;\n  \
    \          }\n            open--;\n        }\n    }\n    return open == 0;\n}",
  "{\n    int open = 0;\n    int close = 0;\n    foreach(int i;0..brackets.length)\n\
    \    {\n        if(brackets[i] == '<')\n        {\n            open += 1;\n  \
    \      }\n        else\n        {\n            close += 1;\n        }\n      \
    \  if(close > open)\n        {\n            return false;\n        }\n    }\n\
    \    if(open == close)\n    {\n        return true;\n    }\n    else\n    {\n\
    \        return false;\n    }\n}", "{\n    int i = 0;\n    while (brackets[i]\
    \ != '\\0') {\n        switch (brackets[i]) {\n            case '<':\n       \
    \         i++;\n                break;\n            case '>':\n              \
    \  i--;\n                break;\n        }\n        if (i < 0)\n            return\
    \ false;\n    }\n    return i == 0;\n}", "{\n  // size_t no = brackets.length();\n\
    \  int open = 0;\n  for (auto c : brackets) {\n    if (c == '<') {\n      open++;\n\
    \    } else {\n      if (open == 0) {\n        return false;\n      }\n      open--;\n\
    \    }\n  }\n  return open == 0;\n}", "{\n    int count = 0;\n    foreach(c; brackets)\n\
    \    {\n        if(c == '<')\n            count++;\n        else if(c == '>')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    bool bRet = true;\n    int nLen = brackets.length;\n\
    \    if (0 == nLen)\n    {\n        return bRet;\n    }\n    else if (1 == nLen)\n\
    \    {\n        if (brackets[0] == '<')\n        {\n            bRet = false;\n\
    \        }\n    }\n    else\n    {\n        Stack!int nStack = new Stack!int;\n\
    \        foreach (nIdx, cChar; brackets)\n        {\n            if (cChar ==\
    \ '<')\n            {\n                nStack.push(cChar);\n            }\n  \
    \          else\n            {\n                if (nStack.empty)\n          \
    \      {\n                    bRet = false;\n                    break;\n    \
    \            }\n                else\n                {\n                    nStack.pop();\n\
    \                }\n            }\n        }\n        if (!nStack.empty)\n   \
    \     {\n            bRet = false;\n        }\n    }\n    return bRet;\n}\n/*\n\
    \    >>> swap_case(\"aBc\")\n    \"AbC\"\n    >>> swap_case(\"\")\n    \"\"\n\
    \    >>> swap_case(\"aBcD\")\n    \"AbCd\"\n*/\nstring swap_case(string str)\n\
    {\n    string strRet = \"\";\n    foreach (cChar; str)\n    {\n        strRet\
    \ ~= to!string(cChar).swapcase;\n    }\n    return strRet;\n}\n/*\n    >>> num_digits(0)\n\
    \    1\n    >>> num_digits(12345)\n    5\n    >>> num_digits(-12345)\n    5\n\
    \    >>> num_digits(100000000000000000000000000)\n    24\n*/", "{\n    int count_open\
    \ = 0;\n    int count_close = 0;\n    foreach(char c; brackets)\n    {\n     \
    \   switch(c)\n        {\n            case '<':\n                count_open++;\n\
    \                break;\n            case '>':\n                count_close++;\n\
    \                break;\n        }\n        if(count_close > count_open)\n   \
    \         return false;\n    }\n    return count_open == count_close;\n}", "{\n\
    \tuint count = 0;\n\tforeach(char c; brackets)\n\t{\n\t\tif(c == '<')\n\t\t\t\
    count++;\n\t\telse if(c == '>')\n\t\t\tcount--;\n\t\tif(count == 0)\n\t\t\treturn\
    \ false;\n\t}\n\treturn true;\n}", "{\n    int left = 0;\n    foreach(c; brackets)\
    \ {\n        if (c == '<') {\n            left++;\n        } else {\n        \
    \    if (left == 0) {\n                return false;\n            }\n        \
    \    left--;\n        }\n    }\n    return left == 0;\n}\n/*\n    >>> swap_left_right([\"\
    a\", \"b\", \"c\"])\n    [\"c\", \"b\", \"a\"]\n    >>> swap_left_right([\"a\"\
    , [\"b\", \"c\"], \"d\"])\n    [\"d\", [\"b\", \"c\"], \"a\"]\n    >>> swap_left_right([\"\
    a\", [\"b\", [\"c\", \"d\"], \"e\"], \"f\"])\n    [\"f\", [\"b\", [\"c\", \"d\"\
    ], \"e\"], \"a\"]\n    \n*/\nS swap_left_right(S)(S s) \n{\n    import std.algorithm\
    \ : swapFront;\n    return swapFront(s);\n}\n/*\n    >>> split_digits(123)\n \
    \   [1, 2, 3]\n    >>> split_digits(0)\n    [0]\n    >>> split_digits(6624)\n\
    \    [6, 6, 2, 4]\n    \n*/", "{\n    auto stack = new Stack!(char)();\n    foreach(char\
    \ c; brackets)\n    {\n        if(c == '<')\n        {\n            stack.push(c);\n\
    \        }\n        else if(c == '>')\n        {\n            if(stack.empty)\n\
    \            {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}", "{\n    uint<> open_count = 0;\n\
    \    uint<> close_count = 0;\n    for (uint<> i = 0; i < brackets.length; i++)\
    \ \n    {\n        if (brackets[i] == '<')\n        {\n            open_count++;\n\
    \        }\n        else\n        {\n            close_count++;\n        }\n \
    \       if (close_count > open_count)\n        {\n            return false;\n\
    \        }\n    }\n    if (open_count == close_count)\n    {\n        return true;\n\
    \    }\n    else\n    {\n        return false;\n    }\n}", "{\n    bool flag=true;\n\
    \    int m=0;\n    while(flag==true)\n    {\n        if(brackets.find(\"<>\")==-1)\n\
    \        {\n            flag=false;\n        }\n        else\n        {\n    \
    \        m=brackets.find(\"<>\");\n            brackets.erase(m,2);\n        }\n\
    \    }\n    if(brackets==\"\")\n    {\n        return true;\n    }\n    else\n\
    \    {\n        return false;\n    }\n}", "{\n    int count = 0;\n    for (int\
    \ i = 0; i < brackets.length; i++)\n    {\n        if (brackets[i] == '<')\n \
    \       {\n            count++;\n        }\n        else if (brackets[i] == '>')\n\
    \        {\n            count--;\n        }\n        if (count < 0)\n        {\n\
    \            return false;\n        }\n    }\n    return count == 0;\n}\n/*\n\
    \    return the number of times that a string is inside another string.", "{\n\
    \   // int open = 0;\n    //int close = 0;\n    //int size = length(brackets);\n\
    \    //for (int i = 0; i < size; i++)\n    //{\n        //if (brackets[i] == '<')\n\
    \        //{\n            //open++;\n        //}\n        //else if (brackets[i]\
    \ == '>')\n        //{\n            //close++;\n        //}\n        //if (close\
    \ > open)\n        //{\n            //return false;\n        //}\n    //}\n  \
    \  //if (open == close)\n    //{\n        //return true;\n    //}\n    //else\n\
    \    //{\n        //return false;\n    //}\n    struct counter\n    {\n      \
    \  int open;\n        int close;\n    };\n    auto numbers = map!(brackets, (x)\
    \ => counter(0, 0))();\n    foreach (i, c; zip(brackets, numbers))\n    {\n  \
    \      if (c == '<')\n        {\n            numbers[i].open++;\n        }\n \
    \       else if (c == '>')\n        {\n            numbers[i].close++;\n     \
    \   }\n        if (numbers[i].close > numbers[i].open)\n        {\n          \
    \  return false;\n        }\n    }\n    return numbers[$ - 1].open == numbers[$\
    \ - 1].close;\n}", "{\n    int count = 0;\n    foreach(char c; brackets)\n   \
    \ {\n        if(c == '<')\n            count++;\n        else\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}", "{\n    uint count = 0;\n    foreach(char c; brackets) {\n        if\
    \ (c == '<') \n            count++;\n        else if (c == '>') \n           \
    \ count--;\n    }\n    return count == 0;\n}", "{\n    int bracket_counter = 0;\n\
    \    for (int i = 0; i < brackets.length; i++) \n    {\n        char bracket =\
    \ brackets[i];\n        if (bracket == '<') {\n            bracket_counter++;\n\
    \        } else if (bracket == '>') {\n            bracket_counter--;\n      \
    \  } else {\n            return false;\n        }\n        if (bracket_counter\
    \ < 0) {\n            return false;\n        }\n    }\n    return bracket_counter\
    \ == 0;\n}", "{\n    int n = 0;\n    foreach(x;brackets)\n    {\n        if(x\
    \ == '<') n++;\n        else n--;\n        if(n < 0) return false;\n    }\n  \
    \  return n == 0;\n}", "{\n\tint[int] counts;\n\tforeach(i, c; brackets)\n\t{\n\
    \t\tif(c == '<') counts[i] = 1;\n\t\telse counts[i] = -1;\n\t}\n\tforeach(i, c;\
    \ zip(counts, iota(counts.length)))\n\t{\n\t\tif(c[0] == 1)\n\t\t{\n\t\t\tbool\
    \ found = false;\n\t\t\tfor(j = c[1] + 1; j < counts.length; j++)\n\t\t\t{\n\t\
    \t\t\tif(counts[j] == -1)\n\t\t\t\t{\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\tif(!found) return false;\n\t\t}\n\t}\n\treturn true;\n\
    }", "{\n  struct BracketIterator \n  {\n    string brackets;\n    size_t index;\n\
    \    @property\n    {\n      @property\n      inout(char) opIndex(size_t) ()\n\
    \      {\n        return brackets[index];\n      }\n      @property\n      size_t\
    \ length()\n      {\n        return brackets.length;\n      }\n    }\n    inout(char)\
    \ front()\n    {\n      return brackets[index];\n    }\n    bool empty()\n   \
    \ {\n      return index == brackets.length;\n    }\n    BracketIterator save()\n\
    \    {\n      return BracketIterator(index, brackets);\n    }\n    void popFront()\n\
    \    {\n      ++index;\n    }\n  }\n  bool front_is_close(ref BracketIterator\
    \ i)\n  {\n    return i.front == '>';\n  }\n  struct BracketState\n  {\n    bool\
    \ ok;\n    BracketIterator i;\n    static BracketState ok_(ref BracketIterator\
    \ i)\n    {\n      return BracketState(true, i);\n    }\n    static BracketState\
    \ not_ok_(ref BracketIterator i)\n    {\n      return BracketState(false, i);\n\
    \    }\n  }\n  BracketState iter_loop(ref BracketIterator i)\n  {\n    if (i.empty)\n\
    \    {\n      return BracketState.ok_(i);\n    }\n    auto saved = i.save;\n \
    \   if (front_is_close(i))\n    {\n      i.popFront;\n      if (i.empty)\n   \
    \   {\n        return BracketState.not_ok_(i);\n      }\n      if (front_is_close(i))\n\
    \      {\n        return BracketState.not_ok_(i);\n      }\n      else\n     \
    \ {\n        i.popFront;\n        return iter_loop(i);\n      }\n    }\n    else\n\
    \    {\n      i.popFront;\n      if (i.empty)\n      {\n        return BracketState.not_ok_(i);\n\
    \      }\n      if (front_is_close(i))\n      {\n       ", "{\n\tint count = 0;\n\
    \tforeach(char x; brackets)\n\t{\n\t\tif(x == '<')\n\t\t\tcount++;\n\t\telse if(x\
    \ == '>')\n\t\t\tcount--;\n\t\tif(count < 0)\n\t\t\treturn false;\n\t}\n\treturn\
    \ count == 0;\n}", "{\n\tbrackets = <\"(\"|\")\">.join(brackets.split(\"<\"));\n\
    \tforeach(c;brackets)\n\t{\n\t\tif(c == \"(\") continue;\n\t\tif(c == \")\")\n\
    \t\t{\n\t\t\tauto found = brackets.find(\"(\");\n\t\t\tif(found==0)\n\t\t\t{\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbrackets = brackets[0..found-1]\
    \ ~ brackets[found+1..$];\n\t\t\t}\n\t\t}\n\t}\n\treturn brackets.length == 0;\n\
    }", "{\n    uint opentotal = 0, closetotal = 0;\n    uint i = 0;\n    while (i\
    \ < brackets.length)\n    {\n        if (brackets[i] == '<')\n        {\n    \
    \        opentotal++;\n        }\n        else\n        {\n            closetotal++;\n\
    \        }\n        i++;\n    }\n    return opentotal == closetotal;\n}\n/*\n\
    \    reverse_list should take a tuple of integers and return a tuple of integers.\n\
    \    The integers in the tuple should be reversed from how they were in the original\
    \ tuple.", "{\n    assert(!brackets.empty);\n    foreach( c; brackets)\n    {\n\
    \        assert(c == '<' || c == '>');\n    }\n    int stack = 0;\n    foreach(\
    \ b; brackets)\n    {\n        if(b == '<') {\n            stack++;\n        }\
    \ else {\n            if(stack == 0) {\n                return false;\n      \
    \      }\n            stack--;\n        }\n    }\n    return stack == 0;\n}\n\
    /*\n    Given a starting position and direction,\n    return the next position.\n\
    */\nd_t step(d_t pos, d_t dir)\n{\n    assert(dir != d_t(0,0));\n    pos += dir;\n\
    \    return pos;\n}\nstruct TurnError\n{\n    enum TurnType\n    {\n        invalid,\n\
    \        overshoot,\n        loop,\n    } turnType;\n    TurnError(TurnType tt)\
    \ {\n        turnType = tt;\n    }\n}", "{\n    uint brace_count = 0;\n    for\
    \ (uint i = 0; i < brackets.length; i++) \n    {\n        if (brackets[i] == '<')\
    \ \n        {\n            brace_count++;\n        } \n        else if (brackets[i]\
    \ == '>') \n        {\n            if (brace_count == 0) \n            {\n   \
    \             return false;\n            }\n            brace_count--;\n     \
    \   }\n    }\n    return brace_count == 0;\n}\n/*\nbalanced_parentheses is a string\
    \ of parentheses which is made up of\nopening and closing parentheses in one of\
    \ the following forms:\n    \n    \"\", \"()\", \"(())\", \"()()\", \"(()())\"\
    , \"((()))\" etc.", "{\n    uint pos, k;\n    Stack!(char) S;", "{\n    return\
    \ true;\n}\n/*\n    returns a version of the string where all brackets are removed.",
  "{\n    int openbracket=0;\n    int closebracket=0;\n    //std.algorithm.find!(x\
    \ => x == '>');\n    for(char i : brackets)\n    {\n        if(i=='<')\n     \
    \   {\n            openbracket++;\n        }\n        else if(i=='>')\n      \
    \  {\n            closebracket++;\n        }\n    }\n    if(openbracket==closebracket)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\n/*\n    return true if brackets is a balanced bracketing.", "{\n  \
    \  int counter = 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n  \
    \      if (brackets[i] == '<')\n        {\n            counter++;\n        }\n\
    \        else if (brackets[i] == '>')\n        {\n            counter--;\n   \
    \     }\n        if (counter < 0)\n        {\n            return false;\n    \
    \    }\n    }\n    if (counter == 0)\n    {\n        return true;\n    }\n   \
    \ else\n    {\n        return false;\n    }\n}", "{\n    int count = 0;\n    foreach(element;\
    \ brackets) \n    {\n        if (element == '<') \n        {\n            count++;\n\
    \        } \n        else if (element == '>') \n        {\n            count--;\n\
    \        }\n        if (count < 0) \n        {\n            return false;\n  \
    \      }\n    }\n    return count == 0;\n}", "{\n    int a = 0;\n    for (auto\
    \ itr = brackets.begin(); itr != brackets.end(); itr++)\n    {\n        if (*itr\
    \ == '<')\n        {\n            a++;\n        } else\n        {\n          \
    \  a--;\n        }\n        if (a < 0)\n        {\n            return false;\n\
    \        }\n    }\n    if (a == 0)\n    {\n        return true;\n    } else\n\
    \    {\n        return false;\n    }\n}\n/*\n    s is a string.\n    return s\
    \ with all its vowels replaced by \"!\"\n    >>> replace_vowels(\"\")\n    \"\"\
    \n    >>> replace_vowels(\"aeiou\")\n    \"!!!!!\"\n    >>> replace_vowels(\"\
    hello world\")\n    \"h!ll! w!rld\"\n*/\nstring replace_vowels(string s)\n{\n\
    \    for (auto itr = s.begin(); itr != s.end(); itr++)\n    {\n        if (*itr\
    \ == 'a' || *itr == 'e' || *itr == 'i' || *itr == 'o' || *itr == 'u')\n      \
    \  {\n            *itr = '!';\n        }\n    }\n    return s;\n}\n/*\n    c is\
    \ a char.\n    return c with all its vowels replaced by \"!\"\n    >>> replace_vowels(\"\
    \")\n    \"\"\n    >>> replace_vowels(\"aeiou\")\n    \"!!!!!\"\n    >>> replace_vowels(\"\
    hello world\")\n    \"h!ll! w!rld\"\n*/\nchar replace_vowels_c(char c)\n{\n  \
    \  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n    {\n    \
    \    c = '!';\n    }\n    return c;\n}\n/*\n    s is a string.\n    Return s with\
    \ all its vowels removed.\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"\
    aeiou\")\n    \"\"\n    >>> remove_vowels(\"hello world", "{\n  int left;\n  int\
    \ right;\n  left = count(brackets, \"<\");\n  right = count(brackets, \">\");\n\
    \  if (left == right)\n  {\n    return true;\n  }\n  else\n  {\n    return false;\n\
    \  }\n}", "{\n    int c = 0;\n    foreach(char b; brackets)\n    {\n        if(b\
    \ == '<')\n            c++;\n        else if(b == '>')\n            c--;\n   \
    \     if(c < 0)\n            return false;\n    }\n    return c == 0;\n}", "{\n\
    \    bool result = true;\n    int balance = 0;\n    foreach(char c; brackets)\
    \ {\n        if (c == '<')\n            balance++;\n        else if (c == '>')\n\
    \            balance--;\n        if (balance < 0) {\n            result = false;\n\
    \            break;\n        }\n    }\n    if (balance != 0)\n        result =\
    \ false;\n    return result;\n}", "{\n    foreach(c; brackets) \n    {\n     \
    \   if (c == '<')\n            brackets = brackets[1 .. $];\n        else if (c\
    \ == '>')\n            return false;\n    }\n    return true;\n}\n/*\n * The syntax\
    \ for function declarations is:", "{\n  return true;\n}", "{\n    auto b = array(int,length(brackets));\n\
    \    foreach(i,ch;zip(b,brackets)) {\n        ch == '<' ? b[i] = 1 : b[i] = -1;\n\
    \    }\n    int sum = 0;\n    foreach(i,v;b) {\n        sum += v;\n        if(sum\
    \ < 0) return false;\n    }\n    return sum == 0;\n}", "{\n    int leftbrackets\
    \ = 0;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n        {\n   \
    \         leftbrackets++;\n        }\n        else if(c == '>')\n        {\n \
    \           leftbrackets--;\n        }\n        if(leftbrackets < 0)\n       \
    \ {\n            return false;\n        }\n    }\n    return leftbrackets == 0;\n\
    }", "{\n    char[int] stack;\n    foreach(char bracket;brackets)\n    {\n    \
    \    if(bracket == '<')\n        {\n            stack ~= bracket;\n        }\n\
    \        else\n        {\n            if(stack.length == 0)\n            {\n \
    \               return false;\n            }\n            stack.length--;\n  \
    \      }\n    }\n    return stack.length == 0;\n}", "{\n    struct bracket\n \
    \   {\n        int type;\n        int index;\n    };\n    auto arr = split(brackets,\
    \ \"\");\n    bracket[] br;\n    foreach(i, c; arr)\n    {\n        if(c == \"\
    <\")\n        {\n            br ~= bracket(0, i);\n        }\n        else if(c\
    \ == \">\")\n        {\n            if(br.length == 0)\n            {\n      \
    \          return false;\n            }\n            br = br[0..$-1];\n      \
    \  }\n    }\n    return br.length == 0;\n}\n/*\n    return true if every opening\
    \ bracket has a corresponding closing bracket.", "{\n    int count = 0;\n    foreach(c;\
    \ brackets)\n    {\n        if(c == '<')\n            count++;\n        else if(c\
    \ == '>')\n            count--;\n        \n        if(count < 0)\n           \
    \ return false;\n    }\n    return count == 0;\n}", "{\n    int balance = 0;\n\
    \    for (char ch : brackets)\n    {\n        if (ch == '<')\n            balance++;\n\
    \        else\n            balance--;\n        if (balance < 0)\n            return\
    \ false;\n    }\n    return balance == 0;\n}", "{\n    int counter = 0;\n    foreach(c;\
    \ brackets) \n    {\n        if (c == '<') \n        {\n            counter++;\n\
    \        } \n        else if (c == '>') \n        {\n            counter--;\n\
    \        }\n        if (counter < 0) \n        {\n            return false;\n\
    \        }\n    }\n    return counter == 0;\n}\n/*\n    return the number of left\
    \ brackets, minus the number of right brackets, in brackets\n    \n    >>> num_left_brackets(\"\
    <\")\n    1\n    >>> num_left_brackets(\"<>\")\n    1\n    >>> num_left_brackets(\"\
    <<><>>\")\n    2\n    >>> num_left_brackets(\"><<>\")\n    -1\n*/", "{\n\tint\
    \ size = 0;\n\tint index = 0;\n\twhile (index < brackets.length)\n\t{\n\t\tif\
    \ (brackets[index] == '<')\n\t\t{\n\t\t\tsize++;\n\t\t}\n\t\telse if (brackets[index]\
    \ == '>')\n\t\t{\n\t\t\tsize--;\n\t\t}\n\t\tif (size < 0)\n\t\t{\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tindex++;\n\t}\n\tif (size == 0)\n\t{\n\t\treturn true;\n\t\
    }\n\telse\n\t{\n\t\treturn false;\n\t}\n}", "{\n    bool flag = true;\n    Tuple!(int,\
    \ int) count = tuple(0, 0);\n    foreach(cur; brackets)\n    {\n        if(cur\
    \ == '<')\n        {\n            ++count[0];\n        }\n        else if(cur\
    \ == '>')\n        {\n            ++count[1];\n        }\n        if(count[1]\
    \ > count[0])\n        {\n            flag = false;\n            break;\n    \
    \    }\n    }\n    return flag && count[0] == count[1];\n}", "{\n    struct Stack\
    \ { \n      //stack is used to match the brackets\n      string[] array;\n   \
    \   int top;\n    }\n    Stack s;\n    s.array = new string[100];\n    s.top =\
    \ -1;\n    foreach(i;0..brackets.length) {\n      if(brackets[i] == '<') {\n \
    \       s.top++;\n        s.array[s.top] = '<';\n      }\n      else if(brackets[i]\
    \ == '>') {\n        if(s.top == -1) {\n          return false;\n        }\n \
    \       else {\n          s.top--;\n        }\n      }\n    }\n    if(s.top !=\
    \ -1) {\n      return false;\n    }\n    return true;\n}\n/*\n    This is a more\
    \ general version of the previous question.\n    brackets is a string consisting\
    \ of \"<\", \">\", \"[\", \"]\", \"{\", and \"}\".\n    return true if every opening\
    \ bracket has a corresponding closing bracket,\n    and bracketing is correct\
    \ for all sets of brackets.", "{\n   int open_count = 0;\n   for (char c : brackets)\
    \ {\n       if (c == '<') {\n           open_count++;\n       } else if (c ==\
    \ '>') {\n           open_count--;\n       }\n       if (open_count < 0) {\n \
    \          return false;\n       }\n   }\n   return open_count == 0;\n}\n/*\n\
    \    >>> bracket_remover(\"<><<<><>>>>>\")\n    '<<>>'\n    >>> bracket_remover(\"\
    <><<<><<>>>>>\")\n    '<<<>>'\n    >>> bracket_remover(\"<><<<><>>>>>\")\n   \
    \ '<<>>'\n    >>> bracket_remover(\"<<<><><<<><<>>>>\")\n    '<<><<>>>>'\n   \
    \ >>> bracket_remover(\"<>\")\n    ''\n    >>> bracket_remover(\"<><<><>>>>>\"\
    )\n    '<<><>>>>'\n    >>> bracket_remover(\"<<><<><<<><>>>>>\")\n    '<<><>>>>'\n\
    */\nstring bracket_remover(string brackets)\n{\n    int open_count = 0;\n    string\
    \ result = \"\";\n    for (char c : brackets) {\n        if (c == '<') {\n   \
    \         open_count++;\n        } else if (c == '>') {\n            open_count--;\n\
    \        }\n        if (open_count == 0) {\n            continue;\n        }\n\
    \        result += c;\n    }\n    return result;\n}\n/*\n    >>> tree_counter(\"\
    <>\")\n    1\n    >>> tree_counter(\"<>>\")\n    1\n    >>> tree_counter(\"<<>>\"\
    )\n    2\n    >>> tree_counter(\"<<>>>\")\n    3\n    >>> tree_counter(\"<<<>>>\"\
    )\n    3\n    >>> tree_counter(\"<<<>>>>\")\n    4\n    >>> tree_counter(\"<<><<<<>>>>\"\
    )\n    8\n    >>> tree_counter(\"<<><<<<>>>>\")\n    8\n    >>> tree_counter(\"\
    <<><<<<>>>>\")\n    8\n    >>> tree_counter(\"<<<><<<>>>>\")\n    4\n    >>> tree_counter(\"\
    <<<><", "{\n\tint count1 = 0;\n\tforeach(x; brackets)\n\t{\n\t\tif(x == '<')\n\
    \t\t{\n\t\t\tcount1++;\n\t\t}\n\t\telse if(x == '>')\n\t\t{\n\t\t\tcount1--;\n\
    \t\t}\n\t\tif(count1 < 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(count1\
    \ == 0)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}",
  "{\n    \n    int open = 0;\n    int closed = 0;\n    int len = length(brackets);\n\
    \    if (brackets[0] == '>')\n        return false;\n    if (len > 0)\n    {\n\
    \        for (int i = 0; i < len; i++)\n        {\n            if (brackets[i]\
    \ == '<')\n                open += 1;\n            else\n                closed\
    \ += 1;\n            if (closed > open)\n                return false;\n     \
    \   }\n        if (open != closed)\n            return false;\n        else\n\
    \            return true;\n    }\n    else\n        return false;\n}\n/*\n   \
    \ Given a string of symbols, return the reverse polish notation of the symbols.\n\
    \    If there are \"(\" in the string, it must be a valid bracketing, i.e.,\n\
    \    for every \"(\" there must be a \")\". And the \"(\" and \")\" must be in\
    \ pairs\n    and enclose the whole string.", "{\n    int k=0;\n    foreach(bracket;brackets)\n\
    \    {\n        if(bracket=='<')\n            k++;\n        else\n           \
    \ k--;\n        if(k<0)\n            return false;\n    }\n    return k==0;\n}",
  "{ \n    /*\n    int counter = 0;\n    foreach(b; brackets)\n    {\n        if(b\
    \ == '<')\n            counter++;\n        else\n            counter--;\n    \
    \    if(counter < 0)\n            return false;\n    }\n    return counter ==\
    \ 0;\n    */\n    return brackets.count('<') == brackets.count('>');\n}", "{\n\
    \    Stack() lst = new Stack();\n    for (dchar elem in brackets)\n    {\n   \
    \     if (elem == '<')\n        {\n            lst.push(elem);\n        }\n  \
    \      else\n        {\n            if (lst.empty)\n            {\n          \
    \      return false;\n            }\n            else\n            {\n       \
    \         lst.pop();\n            }\n        }\n    }\n    return lst.empty;\n\
    }", "{\n    import std.typecons;\n    int oppen_bracket_count = 0;\n    foreach(char\
    \ ch; brackets)\n    {\n        if(ch == '<')\n        {\n            oppen_bracket_count++;\n\
    \        }\n        else if(ch == '>')\n        {\n            oppen_bracket_count--;\n\
    \        }\n        if(oppen_bracket_count < 0)\n        {\n            return\
    \ false;\n        }\n    }\n    return oppen_bracket_count == 0;\n}\n/*\n    >>>\
    \ a = [1,2,3,1]\n    >>> only_unique(a)\n    false\n    >>> a = [1,2,3]\n    >>>\
    \ only_unique(a)\n    true\n    >>> a = [1,1,1]\n    >>> only_unique(a)\n    false\n\
    */", "{\n    uint i = 0;\n    uint depth = 0;\n    while (i < brackets.length)\n\
    \    {\n        if (brackets[i] == '<')\n        {\n            depth++;\n   \
    \     }\n        else if (brackets[i] == '>')\n        {\n            if (depth\
    \ == 0)\n            {\n                return false;\n            }\n       \
    \     depth--;\n        }\n        i++;\n    }\n    return depth == 0;\n}\n/*\n\
    \ brackets is a string of \"<\" and \">\".\n    return true if every opening bracket\
    \ has a corresponding closing bracket.", "{\n\tint p = 0;\n\tforeach(c;brackets)\n\
    \t{\n\t\tif(c == '<')\n\t\t\tp++;\n\t\telse\n\t\t\tp--;\n\t\tif(p < 0)\n\t\t\t\
    return false;\n\t}\n\treturn p == 0;\n}", "{\n    int count = 0;\n    foreach(ch;\
    \ brackets)\n    {\n        if(ch == '<')\n            count++;\n        else\
    \ if(ch == '>')\n            count--;\n        if(count < 0)\n            return\
    \ false;\n    }\n    return count == 0;\n}\n/*\n        return a new string in\
    \ which all characters occur in the same order, but\n        at most max_consecutive\
    \ times.\n        >>> no_more_than_n_times(\"\", 0)\n        \"\"\n        >>>\
    \ no_more_than_n_times(\"a\", 0)\n        \"\"\n        >>> no_more_than_n_times(\"\
    a\", 1)\n        \"a\"\n        >>> no_more_than_n_times(\"a\", 2)\n        \"\
    a\"\n        >>> no_more_than_n_times(\"aaa\", 1)\n        \"a\"\n        >>>\
    \ no_more_than_n_times(\"aaa\", 2)\n        \"aa\"\n        >>> no_more_than_n_times(\"\
    banana\", 3)\n        \"banana\"\n        >>> no_more_than_n_times(\"banana\"\
    , 4)\n        \"banana\"\n        >>> no_more_than_n_times(\"abracadabra\", 2)\n\
    \        \"abracadabra\"\n        >>> no_more_than_n_times(\"abracadabra\", 3)\n\
    \        \"abracadabra\"\n        >>> no_more_than_n_times(\"abracadabra\", 4)\n\
    \        \"abracadabra\"\n        >>> no_more_than_n_times(\"aaaaa\", 2)\n   \
    \     \"aaba\"\n        >>> no_more_than_n_times(\"aaaaa\", 3)\n        \"aaab\"\
    \n        >>> no_more_than_n_times(\"aaaaa\", 4)\n        \"aaab\"\n        >>>\
    \ no_more_than_n_times(\"aaaaaaaaaa\", 2)\n        \"aabaabaa\"\n        >>> no_more_than_n_times(\"\
    aaaaaaaaaa\", 3)\n        \"aaabaaab\"\n        >>> no_more_than_n_times(\"aaaaaaaaaa\"\
    ,", "{ \n    uint int count = 0;\n    foreach(c; brackets)\n    {\n        if(c\
    \ == '<')\n            count++;\n        else if(c == '>')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}", "{\n    int balance = 0;\n    for (size_t i = 0; i < brackets.length;\
    \ i++)\n    {\n        if (brackets[i] == '<')\n        {\n            balance\
    \ += 1;\n        }\n        else\n        {\n            balance -= 1;\n     \
    \   }\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n\
    }", "{\n    bool correct = true;\n    int counter = 0;\n    foreach(char c; brackets)\n\
    \    {\n        if(c == '<')\n        {\n            counter++;\n        }\n \
    \       else if(c == '>')\n        {\n            counter--;\n        }\n    \
    \    if(counter < 0)\n        {\n            correct = false;\n            break;\n\
    \        }\n    }\n    return correct && counter == 0;\n}", "{\n    return brackets.length\
    \ % 2 == 0;\n}", "{\n    return true;\n}\n/*\n fibonacci returns the nth fibonacci\
    \ number.\n    The fibonacci sequence is a series of numbers where each number\
    \ is the sum of the previous two.\n    In fibonacci(0), return 0.\n    In fibonacci(1),\
    \ return 1.\n    In fibonacci(2), return 1.\n    In fibonacci(3), return 2.\n\
    \    In fibonacci(4), return 3.\n    In fibonacci(5), return 5.\n    In fibonacci(6),\
    \ return 8.\n    In fibonacci(7), return 13.\n    In fibonacci(8), return 21.\n\
    \    In fibonacci(9), return 34.\n    In fibonacci(10), return 55.\n    \n*/",
  "{\n    bool wrong_count = false;\n    int counter = 0;\n    foreach(char c; brackets)\n\
    \    {\n        if(c == '<')\n        {\n            counter++;\n        }\n \
    \       else\n        {\n            counter--;\n        }\n        if(counter\
    \ < 0)\n        {\n            wrong_count = true;\n        }\n    }\n    if(counter\
    \ != 0)\n    {\n        wrong_count = true;\n    }\n    return !wrong_count;\n\
    }\n/*\n    polygon is a list of 2-tuples of floats.\n    return true if polygon\
    \ is a convex polygon.", "    in \n    {\n        assert(!brackets.empty);\n \
    \   }\n    out (result)\n    {\n        assert(result == std.algorithm.all!(\n\
    \            \"(a, b) => (a == '<' && b == '>') || (a == '>' && b == '<')\"\n\
    \        )(brackets));\n    }\n{\n    return std.algorithm.all!(\n        \"(a,\
    \ b) => (a == '<' && b == '>') || (a == '>' && b == '<')\"\n    )(brackets);\n\
    }", "{\n  int count = 0;\n  for (int i = 0; i < brackets.length; i++)\n  {\n \
    \   if (brackets[i] == '<')\n    {\n      count++;\n    }\n    else\n    {\n \
    \     count--;\n    }\n    if (count < 0)\n    {\n      return false;\n    }\n\
    \  }\n  if (count == 0)\n  {\n    return true;\n  }\n  else\n  {\n    return false;\n\
    \  }\n  \n}", "{\n\tstring opening = \"<\";\n\tstring closing = \">\";\n\t//int\
    \ open_count = 0;\n\t//int close_count = 0;\n\tint open_closing_count = 0;", "{\n\
    \    // invariant:\n    //    sofar is a string of \"<\" and \">\"\n    //   \
    \ every opening bracket in sofar has a corresponding closing bracket\n    // \
    \   \">>\" is not a substring of sofar", "    {\n    if (brackets.length == 0)\
    \ \n        {\n        return true;\n        } \n    else if (brackets.at(0) ==\
    \ '>') \n        {\n        return false;\n        } \n    else \n        {\n\
    \        int current_bracket_level = 0;\n        auto closing_bracket_loc = -1;\n\
    \        for (int i = 0; i < brackets.length; i++) \n            {\n         \
    \   if (brackets.at(i) == '<') \n                {\n                current_bracket_level\
    \ += 1;\n                } \n            else if (brackets.at(i) == '>') \n  \
    \              {\n                current_bracket_level -= 1;\n              \
    \  if (current_bracket_level == 0) \n                    {\n                 \
    \   closing_bracket_loc = i;\n                    break;\n                   \
    \ }\n                }\n            }\n        if (closing_bracket_loc == -1)\
    \ \n            {\n            return false;\n            } \n        else \n\
    \            {\n            return correct_bracketing(brackets.substr(1, closing_bracket_loc\
    \ - 1)) && correct_bracketing(brackets.substr(closing_bracket_loc + 1, brackets.length\
    \ - closing_bracket_loc - 1));\n            }\n        }\n    }", "{\n  int count\
    \ = 0;\n  for (int i = 0; i < brackets.length; i++) \n  {\n    if (brackets[i]\
    \ == '<')\n    {\n      count++;\n    }\n    else if (brackets[i] == '>')\n  \
    \  {\n      count--;\n    }\n  }\n  return count == 0;\n}", "{\n    struct Count\
    \ {\n        // Alias declarations are a way to give a new name to an existing\
    \ type.\n        alias ValueType = int;\n        ValueType value;\n    } ;\n \
    \   // Tuple of 2 integer, int constructor\n    auto tuple = tuple(0, 0);\n  \
    \  foreach(bracket; brackets) {\n        if (bracket == '<') {\n            //\
    \ Tuple set index 0 to tuple[0] + 1\n            tuple[0] = tuple[0] + 1;\n  \
    \      } else {\n            // Tuple set index 1 to tuple[1] + 1\n          \
    \  tuple[1] = tuple[1] + 1;\n        }\n    }\n    // tuple get index 0 equal\
    \ to tuple get index 1\n    return tuple[0] == tuple[1];\n}", "{\n    foreach(i;\
    \ 0 .. brackets.length)\n    {\n        foreach(j; i .. brackets.length)\n   \
    \     {\n            if(brackets[i] == '<' && brackets[j] == '>')\n          \
    \  {\n                brackets[i] = ' ';\n                brackets[j] = ' ';\n\
    \                break;\n            }\n        }\n    }\n    return brackets.indexOf('<')\
    \ == -1;\n}", "{\n    int bal = 0;\n    foreach(ch;brackets)\n    {\n        if(ch\
    \ == '<')\n            bal++;\n        else\n            bal--;\n        if(bal\
    \ < 0)\n            return false;\n    }\n    return bal == 0;\n}", "{\n    int\
    \ n = brackets.length;\n    int count = 0;\n    for (int i = 0; i < n; i++)\n\
    \    {\n        if (brackets[i] == '<')\n        {\n            count++;\n   \
    \     }\n        else if (brackets[i] == '>')\n        {\n            count--;\n\
    \        }\n        if (count < 0)\n        {\n            return false;\n   \
    \     }\n    }\n    return count == 0;\n}\n/*\n * return true if every opening\
    \ bracket in brackets has a corresponding closing bracket before any other type\
    \ of character.\n * \n * >>> correct_bracketing_before_other_character(\"<<><\"\
    )\n * true\n * >>> correct_bracketing_before_other_character(\"<>\")\n * true\n\
    \ * >>> correct_bracketing_before_other_character(\"<<><>>\")\n * true\n * >>>\
    \ correct_bracketing_before_other_character(\"><<><>\")\n * false\n * >>> correct_bracketing_before_other_character(\"\
    <ab>\")\n * true\n * >>> correct_bracketing_before_other_character(\"<<>ab>\"\
    )\n * true\n * >>> correct_bracketing_before_other_character(\"<<>a<b>\")\n *\
    \ false\n */", "{\n    int nLeft=0;\n    int nRight=0;\n    foreach(char c;brackets)\n\
    \    {\n        switch(c)\n        {\n            case '<':\n                nLeft++;\n\
    \                break;\n            case '>':\n                nRight++;\n  \
    \              break;\n        }\n    }\n    return nLeft==nRight;\n}\n/*\n  \
    \  A word ladder is a sequence of words where each word is one letter different\
    \ from the previous.", "{\n    \n    uint counter = 0;\n    foreach(x; brackets)\n\
    \    {\n        if(x == '<')\n        {\n            counter++;\n        }\n \
    \       else\n        {\n            counter--;\n        }\n        if(counter\
    \ == -1)\n        {\n            return false;\n        }\n    }\n    if(counter\
    \ == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\n/*\n    A unival tree is a tree which has the same value at every node.\n\
    \    return true if tree is a unival tree.", "{\n    uint count = 0;\n    foreach(b;\
    \ brackets) \n    {\n        if (b == '<') \n        {\n            count++;\n\
    \        }\n        else if (b == '>') \n        {\n            if (count == 0)\
    \ \n            {\n                return false;\n            }\n            count--;\n\
    \        }\n    }\n    return count == 0;\n}\n/*\n    anagrams is a sequence of\
    \ words.\n    return a list of words that form anagrams of each other.\n    >>>\
    \ find_anagrams([\"ab\", \"ba\", \"abcd\", \"dcba\", \"bac\", \"dabc\"])\n   \
    \ [[\"ab\", \"ba\"], [\"abcd\", \"dcba\", \"bac\", \"dabc\"]]\n    >>> find_anagrams([\"\
    silence\", \"enlist\", \"dictionary\", \"tinsel\", \"listen\", \"boaster\", \"\
    boaters\", \"borates\", \"toaster\"])\n    [[\"silence\", \"enlist\", \"tinsel\"\
    , \"listen\"], [\"dictionary\"], [\"boaster\", \"boaters\", \"borates\", \"toaster\"\
    ]]\n    >>> find_anagrams([\"silence\", \"enlist\", \"dictionary\", \"tinsel\"\
    , \"listen\", \"silent\"])\n    [[\"silence\", \"enlist\", \"tinsel\", \"listen\"\
    , \"silent\"]]\n*/\nauto find_anagrams(immutable string[] words) \n{\n    immutable\
    \ sorted_words = words.map!(w => tuple(w, w.sort));\n    return sorted_words.values.groupBy!(a\
    \ => a.item2).values.map!(s => s.map!(a => a.item1));\n}\n/*\n    is a string\
    \ that is valid if it has a \"(\" \")\" \".\" \"?\" \":\" or \"*\" in this order.\n\
    \    >>> is_valid(\"(.)\")\n    true\n    >>> is_valid(\"(.?)\")\n    true\n \
    \   >>> is_valid(\"(.?).\")\n    false\n    >>> is_valid(\"(.*):\")\n    true\n\
    \    >>> is_valid(\"(.*):*\")\n    false\n", "{\n    int count = 0;\n    foreach(immutable\
    \ ch;brackets)\n    {\n        if(ch == '<')\n            count++;\n        else\
    \ if(ch == '>')\n            count--;\n        if(count < 0)\n            return\
    \ false;\n    }\n    return count == 0;\n}\n/*\n>>> correct_bracketing(\"<><<>><<<>>\"\
    )\ntrue\n*/", "{\n    int counter = 0;\n    for (int i = 0; i < brackets.length;\
    \ i++) {\n        if (brackets[i] == '<')\n            counter += 1;\n       \
    \ else\n            counter -= 1;\n        \n        if (counter < 0)\n      \
    \      return false;\n    }\n    return counter == 0;\n}", "{\n    uint bracket_count\
    \ = 0;", "{\n    bool can_pop = false;\n    for (int i = 0; i < brackets.length;\
    \ i++)\n    {\n\tif (brackets[i] == '<') can_pop = true;\n\telse if (brackets[i]\
    \ == '>')\n\t{\n\t    if (can_pop) can_pop = false;\n\t    else return false;\n\
    \t}\n    }\n    return !can_pop;\n}", "{\n    bool flag = true;\n    for (int\
    \ i = 0; i < brackets.length; i++)\n    {\n        if (brackets[i] == '<') \n\
    \        {\n            while (brackets[i] == '<') \n            {\n         \
    \       i++;\n            }\n            if (brackets[i] != '>') \n          \
    \  {\n                flag = false;\n                break;\n            }\n \
    \       }\n        else if (brackets[i] == '>') \n        {\n            flag\
    \ = false;\n            break;\n        }\n    }\n    return flag;\n}", "{\n \
    \   int count = 0;\n    for (int i = 0; i < brackets.length; i++) {\n        if\
    \ (brackets[i] == '<') {\n            count++;\n        } else if (brackets[i]\
    \ == '>') {\n            count--;\n        }\n        if (count < 0) return false;\n\
    \    }\n    return count == 0;\n}\n/*\n a binary tree is a recursive data structure\
    \ that stores the value of a node,\n and the two subtrees of the node.", "{\n\
    \    int len = brackets.length;\n    int open = 0;\n    for (int i = 0; i < len;\
    \ i++) {\n        if (brackets[i] == '<') open++;\n        else if (brackets[i]\
    \ == '>') {\n            if (open == 0) return false;\n            open--;\n \
    \       }\n    }\n    return open == 0;\n}", "{\n    /*\n    if(brackets.length\
    \ == 0){return true;}\n    int count = 0;\n    foreach(ch;brackets){\n       \
    \ if(ch == '<'){\n            count++;\n        }\n        else if(ch == '>'){\n\
    \            count--;\n        }\n        if(count < 0){\n            return false;\n\
    \        }\n    }\n    return count == 0;\n    */\n    \n    int cnt = 0;\n  \
    \  foreach(ch;brackets){\n        if(ch == '<'){\n            cnt += 1;\n    \
    \    }\n        else if(ch == '>'){\n            cnt -= 1;\n        }\n      \
    \  if(cnt < 0){\n            return false;\n        }\n    }\n    return cnt ==\
    \ 0;\n}", "{\n    int count_lt = 0;\n    int count_gt = 0;\n    foreach(i; 0 ..\
    \ brackets.length)\n    {\n        if(brackets[i] == '<')\n        {\n       \
    \     count_lt++;\n        }\n        else if(brackets[i] == '>')\n        {\n\
    \            count_gt++;\n        }\n        if(count_gt > count_lt)\n       \
    \ {\n            return false;\n        }\n    }\n    if(count_lt == count_gt)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\n/*\n    return true if brackets contains balanced\n    brackets.  A\
    \ bracket is either \"<\" or \">\".", "{ \n    int count1 = 0;\n    int count2\
    \ = 0;\n    int count3 = 0;\n    int i = 0;\n    foreach(ch; brackets)\n    {\n\
    \        if(ch == '<')\n        {\n            ++count1;\n        }\n        else\
    \ if(ch == '>')\n        {\n            ++count2;\n        }\n    }\n    foreach(ch;\
    \ brackets)\n    {\n        if(ch == '<')\n        {\n            ++count3;\n\
    \        }\n        else if(ch == '>')\n        {\n            --count3;\n   \
    \     }\n        if(count3 < 0)\n        {\n            return false;\n      \
    \  }\n    }\n    if(count1 == count2)\n    {\n        return true;\n    }\n  \
    \  else\n    {\n        return false;\n    }\n}", "{\n    int balance = 0;\n \
    \   foreach(char ch; brackets)\n    {\n        if (ch == '<')\n            balance++;\n\
    \        else if (ch == '>')\n            balance--;\n        if (balance < 0)\n\
    \            return false;\n    }\n    return balance == 0;\n}", "{\n    uint\
    \ x = 0;\n    foreach(inout char c; brackets)\n    {\n        if(c == '<') x++;\n\
    \        else if(c == '>') x--;\n        else throw new Exception(\"String does\
    \ not contain only < and >.\");\n    }\n    return x == 0;\n}", "{ \n    int count\
    \ = 0;\n    foreach(int ch; brackets)\n    {\n        if(ch == '<')\n        \
    \    count++;\n        else if(ch == '>')\n            count--;\n        if(count\
    \ < 0)\n            return false;\n    }\n    return count == 0;\n}", "{ \n  bool\
    \ r = true;\n  if(brackets.length > 1)\n  {\n    alias ch = brackets[0];\n   \
    \ if(ch == '<')\n    {\n      auto c = brackets.popFront;\n      r = correct_bracketing(c);\n\
    \      if(r)\n      {\n        auto p = c.popFront;\n        if(p != \"\")\n \
    \       {\n          if(p[0] == '>')\n          {\n            p.popFront;\n \
    \           r = correct_bracketing(p);\n          }else\n          {\n       \
    \     r = false;\n          }\n        }\n      }\n    }else\n    {\n      r =\
    \ false;\n    }\n  }else\n  {\n    r = false;\n  }\n  return r;\n}", "{\n    return\
    \ false;\n}", "{\n    if(brackets.empty)\n        return true;\n    int b = 0;\n\
    \    foreach(c;brackets)\n    {\n        if(c == '<')\n            b++;\n    \
    \    else if(c == '>')\n            b--;\n        if(b < 0)\n            return\
    \ false;\n    }\n    return b == 0;\n}\nstruct minmax(T)\n{\n    T min;\n    T\
    \ max;\n    this(T t)\n    {\n        min = t;\n        max = t;\n    }\n    this(T\
    \ min, T max)\n    {\n        this.min = min;\n        this.max = max;\n    }\n\
    \    bool empty()\n    {\n        return min > max;\n    }\n    @property bool\
    \ opEquals(minmax!T that)\n    {\n        return min == that.min && max == that.max;\n\
    \    }\n    @property bool opEquals(T that)\n    {\n        return min == that\
    \ && max == that;\n    }\n    auto tupleof()\n    {\n        return tuple(min,\
    \ max);\n    }\n    auto opCast(T)\n    {\n        return tupleof();\n    }\n\
    }\nstruct arr(T)\n{\n    size_t offset;\n    size_t length;\n    T* p;\n    this(T*\
    \ p, size_t offset, size_t length)\n    {\n        this.p = p;\n        this.offset\
    \ = offset;\n        this.length = length;\n    }\n    this(T* p, size_t length)\n\
    \    {\n        this.p = p;\n        this.offset = 0;\n        this.length = length;\n\
    \    }\n    auto opIndex(size_t i)\n    {\n        return p[offset + i];\n   \
    \ }\n    auto opSlice()\n    {\n        return this;\n    }\n    auto opSlice(size_t\
    \ low)\n    {\n        return arr!T(p, offset + low, length - low);\n    }\n \
    \   auto opSlice(size_t low, size_t high)\n    {\n        return", "{\n    return\
    \ brackets.sum!((a, b) => a == '<' ? 1 : -1) == 0;\n}\n/*\n find_bracketing is\
    \ a string of \"<\" and \">\".\n    return true if there is a sequence of brackets\
    \ such that every opening bracket\n    has a corresponding closing bracket.",
  "{\n    \n    return true;\n}", "{\n    int count = 0;\n    foreach(char ch; brackets)\n\
    \    {\n        if(ch == '<')\n            count++;\n        else if(ch == '>')\n\
    \            count--;\n        \n        if(count < 0)\n            return false;\n\
    \    }\n    return count == 0;\n}\n/*\ndigit_sum is a string of digits, such as\
    \ \"0123\".\n    return the sum of all the digits in the string.", "{\n    int\
    \ open = 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n        if\
    \ (brackets[i] == '<')\n        {\n            open++;\n        }\n        else\
    \ if (brackets[i] == '>')\n        {\n            open--;\n        }\n       \
    \ if (open < 0)\n        {\n            return false;\n        }\n    }\n    return\
    \ open == 0;\n}", "{\n    // If the length of brackets is odd, return false.\n\
    \    if (brackets.length % 2 == 1) \n    {\n        return false;\n    }\n   \
    \ else \n    {\n        int count = 0;\n        //for each of the bracket in brackets\n\
    \        foreach (bracket; brackets) \n        {\n            //if the bracket\
    \ is \">\" and count is less than 0, return false\n            if (bracket ==\
    \ '>' && count < 0) \n            {\n                return false;\n         \
    \   }\n            //if the bracket is \"<\", increase count by 1\n          \
    \  else if (bracket == '<') \n            {\n                count += 1;\n   \
    \         }\n            //if the bracket is \">\", decrease count by 1\n    \
    \        else if (bracket == '>') \n            {\n                count -= 1;\n\
    \            }\n        }\n        // if count equals 0, return true. if not,\
    \ return false.\n        if (count == 0) \n        {\n            return true;\n\
    \        }\n        else \n        {\n            return false;\n        }\n \
    \   }\n}", "{\n    int count = 0;\n    for (int i = 0; i < brackets.length; i++)\n\
    \    {\n        if (brackets[i] == '<')\n        {\n            count += 1;\n\
    \        }\n        else\n        {\n            count -= 1;\n        }\n    \
    \    if (count < 0)\n        {\n            return false;\n        }\n    }\n\
    \    return count == 0;\n}", "{\n    \n    int i = 0;\n    int count = 0;\n  \
    \  for(int i = 0; i < brackets.length; i++)\n    {\n        if(brackets[i] ==\
    \ '<')\n        {\n            count++;\n        }\n        else\n        {\n\
    \            count--;\n        }\n        if(count < 0)\n        {\n         \
    \   return false;\n        }\n    }\n    if(count == 0)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }\n}", "{\n  auto\
    \ l = brackets.length;\n  // the empty string is correct\n  if (l == 0) return\
    \ true;\n  if (l == 1) return false;\n  // test the first bracket\n  if (brackets[0]\
    \ == '>') return false;\n  // test the last bracket\n  if (brackets[l-1] == '<')\
    \ return false;\n  // test bracketing\n  // assert(l>=2);\n  int stack = 0;\n\
    \  for (int i = 0; i < l; i++)\n  {\n    char c = brackets[i];\n    if (c == '<')\n\
    \    {\n      stack++;\n    }\n    else if (c == '>')\n    {\n      if (stack\
    \ == 0) return false;\n      stack--;\n    }\n    else\n    {\n      assert(false);\n\
    \    }\n  }\n  return stack == 0;\n}", "{\n    if (brackets.length == 0)\n   \
    \     return true;\n    if (brackets.length == 1)\n        return false;\n   \
    \ if (brackets[0] == '>')\n        return false;\n    int counter = 0;\n    foreach\
    \ (i, e; brackets)\n    {\n        if (e == '<')\n            counter++;\n   \
    \     else if (e == '>')\n            counter--;\n        if (counter < 0)\n \
    \           return false;\n    }\n    return counter == 0;\n}\n/*\n    Implement\
    \ a function that given a string \"s\" and an integer \"n\"\n    returns the string\
    \ \"s\" with exactly \"n\" occurrences of the character 'x'.\n    If \"n\" is\
    \ higher than the number of occurrences of 'x' in \"s\",\n    all occurrences\
    \ of 'x' must be duplicated as many times as needed.\n    If \"n\" is lower than\
    \ the number of occurrences of 'x' in \"s\",\n    all occurrences of 'x' must\
    \ be removed.", "{\n\tuint cnt = 0;\n\tforeach(c; brackets)\n\t{\n\t\tif(c ==\
    \ '<') cnt++;\n\t\telse if(c == '>')\n\t\t{\n\t\t\tif(cnt == 0) return false;\n\
    \t\t\tcnt--;\n\t\t}\n\t}\n\treturn cnt == 0;\n}", "{\n    if (brackets.empty)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return brackets.front\
    \ == '<' && brackets.back == '>' && correct_bracketing(brackets[1..$-1]);\n  \
    \  }\n}", "{\n    Stack!(int) stack;\n    foreach(bracket; brackets) {\n     \
    \   if (bracket == '<') {\n            stack.push(0);\n        } else {\n    \
    \        if (stack.empty) {\n                return false;\n            }\n  \
    \          stack.pop();\n        }\n    }\n    return stack.empty;\n}", "{\n\t\
    int open = 0;\n\tint close = 0;\n\tint i = 0;\n\twhile (i < brackets.length)\n\
    \t{\n\t\tif (brackets[i] == '<')\n\t\t{\n\t\t\topen++;\n\t\t}\n\t\telse if (brackets[i]\
    \ == '>')\n\t\t{\n\t\t\tclose++;\n\t\t}\n\t\ti++;\n\t}\n\tif (open > close)\n\t\
    {\n\t\treturn false;\n\t}\n\treturn true;\n}", "{\n    assert(brackets.length\
    \ >= 0);\n    foreach(c; brackets) assert(c == '<' || c == '>');\n    auto matching\
    \ = false;\n    int openBrackets = 0;\n    foreach(c; brackets)\n    {\n     \
    \   if(c == '<')\n        {\n            openBrackets++;\n        }\n        else\n\
    \        {\n            if(openBrackets > 0)\n            {\n                openBrackets--;\n\
    \            }\n            else\n            {\n                return false;\n\
    \            }\n        }\n    }\n    if(openBrackets == 0)\n    {\n        matching\
    \ = true;\n    }\n    return matching;\n}\n/*\n    removes the character from\
    \ the strings.\n    >>> remove_char(\"abc\")\n    [\"bc\", \"ac\", \"ab\"]\n \
    \   >>> remove_char(\"x\")\n    [\"\"]\n    >>> remove_char(\"\")\n    []\n*/\n\
    T[] remove_char(T)(T[] strings)\n{\n    foreach(string; strings) assert(string.length\
    \ >= 0);\n    T[] result = [];\n    foreach(string; strings)\n    {\n        foreach(i;\
    \ 0..string.length)\n        {\n            if(string.length == 1)\n         \
    \   {\n                result ~= \"\";\n            }\n            else\n    \
    \        {\n                result ~= string[0..i] ~ string[i+1..$];\n       \
    \     }\n        }\n    }\n    return result;\n}\n/*\n    return the string with\
    \ the longest common prefix with the other strings.\n    >>> longest_common_prefix(\"\
    ab\", \"abc\")\n    \"ab\"\n    >>> longest_common_prefix(\"ab\", \"ad\")\n  \
    \  \"a\"\n    >>> longest_common_prefix(\"ac\", \"ad\")\n    \"\"\n    >>> longest_common_prefix(\"\
    ab\", \"ac\", \"ad\")\n    \"\"\n*/\nstring longest_common_prefix(T...)(T strings)\n\
    {\n    assert(strings.length >= 0);\n    foreach(string; strings) assert(string.length\
    \ >= 0);\n    if(strings.length == 0)\n    {\n        return \"\";\n    }\n  \
    \  fore", "{\n    int count = 0;\n    foreach(char c; brackets)\n    {\n     \
    \   if(c == '<')\n            count++;\n        else if(c == '>')\n          \
    \  count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}", "{\n    int bracket_sum = 0;", "{\n    //opening brackets\n\
    \    int count = 0;", "{\n    int i = 0;\n    int j = 0;\n    foreach(c; brackets)\n\
    \    {\n        if(c == '<')\n        {\n            i++;\n        }\n       \
    \ else if(c == '>')\n        {\n            j++;\n        }\n        if(j > i)\n\
    \        {\n            return false;\n        }\n    }\n    if(i == j)\n    {\n\
    \        return true;\n    }\n    else\n    {\n        return false;\n    }\n\
    }\n/*", "{\n\tbool result = true;\n\tint count = 0;\n\tforeach(b; brackets) \n\
    \t{\n\t\tif (b == '<') \n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\t\
    count--;\n\t\t}\n\t\tif (count < 0) \n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\tif (count != 0) \n\t{\n\t\tresult = false;\n\t}\n\treturn result;\n\
    }", "{\n    int i = 0;\n    int count = 0;\n    foreach(char c; brackets)\n  \
    \  {\n        if(c == '<')\n        {\n            count++;\n        }\n     \
    \   else if(c == '>')\n        {\n            count--;\n        }\n        else\n\
    \        {\n            return false;\n        }\n        if(count < 0)\n    \
    \    {\n            return false;\n        }\n    }\n    if(count == 0)\n    {\n\
    \        return true;\n    }\n    else\n    {\n        return false;\n    }\n\
    \    \n}", "{\n    size_t n = brackets.length;\n    size_t acc = 0;\n    foreach(i;\
    \ 0..n)\n    {\n        if(brackets[i] == '<')\n            acc++;\n        else\n\
    \            acc--;\n        if(acc < 0)\n            return false;\n    }\n \
    \   return acc == 0;\n}", "{\n    int balance = 0;\n    foreach(bracket; brackets)\n\
    \    {\n        if(bracket == '<')\n            balance++;\n        else if(bracket\
    \ == '>')\n            balance--;\n        if(balance < 0)\n            return\
    \ false;\n    }\n    return balance == 0;\n}", "{\n    int opening_brackets_so_far\
    \ = 0;\n    foreach (symbol; brackets) {\n        if (symbol == '<') \n      \
    \      opening_brackets_so_far++;\n        else if (symbol == '>') {\n       \
    \     if (opening_brackets_so_far == 0)\n                return false;\n     \
    \       opening_brackets_so_far--;\n        }\n    }\n    return opening_brackets_so_far\
    \ == 0;\n}", "{\n    if(brackets.length < 2) return false;\n    bool open=false;\n\
    \    foreach(c;brackets) {\n        if(c == '<') {\n            open = true;\n\
    \        } else if(c == '>') {\n            if(!open) {\n                return\
    \ false;\n            }\n            open = false;\n        }\n    }\n    return\
    \ !open;\n}\n/* \n    count the number of brackets in a string of brackets.",
  "{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    ", "{\n    uint count = 0;\n\
    \    foreach(ch;brackets)\n    {\n        if(ch == '<')\n            count++;\n\
    \        else if(ch == '>')\n            count--;\n        if(count < 0)\n   \
    \         return false;\n    }\n    return count == 0;\n}\n/*\n  Returns the sum\
    \ of a list of integers. \n  Throws std.exception.AssertError if the list is empty.\n\
    \  >>> sum_list([]);\n  AssertError\n  >>> sum_list([1, 2, 3, 4, 5]);\n  15\n\
    \  >>> sum_list([5, 2, -5, -1, 7]);\n  8\n*/", "{\n  int count = 0;\n  foreach(char\
    \ c;brackets)\n  {\n    if(c == '<')\n      count++;\n    else if(c == '>')\n\
    \      count--;\n    if(count < 0)\n      return false;\n  }\n  return (count\
    \ == 0);\n}", "{\n\tint i = 0;\n\tint j = 0;\n\twhile (i < brackets.length())\
    \ {\n\t\tif (brackets[i] == '<') {\n\t\t\tj = i + 1;\n\t\t\twhile (j < brackets.length())\
    \ {\n\t\t\t\tif (brackets[j] == '>') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\
    else {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == brackets.length())\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti = j + 1;\n\t\t\t\
    }\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn true;\n}", "{\n    int\
    \ nb_open = 0;\n    foreach(b;brackets)\n    {\n        if(b == '<')\n       \
    \     nb_open++;\n        else if(b == '>')\n            nb_open--;\n        if(nb_open\
    \ < 0)\n            return false;\n    }\n    return nb_open == 0;\n}", "{\n \
    \   return true;\n}", "{\n    if (brackets.length() == 0) return true;\n    if\
    \ (brackets.length() % 2 == 1) return false;\n    int i = 0;\n    while (i < brackets.length())\n\
    \    {\n        if (brackets[i] == '<')\n        {\n            int count = 1;\n\
    \            while (count != 0)\n            {\n                i++;\n       \
    \         if (brackets[i] == '<') count++;\n                if (brackets[i] ==\
    \ '>') count--;\n            }\n        }\n        else i++;\n    }\n    return\
    \ true;\n}", "{\n\tint level = 0;\n\tfor (int i = 0; i < brackets.length; i++)\n\
    \t{\n\t\tif (brackets[i] == '<')\n\t\t{\n\t\t\tlevel++;\n\t\t}\n\t\telse if (brackets[i]\
    \ == '>')\n\t\t{\n\t\t\tlevel--;\n\t\t}\n\t\tif (level < 0)\n\t\t{\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn level == 0;\n}", "{\n    import std.array;\n  \
    \  import std.algorithm;\n    import std.range;\n    bool flag = true;\n    for(size_t\
    \ i = 0; i < brackets.length; ++i)\n    {\n        if(brackets[i] == '<')\n  \
    \      {\n            for(size_t j = brackets.length - 1; j > i; --j)\n      \
    \      {\n                if(brackets[j] == '>')\n                {\n        \
    \            brackets[i] = ' ';\n                    brackets[j] = ' ';\n    \
    \                break;\n                }\n            }\n        }\n    }\n\
    \    brackets = brackets.replace(' ', ' ');\n    return !brackets.length;\n}\n\
    /*\nopen_brackets is a string of \"<\".\n    return the minimum number of \">\"\
    \ that must be added to make brackets a\n    correct bracketing.", "{\n\tint bracket_count\
    \ = 0;\n\tforeach(c; brackets)\n\t{\n\t\tif(c == '<')\n\t\t{\n\t\t\tbracket_count++;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tbracket_count--;\n\t\t}\n\t\tif(bracket_count <\
    \ 0) return false;\n\t}\n\treturn bracket_count == 0;\n}", "{\n\timmutable stack\
    \ = new StackImpl!string();\n\tforeach(c; brackets)\n\t{\n\t\tif(c == '<')\n\t\
    \t{\n\t\t\tstack.push(c);\n\t\t}\n\t\telse if(c == '>')\n\t\t{\n\t\t\tif(stack.empty)\n\
    \t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstack.pop();\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn stack.empty;\n}", "{\n    // extract all opening\
    \ brackets\n    string open = brackets.filter!((x) => x == '<');\n    // extract\
    \ all closing brackets\n    string close = brackets.filter!((x) => x == '>');\n\
    \    // if number of opening brackets are not equal to the number of closing brackets,\
    \ then it is false\n    if (open.length != close.length) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        return true;\n    }\n}", "{\n    //\
    \ \u0441\u0447\u0435\u0442\u0447\u0438\u043A \u043E\u0442\u043A\u0440\u044B\u0432\
    \u0430\u044E\u0449\u0438\u0445 \u0441\u043A\u043E\u0431\u043E\u043A\n    int counter\
    \ = 0;\n    foreach(char c; brackets)\n    {\n        if (c == '<')\n        \
    \    counter++;\n        else\n            counter--;\n        if (counter < 0)\n\
    \            return false;\n    }\n    return counter == 0;\n}", "{\n    int count\
    \ = 0;\n    foreach(b; brackets)\n    {\n        if(b == '<') ++count;\n     \
    \   else --count;\n        if(count < 0) return false;\n    }\n    return count\
    \ == 0;\n}\n/*\n    get_bracketing(n) returns a string with n left and n right\
    \ brackets,\n    where every possible bracketing is included\n    >>> get_bracketing(2)\n\
    \    [\"<<>>\", \"<><>\"]\n    >>> get_bracketing(3)\n    [\"<<<>>>\", \"<><><>\"\
    , \"<<><>>\", \"<><<>>>\", \"<<<><>>\", \"<><<><>>\"]\n*/\nstring[] get_bracketing(size_t\
    \ n) \n{\n    if(n == 0) return [\"\"];\n    if(n == 1) return [\"<>\"];\n   \
    \ string[] ret;\n    foreach(b; get_bracketing(n-1))\n    {\n        ret ~= \"\
    <\" ~ b ~ \">\";\n        ret ~= \"<\" ~ b;\n        ret ~= b ~ \">\";\n    }\n\
    \    return ret;\n}\n/*\n    returns the highest possible 3-digit score that can\
    \ be obtained on \n    a given string of brackets.\n    >>> str_score(\"<><><><>\"\
    )\n    3\n    >>> str_score(\"<<<><><>\")\n    6\n    >>> str_score(\"<<<<><>>\"\
    )\n    9\n*/", "{\n\tint bracketCount = 0;\n\tforeach(char bracket; brackets)\n\
    \t{\n\t\tif(bracket == '<')\n\t\t{\n\t\t\tbracketCount++;\n\t\t}\n\t\telse if(bracket\
    \ == '>')\n\t\t{\n\t\t\tbracketCount--;\n\t\t}\n\t\tif(bracketCount < 0)\n\t\t\
    {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn bracketCount == 0;\n}", "{ \n   \
    \ // [ ] has a static size\n    // allocate an array of size brackets.length and\
    \ set it to 0\n    int[brackets.length] open_brackets = void;\n    int open_brackets_index\
    \ = 0;\n    foreach (i, c; brackets) {\n        if (c == '<') {\n            open_brackets[open_brackets_index]\
    \ = i;\n            open_brackets_index++;\n        } else if (c == '>') {\n \
    \           if (open_brackets_index == 0) {\n                return false;\n \
    \           }\n            open_brackets_index--;\n        }\n    }\n    if (open_brackets_index\
    \ != 0) {\n        return false;\n    }\n    return true;\n}", "{\n\tint count\
    \ = 0;", "{\n  //  int counter;\n  //  foreach(bracket; brackets) {\n  //    if\
    \ (bracket == '<') {\n  //       counter += 1;\n  //    } else {\n  //       counter\
    \ -= 1;\n  //       if (counter < 0)\n  //          return false;\n  //    }\n\
    \  // }\n  // return counter == 0;", "{\n  int p = 0;\n  foreach(char c; brackets)\n\
    \  {\n    if (c == '<')\n      p += 1;\n    else if (c == '>')\n      p -= 1;\n\
    \    if (p < 0)\n      return false;\n  }\n  return p == 0;\n}", "{\n    auto\
    \ s = stack!int();\n    foreach(b;brackets)\n    {\n        if(b == '<') s.push(1);\n\
    \        else if(s.empty) return false;\n        else s.pop();\n    }\n    return\
    \ s.empty;\n}\n/*\n    return the number of elements in brackets that will be\
    \ unbalanced if that element is removed.", "{\n    int count = 0;\n    foreach(ch;\
    \ brackets)\n    {\n        if(ch == '<')\n            count++;\n        else\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    int _nopen = 0;\n    foreach(c; brackets)\n\
    \    {\n        if(c == '<')\n            _nopen++;\n        else\n          \
    \  _nopen--;\n        if(_nopen < 0)\n            return false;\n    }\n    return\
    \ _nopen == 0;\n}", "{\n    foreach(immutable c; brackets)\n    {\n        if(c\
    \ == '<')\n        {\n            scope(exit)\n            {\n               \
    \ if(brackets.length == 1)\n                    return false;\n            }\n\
    \            else\n            {\n                immutable index = brackets.find('>');\n\
    \                if(index == -1)\n                    return false;\n        \
    \        brackets = brackets[index + 1 .. $];\n            }\n        }\n    \
    \    else\n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}", "{\n    debug(brackets);\n    return true;\n}\n/*\n brackets is a\
    \ string of \"<\" and \">\".\n    return the maximum number of opening brackets\
    \ that can be closed by the\n    final closing bracket.", "{\n\tint bracketCount\
    \ = 0;\n\tforeach(char c; brackets)\n\t{\n\t\tif(c == '<')\n\t\t{\n\t\t\tbracketCount++;\n\
    \t\t}\n\t\telse if(c == '>')\n\t\t{\n\t\t\tbracketCount--;\n\t\t}\n\t\telse\n\t\
    \t{\n\t\t\tassert(0);\n\t\t}\n\t\tif(bracketCount < 0)\n\t\t{\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn bracketCount == 0;\n}", "{\n    import std.typecons;\n  \
    \  struct Node\n    {\n        char info;\n        Node next;\n    }\n    Node\
    \ top;\n    char[] a = brackets.dup;\n    for (int i = 0; i < a.length; i++)\n\
    \    {\n        if (a[i] == '<')\n        {\n            Node new_node = new Node;\n\
    \            new_node.info = a[i];\n            new_node.next = top;\n       \
    \     top = new_node;\n        }\n        else if (a[i] == '>')\n        {\n \
    \           if (top != null)\n            {\n                top = top.next;\n\
    \            }\n            else\n            {\n                return false;\n\
    \            }\n        }\n    }\n    if (top == null)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }\n}", "{\n    static\
    \ assert(brackets.length <= 100000);\n    static assert(all!(c => c == '<' ||\
    \ c == '>')(brackets));\n    static assert(!brackets.empty);\n    int n = brackets.length;\n\
    \    int depth = 0;\n    for (int i = 0; i < n; i++) {\n        if (brackets[i]\
    \ == '<') {\n            depth++;\n        } else {\n            depth--;\n  \
    \      }\n        if (depth < 0) {\n            return false;\n        }\n   \
    \ }\n    return depth == 0;\n}", "{\n    int i = 0;\n    int lefts = 0;\n    int\
    \ rights = 0;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n       \
    \ {\n            lefts++;\n        }\n        else if(c == '>')\n        {\n \
    \           rights++;\n        }\n        if(rights > lefts)\n        {\n    \
    \        return false;\n        }\n    }\n    if(lefts != rights)\n    {\n   \
    \     return false;\n    }\n    return true;\n}", "{\n    /*\n    return true\
    \ if every opening bracket has a corresponding closing bracket.\n    */\n    int\
    \ count = 0;\n    foreach(char c; brackets)\n    {\n\tif(c == '<')\n\t    count++;\n\
    \telse if(c == '>')\n\t    count--;\n\tif(count < 0)\n\t    return false;\n  \
    \  }\n    return count == 0;\n}\n/*\ncorrect_bracketing uses a variable to count\
    \ the number of open brackets\n\"<\" minus the number of closed brackets \">\"\
    .  Any time the variable is negative\nthen there must be an opening bracket without\
    \ a closing bracket, so it\nreturns false.  Otherwise, it returns true if the\
    \ variable is zero.\n*/", "{\n    int index_opening = 0;\n    int index_closing\
    \ = 0;\n    size_t length = brackets.length;\n    int length_first_half = (length\
    \ / 2);\n    foreach(i; 0 .. length_first_half)\n    {\n        if(brackets[i]\
    \ == '<')\n        {\n            index_opening += 1;\n        }\n        else\n\
    \        {\n            return false;\n        }\n    }\n    foreach(i; length_first_half\
    \ .. length)\n    {\n        if(brackets[i] == '>')\n        {\n            index_closing\
    \ += 1;\n        }\n        else\n        {\n            return false;\n     \
    \   }\n    }\n    if(index_opening == index_closing)\n    {\n        return true;\n\
    \    }\n    else\n    {\n        return false;\n    }\n}", "{\n    int sum = 0;\n\
    \    foreach(c; brackets)\n    {\n        if(c == '<')\n            sum++;\n \
    \       else if(c == '>')\n            sum--;\n        if(sum < 0)\n         \
    \   return false;\n    }\n    return sum == 0;\n}\n/*", "{\n    uint level = 0;\n\
    \    for (immutable c : brackets) {\n        if (c == '<') {\n            level++;\n\
    \        } else if (c == '>') {\n            if (level == 0) {\n             \
    \   return false;\n            }\n            level--;\n        }\n    }\n   \
    \ return level == 0;\n}", "{\n    int count = 0;\n    foreach(char ch; brackets)\
    \ \n    {\n        if (ch == '<') \n        {\n            count++;\n        }\n\
    \        else \n        {\n            count--;\n        }\n        if (count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    return count\
    \ == 0;\n}\n/*\nisValid is a string of letters representing a valid mathematical\
    \ expression.\n    return true if the expression is balanced.", "{\n  int i =\
    \ 0;\n  int count = 0;\n  while (i < brackets.length)\n  {\n    if (brackets[i]\
    \ == '<')\n    {\n      count++;\n    }\n    else if (brackets[i] == '>')\n  \
    \  {\n      count--;\n    }\n    if (count < 0)\n    {\n      return false;\n\
    \    }\n    i++;\n  }\n  if (count == 0)\n  {\n    return true;\n  }\n  else\n\
    \  {\n    return false;\n  }\n}\n/*\nbrackets is a string of \"[\" and \"]\".\n\
    \    return true if every opening bracket has a corresponding closing bracket.",
  "{\n    int count = 0;\n    for (char i : brackets)\n    {\n        if (i == '<')\n\
    \        {\n            count++;\n        }\n        else if (i == '>')\n    \
    \    {\n            count--;\n        }\n        if (count < 0)\n        {\n \
    \           return false;\n        }\n    }\n    if (count != 0)\n    {\n    \
    \    return false;\n    }\n    return true;\n}", "{\n    int count = 0;\n    foreach(char\
    \ c; brackets) {\n        if (c == '<') count++;\n        else if (c == '>') count--;\n\
    \    }\n    return count == 0;\n}\n/*\n Given a non-empty string of parentheses\
    \ and brackets, return the number of matching pairs.", "{\n    // See if < or\
    \ > and push or pop\n    Stack!(char) bracket_stack;\n    foreach(bracket; brackets)\n\
    \    {\n        if(bracket == '<')\n        {\n            bracket_stack.push(bracket);\n\
    \        }\n        else if(bracket == '>')\n        {\n            if(bracket_stack.empty)\n\
    \            {\n                return false;\n            }\n            bracket_stack.pop();\n\
    \        }\n    }\n    return bracket_stack.empty;\n}", "{\n    /*\n     stack\
    \ is a stack of characters.\n        push(): takes a character, push it on the\
    \ stack.\n        pop(): takes nothing, returns a character.\n        empty():\
    \ takes nothing, returns a bool: true if stack is empty.\n    */\n    struct stack\
    \ {\n        void push(char c) {\n            chars ~= c;\n        }\n       \
    \ char pop() {\n            return chars.pop;\n        }\n        bool empty()\
    \ {\n            return chars.empty;\n        }\n        char[] chars;\n    }\n\
    \    stack open_brackets;\n    foreach (char c; brackets) \n    {\n        if\
    \ (c == '<') \n        {\n            open_brackets.push(c);\n        } \n   \
    \     else if (c == '>') \n        {\n            if (open_brackets.empty()) \n\
    \            {\n                return false;\n            } \n            else\
    \ \n            {\n                open_brackets.pop();\n            }\n     \
    \   }\n    }\n    return open_brackets.empty();\n}\n/*\n stack is a stack of integers.\n\
    \    push(): takes an integer, push it on the stack.\n    pop(): takes nothing,\
    \ returns an integer.\n    empty(): takes nothing, returns a bool: true if stack\
    \ is empty.\n*/\nstruct stack {\n    void push(int x) {\n        nums ~= x;\n\
    \    }\n    int pop() {\n        return nums.pop;\n    }\n    bool empty() {\n\
    \        return nums.empty;\n    }\n    int[] nums;\n}\n/*\n dfs takes a graph\
    \ and a vertex.\n    return a string representing a path from the starting vertex\
    \ to an ending vertex.\n    if there is no such path, return \"fail\".\n    (in\
    \ this case, we have a graph with a single vertex, and a path is a sequence of\
    \ edges where each vertex is adjacent to the next.)", "{\n    int c = 0;\n   \
    \ foreach(char bracket; brackets) {\n        if (bracket == '<') {\n         \
    \   c++;\n        } else {\n            c--;\n        }\n        if (c < 0) {\n\
    \            return false;\n        }\n    }\n    return c == 0;\n}", "{ \n  \
    \  alias Stack = Stack!(char);\n    Stack opening_brackets;\n    foreach(char\
    \ c; brackets)\n    {\n        if(c == '<')\n        {\n            opening_brackets.push(c);\n\
    \        }\n        else\n        {\n            if(opening_brackets.empty)\n\
    \            {\n                return false;\n            }\n            else\n\
    \            {\n                opening_brackets.pop();\n            }\n     \
    \   }\n    }\n    return opening_brackets.empty;\n}\nassert(correct_bracketing(\"\
    <\") == false);\nassert(correct_bracketing(\"<>\") == true);\nassert(correct_bracketing(\"\
    <<><>>\") == true);\nassert(correct_bracketing(\"><<>\") == false);\n/*\n    brackets\
    \ is a string of \"<\" and \">\".\n    return the index of the first erroneous\
    \ bracket.\n    if no error is found, return -1.", "{\n    int i = 0;\n    int\
    \ j = 0;\n    foreach( c; brackets )\n    {\n        if( c == '<' )\n        \
    \    i++;\n        else if( c == '>' )\n            j++;\n        if( j > i )\n\
    \            return false;\n    }\n    return ( i == j );\n}", "{\n    uint len\
    \ = brackets.length;\n    if (len == 0) return true;\n    for (uint i = 0; i <\
    \ len/2; i++)\n    {\n        if (brackets[i] != '<' || brackets[len-i-1] != '>')\n\
    \            return false;\n    }\n    return true;\n}", "{\n    int level = 0;\n\
    \    foreach(char c;brackets)\n    {\n        if(c == '<') \n            level++;\n\
    \        else if(c == '>')\n            level--;\n        else\n            return\
    \ false;\n        if(level < 0)\n            return false;\n    }\n    return\
    \ level == 0;\n}\n/*\n    sort the contents of a linked list in place\n    >>>\
    \ l = [3, 1, 2, 0]\n    >>> sort_list(l)\n    >>> l\n    [0, 1, 2, 3]\n*/", "{\n\
    \    // Should return false if brackets is an empty string.\n    if (brackets.empty)\n\
    \        return false;\n    \n    // Create a stack for bracketing, and initialize\
    \ it to an empty string.\n    auto bracket_stack = new StackedString(\"\");\n\
    \    \n    // Push each bracket to the stack, check for correct bracketing, and\
    \ return.\n    foreach (bracket; brackets) {\n        if (bracket == '<') {\n\
    \            bracket_stack.push(\"<\");\n        } else if (bracket == '>') {\n\
    \            if (bracket_stack.isEmpty())\n                return false;\n   \
    \         bracket_stack.pop();\n        }\n    }\n    if (bracket_stack.isEmpty())\n\
    \        return true;\n    else\n        return false;\n}", "{\n    uint count\
    \ = 0;\n    foreach(ch; brackets) \n    {\n        if (ch == '<') \n        {\n\
    \            count++;\n        } \n        else if (ch == '>') \n        {\n \
    \           if (count == 0) \n            {\n                return false;\n \
    \           }\n            count--;\n        }\n    }\n    return count == 0;\n\
    }\n/*\n * brackets is a string of \"<\" and \">\".\n    return true if every opening\
    \ bracket has a corresponding closing bracket, \n    and it is in the right place.",
  "{\n    int numOpen = 0;", "{\n    // Open bracket types\n    static immutable string\
    \ open_brackets = \"<<<\";\n    // Close bracket types\n    static immutable string\
    \ close_brackets = \">>>\";\n    //stuct to store the bracket type and state of\
    \ a bracket\n    struct Bracket(char type, bool open) {\n        char type;\n\
    \        bool open;\n    }\n    //A tuple of all expected brackets and the types\
    \ of the brackets\n    alias bracket_types = typeof(tuple!(Bracket(open_brackets[0],\
    \ true), \n                                      Bracket(close_brackets[0], false),\n\
    \                                      Bracket(open_brackets[1], true),\n    \
    \                                  Bracket(close_brackets[1], false),\n      \
    \                                Bracket(open_brackets[2], true),\n          \
    \                            Bracket(close_brackets[2], false)));\n    //A stack\
    \ of open brackets\n    Stack!Bracket bracket_stack;\n    //For each bracket in\
    \ the input check if it is an open bracket and if so push it on the stack\n  \
    \  //else if it is an expected close bracket then pop the last bracket and check\
    \ that it is the correct type for the closing bracket\n    //if a bracket type\
    \ is not expected then return false\n    foreach(bracket; brackets) {\n      \
    \  if(bracket_types.find!(bracket => bracket.type == bracket && bracket.open).open)\
    \ {\n            bracket_stack.push(Bracket(bracket, true));\n        } else if(bracket_types.find!(bracket\
    \ => bracket.type == bracket && !bracket.open)) {\n            auto open_bracket\
    \ = bracket_stack.pop();\n            if(open_bracket.type != open_brackets[close_brackets.find(bracket)])\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    return false;\n        }\n    }\n    //If all brackets matched then the stack\
    \ should be empty\n    return bracket_stack.empty;\n}", "{\n    bool res = true;\n\
    \    size_t open = 0;\n    size_t close = 0;\n    foreach(c; brackets)\n    {\n\
    \        if(c == '<') open++;\n        else close++;\n        if(close > open)\n\
    \        {\n            res = false;\n            break;\n        }\n    }\n \
    \   if(open != close) res = false;\n    return res;\n}", "{\n    int open = 0;\n\
    \    int close = 0;\n    for (size_t i = 0; i < brackets.length; i++) {\n    \
    \    char bracket = brackets[i];\n        if (bracket == '<') {\n            open++;\n\
    \        } else if (bracket == '>') {\n            close++;\n        }\n     \
    \   if (close > open) {\n            return false;\n        }\n    }\n    return\
    \ open == close;\n}", "{\n    // TODO: Implement this function.\n    return true;\n\
    }", "{\n    \n    // count how many opening brackets we have, and how many closing\
    \ brackets\n    // we have.\n    // if they are the same, then we are good.\n\
    \    int opening_count = 0;\n    int closing_count = 0;\n    for (int i = 0; i\
    \ < brackets.length(); i++) {\n        if (brackets[i] == '<') {\n           \
    \ opening_count += 1;\n        } else if (brackets[i] == '>') {\n            closing_count\
    \ += 1;\n        }\n    }\n    return opening_count == closing_count;\n}", "{\n\
    \    int count = 0;\n    foreach(char c; brackets)\n    {\n        if(c == '<')\n\
    \            count++;\n        else if(c == '>')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n}",
  "{\n    if (brackets.find('<') == -1)\n        return false;\n    int count = 0;\n\
    \    foreach (c; brackets)\n    {\n        if (c == '<')\n            count++;\n\
    \        else\n            count--;\n        if (count == 0)\n            return\
    \ true;\n    }\n    return false;\n}\n/*\n    >>>  jb(1, 4)\n    [1, 2, 3, 4]\n\
    \    >>>  jb(1, 4, 1)\n    [1, 2, 3, 4]\n    >>>  jb(1, 4, 2)\n    [1, 3]\n  \
    \  >>>  jb(1, 4, 3)\n    [1, 4]\n    >>>  jb(1, 4, 4)\n    [1, 4]\n    >>>  jb(1,\
    \ 4, 5)\n    [1, 4]\n    >>>  jb(1, 4, 6)\n    [1, 4]\n    >>>  jb(1, 4, 7)\n\
    \    [1, 4]\n    >>>  jb(1, 4, 8)\n    [1, 4]\n    >>>  jb(1, 4, 9)\n    [1, 4]\n\
    \    >>>  jb(1, 4, 10)\n    [1, 4]\n    >>>  jb(1, 4, 11)\n    [1, 4]\n    >>>\
    \  jb(1, 4, 12)\n    [1, 4]\n    >>>  jb(1, 4, 13)\n    [1, 4]\n    >>>  jb(1,\
    \ 4, 14)\n    [1, 4]\n    >>>  jb(1, 4, 15)\n    [1, 4]\n    >>>  jb(1, 4, 16)\n\
    \    [1, 4]\n    >>>  jb(1, 4, 17)\n    [1, 4]\n    >>>  jb(1, 4, 18)\n    [1,\
    \ 4]\n    >>>  jb(1, 4, 19)\n    [1, 4]\n    >>>  jb(1, 4, 20)\n    [1, 4", "{\n\
    \    foreach(char c; brackets)\n    {\n        if(c=='<')\n        {\n       \
    \     char[] temp;\n            temp ~= c;\n            temp ~= '>';\n       \
    \     brackets = replace(brackets, temp, \"\");\n        }\n    }\n    return\
    \ brackets.length == 0;\n}", "{\n    uint stack = 0;\n    foreach(i, ch; brackets)\n\
    \    {\n        if(ch == '<')\n            stack++;\n        else if(ch == '>')\n\
    \            stack--;\n        if(stack == -1)\n            return false;\n  \
    \  }\n    return stack == 0;\n}", "{\n    immutable bracketSize = brackets.length;\n\
    \    if(bracketSize < 1) return false;\n    int openBrackets = 0;\n    for(char\
    \ c in brackets)\n    {\n        if(c == '<') openBrackets++;\n        else if(c\
    \ == '>') openBrackets--;\n        if(openBrackets < 0) return false;\n    }\n\
    \    return openBrackets == 0;\n}\n//@safe", "{\n    // your code here\n    return\
    \ false;\n}", "{\n    stack!char st;\n    foreach(c;brackets) {\n\t\tif(c == '<')\n\
    \t\t\tst.push(c);\n\t\telse if(c == '>') {\n\t\t\tif(st.empty || st.top != '<')\n\
    \t\t\t\treturn false;\n\t\t\tst.pop();\n\t\t}\n\t}\n\treturn st.empty;\n}", "{\n\
    \    int count = 0;\n    for (auto c : brackets)\n    {\n        if (c == '<')\n\
    \            count++;\n        else\n            count--;\n        if (count <\
    \ 0)\n            return false;\n    }\n    return count == 0;\n}", "{\n    /*\n\
    \    int open = 0;\n    foreach(char ch; brackets)\n    {\n        if(ch == '<')\
    \ open++;\n        else open--;\n        if(open < 0) return false;\n    }\n \
    \   return open == 0;\n    */\n    /*\n    int open = 0;\n    foreach(char ch;\
    \ brackets)\n    {\n        if(ch == '<') open++;\n        else open--;\n    \
    \    if(open < 0) return false;\n    }\n    return open == 0;\n    */\n    /*\n\
    \    int open = 0;\n    foreach(char ch; brackets)\n    {\n        if(ch == '<')\
    \ open++;\n        else open--;\n        if(open < 0) return false;\n    }\n \
    \   return open == 0;\n    */\n    /*\n    int open = 0;\n    foreach(char ch;\
    \ brackets)\n    {\n        if(ch == '<') open++;\n        else open--;\n    \
    \    if(open < 0) return false;\n    }\n    return open == 0;\n    */\n    /*\n\
    \    int open = 0;\n    foreach(char ch; brackets)\n    {\n        if(ch == '<')\
    \ open++;\n        else open--;\n        if(open < 0) return false;\n    }\n \
    \   return open == 0;\n    */\n    int open = 0;\n    foreach(char ch; brackets)\n\
    \    {\n        if(ch == '<') open++;\n        else open--;\n        if(open <\
    \ 0) return false;\n    }\n    return open == 0;\n}", "{\n    return is_empty(brackets)\
    \ || \n        (brackets[0] == '<' && \n        brackets[$-1] == '>' && \n   \
    \     correct_bracketing(brackets[1..$-1]));\n}", "{\n\tint total=0;\n\tforeach(immutable\
    \ char c;brackets)\n\t{\n\t\tif(c=='<') total+=1;\n\t\telse if(c=='>') total-=1;\n\
    \t\tif(total<0) return false;\n\t}\n\treturn total==0;\n}", "{\n    bool flag\
    \ = true;\n    auto temp = brackets.length;\n    struct Stack{\n        int top;\n\
    \        int elements[10];\n    }s;\n    s.top = -1;\n    foreach(i; 0..temp)\n\
    \    {\n        if(brackets[i] == '<')\n        {\n            s.top++;\n    \
    \        s.elements[s.top] = i;\n        }\n        else if(brackets[i] == '>')\n\
    \        {\n            if(s.top == -1)\n            {\n                flag =\
    \ false;\n                break;\n            }\n            else\n          \
    \  {\n                s.top--;\n            }\n        }\n    }\n    if(s.top\
    \ != -1)\n    {\n        flag = false;\n    }\n    return flag;\n}", "{\n    int\
    \ count = 0;\n    foreach(ch; brackets) \n    {\n        if (ch == '<')\n    \
    \        count++;\n        else\n            count--;\n        if (count < 0)\n\
    \            return false;\n    }\n    return count == 0;\n}", "{\n    // keep\
    \ track of the number of left brackets we have seen so far.\n    // only when\
    \ the number of left brackets is zero can we close the right bracket.\n    int\
    \ n_left = 0;\n    foreach(c; brackets) {\n        if (c == '<') {\n         \
    \   n_left++;\n        } else if (c == '>') {\n            n_left--;\n       \
    \ }\n        if (n_left < 0)\n            return false;\n    }\n    return n_left\
    \ == 0;\n}", "{\n\tTuple!(int, int) result;\n\tbrackets = brackets.toLower();\n\
    \tconst char [] less = \"<\";\n\tconst char [] greater = \">\";\n\t\n\tif (brackets.count(greater)\
    \ == brackets.count(less))\n\t{\n\t\treturn true;\n\t}\n\telse \n\t{\n\t\treturn\
    \ false;\n\t}\n}", "{\n\tint cnt = 0;\n\tforeach(b;brackets)\n\t{\n\t\tif(b ==\
    \ '<') cnt++;\n\t\telse if(b == '>') cnt--;\n\t\tif(cnt < 0) return false;\n\t\
    }\n\treturn cnt == 0;\n}\n/*\n    A \"step\" is the difference between an element\
    \ and the next one.\n    return true if the list of steps is in ascending or descending\
    \ order.", "{\n    size_t openBracket = 0;\n    size_t closeBracket = 0;\n   \
    \ for (size_t i = 0; i < brackets.length; i++)\n    {\n        if (brackets[i]\
    \ == '<')\n        {\n            openBracket++;\n        }\n        else\n  \
    \      {\n            closeBracket++;\n        }\n    }\n    return openBracket\
    \ == closeBracket;\n}", "{\n    auto s = stack!char();\n    foreach(c; brackets)\
    \ {\n        if (c == '<')\n            s.push(c);\n        else if (c == '>')\
    \ {\n            if (s.empty || s.pop() != '<')\n                return false;\n\
    \        }\n    }\n    return s.empty;\n}\n/*", "{\n    bool checker = true;\n\
    \    while(0<brackets.length)\n    {\n        if(brackets[0]=='>')\n        {\n\
    \            checker = false;\n            break;\n        }\n        else\n \
    \       {\n            size_t close = brackets.find('>');\n            if(close==string.npos)\n\
    \            {\n                checker = false;\n                break;\n   \
    \         }\n            else\n            {\n                brackets = brackets.substr(close+1);\n\
    \            }\n        }\n    }\n    return checker;\n}", "{\n    int openBrackets=0;\n\
    \    foreach(c;brackets)\n    {\n        if(c=='<')\n            openBrackets++;\n\
    \        else if(c=='>')\n            openBrackets--;\n        if(openBrackets<0)\n\
    \            return false;\n    }\n    return openBrackets==0;\n}", "    if (brackets.length\
    \ == 0) \n        return true;\n    else \n        auto open_bracket_indicies\
    \ = brackets.indices.filter!(c => brackets[c] == '<');\n        auto close_bracket_indicies\
    \ = brackets.indices.filter!(c => brackets[c] == '>');\n        return (open_bracket_indicies.length\
    \ == close_bracket_indicies.length) && open_bracket_indicies.zip(close_bracket_indicies).all!(c\
    \ => c[0] < c[1]);", "{\n    int open = 0;\n    int close = 0;\n    foreach(c;\
    \ brackets)\n    {\n        if(c == '<')\n        {\n            open++;\n   \
    \     }\n        else if(c == '>')\n        {\n            close++;\n        }\n\
    \    }\n    if(open == close)\n    {\n        return true;\n    }\n    else\n\
    \    {\n        return false;\n    }\n}", "{\n    int size = brackets.length;\n\
    \    int count=0;\n    int loop = 0;\n    while(loop < size)\n    {\n        if(brackets[loop]\
    \ == '<')\n        {\n            count++;\n        }\n        else\n        {\n\
    \            count--;\n        }\n        if(count < 0)\n        {\n         \
    \   return false;\n        }\n        loop++;\n    }\n    if(count != 0)\n   \
    \ {\n        return false;\n    }\n    return true;\n}\n/*\ncount_correct_bracketings\
    \ is a string of \"<\" and \">\".\n    return the number of bracketings that are\
    \ both correct and\n    minimal in length.", "{\n    //initialize the counter\
    \ to 0\n    int counter = 0;\n    //iterate through the brackets string\n    foreach(bracket;\
    \ brackets)\n    {\n        //if the bracket is '<'\n        if(bracket == '<')\n\
    \        {\n            //decrement the counter\n            counter--;\n    \
    \    }\n        //if the bracket is '>'\n        else if(bracket == '>')\n   \
    \     {\n            //increment the counter\n            counter++;\n       \
    \ }\n        //if the counter is greater than 0 at any point, return false\n \
    \       if(counter > 0)\n        {\n            return false;\n        }\n   \
    \ }\n    //if the counter is still 0 after the iteration, return true\n    if(counter\
    \ == 0)\n    {\n        return true;\n    }\n    //return false otherwise\n  \
    \  return false;\n}\n/*\n    in_substitution is a string representing an in-substitution.\n\
    \    return true if the in-substitution is valid.", "{\n    int i;\n    char c;\n\
    \    char c1;\n    int angle_count;\n    int open_count;\n    int close_count;\n\
    \    angle_count = 0;\n    open_count = 0;\n    close_count = 0;\n    for (i =\
    \ 0; i < brackets.length; i++)\n    {\n        c = brackets[i];\n        if (c\
    \ == '<')\n        {\n            open_count++;\n            angle_count++;\n\
    \        }\n        else if (c == '>')\n        {\n            close_count++;\n\
    \            angle_count--;\n        }\n        if (angle_count < 0)\n       \
    \ {\n            return false;\n        }\n    }\n    if (open_count == close_count)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}", "{\n    string openers = \"<\";\n    string closers = \">\";\n   \
    \ Stack stack;\n    if (find(brackets, '<') == -1)\n        return false;\n  \
    \  else if (find(brackets, '>') == -1)\n        return false;\n    else\n    {\n\
    \        for (int i = 0; i < len(brackets); i++)\n        {\n            if (find(openers,\
    \ brackets[i]) != -1)\n                stack.push(brackets[i]);\n            else\
    \ if (find(closers, brackets[i]) != -1)\n            {\n                if (len(stack)\
    \ == 0)\n                    return false;\n                else if (stack.pop()\
    \ != \"<\")\n                    return false;\n            }\n        }\n   \
    \     if (len(stack) != 0)\n            return false;\n        else\n        \
    \    return true;\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
