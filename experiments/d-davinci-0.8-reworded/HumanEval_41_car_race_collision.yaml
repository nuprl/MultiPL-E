name: HumanEval_41_car_race_collision
language: d
prompt: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight infinitely\
  \ long line.\n    n cars are driving left to right;  simultaneously, a different\
  \ set of n cars\n    are driving right to left.   The two sets of cars start out\
  \ being very far from\n    each other.  All cars move in the same speed.  Two cars\
  \ are said to collide\n    when a car that's moving left to right hits a car that's\
  \ moving right to left.\n    However, the cars are infinitely sturdy and strong;\
  \ as a result, they continue moving\n    in their trajectory as if they did not\
  \ collide.\n\n    This function outputs the number of such collisions.\n    \n*/\n\
  long car_race_collision(long n) \n"
tests: "unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
  \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
  \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
  \ main(){}"
completions: ["{\n    long ret = 0;\n    return ret;\n}", "{ \n    long index1 = 0;\n\
    \    long index2 = n-1;\n    long count = 0;\n    while (index1 <= index2) {\n\
    \        while (index1 <= index2 && ((index1 + index2) % 2 == 0)) {\n        \
    \    index1++;\n        }\n        while (index1 <= index2 && ((index1 + index2)\
    \ % 2 == 1)) {\n            index2--;\n        }\n        count++;\n    }\n  \
    \  return count;\n}", "{\n    long result;\n    static if (n <= 0) {\n       \
    \ result = 0;\n    } else {\n        result = n * (n - 1) / 2;\n    }\n    return\
    \ result;\n}", "{\n    //* Test cases\n    assert(car_race_collision(1) == 0);\n\
    \    assert(car_race_collision(2) == 1);\n    assert(car_race_collision(4) ==\
    \ 4);\n    assert(car_race_collision(10) == 45);\n    assert(car_race_collision(100)\
    \ == 4950);\n    return (n * (n - 1)) / 2;\n}", "{\n    return (n*(n-1))/2;\n\
    }\n/*", "{\n    return n * (n - 1) / 2;\n}", "{\n    long[] car1 = new long[n];\n\
    \    long[] car2 = new long[n];\n    long[] buffer = new long[n];\n    long[]\
    \ buffer2 = new long[n];\n    long res;\n    long i, j, k;\n    long index, index2;\n\
    \    long min, min_index;\n    for (i = 0; i < n; i++) {\n        car1[i] = random();\n\
    \        car2[i] = random();\n    }\n    for (i = 0; i < log(n) + 1; i++) {\n\
    \        for (j = 0; j < n; j++) {\n            buffer[j] = j;\n        }\n  \
    \      for (j = 0; j < n; j++) {\n            min = car1[j];\n            min_index\
    \ = j;\n            for (k = j; k < n; k++) {\n                if (car1[k] < min)\
    \ {\n                    min = car1[k];\n                    min_index = k;\n\
    \                }\n            }\n            car1[min_index] = car1[j];\n  \
    \          car1[j] = min;\n            buffer2[j] = buffer[min_index];\n     \
    \       buffer[min_index] = buffer[j];\n            buffer[j] = buffer2[j];\n\
    \        }\n        for (j = 0; j < n; j++) {\n            min = car2[j];\n  \
    \          min_index = j;\n            for (k = j; k < n; k++) {\n           \
    \     if (car2[k] < min) {\n                    min = car2[k];\n             \
    \       min_index = k;\n                }\n            }\n            car2[min_index]\
    \ = car2[j];\n            car2[j] = min;\n            buffer2[j] = buffer[min_index];\n\
    \            buffer[min_index] = buffer[j];\n            buffer[j] = buffer2[j];\n\
    \        }\n        index = 0;\n        index2 = 0;\n        while (index < n\
    \ && index2 < n) {\n            if (car1[index] < car2[index2]) {\n          \
    \      index", "{\n    if (n < 1) return 0;\n    auto f = new real[n];\n    for\
    \ (long i = 0; i < n; i++) f[i] = i;", "{\n    uint nb_collisions = 0;\n    if\
    \ (n < 1) \n        return nb_collisions;\n    long rl_time = 0;  // time when\
    \ the right to left car hit the starting point\n    long lr_time = 2*n;  // time\
    \ when the left to right car hit the end point\n    long* rl_speed = new long[n];\
    \  // speed of the right to left cars\n    long* lr_speed = new long[n];  // speed\
    \ of the left to right cars\n    long* rl_pos   = new long[n];  // position of\
    \ the right to left cars\n    long* lr_pos   = new long[n];  // position of the\
    \ left to right cars\n    for (uint i = 0; i < n; ++i) \n    {\n        rl_speed[i]\
    \ = n-i;  // all right to left cars move at different speeds\n        lr_speed[i]\
    \ = n-i;  // all left to right cars move at different speeds\n        rl_pos[i]\
    \ = -(n-i);  // right to left cars start at different positions\n        lr_pos[i]\
    \ = n-i;  // left to right cars start at different positions\n    }\n    // this\
    \ is the time when the right to left and left to right cars will hit each other\n\
    \    long collide_time = 2*n - sqrt(n);  \n    for (uint i = 0; i < n; ++i) \n\
    \    {\n        long speed_rl = rl_speed[i];\n        long speed_lr = lr_speed[i];\n\
    \        // this is the time when the right to left car hit the starting point\n\
    \        rl_time = -rl_pos[i]/speed_rl;  \n        // this is the time when the\
    \ left to right car hit the end point\n        lr_time = 2*n-lr_pos[i]/speed_lr;\
    \  \n        // if the left to right car hit the end point before the right to\
    \ left car\n        // hit the starting point, it means that the collision has\
    \ happened;\n        // we increment the number of collisions\n        if (lr_time\
    \ < r", "{\n    int i;\n    int j;\n    int collisions = 0;\n    for (i = 0; i\
    \ < n; i++)\n    {\n        for (j = i + 1; j < n; j++)\n        {\n         \
    \   collisions++;\n        }\n    }\n    return collisions;\n}", "{\n    long\
    \ collision_count = 0;\n    collision_count = sqrt(n*n);\n    return collision_count;\n\
    }", "{\n    /* no cars = no collisions */\n    if (n == 0) return 0;\n    \n \
    \   /*\n        so we can think of it as having a set of n left-to-right cars\
    \ and a set of n right-to-left cars.\n        - the left-to-right cars have [1..n]\
    \ indices, and the right-to-left cars have [-n..-1] indices.\n        - we only\
    \ have to care about the left-to-right cars, since by symmetry the number of collisions\
    \ is the same.\n        - every left-to-right car is going to collide with at\
    \ most one right-to-left car.\n        - the left-to-right car with index i will\
    \ collide with the right-to-left car with index -i if and only if\n          \
    \  the right-to-left car with index -i is in the range [i-a..i], where a is some\
    \ positive constant.\n        - thus, the number of collisions is equal to the\
    \ number of indices i in [1..n] such that the left-to-right car\n            with\
    \ index i will collide with the right-to-left car with index -i.\n        - now,\
    \ to find out how many indices i in [1..n] there are such that the right-to-left\
    \ car with index -i is in the\n            range [i-a..i], we can partition the\
    \ set of those indices into two parts:\n            - the set of indices j in\
    \ [1..n] such that the right-to-left car with index -j is in the range [j-a..j].\n\
    \            - the set of indices j in [1..n] such that the right-to-left car\
    \ with index -j is not in the range [j-a..j], but\n                the right-to-left\
    \ car with index -(j+1) is in the range [(j+1)-a..(j+1)].\n        - now, the\
    \ number of collisions is equal to the union of the two sets of indices.\n   \
    \     - the number of collisions is clearly not larger than the first set of indices.\n\
    \        - the number of collisions is also not larger than the second set of\
    \ indices.\n        - since the number of collisions is clearly not larger than\
    \ the first set of indices, the number of collisions is\n", "{\n    auto left\
    \ = range(0, n);\n    auto right = array(left[n - 1 - i] for i in 0 .. n);\n \
    \   auto left_pos = array(n - i - 1 for i in 0 .. n);\n    auto right_pos = array(i\
    \ for i in 0 .. n);\n    long collisions = 0;\n    for (; ; ) \n    {\n      \
    \  auto min_left = min(left_pos);\n        auto min_right = min(right_pos);\n\
    \        if (min_left >= min_right)\n            break;\n        collisions +=\
    \ n - max(left_pos);\n        left_pos[left_pos.find(min_left)] += 1;\n      \
    \  right_pos[right_pos.find(min_right)] += 1;\n    }\n    return collisions;\n\
    }", "{\n    /*\n    But how do you find the number of collisions?\n    Lets say\
    \ the cars on the left and the cars on the right start\n    out in a certain order.\
    \  That is, we can say that the starting position\n    for the cars is \n    Left:\
    \    A, B, C, D\n    Right:   E, F, G, H\n    This is one possible starting arrangement.\
    \  There are 4! = 24 possible arrangements.\n    Now, lets say we have a collision.\
    \  This means that in the end:\n    Left:    A, C, D, B\n    Right:   E, G, H,\
    \ F\n    This is another possible starting arrangement.  There are 4! = 24 possible\
    \ arrangements.\n    So if we could enumerate all possible arrangements, then\
    \ we could just find the number of\n    arrangements that have at least one collision.\
    \  This is equivalent to finding the total number\n    of arrangements minus the\
    \ number of arrangements that do not have any collisions.\n    */\n    long num_collisions\
    \ = 0;\n    long all_arrangements = 0;\n    /*\n    Lets iterate over all of the\
    \ possible arrangements.  One way to do this is to use a recursive\n    algorithm.\
    \  One possible algorithm is as follows:\n    1.  We start with the cars on the\
    \ left and the cars on the right all in order.  E.g.,\n    Left:    A, B, C, D\n\
    \    Right:   E, F, G, H\n    2.  Then, we find the minimum position number p\
    \ such that either the car in position p on the left\n    or the car in position\
    \ p on the right is greater than the corresponding car on the other side.  E.g.,\n\
    \    Left:    A, B, C, D\n    Right:   E, F, G, H\n    Here, p = 2.  The car in\
    \ position 2 on the left is C, which is greater than the car in position 2 on\
    \ the right, which is F.\n    (The car in position 2 on the right is F, which\
    \ is smaller than the car in position 2 on the left, which is C.)\n    3.  Then,\
    \ we swap the cars at positions p on the left and p on the right, as well as all\
    \ of the cars in positions greater than p", "{\n    int[] c1 = new int[n];\n \
    \   int[] c2 = new int[n];\n    for (int i = 0; i < n; i++) \n    {\n        c1[i]\
    \ = (int)rand(1, n*2);\n        c2[i] = (int)rand(1, n*2);\n    }\n    sort(c1);\n\
    \    sort(c2);\n    int j = 0;\n    int count = 0;\n    for (int i = 0; i < n;\
    \ i++) \n    {\n        if (c1[i] < c2[j]) \n        {\n            count++;\n\
    \        }\n        else \n        {\n            j++;\n        }\n    }\n   \
    \ return count;\n}\n/*", "{\n    long sum = 0;\n    foreach (i; 0 .. n) {\n  \
    \      sum += i;\n    }\n    return sum;\n}\n/*\n    Imagine a road that's a perfectly\
    \ straight infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "{\n    return n * (n - 1) / 2;\n}", "{\n    import\
    \ std.math;\n    const long infinity = 46340;\n    const int steps = 100;\n  \
    \  int carsLeft[infinity];\n    int carsRight[infinity];\n    for (int i = 0;\
    \ i < infinity; i++) {\n        carsLeft[i] = 0;\n        carsRight[i] = 0;\n\
    \    }\n    foreach (i; 0 .. n) {\n        carsLeft[i] = infinity/n * i;\n   \
    \     carsRight[i] = infinity - infinity/n * i;\n    }\n    int collisions = 0;\n\
    \    for (int i = 0; i < steps; i++) {\n        foreach (j; 0 .. n) {\n      \
    \      if (carsLeft[j] == infinity)\n                continue;\n            if\
    \ (carsLeft[j] > infinity - infinity/n * i)\n                carsLeft[j] -= infinity/n;\n\
    \            else if (carsLeft[j] < infinity/n * i)\n                carsLeft[j]\
    \ += infinity/n;\n            else {\n                foreach (k; 0 .. n) {\n\
    \                    if (carsRight[k] == infinity)\n                        continue;\n\
    \                    if (carsRight[k] > infinity - infinity/n * i)\n         \
    \               carsRight[k] -= infinity/n;\n                    else if (carsRight[k]\
    \ < infinity/n * i)\n                        carsRight[k] += infinity/n;\n   \
    \                 else {\n                        if (carsLeft[j] == carsRight[k])\
    \ {\n                            collisions++;\n                            carsLeft[j]\
    \ = infinity;\n                            carsRight[k] = infinity;\n        \
    \                }\n                    }\n                }\n            }\n\
    \        }\n    }\n    return collisions;\n}", "{\n    long i;\n    long total\
    \ = 0;\n    long left_to_right[n];\n    long right_to_left[n];\n    for (i = 0;\
    \ i < n; i++) \n    {\n        left_to_right[i] = i;\n        right_to_left[i]\
    \ = -(i + 1);\n    }\n    for (i = 0; i < n; i++) \n    {\n        total += left_to_right[i]\
    \ + right_to_left[i];\n    }\n    return total;\n}\n/*\n    What is the time complexity\
    \ of this algorithm?\n    The first loop will run n times.\n    The second loop\
    \ will run n times.\n    No other operations other than adding.\n    Therefore,\
    \ this is an O(n) algorithm.", "{\n    //assert(n > 0);\n    long *arr = new long[n];\n\
    \    for (long i = 0; i < n; i++)\n        arr[i] = i;\n    shuffle(arr, arr +\
    \ n);\n    long count = 0;\n    for (long i = 0; i < n; i++)\n        for (long\
    \ j = i + 1; j < n; j++)\n            if (arr[i] > arr[j])\n                count++;\n\
    \    return count;\n}", "{\n    long num_left_to_right_cars = n;\n    long num_right_to_left_cars\
    \ = n;\n    long num_collisions = 0;\n    while (num_left_to_right_cars > 0 &&\
    \ num_right_to_left_cars > 0) \n    {\n        if (num_left_to_right_cars % 2\
    \ == 1) \n        {\n            num_collisions += num_right_to_left_cars / 2;\n\
    \        }\n        num_left_to_right_cars /= 2;\n        num_right_to_left_cars\
    \ /= 2;\n    }\n    return num_collisions;\n}", "{\n    return n*(n-1)/2;\n}\n\
    /*\n    Given the number of cars n, this function outputs the number of collisions.\n\
    */\nlong car_race_collision_1(long n) \n{\n    long collision = 0;\n    foreach(i;\
    \ 0 .. n-1)\n    {\n        foreach(j; i+1 .. n)\n        {\n            collision++;\n\
    \        }\n    }\n    return collision;\n}\n/*\n    The method above actually\
    \ runs in O(n^2) time.  \n    Using a divide and conquer algorithm, we can reduce\
    \ the running time to O(n lg n).\n    Because the algorithm is divide and conquer,\
    \ it will run in O(n) space.\n*/\nlong car_race_collision_2(long n) \n{\n    auto\
    \ car_collisions = (a, b)\n    {\n        return (b-a-1)*(b-a)/2;\n    };\n  \
    \  long collisions = 0;\n    long high = n;\n    long low = 0;\n    long mid =\
    \ (high+low)/2;\n    long total_collisions = car_collisions(low, high);\n    collisions\
    \ += total_collisions;\n    while(high != mid && low != mid)\n    {\n        total_collisions\
    \ = car_collisions(low, mid) + car_collisions(mid, high);\n        collisions\
    \ += total_collisions;\n        high = mid;\n        mid = (high+low)/2;\n   \
    \ }\n    return collisions;\n}\n/*\n    Another method is to use a bit manipulations.\n\
    \    I create a binary representation of n. \n    Then, I count the number of\
    \ 1's in the binary representation.\n    For example, n = 13, 13 in binary is\
    \ 1101.  There are 3 1's in 1101.\n    And using the formula above, we get 3*(3-1)/2\
    \ = 3.\n    We can do this in O(n) time, where n is the number of bits in the\
    \ binary representation.\n*/\nlong car_race_collision_3(long n) \n{\n    long\
    \ collision = 0;\n    while(n > 0)\n   ", "{\n    long num_collisions;\n    float\
    \ * left_to_right_x_positions = new float[n];\n    float * right_to_left_x_positions\
    \ = new float[n];\n    num_collisions = 0;\n    for (long left_to_right_car_number\
    \ = 0; left_to_right_car_number < n; left_to_right_car_number++) \n    {\n   \
    \     for (long right_to_left_car_number = 0; right_to_left_car_number < n; right_to_left_car_number++)\
    \ \n        {\n            if (right_to_left_x_positions[right_to_left_car_number]\
    \ - left_to_right_x_positions[left_to_right_car_number] <= 0) \n            {\n\
    \                num_collisions++;\n            }\n        }\n    }\n    return\
    \ num_collisions;\n}", "{ \n    return n*(n-1); \n}", "{\n    long x;\n    for\
    \ (x = 0; x < n; x++) \n    {\n        x += 1;\n    }\n    return x;\n}", "{\n\
    \    long n1=n; // n1 cars are going from left to right\n    long n2=n; // n2\
    \ cars are going from right to left\n    long number_of_collisions=0;\n    long\
    \ a1[n1]; // positions of the n1 cars going from left to right\n    long a2[n2];\
    \ // positions of the n2 cars going from right to left\n    /*\n        For this\
    \ sample problem, we assume that the positions of the\n        cars are 0, 1,\
    \ 2, 3, 4, 5, ..., n-1.\n    */\n    long i=0;\n    while(i<n1) {\n        a1[i]=i;\n\
    \        i=i+1;\n    }\n    i=0;\n    while(i<n2) {\n        a2[i]=n-1-i;\n  \
    \      i=i+1;\n    }\n    /*\n        Now, we check whether there are any cars\
    \ that both have the same\n        position, which means there has been a collision.\n\
    \    */\n    i=0;\n    while(i<n1) {\n        long j=0;\n        while(j<n2) {\n\
    \            if(a1[i]==a2[j]) {\n                number_of_collisions=number_of_collisions+1;\n\
    \            }\n            j=j+1;\n        }\n        i=i+1;\n    }\n    return\
    \ number_of_collisions;\n}", "{\n    long i, j, collisions = 0;\n    float[] leftcars\
    \ = new float[n];\n    float[] rightcars = new float[n];\n    float x;\n    foreach\
    \ (i; 0 .. n) {\n\tx = uniform(0, 100);\n\tleftcars[i] = x;\n\trightcars[i] =\
    \ x;\n    }\n    foreach (i; 0 .. n) {\n\tforeach (j; 0 .. n) {\n\t    if (leftcars[i]\
    \ < rightcars[j])\n\t\tcollisions++;\n\t}\n    }\n    return collisions;\n}",
  "{\n    long car_x_to_right[], car_x_to_left[];\n    long time = 0;\n    long collision_count\
    \ = 0;\n    long i, j;\n    long temp;\n    \n    for (i = 0; i < n; i++) {\n\
    \        car_x_to_right.length = i + 1;\n        car_x_to_right[i] = i;\n    \
    \    car_x_to_left.length = i + 1;\n        car_x_to_left[i] = -i;\n    }\n  \
    \  \n    while (1) {\n        time++;\n        collision_count = 0;\n        temp\
    \ = car_x_to_right[0];\n        for (i = 0; i < n; i++) {\n            if (i <\
    \ n - 1) {\n                car_x_to_right[i] = car_x_to_right[i + 1];\n     \
    \       }\n            if (i > 0) {\n                car_x_to_left[i] = car_x_to_left[i\
    \ - 1];\n            }\n        }\n        car_x_to_right[n - 1] = temp + 1;\n\
    \        car_x_to_left[0] = -car_x_to_left[0] - 1;\n        \n        for (i =\
    \ 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if\
    \ (abs(car_x_to_right[i] - car_x_to_left[j]) == 1) {\n                    collision_count++;\n\
    \                }\n            }\n        }\n        if (collision_count == 0)\
    \ {\n            break;\n        }\n    }\n    return time;\n}", "{\n    long\
    \ num_left_to_right, num_right_to_left;\n    long i, cur_position;\n    long num_collisions\
    \ = 0;\n    num_left_to_right = n;\n    num_right_to_left = n;\n    i = 0;\n \
    \   while(num_left_to_right > 0 && num_right_to_left > 0) {\n        // count\
    \ how many left to right cars are entering the left-side\n        while(i < n\
    \ && num_left_to_right > 0) {\n            num_left_to_right--;\n            i++;\n\
    \        }\n        // count how many right to left cars are entering the right-side\n\
    \        cur_position = i;\n        while(cur_position < 2*n && num_right_to_left\
    \ > 0) {\n            num_right_to_left--;\n            cur_position++;\n    \
    \    }\n        // now, i cars are left to right;  cur_position - i are right\
    \ to left\n        // now, i cars are left to right;  cur_position - i are right\
    \ to left\n        // count how many collisions will occur\n        num_collisions\
    \ += (i * (cur_position - i));\n        // now, there are a total of cur_position\
    \ cars in the road\n        i = cur_position;\n    }\n    return num_collisions;\n\
    }", "{\n    long x=0;\n    int i;\n    int j;\n    //int z;\n    //int y;\n  \
    \  int tempx=0;\n    int tempy=0;\n    int n1=n;\n    int n2=n;\n    int tempx=0;\n\
    \    int tempy=0;\n    int z;\n    int y;\n    int data[];\n    int data2[];\n\
    \    int a=0;\n    int b=0;\n    int c=0;\n    int d=0;\n    int e=0;\n    for(i=0;i<n;i++)\n\
    \    {\n        data[i]=i+1;\n        data2[i]=i+1;\n    }\n    for(i=0;i<n;i++)\n\
    \    {\n        a=data[i];\n        if(data[i]!=tempx)\n        {\n          \
    \  if(data[i]!=tempy)\n            {\n                if(data[i]>data2[i])\n \
    \               {\n                    x++;\n                    tempx=data[i];\n\
    \                    tempy=data2[i];\n                }\n            }\n     \
    \   }\n    }\n    return x;\n}", "{\n    bool[] is_r_to_l = new bool[n];\n   \
    \ long[] cars = new long[n];\n    bool[][] collided = new bool[n][n];\n    long\
    \ num_collisions = 0;\n    long i,j;\n    long num_r_to_l = n;\n    long num_l_to_r\
    \ = n;\n    long r_to_l_pos = 0;\n    long l_to_r_pos = 0;\n    long pos;\n  \
    \  long cars_left_to_place = n;\n    long collision_distance = 0;\n    bool l_to_r_flipped\
    \ = false;\n    bool r_to_l_flipped = false;\n    bool collision_happened = false;\n\
    \    long t = 0;", "{\n    static assert(n > 0, \"0 or negative cars is undefined\"\
    );\n    long res;\n    long a[];\n    a.length = n;\n    for (int i = 0; i < n;\
    \ i++)\n    {\n        a[i] = uniform(0,n);\n    }\n    std.algorithm.sort(a);\n\
    \    res = 0;\n    for (int i = 0; i < n; i++)\n    {\n        res += abs(a[i]\
    \ - i);\n    }\n    return res;\n}", "{\n    return (n * (n - 1)) / 2;\n}", "{\n\
    \    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j\
    \ = i+1; j < n; j++) {\n            long diff = j - i;\n            count += 1\
    \ + (diff - 1) * diff / 2;\n        }\n    }\n    return count;\n}", "{\n    long\
    \ left[n];\n    long right[n];\n    long i = 0, coll = 0;\n    foreach(item; left)\
    \ item = uniform(0, 1000000);\n    foreach(item; right) item = uniform(0, 1000000);\n\
    \    left = sort(left);\n    right = sort(right);\n    while(i < n) \n    {\n\
    \        if(left[i] > right[i]) \n        {\n            i++;\n            coll++;\n\
    \        }\n        else i++;\n    }\n    return coll;\n}", "{\n  long v1[], v2[];\n\
    \  foreach(i; 0 .. n)\n  {\n    v1[i] = uniform(0.0, 3.0);\n    v2[i] = uniform(0.0,\
    \ 3.0);\n  }\n  sort(v1);\n  sort(v2);\n  long result = 0;\n  foreach(i; 0 ..\
    \ n)\n  {\n    if (v1[i] <= v2[i]) {\n      result += (n - i);\n    }\n  }\n \
    \ return result;\n}", "{\n    n = n + 1;\n    return (n*(n+1))/2;\n}", "{\n  return\
    \ (n-1)*n/2;\n}", "{\n    if (n <= 0)\n        return 0;\n    \n    return n *\
    \ (n - 1) / 2;\n}", "{ \n    return 2*n-1;\n} \n ", "{\n    return 0;\n}", "{\n\
    \    /*\n        Given the coordinates of each car moving left to right, as well\
    \ as a list of the speeds \n        each such car is driving at, as well as the\
    \ coordinates of each car moving right to left, \n        as well as a list of\
    \ the speeds each such car is driving at, output the number of collisions\n  \
    \      that take place among the n cars, given that the cars are infinitely strong\
    \ and sturdy\n        so they don't move out of their trajectories.", "{\n   \
    \ assert(n>=1);\n    return (n*(n-1))/2;\n}\n/*\n    This function determines\
    \ the number of people who will be saved by the lifeboats\n    at a ship that's\
    \ sinking.  In an emergency situation, lifeboats can only be \n    assigned to\
    \ people in a way that the total weight of people in a lifeboat is \n    smaller\
    \ than or equal to the maximum weight the lifeboat can support.  However, \n \
    \   lifeboats should be assigned to people in a way that minimizes the number\
    \ of\n    people who will not be assigned to a lifeboat.  This function calculates\
    \ that number.", "{\n    long ans = 0;\n    long index = 0;\n    while (index\
    \ < n) {\n        long k = n-index;\n        ans += k;\n        index++;\n   \
    \ }\n    return ans;\n}", "{\n    return ((n-1)*n)/2;\n}", "{\n    \n}", "{\n\
    \    n = n * n;\n    return n;\n}", "{\n  /*\n   if n = 8, then the left to right\
    \ cars are:  1,2,3,4,5,6,7,8\n   and the right to left cars are:             8,7,6,5,4,3,2,1\n\
    \   and the collisions are                     1,2,3,4,5,6,7,8\n  */\n  return\
    \ n;\n}", "{\n    if (n < 2) return 0;\n    long count = 0;\n    for (long i =\
    \ 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n        {\n   \
    \         if (i < j) count++;\n        }\n    }\n    return count;\n}\n/*\n  \
    \  The car_race_collision function above has an order of growth of \n    0(n2).",
  "{\n  /*\n      Your code here\n  */\n  return 1;\n}", "{\n    if (n == 0)\n   \
    \     return 0;\n    \n    if (n == 1)\n        return 1;\n    \n    long ret\
    \ = 0;\n    long next = 1;\n    for (long i = 1; i < n; i++) {\n        next =\
    \ next + i;\n        ret = ret + next;\n    }\n    return ret;\n}", "{\n\tauto\
    \ cars = [];\n\tfor (; n > 0; n--)\n\t{\n\t\tcars ~= std.random.random(1, 1000);\n\
    \t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < cars.length; i++)\n\t{\n\t\tfor\
    \ (int j = 0; j < cars.length; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\
    \tres += abs(cars[i] - cars[j]) <= 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}",
  "{\n    long result = 0;\n    /*\n      Once you have a working solution, you can\
    \ compare the time taken\n      by your program against the time taken by solutions\
    \ written by\n      other students.  To do this, change the value 'true' to 'false'.\n\
    \      As you work on the assignment, you should change the value back\n     \
    \ to 'true' and re-run the program frequently.  If you change the\n      value\
    \ to 'false' and run the program, it will run indefinitely\n      and not exit.\n\
    \    */\n    if (true) {\n        int i = 0;\n        int j = 0;\n        while\
    \ (i < n && j < n)\n        {\n            float xi = float(i) / float(n);\n \
    \           float xj = float(j) / float(n);\n            if (xi > xj)\n      \
    \      {\n                ++j;\n            }\n            else if (xi < xj)\n\
    \            {\n                ++i;\n            }\n            else\n      \
    \      {\n                ++result;\n                ++i;\n                ++j;\n\
    \            }\n        }\n    }\n    else\n    {\n        // This loop is intentionally\
    \ not very efficient\n        for (int i = 0; i < n; ++i)\n        {\n       \
    \     for (int j = 0; j < n; ++j)\n            {\n                float xi = float(i)\
    \ / float(n);\n                float xj = float(j) / float(n);\n             \
    \   if (xi == xj)\n                {\n                    ++result;\n        \
    \        }\n            }\n        }\n    }\n    return result;\n}", "{\n\tif\
    \ (n < 1) \n\t\treturn 0;\n\tlong max = 1;\n\tlong min = max * 2;\n\tlong count\
    \ = 0;\n\tlong temp;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\ttemp = max;\n\
    \t\tmax = min;\n\t\tmin = temp * 2 + 1;\n\t\tcount += min;\n\t}\n\treturn count;\n\
    }", "{\n\tlong i, j, k;\n\tlong count = 0;\n\tlong[] x = new long[n];\n\tlong[]\
    \ y = new long[n];\n\t\n\tfor (i = 0; i < n; i = i + 1) {\n\t\tj = (long)random(n)\
    \ + 1;\n\t\tfor (k = 0; k < i; k = k + 1) {\n\t\t\tif (x[k] == j) {\n\t\t\t\t\
    i = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (k == i) {\n\t\t\tx[i] = j;\n\
    \t\t}\n\t}\n\t\n\tfor (i = 0; i < n; i = i + 1) {\n\t\tj = (long)random(n) + 1;\n\
    \t\tfor (k = 0; k < i; k = k + 1) {\n\t\t\tif (y[k] == j) {\n\t\t\t\ti = i - 1;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (k == i) {\n\t\t\ty[i] = j;\n\t\t}\n\t\
    }\n\t\n\tfor (i = 0; i < n; i = i + 1) {\n\t\tfor (j = 0; j < n; j = j + 1) {\n\
    \t\t\tif (x[i] == y[j]) {\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t}\n\t}\n\t\
    \n\treturn count;\n}", "{\n    long result = 0;\n    long[] left = new long[n];\n\
    \    long[] right = new long[n];\n    foreach (i; 0 .. n) {\n        left[i] =\
    \ i + 1;\n        right[i] = n - i;\n    }\n    foreach (i; 0 .. n) {\n      \
    \  foreach (j; 0 .. n) {\n            if (left[i] == right[j]) {\n           \
    \     ++result;\n            }\n        }\n    }\n    return result;\n}", "{ \n\
    \    double i;\n    long collision = 0;\n    for (i = 0; i < n; i = i + 1) {\n\
    \        if ((i+1) <= n) {\n            collision = collision + 1;\n        }\n\
    \    }\n    return collision;\n}", "{\n    return n * (n - 1);\n}", "{\n    //\
    \ start to write your code here\n    long cnt = 0;\n    for (long i = 0; i < n;\
    \ i++)\n    {\n        for (long j = i + 1; j < n; j++)\n        {\n         \
    \   if (fabs(i - j) == n - 1)\n            {\n                cnt++;\n       \
    \     }\n        }\n    }\n    return cnt;\n}", "{\n    long x = 0;\n    return\
    \ x;\n}", "{\n    long i, j, result = 0;\n    long x[n], v[n];\n    float time;\n\
    \    for (i = 0; i < n; i++) {\n        x[i] = (n - i - 1) * 2;\n        v[i]\
    \ = 1;\n    }\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++)\
    \ {\n            if (v[i] > 0 && v[j] < 0) {\n                if (x[i] < x[j])\
    \ {\n                    time = -(x[i] - x[j]) / (v[i] - v[j]);\n            \
    \        if (time > 0 && time < 1) {\n                        result++;\n    \
    \                }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n  long coll = 0;\n  // find collisions\n  for (long i = 0;\
    \ i < n; i++)\n    for (long j = i+1; j < n; j++)\n      if (abs(i-j) == abs(n+1-i-j))\
    \ coll++;\n  return coll;\n}\n/*\n    There are n + 1 dots on a long straight\
    \ line.  The first n dots are\n    labeled 0 through n-1, and the n-th dot is\
    \ labeled n.\n    A domino is a rectangle.  Its sides are parallel to the line,\n\
    \    and its sides have the same length.\n    Each domino is positioned such that\
    \ it covers two consecutive dots, i.e.,\n    the domino's right side is on dot\
    \ i and its left side is on dot i+1 for some i.\n    Each domino covers exactly\
    \ two dots.  The length of the domino is the distance\n    between the two dots\
    \ it covers.  Two dominos are considered to be different\n    if they are not\
    \ in the same position or the same orientation.\n    The dominos are not allowed\
    \ to overlap;  that is, if a dot is covered by\n    domino i, it cannot be covered\
    \ by domino j for i != j.", "{\n    // Your code here\n    long res = 0;\n   \
    \ for (long i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n; j++)\n\
    \        {\n            if (i < j)\n            {\n                res++;\n  \
    \          }\n        }\n    }\n    return res;\n}", "{\n    // the total number\
    \ of the collisions\n    long output = 0;\n    int[] left_to_right = new int[n];\
    \ // the positions of the cars from left to right\n    int[] right_to_left = new\
    \ int[n]; // the positions of the cars from right to left\n    int[] delta = new\
    \ int[n]; // the difference between the positions of the cars in the same index\
    \ \n    int num = 0; // the number of the cars that have not collided\n    int\
    \ pos = 0; // the index of the target car\n    int prev_pos = 0; // the index\
    \ of the car to compare with\n    for (int i = 0; i < n; i++) \n    {\n      \
    \  // randomly generate the positions of the cars from left to right\n       \
    \ left_to_right[i] = rand() % 10000;\n        // randomly generate the positions\
    \ of the cars from right to left\n        right_to_left[i] = rand() % 10000;\n\
    \        // initialize the delta array\n        delta[i] = left_to_right[i] -\
    \ right_to_left[i];\n    }\n    // sort the cars in the order of their positions\n\
    \    delta = delta.sort();\n    // while there are cars that haven't collided\n\
    \    while (num < n) \n    {\n        // find the car in the delta array whose\
    \ difference is negative\n        for (int i = 0; i < n; i++) \n        {\n  \
    \          if (delta[i] < 0) \n            {\n                pos = i;\n     \
    \           break;\n            }\n        }\n        // if no car has collided\n\
    \        if (pos == 0) \n        {\n            // we are done\n            break;\n\
    \        }\n        // find the car in the delta array that has the smallest difference\
    \ with the target car\n        // this will be the car that will collide with\
    \ the target car\n        for (int i = pos - 1; i >= 0; i--) \n        {\n   \
    \         if (delta[i] == delta[pos]) \n            {\n                prev_pos\
    \ = i;\n                break;\n            }\n        }\n        // add 1 to\
    \ the total number of collisions\n        output += (pos - prev_pos);\n       ",
  "{\n    // This can be computed using geometry.  \n    // The result is n*(n-1)\n\
    \    // We are not interested in the formula.\n    // We are only interested in\
    \ experimenting with the number of collisions\n    // as the number of cars grows.\n\
    \    return n*(n-1);\n}", "{\n    long x[],y[]; \n    long i,j,k;\n    long count=0;",
  "{\n  long x;", "{\n    return (long) ceil(n/2.0);\n}", "{\n    long arr1[], arr2[];\n\
    \    int i, j;\n    bool flag;\n    float left, right;\n    for (i = 0; i < n;\
    \ i++)\n    {\n        arr1[i] = i + 1;\n        arr2[i] = -i - 1;\n    }\n  \
    \  for (i = 0; i < n; i++)\n    {\n        if (arr1[i] < 0)\n            left\
    \ = -arr1[i];\n        else\n            left = arr1[i];\n        if (arr2[i]\
    \ < 0)\n            right = -arr2[i];\n        else\n            right = arr2[i];\n\
    \        if (left == right)\n        {\n            flag = true;\n           \
    \ break;\n        }\n    }\n    if (flag)\n        return arr1[i];\n    else\n\
    \        return 0;\n}", "{\n    long counter = 0;\n    float[] a = new float[];\n\
    \    float[] b = new float[];\n    for (size_t i = 0; i < n; i++) \n    {\n  \
    \      a[i] = cos(0.0001 * uniform(0, 1, 1));\n        b[i] = cos(0.0001 * uniform(0,\
    \ 1, 1));\n    }\n    for (size_t i = 0; i < n; i++) \n    {\n        for (size_t\
    \ j = 0; j < n; j++) \n        {\n            if (a[i] - b[j] < 0.0001) \n   \
    \         {\n                counter++;\n            }\n        }\n    }\n   \
    \ return counter;\n}\n/*\n    Imagine you have n jars of jelly beans.  Each jar\
    \ has a differing number of jelly beans.\n    You do not know what the distribution\
    \ is.  You take a random sample of k jelly beans\n    (out of the n jars) and\
    \ you count how many there are.  This is repeated m times.\n    The function outputs\
    \ the average number of jelly beans per jar.\n*/\nfloat average_jelly_beans(long\
    \ n, long k, long m) \n{\n    long sum = 0;\n    for (size_t i = 0; i < m; i++)\
    \ \n    {\n        long[] a = new long[];\n        for (size_t j = 0; j < n; j++)\
    \ \n        {\n            a[j] = uniform(0, 10000000, 1);\n        }\n      \
    \  for (size_t j = 0; j < k; j++) \n        {\n            sum += a[uniform(0,\
    \ n, 1)];\n        }\n    }\n    return sum / m;\n}\n/*\n    You have a set of\
    \ n coins and an integer k.  This function outputs the number of\n    ways that\
    \ you can arrange the coins in k rows such that every row has the same\n    number\
    \ of coins.\n*/\nlong coin_row_permutation(long n, long k) \n{\n    if (n < k)\
    \ \n    {\n        return 0;\n    }\n    if (n == k) ", "{\n    long count = 0;\n\
    \    long i, j;\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < n;\
    \ j++)\n        {\n            count += 1;\n        }\n    }\n    return count;\n\
    }", "{\n    long sum = 0;\n    auto ind = sequence!long(0, n);\n    foreach(i,\
    \ ref a; ind) {\n        foreach(j, ref b; ind) {\n            if(a < b) \n  \
    \              sum += n - a;\n            else \n                sum += n - b;\n\
    \        }\n    }\n    return sum;\n}", "{\n    long count = 0;\n    for (long\
    \ i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if\
    \ (i < j) {\n                count++;\n            }\n        }\n    }\n    return\
    \ count;\n}", "{\n    \n    /*@\n    loop invariant 0 <= i <= n;\n    loop invariant\
    \ 0 <= j <= n;\n    loop invariant i*j == (i*(i-1))/2 + (j*(j-1))/2;\n    loop\
    \ assigns i, j;\n    loop variant n - i;\n    */\n    for (long i = 1; i <= n;\
    \ i++)\n    {\n        for (long j = 1; j <= n; j++)\n        {\n            if\
    \ (i > j)\n            {\n                i = i + j;\n                j = i -\
    \ j;\n                i = i - j;\n            }\n        }\n    }\n    return\
    \ (n*(n-1))/2;\n}", "{\n    /*\n        a[i] = the position of the ith left-to-right\
    \ moving car\n        b[i] = the position of the ith right-to-left moving car\n\
    \        We want to know how many collisions will happen. \n        Two cars collide\
    \ if and only if a[i] > b[j] and i < j.\n        We can sort both arrays, and\
    \ this is a solution to the problem.\n    */\n    long[] a = new long[n];\n  \
    \  long[] b = new long[n];\n    long r = 0;\n    foreach (i; 0 .. n) {\n     \
    \   a[i] = to!long(random(float.max)) * (random(2) ? 1 : -1);\n        b[i] =\
    \ to!long(random(float.max)) * (random(2) ? 1 : -1);\n    }\n    std.algorithm.sort(a);\n\
    \    std.algorithm.sort(b);\n    auto const max = a.length;\n    foreach (i; 0\
    \ .. max) {\n        foreach (j; 0 .. max) {\n            if (a[i] > b[j] && i\
    \ < j) {\n                r += 1;\n            }\n        }\n    }\n    return\
    \ r;\n}\n/*\n    For example, if a[i] = 1 and b[j] = -1, then car 1 and car -1\
    \ have collided.\n    However, since there is no car number -1, this collision\
    \ doesn't count.\n    If a[i] = -1 and b[j] = -1, then car -1 and car -1 have\
    \ collided;\n    however, there is no such car, so this collision doesn't count.\n\
    \    If a[i] = 1 and b[j] = 0, then car 1 and car 0 have collided.\n    Since\
    \ we are assuming that there are infinitely many cars, car 0 must exist.\n   \
    \ Therefore, this collision counts.\n*/", "{\n    long i,j,k;\n    real x[];",
  "{\n\tlong collisions = 0;\n\tlong[] pos = new long[n];\n\tfor (long i = 0; i <\
    \ n; i++) \n\t{\n\t\tpos[i] = i;\n\t}\n\t\n\tforeach (i; 0 .. n) \n\t{\n\t\tforeach\
    \ (j; 0 .. n) \n\t\t{\n\t\t\tif (pos[i] > pos[j]) \n\t\t\t{\n\t\t\t\tcollisions++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn collisions;\n}", "{\n    long first_starting_positions_right\
    \ = n*(n+1)/2;\n    long first_starting_positions_left = -first_starting_positions_right;\n\
    \    long second_starting_positions_right = -first_starting_positions_left;\n\
    \    long second_starting_positions_left = -second_starting_positions_right;\n\
    \    long num_collisions = 0;\n    for (long i = first_starting_positions_right;\
    \ i > second_starting_positions_left; i--) {\n        num_collisions += i*(i-1)/2;\n\
    \    }\n    for (long i = second_starting_positions_left; i > first_starting_positions_right;\
    \ i--) {\n        num_collisions += i*(i-1)/2;\n    }\n    return num_collisions;\n\
    }\n \n/*\n    You are given a function that takes a string and returns a vector\
    \ of\n    strings (the way words in the input string are partitioned);\n    the\
    \ vector of strings is sorted in the alphabetical order;\n    here are some examples\
    \ of how the string is partitioned:\n    \"uusnus\" -> [\"u\", \"us\", \"nus\"\
    , \"u\", \"s\"]\n    \"1020\" -> [\"10\", \"20\"]\n    \"10\" -> [\"10\"]\n  \
    \  \"\" -> []\n    \n    This function outputs the original string.  If the original\
    \ string\n    cannot be uniquely recovered from the input vector of strings,\n\
    \    the function outputs the empty string.\n*/\nstring to_string(std::vector<string>\
    \ words) \n{\n    string result = \"\";\n    long i = 0;\n    while (i < words.size())\
    \ {\n        result += words[i];\n        while (i < words.size() && words[i].size()\
    \ < result.size()) {\n            ++i;\n        }\n        if (i < words.size()\
    \ && words[i].size() == result.size()) {\n            ++i;\n        }\n    }\n\
    \    return result;\n}\n \n/*\n    Given an array of integers, the function finds\
    \ the maximum number of\n    consecutive integers that are the", "{\n    return\
    \ 0;\n}\n/*\n    Given an array of integers, find the most frequent integer in\
    \ it.  If there are\n    multiple integers that are frequent, return the smallest\
    \ one.\n    \n    This function outputs two values: the most frequent integer\
    \ and its number of occurences.\n*/\nlong find_most_frequent(long* a, long n)\n\
    {\n    return 0;\n}\n/*\n    Given an integer n>0, find the largest positive integer\
    \ m whose square is less than or equal to n.\n    This function outputs two values:\
    \ the largest integer m and its squared value.\n*/\nlong largest_square(long n)\n\
    {\n    return 0;\n}\n/*\n    This function outputs the cost of a given algorithm\
    \ when the input size is a number.\n    The cost of an algorithm is the amount\
    \ of computation it does.  For example,\n    when the input size is 1, the cost\
    \ is 1; when the input size is 2, the cost is 2;\n    when the input size is 3,\
    \ the cost is 3; etc.\n*/\nlong cost(long n)\n{\n    return 0;\n}\n/*\n    This\
    \ function outputs the first integer in a sequence of n numbers that is less than\
    \ or equal to a given number m.\n    For example, if n=3 and m=2, then the function\
    \ outputs 1.\n*/\nlong find_first_less_than_or_equal(long n, long m)\n{\n    return\
    \ 0;\n}\n/*\n    This function outputs the largest integer in a sequence of n\
    \ numbers that is less than or equal to a given number m.\n    For example, if\
    \ n=3 and m=2, then the function outputs 2.\n*/\nlong find_last_less_than_or_equal(long\
    \ n, long m)\n{\n    return 0;\n}\n/*\n    This function outputs the number of\
    \ distinct values in a sequence of n numbers.\n    For example, if n=3 and the\
    \ sequence is 1, 2, 1, then the function outputs 2.\n*/\nlong count_distinct(long\
    \ n)\n{\n    return 0;\n}\n/*\n    This function outputs the product of the values\
    \ in a sequence of n numbers.\n    For example, if n=3 and the sequence is", "{\n\
    \    auto x = new int[n];\n    auto y = new int[n];\n    foreach (i; 0 .. n)\n\
    \    {\n        x[i] = uniform(1L, 1000000000L);\n        y[i] = uniform(1L, 1000000000L);\n\
    \    }\n    auto collisions = 0L;\n    auto j = 0L;\n    foreach (i; 0 .. n)\n\
    \    {\n        while (y[j] < x[i])\n        {\n            j++;\n        }\n\
    \        collisions += j;\n    }\n    return collisions;\n}", "{\n    long i =\
    \ 0;\n    while (i < n) {\n        long j = 0;\n        while (j < n) {\n    \
    \        if (abs(i - j) < n) {\n                __VERIFIER_assert(0);\n      \
    \      }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n    return\
    \ 0;\n}", "{\n    long num_of_collisions = 0;\n    num_of_collisions = sqrt(2*n);\n\
    \    return num_of_collisions;\n}", "{\n    /* writedown here */\n}", "{\n   \
    \ //     The position of the first n cars driving left to right\n    long a[n];\n\
    \    //     The position of the second n cars driving right to left\n    long\
    \ b[n];\n    //     Read the data\n    for (long i = 0; i < n; i++) {\n      \
    \  scanf(\"%ld %ld\", &a[i], &b[i]);\n    }\n    //     Sort the cars driving\
    \ left to right\n    sort(a);\n    //     Sort the cars driving right to left\n\
    \    sort(b);\n    //     The number of collisions that occur\n    long collision\
    \ = 0;\n    //     The two pointers that point to the current cars being compared\n\
    \    long a_pointer = 0;\n    long b_pointer = 0;\n    //     Compare the cars\
    \ and count the number of collisions\n    while (a_pointer < n && b_pointer <\
    \ n) {\n        if (a[a_pointer] <= b[b_pointer]) {\n            collision +=\
    \ a_pointer;\n            a_pointer++;\n        } else {\n            b_pointer++;\n\
    \        }\n    }\n    //     Return the result\n    return collision;\n}", "{\n\
    \    // Only one car on the road, no collision.\n    if (n < 2)\n        return\
    \ 0;\n    \n    long no_of_collisions = (n * (n - 1)) / 2;\n    return no_of_collisions;\n\
    }", "{\n    long[] left_to_right;\n    long[] right_to_left;\n    long num_of_collisions\
    \ = 0;\n    left_to_right.length = n;\n    right_to_left.length = n;\n    for\
    \ (long i = 0; i < n; i++) \n    {\n        left_to_right[i] = i + 1;\n      \
    \  right_to_left[i] = n - i;\n    }\n    while (left_to_right.length > 0 && right_to_left.length\
    \ > 0) \n    {\n        if (left_to_right[0] == right_to_left[0]) \n        {\n\
    \            num_of_collisions += 1;\n            left_to_right.remove(0);\n \
    \           right_to_left.remove(0);\n        }\n        else if (left_to_right[0]\
    \ < right_to_left[0]) \n        {\n            left_to_right.remove(0);\n    \
    \    }\n        else \n        {\n            right_to_left.remove(0);\n     \
    \   }\n    }\n    return num_of_collisions;\n}", "{\n    return (n * (n-1)) /\
    \ 2;\n}\n ", "{\n  long[] a = new long[n];\n  long[] b = new long[n];\n  long[][]\
    \ sorted = new long[2][n];\n  for (long i = 0; i < n; i++) \n  {\n    a[i] = cast(long)\
    \ round(random * n);\n    b[i] = cast(long) round(random * n);\n  }\n  sorted[0]\
    \ = a.dup.sort;\n  sorted[1] = b.dup.sort;\n  long c = 0;\n  for (long i = 0;\
    \ i < n; i++) \n  {\n    auto index = sorted[0].dup.index(a[i]);\n    if (index\
    \ == i) \n    {\n      c += sorted[1].dup.index(b[i]);\n    }\n    else \n   \
    \ {\n      c += n - 1 - sorted[1].dup.index(b[i]);\n    }\n  }\n  return c;\n}",
  "{\n    // The function implements the idea that\n    // the car at index n is the\
    \ first and the last car to collide.\n    // For example, if n is 12, then we\
    \ know that the car at index 12 is the\n    // first car to collide and the car\
    \ at index 12 is the last car to collide.\n    // The first car to collide will\
    \ necessarily collide with the first car\n    // that moves right to left.\n \
    \   // For example, if n is 12, the car at index 12 will collide with\n    //\
    \ the car at index -12.\n    // Similarly, the last car to collide will necessarily\
    \ collide with the last\n    // car that moves right to left.\n    // For example,\
    \ if n is 12, the car at index 12 will collide with\n    // the car at index -12.\n\
    \    //\n    // As a result, this function will first iterate through the cars\
    \ that move\n    // left to right and find the car at index n.  It will then iterate\n\
    \    // through the cars that move right to left and find the car at index -n.\n\
    \    // It will repeat this process for the cars at index n-1, n-2, n-3, ...,\
    \ 1.\n    //\n    // For example, consider the following situation\n    // Car\
    \ Index:                                 0    1   2   3   4   5   6\n    //  \
    \                                          7    8   9   10  11  12  13\n    //\
    \                                            14   15  16  17  18  19  20\n   \
    \ //                                            21   22  23  24  25  26  27\n\
    \    //                                            28   29  30  31  32  33  34\n\
    \    //                                            35   36  37  38  39  40  41\n\
    \    //                                            42   43  44  45  46  47  48\n\
    \    //                                            49   50  51  52  53  54  55\n\
    \    //                                            56   57  58  59  60  61  62\n\
    \    //                                            63   64  65  66  67  68  69\n\
    \    //                                            70   71  72  73  74  75  76\n\
    \    //                                            77   78  79  80  81  82  83",
  "{ \n    double tmp = sqrt(2.0);\n    return (long)(n * (n - 1) / tmp);\n}", "{\n\
    \    // {{{\n    //    version 1\n    //long k=0;\n    //long j=0;\n    //\n \
    \   //while (k<n) {\n    //    j=0;\n    //    while (j<n) {\n    //        if\
    \ ((k>j)&&(k-j)<n) {\n    //            n--;\n    //        }\n    //        else\
    \ if ((k<j)&&(j-k)<n) {\n    //            n--;\n    //        }\n    //     \
    \   j++;\n    //    }\n    //    k++;\n    //}\n    //return n;\n    // }}}\n\
    \    // {{{\n    //    version 2\n    //    this version is better than the previous\
    \ one, because it uses fewer looping variables.\n    //long i=0;\n    //long j=0;\n\
    \    //\n    //while (i<n) {\n    //    j=0;\n    //    while (j<n) {\n    //\
    \        if (abs(i-j)<n) {\n    //            n--;\n    //        }\n    //  \
    \      j++;\n    //    }\n    //    i++;\n    //}\n    //return n;\n    // }}}\n\
    \    // {{{\n    //    version 3\n    //    this version is better than the previous\
    \ one, because it uses a single loop.\n    //long i=0;\n    //long j=0;\n    //\n\
    \    //while (i<n) {\n    //    if (abs(i-j)<n) {\n    //        n--;\n    //\
    \    }\n    //    j++;\n    //    if (j==n) {\n    //        i++;\n    //    \
    \    j=0;\n    //    }\n    //}\n    //return n;\n    // }}}\n    // {{{\n   \
    \ //    version 4\n    //    this version is better than the previous one, because\
    \ it calculates the answer directly.\n    //    n cars moving left to right is\
    \ equivalent to n cars moving right to left;\n    //    the collisions between\
    \ these cars is the same as the collisions of 2 cars moving\n    //    left",
  "{\n    if (n == 0) \n    {\n        return 0;\n    }\n    if (n == 1) \n    {\n\
    \        return 1;\n    }\n    return (n * (n - 1)) / 2;\n}", "{\n    long collisions\
    \ = 0;\n    long i, j;\n    long car_pos[n];\n    long car_pos_opp[n];\n    for\
    \ (i = 0; i < n; i++) {\n        car_pos[i] = i;\n        car_pos_opp[i] = -i;\n\
    \    }\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n   \
    \         if (car_pos[i] == car_pos_opp[j]) {\n                collisions++;\n\
    \            }\n        }\n    }\n    return collisions;\n}", "{\n    long result\
    \ = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n;\
    \ j++) {\n            if (i < j) {\n                result += 1;\n           \
    \ }\n        }\n    }\n    return result;\n}", "{\n    return n * (n - 1);\n}",
  "{ \n    if (n == 0 || n == 1) \n        return 0; \n  \n    long result = 0; \n\
    \    long arr_left[n], arr_right[n]; \n    long i, j; \n  \n    for (i = 0; i\
    \ < n; i++) \n        arr_left[i] = i + 1; \n  \n    for (i = 0; i < n; i++) \n\
    \        arr_right[i] = n - i; \n  \n    for (i = 0; i < n; i++) \n        for\
    \ (j = 0; j < n; j++) \n            if (arr_left[i] == arr_right[j]) \n      \
    \          result++; \n  \n    return result; \n} ", "{\n    n = n+1;\n    return\
    \ (n*(n-1))/2;\n}", "{\n    long result = 0;\n    foreach (immutable i; 0 .. n)\n\
    \    {\n        foreach (immutable j; i+1 .. n)\n        {\n            result\
    \ += 1;\n        }\n    }\n    return result;\n}", "{\n    long i;\n    long j;\n\
    \    long collision_count;\n    collision_count = 0;\n    for (i = 0; i < n; i++)\
    \ {\n        for (j = 0; j < n; j++) {\n            if (i > j) {\n           \
    \     collision_count = collision_count + 1;\n            }\n        }\n    }\n\
    \    return collision_count;\n}\nlong main(void) \n{\n    printf(\"%ld\\n\", car_race_collision(2));\n\
    \    printf(\"%ld\\n\", car_race_collision(1));\n    printf(\"%ld\\n\", car_race_collision(0));\n\
    \    printf(\"%ld\\n\", car_race_collision(3));\n    printf(\"%ld\\n\", car_race_collision(10));\n\
    \    printf(\"%ld\\n\", car_race_collision(100));\n    printf(\"%ld\\n\", car_race_collision(1000));\n\
    \    printf(\"%ld\\n\", car_race_collision(10000));\n    printf(\"%ld\\n\", car_race_collision(4));\n\
    \    printf(\"%ld\\n\", car_race_collision(20));\n    printf(\"%ld\\n\", car_race_collision(100));\n\
    \    printf(\"%ld\\n\", car_race_collision(1000));\n    printf(\"%ld\\n\", car_race_collision(2000));\n\
    \    printf(\"%ld\\n\", car_race_collision(3000));\n    printf(\"%ld\\n\", car_race_collision(4000));\n\
    \    printf(\"%ld\\n\", car_race_collision(5000));\n    printf(\"%ld\\n\", car_race_collision(6000));\n\
    \    printf(\"%ld\\n\", car_race_collision(7000));\n    printf(\"%ld\\n\", car_race_collision(8000));\n\
    \    printf(\"%ld\\n\", car_race_collision(9000));\n    printf(\"%ld\\n\", car_race_collision(10000));\n\
    \    printf(\"%ld\\n\", car_race_collision(10000));\n    printf(\"%ld\\n\",",
  "{\n    long n_col = 1;\n    long* cur_max = new long[n];\n    std.fill(cur_max,\
    \ 0, n, 0);\n    long* next_max = new long[n];\n    std.fill(next_max, 0, n, 0);\n\
    \    long* cur_avg = new long[n];\n    std.fill(cur_avg, 0, n, 0);\n    long*\
    \ next_avg = new long[n];\n    std.fill(next_avg, 0, n, 0);\n    for (long i =\
    \ 0; i < n; i++) \n    {\n        for (long j = 0; j < n; j++) \n        {\n \
    \           if (next_max[j] < cur_max[i] + 1) \n            {\n              \
    \  next_max[j] = cur_max[i] + 1;\n                next_avg[j] = cur_avg[i] + i\
    \ + 1;\n            }\n            else if (next_max[j] == cur_max[i] + 1) \n\
    \            {\n                next_avg[j] = min(next_avg[j], cur_avg[i] + i\
    \ + 1);\n            }\n        }\n        n_col += next_max[i];\n        std.swap(cur_max,\
    \ next_max);\n        std.swap(cur_avg, next_avg);\n        std.fill(next_max,\
    \ 0, n, 0);\n        std.fill(next_avg, 0, n, 0);\n    }\n    return n_col;\n\
    }\n \n/*\n    Now, imagine the road becomes a circle of diameter d.\n    The cars\
    \ that drive left to right now drive counterclockwise;\n    the cars that drive\
    \ right to left now drive clockwise.\n    Each car is 1 unit long and moves 1\
    \ unit per second.", "{\n    long[] left_to_right_car_position = new long[n];\n\
    \    long[] right_to_left_car_position = new long[n];\n    for (long i = 0; i\
    \ < n; i++) \n    {\n        left_to_right_car_position[i] = i + 1;\n        right_to_left_car_position[i]\
    \ = 1000000000 - i;\n    }\n    long left_to_right_car_min_position = min(left_to_right_car_position);\n\
    \    long right_to_left_car_max_position = max(right_to_left_car_position);\n\
    \    long time = 0;\n    long collision_number = 0;\n    while (left_to_right_car_min_position\
    \ < right_to_left_car_max_position) \n    {\n        for (long i = 0; i < n; i++)\
    \ \n        {\n            left_to_right_car_position[i] += (time + 1);\n    \
    \        right_to_left_car_position[i] -= (time + 1);\n        }\n        left_to_right_car_min_position\
    \ = min(left_to_right_car_position);\n        right_to_left_car_max_position =\
    \ max(right_to_left_car_position);\n        collision_number += n;\n        time++;\n\
    \    }\n    return collision_number;\n}", "{\n    return n * (n - 1);\n}", "{\n\
    \tlong i = 1;\n\tlong collision = 0;\n\twhile (i <= n)\n\t{\n\t\tcollision +=\
    \ i;\n\t\ti++;\n\t}\n\treturn collision;\n}", "{\n    long c = 0;\n    for (long\
    \ i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if\
    \ (i >= j) {\n                continue;\n            }\n            double t1\
    \ = double(j)/n;\n            double t2 = double(i)/n;\n            double d =\
    \ abs(t1 - t2);\n            if (d < 0.5) {\n                c += 1;\n       \
    \     }\n        }\n    }\n    return c;\n}", "{\n  //  You've been given an array\
    \ of n numbers. Each number represents a car's starting\n  //  point.  The car\
    \ starts out driving left to right.  So, if the array is [1, 5, 9],\n  //  car\
    \ 0 starts at position 1, car 1 starts at position 5, and car 2 starts at position\
    \ 9.\n  //  This function computes the number of collisions.", "{\n  //@ assert\
    \ n>=0;\n  long c=0;\n  while(n--)\n  {\n    c += n;\n  }\n  return c;\n}", "{\n\
    \    long collissions = 0;\n    long* leftToRightPositions = new long[n];\n  \
    \  long* rightToLeftPositions = new long[n];\n    for (long i = 0; i < n; i++)\n\
    \    {\n        leftToRightPositions[i] = i;\n        rightToLeftPositions[i]\
    \ = -(i + 1);\n    }\n    long rightToLeftIndex = 0;\n    long leftToRightIndex\
    \ = 0;\n    while(rightToLeftIndex < n && leftToRightIndex < n)\n    {\n     \
    \   if(leftToRightPositions[leftToRightIndex] > rightToLeftPositions[rightToLeftIndex])\n\
    \        {\n            collissions++;\n            rightToLeftIndex++;\n    \
    \    }\n        else\n        {\n            leftToRightIndex++;\n        }\n\
    \    }\n    return collissions;\n}", "{\n    long *[] result;\n    result = malloc(2\
    \ * n * sizeof(long *));", "{\n    int i = 0;\n    int j = 0;\n    long result\
    \ = 0;\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n   \
    \         if (i <= j) {\n                result++;\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    long result = 0;\n    foreach (i; 0 ..\
    \ n)\n    {\n        result += i * (n - i);\n    }\n    return result;\n}", "{\n\
    \    long collisions = 0;\n    double[] A = new double[n];\n    double[] B = new\
    \ double[n];\n    double[] C = new double[n];\n    double[] D = new double[n];\n\
    \    foreach (i, ref a; A) {\n        a = i;\n    }\n    foreach (i, ref a; B)\
    \ {\n        a = i;\n    }\n    foreach (i, ref a; C) {\n        a = i;\n    }\n\
    \    foreach (i, ref a; D) {\n        a = i;\n    }\n    //The speed of each car\
    \ is the same\n    double v = 10;\n    foreach (i, ref a; A) {\n        //speed\
    \ for A is positive\n        a += v;\n    }\n    foreach (i, ref a; B) {\n   \
    \     //speed for B is negative\n        a -= v;\n    }\n    //these are the time\
    \ intervals\n    foreach (i, ref a; C) {\n        //the equation is x = v * t,\
    \ where t is the time interval\n        a = abs(a);\n    }\n    foreach (i, ref\
    \ a; D) {\n        //the equation is x = v * t, where t is the time interval\n\
    \        a = abs(a);\n    }\n    //This is the location of the cars\n    foreach\
    \ (i, ref a; A) {\n        a += C[i];\n    }\n    foreach (i, ref a; B) {\n  \
    \      a += D[i];\n    }\n    //This is the collision\n    foreach (i, j; A) {\n\
    \        if (abs(A[i] - B[j]) <= 1) {\n            collisions++;\n        }\n\
    \    }\n    return collisions;\n}", "{\n    auto car_positions = new real[n];",
  "{\n    if (n <= 1) return 0;\n    long[] left(n);\n    long[] right(n);\n    for\
    \ (size_t i = 0; i < n; i++) \n    {\n        left[i] = n-i;\n        right[i]\
    \ = i+1;\n    }\n    sort(left);\n    sort(right);\n    long collisions = 0;\n\
    \    long left_index = 0;\n    long right_index = 0;\n    while (left_index <\
    \ n && right_index < n) \n    {\n        if (left[left_index] > right[right_index])\
    \ \n        {\n            collisions += (n - left_index);\n            right_index++;\n\
    \        } \n        else \n        {\n            left_index++;\n        }\n\
    \    }\n    return collisions;\n}", "{\n    return n;\n}", "{ \n    if (n == 0)\
    \ \n    {\n        return 0;\n    } \n    else \n    {\n        long r = rand;\n\
    \        return car_race_collision(n-1) + r;\n    }\n}", "{ \n    long count =\
    \ 0;\n    while (n) \n    {\n        count += n-1;\n        n--;\n    }\n    return\
    \ count;\n}", "{\n    assert(n >= 1);\n    return n * (n - 1) / 2;\n}", "{\n \
    \   return cast(long) trunc(n * (n - 1) / 2);\n}", "{\n    long count = 0;\n \
    \   while (n > 0) {\n        count += n - 1;\n        n -= 1;\n    }\n    return\
    \ count;\n}\n \n/*\n  Suppose you have a function f that takes n integers as input,\
    \ and outputs true or false.\n  You are given a list of n triples, (a,b,c).\n\
    \  You have to output the number of triples in the list that satisfy the following\
    \ condition:", "{\n    if (n <= 1)\n        return 0;\n    else if (n <= 3)\n\
    \        return n - 1;\n    else if (n % 2 == 0)\n        return n * (n - 2) /\
    \ 4;\n    else if (n % 4 == 1)\n        return (n - 1) * (n - 3) / 4;\n    else\n\
    \        return (n - 1) * (n - 3) / 4 + 1;\n}", "{\n    if (n == 0)\n        return\
    \ 0;\n    \n    long[] cars = new long[n];\n    long[] distances = new long[n];\n\
    \    long collisions = 0;\n    \n    /*\n    On a long road, there can be more\
    \ than one car at a point.  So, for each of the\n    positions on the road, we\
    \ need to maintain an array of indices that tell us the\n    index of the cars\
    \ that are at that position.  The cars array has n entries.\n    The ith entry\
    \ is the position of the ith car.\n    */\n    foreach (i; 0 .. n)\n    {\n  \
    \      cars[i] = 2 * i;\n    }\n    \n    /*\n    The distances array has n entries.\
    \  We will initialize it to contain\n    the distances between car pairs.  The\
    \ distance between car i and j is the\n    absolute value of the difference between\
    \ their initial positions.\n    */\n    foreach (i; 0 .. n)\n    {\n        foreach\
    \ (j; 0 .. n)\n        {\n            distances[i * n + j] = abs(cars[i] - cars[j]);\n\
    \        }\n    }\n    \n    /*\n    There are n^2 car pairs.  The distances array\
    \ has n^2 entries, and so does the\n    indices array.  Each ith entry of the\
    \ indices array is the index of the car pair\n    with the minimum initial distance.\n\
    \    */\n    long[] indices = new long[n * n];\n    foreach (i; 0 .. n * n)\n\
    \    {\n        indices[i] = i;\n    }\n    \n    /*\n    Sort the indices array.\
    \  We are sorting the distances.  As a result, we want to \n    sort the indices\
    \ array by the distances.  But we want to do this in increasing order\n    of\
    \ distances.  So, we need to construct a comparison function that tells us whether\n\
    \    two indices a and b should be swapped.  One of the indices may be the minimum,\
    \ the\n    other may not.  A is the index of a distance.  B is the index of another\
    \ distance.\n    If a < b, then the distance at index a is less than the distance\
    \ at index b.\n    If a", "{\n    long num_collisions = 0;\n    float[long] car_positions;\n\
    \    float[long] car_velocities;\n    foreach(i=0; i<n; i++) {\n        car_positions[i]\
    \ = 0;\n        car_velocities[i] = 1;\n    }\n    foreach(i=0; i<n; i++) {\n\
    \        car_positions[i] = 0;\n        car_velocities[i] = -1;\n    }\n    /*\n\
    \        Now, we have a set of cars all moving in the same direction,\n      \
    \  and a set of cars all moving in the other direction.\n        However, each\
    \ car is traveling at a different speed.\n    */\n    foreach(i=0; i<n; i++) {\n\
    \        foreach(j=0; j<n; j++) {\n            car_positions[i] += car_velocities[i];\n\
    \            car_positions[j] += car_velocities[j];\n            if( car_positions[i]\
    \ > car_positions[j] ) {\n                num_collisions++;\n            }\n \
    \       }\n    }\n    return num_collisions;\n}", "{\n    /*\n        PSEUDOCODE\n\
    \        This is a classic example of a problem that can be solved\n        by\
    \ a sweep line approach.", "{\n    if (n < 1) return 0;\n    return n*(n-1)/2;\n\
    }\n//Tests", "{\n    long result = 0;\n    long A[n];\n    long B[n];\n    srand(time(0));\n\
    \    foreach(i; 0 .. n) { \n        A[i] = (1 - 2 * (i % 2)) * (i + 1);\n    \
    \    B[i] = (1 - 2 * (i % 2)) * (i + 1);\n    }\n    long i = 0;\n    long j =\
    \ 0;\n    for(i = 0; i < n; i++) {\n        for(j = 0; j < n; j++) {\n       \
    \     if(A[i] * B[j] < 0) {\n                result++;\n            }\n      \
    \  }\n    }\n    return result;\n}", "{\n    return (n*(n-1))/2;\n}", "{\n   \
    \ long *right = new long[n];\n    long *left = new long[n];\n    long collisions\
    \ = 0;\n    for (long i = 0; i < n; i++) \n    {\n        right[i] = i;\n    \
    \    left[i] = n - i - 1;\n    }\n    for (long i = 0; i < n; i++) \n    {\n \
    \       for (long j = 0; j < n; j++) \n        {\n            if (right[i] ==\
    \ left[j]) \n            {\n                collisions++;\n            }\n   \
    \     }\n    }\n    return collisions;\n}", "{ \n    long result = 0;\n    foreach\
    \ (left_car; 0 .. n) {\n        foreach (right_car; 0 .. n) {\n            if\
    \ (left_car * right_car * left_car * right_car % n == 0)\n                result\
    \ += 1;\n        }\n    }\n    return result;\n}", "{\n    // Write your solution\
    \ here\n    return n * (n - 1) / 2;\n}", "{\n    auto G = new Graph(2 * n);\n\
    \    for (long i = 0; i < n; i++) \n    {\n        G.addEdge(i, i + n);\n    }\n\
    \    return G.longestPath();\n}", "{\n    long j;\n    long collisions = 0;\n\
    \    long car_x[];\n    long car_y[];\n    long car_v[];\n    long left_cars =\
    \ n;\n    long right_cars = n;\n    long car;\n    long time;\n    long num_collisions;\n\
    \    long closest_left;\n    long closest_right;\n    long i;\n    long dist;\n\
    \    j = 0;\n    for (car = 0; car < n; car = car + 1) {\n        car_x[j] = car\
    \ * 64;\n        car_y[j] = 0;\n        car_v[j] = 8;\n        j = j + 1;\n  \
    \  }\n    while (true) {\n        time = time + 1;\n        num_collisions = 0;\n\
    \        closest_left = (car_x[0] + car_v[0] * time);\n        closest_right =\
    \ -(car_x[n - 1] + car_v[n - 1] * time);\n        for (i = 1; i < n; i = i + 1)\
    \ {\n            dist = (car_x[i] + car_v[i] * time);\n            if (dist <\
    \ closest_left) {\n                closest_left = dist;\n            }\n     \
    \   }\n        for (i = n - 2; i >= 0; i = i - 1) {\n            dist = -(car_x[i]\
    \ + car_v[i] * time);\n            if (dist < closest_right) {\n             \
    \   closest_right = dist;\n            }\n        }\n        if (closest_left\
    \ >= closest_right) {\n            break;\n        }\n        for (i = 1; i <\
    \ n; i = i + 1) {\n            dist = (car_x[i] + car_v[i] * time);\n        \
    \    if (dist == closest_left) {\n                num_collisions = num_collisions\
    \ + 1;\n            }\n        }\n        collisions = collisions + num_collisions\
    \ * right_cars;\n        right_cars = right_cars - num_collisions;\n        num_collisions\
    \ = 0;\n        for", "{\n    return n * (n - 1) / 2;\n}", "{\n    long count\
    \ = 0;\n    auto A = new double[];\n    auto B = new double[];\n    foreach (i;\
    \ 0 .. n)\n    {\n        A[i] = -n + 2 * i;\n        B[i] = n - 2 * i;\n    }\n\
    \    foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n    \
    \        count += (A[i] > B[j]) ? 1 : 0;\n        }\n    }\n    return count;\n\
    }", "{\n    long number_of_collisions = 0;\n    int i = 0;\n    while (i < n)\n\
    \    {\n        int j = 0;\n        while (j < n)\n        {\n            number_of_collisions\
    \ = number_of_collisions + 1;\n            j = j + 1;\n        }\n        i =\
    \ i + 1;\n    }\n    return number_of_collisions;\n}", "{\n    long collisions;\n\
    \    collisions = 0;\n    long i;\n    i = 0;\n    while (i < n) {\n        long\
    \ j;\n        j = 0;\n        while (j < n) {\n            long k;\n         \
    \   k = 0;\n            while (k < n) {\n                long l;\n           \
    \     l = 0;\n                while (l < n) {\n                    long m;\n \
    \                   m = 0;\n                    while (m < n) {\n            \
    \            long o;\n                        o = 0;\n                       \
    \ while (o < n) {\n                            long p;\n                     \
    \       p = 0;\n                            while (p < n) {\n                \
    \                long q;\n                                q = 0;\n           \
    \                     while (q < n) {\n                                    long\
    \ r;\n                                    r = 0;\n                           \
    \         while (r < n) {\n                                        long s;\n \
    \                                       s = 0;\n                             \
    \           while (s < n) {\n                                            long\
    \ t;\n                                            t = 0;\n                   \
    \                         while (t < n) {\n                                  \
    \              long u;\n                                                u = 0;\n\
    \                                                while (u < n) {\n           \
    \                                         long v;\n                          \
    \                          v = 0;\n                                          \
    \          while (v < n) {\n                                                 \
    \       long w;\n                                                        w = 0;\n\
    \                                                        while (w < n) {\n   \
    \                                                         long x;\n          \
    \                                                  x = 0;\n                  \
    \                                          while (x < n) {\n                 \
    \                                               long y;\n                    \
    \                                            y = 0;\n                        \
    \                                        while (y < n) {\n                   \
    \                                                 long z;\n                  \
    \                                                  z = 0;\n                  \
    \                                                  while (z < n) {\n         \
    \                                                               collisions = collisions\
    \ + 1;\n                                                                     \
    \   z = z + 1;\n                                                             \
    \       }\n                                                                  \
    \  y = y + 1;\n                                                              \
    \  }\n                                                                x = x +\
    \ 1;\n                                                            }\n        \
    \                                                    w = w + 1;\n            \
    \                                            }\n                             \
    \                           v = v + 1;\n                                     \
    \               }\n                                ", "{\n    long numCollisions\
    \ = 0;\n    long count = n;\n    double leftSide = 0.0;\n    double rightSide\
    \ = 0.0;\n    bool isLeftIncreasing = true;\n    bool isRightIncreasing = false;\n\
    \    while (count > 0)\n    {\n        if (isLeftIncreasing && leftSide >= 0)\n\
    \        {\n            isLeftIncreasing = false;\n            isRightIncreasing\
    \ = true;\n            count--;\n        }\n        else if (isRightIncreasing\
    \ && rightSide <= 0)\n        {\n            isRightIncreasing = false;\n    \
    \        isLeftIncreasing = true;\n            count--;\n        }\n        else\
    \ if (isLeftIncreasing)\n        {\n            leftSide += 0.01;\n        }\n\
    \        else if (isRightIncreasing)\n        {\n            rightSide -= 0.01;\n\
    \        }\n        else\n        {\n            if (abs(leftSide) == abs(rightSide))\n\
    \            {\n                numCollisions++;\n            }\n            leftSide\
    \ -= 0.01;\n            rightSide += 0.01;\n        }\n    }\n    return numCollisions;\n\
    }", "{\n    long collisions = 0;\n    int i;\n    for (i = 0; i < n; i++)\n  \
    \  {\n        double position_left_i;\n        double position_right_i;\n    \
    \    double speed_left_i;\n        double speed_right_i;\n        double time_to_collision_i;\n\
    \        int j;\n        for (j = 0; j < n; j++)\n        {\n            double\
    \ position_left_j;\n            double position_right_j;\n            double speed_left_j;\n\
    \            double speed_right_j;\n            double time_to_collision_j;\n\
    \            if (i != j)\n            {\n                if (speed_left_i < speed_right_j)\n\
    \                {\n                    time_to_collision_i = (position_right_j\
    \ - position_left_i) / (speed_left_i - speed_right_j);\n                    if\
    \ (time_to_collision_i < 0)\n                    {\n                        collisions++;\n\
    \                    }\n                }\n                if (speed_right_i >\
    \ speed_left_j)\n                {\n                    time_to_collision_j =\
    \ (position_left_j - position_right_i) / (speed_right_i - speed_left_j);\n   \
    \                 if (time_to_collision_j < 0)\n                    {\n      \
    \                  collisions++;\n                    }\n                }\n \
    \           }\n        }\n    }\n    return collisions;\n}", "{\n    assert(n\
    \ >= 0);\n    if (n == 0)\n    {\n        return 0;\n    }", "{\n    if (n==0)\n\
    \    {\n        return 0;\n    }\n    else\n    {\n        return n-1;\n    }\n\
    \    \n}", "{\n    return n;\n}", "{\n    if (n <= 1) \n        return 0;", "{\n\
    \    long double [] rl_array = new long double[n]; // right to left\n    long\
    \ double [] lr_array = new long double[n]; // left to right\n    long double max_lr_to_rl\
    \ = 0.0;\n    long double max_rl_to_lr = 0.0;\n    long double max_lr_to_lr =\
    \ 0.0;\n    long double max_rl_to_rl = 0.0;\n    long i = 0;\n    long j = 0;\n\
    \    long count = 0;\n    for (i = 0; i < n; i++) {\n        rl_array[i] = i;\n\
    \        lr_array[i] = i;\n    }\n    for (i = 0; i < n; i++) {\n        max_lr_to_rl\
    \ = max(max_lr_to_rl, rl_array[i] - lr_array[i]);\n        max_rl_to_lr = max(max_rl_to_lr,\
    \ lr_array[i] - rl_array[i]);\n        max_lr_to_lr = max(max_lr_to_lr, lr_array[i]\
    \ - lr_array[i]);\n        max_rl_to_rl = max(max_rl_to_rl, rl_array[i] - rl_array[i]);\n\
    \    }\n    for (i = 0; i < n; i++) {\n        lr_array[i] = lr_array[i] + max_lr_to_rl;\n\
    \        rl_array[i] = rl_array[i] + max_rl_to_lr;\n    }\n    for (i = 0; i <\
    \ n; i++) {\n        for (j = 0; j < n; j++) {\n            if (lr_array[i] -\
    \ rl_array[j] == 0) {\n                count = count + 1;\n            }\n   \
    \     }\n    }\n    return count;\n}", "{\n    if (n == 0 || n == 1)\n       \
    \ return 0;\n    if (n == 2)\n        return 1;\n    long i;\n    long n1 = n;\n\
    \    long n2 = n;\n    long result = 0;\n    long current;\n    long remaining;\n\
    \    for (i = 1; i <= n1; i++) \n    {\n        current = i;\n        remaining\
    \ = n1 - i;\n        result += min(current, remaining);\n    }\n    for (i = 1;\
    \ i <= n2; i++) \n    {\n        current = i;\n        remaining = n2 - i;\n \
    \       result += min(current, remaining);\n    }\n    return result;\n}", "{\n\
    \    long iter = 0;\n    foreach (i; 0 .. n) \n    {\n        iter += (n - i);\n\
    \    }\n    return iter;\n}\n ", "{\n  return n * (n - 1) / 2;\n}", "{\n    long\
    \ result;\n    long[] car1 = new long[n];\n    long[] car2 = new long[n];\n  \
    \  long offset = 10000000;\n    long collision_count = 0;\n    long i;\n    long\
    \ j;\n    long temp;\n    long first_car_index;\n    long second_car_index;\n\
    \    for (i = 0; i < n; i++) {\n        car1[i] = i * offset;\n        car2[i]\
    \ = -1 * (i * offset);\n    }\n    for (i = 0; i < n; i++) {\n        for (j =\
    \ 0; j < n - 1; j++) {\n            if (car1[j] > car1[j + 1]) {\n           \
    \     temp = car1[j];\n                car1[j] = car1[j + 1];\n              \
    \  car1[j + 1] = temp;\n            }\n            if (car2[j] > car2[j + 1])\
    \ {\n                temp = car2[j];\n                car2[j] = car2[j + 1];\n\
    \                car2[j + 1] = temp;\n            }\n        }\n    }\n    first_car_index\
    \ = 0;\n    second_car_index = 0;\n    collision_count = 0;\n    while (first_car_index\
    \ < n && second_car_index < n) {\n        if (car1[first_car_index] <= car2[second_car_index])\
    \ {\n            collision_count += second_car_index;\n            first_car_index++;\n\
    \        } else {\n            second_car_index++;\n        }\n    }\n    result\
    \ = collision_count;\n    return result;\n}\nlong main()\n{\n    long i;\n   \
    \ i = car_race_collision(1);\n    print_text(\"for 1 car, collision is \");\n\
    \    print_long(i);\n    print_text(\"\\n\");\n    i = car_race_collision(2);\n\
    \    print_text(\"for 2 cars, collision is \");\n    print_long(i);\n    print_text(\"\
    \\n\");\n    i = car_race", "{\n    if (n == 0) return 0;\n    if (n == 1) return\
    \ 0;\n    if (n == 2) return 1;\n    long sum = 0;\n    for (long i = 0; i < n;\
    \ i++)\n    {\n        sum += n - i - 1;\n    }\n    return sum;\n}", "{\n   \
    \ constexpr long MAX_SPEED = 100'000'000;\n    constexpr long MAX_TIME = 1000'000'000;\n\
    \    constexpr long MAX_CARS = 100'000;\n    long num_pos[MAX_CARS+1]; // the\
    \ initial positions of the cars moving left to right\n    long num_speed[MAX_CARS+1];\
    \ // the speeds of the cars moving left to right\n    long num_pos_neg[MAX_CARS+1];\
    \ // the initial positions of the cars moving right to left\n    long num_speed_neg[MAX_CARS+1];\
    \ // the speeds of the cars moving right to left\n    long num_collisions = 0;\n\
    \    for (long i = 1; i <= n; i++) \n    {\n        num_pos[i] = (long) (uniform01()\
    \ * MAX_TIME);\n        num_speed[i] = (long) (uniform01() * MAX_SPEED) + 1;\n\
    \        num_pos_neg[i] = (long) (uniform01() * MAX_TIME);\n        num_speed_neg[i]\
    \ = (long) (uniform01() * MAX_SPEED) + 1;\n    }\n    sort(num_pos + 1, num_pos\
    \ + n + 1);\n    sort(num_pos_neg + 1, num_pos_neg + n + 1);\n    // Invariant:\
    \ cars 1..k-1 are already placed in the array.\n    for (long k = 1; k <= n; k++)\
    \ \n    {\n        num_pos[k] += k * num_speed[k];\n        num_pos_neg[k] -=\
    \ k * num_speed_neg[k];\n        num_collisions += (num_pos[k] <= num_pos_neg[k])\
    \ ? 1 : 0;\n    }\n    return num_collisions;\n}", "{\n    return n*(n-1)/2;\n\
    }", "{\n    auto i = 0L;\n    auto j = n-1L;\n    auto count = 0L;\n    while\
    \ (i < n && j >= 0) {\n        if (i == j) \n            ++count;\n        else\
    \ \n            count += 2;\n        ++i;\n        --j;\n    }\n    return count;\n\
    }", "{\n    return n*(n-1)/2;\n}", "{\n    //     null     0     1     2     3\
    \     4     5     6     7     8     9\n    // left_cars  0     0     1     2 \
    \    3     4     5     6     7     8\n    // right_cars 0     9     8     7  \
    \   6     5     4     3     2     1\n    //             \\ /   \\ /   \\ /   \\\
    \ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /\n    //              2     1   \
    \  0     0     1     2     3     4     5     6\n    return n * (n-1) / 2;\n}",
  "{\n    long left = n;\n    long right = n;\n    long collide = 0;\n    while (left\
    \ > 0 && right > 0) \n    {\n        if (left > right) \n        {\n         \
    \   collide += right;\n            left -= right;\n            right = 0;\n  \
    \      } \n        else if (left < right) \n        {\n            collide +=\
    \ left;\n            right -= left;\n            left = 0;\n        } \n     \
    \   else // left == right\n        {\n            collide += left;\n         \
    \   left = 0;\n            right = 0;\n        }\n    }\n    return collide;\n\
    }", "{\n    double[long] right_cars; //1D array with n elements\n    double[long]\
    \ left_cars; //1D array with n elements\n    long right_cars_count=0;\n    long\
    \ left_cars_count=0;\n    long num_collisions=0;\n    long temp_right_count=0;\n\
    \    long temp_left_count=0;\n    int i;\n    int j;\n    /*\n        Initialize\
    \ the two arrays by assigning each element to a distinct number.\n        For\
    \ example, if n = 3, then the array of right cars must be 0, 1, 2, and the\n \
    \       array of left cars must be 0, 1, 2.\n    */\n    for(i=0;i<n;i++) {\n\
    \        right_cars[i]=i;\n        left_cars[i]=i;\n    }\n    for(i=0;i<n;i++)\
    \ {\n        temp_right_count = right_cars_count;\n        temp_left_count = left_cars_count;\n\
    \        right_cars_count = right_cars_count + right_cars[i];\n        left_cars_count\
    \ = left_cars_count + left_cars[i];\n        num_collisions = num_collisions +\
    \ temp_right_count * temp_left_count;\n    }\n    /*\n        These values must\
    \ be returned.\n    */\n    return num_collisions;\n}", "{\n    if (n<=1) return\
    \ 0;\n    return n*(n-1)/2;\n}", "{\n    long cnt = 0;\n    int cur_dir = 1;\n\
    \    long pos = 0;\n    int* car_pos = new int[n];\n    // pos is the current\
    \ position of the car.  Cars start at the same position\n    // with the same\
    \ distance to each other.\n    for (int i = 0; i < n; i++) {\n        car_pos[i]\
    \ = i * 2;\n    }\n    while (true) {\n        // move the car to the next position\n\
    \        if (cur_dir == 1) {\n            pos++;\n        } else {\n         \
    \   pos--;\n        }\n        // iterate through all the cars to see whether\
    \ a collision happened.\n        for (int i = 0; i < n; i++) {\n            if\
    \ (car_pos[i] == pos) {\n                // a collision happened\n           \
    \     cnt++;\n                cur_dir = -cur_dir;\n                break;\n  \
    \          }\n        }\n        // check if all the cars have passed by each\
    \ other.\n        if (cur_dir == 1) {\n            if (pos > n * 2) {\n      \
    \          break;\n            }\n        } else {\n            if (pos < 0) {\n\
    \                break;\n            }\n        }\n    }\n    return cnt;\n}",
  "{\n    long car[n];\n    long car2[n];\n    long c=0;\n    for(long i=0;i<n;i++)\n\
    \    {\n        car[i]=0;\n        car2[i]=0;\n    }\n    for(long i=0;i<n;i++)\n\
    \    {\n        car[i]=i+1;\n        car2[i]=n-i;\n    }\n    for(long i=0;i<n;i++)\n\
    \    {\n        for(long j=0;j<n;j++)\n        {\n            if(car[i]==car2[j])\n\
    \            {\n                c++;\n            }\n        }\n    }\n    return\
    \ c;\n}\n/*", "{\n    return n * (n - 1) / 2;\n}", "{\n    double num_collisions\
    \ = 0;\n    /*\n        The second loop is the more important loop. \n       \
    \ Think of all the cars that are moving from left to right as fixed.\n       \
    \ Now, take one of the cars that's moving from right to left. \n        This car\
    \ will collide with all the cars that are moving from left to right,\n       \
    \ and so the number of collisions that this car is involved in is n,\n       \
    \ and so the total number of collisions is n * n = n^2.\n        \n        We\
    \ could have written a second loop, but there is no need, as all we have to do\
    \ is\n        to multiply the number of cars that are moving from left to right\
    \ by the number\n        of cars that are moving from right to left.\n    */\n\
    \    return (long) ceil(n * n);\n}", "{\n    long i;\n    long collision = 0;\n\
    \    int[] cars;", "{\n    // long[] left = new long[n];\n    // long[] right\
    \ = new long[n];\n    // long answer = 0;\n    // long i, j;\n    // for (i =\
    \ 0; i < n; i++) {\n    //     left[i] = i;\n    //     right[i] = n - i - 1;\n\
    \    // }\n    // for (i = 0; i < n; i++) {\n    //     for (j = 0; j < n; j++)\
    \ {\n    //         if (left[i] < right[j]) {\n    //             answer++;\n\
    \    //         }\n    //     }\n    // }\n    // return answer;\n    return n\
    \ * (n - 1) / 2;\n}\n/*\n    This is a sorted list of numbers.  A painter chooses\
    \ a number, and deletes it.\n    However, in the process of deleting, it also\
    \ deletes the number to the right of\n    the chosen number.  For example, if\
    \ the painter chooses the number 6, it deletes\n    the number 6 and the number\
    \ 7.\n    This function outputs the number of different number-deletion sequences\
    \ that\n    lead to the deletion of all numbers from the list.\n*/\nlong list_painter(long\
    \ n) \n{\n    return n;\n}\n/*\n    You are given an array of length n, with integer\
    \ elements between 0 and n-1.\n    In this array, there are some number of cycles.\
    \  For example, consider the array\n    {1, 2, 0, 3}.  0->1->2->0 is a cycle,\
    \ and 3 is a cycle of length 1.\n    This function outputs the number of such\
    \ cycles.\n*/\nlong number_of_cycles(int[] array) \n{\n    long n = array.length;\n\
    \    bool[] visited = new bool[n];\n    long answer = 0;\n    long i;\n    for\
    \ (i = 0; i < n; i++) {\n        visited[i] = false;\n    }\n    for (i = 0; i\
    \ < n; i++) {\n        if (!visited[i]) {\n            visited[i] = true;\n  \
    \          long j = array[i];\n           ", "{\n    if (n <= 0) return 0;\n \
    \   long half = (n - 1) / 2;\n    return half * (half + 1);\n}", "{\n  auto l\
    \ = new real[n];\n  auto r = new real[n];\n  for (long i = 0; i < n; i++)\n  {\n\
    \    l[i] = real(i+1);\n    r[i] = real(n - i);\n  }\n  sort(l);\n  sort(r);\n\
    \  lsort!((a, b) => a.y < b.y)(r);\n  long r_last = 0;\n  long collisions = 0;\n\
    \  for (long i = 0; i < n; i++)\n  {\n    while (r_last < n && r[r_last].y < l[i].y)\
    \ \n    {\n      r_last++;\n    }\n    collisions += r_last - i;\n  }\n  return\
    \ collisions;\n}", "{\n    // your code goes here\n    return n * (n - 1) / 2;\n\
    }", "{\n    /*\n        To find the number of collisions, we sort each set of\
    \ cars.\n        We'll call the set of cars moving left to right A, the set of\
    \ cars moving right to left B.\n        We keep a running sum of the number of\
    \ collisions.  We go through each car in A from back to front.\n        For each\
    \ car in A, we look for the first car in B that's farther to the right than the\
    \ current car in A.\n        When we find such a car, we know that the current\
    \ car in A will collide with it.\n        In addition, it will collide with all\
    \ cars in B that precede it.  So, we add the number of preceding cars to the running\
    \ sum.\n        We then increment the pointer that points to B by 1.\n       \
    \ We then move on to the next car in A.  When we reach the end of A, we return\
    \ the running sum.\n    */\n    long[] A = new long[n];\n    long[] B = new long[n];\n\
    \    for (long i = 0; i < n; i++) \n    {\n        A[i] = n - i;\n        B[i]\
    \ = n - i;\n    }\n    std.sort(A);\n    std.sort(B);\n    long sum = 0;\n   \
    \ long j = 0;\n    for (long i = 0; i < n; i++) \n    {\n        while (j < n\
    \ && B[j] < A[i]) \n        {\n            j++;\n        }\n        sum += j;\n\
    \    }\n    return sum;\n}", "{\n    long c = 0;\n    for (long i = 0; i < n;\
    \ i++) {\n        for (long j = i + 1; j < n; j++) {\n            c += 1;\n  \
    \      }\n    }\n    return c;\n}", "{\n    return (n*(n-1))/2;\n}", "{\n    size_t\
    \ r = n;\n    size_t l = n;\n    size_t result = 0;\n    while (l > 0) \n    {\n\
    \        result += r;\n        l--;\n        r--;\n    }\n    return result;\n\
    }", "{\n    // Write your code here\n    // To debug: std.error.writeln(\"Debug\
    \ messages...\");\n    long left[];\n    for (int i = 0; i < n; i++)\n    {\n\
    \        left.push_back(n - i);\n    }\n    long right[];\n    for (int i = 0;\
    \ i < n; i++)\n    {\n        right.push_back(i + 1);\n    }\n    sort(left);\n\
    \    sort(right);\n    long answer = 0;\n    int l = 0;\n    int r = 0;\n    while\
    \ (l < n && r < n)\n    {\n        if (left[l] < right[r])\n        {\n      \
    \      l++;\n        }\n        else if (left[l] > right[r])\n        {\n    \
    \        r++;\n        }\n        else\n        {\n            answer++;\n   \
    \         l++;\n            r++;\n        }\n    }\n    return answer;\n}", "{\n\
    \    static assert(n >= 0);\n    return n * (n - 1) / 2;\n}", "{\n    long car_count\
    \ = 0;\n    long[] left_to_right_cars = new long[n];\n    long[] right_to_left_cars\
    \ = new long[n];\n    for (long i = 0; i < n; i++) \n    {\n        left_to_right_cars[i]\
    \ = i + 1;\n        right_to_left_cars[i] = n - i;\n    }\n    for (long i = 0;\
    \ i < n; i++) \n    {\n        for (long j = 0; j < n; j++) \n        {\n    \
    \        if (left_to_right_cars[i] == right_to_left_cars[j]) \n            {\n\
    \                car_count++;\n            }\n        }\n    }\n    return car_count;\n\
    }", "{\n    long cnt = 0;\n    n *= 2;\n    for (long i = 0; i < n; i++) \n  \
    \  {\n        double speed;\n        speed = randf();\n        for (long j = i+1;\
    \ j < n; j++) \n        {\n            if (speed > randf()) \n            {\n\
    \                cnt++;\n            }\n        }\n    }\n    return cnt;\n}",
  "{\n    long leftToRight[n];\n    long rightToLeft[n];\n    long i = 0, j = 0, k\
    \ = 0;\n    long leftToRightCount = 0, rightToLeftCount = 0;\n    while (n-- >\
    \ 0) {\n        cin >> leftToRight[i];\n        i++;\n    }\n    n = i;\n    i\
    \ = 0;\n    while (n-- > 0) {\n        cin >> rightToLeft[i];\n        i++;\n\
    \    }\n    n = i;\n    i = 0;\n    qsort(leftToRight, 0, n - 1);\n    qsort(rightToLeft,\
    \ 0, n - 1);\n    while (i < n && j < n) {\n        if (leftToRight[i] <= rightToLeft[j])\
    \ {\n            leftToRightCount++;\n            i++;\n        } else {\n   \
    \         rightToLeftCount++;\n            j++;\n        }\n    }\n    if (i ==\
    \ n)\n        rightToLeftCount += n - j;\n    else\n        leftToRightCount +=\
    \ n - i;\n    k = leftToRightCount * rightToLeftCount;\n    return k;\n}", "{\n\
    \    return n*(n-1)/2;\n}", "{\n\treturn ( n * (n - 1) / 2 );\n}", "{\n    //\
    \ Write your code here\n    // To debug: write to stderr, e.g. cerr << \"Debug\
    \ messages...\" << endl;\n    long num_collisions = 0;\n    long left_car_index\
    \ = 0;\n    long right_car_index = n - 1;\n    while (left_car_index < n && right_car_index\
    \ >= 0) {\n        if (left_car_index == right_car_index) {\n            break;\n\
    \        }\n        if (left_car_index < right_car_index) {\n            left_car_index++;\n\
    \            num_collisions++;\n        } else {\n            right_car_index--;\n\
    \            num_collisions++;\n        }\n    }\n    return num_collisions;\n\
    }", "{\n    long[long]  nd;\n    long        num_collisions = 0;\n    long   \
    \     idx;\n    long        i;\n    long        j;\n    long        v;\n    long\
    \        num_already_registered = 0;\n    long        prev_value = -1;\n    //\
    \ invariant:  each element in 'nd' is a tuple of the form {v,j}\n    // where\
    \ 'v' is the position of the car and 'j' is the index\n    // the car is the j-th\
    \ car in its lane.\n    nd.rehash( n );\n    foreach(i; 0 .. n) {\n        idx\
    \ = (i * n) / (n+1);\n        nd[idx] = {i,j};\n    }\n    // now we must print\
    \ the cars starting in order of\n    // position.\n    foreach(idx; nd.keys())\
    \ {\n        v = nd[idx][0];\n        j = nd[idx][1];\n        if (prev_value\
    \ != -1) {\n            num_collisions += abs(prev_value - v);\n        }\n  \
    \      if (prev_value != -1 && num_already_registered < n) {\n            num_collisions\
    \ += num_already_registered;\n        }\n        prev_value = v;\n        num_already_registered++;\n\
    \    }\n    return num_collisions;\n}", "{\n    auto i=0, j=0, count=0;\n    long\
    \ left[], right[];\n    auto leftSize=0, rightSize=0;\n    while(i<n)\n    {\n\
    \        auto dir=readInt();\n        auto speed=readInt();\n        if(dir==1)\n\
    \        {\n            left[leftSize++]=speed;\n        }\n        else\n   \
    \     {\n            right[rightSize++]=speed;\n        }\n        i++;\n    }\n\
    \    sort(left);\n    sort(right);\n    i=0;\n    j=0;\n    while(i<leftSize &&\
    \ j<rightSize)\n    {\n        if(left[i]<right[j])\n        {\n            count++;\n\
    \            i++;\n        }\n        else\n        {\n            j++;\n    \
    \    }\n    }\n    return count;\n}", "{\n  // First, we have to have the two\
    \ sets of car, one driving left and one driving right\n  // In this function,\
    \ the one driving left are called \"first\", and the one driving right are called\
    \ \"second\"\n  // As the name implies, \"first\" starts before \"second\"", "{\n\
    \    long ans = 0;", "{\n  long i = 0;\n  long j = 0;\n  long coll = 0;\n  while\
    \ (i < n && j < n) {\n    if (i == j) {\n      coll += n-j;\n      i++;\n    }\
    \ else if (i < j) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return\
    \ coll;\n}\n/*\n    Now imagine an arbitrary curve instead of a straight line.\n\
    \    The cars are still moving in the same speed; all cars start\n    at the same\
    \ time and location.  However, the cars are not\n    infinitely long; they have\
    \ a size.  As a result, the cars\n    will collide if the cars on a different\
    \ direction touch\n    or interleave.", "{ \n    // n == 0\n    // n == 1;\n \
    \   // n == 2;\n    // n == 3;\n    // ...\n    // n == 8;\n    // n == 9;\n \
    \   // n == 10;\n    // n == 11;\n    // n == 12;\n    // n == 13;\n    // n ==\
    \ 14;\n    // n == 15;\n    // ...\n    // n == 31;\n    // n == 32;\n    // n\
    \ == 33;\n    // n == 34;\n    // n == 35;\n    // n == 36;\n    // n == 37;\n\
    \    // n == 38;\n    // n == 39;\n    // n == 40;\n    // n == 41;\n    // n\
    \ == 42;\n    // n == 43;\n    // n == 44;\n    // n == 45;\n    // n == 46;\n\
    \    // n == 47;\n    // n == 48;\n    // n == 49;\n    // n == 50;\n    // n\
    \ == 51;\n    // n == 52;\n    // n == 53;\n    // n == 54;\n    // n == 55;\n\
    \    // n == 56;\n    // n == 57;\n    // n == 58;\n    // n == 59;\n    // n\
    \ == 60;\n    // n == 61;\n    // n == 62;\n    // n == 63;\n    // n == 64;\n\
    \    // n == 65;\n    // n == 66;\n    // n == 67;\n    // n == 68;\n    // n\
    \ == 69;\n    // n == 70;\n    // n == 71;\n    // n == 72;\n    // n == 73;\n\
    \    // n == 74;\n    // n == 75;\n    // n == 76;\n    // n == 77;\n    // n\
    \ == 78;\n    // n == 79;\n    // n == 80;\n    // n == 81;\n    // n == 82;\n\
    \    // n == 83;\n    // n == 84;\n    // n == 85;\n    // n == 86;\n    // n\
    \ == 87;\n    // n == 88;\n    // n == 89;\n    // n ==", "{\n    \n}", "{\n \
    \   auto left_to_right = new double[n];\n    auto right_to_left = new double[n];\n\
    \    foreach (i, ref x; left_to_right)\n        x = (i + 1) * 10000000;\n    foreach\
    \ (i, ref x; right_to_left)\n        x = n * 10000000 - (i + 1) * 10000000;\n\
    \    auto count = 0;\n    for (auto i = 0; i < n; i++) \n    {\n        for (auto\
    \ j = 0; j < n; j++) \n        {\n            if (abs(left_to_right[i] - right_to_left[j])\
    \ < 1)\n                count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    /*\n        Your code goes here.\n    */\n    return (long)sqrt(n);\n}",
  "{\n    long result = 0;\n    long a = 0;\n    while (a < n) {\n        long b =\
    \ n;\n        while (b > 0) {\n            if (a == b) {\n                ++result;\n\
    \            }\n            b -= 1;\n        }\n        a += 1;\n    }\n    return\
    \ result;\n}", "{\n    if (n < 1)\n    {\n        return 0;\n    }\n    auto b1\
    \ = array(1 .. n);\n    auto b2 = array(1 .. n);\n    for (int i = 0; i < n; i\
    \ += 1)\n    {\n        b1[i] = i + 1;\n        b2[i] = n - i;\n    }\n    long\
    \ collisions = 0;\n    for (int i = 0; i < n; i += 1)\n    {\n        for (int\
    \ j = 0; j < n; j += 1)\n        {\n            if (b1[i] == b2[j])\n        \
    \    {\n                collisions += 1;\n            }\n        }\n    }\n  \
    \  return collisions;\n}\n/*\n    Suppose that you're given a list of integers,\
    \ where each integer represents an ID number.\n    Each ID number belongs to a\
    \ particular person.  However, some of the given integers are\n    duplicates,\
    \ meaning they're ID numbers of the same person.", "{\n     if (n < 2)\n     \
    \   return 0;\n    else \n        return (n * (n - 1)) / 2;\n}", "{\n    long\
    \ number_of_collisions;\n    /*\n        When cars collide, then their speeds\
    \ are moving in the same direction and\n        the car with the faster speed\
    \ is going to reach the car with the slower speed\n        exactly at the same\
    \ time.\n        \n        (1) The time it takes a car to reach the car in front\
    \ is given by:\n            \n            distance / speed", "{\n    long res\
    \ = 0;\n    for (long i = 0; i < n; i += 1) \n    {\n        for (long j = 0;\
    \ j < n; j += 1) \n        {\n            res += (i - j) < 0;\n        }\n   \
    \ }\n    return res;\n}", "{\n    return n * (n - 1) / 2;\n}", "{\n    if (n ==\
    \ 0)\n        return 0;\n    else if (n == 1)\n        return 0;\n    else if\
    \ (n == 2)\n        return 1;\n    else\n        return n + car_race_collision(n\
    \ - 1);\n}", "{\n    long i;\n    long result = 0;\n    for (i = 0; i < n; i =\
    \ i + 1) \n    {\n        result = result + n - i;\n    }\n    return result;\n\
    }", "{\n    assert(n>=0);\n    long i;\n    long count = 0;\n    long j = 0;\n\
    \    for (i = 0; i < n; i++) \n    {\n        long k = sqrt(i * i + j * j);\n\
    \        if (k >= i && k <= n && k > j) \n        {\n            count++;\n  \
    \      }\n        j++;\n    }\n    return count;\n}", "{\n    assert(n >= 0);\n\
    \    return n*(n-1)/2;\n}", "{\n    return n * (n - 1) / 2;\n}", "{\n    long\
    \ result = 0;", "{\n    long count = 0;\n    foreach (i, car1; n) {\n        count\
    \ += n - i - 1;\n    }\n    return count;\n}", "{\n    assert(n > 0);\n    return\
    \ n*(n-1)/2;\n}", "{\n    if (n <= 0)\n        return 0;\n    long res = 0;\n\
    \    long[] left = new long[n];\n    long[] right = new long[n];\n    long i =\
    \ 0;\n    while (i < n) \n    {\n        left[i] = i * (n - i);\n        right[i]\
    \ = left[i];\n        ++i;\n    }\n    i = 0;\n    while (i < n) \n    {\n   \
    \     res += left[i] * right[i];\n        ++i;\n    }\n    return res;\n}\nstatic\
    \ assert(car_race_collision(0) == 0);\nstatic assert(car_race_collision(1) ==\
    \ 0);\nstatic assert(car_race_collision(2) == 1);\nstatic assert(car_race_collision(3)\
    \ == 5);\nstatic assert(car_race_collision(4) == 14);\nstatic assert(car_race_collision(5)\
    \ == 30);\nstatic assert(car_race_collision(6) == 55);\nstatic assert(car_race_collision(7)\
    \ == 91);\nstatic assert(car_race_collision(8) == 140);\nstatic assert(car_race_collision(9)\
    \ == 204);\nstatic assert(car_race_collision(10) == 285);\nstatic assert(car_race_collision(11)\
    \ == 385);\nstatic assert(car_race_collision(12) == 506);\nstatic assert(car_race_collision(13)\
    \ == 650);\nstatic assert(car_race_collision(14) == 819);\nstatic assert(car_race_collision(15)\
    \ == 1015);\nstatic assert(car_race_collision(16) == 1240);\nstatic assert(car_race_collision(17)\
    \ == 1496);\nstatic assert(car_race_collision(18) == 1785);\nstatic assert(car_race_collision(19)\
    \ == 2109);\nstatic assert(car_race_collision(20) == 2470);\nstatic assert(car_race_collision(21)\
    \ == 2870);\nstatic assert(car_race_coll"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
