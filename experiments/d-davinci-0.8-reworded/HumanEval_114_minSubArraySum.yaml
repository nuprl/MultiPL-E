name: HumanEval_114_minSubArraySum
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of integers\
  \ nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n\
  \    >>> minSubArraySum([2L, 3L, 4L, 1L, 2L, 4L])\n    1L\n    >>> minSubArraySum([-1L,\
  \ -2L, -3L])\n    -6L\n    \n*/\nlong minSubArraySum(long[] nums) \n"
tests: "unittest\n{\n    alias candidate = minSubArraySum;\n\n    assert(candidate([2L,\
  \ 3L, 4L, 1L, 2L, 4L]) == 1L);\n    assert(candidate([-1L, -2L, -3L]) == -6L);\n\
  \    assert(candidate([-1L, -2L, -3L, 2L, -10L]) == -14L);\n    assert(candidate([-9999999999999999L])\
  \ == -9999999999999999L);\n    assert(candidate([0L, 10L, 20L, 1000000L]) == 0L);\n\
  \    assert(candidate([-1L, -2L, -3L, 10L, -5L]) == -6L);\n    assert(candidate([100L,\
  \ -1L, -2L, -3L, 10L, -5L]) == -6L);\n    assert(candidate([10L, 11L, 13L, 8L, 3L,\
  \ 4L]) == 3L);\n    assert(candidate([100L, -33L, 32L, -1L, 0L, -2L]) == -33L);\n\
  \    assert(candidate([-10L]) == -10L);\n    assert(candidate([7L]) == 7L);\n  \
  \  assert(candidate([1L, -1L]) == -1L);\n}\nvoid main(){}"
completions: ["{\n    long ans = nums[0];\n    long sum = 0;\n    foreach(i; 0 ..\
    \ nums.length) \n    {\n        sum += nums[i];\n        ans = min(ans, sum);\n\
    \        if(sum > 0) \n        {\n            sum = 0;\n        }\n    }\n   \
    \ return ans;\n}", "{\n    long sum = 0;\n    long min_sum = long.max;\n    for\
    \ (in long i = 0; i < nums.length; i++)\n    {\n        if (sum > 0)\n       \
    \ {\n            sum = nums[i];\n        }\n        else\n        {\n        \
    \    sum += nums[i];\n        }\n        min_sum = min(min_sum, sum);\n    }\n\
    \    return min_sum;\n}", "{\n    long s=nums[0],e=nums[0],ms=nums[0];\n    for(int\
    \ i=1;i<nums.length;i++)\n    {\n        s=min(s+nums[i],nums[i]);\n        e=max(e+nums[i],nums[i]);\n\
    \        ms=min(e,ms);\n    }\n    return ms;\n}\nlong[] tests = {-1L, -2L, -3L};\n\
    \  long[] tests2 = {2L, 3L, 4L, 1L, 2L, 4L};\n  assert(tests.minSubArraySum ==\
    \ -6L);\n  assert(tests2.minSubArraySum == 1L);", "{\n    long sum = nums[0];\n\
    \    long minSum = sum;\n    foreach(i; 1 .. nums.length)\n    {\n        sum\
    \ = max(nums[i], sum + nums[i]);\n        minSum = min(minSum, sum);\n    }\n\
    \    return minSum;\n}\n/*\n    Given an array of integers nums, find the maximum\
    \ sum of any non-empty\n    sub-array of nums.\n    Example\n    >>> maxSubArraySum([2L,\
    \ 3L, 4L, 1L, 2L, 4L])\n    15L\n    >>> maxSubArraySum([-1L, -2L, -3L])\n   \
    \ -1L\n*/\nlong maxSubArraySum(long[] nums) \n{\n    long sum = nums[0];\n   \
    \ long maxSum = sum;\n    foreach(i; 1 .. nums.length)\n    {\n        sum = max(nums[i],\
    \ sum + nums[i]);\n        maxSum = max(maxSum, sum);\n    }\n    return maxSum;\n\
    }\n/*\n    Given an array of integers nums, find the minimum sum of any contiguous\n\
    \    sub-array of size k.\n    Example\n    >>> minSubArraySumSizeK([2L, 3L, 4L,\
    \ 1L, 2L, 4L], 2)\n    5L\n    >>> minSubArraySumSizeK([2L, 3L, 4L, 1L, 2L, 4L],\
    \ 3)\n    6L\n    >>> minSubArraySumSizeK([2L, 3L, 4L, 1L, 2L, 4L], 4)\n    9L\n\
    \    >>> minSubArraySumSizeK([2L, 3L, 4L, 1L, 2L, 4L], 5)\n    10L\n    >>> minSubArraySumSizeK([2L,\
    \ 3L, 4L, 1L, 2L, 4L], 6)\n    11L\n*/\nlong minSubArraySumSizeK(long[] nums,\
    \ long k) \n{\n    assert(nums.length >= k);\n    long result = tuple(nums[0 ..\
    \ k])\n        .tuple", "{\n    if (nums.length == 0)\n        return 0;\n   \
    \ \n    long min_sum = min(nums);\n    long current_sum = 0;\n    foreach (i;\
    \ 0 .. nums.length)\n    {\n        if (current_sum + nums[i] < min_sum)\n   \
    \         min_sum = current_sum + nums[i];\n        current_sum += nums[i];\n\
    \    }\n    return min_sum;\n}", "{\n    long sum = 0L;\n    long min = 0L;\n\
    \    foreach(i, v; nums)\n    {\n        if(i == 0) \n        {\n            min\
    \ = v;\n            sum = v;\n        }\n        else \n        {\n          \
    \  sum += v;\n            if(sum < min) min = sum;\n        }\n    }\n    return\
    \ min;\n}", "{\n    if (nums.length == 0) return 0;\n    if (nums.length == 1)\
    \ return nums[0];\n    long[] sums = new long[nums.length];\n    sums[0] = nums[0];\n\
    \    for (long i = 1; i < nums.length; i++) {\n        sums[cast(size_t)i] = sums[cast(size_t)i\
    \ - 1] + nums[cast(size_t)i];\n    }\n    long min = min(nums);\n    if (min >\
    \ 0) return min;\n    min = sums[0];\n    for (long i = 0; i < nums.length; i++)\
    \ {\n        for (long j = i; j < nums.length; j++) {\n            if (i == 0)\
    \ {\n                min = min(min, sums[cast(size_t)j]);\n            } else\
    \ {\n                min = min(min, sums[cast(size_t)j] - sums[cast(size_t)i -\
    \ 1]);\n            }\n        }\n    }\n    return min;\n}", "{\n    if (nums.length\
    \ == 0) \n    {\n        return 0;\n    }\n    if (nums.length == 1) \n    {\n\
    \        return nums[0];\n    }\n    long min = nums[0];\n    long[] dp = new\
    \ long[nums.length];\n    dp[0] = nums[0];\n    for (int i = 1; i < nums.length;\
    \ i++) \n    {\n        dp[i] = min(dp[i - 1] + nums[i], nums[i]);\n        min\
    \ = min(min, dp[i]);\n    }\n    return min;\n}\n/*\n    Examples\n    >>> minSumOfPartition([2L,\
    \ 3L, 1L, 4L, 1L, 2L, 1L])\n    8L\n    >>> minSumOfPartition([1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L])\n    0L\n    >>> minSumOfPartition([4L, 3L, 2L, 5L, 1L, 1L, 2L])\n\
    \    0L\n    >>> minSumOfPartition([1L, 2L, 3L, 2L, 1L, 2L, 3L])\n    1L\n   \
    \ >>> minSumOfPartition([1L, 2L, 1L, 2L, 1L, 2L, 1L])\n    0L\n*/\nlong minSumOfPartition(long[]\
    \ nums) \n{\n    if (nums.length <= 1) \n    {\n        return 0;\n    }\n   \
    \ int leftSum = 0;\n    int rightSum = 0;\n    for (int i = 0; i < nums.length;\
    \ i++) \n    {\n        rightSum += nums[i];\n    }\n    int diff = abs(leftSum\
    \ - rightSum);\n    for (int i = 0; i < nums.length - 1; i++) \n    {\n      \
    \  leftSum += nums[i];\n        rightSum -= nums[i];\n        diff = min(diff,\
    \ abs(leftSum - rightSum));\n    }\n    return diff;\n}\n", "{\n    long min =\
    \ nums[0];\n    long sum = nums[0];\n    for (size_t i = 1; i < nums.length; i++)\n\
    \    {\n        if (sum > 0)\n            sum = nums[i];\n        else\n     \
    \       sum += nums[i];\n        min = min(min, sum);\n    }\n    return min;\n\
    }", "{\n    long minSum = long.MAX;\n    long acc = 0L;\n    foreach(num; nums)\n\
    \    {\n        acc += num;\n        minSum = min(minSum, acc);\n        acc =\
    \ max(acc, 0L);\n    }\n    return minSum;\n}", "{\n    if (nums.length == 0)\
    \ \n    {\n        return 0;\n    }\n    long min = nums[0];\n    long sum = 0;\n\
    \    foreach (num; nums) \n    {\n        sum += num;\n        min = min(min,\
    \ sum);\n        if (sum < 0) \n        {\n            sum = 0;\n        }\n \
    \   }\n    return min;\n}", "{\n    long sum = nums[0];\n    long ans = nums[0];\n\
    \    foreach(i; 1..nums.length) \n    {\n        if (sum > 0) \n        {\n  \
    \          sum = nums[i];\n        } \n        else \n        {\n            sum\
    \ += nums[i];\n        }\n        ans = min(ans, sum);\n    }\n    return ans;\n\
    }\n/*\n    Given an array of integers nums, find the minimum sum of any sub-array\
    \ of\n    nums.\n    Example\n    >>> minSubArraySum([2L, 3L, 4L, 1L, 2L, 4L])\n\
    \    1L\n    >>> minSubArraySum([-1L, -2L, -3L])\n    -6L\n*/\nlong minSubArraySum1(long[]\
    \ nums) \n{\n    if (nums.length == 0) \n    {\n        return 0;\n    }\n   \
    \ long sum = nums[0];\n    long ans = nums[0];\n    foreach(i; 1..nums.length)\
    \ \n    {\n        sum = min(sum + nums[i], nums[i]);\n        ans = min(ans,\
    \ sum);\n    }\n    return ans;\n}\n/*\n    Given an array of integers nums, find\
    \ the maximum sum of any sub-array of\n    nums.\n    Example\n    >>> maxSubArraySum([2L,\
    \ 3L, 4L, 1L, 2L, 4L])\n    15L\n    >>> maxSubArraySum([-1L, -2L, -3L])\n   \
    \ -1L\n*/\nlong maxSubArraySum(long[] nums) \n{\n    long sum = nums[0];\n   \
    \ long ans = nums[0];\n    foreach(i; 1..nums.length) \n    {\n        if (sum\
    \ < 0) \n        {\n            sum = nums[i];\n        } \n        else \n  \
    \      {\n            sum += nums[i];\n        }\n        ans = max(ans, sum);\n\
    \    }\n    return ans;\n}\n/*", "{ \n    long result = long.max;\n    long current_sum\
    \ = 0L; \n    foreach (num; nums)\n    { \n        current_sum += num; \n    \
    \    if (current_sum < result) \n            result = current_sum; \n        if\
    \ (current_sum > 0) \n            current_sum = 0; \n    } \n    return result;\
    \ \n} \n/*\n    Given an array nums of integers, find the maximum of j - i subjected\
    \ to the \n    constraint of a <= j and i <= b.\n    Example\n    >>> maxSubArraySum([3L,\
    \ 4L, 6L, 5L], 1L, 3L)\n    2L\n    >>> maxSubArraySum([3L, 4L, 6L, 5L], 2L, 2L)\n\
    \    -1L\n    >>> maxSubArraySum([2L, 3L, 4L, 1L, 2L, 4L], 0L, 5L)\n    5L\n \
    \   >>> maxSubArraySum([2L, 3L, 4L, 1L, 2L, 4L], 3L, 5L)\n    2L\n*/\nlong maxSubArraySum(long[]\
    \ nums, long a, long b) \n{ \n    long maxSum = -1L; \n    long sumSoFar = 0L;\
    \ \n    long n = b - a + 1L;\n    foreach (idx, num; nums)\n    { \n        if\
    \ (idx < a)\n            continue;\n        if (idx > b)\n            break;\n\
    \        sumSoFar += num; \n        if (sumSoFar < 0) \n            sumSoFar =\
    \ 0; \n        else if (sumSoFar > maxSum) \n            maxSum = sumSoFar; \n\
    \    } \n    return maxSum; \n} \n/*\n    Given an array of integers nums and\
    \ a window size of w, find the window of w \n    elements that maximizes the sum\
    \ of the window. \n    Example\n    >>> maxSubArraySumWindow([2L, 3L, 4L, 1L,\
    \ 2L, 4L], 3L)\n    9L\n", "{\n    long minSum = const(long.max);\n    long sum\
    \ = 0L;\n    long start = 0L;\n    long end = 0L;\n    while (end < nums.length)\n\
    \    {\n        sum += nums[end];\n        if (sum < minSum)\n        {\n    \
    \        minSum = sum;\n        }\n        if (sum >= 0L)\n        {\n       \
    \     while (sum >= 0L)\n            {\n                sum -= nums[start];\n\
    \                start++;\n            }\n        }\n        end++;\n    }\n \
    \   return minSum;\n}", "{\n    long minSum = long.max;\n    long sum = 0L;\n\
    \    foreach(n; nums) \n    {\n        sum += n;\n        minSum = min(minSum,\
    \ sum);\n        if(sum < 0L) \n        {\n            sum = 0L;\n        }\n\
    \    }\n    return minSum;\n}", "{\n    long minSum=nums[0];\n    long sum=0;\n\
    \    foreach(num;nums)\n    {\n        sum+=num;\n        minSum=min(minSum,sum);\n\
    \        if(sum<0)\n            sum=0;\n    }\n    return minSum;\n}\n//long minSubArraySum1(long[]\
    \ nums) \n//{\n//    size_t n=nums.length;\n//    long[] sums=new long[n+1];\n\
    //    sums[0]=0;\n//    for(size_t i=0;i<n;i++)\n//        sums[i+1]=sums[i]+nums[i];\n\
    //    long sum=long.max;\n//    for(size_t i=0;i<n;i++)\n//        for(size_t\
    \ j=i+1;j<=n;j++)\n//            sum=min(sum,sums[j]-sums[i]);\n//    return sum;\n\
    //}", "{\n    long minSum = long.max;\n    long sum = 0L;\n    foreach(i, v; nums)\n\
    \    {\n        sum += v;\n        minSum = min(minSum, sum);\n        if(sum\
    \ > 0L)\n            sum = 0L;\n    }\n    return minSum;\n}", "{\n    auto minsum\
    \ = nums[0];\n    auto sum = nums[0];\n    foreach(i, num; nums[1..$]) \n    {\n\
    \        if (sum < 0) \n        {\n            sum = 0;\n        }\n        sum\
    \ += num;\n        minsum = min(minsum, sum);\n    }\n    return minsum;\n}",
  "{\n    long minSum = long.max;\n    long runningSum = 0L;\n    for (int i = 0;\
    \ i < nums.length; i++)\n    {\n        runningSum += nums[i];\n        minSum\
    \ = min(minSum, runningSum);\n        if (runningSum > 0)\n            runningSum\
    \ = 0;\n    }\n    return minSum;\n}\n/*\n    Note:\n        An array is a linear\
    \ collection of objects. The elements of an array \n        can be any type of\
    \ object.", "{\n    long minSum = long.max;\n    long sum = 0L;\n    foreach(long\
    \ val; nums) \n    {\n        sum += val;\n        if (sum < minSum) \n      \
    \  {\n            minSum = sum;\n        }\n        if (sum > 0L) \n        {\n\
    \            sum = 0L;\n        }\n    }\n    return minSum;\n}", "{\n    long\
    \ min = nums[0];\n    for (long x = 0; x < nums.length; x++)\n    {\n        if\
    \ (nums[x] < min)\n        {\n            min = nums[x];\n        }\n    }\n \
    \   return min;\n}", "{\n    long minSum = long.max;\n    long curSum = 0L;\n\
    \    foreach(var num; nums)\n    {\n        curSum += num;\n        minSum = min(minSum,\
    \ curSum);\n        if(curSum > 0L)\n            curSum = 0L;\n    }\n    return\
    \ minSum;\n}", "{\n    auto min = nums[0];\n    auto cur = nums[0];\n    for (auto\
    \ i = 1; i < nums.length; i++) \n    {\n        cur = min(cur + nums[i], nums[i]);\n\
    \        min = min(min, cur);\n    }\n    return min;\n}", "{\n    long min_ =\
    \ nums[0];\n    long sum_ = nums[0];\n    foreach(int i, num; 1 .. nums.length)\
    \ \n    {\n        if (sum_ < 0)\n            sum_ = 0;\n        sum_ += num;\n\
    \        min_ = min(min_, sum_);\n    }\n    return min_;\n}", "{\n    long sum\
    \ = 0;\n    long minSum = long.max;\n    for (int i = 0; i < nums.length; i++)\n\
    \    {\n        sum += nums[i];\n        minSum = min(minSum, sum);\n        if\
    \ (sum > 0)\n            sum = 0;\n    }\n    return minSum;\n}", "{\n    auto\
    \ minSum = nums[0];\n    auto currSum = nums[0];\n    foreach(i, n; nums[1..$])\n\
    \    {\n        if(currSum + n < n)\n            currSum = n;\n        else\n\
    \            currSum += n;\n        if(currSum < minSum)\n            minSum =\
    \ currSum;\n    }\n    return minSum;\n}", "{\n    long res = nums[0];\n    long\
    \ sum = nums[0];\n    int i = 1;\n    for (; i < nums.length; i++)\n    {\n  \
    \      if (sum > 0)\n        {\n            sum = nums[i];\n        }\n      \
    \  else\n        {\n            sum += nums[i];\n        }\n        res = min(res,\
    \ sum);\n    }\n    return res;\n}", "{\n    enum min = INT_MAX;\n    long sum\
    \ = 0L;\n    long subSum = 0L;\n    foreach(i, x; nums)\n    {\n        sum +=\
    \ x;\n        min = min(min, sum - subSum);\n        subSum = min(subSum, sum);\n\
    \    }\n    return min;\n}", "{\n  auto len = nums.length;\n  auto l = 0;\n  auto\
    \ r = 0;\n  auto sum = 0L;\n  auto minSum = nums[0];\n  while (r < len)\n  {\n\
    \    sum += nums[r];\n    minSum = min(minSum, sum);\n    if (sum > 0)\n    {\n\
    \      sum = 0;\n      l = r + 1;\n    }\n    r++;\n  }\n  return minSum;\n}\n\
    ```", "{\n    long max = nums[0];\n    long sum = 0;\n    foreach(idx, n; nums)\
    \ {\n        sum += n;\n        if(sum > max)\n            max = sum;\n      \
    \  if(sum < 0)\n            sum = 0;\n    }\n    return max;\n}", "{\n    // initialise\
    \ minimum sum value\n    long minSum = long.max;\n    // initialise current sum\n\
    \    long currentSum = 0L;\n    // iterate over each item\n    foreach(i; 0 ..\
    \ nums.length) \n    {\n        // update current sum with each item\n       \
    \ currentSum += nums[i];\n        // if current sum is less than minSum\n    \
    \    if(currentSum < minSum) \n        {\n            // set minSum to current\
    \ sum\n            minSum = currentSum;\n        }\n        // if current sum\
    \ is negative\n        if(currentSum < 0L) \n        {\n            // reset current\
    \ sum to 0\n            currentSum = 0L;\n        }\n    }\n    // return minimum\
    \ sum value\n    return minSum;\n}", "{\n    long res = long.max;\n    long temp\
    \ = 0L;\n    auto len = nums.length;\n    if (len == 0) return res;\n    foreach\
    \ (val; nums) \n    {\n        temp += val;\n        res = min(res, temp);\n \
    \       if (temp > 0) temp = 0;\n    }\n    return res;\n}", "{\n    if (nums.length\
    \ == 0) \n    {\n        return 0;\n    }\n    long sum = 0;\n    long minSum\
    \ = long.max;\n    foreach (i, x; nums) \n    {\n        sum += x;\n        if\
    \ (i >= 1) \n        {\n            minSum = min(minSum, sum);\n        }\n  \
    \  }\n    return minSum;\n}", "{\n    long min = nums[0];\n    long sum = 0;\n\
    \    int i;\n    foreach(num; nums)\n    {\n        sum += num;\n        min =\
    \ min(min, sum);\n        if(sum > 0)\n            sum = 0;\n    }\n    return\
    \ min;\n}", "{\n    if (nums.length == 0) return 0;\n    long sum = 0, min = nums[0];\n\
    \    foreach (i; 0 .. nums.length)\n    {\n        sum += nums[i];\n        if\
    \ (sum < min) min = sum;\n        if (sum > 0) sum = 0;\n    }\n    return min;\n\
    }\n/*\n    Given an array of integers nums and a positive integer k, find whether\
    \ it's possible to\n    divide this array into k non-empty subsets whose sums\
    \ are all equal.\n    Example\n    >>> canPartitionKSubsets([4L, 3L, 2L, 3L, 5L,\
    \ 2L], 3L)\n    true\n    >>> canPartitionKSubsets([1L, 2L, 3L, 4L], 2L)\n   \
    \ false\n    >>> canPartitionKSubsets([1L, 2L, 3L, 4L], 3L)\n    false\n    >>>\
    \ canPartitionKSubsets([1L, 2L, 3L, 4L], 4L)\n    true\n*/", "{\n    long min\
    \ = nums[0];\n    long cur = nums[0];\n    for (int i = 1; i < nums.length; i++)\n\
    \    {\n        cur = min(cur + nums[i], nums[i]);\n        min = min(min, cur);\n\
    \    }\n    return min;\n}", "{\n    auto min_sum = typeof(nums[0])();\n    auto\
    \ sum = typeof(nums[0])();\n    auto min_sum_ret = typeof(nums[0])();\n    foreach(i,\
    \ val; nums)\n    {\n        if(i == 0)\n        {\n            min_sum = nums[i];\n\
    \            sum = nums[i];\n            min_sum_ret = nums[i];\n        }\n \
    \       else\n        {\n            min_sum = min(min_sum + nums[i], nums[i]);\n\
    \            sum += nums[i];\n            min_sum_ret = min(min_sum_ret, min_sum);\n\
    \        }\n    }\n    return min_sum_ret;\n}", "{\n  // Type alias for built-in\
    \ tuple\n  auto intPair = Tuple!(int,int);\n  // Using Algorithm to reduce\n \
    \ return nums.reduce!((a, b) => Tuple(a[0] + b, a[1] + 1), Tuple(0, 0)).map!((a,\
    \ b) => a / b).min;\n}", "{\n    long result = long.max;\n    long sum = 0L;\n\
    \    for (int i = 0; i < nums.length; i++) \n    {\n        sum += nums[i];\n\
    \        result = min(result, sum);\n        if (sum > 0) \n        {\n      \
    \      sum = 0;\n        }\n    }\n    return result;\n}\n```", "{\n    long[]\
    \ minSum = new long[nums.length];\n    minSum[0] = nums[0];\n    long minValue\
    \ = minSum[0];\n    for (int i = 1; i < nums.length; i++)\n    {\n        minSum[i]\
    \ = min(nums[i], minSum[i - 1] + nums[i]);\n        minValue = min(minValue, minSum[i]);\n\
    \    }\n    return minValue;\n}", "{\n    long sum = 0;\n    long min_sum = long.max;\n\
    \    for (in out i = 0; i < nums.length; i++) \n    {\n        sum += nums[i];\n\
    \        if (sum < min_sum)\n            min_sum = sum;\n        if (sum > 0)\n\
    \            sum = 0;\n    }\n    return min_sum;\n}", "{\n    long min = nums[0];\n\
    \    long currentSum = 0;\n    for (size_t i = 0; i < nums.length; i++)\n    {\n\
    \        currentSum += nums[i];\n        if (currentSum < min)\n        {\n  \
    \          min = currentSum;\n        }\n        if (currentSum > 0)\n       \
    \ {\n            currentSum = 0;\n        }\n    }\n    return min;\n}\n/*\n \
    \   Example\n    >>> maxSubArraySum([2L, 3L, 4L, 1L, 2L, 4L])\n    14L\n    >>>\
    \ maxSubArraySum([-1L, -2L, -3L])\n    -1L\n*/\nlong maxSubArraySum(long[] nums)\
    \ \n{\n    long max = nums[0];\n    long currentSum = 0;\n    for (size_t i =\
    \ 0; i < nums.length; i++)\n    {\n        currentSum += nums[i];\n        if\
    \ (currentSum > max)\n        {\n            max = currentSum;\n        }\n  \
    \      if (currentSum < 0)\n        {\n            currentSum = 0;\n        }\n\
    \    }\n    return max;\n}\n/*\n    KMP search algorithm\n    Example\n    >>>\
    \ kmp(\"pattern\", \"xabxacxabxac\")\n    [0L, 8L]\n    >>> kmp(\"pattern\", \"\
    patternpatternpattern\")\n    [0L, 8L, 16L]\n    >>> kmp(\"pPp\", \"pPp\")\n \
    \   [0L]\n    >>> kmp(\"pPp\", \"pPpP\")\n    [0L, 2L]\n    >>> kmp(\"xabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxabxab",
  "{\n    long min = nums[0];\n    long sum = nums[0];\n    long[long] list;\n   \
    \ long[long] list1;\n    auto it = nums.save.split.dropOne.dup;\n    auto rit\
    \ = nums.save.split.dropOne.dup.assumeSorted.retro;\n    if (rit.front > 0 &&\
    \ it.front > 0) \n    {\n        list ~= it.front;\n        list1 ~= rit.front;\n\
    \    }\n    foreach (n; it) \n    {\n        if (n > 0) \n        {\n        \
    \    list ~= n;\n        }\n        sum += n;\n        if (sum < min) \n     \
    \   {\n            min = sum;\n        }\n    }\n    sum = nums[0];\n    foreach\
    \ (n; rit) \n    {\n        if (n > 0) \n        {\n            list1 ~= n;\n\
    \        }\n        sum += n;\n        if (sum < min) \n        {\n          \
    \  min = sum;\n        }\n    }\n    if (list.length > 0 && list1.length > 0)\
    \ \n    {\n        auto it2 = list.dup;\n        auto rit2 = list1.dup.assumeSorted.retro;\n\
    \        long a = it2.front;\n        long b = rit2.front;\n        if (a + b\
    \ < min) \n        {\n            min = a + b;\n        }\n        while (it2.popFront()\
    \ && rit2.popFront()) \n        {\n            a = it2.front;\n            b =\
    \ rit2.front;\n            if (a + b < min) \n            {\n                min\
    \ = a + b;\n            }\n        }\n    }\n    return min;\n}", "{\n    return\
    \ nums.length == 0 ? 0 : nums.min();\n}\n/*\n    Given a string s, find the largest\
    \ palindrome in it. For example,\n    >>> largestPalindrome(\"aabcdcb\")\n   \
    \ 'bcdcb'\n    >>> largestPalindrome(\"bananas\")\n    'anana'\n    >>> largestPalindrome(\"\
    hyderabad\")\n    'hyderahyd'\n    >>> largestPalindrome(\"flyers\")\n    'None'\n\
    \    \n*/\nstring largestPalindrome(string s) \n{\n    import std.algorithm :\
    \ equal;\n    import std.range : iota;\n    import std.string : join;\n    import\
    \ std.conv : to;\n    string largestPalindrome(string s) \n    {\n        int\
    \ longestPalindromeLen(string s)\n        {\n            import std.range : iota;\n\
    \            import std.conv : to;\n            auto mid = s.length / 2;\n   \
    \         int isPalindrome(int a, int b)\n            {\n                for (auto\
    \ i = a, j = b; i < j; i++, j--) \n                {\n                    if (s[i]\
    \ != s[j])\n                        return 0;\n                }\n           \
    \     return b - a + 1;\n            }\n            int result = 0;\n        \
    \    if (s.length % 2)\n            {\n                result = isPalindrome(mid\
    \ - 1, mid + 1);\n            }\n            else\n            {\n           \
    \     result = isPalindrome(mid - 1, mid);\n            }\n            if (result)\n\
    \                return result;\n            foreach (offset; iota(1, mid + 1))\n\
    \            {\n                int len1 = isPalindrome(mid - offset, mid + offset\
    \ - 1);\n                int len2 = isPalindrome(mid - offset + 1, mid + offset);\n\
    \                if (len1 > result)\n                    result = len1;\n    \
    \            if (len2 > result)\n                    result = len2;\n        \
    \    }\n            return result;\n        }\n        auto longestPalindrome\
    \ = longestPalindromeLen(s);\n        if (longestPalindrome <=", "{\n    long\
    \ length = nums.length;\n    if (length == 0) return 0;\n    else if (length ==\
    \ 1) return nums[0];\n    long min = nums[0];\n    long sum = 0;\n    foreach\
    \ (i; 0 .. length)\n    {\n        sum += nums[i];\n        if (sum < min) min\
    \ = sum;\n        if (sum > 0) sum = 0;\n    }\n    return min;\n}", "{\n    long\
    \ minSum = long.max;\n    long sum = 0L;\n    foreach(sum;\n            accumulate!(\"\
    a + b\")(nums).dropOne().dropOne())\n    {\n        minSum = min(minSum, sum);\n\
    \    }\n    return minSum;\n}", "{\n    long minSum = nums[0];\n    long sum =\
    \ 0;\n    foreach(n; nums)\n    {\n        sum += n;\n        minSum = min(minSum,\
    \ sum);\n        if(sum > 0)\n            sum = 0;\n    }\n    return minSum;\n\
    }", "{ \n    long result = nums[0]; \n    long sum = nums[0]; \n    size_t left\
    \ = 0;\n    for (size_t i = 1; i < nums.length; i++) \n    { \n        if (sum\
    \ > 0) \n            sum = nums[i]; \n        else\n            sum += nums[i];\
    \ \n        if (sum < result)\n        {\n            result = sum;\n        \
    \    left = i;\n        }\n    } \n    return result; \n}", "{\n    long sum =\
    \ 0L;\n    long maxSum = nums[0];\n    for (int i = 0; i < nums.length; i++) \n\
    \    {\n        if (sum > 0)\n            sum += nums[i];\n        else\n    \
    \        sum = nums[i];\n        maxSum = min(maxSum, sum);\n    }\n    return\
    \ maxSum;\n}\n// EXPLANATION:\n/*\n    for each element in the array keep track\
    \ of the current sum.\n    If this sum is negative, set it to zero and start a\
    \ new sum.\n    The running minimum will be the minimum of the sum at each\n \
    \   iteration.\n    If sum is negative and we add it to nums[i], we will not be\n\
    \    able to get a smaller number.\n    If sum is positive and we add it to nums[i],\
    \ we will be able\n    to get a smaller number.\n    This is because there are\
    \ negative numbers in the array.\n*/\n// TEST CASES:\n/*\n    >>> minSubArraySum([2L,\
    \ 3L, 4L, 1L, 2L, 4L])\n    1L\n    >>> minSubArraySum([-1L, -2L, -3L])\n    -6L\n\
    \    >>> minSubArraySum([-1L, 2L, 3L, 4L, -5L, 2L, 1L, 6L, -4L, 5L])\n    -3L\n\
    \    >>> minSubArraySum([-1L, -3L, -5L, -7L, -2L, -4L, -6L, -9L, -10L, -12L])\n\
    \    -45L\n    >>> minSubArraySum([0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L])\n\
    \    0L\n    >>> minSubArraySum([0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0", "{\n    long minSum = nums[0];\n\
    \    long currentSum = 0;\n    foreach(idx, val; nums) \n    {\n        currentSum\
    \ += val;\n        if(currentSum < minSum) \n        {\n            minSum = currentSum;\n\
    \        }\n        if(currentSum > 0) \n        {\n            currentSum = 0;\n\
    \        }\n    }\n    return minSum;\n}\n//\nlong minSubArraySumTest() \n{\n\
    \    import std.stdio : writeln;\n    import std.algorithm : sort;\n    writeln(minSubArraySum([2L,\
    \ 3L, 4L, 1L, 2L, 4L]));\n    writeln(minSubArraySum([-1L, -2L, -3L]));\n    writeln(minSubArraySum([1L,\
    \ 1L, 1L, 1L, 1L, 1L]));\n    writeln(minSubArraySum([1L, 2L, 3L, 4L, 5L, 6L]));\n\
    \    writeln(minSubArraySum([1L, -1L, 1L, -1L, 1L, -1L]));\n    writeln(minSubArraySum([1L,\
    \ -1L, 1L, -1L, 1L, 0L]));\n    writeln(minSubArraySum([1L, -1L, 1L, -1L, 1L,\
    \ 2L]));\n    writeln(minSubArraySum([1L, -1L, 1L, -1L, 1L, 1L]));\n    return\
    \ 0;\n}\n//\n//\nlong minSubArraySumTestUnit() \n{\n    import std.stdio : writeln;\n\
    \    import std.typecons : Tuple;\n    import std.meta : AliasSeq;\n    //\n \
    \   auto testFunc = function(alias f) \n    {\n        auto args = Tuple!(long[])([[2L,\
    \ 3L, 4L, 1L, 2L, 4L], [-1L, -2L, -3L], [1L, 1L, 1L, 1L, 1L, 1L], [", "{ \n  \
    \  long result = long.min; \n    long sum = 0L; \n    size_t left = 0L; \n   \
    \ foreach (num; nums) { \n        sum += num; \n        result = min(result, sum);\
    \ \n        if (sum > 0L) { \n            sum = 0L; \n            left = nums.length;\
    \ \n        } \n    } \n    return result; \n} \n// class Solution {\n// public:\n\
    //     long minSubArraySum(vector<long>& nums) {\n//         long min_sum = std::numeric_limits<long>::max();\n\
    //         long sum = 0;\n//         size_t left = 0;\n        \n//         for\
    \ (size_t i = 0; i < nums.size(); ++i) {\n//             sum += nums[i];\n// \
    \            min_sum = std::min(min_sum, sum);\n//             if (sum > 0) {\n\
    //                 sum = 0;\n//                 left = i + 1;\n//            \
    \ }\n//         }\n        \n//         return min_sum;\n//     }\n// };", "{\n\
    \    long[] minSums = new long[nums.length];\n    // Initialize minSums with the\
    \ first element in nums\n    minSums[0] = nums[0];\n    for (size_t i = 1; i <\
    \ nums.length; i++) \n    {\n        // For each index, either add the nums[i]\
    \ to the previous\n        // minSum or just keep the previous minSum\n      \
    \  minSums[i] = min(minSums[i - 1] + nums[i], nums[i]);\n    }\n    return min(minSums);\n\
    }", "{\n    long len = nums.length;\n    if (len == 0)\n        return 0;\n  \
    \  long minSum = nums[0];\n    long sum = nums[0];\n    long max = nums[0];\n\
    \    for (long i = 1; i < len; i++) \n    {\n        sum += nums[i];\n       \
    \ if (nums[i] > max)\n            max = nums[i];\n        if (sum < minSum)\n\
    \            minSum = sum;\n    }\n    if (max < 0)\n        return max;\n   \
    \ return minSum;\n}\n/*\n    assert(minSubArraySum([2L, 3L, 4L, 1L, 2L, 4L]) ==\
    \ 1L);\n    assert(minSubArraySum([-1L, -2L, -3L]) == -6L);\n    assert(minSubArraySum([])\
    \ == 0L);\n    assert(minSubArraySum([1L, 2L, 3L, 4L, 5L]) == 1L);\n    assert(minSubArraySum([5L,\
    \ 4L, 3L, 2L, 1L]) == 1L);\n    assert(minSubArraySum([5L, 4L, 3L, 2L, 1L, 6L])\
    \ == 1L);\n    assert(minSubArraySum([1L, -2L, 3L, 10L, -4L, 7L, 2L, -5L]) ==\
    \ -6L);\n    assert(minSubArraySum([-1L, -2L, -3L, -4L, -5L]) == -15L);\n    assert(minSubArraySum([-5L,\
    \ -4L, -3L, -2L, -1L]) == -15L);\n    assert(minSubArraySum([-5L, -4L, -3L, -2L,\
    \ -1L, -6L]) == -21L);\n    assert(minSubArraySum([-1L, -2L, -3L, -10L, -4L, -7L,\
    \ -2L, -5L]) == -42L);\n    assert(minSubArraySum([1L, 2L", "{\n    if (nums.length\
    \ < 1) \n    {\n        return 0L;\n    }", "{\n    long result = nums[0L];\n\
    \    long currentSum = nums[0L];\n    foreach (i, e; nums[1L .. $]) \n    {\n\
    \        currentSum = min(currentSum + e, e);\n        result = min(result, currentSum);\n\
    \    }\n    return result;\n}", "{\n    if (nums.length == 0) return 0;\n    long\
    \ sum = nums[0];\n    long min = sum;\n    for (int i = 1; i < nums.length; i++)\
    \ \n    {\n        sum = min(sum + nums[i], nums[i]);\n        min = min(min,\
    \ sum);\n    }\n    return min;\n}", "{ \n    auto n = nums.length; \n    auto\
    \ s = n.iota.map!((i) => nums[i..n].sum).array; \n    return s.min; \n}\n ", "{\n\
    \    long mins = long.max;\n    foreach(i; 0 .. nums.length) \n    {\n       \
    \ long sum = 0L;\n        foreach(j; i .. nums.length) \n        {\n         \
    \   sum += nums[j];\n            mins = min(mins, sum);\n        }\n    }\n  \
    \  return mins;\n}", "{\n    if (nums.length == 0) \n    {\n        return 0;\n\
    \    }\n    long[] dp = new long[nums.length];\n    dp[0] = nums[0];\n    for\
    \ (int i = 1; i < nums.length; i++) \n    {\n        dp[i] = min(dp[i - 1] + nums[i],\
    \ nums[i]);\n    }\n    return dp.min;\n}", "{ \n    long s = 0L;\n    auto m\
    \ = nums[0];\n    foreach(n; nums)\n    {\n        s += n;\n        m = min(m,\
    \ s);\n        s = min(s, 0L);\n    }\n    return m;\n}", "{\n    auto minSum\
    \ = nums[0];\n    auto sum = 0L;\n    foreach(i, elem; nums)\n    {\n        sum\
    \ += elem;\n        if(sum < minSum)\n            minSum = sum;\n        if(sum\
    \ > 0)\n            sum = 0;\n    }\n    return minSum;\n}\n/*\n    Given a list\
    \ of integers,\n    return a new list, by inserting the median into the list.\n\
    \    >>> median([1, 2, 3, 4, 5])\n    [1, 2, 3, 3, 4, 5]\n    >>> median([4, 5,\
    \ 6, 7, 8])\n    [4, 5, 6, 7, 7, 8]\n    >>> median([1, 2, 3, 4, 7])\n    [1,\
    \ 2, 3, 4, 4, 7]\n    >>> median([3, 4, 5, 6, 7])\n    [3, 4, 5, 5, 6, 7]\n*/\n\
    long[] median(long[] arr)\n{\n    auto d = arr.dup;\n    auto r = arr.dup;\n \
    \   auto m = d.length / 2;\n    auto n = d.length;\n    if(n == 1)\n        return\
    \ [d[0]];\n    d[m] = d[m - 1];\n    d[m - 1] = d[m];\n    return d;\n}\n/*\n\
    \    Given a list of integers, return the sum of all elements.\n    >>> sumNums([1,\
    \ 2, 3, 4, 5])\n    15\n    >>> sumNums([3, 4, 5, 6, 7])\n    25\n    >>> sumNums([1,\
    \ 2, 3, 4, 7])\n    17\n    >>> sumNums([3, 4, 5, 6, 7])\n    25\n*/\nlong sumNums(long[]\
    \ arr)\n{\n    auto sum = 0L;\n    foreach(a; arr)\n        sum += a;\n    return\
    \ sum;\n}\n/*\n    Given a list of integers, return the product of all elements.\n\
    \    >>> prodNums([1, 2, 3, 4, 5])\n    120\n", "{\n    if (all(i => i > 0L)(nums))\n\
    \        return front(nums);\n    else if (all(i => i < 0L)(nums))\n        return\
    \ back(nums);\n    else\n    {\n        long[] temp = nums.split.map!(e => reduce!(min)(e)).array;\n\
    \        return back(temp);\n    }\n}\n/*Test*/", "{\n    long[] (long, long)[]\
    \ dp = new long[$][2];\n    long sum = 0L;\n    long ret = 0L;\n    dp[0][0] =\
    \ 0L;\n    dp[0][1] = 0L;\n    for (int i = 0; i < nums.length; i++)\n    {\n\
    \        sum += nums[i];\n        dp[i][0] = sum;\n        if (i > 0)\n      \
    \  {\n            dp[i][1] = min(dp[i-1][1], dp[i-1][0]);\n        }\n       \
    \ ret = min(ret, dp[i][0] - dp[i][1]);\n    }\n    return ret;\n}", "{\n    //\
    \ your code goes here\n    long min_so_far = nums[0];\n    long sum = 0;\n   \
    \ foreach(i; 0..nums.length)\n    {\n        if(sum > 0)\n            sum = nums[i];\n\
    \        else\n            sum += nums[i];\n        min_so_far = min(min_so_far,\
    \ sum);\n    }\n    return min_so_far;\n}", "{\n    long[] subArraySums = new\
    \ long[nums.length];\n    for (int i = 0; i < nums.length; i++) \n    {\n    \
    \    long subSum = 0;\n        for (int j = i; j < nums.length; j++) \n      \
    \  {\n            subSum += nums[j];\n            subArraySums[i] = min(subArraySums[i],\
    \ subSum);\n        }\n    }\n    return min(subArraySums);\n}", "{\n    long\
    \ minSum = long.max;\n    long sum = 0L;\n    for (long i = 0L; i < nums.length;\
    \ i++)\n    {\n        for (long j = i; j < nums.length; j++)\n        {\n   \
    \         sum += nums[cast(size_t)j];\n            minSum = min(minSum, sum);\n\
    \        }\n        sum = 0L;\n    }\n    return minSum;\n}\n/*\n    Output\n\
    \    1L\n    -6L\n*/", "{ \n    long minSum = nums[0]; \n    long currentSum =\
    \ nums[0]; \n  \n    foreach (i, val; nums[1 .. $]) \n    { \n        currentSum\
    \ = min(currentSum + val, val); \n        minSum = min(minSum, currentSum); \n\
    \    } \n  \n    return minSum; \n} \n ", "{\n    long minSum = long.max;\n  \
    \  long curSum = 0L;\n    auto len = nums.length;\n    for (long i = 0L; i < len;\
    \ i++)\n    {\n        curSum += nums[i];\n        if (curSum < minSum)\n    \
    \    {\n            minSum = curSum;\n        }\n        if (curSum > 0L)\n  \
    \      {\n            curSum = 0L;\n        }\n    }\n    return minSum;\n}\n ",
  "{\n    long m = nums[0];\n    long r = nums[0];\n    foreach(i; 1..nums.length)\n\
    \    {\n        m = max(nums[i], m + nums[i]);\n        r = min(r, m);\n    }\n\
    \    return r;\n}", "{\n    long sum = 0L;\n    long minSum = long.max;\n    for\
    \ (long v : nums) \n    {\n        sum += v;\n        minSum = min(minSum, sum);\n\
    \        if (sum > 0L) sum = 0L;\n    }\n    return minSum;\n}", "{\n    long\
    \ result = long.max;\n    long sum = 0L;\n    foreach (n; nums)\n    {\n     \
    \   sum += n;\n        if (sum < result)\n            result = sum;\n        if\
    \ (sum > 0L)\n            sum = 0L;\n    }\n    return result;\n}\n/*\n    This\
    \ algorithm is O(n). First we calculate the sum of\n    the subarray using a sliding\
    \ window. If the sum is less than\n    result, then we update result to be equal\
    \ to sum. Finally\n    we check if sum is greater than 0. If so, we reset the\
    \ sum\n    to 0.\n*/", "{\n    long minSum = nums[0];\n    long runningSum = nums[0];\n\
    \    foreach(num; nums[1..$])\n    {\n        runningSum = min(runningSum + num,\
    \ num);\n        minSum = min(minSum, runningSum);\n    }\n    return minSum;\n\
    }", "{\n    long sum = 0;\n    long min = int.max;\n    long[] sums = new long[nums.length];\n\
    \    foreach(i, el; nums)\n    {\n        sum += el;\n        if(sum < min)\n\
    \            min = sum;\n        sums[i] = sum;\n    }\n    // d_print(sums);\n\
    \    sum = int.max;\n    for(long i = nums.length - 1; i >= 0; i--)\n    {\n \
    \       if(sums[i] > min)\n            min = sums[i];\n        if(sum > min)\n\
    \            sum = min;\n    }\n    return sum;\n}", "{\n    long minSum = long.max;\n\
    \    long sum = 0L;\n    foreach(i, elem; nums)\n    {\n        sum += elem;\n\
    \        if(sum < minSum)\n            minSum = sum;\n        if(sum > 0L)\n \
    \           sum = 0L;\n    }\n    return minSum;\n}", "{\n    long prevMin = 0;\n\
    \    long minSum = long.max;\n    long sum = 0;\n    foreach (index, num; nums)\n\
    \    {\n        sum += num;\n        minSum = min(minSum, sum - prevMin);\n  \
    \      prevMin = min(prevMin, sum);\n    }\n    return minSum;\n}\n/*\n    Given\
    \ an array of integers, find the maximum sum of a subsequence\n    with the constraint\
    \ that no 2 numbers in the sequence should be adjacent\n    in the array. So 3\
    \ 2 7 10 should return 13 (sum of 3 and 10) or 3 2 5 10 7\n    should return 15\
    \ (sum of 3, 5 and 7).\n    Example\n    >>> maxSumNonAdjacent([1L, 2L, 3L, 4L,\
    \ 5L])\n    8L\n    >>> maxSumNonAdjacent([2L, 3L, 4L, 1L, 2L, 4L])\n    8L\n\
    \    >>> maxSumNonAdjacent([1L, 1L, 1L, 1L, 1L])\n    2L\n    >>> maxSumNonAdjacent([1L,\
    \ -2L, 3L, 4L, -5L])\n    7L\n*/\nlong maxSumNonAdjacent(long[] arr)\n{\n    long[]\
    \ dp = arr.dup;\n    foreach (i; 1 .. dp.length)\n    {\n        if (i < 2)\n\
    \        {\n            dp[i] = max(dp[i - 1], dp[i]);\n        }\n        else\n\
    \        {\n            dp[i] = max(dp[i - 1], dp[i] + dp[i - 2]);\n        }\n\
    \    }\n    return dp[$ - 1];\n}\n/*\n    Given an array of integers nums, find\
    \ the contiguous subarray (containing at least one number)\n    which has the\
    \ largest sum and return its sum.\n    >>> maxSubArray([1L, 2L, 3L, 4L, 5L])\n\
    \    15L\n    >>> maxSubArray([-1L, -2L, -3L, -4L, -5L])\n    -1L", "{\n    long\
    \ m = nums[0];\n    long s = nums[0];\n    foreach(n; nums[1..$])\n    {\n   \
    \     s = max(s + n, n);\n        m = min(m, s);\n    }\n    return m;\n}", "{\n\
    \    long minSum = nums[0];\n    long currSum = nums[0];\n    for (size_t i =\
    \ 1; i < nums.length; i++) \n    {\n        currSum = max(nums[i], currSum + nums[i]);\n\
    \        minSum = min(minSum, currSum);\n    }\n    return minSum;\n}\n//\nsize_t\
    \ findIndexesOfGivenSum(long[] a, size_t sum)\n{\n    size_t currSum = a[0];\n\
    \    size_t start = 0;\n    size_t i;\n    for (i = 1; i <= a.length; i++) \n\
    \    {\n        while (currSum > sum && start < i - 1) \n        {\n         \
    \   currSum = currSum - a[start];\n            start++;\n        }\n        if\
    \ (currSum == sum) \n        {\n            return tuple(start, i - 1);\n    \
    \    }\n        if (i < a.length)\n            currSum = currSum + a[i];\n   \
    \ }\n    return tuple(start, a.length);\n}\n//", "{\n    long sumMin = 0L;\n \
    \   long sumCurrent = 0L;\n    if (nums.length != 0)\n    {\n        sumMin =\
    \ long.max;\n        sumCurrent = 0L;\n        foreach (i; 0..nums.length)\n \
    \       {\n            if (sumCurrent > 0L)\n            {\n                sumCurrent\
    \ += nums[i];\n            }\n            else\n            {\n              \
    \  sumCurrent = nums[i];\n            }\n            if (sumCurrent < sumMin)\n\
    \            {\n                sumMin = sumCurrent;\n            }\n        }\n\
    \    }\n    return sumMin;\n}\n/*", "{\n    return 0L;\n}", "{\n    size_t minLength\
    \ = min(1L, nums.length);\n    long minSum = min(0L, nums.sum());\n    long currentSum\
    \ = 0L;\n    size_t currentLength = 0L;\n    size_t currentBegin = 0L;\n    size_t\
    \ currentEnd = 0L;\n    while (currentEnd < nums.length)\n    {\n        while\
    \ (currentSum >= 0L && currentEnd < nums.length)\n        {\n            if (currentLength\
    \ < minLength)\n            {\n                minLength = currentLength;\n  \
    \              minSum = currentSum;\n            }\n            else if (currentLength\
    \ == minLength && currentSum < minSum)\n            {\n                minSum\
    \ = currentSum;\n            }\n            currentSum += nums[currentEnd];\n\
    \            currentLength++;\n            currentEnd++;\n        }\n        while\
    \ (currentSum < 0L && currentBegin < currentEnd)\n        {\n            currentSum\
    \ -= nums[currentBegin];\n            currentLength--;\n            currentBegin++;\n\
    \        }\n    }\n    return minSum;\n}", "{\n    import std.algorithm.comparison\
    \ : min;\n    if (nums.length == 0) \n    {\n        return 0;\n    }", "{\n \
    \   int n = nums.length;\n    long sum = 0L;\n    long minSum = long.max;\n  \
    \  for (int i = 0; i < n; i++)\n    {\n        sum += nums[i];\n        minSum\
    \ = min(minSum, sum);\n        if (sum > 0)\n            sum = 0;\n    }\n   \
    \ return minSum;\n}", "{\n    long min = nums[0];\n    long sum = nums[0];\n \
    \   foreach(long i, nums[1..$])\n    {\n        sum += i;\n        if(sum < min)\n\
    \            min = sum;\n        if(sum > 0)\n            sum = 0;\n    }\n  \
    \  return min;\n}", "{\n    if (nums.length < 1) return 0;\n    auto minSum =\
    \ nums[0];\n    auto curSum = nums[0];\n    foreach (i, n; nums[1..$]) \n    {\n\
    \        curSum = min(curSum + n, n);\n        minSum = min(minSum, curSum);\n\
    \    }\n    return minSum;\n}\n/*\n    Given a string s, find the longest palindromic\
    \ substring in s.\n    Example\n    >>> longestPalindrome(\"abcabcbb\")\n    \"\
    abcba\"\n    >>> longestPalindrome(\"bbbbb\")\n    \"bbbbb\"\n    >>> longestPalindrome(\"\
    pwwkew\")\n    \"wke\"\n    >>> longestPalindrome(\"cbbd\")\n    \"bb\"\n    >>>\
    \ longestPalindrome(\"a\")\n    \"a\"\n*/\nstring longestPalindrome(string s)\
    \ \n{\n    int n = s.length;\n    string res = \"\";\n    int maxLen = 0;\n  \
    \  foreach (i, ss; s[0..n]) \n    {\n        int l = i;\n        int r = i;\n\
    \        while (r < n && s[r] == s[l]) \n        {\n            r++;\n       \
    \ }\n        l--;\n        while (l >= 0 && r < n && s[l] == s[r]) \n        {\n\
    \            l--;\n            r++;\n        }\n        l++;\n        r--;\n \
    \       if (r - l + 1 > maxLen) \n        {\n            maxLen = r - l + 1;\n\
    \            res = s[l..r + 1];\n        }\n    }\n    return res;\n}\n/*\n  \
    \  Given an array of integers nums, sort the array in ascending order.\n    Example\n\
    \    >>> sort([3L, 2L, 1L])\n    [1L, 2L, 3L]\n    >>> sort([1L, 2L, 3L])\n  \
    \  [1L, 2L, 3L]\n    >>> sort([])\n    []\n*/\nlong[] sort(long[] nums) \n{\n\
    \   ", "{ \n    return nums.length == 0 ? 0 : nums.reduce!\"a + b\".min;\n}",
  "{\n    long acc = 0L;\n    long res = long.max;\n    long[] mins = new long[nums.length];\n\
    \    foreach(i, n; nums) {\n        acc += n;\n        if (acc < res) res = acc;\n\
    \        mins[i] = res;\n    }\n    acc = 0L;\n    for (int i = nums.length -\
    \ 1; i >= 0; i--) {\n        acc += nums[i];\n        if (acc < res) res = acc;\n\
    \        if (i > 0 && acc - mins[i - 1] < res) res = acc - mins[i - 1];\n    }\n\
    \    return res;\n}", "{\n    long min = nums[0];\n    long sum = 0;\n    foreach(num;\
    \ nums)\n    {\n        sum += num;\n        if(sum < min)\n            min =\
    \ sum;\n        if(sum > 0)\n            sum = 0;\n    }\n    return min;\n}",
  "{ \n  int i, len = nums.length;\n  long minSum = 0;\n  long sum = 0;\n  for (i\
    \ = 0; i < len; i++)\n  {\n      sum += nums[i];\n      if (sum > 0)\n       \
    \   sum = 0;\n      else if (sum < minSum)\n          minSum = sum;\n  }\n  return\
    \ minSum;\n}", "{\n    long sum = 0L;\n    long minSum = long.max;\n    foreach(n;\
    \ nums) \n    {\n        sum += n;\n        minSum = min(minSum, sum);\n     \
    \   if(sum > 0L)\n            sum = 0L;\n    }\n    return minSum;\n}", "{\n \
    \   long min = nums[0];\n    long sum = nums[0];\n    for (long i = 1L; i < nums.length;\
    \ i++)\n    {\n        if (sum > 0)\n        {\n            sum = nums[i];\n \
    \       }\n        else\n        {\n            sum += nums[i];\n        }\n \
    \       min = min(min, sum);\n    }\n    return min;\n}", "{\n    auto min = nums[0];\n\
    \    auto temp = 0L;\n    foreach(i, n; nums)\n    {\n        temp += n;\n   \
    \     if(temp < min)\n            min = temp;\n        if(temp > 0)\n        \
    \    temp = 0;\n    }\n    return min;\n}", "{\n    long minSum = long.min;\n\
    \    long sum = 0L;\n    foreach(num; nums) \n    {\n        sum += num;\n   \
    \     minSum = min(minSum, sum);\n        if(sum < 0L) \n        {\n         \
    \   sum = 0L;\n        }\n    }\n    return minSum;\n}", "{\n    long[] minSums\
    \ = new long[nums.length];\n    minSums[0] = nums[0];\n    foreach(i; 1..nums.length)\n\
    \    {\n        minSums[i] = min(minSums[i-1], 0L) + nums[i];\n    }\n    return\
    \ min(minSums);\n}", "{\n    return nums.map!((n) => n < 0 ? n : n * -1L).array().min;\n\
    }", "{\n    if (nums.length == 0) return 0;\n    long[] sums = new long[nums.length];\n\
    \    sums[0] = nums[0];\n    for (long i = 1; i < nums.length; i++) {\n      \
    \  sums[cast(ulong)i] = sums[cast(ulong)i - 1] + nums[cast(ulong)i];\n    }\n\
    \    long minSum = 0;\n    long minSumPos = 0;\n    for (long i = 0; i < nums.length;\
    \ i++) {\n        long sum = sums[cast(ulong)i] - minSum;\n        if (sum < 0)\
    \ {\n            minSum = sums[cast(ulong)i];\n            minSumPos = i;\n  \
    \      }\n    }\n    long minSubArraySum = sums[cast(ulong)nums.length - 1] -\
    \ minSum;\n    return minSubArraySum;\n}", "{ \n    long[] sums = new long[nums.length];\n\
    \    sums[0] = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n       \
    \ sums[i] = sums[i - 1] + nums[i];\n    }\n    long min = sums[0];\n    for (int\
    \ i = 0; i < sums.length; i++) {\n        for (int j = i; j < sums.length; j++)\
    \ {\n            long sum = sums[j] - (i > 0 ? sums[i - 1] : 0);\n           \
    \ if (sum < min) {\n                min = sum;\n            }\n        }\n   \
    \ }\n    return min;\n}", "{\n    long minimumSum = 0L;\n    long currSum = 0L;\n\
    \    size_t minLen = nums.length;\n    size_t currLen = 0LU;\n    bool first =\
    \ true;\n    size_t i = 0LU;\n    while (i < nums.length)\n    {\n        currSum\
    \ += nums[i];\n        ++currLen;\n        while (currSum >= 0L)\n        {\n\
    \            if (first || currSum < minimumSum)\n            {\n             \
    \   minimumSum = currSum;\n                minLen = currLen;\n               \
    \ first = false;\n            }\n            currSum -= nums[i - currLen + 1LU];\n\
    \            --currLen;\n        }\n        ++i;\n    }\n    if (first)\n    {\n\
    \        return 0L;\n    }\n    return minimumSum;\n}\n/*\n    Given a list of\
    \ integers nums, return the size of the longest\n    contiguous sub-array within\
    \ nums such that no adjacent values\n    in the sub-array may be the same.\n \
    \   If no contiguous sub-array exists, return 0.\n    Example\n    >>> maxNonAdjacentSubArrayLen([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 1L, 7L])\n    5L\n    >>> maxNonAdjacentSubArrayLen([1L,\
    \ 1L, 1L, 1L, 1L, 1L, 1L, 1L])\n    0L\n    >>> maxNonAdjacentSubArrayLen([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L])\n    8L\n*/\nlong maxNonAdjacentSubArrayLen(long[]\
    \ nums) \n{\n    size_t nonAdjacentSubArrayLen = 0LU;\n    size_t currLen = 0LU;\n\
    \    size_t i = 0LU;\n    while (i < nums.length)\n    {\n        if (i == 0LU\
    \ || nums[i] != nums[i - 1LU])\n        {\n            currLen = 1LU;\n      \
    \  }\n        else\n        {\n", "{\n    return (nums.length < 1 ? 0L : minSubArraySum(nums,\
    \ 1L));\n}", "{\n    long n = nums.length;\n    long[] dp = new long[n + 1];\n\
    \    dp[0] = 0;\n    long min = dp[0];\n    foreach (i, j; iota(n + 1))\n    {\n\
    \        dp[j] = min(dp[j - 1] + nums[j - 1], nums[j - 1]);\n        min = min(min,\
    \ dp[j]);\n    }\n    return min;\n}\n/*\n    Given a matrix of integers nums,\
    \ find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n\
    \    >>> minSubArraySum([[2L, 3L, 4L, 1L, 2L, 4L], [2L, 3L, 4L, 1L, 2L, 4L]])\n\
    \    1L\n    >>> minSubArraySum([[-1L, -2L, -3L], [-1L, -2L, -3L]])\n    -6L\n\
    \    \n*/\nlong minSubArraySum(long[][] nums) \n{\n    long m = nums.length;\n\
    \    long n = nums[0].length;\n    long[][] dp = new long[m + 1][n + 1];\n   \
    \ dp[0][0] = 0;\n    foreach (i, j; iota(m + 1))\n    {\n        foreach (k, l;\
    \ iota(n + 1))\n        {\n            if (j == 0)\n            {\n          \
    \      dp[j][l] = min(dp[j][l - 1] + nums[j][l - 1], nums[j][l - 1]);\n      \
    \      }\n            else if (l == 0)\n            {\n                dp[j][l]\
    \ = min(dp[j - 1][l] + nums[j - 1][l], nums[j - 1][l]);\n            }\n     \
    \       else\n            {\n                dp[j][l] = min(dp[j - 1][l], dp[j][l\
    \ - 1]) + nums[j - 1][l - 1];\n            }", "{\n    long minSum = std.numeric.min.minValue!long;\n\
    \    long currentSum = 0L;\n    size_t startIndex = 0L;\n    size_t len = nums.length;\n\
    \    foreach(i, x; nums)\n    {\n        currentSum += x;\n        if(currentSum\
    \ < minSum)\n        {\n            minSum = currentSum;\n        }\n        if(currentSum\
    \ > 0L)\n        {\n            currentSum = 0L;\n        }\n    }\n    return\
    \ minSum;\n}", "{\n\tenum numElements = nums.length;\n\tassert(numElements > 0);\n\
    \tlong minSum = nums[0];\n\tlong sum = 0;\n\tforeach(i, element; nums)\n\t{\n\t\
    \tsum += element;\n\t\tif(sum < minSum)\n\t\t\tminSum = sum;\n\t\tif(sum > 0)\n\
    \t\t\tsum = 0;\n\t}\n\treturn minSum;\n}", "{\n    long minSum = long.max;\n \
    \   long sum = 0L;\n    for (long num; nums.length; nums.popFront)\n    {\n  \
    \      num = nums.front;\n        if (num < 0L)\n        {\n            minSum\
    \ = min(sum, minSum);\n        }\n        sum += num;\n        if (sum < 0L)\n\
    \        {\n            sum = 0L;\n        }\n    }\n    if (minSum == long.max)\n\
    \    {\n        minSum = sum;\n    }\n    return minSum;\n}", "{\n    auto isEven\
    \ = (nums[0] & 1) == 0;\n    long min = nums[0];\n    long sum = 0;\n    foreach(i,\
    \ j; iota(nums.length))\n    {\n        sum += nums[j];\n        if(isEven ==\
    \ ((sum & 1) == 0))\n        {\n            if(sum < min)\n                min\
    \ = sum;\n        }\n    }\n    return min;\n}", "{\n    return nums.chunks(2).map!((nums)\
    \ => \n        nums.length == 1 ? nums[0] : min(nums[0], nums[1])\n    ).sum;\n\
    }", "{\n    long min = nums[0], cmin = nums[0];\n    foreach(i, n; nums[1..$])\
    \ \n    {\n        cmin = min(cmin + n, n);\n        min = min(min, cmin);\n \
    \   }\n    return min;\n}", "{\n    long m = nums[0];\n    long sum = 0;\n   \
    \ foreach(i; nums)\n    {\n        sum += i;\n        m = min(m, sum);\n     \
    \   if(sum > 0) sum = 0;\n    }\n    return m;\n}\n/*\n    Given an array arr\
    \ of integers, find the minimum sum of any\n    contiguous sub-array of arr.\n\
    \    Example\n    >>> minimumSubArray([1L, 2L, 3L, 4L, 5L])\n    1L\n    >>> minimumSubArray([-1L,\
    \ -2L, -3L, -4L, -5L])\n    -15L\n    >>> minimumSubArray([1L, 2L, -5L, 1L, 2L,\
    \ -1L])\n    -3L\n*/\nlong minimumSubArray(long[] arr) \n{\n    long sum = 0;\n\
    \    long m = long.max;\n    foreach(i; arr)\n    {\n        sum += i;\n     \
    \   m = min(m, sum);\n        if(sum > 0) sum = 0;\n    }\n    return m;\n}\n\
    /*\n    Given a string s and an integer k, partition s such that every substring\n\
    \    of the partition is a palindrome.\n    Return the minimum cuts needed for\
    \ a palindrome partitioning of s.\n    Example\n    >>> minCutPalindrome(\"aab\"\
    )\n    1\n    >>> minCutPalindrome(\"cdd\")\n    1\n    >>> minCutPalindrome(\"\
    cdd\")\n    1\n    >>> minCutPalindrome(\"fifgbeajcacehiicccfecbfhhgfiiecdcjjffbghdidbhbdbfbfjccgbbdcjheccfbhafehieabbdfeigbiaggchaeghaijfbjhi\"\
    )\n    75\n*/", "{\n    immutable int len = nums.length;\n    long minSum = long.max;\n\
    \    long[] sums = new long[len + 1];\n    for (int i = 0; i < len; i++) \n  \
    \  {\n        sums[i + 1] = sums[i] + nums[i];\n    }\n    for (int i = 0; i <\
    \ len; i++) \n    {\n        for (int j = i + 1; j <= len; j++) \n        {\n\
    \            long sum = sums[j] - sums[i];\n            if (sum < minSum) \n \
    \           {\n                minSum = sum;\n            }\n        }\n    }\n\
    \    return minSum;\n}\nlong minSubArraySum2(long[] nums) \n{\n    long minSum\
    \ = long.max;\n    long sum = 0;\n    for (long num : nums) \n    {\n        sum\
    \ += num;\n        if (sum < minSum) \n        {\n            minSum = sum;\n\
    \        }\n        if (sum > 0) \n        {\n            sum = 0;\n        }\n\
    \    }\n    return minSum;\n}\nlong minSubArraySum3(long[] nums) \n{\n    int\
    \ len = nums.length;\n    long minSum = long.max;\n    long sum = 0;\n    for\
    \ (int i = 0; i < len; i++) \n    {\n        sum += nums[i];\n        if (sum\
    \ < minSum) \n        {\n            minSum = sum;\n        }\n        if (sum\
    \ > 0) \n        {\n            sum = 0;\n        }\n    }\n    return minSum;\n\
    }\nlong minSubArraySum4(long[] nums) \n{\n    immutable int len = nums.length;\n\
    \    long minSum = long.max;\n    long[][] dp = new long[len][len];\n    for (int\
    \ i = 0; i < len; i++) \n    {\n        for (int j = i; j < len; j++) \n     \
    \   {\n            if (i == j) \n            {\n                dp[i][", "{\n\
    \    long minSum = long.max;\n    long sum = 0L;\n    int startIndex = 0;\n  \
    \  for (int i = 0; i < nums.length; i++)\n    {\n        sum += nums[i];\n   \
    \     if (sum < minSum)\n        {\n            minSum = sum;\n        }\n   \
    \     if (sum > 0)\n        {\n            sum = 0;\n        }\n    }\n    return\
    \ minSum;\n}", "{\n    if (nums.length == 0) return 0;\n    if (nums.length ==\
    \ 1) return nums[0];\n    auto minSum = min(nums);\n    auto maxSum = max(nums);\n\
    \    auto sumRange = tuple(minSum, maxSum);\n    long sum = 0;\n    long min =\
    \ nums[0];\n    while (sumRange[0] <= sumRange[1])\n    {\n        long mid =\
    \ (sumRange[0] + sumRange[1]) / 2;\n        for (int i = 0; i < nums.length; i++)\n\
    \        {\n            sum += nums[i];\n            if (sum < mid)\n        \
    \    {\n                sum = 0;\n                continue;\n            }\n \
    \           else\n            {\n                if (sum < min) min = sum;\n \
    \               sum = 0;\n            }\n        }\n        if (sumRange[0] ==\
    \ sumRange[1]) break;\n        sumRange[0] = mid + 1;\n    }\n    return min;\n\
    }", "{\n    long numSliceLen = nums.length;\n    if (numSliceLen == 0UL) return\
    \ 0L;\n    Tuple!(long, long, long) minMax = minMaxElement(nums);\n    long min\
    \ = minMax[0L];\n    long max = minMax[1L];\n    if (min >= 0L) return min;\n\
    \    if (max <= 0L) return max;\n    long[] cumsum = cumsum(nums);\n    long curSum\
    \ = cumsum[0L];\n    long minSum = curSum;\n    immutable long[] indices = cumsum.indices;\n\
    \    foreach (idx, i; indices[1L .. $]) \n    {\n        if (cumsum[i] < minSum)\
    \ minSum = cumsum[i];\n        curSum += nums[i];\n        if (curSum < minSum)\
    \ minSum = curSum;\n    }\n    return minSum;\n}", "{ \n    long minSoFar = 0L;\n\
    \    long minEndingHere = 0L;\n    long minSum = nums[0];\n    foreach(idx, n;\
    \ nums)\n    {\n        minEndingHere = min(minEndingHere + n, 0L);\n        minSoFar\
    \ = min(minSoFar, minEndingHere);\n        minSum = min(minSum, minSoFar);\n \
    \   }\n    return minSum;\n}", "{\n    return typeof(nums).piecewiseSum(nums).min;\n\
    }\nlong minSubArraySumStream(long[] nums) \n{\n    return nums.piecewiseSum.min;\n\
    }\n/*", "{\n    auto sums = sum!((a, b) => a + b)(iota(nums));\n    return min!((a,\
    \ b) => a < b)(sums);\n}", "{\n    long minSum = long.max;\n    long sum = 0L;\n\
    \    foreach(i, v; nums)\n    {\n        sum += v;\n        minSum = min(minSum,\
    \ sum);\n        if(sum > 0L) sum = 0L;\n    }\n    return minSum;\n}", "{\n \
    \   long result = long.max;\n    long sum = 0L;\n    int begin = 0;\n    int end\
    \ = 0;\n    foreach(e; nums)\n    {\n        sum += e;\n        if(sum < result)\n\
    \        {\n            result = sum;\n            end = end + 1;\n        }\n\
    \        if(sum > 0)\n        {\n            sum = 0;\n            begin = end;\n\
    \        }\n    }\n    return result;\n}", "{\n    if (nums.length == 0)\n   \
    \     return 0;\n    if (nums.length == 1)\n        return nums[0];\n    long\
    \ sum = nums[0];\n    long minSum = nums[0];\n    for (long i = 1; i < nums.length;\
    \ i++)\n    {\n        sum = nums[i] + (sum < 0 ? sum : 0);\n        minSum =\
    \ min(sum, minSum);\n    }\n    return minSum;\n}", "{\n    size_t sz = nums.length;\n\
    \    long sum = nums[0];\n    long min = sum;\n    for (size_t i = 1; i < sz;\
    \ i++)\n    {\n        sum += nums[i];\n        if (nums[i] > sum)\n         \
    \   sum = nums[i];\n        if (sum < min)\n            min = sum;\n    }\n  \
    \  return min;\n}\n/*\n    Given a non-empty array nums containing only positive\
    \ integers,\n    find the maximum sum of any contiguous sub-array of length at\
    \ least k.\n    Example\n    >>> maxSubArraySum([-1L, 2L, -4L, 3L, -2L, 4L, -6L,\
    \ -1L, 3L, 2L], 4)\n    5L\n    >>> maxSubArraySum([-1L, 2L, -4L, 3L, -2L, 4L,\
    \ -6L, -1L, 3L, 2L], 2)\n    6L\n*/\nlong maxSubArraySum(long[] nums, size_t k)\
    \ \n{\n    size_t sz = nums.length;\n    long sum = 0;\n    long max = sum;\n\
    \    for (size_t i = 0; i < k; i++)\n        sum += nums[i];\n    max = sum;\n\
    \    for (size_t i = k; i < sz; i++)\n    {\n        sum += nums[i] - nums[i -\
    \ k];\n        if (sum > max)\n            max = sum;\n    }\n    return max;\n\
    }\n/*\n    Given an array of integers nums, return a string that contains the\
    \ numbers in\n    increasing order.\n    Example\n    >>> formatArray([1L, 2L,\
    \ 3L, 4L, 5L])\n    \"1 2 3 4 5\"\n    >>> formatArray([-1L, -2L, -3L, -4L, -5L])\n\
    \    \"-5 -4 -3 -2 -1\"\n*/\nstring formatArray(long[] nums) \n{\n    size_t sz\
    \ = nums.length;\n", "{\n    long minSum = 0L;\n    long currentSum = 0L;\n  \
    \  long min = nums[0];\n    foreach(num; nums)\n    {\n        if(num < min)\n\
    \            min = num;\n    }\n    foreach(num; nums)\n    {\n        currentSum\
    \ += num;\n        if(currentSum < minSum)\n            minSum = currentSum;\n\
    \        if(currentSum < 0)\n            currentSum = 0;\n    }\n    if(minSum\
    \ == 0)\n        return min;\n    return minSum;\n}", "{\n    // Initialization\n\
    \    long result = nums[0];\n    long sum = 0;\n    // Kadane's algorithm\n  \
    \  foreach (num; nums)\n    {\n        sum = max(sum + num, num);\n        result\
    \ = min(result, sum);\n    }\n    return result;\n}", "{\n    auto sum = nums[0L];\n\
    \    auto minSum = nums[0L];\n    foreach (i, num; nums[1L .. $])\n    {\n   \
    \     sum = max(sum + num, num);\n        minSum = min(minSum, sum);\n    }\n\
    \    return minSum;\n}\nlong[][] input = new long[][]{[2L, 3L, 4L, 1L, 2L, 4L],\
    \ [-1L, -2L, -3L]};", "{\n    long[] sum = new long[nums.length];\n    sum[0]\
    \ = nums[0];\n    for (int i = 1; i < nums.length; i++) \n    {\n        sum[i]\
    \ = sum[i - 1] + nums[i];\n    }\n    return min(sum);\n}\npublic class Program\n\
    {\n    public static void Main()\n    {\n        Console.WriteLine(minSubArraySum([2L,\
    \ 3L, 4L, 1L, 2L, 4L]));\n        Console.WriteLine(minSubArraySum([-1L, -2L,\
    \ -3L]));\n    }\n}", "{\n    if (nums.length == 0) return 0;\n    long minSum\
    \ = max;\n    long sum = 0;\n    for (int i = 0; i < nums.length; i++) \n    {\n\
    \        sum += nums[i];\n        minSum = min(minSum, sum);\n        if (sum\
    \ > 0) sum = 0;\n    }\n    return minSum;\n}\nstatic struct DoubleTuple(T, U)\
    \ { T[] arr; U[] arr2; }\nDoubleTuple!long minSubArraySumWithIndex(long[] nums)\n\
    {\n    if (nums.length == 0) return null;\n    long minSum = max;\n    long sum\
    \ = 0;\n    int start = 0;\n    int end = 0;\n    int i = 0;\n    while (i < nums.length)\n\
    \    {\n        if (sum < 0)\n        {\n            sum = nums[i];\n        \
    \    start = i;\n            end = i;\n        }\n        else\n        {\n  \
    \          sum += nums[i];\n            end = i;\n        }\n        minSum =\
    \ min(minSum, sum);\n        i++;\n    }\n    return DoubleTuple!long(nums[start..end\
    \ + 1], new long[]{minSum});\n}", "{\n    if (nums.length == 0) \n    {\n    \
    \    return 0;\n    }\n    long[] dp = new long[nums.length];\n    dp[0] = nums[0];\n\
    \    foreach (i, n; nums[1 .. $]) \n    {\n        dp[i] = min(dp[i - 1] + n,\
    \ n);\n    }\n    return min(dp);\n}\n// int main()\n// {\n//     int[] nums =\
    \ [2, 3, 4, 1, 2, 4];\n//     assert(minSubArraySum(nums) == 1);\n//     nums\
    \ = [-1, -2, -3];\n//     assert(minSubArraySum(nums) == -6);\n//     return 0;\n\
    // }", "{\n    auto minSum = inf;\n    auto curSum = 0L;\n    foreach (i, x; nums)\n\
    \    {\n        curSum += x;\n        minSum = min(minSum, curSum);\n        if\
    \ (curSum > 0)\n            curSum = 0;\n    }\n    return minSum;\n}", "{\n \
    \   /*\n        for(i in 0 .. nums.length-1)\n        {\n            for(j in\
    \ i .. nums.length-1)\n            {\n                sum += nums[j];\n      \
    \          if(sum < minimum)\n                {\n                    minimum =\
    \ sum;\n                }\n            }\n        }\n    */\n    return 0L;\n\
    }\n/*\n    Determine whether a string begins with a capital letter.\n    Example\n\
    \    >>> startsWithCapital(\"John Smith\")\n    true\n    >>> startsWithCapital(\"\
    Lucy Jordan\")\n    true\n    >>> startsWithCapital(\"lucy Jordan\")\n    false\n\
    \    >>> startsWithCapital(\"\")\n    false\n*/", "{\n    if (nums.length < 1)\n\
    \        return 0;\n    if (nums.length == 1)\n        return nums[0];\n    auto\
    \ minStart = [](long start, long[] nums, long[] minSum)\n    {\n        auto myMin\
    \ = 100000000000000;\n        auto sum = 0;\n        for (auto j = start; j <\
    \ nums.length; j++)\n        {\n            sum += nums[j];\n            if (sum\
    \ < myMin)\n                myMin = sum;\n        }\n        return myMin;\n \
    \   };\n    auto minSum = new long[nums.length];\n    minSum[0] = nums[0];\n \
    \   for (auto i = 1; i < nums.length; i++)\n    {\n        minSum[i] = min(minSum[i\
    \ - 1], minStart(i, nums, minSum));\n    }\n    auto res = 100000000000000;\n\
    \    for (auto i = 0; i < nums.length; i++)\n    {\n        if (minSum[i] < res)\n\
    \            res = minSum[i];\n    }\n    return res;\n}\n}", "{\n    if (nums.length\
    \ == 0)\n        return 0;\n    if (nums.length == 1)\n        return nums[0];\n\
    \    long res = (long) INFINITY;\n    long sum = 0;\n    long[] dp = new long[nums.length];\n\
    \    dp[0] = nums[0];\n    for (long i = 1; i < nums.length; i++)\n    {\n   \
    \     dp[(int) i] = min(dp[(int) (i - 1)] + nums[(int) i], nums[(int) i]);\n \
    \       res = min(res, dp[(int) i]);\n    }\n    return res;\n}", "{\n  if (nums.length\
    \ == 0) return 0;\n  long min = nums[0];\n  long current = nums[0];\n  for (long\
    \ i = 1; i < nums.length; i++) \n  {\n    current = min(current + nums[cast(size_t)i],\
    \ nums[cast(size_t)i]);\n    min = min(min, current);\n  }\n  return min;\n}",
  "{\n    long answer = 0;\n    long min_sofar = 0;\n    int i = 0;\n    while (i\
    \ < nums.length)\n    {\n        answer += nums[i];\n        min_sofar = min(min_sofar,\
    \ answer);\n        i++;\n    }\n    return min_sofar;\n}", "{\n    auto range\
    \ = nums.retro;\n    auto sum = range.front;\n    auto min = sum;\n    range.popFront;\n\
    \    foreach(i; range) \n    {\n        sum += i;\n        if(sum < min) \n  \
    \      {\n            min = sum;\n        }\n        else if(sum > 0) \n     \
    \   {\n            sum = 0;\n        }\n    }\n    return min;\n}", "{\n    long\
    \ minimum = long.MAX;\n    long current = 0;\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        current += nums[i];\n        minimum = min(minimum, current);\n\
    \        if (current > 0)\n            current = 0;\n    }\n    return minimum;\n\
    }", "{\n    long ans = nums[0];\n    long sum = 0;\n    foreach(val; nums)\n \
    \   {\n        sum += val;\n        ans = min(ans, sum);\n        sum = max(sum,\
    \ 0L);\n    }\n    return ans;\n}\n/*\n    Given an array of integers nums.\n\
    \    Return an array where every index i of the array contains the product of\n\
    \    all the values in nums except nums[i].\n    Example\n    >>> productExceptSelf([1L,\
    \ 2L, 3L, 4L])\n    [24L, 12L, 8L, 6L]\n    >>> productExceptSelf([0L, 0L])\n\
    \    [0L, 0L]\n    >>> productExceptSelf([1L, 0L])\n    [0L, 1L]\n*/\nlong[] productExceptSelf(long[]\
    \ nums) \n{\n    enum arrLen = nums.length;\n    long[] L = new long[arrLen];\n\
    \    long[] R = new long[arrLen];\n    long[] ans = new long[arrLen];\n    L[0]\
    \ = 1;\n    R[arrLen - 1] = 1;\n    foreach_reverse(i; 1 .. arrLen)\n    {\n \
    \       L[i] = nums[i - 1] * L[i - 1];\n    }\n    foreach(i; 0 .. arrLen - 1)\n\
    \    {\n        R[i] = nums[i + 1] * R[i + 1];\n    }\n    foreach(i; 0 .. arrLen)\n\
    \    {\n        ans[i] = L[i] * R[i];\n    }\n    return ans;\n}\n/*\n    Given\
    \ an array of integers nums, write a method that returns the \"pivot\" index\n\
    \    of this array.\n    We define the pivot index as the index where the sum\
    \ of the numbers to the left\n    of the index is equal to the sum of the numbers\
    \ to the right of the index.\n    If no such index exists, we should return -1.\
    \ If there are multiple pivot indexes,\n    you should return the left-most pivot\
    \ index.\n    Example\n    >>> pivotIndex([1L", "{\n    auto minSum = num(long.max);\n\
    \    auto sum = long.init;\n    foreach(i, num; nums)\n    {\n        sum += num;\n\
    \        if(sum < minSum)\n            minSum = sum;\n        if(sum > 0)\n  \
    \          sum = 0;\n    }\n    return minSum;\n}", "{\n    auto min = tuple(nums[0L],\
    \ 0L, 0L);\n    foreach (i, num; nums[1 .. $])\n    {\n        if (get!0(min)\
    \ > num)\n            min = tuple(num, i, i);\n        else if (get!0(min) + num\
    \ > num)\n            min = tuple(get!0(min) + num, get!1(min), i);\n    }\n \
    \   return get!0(min);\n}", "{\n    long sum = 0;\n    long minSum = sum;\n  \
    \  foreach(n; nums)\n    {\n        sum += n;\n        minSum = min(minSum, sum);\n\
    \        if(sum < 0)\n            sum = 0;\n    }\n    return minSum;\n}\nlong[3L]\
    \ test1 = [2L, 3L, 4L, 1L, 2L, 4L];\nlong[3L] test2 = [-1L, -2L, -3L];", "{\n\
    \    if (nums.length == 0)\n        return 0;\n    if (nums.length == 1)\n   \
    \     return nums[0];\n    \n    bool isNegative = nums.front < 0;\n    long sum\
    \ = 0;\n    long min = nums.front;\n    long max = nums.front;\n    long result\
    \ = nums.front;\n    foreach (i, n; nums)\n    {\n        if (n < min)\n     \
    \       min = n;\n        if (n > max)\n            max = n;\n        \n     \
    \   sum += n;\n        if (sum < result)\n            result = sum;\n        if\
    \ (sum > 0)\n            sum = 0;\n    }\n    if (isNegative)\n        return\
    \ min;\n    return result;\n}", "{\n    auto len = nums.length;\n    if (len ==\
    \ 0) \n    {\n        return 0;\n    }\n    auto result = nums[0];\n    auto cur\
    \ = nums[0];\n    for (auto i = 1; i < len; i++) \n    {\n        cur = min(cur\
    \ + nums[i], nums[i]);\n        result = min(result, cur);\n    }\n    return\
    \ result;\n}", "{\n    // long[] 0-padded for convenience \n    long[] padded\
    \ = new long[nums.length + 1];\n    padded[0] = 0;\n    auto sum = 0L;\n    auto\
    \ result = nums[0];\n    foreach (i, v; nums)\n    {\n        padded[i + 1] =\
    \ sum += v;\n        result = min(result, padded[i + 1] - padded[i]);\n    }\n\
    \    return result;\n}", "{\n    long ans = nums[0];\n    long cur = 0;\n    foreach(x;\
    \ nums)\n    {\n        cur += x;\n        ans = min(ans, cur);\n        cur =\
    \ max(cur, 0L);\n    }\n    return ans;\n}", "{\n    long minSum = long.max;\n\
    \    long sum = 0L;\n    foreach(i, nums) \n    {\n        sum += i;\n       \
    \ minSum = min(minSum, sum);\n        if (sum > 0L)\n            sum = 0L;\n \
    \   }\n    return minSum;\n}", "{\n    if (nums.length < 1) return long.min;\n\
    \    if (nums.length == 1) return nums[0];\n    long minSum = nums[0];\n    long\
    \ currentSum = 0;\n    long[] sums = new long[nums.length];\n    sums[0] = nums[0];\n\
    \    for (int i = 1; i < nums.length; i++)\n    {\n        sums[i] = sums[i -\
    \ 1] + nums[i];\n    }\n    for (int i = 0; i < nums.length; i++)\n    {\n   \
    \     for (int j = i; j < nums.length; j++)\n        {\n            if (i == 0)\n\
    \            {\n                currentSum = sums[j];\n            }\n       \
    \     else\n            {\n                currentSum = sums[j] - sums[i - 1];\n\
    \            }\n            if (currentSum < minSum)\n            {\n        \
    \        minSum = currentSum;\n            }\n        }\n    }\n    return minSum;\n\
    }", "{\n    long minSum = long.max;\n    auto ss = sum(nums);\n    long min =\
    \ nums[0];\n    foreach(i, j; zip(iota(nums.length), nums))\n    {\n        if(nums[i]\
    \ < min)\n            min = nums[i];\n        ss = ss - nums[i];\n        if(minSum\
    \ > ss + min)\n            minSum = ss + min;\n    }\n    return minSum;\n}",
  "{\n    long minimum = nums[0];\n    foreach(i; 1..nums.length)\n    {\n       \
    \ nums[i] = min(nums[i], nums[i] + nums[i - 1]);\n        minimum = min(minimum,\
    \ nums[i]);\n    }\n    return minimum;\n}", "{\n    int n = nums.length;\n  \
    \  long minSum = nums[0];\n    long tempSum = 0L;\n    for (int i = 0; i < n;\
    \ i++)\n    {\n        tempSum += nums[i];\n        if (tempSum < minSum)\n  \
    \      {\n            minSum = tempSum;\n        }\n        if (tempSum > 0)\n\
    \        {\n            tempSum = 0;\n        }\n    }\n    return minSum;\n}",
  "{\n    // write your code here\n    long mi = long.max;\n    long su = 0L;\n  \
    \  foreach(immutable x; nums)\n    {\n        su += x;\n        mi = min(mi, su);\n\
    \        if(su > 0L)\n            su = 0L;\n    }\n    return mi;\n}", "{\n  \
    \  return min(nums);\n}", "{\n    long res = long.MAX;\n    long sum = 0L;\n \
    \   foreach (immutable i, immutable x; nums)\n    {\n        sum += x;\n     \
    \   res = min(res, sum);\n        if (sum > 0L)\n            sum = 0L;\n    }\n\
    \    return res;\n}", "{\n    long ret = long.max;\n    long temp = 0L;\n    foreach(var\
    \ item; nums)\n    {\n        temp += item;\n        ret = min(ret, temp);\n \
    \       if(temp > 0L)\n            temp = 0L;\n    }\n    return ret;\n}", "{\n\
    \    long min = nums[0];\n    long sum = nums[0];\n    foreach(i, n; nums[1..$])\n\
    \    {\n        sum += n;\n        if(sum < min)\n            min = sum;\n   \
    \ }\n    return min;\n}", "{\n    long[] sums = new long[nums.length + 1];\n \
    \   sums[0] = 0;\n    foreach (i, e; nums)\n        sums[i + 1] = sums[i] + e;\n\
    \    long minSum = long.max;\n    for (int i = 0; i < nums.length; i++)\n    \
    \    for (int j = i + 1; j <= nums.length; j++)\n            minSum = min(minSum,\
    \ sums[j] - sums[i]);\n    return minSum;\n}\n// 2nd step (better solution)\n\
    long minSubArraySum(long[] nums) \n{\n    long[] sums = new long[nums.length +\
    \ 1];\n    sums[0] = 0;\n    foreach (i, e; nums)\n        sums[i + 1] = sums[i]\
    \ + e;\n    long minSum = long.max;\n    for (int i = 0; i < nums.length; i++)\n\
    \        for (int j = i + 1; j <= nums.length; j++)\n            minSum = min(minSum,\
    \ sums[j] - sums[i]);\n    return minSum;\n}\n// 3rd step (better solution)\n\
    long minSubArraySum(long[] nums) \n{\n    long[] sums = new long[nums.length +\
    \ 1];\n    sums[0] = 0;\n    foreach (i, e; nums)\n        sums[i + 1] = sums[i]\
    \ + e;\n    long minSum = long.max;\n    for (int i = 0; i < nums.length; i++)\n\
    \        for (int j = i + 1; j <= nums.length; j++)\n            minSum = min(minSum,\
    \ sums[j] - sums[i]);\n    return minSum;\n}\n// 4th step (better solution)\n\
    long minSubArraySum(long[] nums) \n{\n    long[] sums = new long[nums.length +\
    \ 1];\n    sums[0] = 0;\n    foreach (i, e; nums)\n        sums[i + 1] = sums[i]\
    \ + e;\n", "{\n    long minSum = long.max;\n    long curSum = 0L;\n    for (long\
    \ n : nums)\n    {\n        curSum += n;\n        minSum = min(minSum, curSum);\n\
    \        if (curSum > 0L)\n            curSum = 0L;\n    }\n    return minSum;\n\
    }", "{\n    auto n = nums.length;\n    if (n == 0) \n    {\n        return 0;\n\
    \    }\n    long minSum = nums[0];\n    long sum = 0;\n    foreach (num; nums)\
    \ \n    {\n        sum += num;\n        minSum = min(minSum, sum);\n        if\
    \ (sum < 0) \n        {\n            sum = 0;\n        }\n    }\n    return minSum;\n\
    }", "{\n    long res = 0L;\n    long sum = 0L;\n    long minValue = long.max;\n\
    \    for (int i = 0; i < nums.length; i++) \n    {\n        sum += nums[i];\n\
    \        minValue = min(minValue, sum - res);\n        res = min(res, sum);\n\
    \    }\n    return minValue;\n}\n/*\n    Given an array of integers nums, find\
    \ the contiguous sub-array (containing at least one number)\n    which has the\
    \ largest sum and return its sum.\n    Example\n    >>> maxSubArraySum([-2L, 1L,\
    \ -3L, 4L, -1L, 2L, 1L, -5L, 4L])\n    6L\n    >>> maxSubArraySum([1L, 2L, -1L,\
    \ 3L, 4L, -1L])\n    10L\n*/\nlong maxSubArraySum(long[] nums) \n{\n    long res\
    \ = nums[0];\n    long sum = nums[0];\n    for (int i = 1; i < nums.length; i++)\
    \ \n    {\n        sum = max(nums[i], sum + nums[i]);\n        res = max(res,\
    \ sum);\n    }\n    return res;\n}\n/*\n    Given an array of integers nums, find\
    \ the contiguous sub-array (containing at least one number)\n    which has the\
    \ largest sum and return its sum.\n    Example\n    >>> maxSubArraySum([-2L, 1L,\
    \ -3L, 4L, -1L, 2L, 1L, -5L, 4L])\n    6L\n    >>> maxSubArraySum([1L, 2L, -1L,\
    \ 3L, 4L, -1L])\n    10L\n*/\nlong maxSubArraySum(long[] nums) \n{\n    long res\
    \ = nums[0];\n    long sum = nums[0];\n    for (int i = 1; i < nums.length; i++)\
    \ \n    {\n        sum = max(nums[i], sum + nums[i]);\n        res = max(res,\
    \ sum);\n    }\n", "{\n    long result;\n    size_t n = nums.length;\n    size_t\
    \ start = 0;\n    size_t end = 0;\n    long sum = 0;\n    long minSum = typeof(sum).max;\n\
    \    long maxSum = typeof(sum).min;\n    /*\n        Sliding window approach.\n\
    \        find the min sub-array sum that is non-empty.\n    */\n    while (end\
    \ < n)\n    {\n        while (end < n && sum + nums[end] >= 0)\n        {\n  \
    \          sum += nums[end];\n            end++;\n        }\n        if (sum <\
    \ minSum)\n        {\n            minSum = sum;\n        }\n        while (start\
    \ < end && sum + nums[end] < 0)\n        {\n            sum -= nums[start];\n\
    \            start++;\n        }\n        if (start == end)\n        {\n     \
    \       maxSum = max(nums[start], maxSum);\n            start++;\n           \
    \ end++;\n        }\n    }\n    result = min(minSum, maxSum);\n    return result;\n\
    }", "{\n    long minSum = long.max;\n    long sum = 0L;\n    foreach(num; nums)\n\
    \    {\n        sum += num;\n        if(sum < minSum)\n            minSum = sum;\n\
    \        if(sum > 0L)\n            sum = 0L;\n    }\n    return minSum;\n}", "{\n\
    \    return 0L;\n}", "{\n    long minSum = long.max;\n    long curSum = 0L;\n\
    \    foreach(i, val; nums)\n    {\n        curSum += val;\n        if(curSum <\
    \ minSum)\n            minSum = curSum;\n        if(curSum > 0L)\n           \
    \ curSum = 0L;\n    }\n    return minSum;\n}\n/*\n    Given a range [a, b] and\
    \ an array of values, find the minimum value in the array\n    that is greater\
    \ than or equal to a and less than or equal to b.\n    >>> minInRange([0L, 5L],\
    \ [5L, 10L, 3L, 7L, 12L])\n    7L\n*/\nlong minInRange(Range!long range, long[]\
    \ arr)\n{\n    long minVal = long.max;\n    foreach(i, val; arr)\n    {\n    \
    \    if(val >= range.front && val <= range.back && val < minVal)\n           \
    \ minVal = val;\n    }\n    return minVal;\n}\n/*\n    Given a array of integer,\
    \ return a 2D array of 3 integers.\n    The array will contain the product of\
    \ all integers except the one in the current position\n    >>> productOfOthers([1L,\
    \ 2L, 3L, 4L])\n    [[24L, 12L, 8L, 6L],\n     [12L, 8L, 6L, 4L],\n     [8L, 6L,\
    \ 4L, 3L],\n     [6L, 4L, 3L, 2L]]\n*/\nlong[][] productOfOthers(long[] arr)\n\
    {\n    long[][] arrNew = new long[arr.length][arr.length];\n    foreach(i, val;\
    \ arr)\n    {\n        long p = 1L;\n        foreach(j, val; arr)\n        {\n\
    \            if(i != j)\n                p *= val;\n        }\n        arrNew[i][i]\
    \ = p;\n    }\n    return arrNew;\n}\n/*\n    Given an array of integers find\
    \ out how many pairs of integers are duplicates\n    >>> duplicates([1L, 2L, 3L,",
  "{\n    long minimum = nums[0];\n    long sum = 0;\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        sum += nums[i];\n        minimum = sum < minimum ? sum\
    \ : minimum;\n        if (sum < 0)\n            sum = 0;\n    }\n    return minimum;\n\
    }\n//Test Cases:", "{\n    if (nums.length == 0) return 0;\n    //long[] sum =\
    \ new long[nums.length];\n    long sum = 0L;\n    long min = 0L;\n    foreach\
    \ (i, n; nums)\n    {\n        if (i == 0)\n        {\n            sum = n;\n\
    \            min = n;\n        }\n        else\n        {\n            sum +=\
    \ n;\n            min = min(min, sum);\n        }\n        //writeln(i, \": \"\
    , n, \" \", sum, \" \", min);\n    }\n    //writeln(sum, \" \", min);\n    //foreach\
    \ (i, n; nums)\n    //{\n    //    if (i == 0)\n    //    {\n    //        sum[i]\
    \ = n;\n    //        min = n;\n    //    }\n    //    else\n    //    {\n   \
    \ //        sum[i] = sum[i - 1] + n;\n    //        min = min(min, sum[i]);\n\
    \    //    }\n    //    writeln(i, \": \", n, \" \", sum[i], \" \", min);\n  \
    \  //}\n    //writeln(sum, \" \", min);\n    //foreach (i, s; sum)\n    //{\n\
    \    //    writeln(i, \": \", s);\n    //}\n    //writeln(sum);\n    return min;\n\
    }", "{\n    int start = 0;\n    int end = 0;\n    long sum = 0;\n    long max\
    \ = nums[0];\n    for (int i = 0; i < nums.length; i++)\n    {\n        max =\
    \ max(max, nums[i]);\n    }\n    long result = max;\n    while (end < nums.length)\n\
    \    {\n        sum += nums[end];\n        if (sum < result)\n        {\n    \
    \        result = sum;\n        }\n        if (sum > 0)\n        {\n         \
    \   while (sum > 0)\n            {\n                sum -= nums[start];\n    \
    \            start++;\n            }\n        }\n        end++;\n    }\n    return\
    \ result;\n}", "{\n    long minSum = ulong.max;\n    long curSum = 0L;\n    foreach(index,\
    \ num; nums) \n    {\n        if(num < 0L)\n        {\n            if(curSum >\
    \ 0L) \n            {\n                minSum = min(minSum, curSum);\n       \
    \         curSum = 0L;\n            }\n            minSum = min(minSum, num);\n\
    \        }\n        else\n        {\n            curSum += num;\n        }\n \
    \   }\n    return minSum;\n}", "{\n    // Given an array of integers nums, find\
    \ the minimum sum of any non-empty sub-array\n    // of nums.\n    // \n    //\
    \ Example:\n    // >>> minSubArraySum([2L, 3L, 4L, 1L, 2L, 4L])\n    // 1L\n \
    \   // >>> minSubArraySum([-1L, -2L, -3L])\n    // -6L\n    long sum = nums[0];\n\
    \    long min = sum;\n    foreach (i,n; nums[1..$])\n    {\n        sum += n;\n\
    \        min = min(min, sum);\n        if (sum < 0)\n            sum = 0;\n  \
    \  }\n    return min;\n}\n/*", "{\n    import std.algorithm : min;\n    // Special\
    \ case\n    if (nums.length == 0)\n        return 0;\n    if (nums.length == 1)\n\
    \        return nums[0];\n    long sum = 0;\n    long minSum = nums[0];\n    for\
    \ (long i = 0; i < nums.length; i++)\n    {\n        sum += nums[i];\n       \
    \ minSum = min(minSum, sum);\n        if (sum < 0)\n            sum = 0;\n   \
    \ }\n    return minSum;\n}", "{\n    auto minStart = 0UL;\n    auto minEnd = 0UL;\n\
    \    auto minSum = 0L;\n    auto sum = 0L;\n    for (auto i = 0UL; i < nums.length;\
    \ i++)\n    {\n        auto n = nums[i];\n        if (n < 0)\n        {\n    \
    \        if (n < minSum)\n            {\n                minSum = n;\n       \
    \         minStart = i;\n                minEnd = i;\n            }\n        }\n\
    \        else\n        {\n            sum += n;\n            if (sum < minSum)\n\
    \            {\n                minSum = sum;\n                minStart = i;\n\
    \                minEnd = i;\n            }\n        }\n        if (sum < 0)\n\
    \        {\n            sum = 0;\n        }\n    }\n    return minSum;\n}", "{\n\
    \    struct Entry \n    {\n        int minSum;\n        int minPos;\n        int\
    \ maxPos;\n        int len;\n        Entry() { this.minSum = 0; this.minPos =\
    \ 0; this.maxPos = 0; this.len = 0; }\n        Entry(int minSum, int minPos, int\
    \ maxPos, int len) \n        { \n            this.minSum = minSum; this.minPos\
    \ = minPos; this.maxPos = maxPos; this.len = len; \n        }\n    }\n    Entry[]\
    \ results = new Entry[nums.length];\n    for (int i = 0; i < nums.length; i++)\
    \ \n    {\n        Entry curResult = new Entry();\n        int curVal = nums[i];\n\
    \        if (i == 0) \n        {\n            curResult.minSum = curVal;\n   \
    \         curResult.minPos = i;\n            curResult.maxPos = i;\n         \
    \   curResult.len = 1;\n        } \n        else \n        {\n            Entry\
    \ prevResult = results[i - 1];\n            int sum = prevResult.minSum + curVal;\n\
    \            if (sum >= curVal) \n            {\n                curResult.minSum\
    \ = curVal;\n                curResult.minPos = i;\n                curResult.maxPos\
    \ = i;\n                curResult.len = 1;\n            } \n            else \n\
    \            {\n                curResult.minSum = sum;\n                curResult.minPos\
    \ = prevResult.minPos;\n                curResult.maxPos = i;\n              \
    \  curResult.len = i - prevResult.minPos + 1;\n            }\n        }\n    \
    \    results[i] = curResult;\n    }\n    Entry finalResult = results[0];\n   \
    \ for (int i = 1; i < results.length; i++) \n    {\n        Entry curResult =\
    \ results[i];\n        if (curResult.minSum < finalResult.minSum) \n        {\n\
    \            finalResult = curResult;\n        }\n    }\n    return finalResult.minSum;\n\
    }\n/*\n    Move zeros to the end of an array\n    Example\n   ", "{ \n    long\
    \ n = nums.length; \n    long ans = nums[0]; \n    long currSum = nums[0]; \n\
    \  \n    for (long i = 1; i < n; ++i) \n    { \n        currSum = min(nums[i],\
    \ currSum + nums[i]); \n        ans = min(ans, currSum); \n    } \n    return\
    \ ans; \n} ", "{\n    long minSum = long.MAX;\n    long currentSum = 0L;\n   \
    \ foreach(i; 0 .. nums.length)\n    {\n        currentSum += nums[i];\n      \
    \  if(currentSum < minSum)\n        {\n            minSum = currentSum;\n    \
    \    }\n        if(currentSum > 0)\n        {\n            currentSum = 0;\n \
    \       }\n    }\n    return minSum;\n}", "{\n    long result = nums[0];\n   \
    \ long sum = nums[0];\n    for (int i = 1; i < nums.length; i++) \n    {\n   \
    \     if (sum > 0) \n        {\n            sum = nums[i];\n        } \n     \
    \   else \n        {\n            sum += nums[i];\n        }\n        result =\
    \ min(result, sum);\n    }\n    return result;\n}", "{\n    int i = 0;\n    long\
    \ minSum = long.max;\n    long currentSum = 0L;\n    int tail = 0;\n    while\
    \ (i < nums.length) {\n        currentSum += nums[i];\n        if (currentSum\
    \ < minSum) {\n            minSum = currentSum;\n        }\n        while (currentSum\
    \ > 0L) {\n            currentSum -= nums[tail];\n            tail++;\n      \
    \  }\n        i++;\n    }\n    return minSum;\n}", "{\n    long sum = 0L;\n  \
    \  long minSum = long.max;\n    for (long num : nums)\n    {\n        sum += num;\n\
    \        minSum = min(minSum, sum);\n        if (sum > 0L)\n            sum =\
    \ 0L;\n    }\n    return minSum;\n}\n/*\n    Given an array of integers nums,\
    \ find the maximum sum of any non-empty sub-array\n    of nums.\n    Example\n\
    \    >>> maxSubArraySum([2L, 3L, 4L, 1L, 2L, 4L])\n    15L\n    >>> maxSubArraySum([-1L,\
    \ -2L, -3L])\n    -1L\n    \n*/\nlong maxSubArraySum(long[] nums) \n{\n    long\
    \ sum = 0L;\n    long maxSum = long.min;\n    for (long num : nums)\n    {\n \
    \       sum += num;\n        maxSum = max(maxSum, sum);\n        if (sum < 0L)\n\
    \            sum = 0L;\n    }\n    return maxSum;\n}\n/*\n    Given a circular\
    \ array (the next element of the last element is the first\n    element of the\
    \ array), print the Next Greater Number for every element.\n    The Next Greater\
    \ Number of a number x is the first greater number to its\n    traversing-order\
    \ next in the array, which means you could search circularly\n    to find its\
    \ next greater number. If it doesn't exist, output -1 for this\n    number.\n\
    \    Example\n    >>> nextGreaterElements([1L, 2L, 1L])\n    [2L, -1L, 2L]\n \
    \   \n*/\nlong[] nextGreaterElements(long[] nums) \n{\n    long[] result = new\
    \ long[nums.length];\n    long[] copy = new long[nums.length * 2];\n    for (int\
    \ i = 0; i < nums.length; i++)\n    {\n        result[i] = -1L;\n        copy[i]\
    \ = nums[i];\n        copy[i + nums.length] = nums[i];\n    }\n    for (int i\
    \ = 0", "{\n    if (nums.length == 0)\n        return 0;\n    if (nums.length\
    \ == 1)\n        return nums[0];\n    long minVal = nums[0];\n    long curVal\
    \ = nums[0];\n    for (int i = 1; i < nums.length; i++)\n    {\n        curVal\
    \ = max(nums[i], curVal + nums[i]);\n        minVal = min(minVal, curVal);\n \
    \   }\n    return minVal;\n}", "{\n    long curr = 0L;\n    return nums.foldLeft!(std.typecons.Tuple!(long,\
    \ long)(long.max, 0L))\n               ((t, e) => \n               {\n       \
    \            if (t[0] > t[1] + e)\n                   {\n                    \
    \   curr = e;\n                       return std.typecons.Tuple!(long, long)(t[1]\
    \ + e, e);\n                   }\n                   else if (t[0] == t[1] + e)\n\
    \                   {\n                       curr = min(curr, e);\n         \
    \              return std.typecons.Tuple!(long, long)(t[1] + e, e);\n        \
    \           }\n                   else\n                   {\n               \
    \        return std.typecons.Tuple!(long, long)(t[0], t[1] + e);\n           \
    \        }\n               })[0];\n}", "{\n    return nums.length == 0 ? 0 : minSubArraySum(nums,\
    \ 0, nums.length - 1);\n}\nprivate long minSubArraySum(long[] nums, long start,\
    \ long end)\n{\n    if (start == end)\n        return nums[start];\n    long mid\
    \ = (start + end) / 2;\n    return min(minSubArraySum(nums, start, mid), minSubArraySum(nums,\
    \ mid + 1, end),\n        minSum(nums, start, mid, end));\n}\nprivate long minSum(long[]\
    \ nums, long start, long mid, long end)\n{\n    long minRight = minSumRight(nums,\
    \ mid + 1, end);\n    long minLeft = minSumLeft(nums, start, mid);\n    return\
    \ minRight + minLeft;\n}\nprivate long minSumRight(long[] nums, long start, long\
    \ end)\n{\n    long minEnd = nums[end];\n    long sum = 0;\n    while (end >=\
    \ start)\n    {\n        sum += nums[end];\n        if (sum < minEnd)\n      \
    \      minEnd = sum;\n        end--;\n    }\n    return minEnd;\n}\nprivate long\
    \ minSumLeft(long[] nums, long start, long end)\n{\n    long minStart = nums[start];\n\
    \    long sum = 0;\n    while (start <= end)\n    {\n        sum += nums[start];\n\
    \        if (sum < minStart)\n            minStart = sum;\n        start++;\n\
    \    }\n    return minStart;\n}", "{\n    // only works if len(nums) > 0\n   \
    \ import std.algorithm : iterate, reduce;\n    if (nums.length == 1)\n       \
    \ return nums[0];\n    int startingPoint = 0;\n    int minEndingPoint = 0;\n \
    \   long minSoFar = 0;\n    long currentSum = 0;\n    foreach (i, value; nums)\
    \ {\n        currentSum += value;\n        if (currentSum < minSoFar) {\n    \
    \        minSoFar = currentSum;\n            minEndingPoint = i;\n        }\n\
    \    }\n    return currentSum - nums[startingPoint..minEndingPoint + 1].reduce!((a,\
    \ b) => a + b)();\n}", "{\n    size_t n = nums.length;\n    if (n == 0U)\n   \
    \     return 0L;\n    long minEndingHere = nums[0];\n    long minSoFar = nums[0];\n\
    \    foreach (i, item; nums[1 .. $])\n    {\n        minEndingHere = min(minEndingHere\
    \ + item, item);\n        minSoFar = min(minSoFar, minEndingHere);\n    }\n  \
    \  return minSoFar;\n}", "{\n    long min_so_far = nums[0];\n    long min_ending_here\
    \ = 0;\n    foreach (long n; nums) \n    {\n        min_ending_here = min(min_ending_here\
    \ + n, n);\n        min_so_far = min(min_so_far, min_ending_here);\n    }\n  \
    \  return min_so_far;\n}", "{\n\treturn nums.length <= 1 ? nums[0] :\n\t\tmin(nums.takeWhile!(x\
    \ => x < 0).sum,\n\t\t    nums.dropWhile!(x => x < 0).min!((a, b) => abs(a) <\
    \ abs(b)));\n}", "{\n    auto n = nums.length;\n    if (n == 0)\n        return\
    \ 0;\n    else if (n == 1)\n        return nums[0];\n    \n    auto minSum = nums[0];\n\
    \    auto curSum = 0;\n    for (size_t i = 0; i < n; i++)\n    {\n        curSum\
    \ += nums[i];\n        minSum = min(minSum, curSum);\n        if (curSum > 0)\n\
    \            curSum = 0;\n    }\n    return minSum;\n}", "{\n    if (nums.length\
    \ == 0)\n        return 0;\n    if (nums.length == 1)\n        return nums[0];\n\
    \    long sum = 0;\n    long minSum = nums[0];\n    auto accum = [sum, minSum](long\
    \ x){\n        sum += x;\n        minSum = min(sum, minSum);\n        return sum;\n\
    \    };\n    auto init = [](long x){\n        return x;\n    };\n    nums.scanLeft(init,\
    \ accum);\n    return minSum;\n}", "{\n    long sum = 0L;\n    long minSum = long.max;\n\
    \    foreach(j, x; nums)\n    {\n        sum += x;\n        if(j > 0L) minSum\
    \ = min(minSum, sum);\n        if(sum < 0L) sum = 0L;\n    }\n    return minSum;\n\
    }", "{\n    long min = long.max;\n    long total = 0L;\n    foreach(num; nums)\n\
    \    {\n        total += num;\n        min = min(min, total);\n        if(total\
    \ < 0L)\n            total = 0L;\n    }\n    return min;\n}", "{\n    enum size_t\
    \ len = nums.length;\n    long minSum = 1L << 63;\n    long sum = 0L;\n    for\
    \ (int i = 0; i < len; i++)\n    {\n        sum += nums[i];\n        minSum =\
    \ min(minSum, sum);\n        if (sum < 0L)\n            sum = 0L;\n    }\n   \
    \ return minSum;\n}", "{\n    return nums.reduce!\"a + b\".min;\n}\n// ------------------------------------------------\n\
    long minSubArraySum2(long[] nums)\n{\n    long out = nums[0];\n    long cur =\
    \ 0;\n    foreach(elem; nums)\n    {\n        cur += elem;\n        if(cur < out)\n\
    \            out = cur;\n    }\n    return out;\n}\n// ------------------------------------------------\n\
    // https://www.google.com/search?q=min%20subarray&oq=min%20subarray&aqs=chrome..69i57j69i61j0l4.2053j0j4&sourceid=chrome&ie=UTF-8\n\
    long minSubArraySum1(long[] nums)\n{\n    long min_sum = nums[0];\n    long cur_sum\
    \ = 0;\n    foreach(num; nums)\n    {\n        cur_sum += num;\n        if(cur_sum\
    \ < min_sum)\n            min_sum = cur_sum;\n    }\n    return min_sum;\n}\n\
    // ------------------------------------------------\n// http://www.cplusplus.com/reference/algorithm/min_element/\n\
    long minSubArraySum0(long[] nums)\n{\n    import std.algorithm.iteration : reduce;\n\
    \    import std.algorithm.searching : minElement;\n    import std.algorithm.mutation\
    \ : fill;\n    import std.range.primitives : isForwardRange;\n    import std.range\
    \ : iota;\n    import std.range.primitives : popFront;\n    import std.range.primitives\
    \ : front;\n    import std.range.primitives : max;\n    import std.range.primitives\
    \ : empty;\n    import std.range.primitives : ret;\n    import std.math : sqrt;\n\
    \    import std.math : isInfinite;\n    import std.math : isNaN;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : Yes;\n\
    \    import std.typecons : No;\n    import std.typecons : isSomeString;\n    import\
    \ std", "{\n    long result = 0L;\n    long currentSum = 0L;\n    int length =\
    \ nums.length;\n    int i = 0;\n    while (i < length)\n    {\n        currentSum\
    \ += nums[i];\n        result = min(result, currentSum);\n        if (currentSum\
    \ > 0L)\n        {\n            currentSum = 0L;\n        }\n        i++;\n  \
    \  }\n    return result;\n}", "{\n    auto N = nums.length;\n    auto minSum =\
    \ nums[0];\n    auto currSum = nums[0];\n    foreach (i, j; N[1 .. $]) \n    {\n\
    \        currSum = min(currSum + nums[j], nums[j]);\n        minSum = min(minSum,\
    \ currSum);\n    }\n    return minSum;\n}\n/*\n    Find the max sum of any continuous\
    \ subarray.\n    Example\n    >>> maxSubArraySum([-1L, -2L, -3L])\n    -1L\n \
    \   >>> maxSubArraySum([2L, 3L, 4L, 1L, 2L, 4L])\n    13L\n*/\nlong maxSubArraySum(long[]\
    \ nums) \n{\n    auto N = nums.length;\n    auto maxSum = nums[0];\n    auto currSum\
    \ = nums[0];\n    foreach (i, j; N[1 .. $]) \n    {\n        currSum = max(currSum\
    \ + nums[j], nums[j]);\n        maxSum = max(maxSum, currSum);\n    }\n    return\
    \ maxSum;\n}\n/*\n    Find the max sum of any continuous subarray of length k.\n\
    \    Example\n    >>> maxSubArraySumOfLength([1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L], 2)\n    2L\n    >>> maxSubArraySumOfLength([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L], 2)\n    19L\n*/\nlong maxSubArraySumOfLength(long[] nums,\
    \ size_t k) \n{\n    auto N = nums.length;\n    auto maxSum = nums[0 .. k].sum;\n\
    \    auto currSum = nums[0 .. k].sum;\n    foreach (i, j; k[1 .. $]) \n    {\n\
    \        currSum = currSum + nums[j] - nums[j - k];\n        maxSum", "{\n   \
    \ const long max = TypeTuple(nums).max;\n    auto result = map!(a => a * a)(nums);\n\
    \    return TypeTuple(result).max;\n}", "{ \n    long minSum = long.max;\n   \
    \ long sum = 0L;\n    for (int i = 0; i < nums.length; i++)\n    {\n        sum\
    \ += nums[i];\n        if (sum < minSum)\n            minSum = sum;\n        if\
    \ (sum > 0)\n            sum = 0;\n    }\n    return minSum;\n}", "{\n    if (nums.length\
    \ == 0)\n        return 0;\n    if (nums.length == 1)\n        return nums[0];\n\
    \    \n    // Initialize minimum length and starting index \n    long minSum =\
    \ nums[0];\n    long subarrayStart = 0;\n    long subarrayLength = 1;\n    \n\
    \    // Initialize current sum and current sum starting index\n    long currSum\
    \ = nums[0];\n    long currSumStart = 0;\n    \n    for (long index = 1; index\
    \ < nums.length; index++)\n    {\n        // If the previous sum is more than\
    \ the current number\n        // it means that the current sum would decrease\
    \ even if we\n        // add the current number\n        if (currSum > nums[index])\n\
    \        {\n            // We reset the current sum to the current number\n  \
    \          currSum = nums[index];\n            // And the current sum starting\
    \ index to the current index\n            currSumStart = index;\n        }\n \
    \       else\n        {\n            // Otherwise, we add the current number to\
    \ the current sum\n            currSum += nums[index];\n        }\n        \n\
    \        // If the current sum is less than the minimum sum,\n        // we replace\
    \ the minimum sum with the current sum\n        if (currSum < minSum)\n      \
    \  {\n            minSum = currSum;\n            // We also replace the minimum\
    \ sum starting index and length\n            subarrayStart = currSumStart;\n \
    \           subarrayLength = index - currSumStart + 1;\n        }\n    }\n   \
    \ \n    return minSum;\n}", "{\n    long sum = 0L;\n    long minSum = 0L;\n  \
    \  auto min = tuple(sum,minSum);\n    //auto min = Tuple(sum,minSum);\n    for(;sum\
    \ = 0L, minSum = 0L, min = tuple(sum,minSum), minSum = min[1], sum = min[0], minSum\
    \ <= 0L, minSum = sum, min = tuple(sum,minSum), true;)\n    {\n        foreach(item;\
    \ nums)\n        {\n            sum += item;\n            if(sum < minSum)\n \
    \           {\n                minSum = sum;\n                min = tuple(sum,minSum);\n\
    \            }\n        }\n    }\n    return minSum;\n}", "{\n    if (nums.length\
    \ == 0)\n        return 0;\n    auto current = nums[0];\n    auto min = current;\n\
    \    foreach (i, num; nums[1 .. $])\n    {\n        current = min(current + num,\
    \ num);\n        min = min(min, current);\n    }\n    return min;\n}", "{ \n \
    \ return nums.min.sum;\n}", "{\n    if (nums.length < 1)\n        return 0;\n\
    \    if (nums.length == 1)\n        return nums[0];\n    long sum = 0;\n    long\
    \ result = nums[0];\n    for (size_t i = 0; i < nums.length; i++)\n    {\n   \
    \     sum += nums[i];\n        result = min(result, sum);\n        if (sum > 0)\n\
    \            sum = 0;\n    }\n    return result;\n}\n/*\n    Given a positive\
    \ integer n, find the least number of perfect square numbers\n    (for example,\
    \ 1, 4, 9, 16, ...) which sum to n.\n    Example\n    >>> numSquares(2)\n    2\n\
    \    >>> numSquares(12)\n    3\n*/", "{\n    if (nums.length == 0) return 0;\n\
    \    long minSum = typeof(nums[0]).max;\n    long curSum = 0;\n    foreach (i;\
    \ 0 .. nums.length)\n    {\n        curSum += nums[i];\n        minSum = min(minSum,\
    \ curSum);\n        if (curSum < 0)\n            curSum = 0;\n    }\n    return\
    \ minSum;\n}", "{\n    //return minSubArraySum_with_recursion(nums);\n    return\
    \ minSubArraySum_dynamic_programming(nums);\n}\n// O(N^2)\nlong minSubArraySum_with_recursion(long[]\
    \ nums)\n{\n    long result = long.max;\n    for (int i = 0; i < nums.length;\
    \ i++) {\n        long sum = 0;\n        for (int j = i; j < nums.length; j++)\
    \ {\n            sum += nums[j];\n            result = min(result, sum);\n   \
    \     }\n    }\n    return result;\n}\n// O(N)\nlong minSubArraySum_dynamic_programming(long[]\
    \ nums)\n{\n    long result = long.max;\n    long sum = 0;\n    for (int i = 0;\
    \ i < nums.length; i++) {\n        sum += nums[i];\n        result = min(result,\
    \ sum);\n        if (sum > 0) {\n            sum = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long smallest = nums[0];\n    long sum = 0;\n    foreach(i;\
    \ 0 .. nums.length)\n    {\n        sum += nums[i];\n        if(smallest > sum)\n\
    \        {\n            smallest = sum;\n        }\n        if(sum > 0)\n    \
    \    {\n            sum = 0;\n        }\n    }\n    return smallest;\n}", "{\n\
    \    long min_sum = nums[0];\n    long curr_sum = nums[0];\n    foreach(i; 1..nums.length)\n\
    \    {\n        curr_sum = min(curr_sum + nums[i], nums[i]);\n        min_sum\
    \ = min(min_sum, curr_sum);\n    }\n    return min_sum;\n}", "{\n    if (nums.length\
    \ == 0)\n        return 0;\n    if (nums.length == 1)\n        return nums[0];\n\
    \    long sum = nums[0];\n    long minSum = nums[0];\n    foreach (index, val;\
    \ nums[1 .. $])\n    {\n        if (sum <= 0)\n            sum = val;\n      \
    \  else\n            sum += val;\n        minSum = min(minSum, sum);\n    }\n\
    \    return minSum;\n}", "{\n    auto N = nums.length;\n    long[] dp = new long[N];\n\
    \    dp[0] = nums[0];\n    return reduce!((a, b) => min(a, b))(dp);\n}", "{\n\
    \    if (nums.length == 0)\n        return 0;\n    if (nums.length == 1)\n   \
    \     return nums[0];\n    long currentSum = nums[0];\n    long totalSum = nums[0];\n\
    \    for (int i = 1; i < nums.length; i++)\n    {\n        currentSum = currentSum\
    \ < 0 ? nums[i] : currentSum + nums[i];\n        totalSum = min(totalSum, currentSum);\n\
    \    }\n    return totalSum;\n}", "{\n    long minSum = 0L;\n    long currentSum\
    \ = 0L;\n    for (long n : nums) \n    {\n        currentSum += n;\n        if\
    \ (currentSum < minSum) \n        {\n            minSum = currentSum;\n      \
    \  }\n    }\n    return minSum;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
