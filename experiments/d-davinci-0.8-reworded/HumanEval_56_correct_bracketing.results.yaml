language: d
name: HumanEval_56_correct_bracketing
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   string opening = \"<\";\n    string closing = \">\";\n    int length = brackets.length;\n\
    \    Stack!(string) s = Stack!(string)();\n    for (int i = 0; i < length; i++)\
    \ \n    {\n        if (brackets[i] == '<') \n        {\n            s.push(opening);\n\
    \        }\n        else if (brackets[i] == '>') \n        {\n            if (s.empty)\
    \ \n            {\n                return false;\n            }\n            else\
    \ \n            {\n                s.pop();\n            }\n        }\n    }\n\
    \    return s.empty;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpadkxke16.d(21): Error: cannot implicitly convert expression `brackets.length`
    of type `ulong` to `int`

    /tmp/tmpadkxke16.d(22): Error: template instance `Stack!string` template `Stack`
    is not defined

    /tmp/tmpadkxke16.d(22): Error: template instance `Stack!string` template `Stack`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpadkxke16.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{ \n\
    \    auto last_lt = find(brackets, '<');\n    foreach(int i, char c; last_lt ..\
    \ brackets.length) {\n        if (c == '>')\n            last_lt = i;\n      \
    \  else if (c == '<')\n            return false;\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpde3b2o_w.d(20): Error: found `..` when expecting `)`

    /tmp/tmpde3b2o_w.d(20): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde3b2o_w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int opening_n = 0;\n    int closing_n = 0;\n    foreach(char c; brackets)\n\
    \    {\n        if(c == '<')\n        {\n            opening_n += 1;\n       \
    \ }\n        else\n        {\n            closing_n += 1;\n        }\n       \
    \ if(closing_n > opening_n)\n        {\n            return false;\n        }\n\
    \    }\n    if(opening_n == closing_n)\n    {\n        return true;\n    }\n \
    \   else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   Stack!char stk;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n \
    \           stk.push(c);\n        else if(c == '>')\n        {\n            //if\
    \ stack is empty and we see a closing bracket, then its not correct\n        \
    \    if(stk.empty)\n                return false;\n            //pop out the last\
    \ bracket.\n            stk.pop();\n        }\n    }\n    //if no opening bracket\
    \ is left, then its correct\n    return stk.empty;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4gnwusu3.d(19): Error: template instance `Stack!char` template
    `Stack` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4gnwusu3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint counter = 0;\n    for (size_t i = 0; i < brackets.length; i++) \n   \
    \ {\n        switch (brackets[i]) \n        {\n            case '<':\n       \
    \         counter++;\n                break;\n            case '>':\n        \
    \        counter--;\n                break;\n        }\n        if (counter <\
    \ 0) \n        {\n            return false;\n        }\n    }\n    return counter\
    \ == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpke4hr7im.d(22): Error: `switch` statement without a `default`;
    use `final switch` or add `default: assert(0);` or add `default: break;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpke4hr7im.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   void decrement_char(inout char[] s, size_t i)\n    {\n        if (s[i] ==\
    \ '>')\n            s[i] = '<';\n        else\n            s[i] = '>';\n    }\n\
    \    char[] s = brackets;\n    decrement_char(s, 0);\n    decrement_char(s, s.length\
    \ - 1);\n    return s.all!(c => c == '<');\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp55imzr68.d(22): Error: cannot modify `inout` expression `s[i]`

    /tmp/tmp55imzr68.d(24): Error: cannot modify `inout` expression `s[i]`

    /tmp/tmp55imzr68.d(26): Error: cannot implicitly convert expression `brackets`
    of type `string` to `char[]`

    /tmp/tmp55imzr68.d(29): Error: no property `all` for type `char[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp55imzr68.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   //@./correct_bracketing.dnl\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdha11mj9.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmpdha11mj9.__unittest_L22_C1() [0x427ada]

    ??:? void tmpdha11mj9.__modtest() [0x427c0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   stack!int s;\n    foreach(char c; brackets) {\n        if (c == '<')\n   \
    \         s.push(1);\n        else if (c == '>') {\n            if (s.empty) return\
    \ false;\n            s.pop();\n        }\n    }\n    return s.empty;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpampu9yz6.d(19): Error: template instance `stack!int` template `stack`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpampu9yz6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int open = 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n    \
    \    if (brackets[i] == '<')\n        {\n            open++;\n        }\n    \
    \    else\n        {\n            if (open == 0)\n            {\n            \
    \    return false;\n            }\n            open--;\n        }\n    }\n   \
    \ return open == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int open = 0;\n    int close = 0;\n    foreach(int i;0..brackets.length)\n\
    \    {\n        if(brackets[i] == '<')\n        {\n            open += 1;\n  \
    \      }\n        else\n        {\n            close += 1;\n        }\n      \
    \  if(close > open)\n        {\n            return false;\n        }\n    }\n\
    \    if(open == close)\n    {\n        return true;\n    }\n    else\n    {\n\
    \        return false;\n    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy7kwbj_e.d(21): Error: cannot implicitly convert expression `brackets.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy7kwbj_e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int i = 0;\n    while (brackets[i] != '\\0') {\n        switch (brackets[i])\
    \ {\n            case '<':\n                i++;\n                break;\n   \
    \         case '>':\n                i--;\n                break;\n        }\n\
    \        if (i < 0)\n            return false;\n    }\n    return i == 0;\n}\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9wte2arz.d(21): Error: `switch` statement without a `default`;
    use `final switch` or add `default: assert(0);` or add `default: break;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9wte2arz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ // size_t no = brackets.length();\n  int open = 0;\n  for (auto c : brackets)\
    \ {\n    if (c == '<') {\n      open++;\n    } else {\n      if (open == 0) {\n\
    \        return false;\n      }\n      open--;\n    }\n  }\n  return open == 0;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw_rlmcaj.d(21): Error: no identifier for declarator `c`

    /tmp/tmpw_rlmcaj.d(21): Error: expression expected, not `:`

    /tmp/tmpw_rlmcaj.d(21): Error: found `brackets` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw_rlmcaj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n  \
    \          count++;\n        else if(c == '>')\n            count--;\n       \
    \ if(count < 0)\n            return false;\n    }\n    return count == 0;\n}\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool bRet = true;\n    int nLen = brackets.length;\n    if (0 == nLen)\n \
    \   {\n        return bRet;\n    }\n    else if (1 == nLen)\n    {\n        if\
    \ (brackets[0] == '<')\n        {\n            bRet = false;\n        }\n    }\n\
    \    else\n    {\n        Stack!int nStack = new Stack!int;\n        foreach (nIdx,\
    \ cChar; brackets)\n        {\n            if (cChar == '<')\n            {\n\
    \                nStack.push(cChar);\n            }\n            else\n      \
    \      {\n                if (nStack.empty)\n                {\n             \
    \       bRet = false;\n                    break;\n                }\n       \
    \         else\n                {\n                    nStack.pop();\n       \
    \         }\n            }\n        }\n        if (!nStack.empty)\n        {\n\
    \            bRet = false;\n        }\n    }\n    return bRet;\n}\n/*\n    >>>\
    \ swap_case(\"aBc\")\n    \"AbC\"\n    >>> swap_case(\"\")\n    \"\"\n    >>>\
    \ swap_case(\"aBcD\")\n    \"AbCd\"\n*/\nstring swap_case(string str)\n{\n   \
    \ string strRet = \"\";\n    foreach (cChar; str)\n    {\n        strRet ~= to!string(cChar).swapcase;\n\
    \    }\n    return strRet;\n}\n/*\n    >>> num_digits(0)\n    1\n    >>> num_digits(12345)\n\
    \    5\n    >>> num_digits(-12345)\n    5\n    >>> num_digits(100000000000000000000000000)\n\
    \    24\n*/\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr19b4779.d(20): Error: cannot implicitly convert expression `brackets.length`
    of type `ulong` to `int`

    /tmp/tmpr19b4779.d(34): Error: template instance `Stack!int` template `Stack`
    is not defined

    /tmp/tmpr19b4779.d(34): Error: template instance `Stack!int` template `Stack`
    is not defined

    /tmp/tmpr19b4779.d(74): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr19b4779.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count_open = 0;\n    int count_close = 0;\n    foreach(char c; brackets)\n\
    \    {\n        switch(c)\n        {\n            case '<':\n                count_open++;\n\
    \                break;\n            case '>':\n                count_close++;\n\
    \                break;\n        }\n        if(count_close > count_open)\n   \
    \         return false;\n    }\n    return count_open == count_close;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiga7dbtj.d(23): Error: `switch` statement without a `default`;
    use `final switch` or add `default: assert(0);` or add `default: break;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiga7dbtj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    uint count = 0;\n\tforeach(char c; brackets)\n\t{\n\t\tif(c == '<')\n\t\t\tcount++;\n\
    \t\telse if(c == '>')\n\t\t\tcount--;\n\t\tif(count == 0)\n\t\t\treturn false;\n\
    \t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2evor0bw.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f05]

    ??:? void tmp2evor0bw.__unittest_L31_C1() [0x427ab2]

    ??:? void tmp2evor0bw.__modtest() [0x427c88]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aabe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc51]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430100]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbdd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa95]

    ??:? runModuleUnitTests [0x42ba01]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428354]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int left = 0;\n    foreach(c; brackets) {\n        if (c == '<') {\n     \
    \       left++;\n        } else {\n            if (left == 0) {\n            \
    \    return false;\n            }\n            left--;\n        }\n    }\n   \
    \ return left == 0;\n}\n/*\n    >>> swap_left_right([\"a\", \"b\", \"c\"])\n \
    \   [\"c\", \"b\", \"a\"]\n    >>> swap_left_right([\"a\", [\"b\", \"c\"], \"\
    d\"])\n    [\"d\", [\"b\", \"c\"], \"a\"]\n    >>> swap_left_right([\"a\", [\"\
    b\", [\"c\", \"d\"], \"e\"], \"f\"])\n    [\"f\", [\"b\", [\"c\", \"d\"], \"e\"\
    ], \"a\"]\n    \n*/\nS swap_left_right(S)(S s) \n{\n    import std.algorithm :\
    \ swapFront;\n    return swapFront(s);\n}\n/*\n    >>> split_digits(123)\n   \
    \ [1, 2, 3]\n    >>> split_digits(0)\n    [0]\n    >>> split_digits(6624)\n  \
    \  [6, 6, 2, 4]\n    \n*/\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   auto stack = new Stack!(char)();\n    foreach(char c; brackets)\n    {\n \
    \       if(c == '<')\n        {\n            stack.push(c);\n        }\n     \
    \   else if(c == '>')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpghpd6ybo.d(19): Error: template instance `Stack!char` template
    `Stack` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpghpd6ybo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint<> open_count = 0;\n    uint<> close_count = 0;\n    for (uint<> i = 0;\
    \ i < brackets.length; i++) \n    {\n        if (brackets[i] == '<')\n       \
    \ {\n            open_count++;\n        }\n        else\n        {\n         \
    \   close_count++;\n        }\n        if (close_count > open_count)\n       \
    \ {\n            return false;\n        }\n    }\n    if (open_count == close_count)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8c2oumky.d(19): Error: no identifier for declarator `uint`

    /tmp/tmp8c2oumky.d(19): Error: found `<` instead of statement

    /tmp/tmp8c2oumky.d(20): Error: no identifier for declarator `uint`

    /tmp/tmp8c2oumky.d(20): Error: found `<` instead of statement

    /tmp/tmp8c2oumky.d(21): Error: no identifier for declarator `uint`

    /tmp/tmp8c2oumky.d(21): Error: expression expected, not `<`

    /tmp/tmp8c2oumky.d(21): Error: found `;` when expecting `)`

    /tmp/tmp8c2oumky.d(21): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8c2oumky.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool flag=true;\n    int m=0;\n    while(flag==true)\n    {\n        if(brackets.find(\"\
    <>\")==-1)\n        {\n            flag=false;\n        }\n        else\n    \
    \    {\n            m=brackets.find(\"<>\");\n            brackets.erase(m,2);\n\
    \        }\n    }\n    if(brackets==\"\")\n    {\n        return true;\n    }\n\
    \    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq045blm6.d(23): Error: no property `find` for type `string`

    /tmp/tmpq045blm6.d(29): Error: no property `find` for type `string`

    /tmp/tmpq045blm6.d(30): Error: no property `erase` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq045blm6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n   \
    \     if (brackets[i] == '<')\n        {\n            count++;\n        }\n  \
    \      else if (brackets[i] == '>')\n        {\n            count--;\n       \
    \ }\n        if (count < 0)\n        {\n            return false;\n        }\n\
    \    }\n    return count == 0;\n}\n/*\n    return the number of times that a string\
    \ is inside another string.\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3cl3t5n6.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3cl3t5n6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \  // int open = 0;\n    //int close = 0;\n    //int size = length(brackets);\n\
    \    //for (int i = 0; i < size; i++)\n    //{\n        //if (brackets[i] == '<')\n\
    \        //{\n            //open++;\n        //}\n        //else if (brackets[i]\
    \ == '>')\n        //{\n            //close++;\n        //}\n        //if (close\
    \ > open)\n        //{\n            //return false;\n        //}\n    //}\n  \
    \  //if (open == close)\n    //{\n        //return true;\n    //}\n    //else\n\
    \    //{\n        //return false;\n    //}\n    struct counter\n    {\n      \
    \  int open;\n        int close;\n    };\n    auto numbers = map!(brackets, (x)\
    \ => counter(0, 0))();\n    foreach (i, c; zip(brackets, numbers))\n    {\n  \
    \      if (c == '<')\n        {\n            numbers[i].open++;\n        }\n \
    \       else if (c == '>')\n        {\n            numbers[i].close++;\n     \
    \   }\n        if (numbers[i].close > numbers[i].open)\n        {\n          \
    \  return false;\n        }\n    }\n    return numbers[$ - 1].open == numbers[$\
    \ - 1].close;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n \
    \   assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp41xj36l_.d(49): Deprecation: use `{ }` for an empty statement,
    not `;`

    /tmp/tmp41xj36l_.d(50): Error: template instance `map!(brackets, (x) => counter(0,
    0))` template `map` is not defined

    /tmp/tmp41xj36l_.d(51): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp41xj36l_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(char c; brackets)\n    {\n        if(c == '<')\n\
    \            count++;\n        else\n            count--;\n        if(count <\
    \ 0)\n            return false;\n    }\n    return count == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint count = 0;\n    foreach(char c; brackets) {\n        if (c == '<') \n\
    \            count++;\n        else if (c == '>') \n            count--;\n   \
    \ }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp84kvph3x.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427efd]

    ??:? void tmp84kvph3x.__unittest_L28_C1() [0x427b73]

    ??:? void tmp84kvph3x.__modtest() [0x427c7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aab6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbd5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa8d]

    ??:? runModuleUnitTests [0x42b9f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42834c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int bracket_counter = 0;\n    for (int i = 0; i < brackets.length; i++) \n\
    \    {\n        char bracket = brackets[i];\n        if (bracket == '<') {\n \
    \           bracket_counter++;\n        } else if (bracket == '>') {\n       \
    \     bracket_counter--;\n        } else {\n            return false;\n      \
    \  }\n        if (bracket_counter < 0) {\n            return false;\n        }\n\
    \    }\n    return bracket_counter == 0;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int n = 0;\n    foreach(x;brackets)\n    {\n        if(x == '<') n++;\n  \
    \      else n--;\n        if(n < 0) return false;\n    }\n    return n == 0;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int[int] counts;\n\tforeach(i, c; brackets)\n\t{\n\t\tif(c == '<') counts[i] =\
    \ 1;\n\t\telse counts[i] = -1;\n\t}\n\tforeach(i, c; zip(counts, iota(counts.length)))\n\
    \t{\n\t\tif(c[0] == 1)\n\t\t{\n\t\t\tbool found = false;\n\t\t\tfor(j = c[1] +\
    \ 1; j < counts.length; j++)\n\t\t\t{\n\t\t\t\tif(counts[j] == -1)\n\t\t\t\t{\n\
    \t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found)\
    \ return false;\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpenca8l8s.d(22): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpenca8l8s.d(23): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpenca8l8s.d(25): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpenca8l8s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ struct BracketIterator \n  {\n    string brackets;\n    size_t index;\n    @property\n\
    \    {\n      @property\n      inout(char) opIndex(size_t) ()\n      {\n     \
    \   return brackets[index];\n      }\n      @property\n      size_t length()\n\
    \      {\n        return brackets.length;\n      }\n    }\n    inout(char) front()\n\
    \    {\n      return brackets[index];\n    }\n    bool empty()\n    {\n      return\
    \ index == brackets.length;\n    }\n    BracketIterator save()\n    {\n      return\
    \ BracketIterator(index, brackets);\n    }\n    void popFront()\n    {\n     \
    \ ++index;\n    }\n  }\n  bool front_is_close(ref BracketIterator i)\n  {\n  \
    \  return i.front == '>';\n  }\n  struct BracketState\n  {\n    bool ok;\n   \
    \ BracketIterator i;\n    static BracketState ok_(ref BracketIterator i)\n   \
    \ {\n      return BracketState(true, i);\n    }\n    static BracketState not_ok_(ref\
    \ BracketIterator i)\n    {\n      return BracketState(false, i);\n    }\n  }\n\
    \  BracketState iter_loop(ref BracketIterator i)\n  {\n    if (i.empty)\n    {\n\
    \      return BracketState.ok_(i);\n    }\n    auto saved = i.save;\n    if (front_is_close(i))\n\
    \    {\n      i.popFront;\n      if (i.empty)\n      {\n        return BracketState.not_ok_(i);\n\
    \      }\n      if (front_is_close(i))\n      {\n        return BracketState.not_ok_(i);\n\
    \      }\n      else\n      {\n        i.popFront;\n        return iter_loop(i);\n\
    \      }\n    }\n    else\n    {\n      i.popFront;\n      if (i.empty)\n    \
    \  {\n        return BracketState.not_ok_(i);\n      }\n      if (front_is_close(i))\n\
    \      {\n       \nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptlyq0cpd.d(104): Error: found `unittest` instead of statement

    /tmp/tmptlyq0cpd.d(121): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmptlyq0cpd.d(121): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmptlyq0cpd.d(121): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptlyq0cpd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int count = 0;\n\tforeach(char x; brackets)\n\t{\n\t\tif(x == '<')\n\t\t\tcount++;\n\
    \t\telse if(x == '>')\n\t\t\tcount--;\n\t\tif(count < 0)\n\t\t\treturn false;\n\
    \t}\n\treturn count == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    brackets = <\"(\"|\")\">.join(brackets.split(\"<\"));\n\tforeach(c;brackets)\n\
    \t{\n\t\tif(c == \"(\") continue;\n\t\tif(c == \")\")\n\t\t{\n\t\t\tauto found\
    \ = brackets.find(\"(\");\n\t\t\tif(found==0)\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbrackets = brackets[0..found-1] ~ brackets[found+1..$];\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn brackets.length == 0;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6v_o2th4.d(19): Error: expression expected, not `<`

    /tmp/tmp6v_o2th4.d(19): Error: found `"("` when expecting `;` following statement

    /tmp/tmp6v_o2th4.d(19): Error: found `|` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6v_o2th4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint opentotal = 0, closetotal = 0;\n    uint i = 0;\n    while (i < brackets.length)\n\
    \    {\n        if (brackets[i] == '<')\n        {\n            opentotal++;\n\
    \        }\n        else\n        {\n            closetotal++;\n        }\n  \
    \      i++;\n    }\n    return opentotal == closetotal;\n}\n/*\n    reverse_list\
    \ should take a tuple of integers and return a tuple of integers.\n    The integers\
    \ in the tuple should be reversed from how they were in the original tuple.\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl5wfjh54.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl5wfjh54.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   assert(!brackets.empty);\n    foreach( c; brackets)\n    {\n        assert(c\
    \ == '<' || c == '>');\n    }\n    int stack = 0;\n    foreach( b; brackets)\n\
    \    {\n        if(b == '<') {\n            stack++;\n        } else {\n     \
    \       if(stack == 0) {\n                return false;\n            }\n     \
    \       stack--;\n        }\n    }\n    return stack == 0;\n}\n/*\n    Given a\
    \ starting position and direction,\n    return the next position.\n*/\nd_t step(d_t\
    \ pos, d_t dir)\n{\n    assert(dir != d_t(0,0));\n    pos += dir;\n    return\
    \ pos;\n}\nstruct TurnError\n{\n    enum TurnType\n    {\n        invalid,\n \
    \       overshoot,\n        loop,\n    } turnType;\n    TurnError(TurnType tt)\
    \ {\n        turnType = tt;\n    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjs17nbzz.d(55): Error: no identifier for declarator `turnType`

    /tmp/tmpjs17nbzz.d(56): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpjs17nbzz.d(56): Error: no identifier for declarator `TurnError(TurnType
    tt)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjs17nbzz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint brace_count = 0;\n    for (uint i = 0; i < brackets.length; i++) \n \
    \   {\n        if (brackets[i] == '<') \n        {\n            brace_count++;\n\
    \        } \n        else if (brackets[i] == '>') \n        {\n            if\
    \ (brace_count == 0) \n            {\n                return false;\n        \
    \    }\n            brace_count--;\n        }\n    }\n    return brace_count ==\
    \ 0;\n}\n/*\nbalanced_parentheses is a string of parentheses which is made up\
    \ of\nopening and closing parentheses in one of the following forms:\n    \n \
    \   \"\", \"()\", \"(())\", \"()()\", \"(()())\", \"((()))\" etc.\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwlbyk30i.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwlbyk30i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint pos, k;\n    Stack!(char) S;\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpchg8nor0.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchg8nor0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   return true;\n}\n/*\n    returns a version of the string where all brackets\
    \ are removed.\nunittest\n{\n    alias candidate = correct_bracketing;\n\n   \
    \ assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbxvfzopl.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbxvfzopl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int openbracket=0;\n    int closebracket=0;\n    //std.algorithm.find!(x =>\
    \ x == '>');\n    for(char i : brackets)\n    {\n        if(i=='<')\n        {\n\
    \            openbracket++;\n        }\n        else if(i=='>')\n        {\n \
    \           closebracket++;\n        }\n    }\n    if(openbracket==closebracket)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\n/*\n    return true if brackets is a balanced bracketing.\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeutgl87c.d(22): Error: semicolon expected, not `:`

    /tmp/tmpeutgl87c.d(22): Error: expression expected, not `:`

    /tmp/tmpeutgl87c.d(22): Error: found `brackets` when expecting `;` following `for`
    condition

    /tmp/tmpeutgl87c.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeutgl87c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int counter = 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n \
    \       if (brackets[i] == '<')\n        {\n            counter++;\n        }\n\
    \        else if (brackets[i] == '>')\n        {\n            counter--;\n   \
    \     }\n        if (counter < 0)\n        {\n            return false;\n    \
    \    }\n    }\n    if (counter == 0)\n    {\n        return true;\n    }\n   \
    \ else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(element; brackets) \n    {\n        if (element\
    \ == '<') \n        {\n            count++;\n        } \n        else if (element\
    \ == '>') \n        {\n            count--;\n        }\n        if (count < 0)\
    \ \n        {\n            return false;\n        }\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int a = 0;\n    for (auto itr = brackets.begin(); itr != brackets.end(); itr++)\n\
    \    {\n        if (*itr == '<')\n        {\n            a++;\n        } else\n\
    \        {\n            a--;\n        }\n        if (a < 0)\n        {\n     \
    \       return false;\n        }\n    }\n    if (a == 0)\n    {\n        return\
    \ true;\n    } else\n    {\n        return false;\n    }\n}\n/*\n    s is a string.\n\
    \    return s with all its vowels replaced by \"!\"\n    >>> replace_vowels(\"\
    \")\n    \"\"\n    >>> replace_vowels(\"aeiou\")\n    \"!!!!!\"\n    >>> replace_vowels(\"\
    hello world\")\n    \"h!ll! w!rld\"\n*/\nstring replace_vowels(string s)\n{\n\
    \    for (auto itr = s.begin(); itr != s.end(); itr++)\n    {\n        if (*itr\
    \ == 'a' || *itr == 'e' || *itr == 'i' || *itr == 'o' || *itr == 'u')\n      \
    \  {\n            *itr = '!';\n        }\n    }\n    return s;\n}\n/*\n    c is\
    \ a char.\n    return c with all its vowels replaced by \"!\"\n    >>> replace_vowels(\"\
    \")\n    \"\"\n    >>> replace_vowels(\"aeiou\")\n    \"!!!!!\"\n    >>> replace_vowels(\"\
    hello world\")\n    \"h!ll! w!rld\"\n*/\nchar replace_vowels_c(char c)\n{\n  \
    \  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n    {\n    \
    \    c = '!';\n    }\n    return c;\n}\n/*\n    s is a string.\n    Return s with\
    \ all its vowels removed.\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"\
    aeiou\")\n    \"\"\n    >>> remove_vowels(\"hello world\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwnxed1vx.d(81): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwnxed1vx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ int left;\n  int right;\n  left = count(brackets, \"<\");\n  right = count(brackets,\
    \ \">\");\n  if (left == right)\n  {\n    return true;\n  }\n  else\n  {\n   \
    \ return false;\n  }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpluq8bxlp.d(21): Error: undefined identifier `count`

    /tmp/tmpluq8bxlp.d(22): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpluq8bxlp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int c = 0;\n    foreach(char b; brackets)\n    {\n        if(b == '<')\n \
    \           c++;\n        else if(b == '>')\n            c--;\n        if(c <\
    \ 0)\n            return false;\n    }\n    return c == 0;\n}\nunittest\n{\n \
    \   alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool result = true;\n    int balance = 0;\n    foreach(char c; brackets) {\n\
    \        if (c == '<')\n            balance++;\n        else if (c == '>')\n \
    \           balance--;\n        if (balance < 0) {\n            result = false;\n\
    \            break;\n        }\n    }\n    if (balance != 0)\n        result =\
    \ false;\n    return result;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   foreach(c; brackets) \n    {\n        if (c == '<')\n            brackets\
    \ = brackets[1 .. $];\n        else if (c == '>')\n            return false;\n\
    \    }\n    return true;\n}\n/*\n * The syntax for function declarations is:\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0bsgd706.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0bsgd706.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ return true;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbo7pzzm8.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmpbo7pzzm8.__unittest_L21_C1() [0x427ada]

    ??:? void tmpbo7pzzm8.__modtest() [0x427c0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   auto b = array(int,length(brackets));\n    foreach(i,ch;zip(b,brackets)) {\n\
    \        ch == '<' ? b[i] = 1 : b[i] = -1;\n    }\n    int sum = 0;\n    foreach(i,v;b)\
    \ {\n        sum += v;\n        if(sum < 0) return false;\n    }\n    return sum\
    \ == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpypditmgb.d(19): Error: found `,` when expecting `.` following int

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpypditmgb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int leftbrackets = 0;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n\
    \        {\n            leftbrackets++;\n        }\n        else if(c == '>')\n\
    \        {\n            leftbrackets--;\n        }\n        if(leftbrackets <\
    \ 0)\n        {\n            return false;\n        }\n    }\n    return leftbrackets\
    \ == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   char[int] stack;\n    foreach(char bracket;brackets)\n    {\n        if(bracket\
    \ == '<')\n        {\n            stack ~= bracket;\n        }\n        else\n\
    \        {\n            if(stack.length == 0)\n            {\n               \
    \ return false;\n            }\n            stack.length--;\n        }\n    }\n\
    \    return stack.length == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdxtsxuv1.d(24): Error: cannot append type `char` to type `char[int]`

    /tmp/tmpdxtsxuv1.d(32): Error: `_aaLen(stack)` is not an lvalue and cannot be
    modified

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdxtsxuv1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   struct bracket\n    {\n        int type;\n        int index;\n    };\n   \
    \ auto arr = split(brackets, \"\");\n    bracket[] br;\n    foreach(i, c; arr)\n\
    \    {\n        if(c == \"<\")\n        {\n            br ~= bracket(0, i);\n\
    \        }\n        else if(c == \">\")\n        {\n            if(br.length ==\
    \ 0)\n            {\n                return false;\n            }\n          \
    \  br = br[0..$-1];\n        }\n    }\n    return br.length == 0;\n}\n/*\n   \
    \ return true if every opening bracket has a corresponding closing bracket.\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx0ocqc6m.d(23): Deprecation: use `{ }` for an empty statement,
    not `;`

    /tmp/tmpx0ocqc6m.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx0ocqc6m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164355
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n  \
    \          count++;\n        else if(c == '>')\n            count--;\n       \
    \ \n        if(count < 0)\n            return false;\n    }\n    return count\
    \ == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int balance = 0;\n    for (char ch : brackets)\n    {\n        if (ch == '<')\n\
    \            balance++;\n        else\n            balance--;\n        if (balance\
    \ < 0)\n            return false;\n    }\n    return balance == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzwa3dmki.d(20): Error: semicolon expected, not `:`

    /tmp/tmpzwa3dmki.d(20): Error: expression expected, not `:`

    /tmp/tmpzwa3dmki.d(20): Error: found `brackets` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzwa3dmki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int counter = 0;\n    foreach(c; brackets) \n    {\n        if (c == '<')\
    \ \n        {\n            counter++;\n        } \n        else if (c == '>')\
    \ \n        {\n            counter--;\n        }\n        if (counter < 0) \n\
    \        {\n            return false;\n        }\n    }\n    return counter ==\
    \ 0;\n}\n/*\n    return the number of left brackets, minus the number of right\
    \ brackets, in brackets\n    \n    >>> num_left_brackets(\"<\")\n    1\n    >>>\
    \ num_left_brackets(\"<>\")\n    1\n    >>> num_left_brackets(\"<<><>>\")\n  \
    \  2\n    >>> num_left_brackets(\"><<>\")\n    -1\n*/\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int size = 0;\n\tint index = 0;\n\twhile (index < brackets.length)\n\t{\n\t\t\
    if (brackets[index] == '<')\n\t\t{\n\t\t\tsize++;\n\t\t}\n\t\telse if (brackets[index]\
    \ == '>')\n\t\t{\n\t\t\tsize--;\n\t\t}\n\t\tif (size < 0)\n\t\t{\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tindex++;\n\t}\n\tif (size == 0)\n\t{\n\t\treturn true;\n\t\
    }\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nunittest\n{\n    alias candidate =\
    \ correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool flag = true;\n    Tuple!(int, int) count = tuple(0, 0);\n    foreach(cur;\
    \ brackets)\n    {\n        if(cur == '<')\n        {\n            ++count[0];\n\
    \        }\n        else if(cur == '>')\n        {\n            ++count[1];\n\
    \        }\n        if(count[1] > count[0])\n        {\n            flag = false;\n\
    \            break;\n        }\n    }\n    return flag && count[0] == count[1];\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   struct Stack { \n      //stack is used to match the brackets\n      string[]\
    \ array;\n      int top;\n    }\n    Stack s;\n    s.array = new string[100];\n\
    \    s.top = -1;\n    foreach(i;0..brackets.length) {\n      if(brackets[i] ==\
    \ '<') {\n        s.top++;\n        s.array[s.top] = '<';\n      }\n      else\
    \ if(brackets[i] == '>') {\n        if(s.top == -1) {\n          return false;\n\
    \        }\n        else {\n          s.top--;\n        }\n      }\n    }\n  \
    \  if(s.top != -1) {\n      return false;\n    }\n    return true;\n}\n/*\n  \
    \  This is a more general version of the previous question.\n    brackets is a\
    \ string consisting of \"<\", \">\", \"[\", \"]\", \"{\", and \"}\".\n    return\
    \ true if every opening bracket has a corresponding closing bracket,\n    and\
    \ bracketing is correct for all sets of brackets.\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdhphlt0w.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdhphlt0w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \  int open_count = 0;\n   for (char c : brackets) {\n       if (c == '<') {\n\
    \           open_count++;\n       } else if (c == '>') {\n           open_count--;\n\
    \       }\n       if (open_count < 0) {\n           return false;\n       }\n\
    \   }\n   return open_count == 0;\n}\n/*\n    >>> bracket_remover(\"<><<<><>>>>>\"\
    )\n    '<<>>'\n    >>> bracket_remover(\"<><<<><<>>>>>\")\n    '<<<>>'\n    >>>\
    \ bracket_remover(\"<><<<><>>>>>\")\n    '<<>>'\n    >>> bracket_remover(\"<<<><><<<><<>>>>\"\
    )\n    '<<><<>>>>'\n    >>> bracket_remover(\"<>\")\n    ''\n    >>> bracket_remover(\"\
    <><<><>>>>>\")\n    '<<><>>>>'\n    >>> bracket_remover(\"<<><<><<<><>>>>>\")\n\
    \    '<<><>>>>'\n*/\nstring bracket_remover(string brackets)\n{\n    int open_count\
    \ = 0;\n    string result = \"\";\n    for (char c : brackets) {\n        if (c\
    \ == '<') {\n            open_count++;\n        } else if (c == '>') {\n     \
    \       open_count--;\n        }\n        if (open_count == 0) {\n           \
    \ continue;\n        }\n        result += c;\n    }\n    return result;\n}\n/*\n\
    \    >>> tree_counter(\"<>\")\n    1\n    >>> tree_counter(\"<>>\")\n    1\n \
    \   >>> tree_counter(\"<<>>\")\n    2\n    >>> tree_counter(\"<<>>>\")\n    3\n\
    \    >>> tree_counter(\"<<<>>>\")\n    3\n    >>> tree_counter(\"<<<>>>>\")\n\
    \    4\n    >>> tree_counter(\"<<><<<<>>>>\")\n    8\n    >>> tree_counter(\"\
    <<><<<<>>>>\")\n    8\n    >>> tree_counter(\"<<><<<<>>>>\")\n    8\n    >>> tree_counter(\"\
    <<<><<<>>>>\")\n    4\n    >>> tree_counter(\"<<<><\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgyx8xsm7.d(20): Error: semicolon expected, not `:`

    /tmp/tmpgyx8xsm7.d(20): Error: expression expected, not `:`

    /tmp/tmpgyx8xsm7.d(20): Error: found `brackets` when expecting `;` following `for`
    condition

    /tmp/tmpgyx8xsm7.d(52): Error: semicolon expected, not `:`

    /tmp/tmpgyx8xsm7.d(52): Error: expression expected, not `:`

    /tmp/tmpgyx8xsm7.d(52): Error: found `brackets` when expecting `;` following `for`
    condition

    /tmp/tmpgyx8xsm7.d(65): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgyx8xsm7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int count1 = 0;\n\tforeach(x; brackets)\n\t{\n\t\tif(x == '<')\n\t\t{\n\t\t\t\
    count1++;\n\t\t}\n\t\telse if(x == '>')\n\t\t{\n\t\t\tcount1--;\n\t\t}\n\t\tif(count1\
    \ < 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(count1 == 0)\n\t{\n\t\treturn\
    \ true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   \n    int open = 0;\n    int closed = 0;\n    int len = length(brackets);\n\
    \    if (brackets[0] == '>')\n        return false;\n    if (len > 0)\n    {\n\
    \        for (int i = 0; i < len; i++)\n        {\n            if (brackets[i]\
    \ == '<')\n                open += 1;\n            else\n                closed\
    \ += 1;\n            if (closed > open)\n                return false;\n     \
    \   }\n        if (open != closed)\n            return false;\n        else\n\
    \            return true;\n    }\n    else\n        return false;\n}\n/*\n   \
    \ Given a string of symbols, return the reverse polish notation of the symbols.\n\
    \    If there are \"(\" in the string, it must be a valid bracketing, i.e.,\n\
    \    for every \"(\" there must be a \")\". And the \"(\" and \")\" must be in\
    \ pairs\n    and enclose the whole string.\nunittest\n{\n    alias candidate =\
    \ correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcp6yicvf.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcp6yicvf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int k=0;\n    foreach(bracket;brackets)\n    {\n        if(bracket=='<')\n\
    \            k++;\n        else\n            k--;\n        if(k<0)\n         \
    \   return false;\n    }\n    return k==0;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{ \n\
    \    /*\n    int counter = 0;\n    foreach(b; brackets)\n    {\n        if(b ==\
    \ '<')\n            counter++;\n        else\n            counter--;\n       \
    \ if(counter < 0)\n            return false;\n    }\n    return counter == 0;\n\
    \    */\n    return brackets.count('<') == brackets.count('>');\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpldohq8ai.d(32): Error: no property `count` for type `string`

    /tmp/tmpldohq8ai.d(32): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpldohq8ai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   Stack() lst = new Stack();\n    for (dchar elem in brackets)\n    {\n    \
    \    if (elem == '<')\n        {\n            lst.push(elem);\n        }\n   \
    \     else\n        {\n            if (lst.empty)\n            {\n           \
    \     return false;\n            }\n            else\n            {\n        \
    \        lst.pop();\n            }\n        }\n    }\n    return lst.empty;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaajy0zi_.d(19): Error: found `lst` when expecting `;` following
    statement

    /tmp/tmpaajy0zi_.d(19): Error: found `=` instead of statement

    /tmp/tmpaajy0zi_.d(20): Error: semicolon expected, not `in`

    /tmp/tmpaajy0zi_.d(20): Error: expression expected, not `in`

    /tmp/tmpaajy0zi_.d(20): Error: found `brackets` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaajy0zi_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   import std.typecons;\n    int oppen_bracket_count = 0;\n    foreach(char ch;\
    \ brackets)\n    {\n        if(ch == '<')\n        {\n            oppen_bracket_count++;\n\
    \        }\n        else if(ch == '>')\n        {\n            oppen_bracket_count--;\n\
    \        }\n        if(oppen_bracket_count < 0)\n        {\n            return\
    \ false;\n        }\n    }\n    return oppen_bracket_count == 0;\n}\n/*\n    >>>\
    \ a = [1,2,3,1]\n    >>> only_unique(a)\n    false\n    >>> a = [1,2,3]\n    >>>\
    \ only_unique(a)\n    true\n    >>> a = [1,1,1]\n    >>> only_unique(a)\n    false\n\
    */\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint i = 0;\n    uint depth = 0;\n    while (i < brackets.length)\n    {\n\
    \        if (brackets[i] == '<')\n        {\n            depth++;\n        }\n\
    \        else if (brackets[i] == '>')\n        {\n            if (depth == 0)\n\
    \            {\n                return false;\n            }\n            depth--;\n\
    \        }\n        i++;\n    }\n    return depth == 0;\n}\n/*\n brackets is a\
    \ string of \"<\" and \">\".\n    return true if every opening bracket has a corresponding\
    \ closing bracket.\nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvuhbnfqw.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvuhbnfqw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int p = 0;\n\tforeach(c;brackets)\n\t{\n\t\tif(c == '<')\n\t\t\tp++;\n\t\telse\n\
    \t\t\tp--;\n\t\tif(p < 0)\n\t\t\treturn false;\n\t}\n\treturn p == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(ch; brackets)\n    {\n        if(ch == '<')\n\
    \            count++;\n        else if(ch == '>')\n            count--;\n    \
    \    if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\n/*\n        return a new string in which all characters occur in the same order,\
    \ but\n        at most max_consecutive times.\n        >>> no_more_than_n_times(\"\
    \", 0)\n        \"\"\n        >>> no_more_than_n_times(\"a\", 0)\n        \"\"\
    \n        >>> no_more_than_n_times(\"a\", 1)\n        \"a\"\n        >>> no_more_than_n_times(\"\
    a\", 2)\n        \"a\"\n        >>> no_more_than_n_times(\"aaa\", 1)\n       \
    \ \"a\"\n        >>> no_more_than_n_times(\"aaa\", 2)\n        \"aa\"\n      \
    \  >>> no_more_than_n_times(\"banana\", 3)\n        \"banana\"\n        >>> no_more_than_n_times(\"\
    banana\", 4)\n        \"banana\"\n        >>> no_more_than_n_times(\"abracadabra\"\
    , 2)\n        \"abracadabra\"\n        >>> no_more_than_n_times(\"abracadabra\"\
    , 3)\n        \"abracadabra\"\n        >>> no_more_than_n_times(\"abracadabra\"\
    , 4)\n        \"abracadabra\"\n        >>> no_more_than_n_times(\"aaaaa\", 2)\n\
    \        \"aaba\"\n        >>> no_more_than_n_times(\"aaaaa\", 3)\n        \"\
    aaab\"\n        >>> no_more_than_n_times(\"aaaaa\", 4)\n        \"aaab\"\n   \
    \     >>> no_more_than_n_times(\"aaaaaaaaaa\", 2)\n        \"aabaabaa\"\n    \
    \    >>> no_more_than_n_times(\"aaaaaaaaaa\", 3)\n        \"aaabaaab\"\n     \
    \   >>> no_more_than_n_times(\"aaaaaaaaaa\",\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkknpfezd.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkknpfezd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{ \n\
    \    uint int count = 0;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n\
    \            count++;\n        else if(c == '>')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfl2ihw3w.d(19): Error: no identifier for declarator `uint`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfl2ihw3w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int balance = 0;\n    for (size_t i = 0; i < brackets.length; i++)\n    {\n\
    \        if (brackets[i] == '<')\n        {\n            balance += 1;\n     \
    \   }\n        else\n        {\n            balance -= 1;\n        }\n       \
    \ if (balance < 0) return false;\n    }\n    return balance == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool correct = true;\n    int counter = 0;\n    foreach(char c; brackets)\n\
    \    {\n        if(c == '<')\n        {\n            counter++;\n        }\n \
    \       else if(c == '>')\n        {\n            counter--;\n        }\n    \
    \    if(counter < 0)\n        {\n            correct = false;\n            break;\n\
    \        }\n    }\n    return correct && counter == 0;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   return brackets.length % 2 == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjfnfhd0n.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ea5]

    ??:? void tmpjfnfhd0n.__unittest_L21_C1() [0x427b1b]

    ??:? void tmpjfnfhd0n.__modtest() [0x427c24]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbcb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbf1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb7d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa35]

    ??:? runModuleUnitTests [0x42b9a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   return true;\n}\n/*\n fibonacci returns the nth fibonacci number.\n    The\
    \ fibonacci sequence is a series of numbers where each number is the sum of the\
    \ previous two.\n    In fibonacci(0), return 0.\n    In fibonacci(1), return 1.\n\
    \    In fibonacci(2), return 1.\n    In fibonacci(3), return 2.\n    In fibonacci(4),\
    \ return 3.\n    In fibonacci(5), return 5.\n    In fibonacci(6), return 8.\n\
    \    In fibonacci(7), return 13.\n    In fibonacci(8), return 21.\n    In fibonacci(9),\
    \ return 34.\n    In fibonacci(10), return 55.\n    \n*/\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgor0rgkb.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmpgor0rgkb.__unittest_L37_C1() [0x427ada]

    ??:? void tmpgor0rgkb.__modtest() [0x427c0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool wrong_count = false;\n    int counter = 0;\n    foreach(char c; brackets)\n\
    \    {\n        if(c == '<')\n        {\n            counter++;\n        }\n \
    \       else\n        {\n            counter--;\n        }\n        if(counter\
    \ < 0)\n        {\n            wrong_count = true;\n        }\n    }\n    if(counter\
    \ != 0)\n    {\n        wrong_count = true;\n    }\n    return !wrong_count;\n\
    }\n/*\n    polygon is a list of 2-tuples of floats.\n    return true if polygon\
    \ is a convex polygon.\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8398ig6f.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8398ig6f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n    in\
    \ \n    {\n        assert(!brackets.empty);\n    }\n    out (result)\n    {\n\
    \        assert(result == std.algorithm.all!(\n            \"(a, b) => (a == '<'\
    \ && b == '>') || (a == '>' && b == '<')\"\n        )(brackets));\n    }\n{\n\
    \    return std.algorithm.all!(\n        \"(a, b) => (a == '<' && b == '>') ||\
    \ (a == '>' && b == '<')\"\n    )(brackets);\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqfro07v5.d(28): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqfro07v5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ int count = 0;\n  for (int i = 0; i < brackets.length; i++)\n  {\n    if (brackets[i]\
    \ == '<')\n    {\n      count++;\n    }\n    else\n    {\n      count--;\n   \
    \ }\n    if (count < 0)\n    {\n      return false;\n    }\n  }\n  if (count ==\
    \ 0)\n  {\n    return true;\n  }\n  else\n  {\n    return false;\n  }\n  \n}\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    string opening = \"<\";\n\tstring closing = \">\";\n\t//int open_count = 0;\n\t\
    //int close_count = 0;\n\tint open_closing_count = 0;\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjn9zh_e1.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjn9zh_e1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // invariant:\n    //    sofar is a string of \"<\" and \">\"\n    //    every\
    \ opening bracket in sofar has a corresponding closing bracket\n    //    \">>\"\
    \ is not a substring of sofar\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8vsdnfdh.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8vsdnfdh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n    {\n\
    \    if (brackets.length == 0) \n        {\n        return true;\n        } \n\
    \    else if (brackets.at(0) == '>') \n        {\n        return false;\n    \
    \    } \n    else \n        {\n        int current_bracket_level = 0;\n      \
    \  auto closing_bracket_loc = -1;\n        for (int i = 0; i < brackets.length;\
    \ i++) \n            {\n            if (brackets.at(i) == '<') \n            \
    \    {\n                current_bracket_level += 1;\n                } \n    \
    \        else if (brackets.at(i) == '>') \n                {\n               \
    \ current_bracket_level -= 1;\n                if (current_bracket_level == 0)\
    \ \n                    {\n                    closing_bracket_loc = i;\n    \
    \                break;\n                    }\n                }\n          \
    \  }\n        if (closing_bracket_loc == -1) \n            {\n            return\
    \ false;\n            } \n        else \n            {\n            return correct_bracketing(brackets.substr(1,\
    \ closing_bracket_loc - 1)) && correct_bracketing(brackets.substr(closing_bracket_loc\
    \ + 1, brackets.length - closing_bracket_loc - 1));\n            }\n        }\n\
    \    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwrq5vr7t.d(23): Error: no property `at` for type `string`

    /tmp/tmpwrq5vr7t.d(33): Error: no property `at` for type `string`

    /tmp/tmpwrq5vr7t.d(37): Error: no property `at` for type `string`

    /tmp/tmpwrq5vr7t.d(53): Error: no property `substr` for type `string`

    /tmp/tmpwrq5vr7t.d(53): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwrq5vr7t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ int count = 0;\n  for (int i = 0; i < brackets.length; i++) \n  {\n    if (brackets[i]\
    \ == '<')\n    {\n      count++;\n    }\n    else if (brackets[i] == '>')\n  \
    \  {\n      count--;\n    }\n  }\n  return count == 0;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfehdi74l.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f1d]

    ??:? void tmpfehdi74l.__unittest_L33_C1() [0x427b93]

    ??:? void tmpfehdi74l.__modtest() [0x427c9c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bcb7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab4a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcdd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43018c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc69]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab21]

    ??:? runModuleUnitTests [0x42ba8d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   struct Count {\n        // Alias declarations are a way to give a new name\
    \ to an existing type.\n        alias ValueType = int;\n        ValueType value;\n\
    \    } ;\n    // Tuple of 2 integer, int constructor\n    auto tuple = tuple(0,\
    \ 0);\n    foreach(bracket; brackets) {\n        if (bracket == '<') {\n     \
    \       // Tuple set index 0 to tuple[0] + 1\n            tuple[0] = tuple[0]\
    \ + 1;\n        } else {\n            // Tuple set index 1 to tuple[1] + 1\n \
    \           tuple[1] = tuple[1] + 1;\n        }\n    }\n    // tuple get index\
    \ 0 equal to tuple get index 1\n    return tuple[0] == tuple[1];\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: '/tmp/tmph3680zg3.d(23): Deprecation: use `{ }` for an empty statement,
    not `;`

    /tmp/tmph3680zg3.d(23): Deprecation: use `{ }` for an empty statement, not `;`

    core.exception.AssertError@/tmp/tmph3680zg3.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ac5]

    ??:? void tmph3680zg3.__unittest_L38_C1() [0x4280f3]

    ??:? void tmph3680zg3.__modtest() [0x428530]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d46f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42c37e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430ca5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431154]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430c31]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c355]

    ??:? runModuleUnitTests [0x42d245]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428f14]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   foreach(i; 0 .. brackets.length)\n    {\n        foreach(j; i .. brackets.length)\n\
    \        {\n            if(brackets[i] == '<' && brackets[j] == '>')\n       \
    \     {\n                brackets[i] = ' ';\n                brackets[j] = ' ';\n\
    \                break;\n            }\n        }\n    }\n    return brackets.indexOf('<')\
    \ == -1;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnswgjqja.d(25): Error: cannot modify `immutable` expression `brackets[i]`

    /tmp/tmpnswgjqja.d(26): Error: cannot modify `immutable` expression `brackets[j]`

    /tmp/tmpnswgjqja.d(31): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnswgjqja.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int bal = 0;\n    foreach(ch;brackets)\n    {\n        if(ch == '<')\n   \
    \         bal++;\n        else\n            bal--;\n        if(bal < 0)\n    \
    \        return false;\n    }\n    return bal == 0;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int n = brackets.length;\n    int count = 0;\n    for (int i = 0; i < n; i++)\n\
    \    {\n        if (brackets[i] == '<')\n        {\n            count++;\n   \
    \     }\n        else if (brackets[i] == '>')\n        {\n            count--;\n\
    \        }\n        if (count < 0)\n        {\n            return false;\n   \
    \     }\n    }\n    return count == 0;\n}\n/*\n * return true if every opening\
    \ bracket in brackets has a corresponding closing bracket before any other type\
    \ of character.\n * \n * >>> correct_bracketing_before_other_character(\"<<><\"\
    )\n * true\n * >>> correct_bracketing_before_other_character(\"<>\")\n * true\n\
    \ * >>> correct_bracketing_before_other_character(\"<<><>>\")\n * true\n * >>>\
    \ correct_bracketing_before_other_character(\"><<><>\")\n * false\n * >>> correct_bracketing_before_other_character(\"\
    <ab>\")\n * true\n * >>> correct_bracketing_before_other_character(\"<<>ab>\"\
    )\n * true\n * >>> correct_bracketing_before_other_character(\"<<>a<b>\")\n *\
    \ false\n */\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpey41fpyf.d(19): Error: cannot implicitly convert expression `brackets.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpey41fpyf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int nLeft=0;\n    int nRight=0;\n    foreach(char c;brackets)\n    {\n   \
    \     switch(c)\n        {\n            case '<':\n                nLeft++;\n\
    \                break;\n            case '>':\n                nRight++;\n  \
    \              break;\n        }\n    }\n    return nLeft==nRight;\n}\n/*\n  \
    \  A word ladder is a sequence of words where each word is one letter different\
    \ from the previous.\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl2gwt5sk.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl2gwt5sk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   \n    uint counter = 0;\n    foreach(x; brackets)\n    {\n        if(x ==\
    \ '<')\n        {\n            counter++;\n        }\n        else\n        {\n\
    \            counter--;\n        }\n        if(counter == -1)\n        {\n   \
    \         return false;\n        }\n    }\n    if(counter == 0)\n    {\n     \
    \   return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n/*\n\
    \    A unival tree is a tree which has the same value at every node.\n    return\
    \ true if tree is a unival tree.\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgzwlvfqk.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgzwlvfqk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint count = 0;\n    foreach(b; brackets) \n    {\n        if (b == '<') \n\
    \        {\n            count++;\n        }\n        else if (b == '>') \n   \
    \     {\n            if (count == 0) \n            {\n                return false;\n\
    \            }\n            count--;\n        }\n    }\n    return count == 0;\n\
    }\n/*\n    anagrams is a sequence of words.\n    return a list of words that form\
    \ anagrams of each other.\n    >>> find_anagrams([\"ab\", \"ba\", \"abcd\", \"\
    dcba\", \"bac\", \"dabc\"])\n    [[\"ab\", \"ba\"], [\"abcd\", \"dcba\", \"bac\"\
    , \"dabc\"]]\n    >>> find_anagrams([\"silence\", \"enlist\", \"dictionary\",\
    \ \"tinsel\", \"listen\", \"boaster\", \"boaters\", \"borates\", \"toaster\"])\n\
    \    [[\"silence\", \"enlist\", \"tinsel\", \"listen\"], [\"dictionary\"], [\"\
    boaster\", \"boaters\", \"borates\", \"toaster\"]]\n    >>> find_anagrams([\"\
    silence\", \"enlist\", \"dictionary\", \"tinsel\", \"listen\", \"silent\"])\n\
    \    [[\"silence\", \"enlist\", \"tinsel\", \"listen\", \"silent\"]]\n*/\nauto\
    \ find_anagrams(immutable string[] words) \n{\n    immutable sorted_words = words.map!(w\
    \ => tuple(w, w.sort));\n    return sorted_words.values.groupBy!(a => a.item2).values.map!(s\
    \ => s.map!(a => a.item1));\n}\n/*\n    is a string that is valid if it has a\
    \ \"(\" \")\" \".\" \"?\" \":\" or \"*\" in this order.\n    >>> is_valid(\"(.)\"\
    )\n    true\n    >>> is_valid(\"(.?)\")\n    true\n    >>> is_valid(\"(.?).\"\
    )\n    false\n    >>> is_valid(\"(.*):\")\n    true\n    >>> is_valid(\"(.*):*\"\
    )\n    false\n\nunittest\n{\n    alias candidate = correct_bracketing;\n\n   \
    \ assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxvcz9n0.d(52): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxvcz9n0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(immutable ch;brackets)\n    {\n        if(ch ==\
    \ '<')\n            count++;\n        else if(ch == '>')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\n/*\n>>> correct_bracketing(\"<><<>><<<>>\")\ntrue\n*/\nunittest\n{\n\
    \    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int counter = 0;\n    for (int i = 0; i < brackets.length; i++) {\n      \
    \  if (brackets[i] == '<')\n            counter += 1;\n        else\n        \
    \    counter -= 1;\n        \n        if (counter < 0)\n            return false;\n\
    \    }\n    return counter == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint bracket_count = 0;\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ci0j42v.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ci0j42v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool can_pop = false;\n    for (int i = 0; i < brackets.length; i++)\n   \
    \ {\n\tif (brackets[i] == '<') can_pop = true;\n\telse if (brackets[i] == '>')\n\
    \t{\n\t    if (can_pop) can_pop = false;\n\t    else return false;\n\t}\n    }\n\
    \    return !can_pop;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps5l8hpvk.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f35]

    ??:? void tmps5l8hpvk.__unittest_L31_C1() [0x427b0b]

    ??:? void tmps5l8hpvk.__modtest() [0x427cb8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bccf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab62]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcf5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4301a4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc81]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab39]

    ??:? runModuleUnitTests [0x42baa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool flag = true;\n    for (int i = 0; i < brackets.length; i++)\n    {\n\
    \        if (brackets[i] == '<') \n        {\n            while (brackets[i] ==\
    \ '<') \n            {\n                i++;\n            }\n            if (brackets[i]\
    \ != '>') \n            {\n                flag = false;\n                break;\n\
    \            }\n        }\n        else if (brackets[i] == '>') \n        {\n\
    \            flag = false;\n            break;\n        }\n    }\n    return flag;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyk08oa83.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f7d]

    ??:? void tmpyk08oa83.__unittest_L42_C1() [0x427b53]

    ??:? void tmpyk08oa83.__modtest() [0x427d00]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd17]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42abaa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fd3d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4301ec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fcc9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab81]

    ??:? runModuleUnitTests [0x42baed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428440]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    for (int i = 0; i < brackets.length; i++) {\n        if\
    \ (brackets[i] == '<') {\n            count++;\n        } else if (brackets[i]\
    \ == '>') {\n            count--;\n        }\n        if (count < 0) return false;\n\
    \    }\n    return count == 0;\n}\n/*\n a binary tree is a recursive data structure\
    \ that stores the value of a node,\n and the two subtrees of the node.\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4z319qn7.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4z319qn7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int len = brackets.length;\n    int open = 0;\n    for (int i = 0; i < len;\
    \ i++) {\n        if (brackets[i] == '<') open++;\n        else if (brackets[i]\
    \ == '>') {\n            if (open == 0) return false;\n            open--;\n \
    \       }\n    }\n    return open == 0;\n}\nunittest\n{\n    alias candidate =\
    \ correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9l8hjt5.d(19): Error: cannot implicitly convert expression `brackets.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9l8hjt5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   /*\n    if(brackets.length == 0){return true;}\n    int count = 0;\n    foreach(ch;brackets){\n\
    \        if(ch == '<'){\n            count++;\n        }\n        else if(ch ==\
    \ '>'){\n            count--;\n        }\n        if(count < 0){\n           \
    \ return false;\n        }\n    }\n    return count == 0;\n    */\n    \n    int\
    \ cnt = 0;\n    foreach(ch;brackets){\n        if(ch == '<'){\n            cnt\
    \ += 1;\n        }\n        else if(ch == '>'){\n            cnt -= 1;\n     \
    \   }\n        if(cnt < 0){\n            return false;\n        }\n    }\n   \
    \ return cnt == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count_lt = 0;\n    int count_gt = 0;\n    foreach(i; 0 .. brackets.length)\n\
    \    {\n        if(brackets[i] == '<')\n        {\n            count_lt++;\n \
    \       }\n        else if(brackets[i] == '>')\n        {\n            count_gt++;\n\
    \        }\n        if(count_gt > count_lt)\n        {\n            return false;\n\
    \        }\n    }\n    if(count_lt == count_gt)\n    {\n        return true;\n\
    \    }\n    else\n    {\n        return false;\n    }\n}\n/*\n    return true\
    \ if brackets contains balanced\n    brackets.  A bracket is either \"<\" or \"\
    >\".\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphxkh9vj1.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphxkh9vj1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{ \n\
    \    int count1 = 0;\n    int count2 = 0;\n    int count3 = 0;\n    int i = 0;\n\
    \    foreach(ch; brackets)\n    {\n        if(ch == '<')\n        {\n        \
    \    ++count1;\n        }\n        else if(ch == '>')\n        {\n           \
    \ ++count2;\n        }\n    }\n    foreach(ch; brackets)\n    {\n        if(ch\
    \ == '<')\n        {\n            ++count3;\n        }\n        else if(ch ==\
    \ '>')\n        {\n            --count3;\n        }\n        if(count3 < 0)\n\
    \        {\n            return false;\n        }\n    }\n    if(count1 == count2)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int balance = 0;\n    foreach(char ch; brackets)\n    {\n        if (ch ==\
    \ '<')\n            balance++;\n        else if (ch == '>')\n            balance--;\n\
    \        if (balance < 0)\n            return false;\n    }\n    return balance\
    \ == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint x = 0;\n    foreach(inout char c; brackets)\n    {\n        if(c == '<')\
    \ x++;\n        else if(c == '>') x--;\n        else throw new Exception(\"String\
    \ does not contain only < and >.\");\n    }\n    return x == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt_unfde5.d(20): Error: variable `tmpt_unfde5.correct_bracketing.c`
    `inout` variables can only be declared inside `inout` functions

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt_unfde5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{ \n\
    \    int count = 0;\n    foreach(int ch; brackets)\n    {\n        if(ch == '<')\n\
    \            count++;\n        else if(ch == '>')\n            count--;\n    \
    \    if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{ \n\
    \  bool r = true;\n  if(brackets.length > 1)\n  {\n    alias ch = brackets[0];\n\
    \    if(ch == '<')\n    {\n      auto c = brackets.popFront;\n      r = correct_bracketing(c);\n\
    \      if(r)\n      {\n        auto p = c.popFront;\n        if(p != \"\")\n \
    \       {\n          if(p[0] == '>')\n          {\n            p.popFront;\n \
    \           r = correct_bracketing(p);\n          }else\n          {\n       \
    \     r = false;\n          }\n        }\n      }\n    }else\n    {\n      r =\
    \ false;\n    }\n  }else\n  {\n    r = false;\n  }\n  return r;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj79v91e0.d(22): Error: alias `ch` cannot alias an expression `brackets[0]`

    /tmp/tmpj79v91e0.d(25): Error: no property `popFront` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj79v91e0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   return false;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt78ch8th.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmpt78ch8th.__unittest_L21_C1() [0x427a36]

    ??:? void tmpt78ch8th.__modtest() [0x427c0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   if(brackets.empty)\n        return true;\n    int b = 0;\n    foreach(c;brackets)\n\
    \    {\n        if(c == '<')\n            b++;\n        else if(c == '>')\n  \
    \          b--;\n        if(b < 0)\n            return false;\n    }\n    return\
    \ b == 0;\n}\nstruct minmax(T)\n{\n    T min;\n    T max;\n    this(T t)\n   \
    \ {\n        min = t;\n        max = t;\n    }\n    this(T min, T max)\n    {\n\
    \        this.min = min;\n        this.max = max;\n    }\n    bool empty()\n \
    \   {\n        return min > max;\n    }\n    @property bool opEquals(minmax!T\
    \ that)\n    {\n        return min == that.min && max == that.max;\n    }\n  \
    \  @property bool opEquals(T that)\n    {\n        return min == that && max ==\
    \ that;\n    }\n    auto tupleof()\n    {\n        return tuple(min, max);\n \
    \   }\n    auto opCast(T)\n    {\n        return tupleof();\n    }\n}\nstruct\
    \ arr(T)\n{\n    size_t offset;\n    size_t length;\n    T* p;\n    this(T* p,\
    \ size_t offset, size_t length)\n    {\n        this.p = p;\n        this.offset\
    \ = offset;\n        this.length = length;\n    }\n    this(T* p, size_t length)\n\
    \    {\n        this.p = p;\n        this.offset = 0;\n        this.length = length;\n\
    \    }\n    auto opIndex(size_t i)\n    {\n        return p[offset + i];\n   \
    \ }\n    auto opSlice()\n    {\n        return this;\n    }\n    auto opSlice(size_t\
    \ low)\n    {\n        return arr!T(p, offset + low, length - low);\n    }\n \
    \   auto opSlice(size_t low, size_t high)\n    {\n        return\nunittest\n{\n\
    \    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp48c91qqx.d(100): Error: expression expected, not `unittest`

    /tmp/tmp48c91qqx.d(101): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmp48c91qqx.d(117): Error: `}` expected following members in `struct` declaration
    at /tmp/tmp48c91qqx.d(68)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp48c91qqx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   return brackets.sum!((a, b) => a == '<' ? 1 : -1) == 0;\n}\n/*\n find_bracketing\
    \ is a string of \"<\" and \">\".\n    return true if there is a sequence of brackets\
    \ such that every opening bracket\n    has a corresponding closing bracket.\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpstkeq6ei.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpstkeq6ei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   \n    return true;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfyrisnt_.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmpfyrisnt_.__unittest_L22_C1() [0x427ada]

    ??:? void tmpfyrisnt_.__modtest() [0x427c0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(char ch; brackets)\n    {\n        if(ch == '<')\n\
    \            count++;\n        else if(ch == '>')\n            count--;\n    \
    \    \n        if(count < 0)\n            return false;\n    }\n    return count\
    \ == 0;\n}\n/*\ndigit_sum is a string of digits, such as \"0123\".\n    return\
    \ the sum of all the digits in the string.\nunittest\n{\n    alias candidate =\
    \ correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpozgkqzpw.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpozgkqzpw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int open = 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n    \
    \    if (brackets[i] == '<')\n        {\n            open++;\n        }\n    \
    \    else if (brackets[i] == '>')\n        {\n            open--;\n        }\n\
    \        if (open < 0)\n        {\n            return false;\n        }\n    }\n\
    \    return open == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // If the length of brackets is odd, return false.\n    if (brackets.length\
    \ % 2 == 1) \n    {\n        return false;\n    }\n    else \n    {\n        int\
    \ count = 0;\n        //for each of the bracket in brackets\n        foreach (bracket;\
    \ brackets) \n        {\n            //if the bracket is \">\" and count is less\
    \ than 0, return false\n            if (bracket == '>' && count < 0) \n      \
    \      {\n                return false;\n            }\n            //if the bracket\
    \ is \"<\", increase count by 1\n            else if (bracket == '<') \n     \
    \       {\n                count += 1;\n            }\n            //if the bracket\
    \ is \">\", decrease count by 1\n            else if (bracket == '>') \n     \
    \       {\n                count -= 1;\n            }\n        }\n        // if\
    \ count equals 0, return true. if not, return false.\n        if (count == 0)\
    \ \n        {\n            return true;\n        }\n        else \n        {\n\
    \            return false;\n        }\n    }\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnzmt1s0p.d(66): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f35]

    ??:? void tmpnzmt1s0p.__unittest_L57_C1() [0x427bab]

    ??:? void tmpnzmt1s0p.__modtest() [0x427cb4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aaee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc81]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430130]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc0d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aac5]

    ??:? runModuleUnitTests [0x42ba31]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428384]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n   \
    \     if (brackets[i] == '<')\n        {\n            count += 1;\n        }\n\
    \        else\n        {\n            count -= 1;\n        }\n        if (count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    return count\
    \ == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   \n    int i = 0;\n    int count = 0;\n    for(int i = 0; i < brackets.length;\
    \ i++)\n    {\n        if(brackets[i] == '<')\n        {\n            count++;\n\
    \        }\n        else\n        {\n            count--;\n        }\n       \
    \ if(count < 0)\n        {\n            return false;\n        }\n    }\n    if(count\
    \ == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfbkoe4_9.d(22): Error: variable `i` is shadowing variable `tmpfbkoe4_9.correct_bracketing.i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfbkoe4_9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ auto l = brackets.length;\n  // the empty string is correct\n  if (l == 0) return\
    \ true;\n  if (l == 1) return false;\n  // test the first bracket\n  if (brackets[0]\
    \ == '>') return false;\n  // test the last bracket\n  if (brackets[l-1] == '<')\
    \ return false;\n  // test bracketing\n  // assert(l>=2);\n  int stack = 0;\n\
    \  for (int i = 0; i < l; i++)\n  {\n    char c = brackets[i];\n    if (c == '<')\n\
    \    {\n      stack++;\n    }\n    else if (c == '>')\n    {\n      if (stack\
    \ == 0) return false;\n      stack--;\n    }\n    else\n    {\n      assert(false);\n\
    \    }\n  }\n  return stack == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   if (brackets.length == 0)\n        return true;\n    if (brackets.length ==\
    \ 1)\n        return false;\n    if (brackets[0] == '>')\n        return false;\n\
    \    int counter = 0;\n    foreach (i, e; brackets)\n    {\n        if (e == '<')\n\
    \            counter++;\n        else if (e == '>')\n            counter--;\n\
    \        if (counter < 0)\n            return false;\n    }\n    return counter\
    \ == 0;\n}\n/*\n    Implement a function that given a string \"s\" and an integer\
    \ \"n\"\n    returns the string \"s\" with exactly \"n\" occurrences of the character\
    \ 'x'.\n    If \"n\" is higher than the number of occurrences of 'x' in \"s\"\
    ,\n    all occurrences of 'x' must be duplicated as many times as needed.\n  \
    \  If \"n\" is lower than the number of occurrences of 'x' in \"s\",\n    all\
    \ occurrences of 'x' must be removed.\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv7hh3col.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv7hh3col.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    uint cnt = 0;\n\tforeach(c; brackets)\n\t{\n\t\tif(c == '<') cnt++;\n\t\telse\
    \ if(c == '>')\n\t\t{\n\t\t\tif(cnt == 0) return false;\n\t\t\tcnt--;\n\t\t}\n\
    \t}\n\treturn cnt == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   if (brackets.empty)\n    {\n        return true;\n    }\n    else\n    {\n\
    \        return brackets.front == '<' && brackets.back == '>' && correct_bracketing(brackets[1..$-1]);\n\
    \    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd5y62a6k.d(19): Error: no property `empty` for type `string`

    /tmp/tmpd5y62a6k.d(25): Error: no property `front` for type `string`

    /tmp/tmpd5y62a6k.d(25): Error: no property `back` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd5y62a6k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   Stack!(int) stack;\n    foreach(bracket; brackets) {\n        if (bracket\
    \ == '<') {\n            stack.push(0);\n        } else {\n            if (stack.empty)\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpisujw7xg.d(19): Error: template instance `Stack!int` template `Stack`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpisujw7xg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int open = 0;\n\tint close = 0;\n\tint i = 0;\n\twhile (i < brackets.length)\n\
    \t{\n\t\tif (brackets[i] == '<')\n\t\t{\n\t\t\topen++;\n\t\t}\n\t\telse if (brackets[i]\
    \ == '>')\n\t\t{\n\t\t\tclose++;\n\t\t}\n\t\ti++;\n\t}\n\tif (open > close)\n\t\
    {\n\t\treturn false;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu_uzag3x.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f25]

    ??:? void tmpu_uzag3x.__unittest_L40_C1() [0x427b76]

    ??:? void tmpu_uzag3x.__modtest() [0x427ca8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bcbf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab52]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fce5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430194]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc71]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab29]

    ??:? runModuleUnitTests [0x42ba95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   assert(brackets.length >= 0);\n    foreach(c; brackets) assert(c == '<' ||\
    \ c == '>');\n    auto matching = false;\n    int openBrackets = 0;\n    foreach(c;\
    \ brackets)\n    {\n        if(c == '<')\n        {\n            openBrackets++;\n\
    \        }\n        else\n        {\n            if(openBrackets > 0)\n      \
    \      {\n                openBrackets--;\n            }\n            else\n \
    \           {\n                return false;\n            }\n        }\n    }\n\
    \    if(openBrackets == 0)\n    {\n        matching = true;\n    }\n    return\
    \ matching;\n}\n/*\n    removes the character from the strings.\n    >>> remove_char(\"\
    abc\")\n    [\"bc\", \"ac\", \"ab\"]\n    >>> remove_char(\"x\")\n    [\"\"]\n\
    \    >>> remove_char(\"\")\n    []\n*/\nT[] remove_char(T)(T[] strings)\n{\n \
    \   foreach(string; strings) assert(string.length >= 0);\n    T[] result = [];\n\
    \    foreach(string; strings)\n    {\n        foreach(i; 0..string.length)\n \
    \       {\n            if(string.length == 1)\n            {\n               \
    \ result ~= \"\";\n            }\n            else\n            {\n          \
    \      result ~= string[0..i] ~ string[i+1..$];\n            }\n        }\n  \
    \  }\n    return result;\n}\n/*\n    return the string with the longest common\
    \ prefix with the other strings.\n    >>> longest_common_prefix(\"ab\", \"abc\"\
    )\n    \"ab\"\n    >>> longest_common_prefix(\"ab\", \"ad\")\n    \"a\"\n    >>>\
    \ longest_common_prefix(\"ac\", \"ad\")\n    \"\"\n    >>> longest_common_prefix(\"\
    ab\", \"ac\", \"ad\")\n    \"\"\n*/\nstring longest_common_prefix(T...)(T strings)\n\
    {\n    assert(strings.length >= 0);\n    foreach(string; strings) assert(string.length\
    \ >= 0);\n    if(strings.length == 0)\n    {\n        return \"\";\n    }\n  \
    \  fore\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkyhl8est.d(96): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpkyhl8est.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkyhl8est.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(char c; brackets)\n    {\n        if(c == '<')\n\
    \            count++;\n        else if(c == '>')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int bracket_sum = 0;\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwpp735gy.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwpp735gy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   //opening brackets\n    int count = 0;\nunittest\n{\n    alias candidate =\
    \ correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps1e43zpq.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps1e43zpq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164356
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int i = 0;\n    int j = 0;\n    foreach(c; brackets)\n    {\n        if(c\
    \ == '<')\n        {\n            i++;\n        }\n        else if(c == '>')\n\
    \        {\n            j++;\n        }\n        if(j > i)\n        {\n      \
    \      return false;\n        }\n    }\n    if(i == j)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }\n}\n/*\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoe3rscgm.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoe3rscgm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    bool result = true;\n\tint count = 0;\n\tforeach(b; brackets) \n\t{\n\t\tif (b\
    \ == '<') \n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tcount--;\n\t\
    \t}\n\t\tif (count < 0) \n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\
    }\n\tif (count != 0) \n\t{\n\t\tresult = false;\n\t}\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int i = 0;\n    int count = 0;\n    foreach(char c; brackets)\n    {\n   \
    \     if(c == '<')\n        {\n            count++;\n        }\n        else if(c\
    \ == '>')\n        {\n            count--;\n        }\n        else\n        {\n\
    \            return false;\n        }\n        if(count < 0)\n        {\n    \
    \        return false;\n        }\n    }\n    if(count == 0)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }\n    \n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   size_t n = brackets.length;\n    size_t acc = 0;\n    foreach(i; 0..n)\n \
    \   {\n        if(brackets[i] == '<')\n            acc++;\n        else\n    \
    \        acc--;\n        if(acc < 0)\n            return false;\n    }\n    return\
    \ acc == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n   \
    \ assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi8xheb_l.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x427efd]

    ??:? void tmpi8xheb_l.__unittest_L32_C1() [0x427b73]

    ??:? void tmpi8xheb_l.__modtest() [0x427c7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc97]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab2a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcbd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43016c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc49]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab01]

    ??:? runModuleUnitTests [0x42ba6d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int balance = 0;\n    foreach(bracket; brackets)\n    {\n        if(bracket\
    \ == '<')\n            balance++;\n        else if(bracket == '>')\n         \
    \   balance--;\n        if(balance < 0)\n            return false;\n    }\n  \
    \  return balance == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int opening_brackets_so_far = 0;\n    foreach (symbol; brackets) {\n     \
    \   if (symbol == '<') \n            opening_brackets_so_far++;\n        else\
    \ if (symbol == '>') {\n            if (opening_brackets_so_far == 0)\n      \
    \          return false;\n            opening_brackets_so_far--;\n        }\n\
    \    }\n    return opening_brackets_so_far == 0;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   if(brackets.length < 2) return false;\n    bool open=false;\n    foreach(c;brackets)\
    \ {\n        if(c == '<') {\n            open = true;\n        } else if(c ==\
    \ '>') {\n            if(!open) {\n                return false;\n           \
    \ }\n            open = false;\n        }\n    }\n    return !open;\n}\n/* \n\
    \    count the number of brackets in a string of brackets.\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpomc7me_9.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpomc7me_9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoiu32ow1.d(274): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoiu32ow1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint count = 0;\n    foreach(ch;brackets)\n    {\n        if(ch == '<')\n\
    \            count++;\n        else if(ch == '>')\n            count--;\n    \
    \    if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\n/*\n  Returns the sum of a list of integers. \n  Throws std.exception.AssertError\
    \ if the list is empty.\n  >>> sum_list([]);\n  AssertError\n  >>> sum_list([1,\
    \ 2, 3, 4, 5]);\n  15\n  >>> sum_list([5, 2, -5, -1, 7]);\n  8\n*/\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg9u687vn.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x427efd]

    ??:? void tmpg9u687vn.__unittest_L41_C1() [0x427b73]

    ??:? void tmpg9u687vn.__modtest() [0x427c7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aab6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbd5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa8d]

    ??:? runModuleUnitTests [0x42b9f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42834c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ int count = 0;\n  foreach(char c;brackets)\n  {\n    if(c == '<')\n      count++;\n\
    \    else if(c == '>')\n      count--;\n    if(count < 0)\n      return false;\n\
    \  }\n  return (count == 0);\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int i = 0;\n\tint j = 0;\n\twhile (i < brackets.length()) {\n\t\tif (brackets[i]\
    \ == '<') {\n\t\t\tj = i + 1;\n\t\t\twhile (j < brackets.length()) {\n\t\t\t\t\
    if (brackets[j] == '>') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\
    \t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == brackets.length()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti = j + 1;\n\t\t\t}\n\t\t}\n\t\telse\
    \ {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp426qu60b.d(21): Error: no property `length` for type `string`

    /tmp/tmp426qu60b.d(24): Error: no property `length` for type `string`

    /tmp/tmp426qu60b.d(32): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp426qu60b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int nb_open = 0;\n    foreach(b;brackets)\n    {\n        if(b == '<')\n \
    \           nb_open++;\n        else if(b == '>')\n            nb_open--;\n  \
    \      if(nb_open < 0)\n            return false;\n    }\n    return nb_open ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   return true;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgpvjr73k.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmpgpvjr73k.__unittest_L21_C1() [0x427ada]

    ??:? void tmpgpvjr73k.__modtest() [0x427c0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   if (brackets.length() == 0) return true;\n    if (brackets.length() % 2 ==\
    \ 1) return false;\n    int i = 0;\n    while (i < brackets.length())\n    {\n\
    \        if (brackets[i] == '<')\n        {\n            int count = 1;\n    \
    \        while (count != 0)\n            {\n                i++;\n           \
    \     if (brackets[i] == '<') count++;\n                if (brackets[i] == '>')\
    \ count--;\n            }\n        }\n        else i++;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppiz3x9rj.d(19): Error: no property `length` for type `string`

    /tmp/tmppiz3x9rj.d(20): Error: no property `length` for type `string`

    /tmp/tmppiz3x9rj.d(22): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppiz3x9rj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int level = 0;\n\tfor (int i = 0; i < brackets.length; i++)\n\t{\n\t\tif (brackets[i]\
    \ == '<')\n\t\t{\n\t\t\tlevel++;\n\t\t}\n\t\telse if (brackets[i] == '>')\n\t\t\
    {\n\t\t\tlevel--;\n\t\t}\n\t\tif (level < 0)\n\t\t{\n\t\t\treturn false;\n\t\t\
    }\n\t}\n\treturn level == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   import std.array;\n    import std.algorithm;\n    import std.range;\n    bool\
    \ flag = true;\n    for(size_t i = 0; i < brackets.length; ++i)\n    {\n     \
    \   if(brackets[i] == '<')\n        {\n            for(size_t j = brackets.length\
    \ - 1; j > i; --j)\n            {\n                if(brackets[j] == '>')\n  \
    \              {\n                    brackets[i] = ' ';\n                   \
    \ brackets[j] = ' ';\n                    break;\n                }\n        \
    \    }\n        }\n    }\n    brackets = brackets.replace(' ', ' ');\n    return\
    \ !brackets.length;\n}\n/*\nopen_brackets is a string of \"<\".\n    return the\
    \ minimum number of \">\" that must be added to make brackets a\n    correct bracketing.\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi45etwrb.d(41): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi45etwrb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int bracket_count = 0;\n\tforeach(c; brackets)\n\t{\n\t\tif(c == '<')\n\t\t{\n\
    \t\t\tbracket_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbracket_count--;\n\t\t}\n\
    \t\tif(bracket_count < 0) return false;\n\t}\n\treturn bracket_count == 0;\n}\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    immutable stack = new StackImpl!string();\n\tforeach(c; brackets)\n\t{\n\t\tif(c\
    \ == '<')\n\t\t{\n\t\t\tstack.push(c);\n\t\t}\n\t\telse if(c == '>')\n\t\t{\n\t\
    \t\tif(stack.empty)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\
    \t{\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.empty;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpts3yr01f.d(19): Error: template instance `StackImpl!string` template
    `StackImpl` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpts3yr01f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // extract all opening brackets\n    string open = brackets.filter!((x) =>\
    \ x == '<');\n    // extract all closing brackets\n    string close = brackets.filter!((x)\
    \ => x == '>');\n    // if number of opening brackets are not equal to the number\
    \ of closing brackets, then it is false\n    if (open.length != close.length)\
    \ \n    {\n        return false;\n    }\n    else \n    {\n        return true;\n\
    \    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgu76ypa3.d(20): Error: no property `filter` for type `string`

    /tmp/tmpgu76ypa3.d(22): Error: no property `filter` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgu76ypa3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // \u0441\u0447\u0435\u0442\u0447\u0438\u043A \u043E\u0442\u043A\u0440\u044B\
    \u0432\u0430\u044E\u0449\u0438\u0445 \u0441\u043A\u043E\u0431\u043E\u043A\n  \
    \  int counter = 0;\n    foreach(char c; brackets)\n    {\n        if (c == '<')\n\
    \            counter++;\n        else\n            counter--;\n        if (counter\
    \ < 0)\n            return false;\n    }\n    return counter == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(b; brackets)\n    {\n        if(b == '<') ++count;\n\
    \        else --count;\n        if(count < 0) return false;\n    }\n    return\
    \ count == 0;\n}\n/*\n    get_bracketing(n) returns a string with n left and n\
    \ right brackets,\n    where every possible bracketing is included\n    >>> get_bracketing(2)\n\
    \    [\"<<>>\", \"<><>\"]\n    >>> get_bracketing(3)\n    [\"<<<>>>\", \"<><><>\"\
    , \"<<><>>\", \"<><<>>>\", \"<<<><>>\", \"<><<><>>\"]\n*/\nstring[] get_bracketing(size_t\
    \ n) \n{\n    if(n == 0) return [\"\"];\n    if(n == 1) return [\"<>\"];\n   \
    \ string[] ret;\n    foreach(b; get_bracketing(n-1))\n    {\n        ret ~= \"\
    <\" ~ b ~ \">\";\n        ret ~= \"<\" ~ b;\n        ret ~= b ~ \">\";\n    }\n\
    \    return ret;\n}\n/*\n    returns the highest possible 3-digit score that can\
    \ be obtained on \n    a given string of brackets.\n    >>> str_score(\"<><><><>\"\
    )\n    3\n    >>> str_score(\"<<<><><>\")\n    6\n    >>> str_score(\"<<<<><>>\"\
    )\n    9\n*/\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int bracketCount = 0;\n\tforeach(char bracket; brackets)\n\t{\n\t\tif(bracket\
    \ == '<')\n\t\t{\n\t\t\tbracketCount++;\n\t\t}\n\t\telse if(bracket == '>')\n\t\
    \t{\n\t\t\tbracketCount--;\n\t\t}\n\t\tif(bracketCount < 0)\n\t\t{\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn bracketCount == 0;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{ \n\
    \    // [ ] has a static size\n    // allocate an array of size brackets.length\
    \ and set it to 0\n    int[brackets.length] open_brackets = void;\n    int open_brackets_index\
    \ = 0;\n    foreach (i, c; brackets) {\n        if (c == '<') {\n            open_brackets[open_brackets_index]\
    \ = i;\n            open_brackets_index++;\n        } else if (c == '>') {\n \
    \           if (open_brackets_index == 0) {\n                return false;\n \
    \           }\n            open_brackets_index--;\n        }\n    }\n    if (open_brackets_index\
    \ != 0) {\n        return false;\n    }\n    return true;\n}\nunittest\n{\n  \
    \  alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpubtb_ppm.d(21): Error: variable `brackets` cannot be read at compile
    time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpubtb_ppm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int count = 0;\nunittest\n{\n    alias candidate = correct_bracketing;\n\n   \
    \ assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4we5vucv.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4we5vucv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ //  int counter;\n  //  foreach(bracket; brackets) {\n  //    if (bracket ==\
    \ '<') {\n  //       counter += 1;\n  //    } else {\n  //       counter -= 1;\n\
    \  //       if (counter < 0)\n  //          return false;\n  //    }\n  // }\n\
    \  // return counter == 0;\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw0_gw1cu.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw0_gw1cu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ int p = 0;\n  foreach(char c; brackets)\n  {\n    if (c == '<')\n      p +=\
    \ 1;\n    else if (c == '>')\n      p -= 1;\n    if (p < 0)\n      return false;\n\
    \  }\n  return p == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   auto s = stack!int();\n    foreach(b;brackets)\n    {\n        if(b == '<')\
    \ s.push(1);\n        else if(s.empty) return false;\n        else s.pop();\n\
    \    }\n    return s.empty;\n}\n/*\n    return the number of elements in brackets\
    \ that will be unbalanced if that element is removed.\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpznwcikw0.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpznwcikw0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(ch; brackets)\n    {\n        if(ch == '<')\n\
    \            count++;\n        else\n            count--;\n        if(count <\
    \ 0)\n            return false;\n    }\n    return count == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int _nopen = 0;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n \
    \           _nopen++;\n        else\n            _nopen--;\n        if(_nopen\
    \ < 0)\n            return false;\n    }\n    return _nopen == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   foreach(immutable c; brackets)\n    {\n        if(c == '<')\n        {\n \
    \           scope(exit)\n            {\n                if(brackets.length ==\
    \ 1)\n                    return false;\n            }\n            else\n   \
    \         {\n                immutable index = brackets.find('>');\n         \
    \       if(index == -1)\n                    return false;\n                brackets\
    \ = brackets[index + 1 .. $];\n            }\n        }\n        else\n      \
    \  {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpze_sjakb.d(28): Error: found `else` without a corresponding `if`,
    `version` or `debug` statement

    /tmp/tmpze_sjakb.d(36): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmpze_sjakb.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpze_sjakb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   debug(brackets);\n    return true;\n}\n/*\n brackets is a string of \"<\"\
    \ and \">\".\n    return the maximum number of opening brackets that can be closed\
    \ by the\n    final closing bracket.\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9kogbynj.d(19): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmp9kogbynj.d(22): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9kogbynj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int bracketCount = 0;\n\tforeach(char c; brackets)\n\t{\n\t\tif(c == '<')\n\t\t\
    {\n\t\t\tbracketCount++;\n\t\t}\n\t\telse if(c == '>')\n\t\t{\n\t\t\tbracketCount--;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tassert(0);\n\t\t}\n\t\tif(bracketCount < 0)\n\t\t\
    {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn bracketCount == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   import std.typecons;\n    struct Node\n    {\n        char info;\n       \
    \ Node next;\n    }\n    Node top;\n    char[] a = brackets.dup;\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        if (a[i] == '<')\n        {\n    \
    \        Node new_node = new Node;\n            new_node.info = a[i];\n      \
    \      new_node.next = top;\n            top = new_node;\n        }\n        else\
    \ if (a[i] == '>')\n        {\n            if (top != null)\n            {\n \
    \               top = top.next;\n            }\n            else\n           \
    \ {\n                return false;\n            }\n        }\n    }\n    if (top\
    \ == null)\n    {\n        return true;\n    }\n    else\n    {\n        return\
    \ false;\n    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwk1086_v.d(20): Error: struct `tmpwk1086_v.correct_bracketing.Node`
    cannot have field `next` with same struct type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwk1086_v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   static assert(brackets.length <= 100000);\n    static assert(all!(c => c ==\
    \ '<' || c == '>')(brackets));\n    static assert(!brackets.empty);\n    int n\
    \ = brackets.length;\n    int depth = 0;\n    for (int i = 0; i < n; i++) {\n\
    \        if (brackets[i] == '<') {\n            depth++;\n        } else {\n \
    \           depth--;\n        }\n        if (depth < 0) {\n            return\
    \ false;\n        }\n    }\n    return depth == 0;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc6cpssx5.d(19): Error: variable `brackets` cannot be read at compile
    time

    /tmp/tmpc6cpssx5.d(19):        while evaluating: `static assert(brackets.length
    <= 100000LU)`

    /tmp/tmpc6cpssx5.d(20): Error: template instance `all!((c) => c == ''<'' || c
    == ''>'')` template `all` is not defined

    /tmp/tmpc6cpssx5.d(20):        while evaluating: `static assert(all!((c) => c
    == ''<'' || c == ''>'')(brackets))`

    /tmp/tmpc6cpssx5.d(21): Error: no property `empty` for type `string`

    /tmp/tmpc6cpssx5.d(21):        while evaluating: `static assert(!brackets.empty)`

    /tmp/tmpc6cpssx5.d(22): Error: cannot implicitly convert expression `brackets.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc6cpssx5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int i = 0;\n    int lefts = 0;\n    int rights = 0;\n    foreach(c; brackets)\n\
    \    {\n        if(c == '<')\n        {\n            lefts++;\n        }\n   \
    \     else if(c == '>')\n        {\n            rights++;\n        }\n       \
    \ if(rights > lefts)\n        {\n            return false;\n        }\n    }\n\
    \    if(lefts != rights)\n    {\n        return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   /*\n    return true if every opening bracket has a corresponding closing bracket.\n\
    \    */\n    int count = 0;\n    foreach(char c; brackets)\n    {\n\tif(c == '<')\n\
    \t    count++;\n\telse if(c == '>')\n\t    count--;\n\tif(count < 0)\n\t    return\
    \ false;\n    }\n    return count == 0;\n}\n/*\ncorrect_bracketing uses a variable\
    \ to count the number of open brackets\n\"<\" minus the number of closed brackets\
    \ \">\".  Any time the variable is negative\nthen there must be an opening bracket\
    \ without a closing bracket, so it\nreturns false.  Otherwise, it returns true\
    \ if the variable is zero.\n*/\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int index_opening = 0;\n    int index_closing = 0;\n    size_t length = brackets.length;\n\
    \    int length_first_half = (length / 2);\n    foreach(i; 0 .. length_first_half)\n\
    \    {\n        if(brackets[i] == '<')\n        {\n            index_opening +=\
    \ 1;\n        }\n        else\n        {\n            return false;\n        }\n\
    \    }\n    foreach(i; length_first_half .. length)\n    {\n        if(brackets[i]\
    \ == '>')\n        {\n            index_closing += 1;\n        }\n        else\n\
    \        {\n            return false;\n        }\n    }\n    if(index_opening\
    \ == index_closing)\n    {\n        return true;\n    }\n    else\n    {\n   \
    \     return false;\n    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5z73sdiu.d(22): Error: cannot implicitly convert expression `length
    / 2LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5z73sdiu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int sum = 0;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n    \
    \        sum++;\n        else if(c == '>')\n            sum--;\n        if(sum\
    \ < 0)\n            return false;\n    }\n    return sum == 0;\n}\n/*\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe61nj93v.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe61nj93v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint level = 0;\n    for (immutable c : brackets) {\n        if (c == '<')\
    \ {\n            level++;\n        } else if (c == '>') {\n            if (level\
    \ == 0) {\n                return false;\n            }\n            level--;\n\
    \        }\n    }\n    return level == 0;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpafillam2.d(20): Error: no identifier for declarator `c`

    /tmp/tmpafillam2.d(20): Error: expression expected, not `:`

    /tmp/tmpafillam2.d(20): Error: found `brackets` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpafillam2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(char ch; brackets) \n    {\n        if (ch ==\
    \ '<') \n        {\n            count++;\n        }\n        else \n        {\n\
    \            count--;\n        }\n        if (count < 0)\n        {\n        \
    \    return false;\n        }\n    }\n    return count == 0;\n}\n/*\nisValid is\
    \ a string of letters representing a valid mathematical expression.\n    return\
    \ true if the expression is balanced.\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3repyik.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3repyik.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ int i = 0;\n  int count = 0;\n  while (i < brackets.length)\n  {\n    if (brackets[i]\
    \ == '<')\n    {\n      count++;\n    }\n    else if (brackets[i] == '>')\n  \
    \  {\n      count--;\n    }\n    if (count < 0)\n    {\n      return false;\n\
    \    }\n    i++;\n  }\n  if (count == 0)\n  {\n    return true;\n  }\n  else\n\
    \  {\n    return false;\n  }\n}\n/*\nbrackets is a string of \"[\" and \"]\".\n\
    \    return true if every opening bracket has a corresponding closing bracket.\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp2ydxqw8.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp2ydxqw8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    for (char i : brackets)\n    {\n        if (i == '<')\n\
    \        {\n            count++;\n        }\n        else if (i == '>')\n    \
    \    {\n            count--;\n        }\n        if (count < 0)\n        {\n \
    \           return false;\n        }\n    }\n    if (count != 0)\n    {\n    \
    \    return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdy3kw41g.d(20): Error: semicolon expected, not `:`

    /tmp/tmpdy3kw41g.d(20): Error: expression expected, not `:`

    /tmp/tmpdy3kw41g.d(20): Error: found `brackets` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdy3kw41g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(char c; brackets) {\n        if (c == '<') count++;\n\
    \        else if (c == '>') count--;\n    }\n    return count == 0;\n}\n/*\n Given\
    \ a non-empty string of parentheses and brackets, return the number of matching\
    \ pairs.\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps7h2el8j.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps7h2el8j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // See if < or > and push or pop\n    Stack!(char) bracket_stack;\n    foreach(bracket;\
    \ brackets)\n    {\n        if(bracket == '<')\n        {\n            bracket_stack.push(bracket);\n\
    \        }\n        else if(bracket == '>')\n        {\n            if(bracket_stack.empty)\n\
    \            {\n                return false;\n            }\n            bracket_stack.pop();\n\
    \        }\n    }\n    return bracket_stack.empty;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg4axkw2a.d(20): Error: template instance `Stack!char` template
    `Stack` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg4axkw2a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   /*\n     stack is a stack of characters.\n        push(): takes a character,\
    \ push it on the stack.\n        pop(): takes nothing, returns a character.\n\
    \        empty(): takes nothing, returns a bool: true if stack is empty.\n   \
    \ */\n    struct stack {\n        void push(char c) {\n            chars ~= c;\n\
    \        }\n        char pop() {\n            return chars.pop;\n        }\n \
    \       bool empty() {\n            return chars.empty;\n        }\n        char[]\
    \ chars;\n    }\n    stack open_brackets;\n    foreach (char c; brackets) \n \
    \   {\n        if (c == '<') \n        {\n            open_brackets.push(c);\n\
    \        } \n        else if (c == '>') \n        {\n            if (open_brackets.empty())\
    \ \n            {\n                return false;\n            } \n           \
    \ else \n            {\n                open_brackets.pop();\n            }\n\
    \        }\n    }\n    return open_brackets.empty();\n}\n/*\n stack is a stack\
    \ of integers.\n    push(): takes an integer, push it on the stack.\n    pop():\
    \ takes nothing, returns an integer.\n    empty(): takes nothing, returns a bool:\
    \ true if stack is empty.\n*/\nstruct stack {\n    void push(int x) {\n      \
    \  nums ~= x;\n    }\n    int pop() {\n        return nums.pop;\n    }\n    bool\
    \ empty() {\n        return nums.empty;\n    }\n    int[] nums;\n}\n/*\n dfs takes\
    \ a graph and a vertex.\n    return a string representing a path from the starting\
    \ vertex to an ending vertex.\n    if there is no such path, return \"fail\".\n\
    \    (in this case, we have a graph with a single vertex, and a path is a sequence\
    \ of edges where each vertex is adjacent to the next.)\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp21yuqyd.d(76): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp21yuqyd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int c = 0;\n    foreach(char bracket; brackets) {\n        if (bracket ==\
    \ '<') {\n            c++;\n        } else {\n            c--;\n        }\n  \
    \      if (c < 0) {\n            return false;\n        }\n    }\n    return c\
    \ == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{ \n\
    \    alias Stack = Stack!(char);\n    Stack opening_brackets;\n    foreach(char\
    \ c; brackets)\n    {\n        if(c == '<')\n        {\n            opening_brackets.push(c);\n\
    \        }\n        else\n        {\n            if(opening_brackets.empty)\n\
    \            {\n                return false;\n            }\n            else\n\
    \            {\n                opening_brackets.pop();\n            }\n     \
    \   }\n    }\n    return opening_brackets.empty;\n}\nassert(correct_bracketing(\"\
    <\") == false);\nassert(correct_bracketing(\"<>\") == true);\nassert(correct_bracketing(\"\
    <<><>>\") == true);\nassert(correct_bracketing(\"><<>\") == false);\n/*\n    brackets\
    \ is a string of \"<\" and \">\".\n    return the index of the first erroneous\
    \ bracket.\n    if no error is found, return -1.\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptozuhtvv.d(41): Error: declaration expected, not `assert`

    /tmp/tmptozuhtvv.d(42): Error: declaration expected, not `assert`

    /tmp/tmptozuhtvv.d(43): Error: declaration expected, not `assert`

    /tmp/tmptozuhtvv.d(44): Error: declaration expected, not `assert`

    /tmp/tmptozuhtvv.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptozuhtvv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int i = 0;\n    int j = 0;\n    foreach( c; brackets )\n    {\n        if(\
    \ c == '<' )\n            i++;\n        else if( c == '>' )\n            j++;\n\
    \        if( j > i )\n            return false;\n    }\n    return ( i == j );\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint len = brackets.length;\n    if (len == 0) return true;\n    for (uint\
    \ i = 0; i < len/2; i++)\n    {\n        if (brackets[i] != '<' || brackets[len-i-1]\
    \ != '>')\n            return false;\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwydgxjr5.d(19): Error: cannot implicitly convert expression `brackets.length`
    of type `ulong` to `uint`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwydgxjr5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int level = 0;\n    foreach(char c;brackets)\n    {\n        if(c == '<')\
    \ \n            level++;\n        else if(c == '>')\n            level--;\n  \
    \      else\n            return false;\n        if(level < 0)\n            return\
    \ false;\n    }\n    return level == 0;\n}\n/*\n    sort the contents of a linked\
    \ list in place\n    >>> l = [3, 1, 2, 0]\n    >>> sort_list(l)\n    >>> l\n \
    \   [0, 1, 2, 3]\n*/\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // Should return false if brackets is an empty string.\n    if (brackets.empty)\n\
    \        return false;\n    \n    // Create a stack for bracketing, and initialize\
    \ it to an empty string.\n    auto bracket_stack = new StackedString(\"\");\n\
    \    \n    // Push each bracket to the stack, check for correct bracketing, and\
    \ return.\n    foreach (bracket; brackets) {\n        if (bracket == '<') {\n\
    \            bracket_stack.push(\"<\");\n        } else if (bracket == '>') {\n\
    \            if (bracket_stack.isEmpty())\n                return false;\n   \
    \         bracket_stack.pop();\n        }\n    }\n    if (bracket_stack.isEmpty())\n\
    \        return true;\n    else\n        return false;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx4imwq6g.d(20): Error: no property `empty` for type `string`

    /tmp/tmpx4imwq6g.d(24): Error: undefined identifier `StackedString`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx4imwq6g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint count = 0;\n    foreach(ch; brackets) \n    {\n        if (ch == '<')\
    \ \n        {\n            count++;\n        } \n        else if (ch == '>') \n\
    \        {\n            if (count == 0) \n            {\n                return\
    \ false;\n            }\n            count--;\n        }\n    }\n    return count\
    \ == 0;\n}\n/*\n * brackets is a string of \"<\" and \">\".\n    return true if\
    \ every opening bracket has a corresponding closing bracket, \n    and it is in\
    \ the right place.\nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpydtp63_o.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpydtp63_o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int numOpen = 0;\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo52o_vl8.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo52o_vl8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // Open bracket types\n    static immutable string open_brackets = \"<<<\"\
    ;\n    // Close bracket types\n    static immutable string close_brackets = \"\
    >>>\";\n    //stuct to store the bracket type and state of a bracket\n    struct\
    \ Bracket(char type, bool open) {\n        char type;\n        bool open;\n  \
    \  }\n    //A tuple of all expected brackets and the types of the brackets\n \
    \   alias bracket_types = typeof(tuple!(Bracket(open_brackets[0], true), \n  \
    \                                    Bracket(close_brackets[0], false),\n    \
    \                                  Bracket(open_brackets[1], true),\n        \
    \                              Bracket(close_brackets[1], false),\n          \
    \                            Bracket(open_brackets[2], true),\n              \
    \                        Bracket(close_brackets[2], false)));\n    //A stack of\
    \ open brackets\n    Stack!Bracket bracket_stack;\n    //For each bracket in the\
    \ input check if it is an open bracket and if so push it on the stack\n    //else\
    \ if it is an expected close bracket then pop the last bracket and check that\
    \ it is the correct type for the closing bracket\n    //if a bracket type is not\
    \ expected then return false\n    foreach(bracket; brackets) {\n        if(bracket_types.find!(bracket\
    \ => bracket.type == bracket && bracket.open).open) {\n            bracket_stack.push(Bracket(bracket,\
    \ true));\n        } else if(bracket_types.find!(bracket => bracket.type == bracket\
    \ && !bracket.open)) {\n            auto open_bracket = bracket_stack.pop();\n\
    \            if(open_bracket.type != open_brackets[close_brackets.find(bracket)])\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    return false;\n        }\n    }\n    //If all brackets matched then the stack\
    \ should be empty\n    return bracket_stack.empty;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkofj_sgy.d(29): Error: struct `tmpkofj_sgy.correct_bracketing.Bracket`
    cannot deduce function from argument types `!()(immutable(char), bool)`, candidates
    are:

    /tmp/tmpkofj_sgy.d(24):        `tmpkofj_sgy.correct_bracketing.Bracket(char type,
    bool open)`

    /tmp/tmpkofj_sgy.d(30): Error: struct `tmpkofj_sgy.correct_bracketing.Bracket`
    cannot deduce function from argument types `!()(immutable(char), bool)`, candidates
    are:

    /tmp/tmpkofj_sgy.d(24):        `tmpkofj_sgy.correct_bracketing.Bracket(char type,
    bool open)`

    /tmp/tmpkofj_sgy.d(31): Error: struct `tmpkofj_sgy.correct_bracketing.Bracket`
    cannot deduce function from argument types `!()(immutable(char), bool)`, candidates
    are:

    /tmp/tmpkofj_sgy.d(24):        `tmpkofj_sgy.correct_bracketing.Bracket(char type,
    bool open)`

    /tmp/tmpkofj_sgy.d(32): Error: struct `tmpkofj_sgy.correct_bracketing.Bracket`
    cannot deduce function from argument types `!()(immutable(char), bool)`, candidates
    are:

    /tmp/tmpkofj_sgy.d(24):        `tmpkofj_sgy.correct_bracketing.Bracket'
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool res = true;\n    size_t open = 0;\n    size_t close = 0;\n    foreach(c;\
    \ brackets)\n    {\n        if(c == '<') open++;\n        else close++;\n    \
    \    if(close > open)\n        {\n            res = false;\n            break;\n\
    \        }\n    }\n    if(open != close) res = false;\n    return res;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int open = 0;\n    int close = 0;\n    for (size_t i = 0; i < brackets.length;\
    \ i++) {\n        char bracket = brackets[i];\n        if (bracket == '<') {\n\
    \            open++;\n        } else if (bracket == '>') {\n            close++;\n\
    \        }\n        if (close > open) {\n            return false;\n        }\n\
    \    }\n    return open == close;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // TODO: Implement this function.\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n\
    \    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\"\
    ) == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\") == true);\n\
    \    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"><<>\"\
    ) == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9xq_lb1n.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmp9xq_lb1n.__unittest_L22_C1() [0x427ada]

    ??:? void tmp9xq_lb1n.__modtest() [0x427c0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   \n    // count how many opening brackets we have, and how many closing brackets\n\
    \    // we have.\n    // if they are the same, then we are good.\n    int opening_count\
    \ = 0;\n    int closing_count = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '<') {\n            opening_count += 1;\n\
    \        } else if (brackets[i] == '>') {\n            closing_count += 1;\n \
    \       }\n    }\n    return opening_count == closing_count;\n}\nunittest\n{\n\
    \    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmr58vvbn.d(25): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmr58vvbn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(char c; brackets)\n    {\n        if(c == '<')\n\
    \            count++;\n        else if(c == '>')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   if (brackets.find('<') == -1)\n        return false;\n    int count = 0;\n\
    \    foreach (c; brackets)\n    {\n        if (c == '<')\n            count++;\n\
    \        else\n            count--;\n        if (count == 0)\n            return\
    \ true;\n    }\n    return false;\n}\n/*\n    >>>  jb(1, 4)\n    [1, 2, 3, 4]\n\
    \    >>>  jb(1, 4, 1)\n    [1, 2, 3, 4]\n    >>>  jb(1, 4, 2)\n    [1, 3]\n  \
    \  >>>  jb(1, 4, 3)\n    [1, 4]\n    >>>  jb(1, 4, 4)\n    [1, 4]\n    >>>  jb(1,\
    \ 4, 5)\n    [1, 4]\n    >>>  jb(1, 4, 6)\n    [1, 4]\n    >>>  jb(1, 4, 7)\n\
    \    [1, 4]\n    >>>  jb(1, 4, 8)\n    [1, 4]\n    >>>  jb(1, 4, 9)\n    [1, 4]\n\
    \    >>>  jb(1, 4, 10)\n    [1, 4]\n    >>>  jb(1, 4, 11)\n    [1, 4]\n    >>>\
    \  jb(1, 4, 12)\n    [1, 4]\n    >>>  jb(1, 4, 13)\n    [1, 4]\n    >>>  jb(1,\
    \ 4, 14)\n    [1, 4]\n    >>>  jb(1, 4, 15)\n    [1, 4]\n    >>>  jb(1, 4, 16)\n\
    \    [1, 4]\n    >>>  jb(1, 4, 17)\n    [1, 4]\n    >>>  jb(1, 4, 18)\n    [1,\
    \ 4]\n    >>>  jb(1, 4, 19)\n    [1, 4]\n    >>>  jb(1, 4, 20)\n    [1, 4\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7d2opwww.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7d2opwww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   foreach(char c; brackets)\n    {\n        if(c=='<')\n        {\n        \
    \    char[] temp;\n            temp ~= c;\n            temp ~= '>';\n        \
    \    brackets = replace(brackets, temp, \"\");\n        }\n    }\n    return brackets.length\
    \ == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvezc9a4h.d(26): Error: undefined identifier `replace`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvezc9a4h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint stack = 0;\n    foreach(i, ch; brackets)\n    {\n        if(ch == '<')\n\
    \            stack++;\n        else if(ch == '>')\n            stack--;\n    \
    \    if(stack == -1)\n            return false;\n    }\n    return stack == 0;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   immutable bracketSize = brackets.length;\n    if(bracketSize < 1) return false;\n\
    \    int openBrackets = 0;\n    for(char c in brackets)\n    {\n        if(c ==\
    \ '<') openBrackets++;\n        else if(c == '>') openBrackets--;\n        if(openBrackets\
    \ < 0) return false;\n    }\n    return openBrackets == 0;\n}\n//@safe\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5491ghjm.d(22): Error: semicolon expected, not `in`

    /tmp/tmp5491ghjm.d(22): Error: expression expected, not `in`

    /tmp/tmp5491ghjm.d(22): Error: found `brackets` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5491ghjm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // your code here\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpczzi4tcr.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmpczzi4tcr.__unittest_L22_C1() [0x427a36]

    ??:? void tmpczzi4tcr.__modtest() [0x427c0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   stack!char st;\n    foreach(c;brackets) {\n\t\tif(c == '<')\n\t\t\tst.push(c);\n\
    \t\telse if(c == '>') {\n\t\t\tif(st.empty || st.top != '<')\n\t\t\t\treturn false;\n\
    \t\t\tst.pop();\n\t\t}\n\t}\n\treturn st.empty;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"\
    <<><>>\") == true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbes5isai.d(19): Error: template instance `stack!char` template
    `stack` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbes5isai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    for (auto c : brackets)\n    {\n        if (c == '<')\n\
    \            count++;\n        else\n            count--;\n        if (count <\
    \ 0)\n            return false;\n    }\n    return count == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnlzfu4tc.d(20): Error: no identifier for declarator `c`

    /tmp/tmpnlzfu4tc.d(20): Error: expression expected, not `:`

    /tmp/tmpnlzfu4tc.d(20): Error: found `brackets` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnlzfu4tc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164357
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   /*\n    int open = 0;\n    foreach(char ch; brackets)\n    {\n        if(ch\
    \ == '<') open++;\n        else open--;\n        if(open < 0) return false;\n\
    \    }\n    return open == 0;\n    */\n    /*\n    int open = 0;\n    foreach(char\
    \ ch; brackets)\n    {\n        if(ch == '<') open++;\n        else open--;\n\
    \        if(open < 0) return false;\n    }\n    return open == 0;\n    */\n  \
    \  /*\n    int open = 0;\n    foreach(char ch; brackets)\n    {\n        if(ch\
    \ == '<') open++;\n        else open--;\n        if(open < 0) return false;\n\
    \    }\n    return open == 0;\n    */\n    /*\n    int open = 0;\n    foreach(char\
    \ ch; brackets)\n    {\n        if(ch == '<') open++;\n        else open--;\n\
    \        if(open < 0) return false;\n    }\n    return open == 0;\n    */\n  \
    \  /*\n    int open = 0;\n    foreach(char ch; brackets)\n    {\n        if(ch\
    \ == '<') open++;\n        else open--;\n        if(open < 0) return false;\n\
    \    }\n    return open == 0;\n    */\n    int open = 0;\n    foreach(char ch;\
    \ brackets)\n    {\n        if(ch == '<') open++;\n        else open--;\n    \
    \    if(open < 0) return false;\n    }\n    return open == 0;\n}\nunittest\n{\n\
    \    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   return is_empty(brackets) || \n        (brackets[0] == '<' && \n        brackets[$-1]\
    \ == '>' && \n        correct_bracketing(brackets[1..$-1]));\n}\nunittest\n{\n\
    \    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7p8rtni2.d(19): Error: undefined identifier `is_empty`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7p8rtni2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int total=0;\n\tforeach(immutable char c;brackets)\n\t{\n\t\tif(c=='<') total+=1;\n\
    \t\telse if(c=='>') total-=1;\n\t\tif(total<0) return false;\n\t}\n\treturn total==0;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool flag = true;\n    auto temp = brackets.length;\n    struct Stack{\n \
    \       int top;\n        int elements[10];\n    }s;\n    s.top = -1;\n    foreach(i;\
    \ 0..temp)\n    {\n        if(brackets[i] == '<')\n        {\n            s.top++;\n\
    \            s.elements[s.top] = i;\n        }\n        else if(brackets[i] ==\
    \ '>')\n        {\n            if(s.top == -1)\n            {\n              \
    \  flag = false;\n                break;\n            }\n            else\n  \
    \          {\n                s.top--;\n            }\n        }\n    }\n    if(s.top\
    \ != -1)\n    {\n        flag = false;\n    }\n    return flag;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphq4fgslo.d(23): Deprecation: instead of C-style syntax, use D-style
    syntax `int[10] elements`

    /tmp/tmphq4fgslo.d(24): Error: undefined identifier `s`

    /tmp/tmphq4fgslo.d(25): Error: undefined identifier `s`

    /tmp/tmphq4fgslo.d(30): Error: undefined identifier `s`

    /tmp/tmphq4fgslo.d(31): Error: undefined identifier `s`

    /tmp/tmphq4fgslo.d(35): Error: undefined identifier `s`

    /tmp/tmphq4fgslo.d(42): Error: undefined identifier `s`

    /tmp/tmphq4fgslo.d(46): Error: undefined identifier `s`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphq4fgslo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(ch; brackets) \n    {\n        if (ch == '<')\n\
    \            count++;\n        else\n            count--;\n        if (count <\
    \ 0)\n            return false;\n    }\n    return count == 0;\n}\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   // keep track of the number of left brackets we have seen so far.\n    //\
    \ only when the number of left brackets is zero can we close the right bracket.\n\
    \    int n_left = 0;\n    foreach(c; brackets) {\n        if (c == '<') {\n  \
    \          n_left++;\n        } else if (c == '>') {\n            n_left--;\n\
    \        }\n        if (n_left < 0)\n            return false;\n    }\n    return\
    \ n_left == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    Tuple!(int, int) result;\n\tbrackets = brackets.toLower();\n\tconst char [] less\
    \ = \"<\";\n\tconst char [] greater = \">\";\n\t\n\tif (brackets.count(greater)\
    \ == brackets.count(less))\n\t{\n\t\treturn true;\n\t}\n\telse \n\t{\n\t\treturn\
    \ false;\n\t}\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n \
    \   assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplzmzl5ej.d(20): Error: no property `toLower` for type `string`

    /tmp/tmplzmzl5ej.d(24): Error: no property `count` for type `string`

    /tmp/tmplzmzl5ej.d(24): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplzmzl5ej.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int cnt = 0;\n\tforeach(b;brackets)\n\t{\n\t\tif(b == '<') cnt++;\n\t\telse if(b\
    \ == '>') cnt--;\n\t\tif(cnt < 0) return false;\n\t}\n\treturn cnt == 0;\n}\n\
    /*\n    A \"step\" is the difference between an element and the next one.\n  \
    \  return true if the list of steps is in ascending or descending order.\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5cndgawy.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5cndgawy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   size_t openBracket = 0;\n    size_t closeBracket = 0;\n    for (size_t i =\
    \ 0; i < brackets.length; i++)\n    {\n        if (brackets[i] == '<')\n     \
    \   {\n            openBracket++;\n        }\n        else\n        {\n      \
    \      closeBracket++;\n        }\n    }\n    return openBracket == closeBracket;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp0zxznnz.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x427efd]

    ??:? void tmpp0zxznnz.__unittest_L34_C1() [0x427b73]

    ??:? void tmpp0zxznnz.__modtest() [0x427c7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc97]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab2a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcbd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43016c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc49]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab01]

    ??:? runModuleUnitTests [0x42ba6d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   auto s = stack!char();\n    foreach(c; brackets) {\n        if (c == '<')\n\
    \            s.push(c);\n        else if (c == '>') {\n            if (s.empty\
    \ || s.pop() != '<')\n                return false;\n        }\n    }\n    return\
    \ s.empty;\n}\n/*\nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo75q0fgf.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo75q0fgf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool checker = true;\n    while(0<brackets.length)\n    {\n        if(brackets[0]=='>')\n\
    \        {\n            checker = false;\n            break;\n        }\n    \
    \    else\n        {\n            size_t close = brackets.find('>');\n       \
    \     if(close==string.npos)\n            {\n                checker = false;\n\
    \                break;\n            }\n            else\n            {\n    \
    \            brackets = brackets.substr(close+1);\n            }\n        }\n\
    \    }\n    return checker;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") ==\
    \ true);\n    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"\
    <><><<<><><>><>><<><><<>>>\") == true);\n    assert(candidate(\"<<<><>>>>\") ==\
    \ false);\n    assert(candidate(\"><<>\") == false);\n    assert(candidate(\"\
    <\") == false);\n    assert(candidate(\"<<<<\") == false);\n    assert(candidate(\"\
    >\") == false);\n    assert(candidate(\"<<>\") == false);\n    assert(candidate(\"\
    <><><<><>><>><<>\") == false);\n    assert(candidate(\"<><><<><>><>>><>\") ==\
    \ false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51kkycsj.d(29): Error: no property `find` for type `string`

    /tmp/tmp51kkycsj.d(30): Error: no property `npos` for type `string`

    /tmp/tmp51kkycsj.d(37): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51kkycsj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int openBrackets=0;\n    foreach(c;brackets)\n    {\n        if(c=='<')\n\
    \            openBrackets++;\n        else if(c=='>')\n            openBrackets--;\n\
    \        if(openBrackets<0)\n            return false;\n    }\n    return openBrackets==0;\n\
    }\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n    if\
    \ (brackets.length == 0) \n        return true;\n    else \n        auto open_bracket_indicies\
    \ = brackets.indices.filter!(c => brackets[c] == '<');\n        auto close_bracket_indicies\
    \ = brackets.indices.filter!(c => brackets[c] == '>');\n        return (open_bracket_indicies.length\
    \ == close_bracket_indicies.length) && open_bracket_indicies.zip(close_bracket_indicies).all!(c\
    \ => c[0] < c[1]);\nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4qkwy8mh.d(18): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmp4qkwy8mh.d(18): Error: declaration expected, not `if`

    /tmp/tmp4qkwy8mh.d(20): Error: declaration expected, not `else`

    /tmp/tmp4qkwy8mh.d(23): Error: declaration expected, not `return`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4qkwy8mh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int open = 0;\n    int close = 0;\n    foreach(c; brackets)\n    {\n     \
    \   if(c == '<')\n        {\n            open++;\n        }\n        else if(c\
    \ == '>')\n        {\n            close++;\n        }\n    }\n    if(open == close)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfiv0hz3m.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f05]

    ??:? void tmpfiv0hz3m.__unittest_L41_C1() [0x427b7f]

    ??:? void tmpfiv0hz3m.__modtest() [0x427c88]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aabe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc51]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430100]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbdd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa95]

    ??:? runModuleUnitTests [0x42ba01]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428354]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int size = brackets.length;\n    int count=0;\n    int loop = 0;\n    while(loop\
    \ < size)\n    {\n        if(brackets[loop] == '<')\n        {\n            count++;\n\
    \        }\n        else\n        {\n            count--;\n        }\n       \
    \ if(count < 0)\n        {\n            return false;\n        }\n        loop++;\n\
    \    }\n    if(count != 0)\n    {\n        return false;\n    }\n    return true;\n\
    }\n/*\ncount_correct_bracketings is a string of \"<\" and \">\".\n    return the\
    \ number of bracketings that are both correct and\n    minimal in length.\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"<>\") ==\
    \ true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps6naz1zl.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps6naz1zl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   //initialize the counter to 0\n    int counter = 0;\n    //iterate through\
    \ the brackets string\n    foreach(bracket; brackets)\n    {\n        //if the\
    \ bracket is '<'\n        if(bracket == '<')\n        {\n            //decrement\
    \ the counter\n            counter--;\n        }\n        //if the bracket is\
    \ '>'\n        else if(bracket == '>')\n        {\n            //increment the\
    \ counter\n            counter++;\n        }\n        //if the counter is greater\
    \ than 0 at any point, return false\n        if(counter > 0)\n        {\n    \
    \        return false;\n        }\n    }\n    //if the counter is still 0 after\
    \ the iteration, return true\n    if(counter == 0)\n    {\n        return true;\n\
    \    }\n    //return false otherwise\n    return false;\n}\n/*\n    in_substitution\
    \ is a string representing an in-substitution.\n    return true if the in-substitution\
    \ is valid.\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwvs_cohu.d(50): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwvs_cohu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int i;\n    char c;\n    char c1;\n    int angle_count;\n    int open_count;\n\
    \    int close_count;\n    angle_count = 0;\n    open_count = 0;\n    close_count\
    \ = 0;\n    for (i = 0; i < brackets.length; i++)\n    {\n        c = brackets[i];\n\
    \        if (c == '<')\n        {\n            open_count++;\n            angle_count++;\n\
    \        }\n        else if (c == '>')\n        {\n            close_count++;\n\
    \            angle_count--;\n        }\n        if (angle_count < 0)\n       \
    \ {\n            return false;\n        }\n    }\n    if (open_count == close_count)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
    <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164358
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n brackets is a string of \"\
    <\" and \">\".\n    return true if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    false\n    >>> correct_bracketing(\"\
    <>\")\n    true\n    >>> correct_bracketing(\"<<><>>\")\n    true\n    >>> correct_bracketing(\"\
    ><<>\")\n    false\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   string openers = \"<\";\n    string closers = \">\";\n    Stack stack;\n \
    \   if (find(brackets, '<') == -1)\n        return false;\n    else if (find(brackets,\
    \ '>') == -1)\n        return false;\n    else\n    {\n        for (int i = 0;\
    \ i < len(brackets); i++)\n        {\n            if (find(openers, brackets[i])\
    \ != -1)\n                stack.push(brackets[i]);\n            else if (find(closers,\
    \ brackets[i]) != -1)\n            {\n                if (len(stack) == 0)\n \
    \                   return false;\n                else if (stack.pop() != \"\
    <\")\n                    return false;\n            }\n        }\n        if\
    \ (len(stack) != 0)\n            return false;\n        else\n            return\
    \ true;\n    }\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n\
    \    assert(candidate(\"<>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n\
    \    assert(candidate(\"<><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\"\
    ) == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
    ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
    <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
    <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n   \
    \ assert(candidate(\"<><><<><>><>>><>\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcz_04s46.d(21): Error: undefined identifier `Stack`

    /tmp/tmpcz_04s46.d(22): Error: undefined identifier `find`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmpcz_04s46.d(24): Error: undefined identifier `find`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmpcz_04s46.d(28): Error: undefined identifier `len`

    /tmp/tmpcz_04s46.d(30): Error: undefined identifier `find`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmpcz_04s46.d(32): Error: undefined identifier `find`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmpcz_04s46.d(34): Error: undefined identifier `len`

    /tmp/tmpcz_04s46.d(40): Error: undefined identifier `len`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcz_04s46.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164358
