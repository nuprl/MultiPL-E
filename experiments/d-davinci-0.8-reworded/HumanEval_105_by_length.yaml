name: HumanEval_105_by_length
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of integers,\
  \ sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting\
  \ array, and then replace each digit by its corresponding name from\n    \"One\"\
  , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
  .\n\n    For example:\n    >>> by_length([2L, 1L, 1L, 4L, 5L, 8L, 2L, 3L])\n   \
  \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
  ]\n    \n      If the array is empty, return an empty array:\n    >>> by_length([])\n\
  \    []\n    \n      If the array has any strange number ignore it:\n    >>> by_length([1L,\
  \ -1L, 55L])\n    [\"One\"]\n    \n*/\nstring[] by_length(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = by_length;\n\n    assert(candidate([2L,\
  \ 1L, 1L, 4L, 5L, 8L, 2L, 3L]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
  Two\", \"Two\", \"One\", \"One\"]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
  \ -1L, 55L]) == [\"One\"]);\n    assert(candidate([1L, -1L, 3L, 2L]) == [\"Three\"\
  , \"Two\", \"One\"]);\n    assert(candidate([9L, 4L, 8L]) == [\"Nine\", \"Eight\"\
  , \"Four\"]);\n}\nvoid main(){}"
completions: ["{\n  /*\n  TODO: Write test cases to check your function\n  */\n  long[string]\
    \ map = [\n      \"One\": 1L,\n      \"Two\": 2L,\n      \"Three\": 3L,\n    \
    \  \"Four\": 4L,\n      \"Five\": 5L,\n      \"Six\": 6L,\n      \"Seven\": 7L,\n\
    \      \"Eight\": 8L,\n      \"Nine\": 9L\n  ];\n  return arr.sort().filter!(a\
    \ => a >= 1 && a <= 9).reverse().map!(a => map.reversed[a]);\n}\n```\n### 4\n\
    ```\n/*\n    Given a non-empty array of integers, write a function that returns\
    \ the longest subarray with consecutive even integers.\n    An array is a sequence\
    \ of elements of the same type placed in contiguous memory locations that can\
    \ be individually referenced by adding an index to a unique identifier.", "{\n\
    \  string[] result;\n  foreach(i; arr)\n    if(i>0 && i<10)\n      result ~= to!string(i);\n\
    \  result.sort;\n  result.reverse;\n  foreach(i; result)\n    i = to!string(result[i]);\n\
    \  return result;\n}", "{\n    string[] digits = [\"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    string[]\
    \ numbers = cast(string[]) arr;\n    string[] filt_nums = filter!((x) => x <=\
    \ 9)(numbers);\n    sort(filt_nums);\n    string[] rev_nums = reverse(filt_nums);\n\
    \    string[] out = map!((x) => digits[to!(int)(x - 1)])(rev_nums);\n    return\
    \ out;\n}", "{\n    auto a = arr.filter!(a => a >= 1 && a <= 9).array.sort().retro;\n\
    \    return a.map!(a => a == 1 ? \"One\"\n                : a == 2 ? \"Two\"\n\
    \                : a == 3 ? \"Three\"\n                : a == 4 ? \"Four\"\n \
    \               : a == 5 ? \"Five\"\n                : a == 6 ? \"Six\"\n    \
    \            : a == 7 ? \"Seven\"\n                : a == 8 ? \"Eight\"\n    \
    \            : a == 9 ? \"Nine\"\n                : \"\").array;\n}", "{\n   \
    \ auto size = arr.length;\n    string[] result = new string[size];\n    int[]\
    \ tmp = new int[size];\n    int i = 0;\n    foreach(l; arr)\n    {\n        if(l\
    \ > 0 && l < 10)\n        {\n            tmp[i] = cast(int)l;\n            i++;\n\
    \        }\n    }\n    sort(tmp[0..i]);\n    reverse(tmp[0..i]);\n    string[]\
    \ names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"];\n    foreach(l; tmp[0..i])\n    {\n        result ~= names[l-1];\n\
    \    }\n    return result;\n}", "{\n    //TODO - implement the function\n    return\
    \ [];\n}\n \n</pre>", "{\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    //return [];\n}", "{ \n    sort(arr);\n    auto res = appender!(string[])();\n\
    \    for (int i = arr.length - 1; i >= 0; i--)\n    {\n        string str = \"\
    \";\n        switch (arr[i])\n        {\n            case 1:\n               \
    \ str = \"One\";\n                break;\n            case 2:\n              \
    \  str = \"Two\";\n                break;\n            case 3:\n             \
    \   str = \"Three\";\n                break;\n            case 4:\n          \
    \      str = \"Four\";\n                break;\n            case 5:\n        \
    \        str = \"Five\";\n                break;\n            case 6:\n      \
    \          str = \"Six\";\n                break;\n            case 7:\n     \
    \           str = \"Seven\";\n                break;\n            case 8:\n  \
    \              str = \"Eight\";\n                break;\n            case 9:\n\
    \                str = \"Nine\";\n                break;\n            default:\n\
    \                break;\n        }\n        if (str.length != 0)\n           \
    \ res.put(str);\n    }\n    return res.data;\n}", "{\n  auto result = new string[];\n\
    \  // write your code here\n  \n  return result;\n}\n \n \n/*\n    Accepts a multidimensional\
    \ array and returns a flattened version of the array.\n    \n    For example:\n\
    \    >>> flatten([[1L, 2L], [3L, 4L], [5L, 6L]])\n    [1L, 2L, 3L, 4L, 5L, 6L]\n\
    \    \n      The multidimensional array will only be up to 2 dimensional:\n  \
    \  >>> flatten([[[1L, 2L]], [[3L], [4L]], [[5L, 6L]]])\n    [1L, 2L, 3L, 4L, 5L,\
    \ 6L]\n    \n      If the array is empty, return an empty array:\n    >>> flatten([])\n\
    \    []\n*/\nlong[] flatten(long[][] arr) \n{\n  auto result = new long[];\n \
    \ // write your code here\n  \n  return result;\n}\n \n/*\n    Accepts a range\
    \ of integers and returns a tuple of the number of odd numbers in the range,\n\
    \    the number of even numbers in the range, and the number of zeros in the range.\n\
    \    \n    For example:\n    >>> count_odd_even_zeros(0..5)\n    (3, 2, 0)\n \
    \   \n      The range can be any length:\n    >>> count_odd_even_zeros(0..20)\n\
    \    (11, 9, 0)\n    \n      Negative integers count:\n    >>> count_odd_even_zeros(-3..1)\n\
    \    (3, 2, 0)\n    \n      Only count the number of zeros between -10 and 10:\n\
    \    >>> count_odd_even_zeros(-10..10)\n    (10, 10, 1)\n*/\nTuple!(ulong, ulong,\
    \ ulong) count_odd_even_zeros(Range)\n{\n  // write your code here\n  return tuple(0,\
    \ 0, 0);\n}\n \n/*\n    Accepts a map and returns a version of the map where the\
    \ keys and values have been swapped.\n    \n   ", "{\n    immutable number_names\
    \ = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"\
    , \"Nine\"];\n    return\n        arr\n        .filter!(x => x >= 1 && x <= 9)\n\
    \        .sort()\n        .reverse()\n        .map!(x => number_names[x - 1])\n\
    \        .array;\n}", "{ \n    import std.algorithm.sorting; \n    import std.range;\
    \ \n    import std.stdio; \n    immutable n = arr.filter!(a => 1L <= a && a <=\
    \ 9L).sort.retro; \n    string[] res = new string[n.length]; \n    size_t i =\
    \ 0; \n    foreach (immutable x; n) \n    { \n        switch (x) \n        { \n\
    \            case 1L: res[i] = \"One\"; break; \n            case 2L: res[i] =\
    \ \"Two\"; break; \n            case 3L: res[i] = \"Three\"; break; \n       \
    \     case 4L: res[i] = \"Four\"; break; \n            case 5L: res[i] = \"Five\"\
    ; break; \n            case 6L: res[i] = \"Six\"; break; \n            case 7L:\
    \ res[i] = \"Seven\"; break; \n            case 8L: res[i] = \"Eight\"; break;\
    \ \n            case 9L: res[i] = \"Nine\"; break; \n        } \n        i++;\
    \ \n    } \n    return res; \n}", "{\n    // create array of names\n    string[]\
    \ names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"];\n    // create array of sorted numbers\n    long[] sorted_arr\
    \ = sort(arr).by!((a, b) => a < b && a <= 9 && b <= 9);\n    // create array of\
    \ empty strings\n    string[] output = repeat(\"\", sorted_arr.length);\n    //\
    \ loop through strings and replace with name\n    for (size_t i = 0; i < sorted_arr.length;\
    \ i++)\n    {\n        if (sorted_arr[i] <= 9)\n        {\n            output[i]\
    \ = names[sorted_arr[i] - 1];\n        }\n    }\n    // reverse output\n    reverse(output);\n\
    \    return output;\n}", "{\n    immutable int[] indexes = iota(arr.length);\n\
    \    indexes.sort!((a, b) => ((arr[a] == arr[b]) ? 0 : ((arr[a] < arr[b]) ? -1\
    \ : 1)));\n    indexes.reverse;\n    string[] ret = [null];\n    ret.length =\
    \ arr.length;\n    foreach (i; indexes)\n    {\n        if (arr[i] <= 9 && arr[i]\
    \ >= 1)\n        {\n            ret[i] = arr[i].to!string;\n        }\n    }\n\
    \    return ret.filter!(a => a !is null).map!(a => format(\"$(a[0].toUpper ~ a[1..$].toLower)\"\
    )).array;\n}\n \n/*\n \nfazit:\nder erste versuch ist nicht schlecht, nur das\
    \ hier ist doch schon k\xFCrzer und was ist das hier denn:", "{\n    long[] sort,\
    \ rev;\n    long i;\n    string[] s;\n    sort = [ 1L, 2L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L];\n    rev = [ 9L, 8L, 7L, 6L, 5L, 4L, 3L, 2L, 1L];\n    i = 0L;\n  \
    \  sort(arr);\n    s = new string[arr.length];\n    foreach(x;arr)\n    {\n  \
    \      if(x >= 1L && x <= 9L)\n        {\n            s[i] = cast(string)x;\n\
    \            i++;\n        }\n    }\n    sort(s);\n    foreach(x;s)\n    {\n \
    \       if(x == \"1\")\n        {\n            x = \"One\";\n        }\n     \
    \   else if(x == \"2\")\n        {\n            x = \"Two\";\n        }\n    \
    \    else if(x == \"3\")\n        {\n            x = \"Three\";\n        }\n \
    \       else if(x == \"4\")\n        {\n            x = \"Four\";\n        }\n\
    \        else if(x == \"5\")\n        {\n            x = \"Five\";\n        }\n\
    \        else if(x == \"6\")\n        {\n            x = \"Six\";\n        }\n\
    \        else if(x == \"7\")\n        {\n            x = \"Seven\";\n        }\n\
    \        else if(x == \"8\")\n        {\n            x = \"Eight\";\n        }\n\
    \        else if(x == \"9\")\n        {\n            x = \"Nine\";\n        }\n\
    \    }\n    return s;\n}", "{\n    int[] tmp = map!(val => val >= 1 && val <=\
    \ 9 ? val : 0)(arr);\n    string[] result = new string[tmp.length];\n    for (int\
    \ i = 0; i < tmp.length; i++) \n    {\n        switch (tmp[i]) \n        {\n \
    \           case 1:\n                result[i] = \"One\";\n                break;\n\
    \            case 2:\n                result[i] = \"Two\";\n                break;\n\
    \            case 3:\n                result[i] = \"Three\";\n               \
    \ break;\n            case 4:\n                result[i] = \"Four\";\n       \
    \         break;\n            case 5:\n                result[i] = \"Five\";\n\
    \                break;\n            case 6:\n                result[i] = \"Six\"\
    ;\n                break;\n            case 7:\n                result[i] = \"\
    Seven\";\n                break;\n            case 8:\n                result[i]\
    \ = \"Eight\";\n                break;\n            case 9:\n                result[i]\
    \ = \"Nine\";\n                break;\n            default:\n                break;\n\
    \        }\n    }\n    return result.array.sort().reverse().take(tmp.length).array;\n\
    }", "{\n    import std.algorithm.sorting;\n    import std.algorithm.iteration;\n\
    \    import std.traits;\n    import std.range;\n    import std.string;\n    import\
    \ std.conv;\n    import std.array;\n    import std.algorithm;\n    import std.math;\n\
    \    import std.typecons;\n    import std.container;\n    immutable arr2 = arr.filter!(a\
    \ => a <= 9 && a >= 1);\n    //arr2.sort!((a, b) => b < a);\n    arr2.sort!((a,\
    \ b) => a < b);\n    immutable arr3 = arr2.map!(a => to!string(a));\n    immutable\
    \ arr4 = arr3.map!(a => \"One Two Three Four Five Six Seven Eight Nine\".split('\
    \ ')[to!long(a)-1]);\n    return arr4;\n}", "{\n    \n    // Sort the array\n\
    \    std.algorithm.sort(arr);\n    \n    // Get the reverse of it\n    auto rev\
    \ = arr.reverse;\n    \n    // Create the array to be returned\n    string[] nums;\n\
    \    \n    // Iterate on the array, convert each int to a string\n    // and append\
    \ it to the array to be returned\n    foreach(n; rev)\n    {\n        switch(n)\n\
    \        {\n            case 1:\n                nums ~= \"One\";\n          \
    \      break;\n            case 2:\n                nums ~= \"Two\";\n       \
    \         break;\n            case 3:\n                nums ~= \"Three\";\n  \
    \              break;\n            case 4:\n                nums ~= \"Four\";\n\
    \                break;\n            case 5:\n                nums ~= \"Five\"\
    ;\n                break;\n            case 6:\n                nums ~= \"Six\"\
    ;\n                break;\n            case 7:\n                nums ~= \"Seven\"\
    ;\n                break;\n            case 8:\n                nums ~= \"Eight\"\
    ;\n                break;\n            case 9:\n                nums ~= \"Nine\"\
    ;\n                break;\n        }\n    }\n    \n    return nums;\n}", "{\n\
    \    string[long] map = [ 1 : \"One\",\n                         2 : \"Two\",\n\
    \                         3 : \"Three\",\n                         4 : \"Four\"\
    ,\n                         5 : \"Five\",\n                         6 : \"Six\"\
    ,\n                         7 : \"Seven\",\n                         8 : \"Eight\"\
    ,\n                         9 : \"Nine\" ];\n    auto sorted = arr.filter!(x =>\
    \ 1 <= x && x <= 9).sort.retro;\n    return sorted.map!(x => map[x]).array;\n}",
  "{\n    /* \n    \n    1. Sort the array in ascending order by the length of each\
    \ element. \n    2. Reverse the sorted array.\n    3. Replace each digit by its\
    \ corresponding name from \"One\", \"Two\", \"Three\", \n    \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    */\n    if (arr.length == 0)\n\
    \    {\n        return [];\n    }\n    arr.sort;\n    arr.reverse;\n    string[]\
    \ finalArray = new string[arr.length];\n    foreach(i, ref value; arr)\n    {\n\
    \        switch(value)\n        {\n            case 1:\n                finalArray[i]\
    \ = \"One\";\n                break;\n            case 2:\n                finalArray[i]\
    \ = \"Two\";\n                break;\n            case 3:\n                finalArray[i]\
    \ = \"Three\";\n                break;\n            case 4:\n                finalArray[i]\
    \ = \"Four\";\n                break;\n            case 5:\n                finalArray[i]\
    \ = \"Five\";\n                break;\n            case 6:\n                finalArray[i]\
    \ = \"Six\";\n                break;\n            case 7:\n                finalArray[i]\
    \ = \"Seven\";\n                break;\n            case 8:\n                finalArray[i]\
    \ = \"Eight\";\n                break;\n            case 9:\n                finalArray[i]\
    \ = \"Nine\";\n                break;\n            default:\n                finalArray[i]\
    \ = \"\";\n                break;\n        }\n    }\n    return finalArray;\n}",
  "{\n    import std.algorithm;\n    import std.range;\n    import std.array;\n  \
    \  import std.conv;\n    import std.string;\n    import std.stdio;\n    import\
    \ std.digest.md;\n    import std.digest.crc;\n    import std.math;\n    import\
    \ std.typecons;\n    import std.range;\n    import std.array;\n    import std.conv;\n\
    \    import std.string;\n    import std.stdio;\n    import std.digest.md;\n  \
    \  import std.digest.crc;\n    import std.math;\n    import std.typecons;\n  \
    \  import std.range;\n    import std.array;\n    import std.conv;\n    import\
    \ std.string;\n    import std.stdio;\n    import std.digest.md;\n    import std.digest.crc;\n\
    \    import std.math;\n    import std.typecons;\n    import std.range;\n    import\
    \ std.array;\n    import std.conv;\n    import std.string;\n    import std.stdio;\n\
    \    import std.digest.md;\n    import std.digest.crc;\n    import std.math;\n\
    \    import std.typecons;\n    import std.range;\n    import std.array;\n    import\
    \ std.conv;\n    import std.string;\n    import std.stdio;\n    import std.digest.md;\n\
    \    import std.digest.crc;\n    import std.math;\n    import std.typecons;\n\
    \    import std.range;\n    import std.array;\n    import std.conv;\n    import\
    \ std.string;\n    import std.stdio;\n    import std.digest.md;\n    import std.digest.crc;\n\
    \    import std.math;\n    import std.typecons;\n    import std.range;\n    import\
    \ std.array;\n    import std.conv;\n    import std.string;\n    import std.stdio;\n\
    \    import std.digest.md;\n    import std.digest.crc;\n    import std.math;\n\
    \    import std.type"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
