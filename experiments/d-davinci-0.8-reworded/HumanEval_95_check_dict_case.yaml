name: HumanEval_95_check_dict_case
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative array,\
  \ return true if all keys are strings in lower \n    case or all keys are strings\
  \ in upper case, else return false.\n    The function should return false is the\
  \ given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
  a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
  a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n   \
  \ >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
  \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
  : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
  , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
  \ dict) \n"
tests: "unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
  p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
  p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
  \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
  ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\"\
  , \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\":\
  \ \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
  : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
  \ == false);\n}\nvoid main(){}"
completions: ["{ \n    if(dict.isNull) return false;\n    int dict_length = dict.get.length;\n\
    \    if(dict_length == 0) return false;\n    bool is_upper_case = false;\n   \
    \ foreach(key; dict.get.keys)\n    {\n        if(key.length == 0) return false;\n\
    \        if(key.length > 1) is_upper_case = key[0].isUpper;\n        if(is_upper_case\
    \ && !key.isUpper) return false;\n        if(!is_upper_case && !key.isLower) return\
    \ false;\n    }\n    return true;\n}", "{\n    if(dict is null)\n        return\
    \ false;\n    if(dict.length == 0)\n        return false;\n    auto keys = dict.keys;\n\
    \    auto b = any!(isUpper(keys[0][0]));\n    return !any!(isLower(keys[0][0]))\
    \ == b;\n}", "{ \n    if (dict.isNull)\n        return false;\n    \n    enum\
    \ is_upper = true;\n    enum is_lower = true;\n    //foreach (k, v; dict) {\n\
    \    for (auto key : dict.keys) {\n        string k = key;\n        string v =\
    \ dict[key];\n        is_upper = is_upper && k.toUpper() == k;\n        is_lower\
    \ = is_lower && k.toLower() == k;\n    }\n    return is_upper || is_lower;\n}",
  "{\n    if (dict == null)\n        return false;\n    bool result = true;\n    bool\
    \ upper;\n    foreach (k, v; dict)\n    {\n        if (k.length == 0) \n     \
    \   {\n            result = false;\n            break;\n        }\n        if\
    \ (upper == false && k[0].isUpper())\n        {\n            upper = true;\n \
    \       }\n        if (upper == true && k[0].isLower())\n        {\n         \
    \   result = false;\n            break;\n        }\n    }\n    return result;\n\
    }", "{\n    if (dict is null)\n        return false;\n    bool is_lower = dict.keys[0].isLower;\n\
    \    bool is_upper = dict.keys[0].isUpper;\n    if (is_lower || is_upper)\n  \
    \  {\n        foreach (key; dict.keys)\n        {\n            if (is_lower)\n\
    \            {\n                if (!key.isLower)\n                    return\
    \ false;\n            }\n            else if (is_upper)\n            {\n     \
    \           if (!key.isUpper)\n                    return false;\n           \
    \ }\n        }\n        return true;\n    }\n    return false;\n}\n/*\n    Return\
    \ the number of vowels in a given string.\n    The function should return an integer.\n\
    \    Example:\n    >>> count_vowels(\"apple\".nullable)\n    2\n    >>> count_vowels(\"\
    HELLO\".nullable)\n    2\n    >>> count_vowels(\"fun\".nullable)\n    1\n    >>>\
    \ count_vowels(\"123\".nullable)\n    0\n*/", "{\n    if (dict == null) return\
    \ false;\n    string[] keys = dict.keys;\n    bool lower_case = true;\n    bool\
    \ upper_case = true;\n    foreach (key; keys) \n    {\n        if (lower_case)\
    \ \n        {\n            if (key.length != key.toLower().length) \n        \
    \    {\n                lower_case = false;\n            }\n        }\n      \
    \  if (upper_case) \n        {\n            if (key.length != key.toUpper().length)\
    \ \n            {\n                upper_case = false;\n            }\n      \
    \  }\n        if (!lower_case && !upper_case) \n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}", "{\n    if(dict.isNull)\n  \
    \      return false;\n    string[] keyList = dict.get.keys.array;\n    bool allUpper\
    \ = true;\n    bool allLower = true;\n    foreach(key; keyList) \n    {\n    \
    \    if(isUpper(key))\n            allLower = false;\n        else\n         \
    \   allUpper = false;\n    }\n    return allUpper || allLower;\n}", "{\n    if(dict\
    \ is null) return false;\n    if(dict.empty) return false;\n    bool first_is_upper\
    \ = dict.keys[0].isUpper;\n    foreach(key; dict.keys) \n    {\n        if(key.isUpper\
    \ == first_is_upper) continue;\n        return false;\n    }\n    return true;\n\
    }", "{\n    string caseType;\n    if (dict is null) return false;\n    foreach\
    \ (key, value; dict)\n    {\n        if (is(typeof(key) == string))\n        {\n\
    \            if (caseType.empty)\n            {\n                if (key.isUpperCase)\n\
    \                    caseType = \"upper\";\n                else if (key.isLowerCase)\n\
    \                    caseType = \"lower\";\n                else\n           \
    \         return false;\n            }\n            else\n            {\n    \
    \            if (caseType == \"upper\" && !key.isUpperCase)\n                \
    \    return false;\n                else if (caseType == \"lower\" && !key.isLowerCase)\n\
    \                    return false;\n            }\n        }\n        else\n \
    \           return false;\n    }\n    return true;\n}", "{\n    bool isLowercase\
    \ = true;\n    bool isUppercase = true;\n    if (dict.isNull)\n        return\
    \ false;\n    foreach (k, v; dict) \n    {\n        isLowercase &= isAlpha(k[0])\
    \ && k.toLower == k;\n        isUppercase &= isAlpha(k[0]) && k.toUpper == k;\n\
    \    }\n    return isLowercase || isUppercase;\n}", "in\n{\n    import std.algorithm;\n\
    \    import std.ascii;\n    import std.conv;\n    import std.range;\n    import\
    \ std.regex;\n    import std.traits;\n}\nbody\n{\n    auto result = dict.value\n\
    \        .all!\"a.isUpper\" || dict.value\n        .all!\"a.isLower\";\n    return\
    \ result;\n}", "in {\n    assert(dict !is null);\n}\nbody {\n    if (dict.isNull)\
    \ return false;\n    auto dict_keys = dict.keys.sort;\n    foreach (key; dict_keys)\
    \ {\n        if (!isUpperCase(key) && !isLowerCase(key)) return false;\n    }\n\
    \    if (dict_keys.length <= 1) return true;\n    if (isUpperCase(dict_keys[0]))\
    \ {\n        foreach (key; dict_keys)\n            if (!isUpperCase(key)) return\
    \ false;\n    } else {\n        foreach (key; dict_keys)\n            if (!isLowerCase(key))\
    \ return false;\n    }\n    return true;\n}", "    if (isInputRange!(typeof(dict)))\n\
    {\n    if (dict is null) return false;\n    /*\n        In Nim we can make a String\
    \ to be upper or lower case by adding\n        ^ to the front of it (see https://nim-lang.org/docs/manual.html#case-conversion)\n\
    \        so we can use that as a way to determine if all keys are upper or all\
    \ \n        keys are lower.\n        str.isupper seems to return false all the\
    \ time, so we can't use that.\n    */\n    // This is just a cheat to get us started,\
    \ this is not the answer\n    return dict.all!((pair) => pair.key.isupper);\n}",
  "    if(is(TypeOf!(dict) == Nullable!(string[string])))\n{\n    if(dict.isNull)\n\
    \        return false;\n    bool allUpper = true;\n    bool allLower = true;\n\
    \    foreach(key; dict.get.keys)\n    {\n        if(!allUpper)\n            break;\n\
    \        allUpper = !(allUpper && anyLower(key));\n    }\n    foreach(key; dict.get.keys)\n\
    \    {\n        if(!allLower)\n            break;\n        allLower = !(allLower\
    \ && anyUpper(key));\n    }\n    return (allUpper || allLower);\n}", "{\n    if\
    \ (dict.isNull) return false;\n    string[] ks = dict.keys();\n    if (ks.length\
    \ == 0) return false;\n    bool is_lower = true;\n    bool is_upper = true;\n\
    \    foreach (int k; ks) {\n        if (is_lower && k >= 'A' && k <= 'Z')\n  \
    \          is_lower = false;\n        if (is_upper && k >= 'a' && k <= 'z')\n\
    \            is_upper = false;\n    }\n    return is_lower || is_upper;\n}", "{\n\
    \    if (dict is null)\n        return false;\n    bool lower = dict.byKey.all!(k\
    \ => k.all!(c => c.isLower));\n    bool upper = dict.byKey.all!(k => k.all!(c\
    \ => c.isUpper));\n    return lower || upper;\n}", "{\n    if (dict is null) return\
    \ false;\n    else if (dict.length == 0) return false;\n    bool isLower = dict.keys[0].isLower;\n\
    \    foreach (k, v; dict)\n    {\n        if (k.isLower != isLower) return false;\n\
    \    }\n    return true;\n}", "{\n    static immutable digitR = appender!(Chain)(\"\
    0\" .. \"9\");\n    static immutable upperR = appender!(Chain)(\"A\" .. \"Z\"\
    );\n    static immutable lowerR = appender!(Chain)(\"a\" .. \"z\");\n    bool\
    \ lower = true;\n    bool upper = true;\n    if (dict is null)\n        return\
    \ false;\n    foreach (key; dict.keys)\n    {\n        foreach (ch; key)\n   \
    \     {\n            if (digitR.canFind(ch))\n                return false;\n\
    \            if (lowerR.canFind(ch))\n                upper = false;\n       \
    \     if (upperR.canFind(ch))\n                lower = false;\n        }\n   \
    \ }\n    return lower || upper;\n}", "{\n    if (dict.isNull) return false;\n\
    \    else \n    {\n        string[] keys = dict.isNull ? [] : dict.get.keys;\n\
    \        if (keys.length == 0) return false;\n        bool allLowerCase = true;\n\
    \        bool allUpperCase = true;\n        foreach (key; keys)\n        {\n \
    \           if (key.isLower) allUpperCase = false;\n            else if (key.isUpper)\
    \ allLowerCase = false;\n            else return false;\n        }\n        return\
    \ allLowerCase || allUpperCase;\n    }\n}", "{\n    \n    if (dict is null) \n\
    \    {\n        return false;\n    }\n    int lower = 0;\n    int upper = 0;\n\
    \    foreach (key; dict.keys) \n    {\n        if (key.isLower) \n        {\n\
    \            lower++;\n        }\n        else if (key.isUpper) \n        {\n\
    \            upper++;\n        }\n        else \n        {\n            return\
    \ false;\n        }\n    }\n    if (lower == 0 || upper == 0) \n    {\n      \
    \  return true;\n    }\n    return false;\n}", "{\n    if(dict is null) \n   \
    \ {\n        return false;\n    }\n    if(dict.length == 0) \n    {\n        return\
    \ false;\n    }\n    bool all_keys_lower = true;\n    foreach(key; dict.keys)\
    \ \n    {\n        if(key.isLowerCase) \n        {\n            continue;\n  \
    \      }\n        all_keys_lower = false;\n        break;\n    }\n    if(all_keys_lower)\
    \ \n    {\n        return true;\n    }\n    else \n    {\n        bool all_keys_upper\
    \ = true;\n        foreach(key; dict.keys) \n        {\n            if(key.isUpperCase)\
    \ \n            {\n                continue;\n            }\n            all_keys_upper\
    \ = false;\n            break;\n        }\n        return all_keys_upper;\n  \
    \  }\n}", "{\n    if(dict.isNull)\n        return false;\n    import std.string;\n\
    \    string key;\n    foreach(key;dict.data.keys)\n    {\n        if(key.length\
    \ <= 0)\n            return false;\n        if(key[0].isUpper!(\"\")!is(typeof(key[0])))\n\
    \            return false;\n        if(key[0].isLower!(\"\")!is(typeof(key[0])))\n\
    \            return false;\n    }\n    return true;\n}", "{\n    if(dict is null)\
    \ \n    {\n        return false;\n    }\n    bool lower = true;\n    bool upper\
    \ = true;\n    foreach(key; dict.keys) \n    {\n        if(key.isUpper) \n   \
    \     {\n            lower = false;\n        }\n        else if(key.isLower) \n\
    \        {\n            upper = false;\n        }\n        else \n        {\n\
    \            return false;\n        }\n    }\n    return lower || upper;\n}",
  "{\n    if(dict is null)\n        return false;\n    \n    bool expected = true;\n\
    \    bool gotString = false;\n    bool gotUpper = false;\n    bool gotLower =\
    \ false;\n    foreach(string key, string value; dict)\n    {\n        if(isUpper(key[0]))\n\
    \            gotUpper = true;\n        else if(isLower(key[0]))\n            gotLower\
    \ = true;\n        \n        if(gotUpper && gotLower)\n            return false;\n\
    \        \n        gotString = true;\n    }\n    \n    if(gotString)\n       \
    \ return true;\n    else\n        return false;\n}\n/*\n    Given a dictionary\
    \ which represent the weather, the key is a string of the \n    city, the value\
    \ is a tuple of the max and min temperature.\n    Return a new dictionary which\
    \ contains only the city that has temperature \n    higher than 80, and the value\
    \ is the difference between the max and min \n    temperature.\n    The difference\
    \ can be negative, in this case, just remove the city from the\n    new dictionary.\n\
    \    Examples:\n    >>> city_to_temp = [\"New York\": (74, 66), \"Berlin\": (44,\
    \ 29), \"London\": (90, 77), \"Johannesburg\": (87, 59)].nullable\n    >>> temp_diff_dict(city_to_temp)\n\
    \    [\"London\": 13, \"Johannesburg\": 28]\n*/\nNullable!(string[int]) temp_diff_dict(Nullable!(string[(int,\
    \ int)]) city_to_temp) \n{\n    if(city_to_temp is null)\n        return null;\n\
    \        \n    auto result = new string[int];\n    foreach(string city, (int min,\
    \ int max) values; city_to_temp)\n    {\n        if(max > 80)\n            result[city]\
    \ = max - min;\n    }\n    \n    return result;\n}\n/*\n    Given an array which\
    \ contains the information of the student ID and their \n    grade. The student\
    \ ID is a string, and the grade is an array of strings.\n    Return a new array\
    \ which contains the student", "{\n    if(dict is null) return false;", "{\n \
    \   if(dict is null) return false;\n    bool all_uppercase = true;\n    bool all_lowercase\
    \ = true;\n    foreach(key; dict.keys)\n    {\n        if(key.length == 0) return\
    \ false;\n        foreach(ch; key)\n        {\n            if(ch.isUpper)\n  \
    \          {\n                all_lowercase = false;\n            }\n        \
    \    else if(ch.isLower)\n            {\n                all_uppercase = false;\n\
    \            }\n            else\n            {\n                return false;\n\
    \            }\n        }\n    }\n    return all_uppercase || all_lowercase;\n\
    }", "{\n    int upperCase = 0;\n    foreach(key; dict.keys)\n    {\n        if(!key.isUpperCase)\n\
    \        {\n            upperCase = -1;\n            break;\n        }\n    }\n\
    \    if(upperCase==0)\n        return true;\n    foreach(key; dict.keys)\n   \
    \ {\n        if(!key.isLowerCase)\n        {\n            return false;\n    \
    \    }\n    }\n    return true;\n}", "{\n    bool result = false;\n    if(dict.isNull)\
    \ \n    {\n        return result;\n    }\n    else \n    {\n        bool isUpper\
    \ = true;\n        bool isLower = true;\n        foreach(key; dict.get.keys) \n\
    \        {\n            isUpper &= isUpper(key);\n            isLower &= isLower(key);\n\
    \        }\n        result = isUpper || isLower;\n    }\n    return result;\n\
    }\nstatic assert(check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable));\n\
    static assert(!check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"\
    banana\"].nullable));\nstatic assert(!check_dict_case([\"a\": \"apple\", 8L: \"\
    banana\", \"a\": \"apple\"].nullable));\nstatic assert(!check_dict_case([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable));\nstatic assert(check_dict_case([\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"].nullable));\n \n ", "{\n    if (dict is null)\
    \ return false;\n    foreach (key, value; dict) \n    {\n        if (key is string)\
    \ \n        {\n            if (isUpperCase(key) && !isUpperCase(key)) return false;\n\
    \            if (isLowerCase(key) && !isLowerCase(key)) return false;\n      \
    \  }\n        else return false;\n    }\n    return true;\n}", "    if (is(typeof(dict)\
    \ == Nullable!(string[string])))\n{\n    static if (is(typeof(dict) == Nullable!(string[string])))\n\
    \    {\n        if (dict is null)\n        {\n            return false;\n    \
    \    }\n        else if (dict.length == 0)\n        {\n            return false;\n\
    \        }\n        else\n        {\n            string[] keys = dict.keys;\n\
    \            string[] values = dict.values;\n            bool flag = true;\n \
    \           for (int i = 0; i < keys.length; i++)\n            {\n           \
    \     static if (is(typeof(keys[i]) == string))\n                {\n         \
    \           static if (keys[i].toLower() == keys[i])\n                    {\n\
    \                        static if (values[i].toLower() == values[i])\n      \
    \                  {\n                            flag = true;\n             \
    \           }\n                        else\n                        {\n     \
    \                       flag = false;\n                            break;\n  \
    \                      }\n                    }\n                    else if (keys[i].toUpper()\
    \ == keys[i])\n                    {\n                        static if (values[i].toUpper()\
    \ == values[i])\n                        {\n                            flag =\
    \ true;\n                        }\n                        else\n           \
    \             {\n                            flag = false;\n                 \
    \           break;\n                        }\n                    }\n       \
    \             else\n                    {\n                        flag = false;\n\
    \                        break;\n                    }\n                }\n  \
    \              else\n                {\n                    flag = false;\n  \
    \                  break;\n                }\n            }\n            return\
    \ flag;\n        }\n    }\n    else\n    {\n        static assert(0, \"dict is\
    \ not an associative array\");\n    }\n}", "{\n    if(dict is null) return false;\n\
    \    bool are_keys_lower = false;\n    bool are_keys_upper = false;\n    foreach(key;\
    \ dict.keys)\n    {\n        if(key.isUpper)\n        {\n            are_keys_upper\
    \ = true;\n        }\n        else if(key.isLower)\n        {\n            are_keys_lower\
    \ = true;\n        }\n        else\n        {\n            return false;\n   \
    \     }\n    }\n    return are_keys_lower ^ are_keys_upper;\n}\n/*\n    The function\
    \ takes a two-dimensional array and returns the sum of all \n    the numbers in\
    \ the array.\n    Examples:\n    >>> sum_of_numbers([[1, 2, 3], [1, 2, 3]].nullable)\n\
    \    12\n    >>> sum_of_numbers([[1, 2, 3], [4, 5, 6]].nullable)\n    21\n   \
    \ >>> sum_of_numbers([[1, 2, 3], [4, 5, 6], [7, 8, 9]].nullable)\n    45\n   \
    \ >>> sum_of_numbers([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]].nullable)\n\
    \    78\n    >>> sum_of_numbers([].nullable)\n    0\n*/", "in {\n    assert(dict\
    \ !is null);\n} \nbody {\n    assert(dict !is null);\n    if (dict.isNull) return\
    \ false;", "in\n{\n    assert(!dict.isNull);\n}\nbody\n{\n    return dict.length\
    \ == 0 ? \n        false : \n        dict.all!(kv => kv.key.toLower() == kv.key\
    \ || kv.key.toUpper() == kv.key);\n}", "{\n    // your code here\n    bool isUpperCase\
    \ = true;\n    bool isLowerCase = true;\n    foreach(key, value; dict)\n    {\n\
    \        if(!std.ascii.isUpper(key[0]))\n        {\n            isUpperCase =\
    \ false;\n        }\n        if(!std.ascii.isLower(key[0]))\n        {\n     \
    \       isLowerCase = false;\n        }\n    }\n    return isUpperCase || isLowerCase;\n\
    }", "{\n    if (dict is null)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    foreach (key; dict.keys) \n    {\n        if (key.length\
    \ == 0)\n            return false;\n        if (key[0].isUpper)\n            lower\
    \ = false;\n        if (key[0].isLower)\n            upper = false;\n    }\n \
    \   return lower || upper;\n}", "{\n    if (dict is null)\n        return false;\n\
    \    string[] keys = dict.keys;\n    if (keys.length == 0)\n        return false;\n\
    \    return keys.every!(a => a.isUpper).any && \n           keys.every!(a => a.isLower).any;\n\
    }\n/*\n    Given an associative array where all keys are strings, return a new\
    \ \n    associative array where the case of the keys is changed.\n    In case\
    \ the given associative array is empty, return the same.\n    Examples:\n    >>>\
    \ change_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    [\"A\"\
    : \"apple\", \"B\": \"banana\"]\n    >>> change_dict_case([\"a\": \"apple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable)\n    [\"a\": \"apple\", \"a\": \"\
    banana\", \"b\": \"banana\"]\n    >>> change_dict_case([\"a\": \"apple\", 8L:\
    \ \"banana\", \"a\": \"apple\"].nullable)\n    [\"a\": \"apple\", 8L: \"banana\"\
    , \"a\": \"apple\"]\n    >>> change_dict_case([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable)\n    [\"nAME\": \"John\", \"aGE\": \"36\"\
    , \"cITY\": \"Houston\"]\n    >>> change_dict_case([\"STATE\": \"NC\", \"ZIP\"\
    : \"12345\"].nullable)\n    [\"state\": \"NC\", \"zip\": \"12345\"]\n*/\nstring[string]\
    \ change_dict_case(Nullable!(string[string]) dict)\n{\n    if (dict is null)\n\
    \        return [];\n    string[] keys = dict.keys;\n    if (keys.length == 0)\n\
    \        return [];\n    string[string] ret;\n    foreach (k; keys)\n    {\n \
    \       if (k.isUpper)\n            ret[k.toLower] = dict[k];\n        else\n\
    \            ret[k.toUpper] = dict[k];\n    }\n    return ret;\n}\n/*\n   ", "{\n\
    \    return dict.isNull || dict.get.all!((k, v) => k.isLower || k.isUpper);\n}",
  "{\n    bool result;\n    // all keys must be strings\n    foreach(key; dict.keys)\n\
    \    {\n        if(!is(typeof(key) == string)) return false;\n    }\n    // check\
    \ if all keys are uppercase or lowercase\n    result = dict.keys.all!(a => a.toUpper()\
    \ == a);\n    if(result) return true;\n    result = dict.keys.all!(a => a.toLower()\
    \ == a);\n    if(result) return true;\n    return false;\n}\n ", "{\n    if (dict\
    \ is null) \n    {\n        return false;\n    }\n    int lowerCount = 0;\n  \
    \  int upperCount = 0;\n    foreach (key; dict.keys) \n    {\n        if (key.isUpper)\
    \ \n        {\n            upperCount++;\n        }\n        else if (key.isLower)\
    \ \n        {\n            lowerCount++;\n        }\n        else \n        {\n\
    \            return false;\n        }\n    }\n    return (lowerCount == 0 || upperCount\
    \ == 0);\n}", "    if (is(typeof(dict)))\n{\n    return dict == null || dict.all!((k,\
    \ v) => to.upper(k) == k || to.lower(k) == k);\n}", "{\n    bool b = true;\n \
    \   if (dict is null)\n        return false;\n    //set!(string) keys = (dict.keys);\n\
    \    foreach (k; dict.keys)\n    {\n        auto ck = k.toLower();\n        if\
    \ (ck != k)\n        {\n            b = false;\n            break;\n        }\n\
    \    }\n    if (b)\n        return true;\n    foreach (k; dict.keys)\n    {\n\
    \        auto ck = k.toUpper();\n        if (ck != k)\n        {\n           \
    \ b = false;\n            break;\n        }\n    }\n    return b;\n}", "{\n  \
    \  if (dict.isNull) return false;\n    else if (dict.isEmpty) return false;\n\
    \    else \n    {\n        /* \n            Here we are using built-in function\
    \ isUpper to check if the first \n            character of the first value of\
    \ the given associative array is \n            upper case. If yes, then we will\
    \ check all values of the dictionary \n            whether all keys are upper\
    \ case or not.\n            If the first character of the first value of the given\
    \ associative \n            array is not upper case, then we will check all values\
    \ of the \n            dictionary whether all keys are lower case or not.\n  \
    \      */\n        if (dict.values[0].isUpper)\n        {\n            return\
    \ dict.values.all!(k => k.isUpper);\n        }\n        else\n        {\n    \
    \        return dict.values.all!(k => k.isLower);\n        }\n    }\n}", "{\n\
    \    if (dict == null) return false;\n    // return dict.all!(k => k.isUpper).all!(k\
    \ => k.isLower);\n    return true;\n}\n ", "{\n    bool flag = true;\n    int\
    \ cnt = 0;\n    bool is_key_upper;\n    bool is_key_lower;\n    foreach(string\
    \ key, value; dict)\n    {\n        cnt++;\n        is_key_upper = isUpper(key);\n\
    \        is_key_lower = isLower(key);\n        if(!is_key_upper && !is_key_lower)\
    \ \n        {\n            flag = false;\n            break;\n        }\n    \
    \    if(cnt == 1) \n        {\n            if(is_key_upper) flag = true;\n   \
    \         else flag = false;\n        }\n        else \n        {\n          \
    \  if(is_key_upper && !flag) break;\n            if(is_key_lower && flag) break;\n\
    \        }\n    }\n    return flag;\n}", "{\n    bool isLower = false;\n    bool\
    \ isUpper = false;\n    bool res = true;\n    if (dict.isNull) return false;\n\
    \    foreach (key, value; dict)\n    {\n        if (key.isLower)\n        {\n\
    \            isLower = true;\n        }\n        else if (key.isUpper)\n     \
    \   {\n            isUpper = true;\n        }\n        else \n        {\n    \
    \        res = false;\n            break;\n        }\n    }\n    return isLower\
    \ || isUpper;\n}", "in {\n    assert(dict.isNull);\n}\nout (result) \nin {\n \
    \   assert(result == false);\n}\nbody {\n    immutable result = true;\n    if\
    \ (dict !is null) {\n        auto key = dict.keys.front;\n        if (key !is\
    \ null) {\n            immutable char_type = islower(key[0]);\n            if\
    \ (char_type != null) {\n                foreach (key; dict.keys) {\n        \
    \            if (char_type != islower(key[0])) {\n                        result\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n            } else {\n                result = false;\n            }\n\
    \        }\n    }\n    return result;\n}", "{\n    auto keys = dict.keys();\n\
    \    if(keys.length == 0) \n    {\n        return false;\n    }\n    bool is_upper\
    \ = (keys[0][0] >= 'A' && keys[0][0] <= 'Z');\n    foreach(index, key; keys) \n\
    \    {\n        if(is_upper) \n        {\n            if(key[0] < 'A' || key[0]\
    \ > 'Z') \n            {\n                return false;\n            }\n     \
    \   }\n        else \n        {\n            if(key[0] < 'a' || key[0] > 'z')\
    \ \n            {\n                return false;\n            }\n        }\n \
    \   }\n    return true;\n}", "{\n    if(dict is null) \n    {\n        return\
    \ false;\n    }\n    return true;\n}", "{\n    /*\n    bool lower = false;\n \
    \   bool upper = false;\n    foreach(key; dict.keys)\n    {\n        string s\
    \ = key;\n        if(s.isLower)\n        {\n            lower = true;\n      \
    \  }\n        else if(s.isUpper)\n        {\n            upper = true;\n     \
    \   }\n        else\n        {\n            return false;\n        }\n    }\n\
    \    return (lower && !upper) || (!lower && upper);\n    */\n    if(dict is null)\n\
    \    {\n        return false;\n    }\n    bool allUpper = true;\n    bool allLower\
    \ = true;\n    foreach(key; dict.keys)\n    {\n        if(key.isUpper)\n     \
    \   {\n            allLower = false;\n        }\n        else if(key.isLower)\n\
    \        {\n            allUpper = false;\n        }\n        else\n        {\n\
    \            return false;\n        }\n    }\n    return allUpper || allLower;\n\
    }", "{\n    import std.algorithm;\n    import std.array;\n    import std.range;\n\
    \    import std.traits;\n    import std.typecons;\n    import std.meta;\n    import\
    \ std.string;\n    import std.conv;\n    import std.exception;\n    import std.range;\n\
    \    import std.typecons;\n    import std.algorithm;\n    import std.ascii;\n\
    \    import std.array;\n    import std.stdio;\n    import std.math;\n    import\
    \ std.typecons;\n    bool check_dict_case(Nullable!(string[string]) dict)\n  \
    \  {\n        return dict.aFilter!((x) => (x.isUpper && !x.isDigit) || (x.isLower\
    \ && !x.isDigit))\n                  .equal!(dict.aFilter!((x) => (x.isLower &&\
    \ !x.isDigit) || (x.isUpper && !x.isDigit)));\n    }\n    return dict.aFilter!((x)\
    \ => (x.isUpper && !x.isDigit) || (x.isLower && !x.isDigit))\n              .equal!(dict.aFilter!((x)\
    \ => (x.isLower && !x.isDigit) || (x.isUpper && !x.isDigit)));\n}", "{\n    bool\
    \ lower = true;\n    bool upper = true;\n    if (dict is null) return false;\n\
    \    foreach (k,v; dict)\n    {\n        if (k.length == 0) continue;\n      \
    \  if (k[0].isUpperCase())\n        {\n            lower = false;\n        }\n\
    \        else if (k[0].isLowerCase())\n        {\n            upper = false;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    return lower || upper;\n}", "{\n\tif(dict is null) return false;\n\t\
    enum is_lower = true;\n\tforeach(const key; dict.keys)\n\t{\n\t\tif(key.length\
    \ == 0)\n\t\t\treturn false;\n\t\tif(is_lower && key[0].isUpper)\n\t\t\tis_lower\
    \ = false;\n\t\telse if(!is_lower && key[0].isLower)\n\t\t\treturn false;\n\t\
    }\n\treturn true;\n}\n//test:\nunittest\n{\n\tauto dict = [\"a\": \"apple\", \"\
    b\": \"banana\"].nullable;\n\tassert(check_dict_case(dict));\n\tdict = [\"a\"\
    : \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable;\n\tassert(!check_dict_case(dict));\n\
    \tdict = [\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable;\n\tassert(!check_dict_case(dict));\n\
    \tdict = [\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable;\n\
    \tassert(!check_dict_case(dict));\n\tdict = [\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable;\n\tassert(check_dict_case(dict));\n}", "{\n    if (dict.isNull ||\
    \ !dict.keyValue.length) \n    {\n        return false;\n    }\n    if (dict.keyValue.tupleof[0][0].isUpper)\
    \ \n    {\n        foreach (key,value; dict.keyValue) \n        {\n          \
    \  if (key.isLower)\n            {\n                return false;\n          \
    \  }\n        }\n    } \n    else if (dict.keyValue.tupleof[0][0].isLower) \n\
    \    {\n        foreach (key,value; dict.keyValue) \n        {\n            if\
    \ (key.isUpper)\n            {\n                return false;\n            }\n\
    \        }\n    } \n    else \n    {\n        return false;\n    }\n    return\
    \ true;\n}", "{\n    if (dict is null) return false;\n    import std.algorithm\
    \ : any, count;\n    if (dict.isEmpty) return false;\n    string[] keys = dict.keys.array;\n\
    \    if (keys.any!(e => e[0].isUpper))\n    {\n        return keys.all!(e => e.isUpper);\n\
    \    }\n    else\n    {\n        return keys.all!(e => e.isLower);\n    }\n}",
  "{\n    assert(dict !is null);\n    static if (is(ValueType!(dict) == string)) \n\
    \    {\n        static if (hasLength!dict) \n        {\n            foreach (key;\
    \ dict.keys) \n            {\n                if (to!string(key).toLowerCase()\
    \ != key && to!string(key).toUpperCase() != key)\n                    return false;\n\
    \            }\n            return true;\n        }\n    }\n    return false;\n\
    }", "{\n    bool is_lowercase = true;\n    bool is_uppercase = true;\n    if (dict.isNull)\n\
    \        return false;\n    foreach (idx, val; dict) \n    {\n        is_lowercase\
    \ &= isLower(idx);\n        is_uppercase &= isUpper(idx);\n    }\n    return is_lowercase\
    \ || is_uppercase;\n}\n/*\n    Given an associative array of key-value pairs in\
    \ the form of a tuple, \n    return a new associative array where the keys are\
    \ the first elements of \n    the tuple and the values are the second elements\
    \ of the tuple.\n    Examples:\n    >>> list_to_dict([(\"a\", \"apple\"), (\"\
    b\", \"banana\")])\n    [\"a\": \"apple\", \"b\": \"banana\"]\n    >>> list_to_dict([(1,\
    \ \"apple\"), (2, \"banana\")])\n    [1: \"apple\", 2: \"banana\"]\n    >>> list_to_dict([(1L,\
    \ \"apple\"), (2L, \"banana\")])\n    [1: \"apple\", 2: \"banana\"]\n    >>> list_to_dict([(\"\
    a\", 1), (\"b\", 2)])\n    [\"a\": 1, \"b\": 2]\n    >>> list_to_dict([(\"a\"\
    , 1L), (\"b\", 2L)])\n    [\"a\": 1, \"b\": 2]\n*/\nTKey[TValue] list_to_dict(TKey,\
    \ TValue)(TKey[TValue] list) \n{\n    TKey[TValue] dict;\n    foreach (val; list)\n\
    \        dict[val[0]] = val[1];\n    return dict;\n}\n/*\n    Given an associative\
    \ array, return a new associative array \n    where all keys are converted to\
    \ lower case. \n    If the given associative array is empty, return an empty associative\
    \ array.\n    Examples:\n    >>> keys_to_lower([\"a\": \"apple\", \"B\": \"banana\"\
    ].nullable)\n    [\"a\": \"apple\", \"b\": \"banana\"]\n    >>> keys_", "{\n \
    \   if (dict is null) \n    {\n        return false;\n    }\n    bool all_lower\
    \ = true;\n    bool all_upper = true;\n    for (auto key; dict.keys) \n    {\n\
    \        if (all_lower && !key.isAllLower) \n        {\n            all_lower\
    \ = false;\n        }\n        if (all_upper && !key.isAllUpper) \n        {\n\
    \            all_upper = false;\n        }\n    }\n    return all_lower || all_upper;\n\
    }", "{\n    bool bValid = true;\n    bool bLower;\n    string key;\n    string\
    \ value;\n    bool bFirst = true;\n    foreach(key, value; dict)\n    {\n    \
    \    if(bFirst)\n        {\n            bLower = (key[0] == key.toLower()[0]);\n\
    \            bFirst = false;\n        }\n        else\n        {\n           \
    \ if(bLower && (key[0] != key.toLower()[0]))\n            {\n                bValid\
    \ = false;\n                break;\n            }\n            else if(!bLower\
    \ && (key[0] != key.toUpper()[0]))\n            {\n                bValid = false;\n\
    \                break;\n            }\n        }\n    }\n    return bValid;\n\
    }", "{\n    static assert(isArray!(dict));\n    static assert(isAssociativeArray!(dict));\n\
    \    static assert(is(typeof(dict[dict.keys[0]]) == string));\n    bool isUpperCase\
    \ = true;\n    bool isLowerCase = true;\n    foreach(key; dict.keys)\n    {\n\
    \        isUpperCase &= key.isUpperCase;\n        isLowerCase &= key.isLowerCase;\n\
    \    }\n    return isUpperCase || isLowerCase;\n}", "{\n    // Write your code\
    \ here\n    \n    bool uppercase = false;\n    bool lowercase = false;\n    if(dict.isNull)\n\
    \    {\n        return false;\n    }\n    foreach(key,value; dict)\n    {\n  \
    \      if(key.length != 0)\n        {\n            uppercase = toUpper(key[0])\
    \ == key[0];\n            lowercase = toLower(key[0]) == key[0];\n           \
    \ if(!uppercase && !lowercase)\n            {\n                return false;\n\
    \            }\n        }\n    }\n    return uppercase || lowercase;\n}", "{\n\
    \    if(dict is null)\n        return false;\n    if(dict.empty)\n        return\
    \ false;\n    string[] keys = dict.keys.toArray;\n    if(keys.length < 2)\n  \
    \      return true;\n    if(keys[0].toUpper == keys[0])\n    {\n        foreach(i,\
    \ e; keys)\n        {\n            if(i == 0)\n                continue;\n   \
    \         if(e.toUpper != e)\n                return false;\n        }\n    }\n\
    \    else if(keys[0].toLower == keys[0])\n    {\n        foreach(i, e; keys)\n\
    \        {\n            if(i == 0)\n                continue;\n            if(e.toLower\
    \ != e)\n                return false;\n        }\n    }\n    else\n        return\
    \ false;\n    return true;\n}", "    if (isSomeString!(dict.getKeyTypeString))\
    \ {\n    if (is(dict.getKeyTypeString == \"string\")) {\n        string[] test\
    \ = dict.keys.sort;\n        string first = test[0];\n        string last = test[$\
    \ - 1];\n        if (first == last.toLower) {\n            return true;\n    \
    \    }\n        if (first == last.toUpper) {\n            return true;\n     \
    \   }\n    }\n    return false;\n}", "{\n    if (dict.isNull) \n    {\n      \
    \  return false;\n    }\n    return dict.values[0].isLower || dict.values[0].isUpper;\n\
    }", "{\n    if (dict is null) return false;\n    bool lower = false;\n    foreach\
    \ (key; dict.keys)\n    {\n        if (!is(typeof(key) == string)) return false;\n\
    \        lower = islower(key[0]);\n        if (!lower) break;\n    }\n    if (lower)\n\
    \    {\n        foreach (key; dict.keys)\n        {\n            if (!islower(key[0]))\
    \ return false;\n        }\n    }\n    else\n    {\n        foreach (key; dict.keys)\n\
    \        {\n            if (!isupper(key[0])) return false;\n        }\n    }\n\
    \    return true;\n}", "{\n    import std.algorithm : sort;\n    if (dict is null)\
    \ \n    {\n        return false;\n    }\n    immutable keys = dict.keys.sort;\n\
    \    string[string] lower;\n    string[string] upper;\n    foreach (key; keys)\
    \ \n    {\n        key.toLower() in lower[key.toLower()] = dict[key];\n      \
    \  key.toUpper() in upper[key.toUpper()] = dict[key];\n    }\n    return keys.all!(key\
    \ => lower[key] == dict[key]) || keys.all!(key => upper[key] == dict[key]);\n}",
  "{\n    if (dict is null) \n    {\n        return false;\n    }\n    int upper =\
    \ 0;\n    int lower = 0;\n    foreach (key; dict.keys) \n    {\n        string\
    \ _key = key;\n        if (_key.isUpper) \n        {\n            upper++;\n \
    \       } \n        else if (_key.isLower) \n        {\n            lower++;\n\
    \        } \n        else \n        {\n            return false;\n        }\n\
    \    }\n    return (upper > 0) ^ (lower > 0);\n}", "{\n    if (dict.isNull ||\
    \ dict.get.length == 0)\n        return false;\n    bool uppers = false;\n   \
    \ bool lowers = false;\n    foreach (k,v; dict.get)\n    {\n        if (k.toLower\
    \ != k)\n            lowers = true;\n        if (k.toUpper != k)\n           \
    \ uppers = true;\n    }\n    return !(uppers && lowers);\n}", "{\n    bool result\
    \ = false;\n    int lower_count = 0;\n    int upper_count = 0;\n    foreach(key,\
    \ value; dict)\n    {\n        if(isUpper(key))\n        {\n            ++upper_count;\n\
    \        }\n        else if(isLower(key))\n        {\n            ++lower_count;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    if(lower_count > 0 && upper_count > 0)\n    {\n        return false;\n\
    \    }\n    return true;\n}\n/*\n    Given an associative array, return true if\
    \ all keys are strings, else return false.\n    >>> check_dict_str_keys([\"a\"\
    : \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_str_keys([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    true\n  \
    \  >>> check_dict_str_keys([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"\
    ].nullable)\n    false\n    >>> check_dict_str_keys([\"Name\": \"John\", \"Age\"\
    : \"36\", \"City\": \"Houston\"].nullable)\n    true\n    >>> check_dict_str_keys([\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n*/", "{\n    // your\
    \ code here\n    static int upper_case = 0;\n    static int lower_case = 0;\n\
    \    static bool init = false;\n    if (dict.isNull)\n        return false;\n\
    \    else\n    {\n        foreach(key, val; dict)\n        {\n            if (key[0]\
    \ >= 'A' && key[0] <= 'Z')\n            {\n                if (init)\n       \
    \         {\n                    if (upper_case == 0)\n                      \
    \  return false;\n                }\n                else\n                  \
    \  upper_case = 1;\n            }\n            else if (key[0] >= 'a' && key[0]\
    \ <= 'z')\n            {\n                if (init)\n                {\n     \
    \               if (lower_case == 0)\n                        return false;\n\
    \                }\n                else\n                    lower_case = 1;\n\
    \            }\n            else\n                return false;\n        }\n \
    \       init = true;\n        return true;\n    }\n}", "{\n    auto rnd = uniform(0,\
    \ dict.keys.length);\n    auto isupper = dict.keys[rnd].isUpper;\n    for (auto\
    \ k; dict.keys)\n    {\n        if (k.isUpper != isupper)\n            return\
    \ false;\n    }\n    return true;\n}", "{\n    if (dict.isNull) \n    {\n    \
    \    return false;\n    }\n    bool result = false;\n    bool isUpper = true;\n\
    \    bool isLower = true;\n    foreach (key, value; dict) \n    {\n        isUpper\
    \ = isUpper && isUpperCase(key);\n        isLower = isLower && isLowerCase(key);\n\
    \    }\n    result = isUpper || isLower;\n    return result;\n}", "{\n    if(null\
    \ == dict)\n        return false;\n    string[] keys = dict.keys;\n    foreach(key;\
    \ keys)\n    {\n        if(key.empty)\n            return false;\n        if(key.toUpper\
    \ != key && key.toLower != key)\n            return false;\n    }\n    return\
    \ true;\n}", "{\n    if (dict is null) return false;\n    int ucount = 0;\n  \
    \  int lcount = 0;\n    foreach (k,v; dict) \n    {\n        if (k.isUpper) ucount++;\n\
    \        if (k.isLower) lcount++;\n    }\n    return ucount == dict.length ||\
    \ lcount == dict.length;\n}\nstring[string] dict = [\"Name\": \"John\", \"Age\"\
    : \"36\", \"City\": \"Houston\"];\nassert(check_dict_case(dict) == false);\n \n\
    string[string] dict2 = [\"STATE\": \"NC\", \"ZIP\": \"12345\"];\nassert(check_dict_case(dict2)\
    \ == true);\n \nstring[string] dict3 = [\"a\": \"apple\", \"b\": \"banana\"];\n\
    assert(check_dict_case(dict3) == true);\n \nstring[string] dict4 = [\"a\": \"\
    apple\", \"A\": \"banana\", \"B\": \"banana\"];\nassert(check_dict_case(dict4)\
    \ == false);\n \nstring[string] dict5 = [\"a\": \"apple\", 8L: \"banana\", \"\
    a\": \"apple\"];\nassert(check_dict_case(dict5) == false);\n \nstring[string]\
    \ dict6 = [];\nassert(check_dict_case(dict6) == false);", "{\n    bool result\
    \ = true;\n    bool is_upper = true;\n    bool is_lower = true;\n    if (dict\
    \ is null) return false;\n    foreach (key, value; dict) \n    {\n        if (is_lower\
    \ && islower(key[0])) \n        {\n            is_upper = false;\n        }\n\
    \        else if (is_upper && isupper(key[0])) \n        {\n            is_lower\
    \ = false;\n        }\n        else \n        {\n            result = false;\n\
    \            break;\n        }\n    }\n    return result;\n}", "{\n    if (dict\
    \ is null)\n        return false;\n    alias key_type = typeof(dict.keys[0]);\n\
    \    if (key_type != string)\n        return false;\n    bool is_lower = true;\n\
    \    for (string key; key = dict.keys.front; dict.keys.popFront())\n    {\n  \
    \      if (key.isUpper)\n        {\n            is_lower = false;\n          \
    \  break;\n        }\n    }\n    for (string key; key = dict.keys.front; dict.keys.popFront())\n\
    \    {\n        if (is_lower ? key.isUpper : key.isLower)\n            return\
    \ false;\n    }\n    return true;\n}", "{\n    return dict.length != 0 && dict.all!(x\
    \ => x.key.toLower == x.key || x.key.toUpper == x.key);\n}", "{\n    if (dict\
    \ is null) return false;\n    bool state = true;\n    if (dict.keys[0].toLower()\
    \ == dict.keys[0]) {\n        foreach (key; dict.keys) \n        {\n         \
    \   if (key.toLower() != key) \n            {\n                state = false;\n\
    \                break;\n            }\n        }\n    }\n    else if (dict.keys[0].toUpper()\
    \ == dict.keys[0]) \n    {\n        foreach (key; dict.keys) \n        {\n   \
    \         if (key.toUpper() != key) \n            {\n                state = false;\n\
    \                break;\n            }\n        }\n    }\n    else \n    {\n \
    \       state = false;\n    }\n    return state;\n}", "{\n    bool is_lower_case\
    \ = false;\n    bool is_upper_case = false;\n    foreach(k, v; dict) \n    {\n\
    \        if (is_lower(k))\n        {\n            is_lower_case = true;\n    \
    \    }\n        else if (is_upper(k))\n        {\n            is_upper_case =\
    \ true;\n        }\n        else\n        {\n            return false;\n     \
    \   }\n    }\n    return is_lower_case ^ is_upper_case;\n}", "{\n\tif (dict is\
    \ null)\n\t\treturn false;\n\tif (dict.length == 0)\n\t\treturn false;\n\tbool\
    \ is_upper = dict.byKey(\"a\").isNull;\n\tforeach (key, value; dict) \n\t{\n\t\
    \tif (key !is string)\n\t\t\treturn false;\n\t\tif (is_upper && key.toLower()\
    \ != key)\n\t\t\treturn false;\n\t\tif (!is_upper && key.toUpper() != key)\n\t\
    \t\treturn false;\n\t}\n\treturn true;\n}", "{\n    return dict is null ? false\
    \ : \n        dict.keys.all!((k) => k.toUpperInPlace() == k) || \n        dict.keys.all!((k)\
    \ => k.toLowerInPlace() == k);\n}", "{\n    if (dict is null)\n        return\
    \ false;\n    bool all_lower = false;\n    bool all_upper = false;\n    foreach\
    \ (k, v; dict)\n    {\n        if (!all_lower && k.isLower)\n            all_lower\
    \ = true;\n        else if (!all_upper && k.isUpper)\n            all_upper =\
    \ true;\n        else\n            return false;\n    }\n    return all_lower\
    \ || all_upper;\n}", "{\n    if (dict is null)\n        return false;\n    if\
    \ (dict.length == 0)\n        return false;\n    bool all_lower = true;\n    bool\
    \ all_upper = true;\n    foreach (k, v; dict)\n    {\n        all_lower = all_lower\
    \ && k.isLower;\n        all_upper = all_upper && k.isUpper;\n    }\n    return\
    \ all_lower || all_upper;\n}", "{\n    if (dict is null) \n    {\n        return\
    \ false;\n    }", "{\n    import std.math;\n    import std.algorithm;\n    import\
    \ std.ascii;\n    import std.typecons;\n    import std.array;\n    import std.range;\n\
    \    if (dict.isNull)\n        return false;\n    enum bool isUpper = true;\n\
    \    foreach (k; dict.get.keys) \n    {\n        if (!k.isUpper) \n        {\n\
    \            isUpper = false;\n            break;\n        }\n    }\n    return\
    \ isUpper || all!(isLower)(dict.get.keys);\n}", "{\n    if (dict is null) return\
    \ false;\n    auto haslower = false;\n    auto hasupper = false;\n    foreach\
    \ (k, _; dict) \n    {\n        if (k.length != 0) \n        {\n            if\
    \ (isUpper(k[0])) \n            {\n                hasupper = true;\n        \
    \    } \n            else \n            {\n                haslower = true;\n\
    \            }\n        }\n    }\n    return haslower.implies(!hasupper);\n}",
  "{\n    if (dict is null) return false;\n    bool lower = true;\n    bool upper\
    \ = true;\n    foreach (key; dict.keys)\n    {\n        lower = lower && (key\
    \ == toLower(key));\n        upper = upper && (key == toUpper(key));\n    }\n\
    \    return lower || upper;\n}", "{\n    /*\n    bool res = true;\n    foreach(k,\
    \ v; dict)\n    {\n        if(!k.isUpper) \n        {\n            res = false;\n\
    \            break;\n        }\n    }\n    return res;\n    */\n    bool is_key_upper\
    \ = true;\n    foreach(k, v; dict)\n    {\n        if(!k.isUpper)\n        {\n\
    \            is_key_upper = false;\n            break;\n        }\n    }\n   \
    \ if(is_key_upper) return true;\n    bool is_key_lower = true;\n    foreach(k,\
    \ v; dict)\n    {\n        if(!k.isLower)\n        {\n            is_key_lower\
    \ = false;\n            break;\n        }\n    }\n    return is_key_lower;\n}",
  "{\n\tif (dict.isNull) \n    {\n\t\treturn false;\n\t}\n\tbool hasLowercaseKey =\
    \ false;\n\tbool hasUppercaseKey = false;\n\tforeach (string key; dict.get) \n\
    \    {\n\t\tif (key.isUpper) \n        {\n\t\t\thasUppercaseKey = true;\n\t\t\
    }\n\t\telse if (key.isLower) \n        {\n\t\t\thasLowercaseKey = true;\n\t\t\
    }\n\t\telse \n        {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn hasLowercaseKey\
    \ != hasUppercaseKey;\n}", "    if (is(Nullable!(string[string]) == null)) \n\
    {\n    return dict is null;\n}", "{\n    return dict.count == 0 ? false : dict.keys().all!(key\
    \ => key.toLower == key || key.toUpper == key);\n}", "{\n    if(dict.isNull) return\
    \ false;\n    bool isLower = true;\n    string[] lower_dict;\n    string[] upper_dict;\n\
    \    foreach(k;dict.get.keys)\n    {\n        if(isLower)\n        {\n       \
    \     isLower = k.isLower;\n            if(isLower)\n            {\n         \
    \       lower_dict[k] = dict[k];\n            }\n            else\n          \
    \  {\n                upper_dict[k] = dict[k];\n            }\n        }\n   \
    \     else\n        {\n            if(!k.isUpper)\n            {\n           \
    \     return false;\n            }\n            upper_dict[k] = dict[k];\n   \
    \     }\n    }\n    return true;\n}", "{\n    bool upper = false;\n    bool lower\
    \ = false;\n    if (dict is null) \n    {\n        return false;\n    }\n    foreach\
    \ (k, v; dict) \n    {\n        if (k.isUpper)\n        {\n            upper =\
    \ true;\n        }\n        else if (k.isLower)\n        {\n            lower\
    \ = true;\n        }\n        else\n        {\n            return false;\n   \
    \     }\n    }\n    return upper ^ lower;\n}", "{\n    if (dict is null)\n   \
    \     return false;\n    if (dict.empty)\n        return false;\n    auto first_key\
    \ = dict.keys[0];\n    if (!first_key.isUpper)\n        return dict.keys.all!(e\
    \ => e.isLower);\n    return dict.keys.all!(e => e.isUpper);\n}", "{\n    return\
    \ dict.isNull ? false : lower(dict).keys.minElement == upper(dict).keys.minElement;\n\
    }", "{\n    foreach(dict.keys, k =>\n    {\n        if (dict.value.hasKey(k.toUpper()))\n\
    \            return false;\n    });\n    return true;\n}", "{\n    if (dict is\
    \ null) return false;\n    bool b1 = true;\n    bool b2 = true;\n    foreach (key;\
    \ dict.keys) \n    {\n        if (b1 && key.isUpperCase) continue;\n        if\
    \ (b2 && key.isLowerCase) continue;\n        b1 = false;\n        b2 = false;\n\
    \    }\n    return b1 || b2;\n}", "{\n    if (dict is null) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        auto lower_case = dict.all!((x) =>\
    \ to!string(x.key).isLower);\n        auto upper_case = dict.all!((x) => to!string(x.key).isUpper);\n\
    \        return lower_case || upper_case;\n    }\n}", "{\n    bool result = true;\n\
    \    bool keysAreUpper = false;\n    foreach(key, value; dict)\n    {\n      \
    \  if(isUpper(key[0]))\n        {\n            keysAreUpper = true;\n        \
    \    continue;\n        }\n        else if(isLower(key[0]))\n        {\n     \
    \       keysAreUpper = false;\n            continue;\n        }\n        else\n\
    \        {\n            result = false;\n            break;\n        }\n    }\n\
    \    if(!dict.isNull)\n    {\n        foreach(key, value; dict)\n        {\n \
    \           if(keysAreUpper && !isUpper(key[0]))\n            {\n            \
    \    result = false;\n                break;\n            }\n            else\
    \ if(!keysAreUpper && !isLower(key[0]))\n            {\n                result\
    \ = false;\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n\tif (dict is null)\n\t\treturn false;\n\t\n\tbool isUpper\
    \ = true;\n\tforeach (k, v; dict)\n\t{\n\t\tif (isUpper)\n\t\t{\n\t\t\tif (k[0]\
    \ !is 'A'..'Z')\n\t\t\t\tisUpper = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (k[0]\
    \ !is 'a'..'z')\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n \
    \   immutable string_keys = true;\n    immutable lower_keys = true;\n    if (dict\
    \ !is null) \n    {\n        foreach (key; dict.keys) \n        {\n          \
    \  if (typeid(key) != typeid(string)) \n            {\n                string_keys\
    \ = false;\n                break;\n            }\n            if (toLower(key)\
    \ != key) \n            {\n                lower_keys = false;\n             \
    \   break;\n            }\n        }\n    } \n    else \n    {\n        return\
    \ false;\n    }\n    return string_keys && lower_keys;\n}\n/*\n    Given a non-negative\
    \ integer in the form of an array of digits, \n    increment one to the integer\
    \ and return the result as an array of digits.\n    Example:\n    >>> increment_number([0])\n\
    \    [1]\n    >>> increment_number([0, 0])\n    [0, 1]\n    >>> increment_number([9,\
    \ 9])\n    [1, 0, 0]\n    >>> increment_number([4, 2, 5, 6, 9])\n    [4, 2, 5,\
    \ 7, 0]\n    >>> increment_number([5, 3, 1, 8, 2, 9, 9, 5, 4, 6, 9, 5, 2, 4, 9,\
    \ 1, 3, 6, 3, 4, 3, 6, 7, 8, 4, 1, 7, 5, 1, 1, 7, 8, 4, 7, 7, 1, 8, 8, 7, 5, 8,\
    \ 6, 7, 8, 3, 3, 3, 4, 1, 8, 7, 5, 3, 1, 3, 5, 4, 6, 7, 1, 8, 8, 7, 5, 8, 6, 7,\
    \ 8, 4, 6, 7, 5, 3, 3, 3, 4, 1, 8, 7, 5, 3, 1, 3, 5, 4, 6, 7, 1, 8, 8, 7, 5, 8,\
    \ 6, 7, 8, 4, 6, 7, 5, 3, 3, 3, 4, 1, 8, 7, 5, 3, 1, 3, 5, 4, 6, 7, 1, 8,", "{\n\
    \    if(dict.isNull)\n        return false;\n    \n    bool is_lower = false;\n\
    \    foreach(key, value; dict)\n    {\n        if(is(typeof(key)))\n        {\n\
    \            if(key.isUpperCase)\n                is_lower = false;\n        \
    \    else if(key.isLowerCase)\n                is_lower = true;\n            else\n\
    \                return false;\n        }\n        else\n            return false;\n\
    \    }\n    return true;\n}", "{\n    if(dict is null)\n        return false;\n\
    \    \n    string[string] Dict = dict;\n    if(Dict.empty)\n        return false;\n\
    \    \n    bool allLower = true;\n    bool allUpper = true;\n    foreach(key;\
    \ Dict.keys) \n    {\n        if(key.isLower)\n            allUpper = false;\n\
    \        else if(key.isUpper)\n            allLower = false;\n        else\n \
    \           return false;\n    }\n    return allLower || allUpper;\n}\n/*\n  \
    \  Given a string containing a domain name, return a tuple containing the \n \
    \   organization and the top-level domain.\n    Examples:\n    >>> get_org_and_tld(\"\
    google.com\")\n    (\"google\", \"com\")\n    >>> get_org_and_tld(\"google.co.uk\"\
    )\n    (\"google\", \"co.uk\")\n    >>> get_org_and_tld(\"google.co.in\")\n  \
    \  (\"google\", \"co.in\")\n    >>> get_org_and_tld(\"google.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co",
  "{\n    if(dict is null)\n        return false;\n    string[string] lower_dict =\
    \ [ \"a\": \"apple\", \"b\": \"banana\"];\n    string[string] upper_dict = [ \"\
    STATE\": \"NC\", \"ZIP\": \"12345\"];\n    int lower = 0;\n    int upper = 0;\n\
    \    foreach(key; dict.keys)\n    {\n        if(key in lower_dict)\n         \
    \   lower += 1;\n        if(key in upper_dict)\n            upper += 1;\n    }\n\
    \    return (lower == dict.length) || (upper == dict.length);\n}", "{\n    if(dict\
    \ is null)\n        return false;\n    if(dict.length == 0)\n        return false;\n\
    \    return dict.keys.array.all!(isUpper) || dict.keys.array.all!(isLower);\n}",
  "{\n    if (dict is null) return false;\n    ulong upper = 0, lower = 0;\n    foreach\
    \ (k, v; dict) \n    {\n        if (k is string) \n        {\n            if (k.toUpper()\
    \ == k)\n                upper++;\n            else if (k.toLower() == k)\n  \
    \              lower++;\n            else\n                return false;\n   \
    \     }\n        else\n            return false;\n    }\n    return (upper * lower\
    \ == 0);\n}", "{\n    import std.algorithm.comparison: equal;\n    import std.algorithm.mutation:\
    \ all;\n    import std.array : array;\n    import std.conv: to;\n    import std.exception:\
    \ enforce;\n    import std.range: all, takeExactly;\n    import std.string: toLower,\
    \ toUpper;\n    import std.typecons: Tuple;\n    import std.typecons: Nullable;\n\
    \    import std.traits: isString;\n    import std.algorithm.sorting: sort;\n \
    \   import std.traits: isNumeric;\n    import std.array: iota;\n    import std.math:\
    \ isInfinity, isNaN;\n    import std.conv: to;\n    import std.array: sort;\n\
    \    if (dict is null)\n    {\n        return false;\n    }\n    if (dict.empty)\n\
    \    {\n        return false;\n    }\n    foreach (key, value; dict)\n    {\n\
    \        if (!is(typeof(key) == string))\n        {\n            return false;\n\
    \        }\n    }\n    if (equal(\n        dict.keys.map!(k => k.toLower()).array,\
    \ \n        dict.keys.map!(k => k.toUpper()).array))\n    {\n        return true;\n\
    \    }\n    return false;\n}", "{\n    if (dict.isNull) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        bool upper;\n        if(dict.get.keys[0].toUpper()\
    \ == dict.get.keys[0])\n        {\n            upper = true;\n        }\n    \
    \    else if(dict.get.keys[0].toLower() == dict.get.keys[0])\n        {\n    \
    \        upper = false;\n        }\n        else\n        {\n            return\
    \ false;\n        }\n        foreach(Key; dict.get.keys)\n        {\n        \
    \    if(upper && Key.toUpper() != Key)\n            {\n                return\
    \ false;\n            }\n            else if(!upper && Key.toLower() != Key)\n\
    \            {\n                return false;\n            }\n        }\n    \
    \    return true;\n    }\n}", "{\n    bool _ = (dict == null);\n    if(_)\n  \
    \      return false;\n    bool result = true;\n    foreach(key; dict.keys)\n \
    \   {\n        auto temp = dict[key];\n        if(key.length != 0 && key.toUpper.length\
    \ == 0 && key.toLower.length == 0)\n        {\n            result = false;\n \
    \           break;\n        }\n    }\n    return result;\n}", "{\n    if(null\
    \ == dict) return false;\n    bool upper = true;\n    foreach(key; dict.keys)\n\
    \    {\n        if(upper)\n        {\n            if(!isUpperAlpha(key[0]))\n\
    \            {\n                upper = false;\n            }\n        }\n   \
    \     else\n        {\n            if(!isLowerAlpha(key[0]))\n            {\n\
    \                return false;\n            }\n        }\n    }\n    return true;\n\
    }", "in {\n    assert(dict.isValid && dict !is null);\n} \nbody {\n    bool lower\
    \ = true;\n    bool upper = true;\n    foreach(key; dict.get.keys) {\n       \
    \ lower = lower && key.isLower;\n        upper = upper && key.isUpper;\n    }\n\
    \    return lower || upper;\n}", "{\n    if (dict is null) return false;\n   \
    \ if (dict.keys.empty) return false;\n    bool found_upper = false;\n    bool\
    \ found_lower = false;\n    foreach (k; dict.keys)\n    {\n        if (k.length\
    \ == 0) return false;\n        if (found_upper) \n        {\n            if (k[0].isLower)\
    \ return false;\n        }\n        else if (found_lower)\n        {\n       \
    \     if (k[0].isUpper) return false;\n        }\n        else\n        {\n  \
    \          if (k[0].isUpper) found_upper = true;\n            else if (k[0].isLower)\
    \ found_lower = true;\n            else return false;\n        }\n    }\n    return\
    \ true;\n}", "{\n    if (dict.isNull) \n    {\n        return false;\n    }\n\
    \    foreach (k, v; dict) \n    {\n        int index = 0;\n        foreach (c;\
    \ k) \n        {\n            if (c.isUpper) \n            {\n               \
    \ index++;\n            }\n        }\n        if (index == 0 || index == k.length)\
    \ \n        {\n            continue;\n        }\n        return false;\n    }\n\
    \    return true;\n}", "in\n{\n  assert(false, \"Unimplemented\");\n}", "{\n \
    \   if (dict is null) \n    {\n        return false;\n    }\n    string[] keys\
    \ = dict.keys;\n    bool all_upper = true;\n    bool all_lower = true;\n    foreach\
    \ (key; keys) \n    {\n        all_upper = all_upper && key.isUpperCase;\n   \
    \     all_lower = all_lower && key.isLowerCase;\n    }\n    return all_upper ||\
    \ all_lower;\n}", "{\n    if (dict is null)\n        return false;\n    enum hasLower\
    \ = false;\n    enum hasUpper = false;\n    foreach (key; dict.keys)\n    {\n\
    \        if (is(typeof(key) == string))\n        {\n            if (std.string.isupper(key))\n\
    \                hasUpper = true;\n            else if (std.string.islower(key))\n\
    \                hasLower = true;\n            else\n                return false;\n\
    \        }\n        else\n            return false;\n    }\n    return hasLower\
    \ == hasUpper;\n}", "{\n    alias KeyType = typeof(dict.keys[0]);\n    return\
    \ dict.keys.all!(key => is(KeyType == string) && \n                          \
    \       is(key == toLower(key) || \n                                    key ==\
    \ toUpper(key)));\n}", "{\n    bool is_all_keys_lowercase = true;\n    bool is_all_keys_uppercase\
    \ = true;\n    if (dict is null) return false;\n    // loop over each pair of\
    \ the dictionary\n    foreach (kvp; dict) \n    {\n        // islower and isupper\
    \ return true if all characters of the string are\n        // lower and upper\
    \ case respectively, else they return false\n        is_all_keys_lowercase &=\
    \ kvp.key.islower;\n        is_all_keys_uppercase &= kvp.key.isupper;\n    }\n\
    \    return is_all_keys_lowercase || is_all_keys_uppercase;\n}", "{\n    if (dict\
    \ is null) return false;\n    string[string] lowerDict;\n    string[string] upperDict;\n\
    \    foreach (k, v; dict) \n    {\n        if (k is string) \n        {\n    \
    \        if (k.isUpper) \n            {\n                upperDict[k] = v;\n \
    \           } \n            else \n            {\n                lowerDict[k]\
    \ = v;\n            }\n        } \n        else \n        {\n            return\
    \ false;\n        }\n    }\n    return lowerDict.length == 0 || upperDict.length\
    \ == 0;\n}", "{\n    if (dict is null) \n    {\n        return false;\n    }",
  "{\n    if(!dict)\n        return false;\n    enum bool all_upper = true;\n    enum\
    \ bool all_lower = true;\n    if(dict.length == 0)\n        return false;\n  \
    \  foreach(string key; dict.keys)\n    {\n        //if key is not all lower case\
    \ set all_lower to false\n        if(key.toLower() != key)\n            all_lower\
    \ = false;\n        //if key is not all upper case set all_upper to false\n  \
    \      if(key.toUpper() != key)\n            all_upper = false;\n    }\n    return\
    \ all_lower || all_upper;\n}", "{\n    // your code here\n    return false;\n}",
  "{\n    if(dict is null) return false;\n    if(dict.length < 1) return false;\n\
    \    int? lower_keys_count;\n    int? upper_keys_count;\n    foreach(key; dict.keys)\n\
    \    {\n        if(key.length > 0)\n        {\n            // if the first letter\
    \ is lowercase increment lower count\n            if(!lower_keys_count.isNull\
    \ && lower_keys_count.get < 1)\n            {\n                lower_keys_count\
    \ = 0;\n            }\n            if(!upper_keys_count.isNull && upper_keys_count.get\
    \ < 1)\n            {\n                upper_keys_count = 0;\n            }\n\
    \            if(!upper_keys_count.isNull && !lower_keys_count.isNull)\n      \
    \      {\n                break;\n            }\n            if(key[0].isUpper)\n\
    \            {\n                upper_keys_count++;\n            }\n         \
    \   else\n            {\n                lower_keys_count++;\n            }\n\
    \        }\n    }\n    return upper_keys_count is null || lower_keys_count is\
    \ null ||\n    upper_keys_count == lower_keys_count;\n}", "{\n    if(dict.isNull)\n\
    \        return false;\n    bool isLower = true;\n    bool isUpper = true;\n \
    \   foreach(index, value; dict)\n    {\n        isLower = isLower && toLower(index)\
    \ == index;\n        isUpper = isUpper && toUpper(index) == index;\n    }\n  \
    \  return isLower || isUpper;\n}", "{\n    if (dict is null) return false;\n \
    \   bool all_lower_case = true;\n    bool all_upper_case = true;\n    foreach\
    \ (i, key; dict.keys)\n    {\n        if (all_lower_case)\n        {\n       \
    \     if (key != key.toLower) all_lower_case = false;\n        }\n        if (all_upper_case)\n\
    \        {\n            if (key != key.toUpper) all_upper_case = false;\n    \
    \    }\n        if (!all_lower_case && !all_upper_case) return false;\n    }\n\
    \    return true;\n}", "{\n    auto lower = true;\n    auto upper = true;\n  \
    \  foreach(key; dict.keys)\n    {\n        if (isLower(key[0]))\n        {\n \
    \           upper = false;\n        }\n        else if (isUpper(key[0]))\n   \
    \     {\n            lower = false;\n        }\n        else\n        {\n    \
    \        return false;\n        }\n    }\n    return lower || upper;\n}", "{\n\
    \    \n}", "{\n    if (dict is null)\n        return false;\n    foreach (key,\
    \ value; dict)\n    {\n        if (!is(typeof(key) == string))\n            return\
    \ false;\n        if (key == toUpper(key))\n            return dict.all!(a =>\
    \ a.key == toUpper(a.key));\n        else if (key == toLower(key))\n         \
    \   return dict.all!(a => a.key == toLower(a.key));\n        else\n          \
    \  return false;\n    }\n    return true;\n}", "{\n    if (dict is null) \n  \
    \  {\n        return false;\n    }\n    bool all_lowercase = false;\n    bool\
    \ all_uppercase = false;\n    foreach (string key; dict.keys) \n    {\n      \
    \  if (key.length == 0) \n        {\n            return false;\n        }\n  \
    \      if (key.isAllLower) \n        {\n            all_lowercase = true;\n  \
    \      }\n        else if (key.isAllUpper) \n        {\n            all_uppercase\
    \ = true;\n        }\n        else \n        {\n            return false;\n  \
    \      }\n    }\n    return all_lowercase || all_uppercase;\n}", "{\n    if(dict.isNull)\
    \ return false;\n    int count = 0;\n    foreach(key, value; dict)\n    {\n  \
    \      if(key.isEmpty) return false;\n        count += key.length;\n    }\n  \
    \  return count % 2 == 0;\n}", "{\n    \n    bool is_all_lower_case(string[string]\
    \ dict) {\n        foreach(key; dict.keys)\n            if(key != key.toLower)\n\
    \                return false;\n        return true;\n    }\n    \n    bool is_all_upper_case(string[string]\
    \ dict) {\n        foreach(key; dict.keys)\n            if(key != key.toUpper)\n\
    \                return false;\n        return true;\n    }\n    \n    if(dict.isNull)\n\
    \        return false;\n    else\n        return is_all_lower_case(dict) || is_all_upper_case(dict);\n\
    }", "{\n    // we assume that nullable is not null\n    assert(dict.isInitialized);\n\
    \    bool is_lower = dict.value.keys.front.isAllLower;\n    bool is_upper = dict.value.keys.front.isAllUpper;\n\
    \    foreach(key; dict.value.keys)\n    {\n        if (key.isAllLower != is_lower\
    \ && key.isAllUpper != is_upper)\n        {\n            return false;\n     \
    \   }\n    }\n    return true;\n}", "{\n    if(dict is null) \n    {\n       \
    \ return false;\n    }\n    if(dict.empty) \n    {\n        return false;\n  \
    \  }\n    foreach(key, value; dict) \n    {\n        import std.algorithm : map;\n\
    \        auto lowerkey = key.map!(a => a.toLower()).array.toStringz();\n     \
    \   auto upperkey = key.map!(a => a.toUpper()).array.toStringz();\n        if(key\
    \ == lowerkey) \n        {\n            continue;\n        }\n        else if(key\
    \ == upperkey) \n        {\n            continue;\n        }\n        else \n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}",
  "    if (isNullable!(dict))\n{\n    return dict.isNull\n        ? false\n      \
    \  : dict.get.all!(key => key.isUpper)\n        || dict.get.all!(key => key.isLower);\n\
    }", "{\n    if (dict.isNull) \n    {\n        return false;\n    }\n    if (dict.isNull\
    \ || dict.length == 0) \n    {\n        return false;\n    }\n    bool lower =\
    \ false;\n    bool upper = false;\n    foreach (key, value; dict) \n    {\n  \
    \      if (key.isUpperCase) \n        {\n            upper = true;\n        }\
    \ \n        else if (key.isLowerCase) \n        {\n            lower = true;\n\
    \        } \n        else \n        {\n            return false;\n        }\n\
    \    }\n    return (lower && !upper) || (!lower && upper);\n}", "{\n    bool upperCase\
    \ = true;\n    bool lowerCase = true;\n    foreach(k, v; dict)\n    {\n      \
    \  if (isUpper(k[0]))\n        {\n            lowerCase = false;\n        } else\
    \ if (isLower(k[0]))\n        {\n            upperCase = false;\n        } else\n\
    \        {\n            return false;\n        }\n    }\n    return lowerCase\
    \ || upperCase;\n}", "{\n    if (dict is null) \n    {\n        return false;\n\
    \    }\n    if (dict.keys.length == 0) \n    {\n        return false;\n    }\n\
    \    bool result;\n    if (dict.keys[0].isUpperCase) \n    {\n        result =\
    \ dict.keys.all!(e => e.isUpperCase);\n    } \n    else \n    {\n        result\
    \ = dict.keys.all!(e => e.isLowerCase);\n    }\n    return result;\n}", "{\n \
    \   if (dict is null)\n        return false;\n    if (dict.length == 0)\n    \
    \    return false;\n    bool is_all_lower = false;\n    foreach (key; dict.keys)\
    \ \n    {\n        if (key.length == 0)\n            return false;\n        if\
    \ (is_all_lower) \n        {\n            if (key != key.toLower)\n          \
    \      return false;\n        }\n        else \n        {\n            if (key\
    \ != key.toUpper)\n                return false;\n            is_all_lower = true;\n\
    \        }\n    }\n    return true;\n}\n/*\n    Given an associative array, return\
    \ an associative array with all strings \n    in lower case.\n    The function\
    \ should return an empty associative array is the given associative array is empty.\n\
    \    Examples:\n    >>> [\"a\": \"apple\", \"b\": \"banana\"].lower_case\n   \
    \ [\"a\": \"apple\", \"b\": \"banana\"]\n    >>> [\"Name\": \"John\", \"Age\"\
    : \"36\", \"City\": \"Houston\"].lower_case\n    [\"name\": \"John\", \"age\"\
    : \"36\", \"city\": \"Houston\"]\n    >>> [\"State\": \"NC\", \"ZIP\": \"12345\"\
    ].lower_case\n    [\"state\": \"NC\", \"zip\": \"12345\"]\n    >>> [].lower_case\n\
    \    []\n    >>> [1 : \"apple\", \"b\": \"banana\"].lower_case\n    [1 : \"apple\"\
    , \"b\": \"banana\"]\n*/\nstring[string] lower_case(string[string] dict)\n{\n\
    \    string[string] res;\n    foreach (key, value; dict)\n        res[key.toLower]\
    \ = value;\n    return res;\n}\n/*\n    Given an associative array, return an\
    \ associative array with all strings \n    in upper case.\n    The function should\
    \ return an empty associative array is the given associative array is empty.\n\
    \    Examples:\n    >>> [\"a\": \"apple\", \"b\": \"banana\"].upper_case\n   \
    \ [\"A\": \"apple\", \"B\": \"banana\"]\n    >>> [\"Name\": \"John\",", "{\n \
    \   bool lower_case, upper_case;\n    if (dict is null) return false;\n    if\
    \ (dict.empty) return false;\n    foreach (key; dict.keys) \n    {\n        if\
    \ (is(typeof(key) : string)) \n        {\n            lower_case = (key.toLower\
    \ == key);\n            upper_case = (key.toUpper == key);\n            if (lower_case\
    \ && upper_case) return false;\n        } \n        else \n        {\n       \
    \     return false;\n        }\n    }\n    return true;\n}", "{\n    auto ret\
    \ = true;\n    if(dict.isNull) return ret;\n    dict.each!(x => { \n        if(ret)\
    \ {\n            ret = x.key.isUpperCase || x.key.isLowerCase;\n        }\n  \
    \  });\n    return ret;\n}\n/*\n    Given a list of strings, return true if every\
    \ string is lower case.\n    >>> is_lower_case([\"abc\", \"abcde\", \"abcdefg\"\
    ])\n    true\n    >>> is_lower_case([\"abc\", \"abCde\", \"abcdefg\"])\n    false\n\
    \    >>> is_lower_case([\"ABC\", \"ABCDE\", \"ABCDEFG\"])\n    false\n    >>>\
    \ is_lower_case([\"abc\", \"DEF\", \"GHI\"])\n    false\n    >>> is_lower_case([\"\
    abc\", \"def\", \"ghi\"])\n    true\n    >>> is_lower_case([\"aBc\", \"Def\",\
    \ \"Ghi\"])\n    false\n*/", "{\n    if (dict is null) \n    {\n        return\
    \ false;\n    }\n    size_t lower = 0;\n    size_t upper = 0;\n    foreach (key;\
    \ dict.keys) \n    {\n        if (isUpper(key[0])) \n        {\n            upper++;\n\
    \        }\n        else if (isLower(key[0])) \n        {\n            lower++;\n\
    \        }\n        else \n        {\n            return false;\n        }\n \
    \   }\n    return (lower == 0 || upper == 0);\n}\n/*\n    Given a list of strings,\
    \ check if all strings have the same length.\n    If the list is empty, return\
    \ true.\n    Examples:\n    >>> check_same_length([\"code\", \"bug\"].nullable)\n\
    \    true\n    >>> check_same_length([\"code\", \"bug\", \"code\"].nullable)\n\
    \    true\n    >>> check_same_length([\"code\", \"bug\", \"code\", \"buggy\"].nullable)\n\
    \    false\n    >>> check_same_length([\"code\", \"bug\", \"code\", \"buggy\"\
    , \"testing\"].nullable)\n    false\n    >>> check_same_length([\"code\", \"bug\"\
    , \"code\", \"buggy\", \"testing\", \"bug\"].nullable)\n    false\n    >>> check_same_length([\"\
    code\", \"bug\", \"code\", \"buggy\", \"testing\", \"bug\", \"code\"].nullable)\n\
    \    false\n    >>> check_same_length([\"code\", \"bug\", \"code\", \"buggy\"\
    , \"testing\", \"bug\", \"code\", \"testing\"].nullable)\n    false\n    >>> check_same_length([\"\
    code\", \"bug\", \"code\", \"buggy\", \"testing\", \"bug\", \"code\", \"testing\"\
    , \"code\"].nullable)\n    false\n    >>> check_same_length([\"code\", \"bug\"\
    , \"code\", \"buggy\", \"testing\", \"bug\", \"code\", \"testing\", \"code\",\
    \ \"bug\"].nullable)\n    false\n    >>> check_same_length([\"code\", \"bug\"\
    , \"code\", \"buggy\", \"testing\", \"bug\", \"code", "{\n    if (dict is null)\
    \ return false;\n    if (dict.length == 0) return false;\n    auto lower = 0,\
    \ upper = 0;\n    foreach (key; dict.keys) \n    {\n        if (is_upper(key[0]))\
    \ upper++;\n        else if (is_lower(key[0])) lower++;\n    }\n    return lower\
    \ == 0 || upper == 0;\n}\n/*\n    Given a non-empty associative array, return\
    \ an array containing \n    the keys in sorted order.\n    The function should\
    \ return null if the given associative array is empty.\n    Examples:\n    >>>\
    \ sort_dict_keys([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    [\"a\",\
    \ \"b\"]\n    >>> sort_dict_keys([\"a\": \"apple\", \"A\": \"banana\", \"B\":\
    \ \"banana\"].nullable)\n    [\"A\", \"B\", \"a\"]\n    >>> sort_dict_keys([\"\
    a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    [8L, \"a\"]\n\
    \    >>> sort_dict_keys([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable)\n    [\"Age\", \"City\", \"Name\"]\n    >>> sort_dict_keys([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable)\n    [\"STATE\", \"ZIP\"]\n*/\nNullable!(string[])\
    \ sort_dict_keys(Nullable!(string[string]) dict) \n{\n    if (dict is null) return\
    \ null;\n    return dict.keys.sort();\n}\n/*\n    Given a non-empty associative\
    \ array, return an array containing \n    the values in sorted order.\n    The\
    \ function should return null if the given associative array is empty.\n    Examples:\n\
    \    >>> sort_dict_values([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n  \
    \  [\"apple\", \"banana\"]\n    >>> sort_dict_values([\"a\": \"apple\", \"A\"\
    : \"banana\", \"B\": \"banana\"].nullable)\n    [\"apple\",", "{\n    if (dict\
    \ is null) return false;\n    if (dict.empty) return false;\n    auto firstKey\
    \ = dict.keys.front;\n    if (!is(typeof(firstKey) == string))\n        return\
    \ false;\n    auto letter = firstKey[0];\n    return dict.keys.all!(k => k[0]\
    \ == letter);\n}", "{\n    return false;\n}", "    if (is(typeof(dict) == Nullable!(string[string])))\n\
    {\n    enum key_type = KeyType.NONE;\n    foreach (key, value; dict) {\n     \
    \   KeyType currentKeyType = key_type.getKeyType(key);\n        if (key_type ==\
    \ KeyType.NONE) {\n            key_type = currentKeyType;\n        } else if (key_type\
    \ != currentKeyType) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}", "{\n    if (dict is null)\n        return false;\n    return dict.keys.all!(x\
    \ => x.isUpper) || dict.keys.all!(x => x.isLower);\n}", "{\n    bool all_lower\
    \ = true;\n    bool all_upper = true;\n    if (dict is null) return false;\n \
    \   foreach (k,v; dict)\n    {\n        if (k.length > 0)\n        {\n       \
    \     if (isLower(k[0])) all_upper = false;\n            if (isUpper(k[0])) all_lower\
    \ = false;\n        }\n    }\n    return all_lower || all_upper;\n}", "{\n   \
    \ bool lower = true;\n    foreach(key; dict.keys)\n    {\n        if(!is(typeof(key)\
    \ == string))\n            return false;\n        bool isLower = key.isLower();\n\
    \        if(lower && !isLower)\n            lower = false;\n        else if(!lower\
    \ && isLower)\n            return false;\n    }\n    return true;\n}", "{\n  \
    \  if (dict.isNull) \n    {\n        return false;\n    }\n    immutable int lowerCount\
    \ = 0;\n    immutable int upperCount = 0;\n    foreach (item; dict.get) \n   \
    \ {\n        if (std.string.isLower(item.key)) \n        {\n            lowerCount++;\n\
    \        }\n        else if (std.string.isUpper(item.key)) \n        {\n     \
    \       upperCount++;\n        }\n        else \n        {\n            return\
    \ false;\n        }\n    }\n    return lowerCount == dict.get.length || upperCount\
    \ == dict.get.length;\n}", "{\n    foreach(key, value; dict) \n    {\n       \
    \ if(!is(typeof(key) == string) || (isLower(key) && isUpper(key))) \n        {\n\
    \            return false;\n        }\n    }\n    return true;\n}", "{\n    bool\
    \ allUpperCase = true;\n    bool allLowerCase = true;\n    foreach(key; dict.keys)\n\
    \    {\n        if(isUpper(key[0])) allLowerCase = false;\n        if(isLower(key[0]))\
    \ allUpperCase = false;\n    }\n    return allUpperCase || allLowerCase;\n}",
  "{\n    /*\n    if (dict.isNull) \n    {\n        return false;\n    }\n    */\n\
    \    if (dict.isNull || dict.isEmpty) \n    {\n        return false;\n    }\n\
    \    bool hasLower = false;\n    bool hasUpper = false;\n    foreach (key, val;\
    \ dict) \n    {\n        foreach (ch; key) \n        {\n            if (isUpper(ch))\
    \ \n            {\n                hasUpper = true;\n            }\n         \
    \   else if (isLower(ch)) \n            {\n                hasLower = true;\n\
    \            }\n            else \n            {\n                return false;\n\
    \            }\n        }\n    }\n    return hasLower == hasUpper;\n}", "{\n \
    \   return dict !is null && dict.all!(k => k.length == 0 || k[0].isLower || k[0].isUpper);\n\
    }", "in\n{\n    assert(dict.isNull);\n}\nout(result)\n{\n    assert(result ==\
    \ true || result == false);\n}\nbody\n{\n    if (dict.isNull) \n    {\n      \
    \  return false;\n    }\n    else\n    {\n        string[string] d = dict.get!string[string]();\n\
    \        int lower = 0;\n        int upper = 0;\n        foreach (string k; d.keys)\n\
    \        {\n            if (k.length > 0)\n            {\n                if (k[0].isLower)\n\
    \                {\n                    lower++;\n                }\n        \
    \        else if (k[0].isUpper)\n                {\n                    upper++;\n\
    \                }\n                else\n                {\n                \
    \    return false;\n                }\n            }\n        }\n        return\
    \ (lower == 0 || upper == 0);\n    }\n}", "{\n    if (dict is null)\n        return\
    \ false;\n    bool result = true;\n    foreach (string key; dict.keys)\n    {\n\
    \        result = result && key.length == 1 && key.equal_case_insensitive(\"a\"\
    );\n    }\n    return result;\n}", "{\n    if (dict is null) return false;\n \
    \   auto s = dict.keys.all!(s => s.toLower() == s);\n    auto b = dict.keys.all!(s\
    \ => s.toUpper() == s);\n    return s || b;\n}", "{\n    string dummy;\n    if\
    \ (dict.isNull) \n    {\n        return false;\n    } \n    else if (dict.get.keys.length\
    \ == 0) \n    {\n        return false;\n    }\n    else if (dict.get.keys[0].isLower(dummy))\
    \ \n    {\n        return dict.get.keys.all!(x => x.isLower(dummy));\n    } \n\
    \    else if (dict.get.keys[0].isUpper(dummy)) \n    {\n        return dict.get.keys.all!(x\
    \ => x.isUpper(dummy));\n    }\n    else \n    {\n        return false;\n    }\n\
    }", "{\n    if (dict is null)\n        return false;\n    bool upper = true;\n\
    \    bool lower = true;\n    foreach (key; dict.keys) \n    {\n        if (!isUpper(key))\n\
    \            upper = false;\n        if (!isLower(key))\n            lower = false;\n\
    \    }\n    return upper || lower;\n}\n/*\n    * For example: given the following\
    \ lists of fruit, output their combined \n    total weight in kilograms, rounded\
    \ to the nearest whole number.\n    >>> list_sum([\"apple\": 5.0, \"banana\":\
    \ 5.5, \"pear\": 1.5], [\"apple\": 1.0, \"banana\": 2.0, \"grape\": 6.0])\n  \
    \  20.0\n    >>> list_sum([\"apple\": 5.0, \"banana\": 5.5, \"pear\": 1.5], [])\n\
    \    12.0\n    >>> list_sum([], [\"apple\": 1.0, \"banana\": 2.0, \"grape\": 6.0])\n\
    \    9.0\n    >>> list_sum([], [])\n    0.0\n*/\ndouble list_sum(string[double]\
    \ fruit1, string[double] fruit2) \n{\n    double total = 0.0;\n    // 1. Combine\
    \ the two lists. If a key is present in both lists, sum the values.\n    // fruit1\n\
    \    foreach (fruit; fruit1.keys) \n    {\n        total += fruit1[fruit];\n \
    \   }\n    // fruit2\n    foreach (fruit; fruit2.keys) \n    {\n        if (fruit1.find(fruit)\
    \ !is null)\n            total += fruit2[fruit];\n        else\n            total\
    \ += fruit2[fruit];\n    }\n    return total;\n}\n/*\n    2. Given a list of pairs\
    \ of a fruit name, weight in kilograms and its price per kilogram in USD, \n \
    \   return the total price of the list rounded to the nearest cent.\n    >>> list_price([\"\
    apple\": tuple(1.0, 2.0), \"banana\": tuple(2.0, 1.5), \"pear\": tuple(0.75, 4",
  "{\n    \n    if (dict is null) \n    {\n        return false;\n    }\n    foreach\
    \ (key, value; dict) \n    {\n        if (!is(typeof(key) == string)) \n     \
    \   {\n            return false;\n        }\n        // Save the case of the first\
    \ key\n        if (dict.keys.length == 1) \n        {\n            if (isLowerCase(key))\
    \ \n            {\n                // If the first key is lower, return true if\
    \ all following \n                // keys are lower\n                return dict.keys.all!(isLowerCase);\n\
    \            }\n            if (isUpperCase(key)) \n            {\n          \
    \      // If the first key is upper, return true if all following \n         \
    \       // keys are upper\n                return dict.keys.all!(isUpperCase);\n\
    \            }\n        }\n    }\n}", "{\n    auto case_checker = (d) => \n  \
    \  {\n        auto keys = d.keys;\n        int upper = 0;\n        int lower =\
    \ 0;\n        foreach(key; keys) \n        {\n            if(key.isUpperCase)\n\
    \                upper++;\n            else if(key.isLowerCase)\n            \
    \    lower++;\n        }\n        return (upper > 0 && lower == 0) || (lower >\
    \ 0 && upper == 0);\n    };\n    return dict.isNull || case_checker(dict);\n}\n\
    /*\n    Given a string, return the first character in the string that has not\
    \ \n    repeated again. For example, given the string \"abacabde\", the function\
    \ \n    should return 'e'.\n*/\nstring find_non_repeating_char(string str) \n\
    {\n    auto arr = str.chars;\n    foreach(ch; arr) \n    {\n        if(str.count(ch)\
    \ == 1)\n            return ch.to!string;\n    }\n    return \"\";\n}\n/*\n  \
    \  Given a string and a list of words, return all the words that contain \n  \
    \  the string as a substring. The words can be in any order.\n*/\nstring[] find_words_with_str(string\
    \ s, string[] words) \n{\n    string[] res;\n    foreach(word; words) \n    {\n\
    \        if(word.contains(s))\n            res ~= word;\n    }\n    return res;\n\
    }\n/*\n    Given a list of tuples, return the third item in each tuple.\n*/",
  "{\n    import std.typecons : tuple;\n    import std.array : empty;\n    if (dict\
    \ is null || dict.empty) \n    {\n        return false;\n    }", "{\n    return\
    \ dict.isNull ? false : dict.get().all!(e => is(typeof(e.key) == string) && e.key.toLower()\
    \ == e.key);\n}", "{\n    import std.algorithm;\n    import std.algorithm.comparison;\n\
    \    import std.ascii;\n    import std.conv;\n    import std.range;\n    import\
    \ std.traits;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    return dict.fold!(false)((bool\
    \ s, string[string] d) => \n    s && d.byKey.map!(key => key.to!string).equal(\n\
    \    d.byKey.map!(key => key.to!string).toUpper()));\n}", "in { \n    assert(dict\
    \ !is null);\n} \nbody {\n    foreach(key; dict.keys) {\n        if (key !is string)\
    \ {\n            return false;\n        }\n    }\n    bool lower_case = false;\n\
    \    bool upper_case = false;\n    foreach(key; dict.keys) {\n        if (key.toLower\
    \ == key) {\n            lower_case = true;\n        }\n        if (key.toUpper\
    \ == key) {\n            upper_case = true;\n        }\n    }\n    return lower_case\
    \ && !upper_case || !lower_case && upper_case;\n}", "{\n    //! dshorthand\n \
    \   if (dict is null) return false;\n    bool lower = true;\n    bool upper =\
    \ true;\n    foreach (value; dict) \n    {\n        if (!is(typeof(value.key)\
    \ == string)) \n        {\n            return false;\n        }\n        lower\
    \ = lower && value.key.toLower() == value.key;\n        upper = upper && value.key.toUpper()\
    \ == value.key;\n    }\n    return lower || upper;\n}", "{\n    bool u = true;\n\
    \    bool l = true;\n    foreach(string k, string v; dict)\n    {\n        if\
    \ (isLower(k))\n            u = false;\n        else if (isUpper(k))\n       \
    \     l = false;\n        else\n            return false;\n    }\n    return u\
    \ || l;\n}", "{\n    if (dict is null)\n        return false;\n    if (dict.length\
    \ == 0)\n        return false;\n    auto keys = dict.keys;\n    if (keys.length\
    \ == 0)\n        return false;\n    auto string_keys = keys.filter!(k => k is\
    \ string).map!(k => cast(string)k);\n    auto lower_keys = string_keys.filter!(k\
    \ => k.toLower == k);\n    auto upper_keys = string_keys.filter!(k => k.toUpper\
    \ == k);\n    if (lower_keys.length > 0 && upper_keys.length > 0)\n        return\
    \ false;\n    return true;\n}\n ", "{\n    if (dict is null) return false;\n \
    \   if (dict.empty) return false;\n    int lower_case_keys = 0;\n    int upper_case_keys\
    \ = 0;\n    foreach (key; dict.keys)\n    {\n        if (key.toUpper() == key)\n\
    \        {\n            upper_case_keys += 1;\n        }\n        else if (key.toLower()\
    \ == key)\n        {\n            lower_case_keys += 1;\n        }\n        else\n\
    \        {\n            return false;\n        }\n    }\n    return ((lower_case_keys\
    \ != 0) == (upper_case_keys != 0));\n}", "nothrow @safe pure \n{\n    if (dict\
    \ is null) return false;\n    if (dict.length == 0) return false;\n    bool all_lower\
    \ = true;\n    bool all_upper = true;\n    auto it = dict.byKey.walk;\n    while(it.moveNext())\n\
    \    {\n        auto pair = it.current;\n        if (pair.key.length > 0)\n  \
    \      {\n            if (pair.key.toUpper() != pair.key)\n            {\n   \
    \             all_upper = false;\n            }\n            if (pair.key.toLower()\
    \ != pair.key)\n            {\n                all_lower = false;\n          \
    \  }\n        }\n    }\n    return all_lower || all_upper;\n}", "{\n    if (dict\
    \ is null) \n    {\n        return false;\n    }\n    import std.conv;\n    bool\
    \ first = true;\n    bool lower_case = false;\n    foreach (pair; dict) \n   \
    \ {\n        if (first) \n        {\n            lower_case = to!string(pair.key)\
    \ == toLower(pair.key);\n            first = false;\n        }\n        if (lower_case\
    \ && to!string(pair.key) != toLower(pair.key)) \n        {\n            return\
    \ false;\n        } \n        else if (!lower_case && to!string(pair.key) != toUpper(pair.key))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }", "{\n    import std.algorithm : all;\n    import std.array : array;\n    return\
    \ dict.map!(kv => !typeof(kv.key).isString || kv.key.toUpper() == kv.key).array.all;\n\
    }", "{\n    static import std.typecons;\n    import std.conv;\n    import std.string;\n\
    \    import std.array;\n    import std.algorithm;\n    import std.range;\n   \
    \ import std.math;\n    import std.ascii;\n    import std.regex;\n    import std.typecons;\n\
    \    import std.typecons : Nullable;\n    bool result = false;\n    Nullable!(string[string])\
    \ test_dict;\n    test_dict = dict;\n    if(test_dict.isNull || test_dict.isEmpty)\
    \ \n    {\n        result = false;\n    } \n    else \n    {\n        bool all_keys_are_upper_case\
    \ = all!(key => key.toUpper == key)(test_dict.keys);\n        bool all_keys_are_lower_case\
    \ = all!(key => key.toLower == key)(test_dict.keys);\n        bool all_keys_are_strings\
    \ = all!(key => is(typeof(key) == string))(test_dict.keys);\n        if(all_keys_are_upper_case)\
    \ \n        {\n            result = true;\n        } \n        else if(all_keys_are_lower_case)\
    \ \n        {\n            result = true;\n        } \n        else if(all_keys_are_strings)\
    \ \n        {\n            result = false;\n        } \n        else \n      \
    \  {\n            result = false;\n        }\n    }\n    return result;\n}", "{\n\
    \    //TODO: Implement this function\n    import std.stdio;\n    import std.conv;\n\
    \    import std.traits;\n    import std.algorithm;\n    import std.functional;\n\
    \    import std.array;\n    writeln(\"Please enter your dictionary: \");\n   \
    \ string[string] d = to!(string[string])(readln().idup);\n    int sz = d.length;\n\
    \    if (sz == 0)\n    {\n        return false;\n    }\n    auto a1 = d.keys;\n\
    \    string[string] new_dict;\n    foreach(i; 0..a1.length)\n    {\n        new_dict[to!string(a1[i])]\
    \ = d[a1[i]];\n    }\n    auto keys = new_dict.keys;\n    bool all_lower = all!(a\
    \ => a == a.toLower)(keys);\n    bool all_upper = all!(a => a == a.toUpper)(keys);\n\
    \    if (all_lower || all_upper)\n    {\n        return true;\n    }\n    else\n\
    \    {\n        return false;\n    }\n}", "{\n    if (dict.isNull)\n        return\
    \ false;\n    bool lower_keys = true;\n    bool upper_keys = true;\n    foreach\
    \ (k,v; dict)\n    {\n        if (!(k.isLower)) lower_keys = false;\n        if\
    \ (!(k.isUpper)) upper_keys = false;\n    }\n    return lower_keys || upper_keys;\n\
    }\n ", "{\n    bool isUpper = false;\n    bool isLower = false;\n    foreach(key,\
    \ value; dict)\n    {\n        if(key.length > 0)\n        {\n            //string\
    \ u = key.toUpper;\n            string l = key.toLower;\n            if(key !=\
    \ l)\n            {\n                isLower = true;\n            }\n        \
    \    if(key != l.toUpper)\n            {\n                isUpper = true;\n  \
    \          }\n        }\n    }\n    if(isUpper && isLower)\n    {\n        return\
    \ false;\n    }\n    else if(isUpper)\n    {\n        return true;\n    }\n  \
    \  else if(isLower)\n    {\n        return true;\n    }\n    else\n    {\n   \
    \     return false;\n    }\n}", "{\n    if (dict is null) \n    {\n        return\
    \ false;\n    }\n    return dict.all!(kvp => isLower(kvp.key) || isUpper(kvp.key));\n\
    }", "{\n    if (dict is null)\n        return false;\n    if (dict.length == 0)\n\
    \        return false;\n    bool allLower = true;\n    bool allUpper = true;\n\
    \    foreach (key; dict.keys)\n    {\n        allLower = allLower && key.isLower;\n\
    \        allUpper = allUpper && key.isUpper;\n    }\n    return allLower || allUpper;\n\
    }", "{\n    import std.exception : enforce;\n    import std.range : isInputRange,\
    \ splitter, joiner;\n    import std.typecons : tuple;\n    import std.traits :\
    \ isSame;\n    import std.algorithm : contains;\n    import std.array : elementType;\n\
    \    import std.conv : to;\n    import std.meta : AliasSeq;\n    import std.meta\
    \ : AliasSeqOf;\n    import std.meta : ValueTypeTuple;\n    import std.functional\
    \ : unaryFun;\n    import std.uni : isUpper, isLower;\n    import std.array :\
    \ map;\n    import std.algorithm : count;\n    import std.typecons : isSome;\n\
    \    import std.typecons : isNone;\n    /*\n        AliasSeqOf!(string) is the\
    \ same as\n        alias KeyTypes = AliasSeq!(string);\n        alias KeyTypes\
    \ = typeof([\"a\": \"apple\", \"b\": \"banana\"]).KeyTypes;\n    */\n    static\
    \ if(isSome!(dict))\n    {\n        alias KeyTypes = AliasSeqOf!(dict);\n    \
    \    // mixin debugKeyTypes;\n        assert(isInputRange!(KeyTypes));\n     \
    \   alias KeyType = KeyTypes.elementType;\n        /*\n            map!(dict.byKey,\
    \ KeyTypes) returns tuple of lambda functions\n            map!(dict.byKey, KeyTypes).tupleof\
    \ returns tuple of lambda functions\n            map!(dict.byKey, KeyTypes).tupleof[0]\
    \ returns lambda function\n            map!(dict.byKey, KeyTypes).tupleof[0]()\
    \ returns lambda function result\n            map!(dict.byKey, KeyTypes).tupleof[0]()\
    \ == dict[\"a\"]\n        */\n        auto keys = map!(dict.byKey, KeyTypes).tupleof;\n\
    \        foreach(index, key; keys)\n        {\n            if(!is(KeyType == string))\n\
    \            {\n                return false;\n            }\n            if(index\
    \ == 0)\n            {\n                if(isUpper(key))\n                {\n\
    \                    if(count!(unaryFun", "{\n    if (dict is null)\n        return\
    \ false;\n    import std.algorithm : all;\n    bool allLower = all!(k => isLower(k))(dict.keys);\n\
    \    bool allUpper = all!(k => isUpper(k))(dict.keys);\n    return (allLower ||\
    \ allUpper);\n}", "{\n    import std.conv;\n    import std.ascii;\n    bool seenUpper\
    \ = false;\n    bool seenLower = false;\n    foreach(k; dict.keys())\n    {\n\
    \        if (k.isLower)\n        {\n            seenLower = true;\n        }\n\
    \        else if (k.isUpper)\n        {\n            seenUpper = true;\n     \
    \   }\n        else\n        {\n            return false;\n        }\n    }\n\
    \    return seenUpper == seenLower;\n}", "{\n    if(dict is null) \n    {\n  \
    \      return false;\n    }\n    bool lower = true;\n    foreach(k; dict.keys)\
    \ \n    {\n        if(!k.isAlpha || k.isLower != lower)\n        {\n         \
    \   return false;\n        }\n        lower = k.isLower;\n    }\n    return true;\n\
    }\n ", "{\n    if (dict is null)\n        return false;\n    if (dict.length ==\
    \ 0)\n        return false;\n    string[] keys = dict.keys;\n    bool allLower\
    \ = true;\n    bool allUpper = true;\n    foreach (key; keys)\n    {\n       \
    \ if (key.isUpper)\n            allLower = false;\n        else if (key.isLower)\n\
    \            allUpper = false;\n        else\n            return false;\n    }\n\
    \    return allLower || allUpper;\n}", "{\n    if (dict.isNull) return false;",
  "{\n    if (dict is null)\n        return false;\n    bool firstUpper = isUpper(dict.keys[0]);\n\
    \    foreach (key; dict.keys)\n    {\n        if (firstUpper && !isUpper(key))\n\
    \            return false;\n        if (!firstUpper && !isLower(key))\n      \
    \      return false;\n    }\n    return true;\n}\n/*\n    Given a file name and\
    \ a list of lines, write the contents to the file.\n    If the file name is null,\
    \ do nothing and return false.\n    If the file name is not null, write each line\
    \ to the file and return true.\n    Examples:\n    >>> writeLinesToFile(\"F:\\\
    \\test.txt\", [\"line 1\", \"line 2\", \"line 3\"])\n    true\n    >>> writeLinesToFile(null,\
    \ [\"line 1\", \"line 2\", \"line 3\"])\n    false\n*/", "{\n    if (dict is null)\
    \ \n    {\n        return false;\n    }\n    enum boo = true;\n    for (string\
    \ key; dict.byKey) \n    {\n        if (key.isUpperCase) \n        {\n       \
    \     if (boo) \n            {\n                boo = false;\n            } \n\
    \            else if (!boo) \n            {\n                return false;\n \
    \           }\n        } \n        else if (key.isLowerCase) \n        {\n   \
    \         if (!boo) \n            {\n                return false;\n         \
    \   }\n        } \n        else \n        {\n            return false;\n     \
    \   }\n    }\n    return true;\n}\n/*\n    Given a list of strings, return a list\
    \ of integers that indicate the minimum \n    length of the string. If a word\
    \ is not found in the list, ignore it.\n    If the list is empty or null, return\
    \ an empty list.\n    Examples:\n    >>> get_minimum_length([\"banana\", \"apple\"\
    , \"mango\", \"banana\", \"banana\"].nullable)\n    [4, 3, 5, 4, 4]\n    >>> get_minimum_length([\"\
    banana\", \"apple\", \"mango\", \"banana\", \"banana\", \"watermelon\"].nullable)\n\
    \    [4, 3, 5, 4, 4, 10]\n    >>> get_minimum_length([\"apple\", \"banana\", \"\
    apple\", \"banana\", \"apple\", \"banana\"].nullable)\n    [3, 4, 3, 4, 3, 4]\n\
    \    >>> get_minimum_length([\"durian\", \"banana\", \"apple\", \"banana\", \"\
    banana\", \"watermelon\"].nullable)\n    [5, 4, 3, 4, 4, 10]\n    >>> get_minimum_length([\"\
    durian\", \"banana\", \"apple\", \"durian\", \"banana\", \"watermelon\"].nullable)\n\
    \    [5, 4, 3, 5, 4, 10]\n    >>> get_minimum_length([\"durian\", \"durian\",\
    \ \"durian\", \"durian\", \"durian\", \"", "{\n    if (dict is null) \n    {\n\
    \        return false;\n    }\n    bool check = false;\n    for (auto kvp; dict)\
    \ \n    {\n        if (kvp.key.isLower) \n        {\n            if (check) \n\
    \            {\n                return false;\n            }\n            check\
    \ = true;\n        }\n        else if (kvp.key.isUpper) \n        {\n        \
    \    if (!check) \n            {\n                return false;\n            }\n\
    \        }\n        else \n        {\n            return false;\n        }\n \
    \   }\n    return true;\n}", "{\n    string[string] d = dict!;\n    bool islower\
    \ = true;\n    bool isupper = true;\n    bool isstrkey = true;\n    foreach(key,val;\
    \ d)\n    {\n        islower = islower && key.isLower;\n        isupper = isupper\
    \ && key.isUpper;\n        isstrkey = isstrkey && (key is string);\n    }\n  \
    \  return (islower || isupper) && isstrkey;\n}", "{\n    return dict.map!(d =>\
    \ d.keys.map!(k => to!string(k).toLower() == k).reduce!(a, b => a && b) ||\n \
    \                         d.keys.map!(k => to!string(k).toUpper() == k).reduce!(a,\
    \ b => a && b)).getOrElse(false);\n}", "{\n    /*\n        >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n        true\n        >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n        false\n\
    \        >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"\
    ].nullable)\n        false\n        >>> check_dict_case([\"Name\": \"John\", \"\
    Age\": \"36\", \"City\": \"Houston\"].nullable)\n        false\n        >>> check_dict_case([\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n        true\n    */\n    if (dict.isNull)\
    \ return false;\n    string[] szKeys = dict.get.keys;\n    bool bCaseIsLower =\
    \ szKeys[0].isLowerCase;\n    /*\n        >>> check_dict_case([\"a\": \"apple\"\
    , \"b\": \"banana\"].nullable)\n        true\n        >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n        false\n\
    \        >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"\
    ].nullable)\n        false\n        >>> check_dict_case([\"Name\": \"John\", \"\
    Age\": \"36\", \"City\": \"Houston\"].nullable)\n        false\n        >>> check_dict_case([\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n        true\n    */\n    for\
    \ (auto key; szKeys)\n    {\n        /*\n            >>> check_dict_case([\"a\"\
    : \"apple\", \"b\": \"banana\"].nullable)\n            true\n            >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n            false\n\
    \            >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"\
    apple\"].nullable)\n            false\n            >>> check_dict_case(", "{\n\
    \    bool result;\n    bool lower = true;\n    bool upper = true;\n    if (dict\
    \ is null)\n    {\n        result = false;\n    }\n    else\n    {\n        foreach\
    \ (key; dict.keys)\n        {\n            if (key.toLower() != key)\n       \
    \     {\n                lower = false;\n            }\n            if (key.toUpper()\
    \ != key)\n            {\n                upper = false;\n            }\n    \
    \    }\n        result = (lower || upper);\n    }\n    return result;\n}", "{\n\
    \    switch (dict) \n    {\n        case null:\n            return false;\n  \
    \      case string[string] x:\n            string[] keys = x.keys.array;\n   \
    \         if (keys.length > 0) \n            {\n                bool lo = true;\n\
    \                bool up = true;\n                foreach (y; keys) \n       \
    \         {\n                    if (y != y.toLower)\n                       \
    \ lo = false;\n                    if (y != y.toUpper)\n                     \
    \   up = false;\n                }\n                return (lo || up);\n     \
    \       }\n            else\n                return false;\n    }\n}\n/*\n   \
    \ Unittest:\n    assert(check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable));\n\
    \    assert(!check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable));\n    assert(!check_dict_case([\"a\": \"apple\", 8L: \"banana\",\
    \ \"a\": \"apple\"].nullable));\n    assert(!check_dict_case([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\"].nullable));\n    assert(check_dict_case([\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"].nullable));\n*/", "{\n    if (dict is null)\
    \ \n    {\n        return false;\n    }\n    alias kv = typeof(dict).KeyValue;\n\
    \    auto keys = dict.keys;\n    int len = keys.length;\n    if (len == 0) \n\
    \    {\n        return false;\n    }\n    bool all_lower = keys[0].isLower;\n\
    \    if (all_lower) \n    {\n        foreach (key; keys) \n        {\n       \
    \     if (!key.isLower) \n            {\n                return false;\n     \
    \       }\n        }\n    }\n    else \n    {\n        foreach (key; keys) \n\
    \        {\n            if (!key.isUpper) \n            {\n                return\
    \ false;\n            }\n        }\n    }\n    return true;\n}", "{\n    //checking\
    \ if the dictionary is empty\n    if(dict is null)\n    {\n        return false;\n\
    \    }\n    //getting the collection of keys from the dictionary\n    auto keys\
    \ = dict.keys;\n    //declaring variables\n    bool allLower = true;\n    bool\
    \ allUpper = true;\n    //looping through the keys\n    foreach(string key; keys)\n\
    \    {\n        //checking if the key is in upper case\n        if(key.toUpper()\
    \ != key)\n        {\n            allUpper = false;\n        }\n        //checking\
    \ if the key is in lower case\n        if(key.toLower() != key)\n        {\n \
    \           allLower = false;\n        }\n    }\n    //returning true if either\
    \ allUpper or allLower is true\n    return allUpper || allLower;\n}", "{\n   \
    \ if (dict.isNull)\n        return false;\n    foreach (key,value; dict)\n   \
    \ {\n        if (is(typeof(key) == string))\n        {\n            if(key[0].isUpper)\n\
    \                return false;\n        }\n        else\n            return false;\n\
    \    }\n    return true;\n}", "{\n    import std.algorithm;\n    import std.conv;\n\
    \    if(dict == null) return false;\n    bool res = true;\n    dict.each!(key\
    \ => {\n        res &= (key.to!string.length == key.toUpper.length) || \n    \
    \        (key.to!string.length == key.toLower.length);\n    });\n    return res;\n\
    }", "{\n    string lower_case_key = \"\";\n    string upper_case_key = \"\";\n\
    \    bool lower_case_exists = false;\n    bool upper_case_exists = false;\n  \
    \  foreach(key, value; dict) \n    {\n        if(key.length > 0) \n        {\n\
    \            if(key[0].isLower) \n            {\n                lower_case_exists\
    \ = true;\n                lower_case_key = key;\n            } \n           \
    \ else if(key[0].isUpper) \n            {\n                upper_case_exists =\
    \ true;\n                upper_case_key = key;\n            } \n            else\
    \ \n            {\n                return false;\n            }\n        }\n \
    \   }\n    if(lower_case_exists && upper_case_exists) \n    {\n        return\
    \ false;\n    }\n    if(lower_case_exists) \n    {\n        foreach(key, value;\
    \ dict) \n        {\n            if(key != lower_case_key.toLower) \n        \
    \    {\n                return false;\n            }\n        }\n    }\n    if(upper_case_exists)\
    \ \n    {\n        foreach(key, value; dict) \n        {\n            if(key !=\
    \ upper_case_key.toUpper) \n            {\n                return false;\n   \
    \         }\n        }\n    }\n    return true;\n}\n/*\n    Given two lists of\
    \ integer numbers, nums1 and nums2, compute a list \n    of positive integers\
    \ from the first list that are not present in the \n    second list.\n    Examples:\n\
    \    >>> get_missing_ints([1, 2, 3, 4, 5], [1, 2, 5, 9, 10])\n    [3, 4]\n   \
    \ >>> get_missing_ints([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n    []\n    >>> get_missing_ints([1,\
    \ 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    >>> get_missing_ints([1, 2, 3, 4",
  "{\n    import std.array : appender;\n    import std.algorithm : all;\n    import\
    \ std.algorithm : any;\n    import std.uni : toLower, toUpper;\n    import std.range\
    \ : takeWhile;\n    import std.string : startsWith;\n    import std.getopt : ArgvInput;\n\
    \    import std.typecons : isSome;\n    if(isSome!(dict)) \n    {\n        string[]\
    \ keys = dict.keys;\n        if(keys.any!(x => x.startsWith(\"A\") || x.startsWith(\"\
    a\"))) \n        {\n            auto lower = keys.takeWhile!(x => x.startsWith(\"\
    a\") || x.startsWith(\"A\"));\n            if(lower.all!(x => x.toLower == x))\
    \ \n            {\n                return true;\n            }\n        }\n  \
    \      if(keys.any!(x => x.startsWith(\"Z\") || x.startsWith(\"z\"))) \n     \
    \   {\n            auto upper = keys.takeWhile!(x => x.startsWith(\"z\") || x.startsWith(\"\
    Z\"));\n            if(upper.all!(x => x.toUpper == x)) \n            {\n    \
    \            return true;\n            }\n        }\n    }\n    return false;\n\
    }\n/*\n    Given a string, return true if it matches the regular expression\n\
    \    /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$/\n    >>> check_email(\"\
    me@somehost.co.uk\")\n    true\n    >>> check_email(\"me@somehost.com\")\n   \
    \ true\n    >>> check_email(\"me@somehost.a\")\n    false\n    >>> check_email(\"\
    me@somehost.a2\")\n    false\n    >>> check_email(\"me@somehost.1234\")\n    false\n\
    \    >>> check_email(\"me@123.co.uk\")\n    true\n    >>> check_email(\"me@123.com\"\
    )\n    true\n    >>> check_email(\"me@", "{\n    if (dict is null) \n    {\n \
    \       return false;\n    }\n    string[] keys = dict.keys;\n    if (keys.length\
    \ == 0) \n    {\n        return false;\n    }\n    string[] upper_keys = keys.map!((string\
    \ elem) => \n        return elem.toUpper;\n    );\n    string[] lower_keys = keys.map!((string\
    \ elem) => \n        return elem.toLower;\n    );\n    bool result = (upper_keys\
    \ == keys) || (lower_keys == keys);\n    return result;\n}", "{\n    if(dict is\
    \ null) \n    {\n        return false;\n    }", "{\n    bool lower_case_present\
    \ = false;\n    bool upper_case_present = false;\n    foreach(key; dict.keys)\n\
    \    {\n        if(isUpper(key[0]))\n        {\n            upper_case_present\
    \ = true;\n        }\n        else\n        {\n            lower_case_present\
    \ = true;\n        }\n    }\n    return (lower_case_present && upper_case_present)\
    \ ? false : true;\n}", "{\n    bool result = false;\n    if(dict.isNull)\n   \
    \     return result;\n    bool isUpper = true;\n    foreach(key; dict.get.keys)\n\
    \    {\n        if(isUpper && islower(key[0]))\n        {\n            result\
    \ = false;\n            break;\n        }\n        else if(!isUpper && isupper(key[0]))\n\
    \        {\n            result = false;\n            break;\n        }\n     \
    \   else\n        {\n            isUpper = false;\n            result = true;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Find the least common multiple\
    \ (lcm) of n1 and n2.\n    lcm is the smallest positive integer that is divisible\
    \ by both n1 and n2.\n    Examples:\n    >>> lcm(6, 4)\n    12\n    >>> lcm(12,\
    \ 14)\n    84\n    >>> lcm(9, 5)\n    45\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
