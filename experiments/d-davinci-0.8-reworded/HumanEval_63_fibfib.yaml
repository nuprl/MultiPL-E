name: HumanEval_63_fibfib
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nThe FibFib number sequence is\
  \ a sequence similar to the Fibbonacci sequnece that's defined as follows:\n   \
  \ fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1)\
  \ + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute\
  \ the n-th element of the fibfib number sequence.\n    >>> fibfib(1L)\n    0L\n\
  \    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n    24L\n    \n*/\nlong fibfib(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = fibfib;\n\n    assert(candidate(2L) ==\
  \ 1L);\n    assert(candidate(1L) == 0L);\n    assert(candidate(5L) == 4L);\n   \
  \ assert(candidate(8L) == 24L);\n    assert(candidate(10L) == 81L);\n    assert(candidate(12L)\
  \ == 274L);\n    assert(candidate(14L) == 927L);\n}\nvoid main(){}"
completions: ["{\n    if (n < 3)\n        return n == 2;\n    // Will create problem\
    \ for overflow\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}",
  "{\n    if (n < 0) \n    {\n        throw new Exception(\"n must be a positive number\"\
    );\n    }\n    else if (n == 0) \n    {\n        return 0;\n    }\n    else if\
    \ (n == 1) \n    {\n        return 0;\n    }\n    else if (n == 2) \n    {\n \
    \       return 1;\n    }\n    else\n    {\n        return fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3);\n    }\n}", "{\n    if (n < 0) \n    {\n        throw new Exception(\"\
    n must be non-negative.\");\n    }\n    if (n == 0) \n    {\n        return 0;\n\
    \    }\n    if (n == 1) \n    {\n        return 0;\n    }\n    if (n == 2) \n\
    \    {\n        return 1;\n    }\n    auto s = tuple(0L, 0L, 1L);\n    foreach\
    \ (i; 2 .. n) \n    {\n        s = tuple(s[2], s[0], s[1] + s[0] + s[2]);\n  \
    \  }\n    return s[2];\n}\n/*", "{\n    if (n == 0) return 0;\n    else if (n\
    \ == 1) return 0;\n    else if (n == 2) return 1;\n    else return fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3);\n}\n/*\nThe FibFib number sequence is a sequence\
    \ similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0)\
    \ == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) +\
    \ fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute\
    \ the n-th element of the fibfib number sequence.\n    >>> fibfib(1L)\n    0L\n\
    \    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n    24L\n    \n*/\nlong fibfib1(long\
    \ n)\n{\n    if (n <= 2) return n-1;\n    else\n    {\n        long a = 0;\n \
    \       long b = 1;\n        long c = 1;\n        for (size_t i = 3; i < n; i++)\n\
    \        {\n            a = b;\n            b = c;\n            c = a + b + c;\n\
    \        }\n        return c;\n    }\n}", "{\n  if (n < 2) \n  {\n    return 0;\n\
    \  }\n  if (n == 2) \n  {\n    return 1;\n  }\n  long a = 0;\n  long b = 0;\n\
    \  long c = 1;\n  long result = 0;\n  foreach (i; 2..n) \n  {\n    result = a\
    \ + b + c;\n    a = b;\n    b = c;\n    c = result;\n  }\n  return result;\n}\n\
    /*\nGiven a sequence of elements, find the first element that repeats itself (first-in-first-out\
    \ basis) or report that there's no repetition.\n    >>> hasRepetition([1,2,3,2,1])\n\
    \    2\n    >>> hasRepetition([1,2,3,4])\n    0\n    >>> hasRepetition([4,4,4,4])\n\
    \    4\n    \n*/\nlong hasRepetition(int[] seq) \n{\n  auto s = new std.typecons.Map!(int,\
    \ int)();\n  foreach (element; seq) \n  {\n    if (s.count ! is(element)) \n \
    \   {\n      s[element] = 0;\n    }\n    else \n    {\n      return element;\n\
    \    }\n  }\n  return 0;\n}\n/*\nGiven an array of elements, return how many times\
    \ those elements appear in order. For example:\n    >>> orderedCount([1, 2, 2,\
    \ 3])\n    [Tuple!(int, \"1\")(1, 1), Tuple!(int, \"2\")(2, 2), Tuple!(int, \"\
    3\")(3, 1)]\n    >>> orderedCount([1, 1, 2, 2, 3])\n    [Tuple!(int, \"1\")(1,\
    \ 2), Tuple!(int, \"2\")(2, 2), Tuple!(int, \"3\")(3, 1)]\n    >>> orderedCount([42])\n\
    \    [Tuple!(int, \"42\")(42, 1)]\n    \n*/\nauto orderedCount(int[] a) \n{\n\
    \  auto s = new std.typecons.Map!(", "{\n\tif (n <= 1)\n\t{\n\t\treturn 0;\n\t\
    }\n\tif (n == 2)\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn fibfib(n -\
    \ 1) + fibfib(n - 2) + fibfib(n - 3);\n\t}\n\t\t\n}", "{\n    if (n < 3) return\
    \ n - 1;", "{\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n    \
    \    return 0;\n    else if (n == 2)\n        return 1;\n    else if (n > 2)\n\
    \        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n\tlong x = 0L;\n\
    \tlong y = 0L;\n\tlong z = 1L;\n\tauto prev = tuple(x, y, z);\n\tfor (long i =\
    \ 0L; i < n; i++) \n\t{\n\t\ty = get!1(prev);\n\t\tz = get!2(prev);\n\t\tx = y\
    \ + z + get!0(prev);\n\t\tprev = tuple(y, z, x);\n\t}\n\treturn y;\n}", "{\n \
    \   if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 0;\n\
    \    else if (n == 2)\n        return 1;\n    else\n        return fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3);\n}", "{\n  import std.typecons : Tuple;\n  long\
    \ fn1 = 0, fn2 = 0, fn3 = 1;\n  Tuple!(long, long, long) fibs = tuple(fn1, fn2,\
    \ fn3);\n  foreach (i; 0..n)\n    fibs = tuple(fibs[2], fibs[0] + fibs[1] + fibs[2],\
    \ fibs[1]);\n  return fibs[1];\n}\n// /usr/include/dmd/phobos/std/typecons.d\n\
    // class tuple(T...)\n// {\n//     private T[] data;\n//     // ...\n//     void\
    \ opIndexAssign(R, U)(U value) if (is(typeof(data[R] = value)));\n//     // ...\n\
    // }", "{\n    if (n == 0) \n    {\n        return 0;\n    }\n    else if (n ==\
    \ 1) \n    {\n        return 0;\n    }\n    else if (n == 2) \n    {\n       \
    \ return 1;\n    }\n    else \n    {\n        long a = 0;\n        long b = 0;\n\
    \        long c = 1;\n        long res = 0;\n        for (int i = 2; i < n; i++)\
    \ \n        {\n            res = a + b + c;\n            a = b;\n            b\
    \ = c;\n            c = res;\n        }\n        return res;\n    }\n}", "{\n\
    \    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 0;\n    if\
    \ (n == 2)\n        return 1;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }\n/*\nFibFib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nFibFib(n-1) = fibfib(n-2)\
    \ + fibfib(n-3) + fibfib(n-4)\nFibFib(n-2) = fibfib(n-3) + fibfib(n-4) + fibfib(n-5)\n\
    FibFib(n-3) = fibfib(n-4) + fibfib(n-5) + fibfib(n-6)\nFibFib(n-4) = fibfib(n-5)\
    \ + fibfib(n-6) + fibfib(n-7)\nFibFib(n-5) = fibfib(n-6) + fibfib(n-7) + fibfib(n-8)",
  "{\n    if (n < 3) \n    {\n        return n;\n    } \n    else \n    {\n      \
    \  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n    }\n}", "{\n    if\
    \ (n < 0) \n    {\n        return -1;\n    }\n    if (n == 0 || n == 1) \n   \
    \ {\n        return 0;\n    }\n    if (n == 2) \n    {\n        return 1;\n  \
    \  }\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}", "{\n    if\
    \ (n == 0L)\n        return 0L;\n    if (n == 1L)\n        return 0L;\n    if\
    \ (n == 2L)\n        return 1L;\n    return fibfib(n - 1L) + fibfib(n - 2L) +\
    \ fibfib(n - 3L);\n}", "{\n    //The best answer will use dynamic programming.\n\
    \    long [] arr = new long[n+1];\n    arr[0] = 0;\n    arr[1] = 0;\n    arr[2]\
    \ = 1;\n    foreach(i;3..n+1)\n    {\n        arr[i] = arr[i-1] + arr[i-2] + arr[i-3];\n\
    \    }\n    return arr[n];\n}\n/*\nA graph is a collection of vertices (nodes)\
    \ and edges. \nIn a graph, edges are undirected (you can go from v1 to v2, or\
    \ you can go from v2 to v1).", "{\n    long a = 0L;\n    long b = 0L;\n    long\
    \ c = 1L;\n    long i = 2L;\n    long fib = 0L;\n    while (i <= n) \n    {\n\
    \        fib = a + b + c;\n        a = b;\n        b = c;\n        c = fib;\n\
    \        i++;\n    }\n    return fib;\n}", "{\n    if (n <= 1)\n        return\
    \ 0;\n    if (n == 2)\n        return 1;\n    return fibfib(n - 1) + fibfib(n\
    \ - 2) + fibfib(n - 3);\n}", "{\n    if (n < 2)\n        return 0;\n    if (n\
    \ == 2)\n        return 1;\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3);\n}", "{\n    // Compute n-th element of the fibfib number sequence\n \
    \   return n >= 3 ? fibfib(n-1) + fibfib(n-2) + fibfib(n-3) : n;\n}", "{\n   \
    \ static long fib[100];\n    static long last = 0;\n    if (n <= 0) return 0;\n\
    \    if (n < 3) return 1;\n    for (; last < n; last++) \n    {\n        fib[last]\
    \ = fib[last-1] + fib[last-2] + fib[last-3];\n    }\n    return fib[n-1];\n}\n\
    long fibfib_recur(long n)\n{\n    static long fib[100];\n    static long last\
    \ = 0;\n    if (n <= 0) return 0;\n    if (n < 3) return 1;\n    if (n <= last)\
    \ return fib[n-1];\n    auto tmp = fibfib_recur(n-1) + fibfib_recur(n-2) + fibfib_recur(n-3);\n\
    \    fib[n-1] = tmp;\n    return tmp;\n}", "{\n    long[] fibArr = new long[n];\n\
    \    fibArr[0] = 0;\n    fibArr[1] = 0;\n    fibArr[2] = 1;\n    if (n <= 3) return\
    \ fibArr[n - 1];\n    for (int i = 3; i < n; i++) {\n        fibArr[i] = fibArr[i\
    \ - 1] + fibArr[i - 2] + fibArr[i - 3];\n    }\n    return fibArr[n - 1];\n}",
  "{\n  if (n <= 2) return n-1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }", "{\n    long n1 = 0;\n    long n2 = 0;\n    long n3 = 1;\n    long n4 = 0;\n\
    \    foreach(i; 2 .. n + 1)\n    {\n        n4 = n1 + n2 + n3;\n        n1 = n2;\n\
    \        n2 = n3;\n        n3 = n4;\n    }\n    return n4;\n}\n/*\nYou have a\
    \ sequence of booleans and you want to efficiently compute the number of \ntimes\
    \ that the sequence changes from true to false (or vice versa). For example,\n\
    \    >>> countFlips([true, true, false, true, false, false, true])\n    3\n  \
    \  >>> countFlips([true, true, false, true, false, false, true, false])\n    4\n\
    */", "{\n    long previous = 0;\n    long current = 0;\n    long next = 1;\n \
    \   while (n--) {\n        previous = current;\n        current = next;\n    \
    \    next = previous + current + next;\n    }\n    return current;\n}", "{\n \
    \   if (n == 0L) \n    {\n        return 0L;\n    }\n    if (n == 1L) \n    {\n\
    \        return 0L;\n    }\n    if (n == 2L) \n    {\n        return 1L;\n   \
    \ }\n    long f_n_minus_3 = 0L;\n    long f_n_minus_2 = 0L;\n    long f_n_minus_1\
    \ = 1L;\n    long fn = 0L;\n    for (long i = 3L; i <= n; i++) \n    {\n     \
    \   fn = f_n_minus_1 + f_n_minus_2 + f_n_minus_3;\n        f_n_minus_3 = f_n_minus_2;\n\
    \        f_n_minus_2 = f_n_minus_1;\n        f_n_minus_1 = fn;\n    }\n    return\
    \ fn;\n}", "{\n    long a = 0;\n    long b = 0;\n    long c = 1;\n    long i =\
    \ 2;\n    long d = 0;\n    if (n < 3)\n        return n - 1;\n    while (i < n)\
    \ \n    {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c =\
    \ d;\n        i++;\n    }\n    return d;\n}", "{\n    n--;\n    return n < 0L\
    \ ? 0L : n < 2L ? 1L : fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}\n/*\nAn Armstrong\
    \ number is a number that is the sum of its own digits each raised to the power\
    \ of the number of digits.\nFor example, 9 is an Armstrong number, because 9 =\
    \ 9^1 = 9.\n10 is not an Armstrong number, because 10 != 1^2 + 0^2 = 1.\n153 is\
    \ an Armstrong number, because: 153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\n154\
    \ is not an Armstrong number, because: 154 != 1^3 + 5^3 + 4^3 = 1 + 125 + 64 =\
    \ 190\nWrite a function that determines whether a number is an Armstrong number.\n\
    >>> isArmstrong(153)\ntrue\n>>> isArmstrong(154)\nfalse\n*/", "{\n    if (n <\
    \ 0)\n        return -1;\n    if (n == 0)\n        return 0;\n    if (n == 1)\n\
    \        return 0;\n    if (n == 2)\n        return 1;\n    //return fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3); //Extremely slow function as it recalculates everything\
    \ all the time\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}\n/*\nWrite\
    \ a function that is capable of adding two lists of arbitrary lengths, using the\
    \ following algorithm:\n    Sum the elements of each list until there are no more\
    \ elements to add in the longer list\n    If the lists are of equal length, add\
    \ the two final elements and return the resulting list\n    If the lists are of\
    \ unequal length, add the final element of the longer list to the last sum,\n\
    \    add the final element of the shorter list to the result, and return the resulting\
    \ list\n    \n    >>> addList([4L, 8L, 15L, 16L, 23L, 42L], [7L, 11L, 19L, 21L,\
    \ 26L, 30L])\n    [11L, 18L, 28L, 32L, 38L, 47L]\n    >>> addList([1L, 2L, 3L,\
    \ 4L, 5L], [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0", "in {\n    assert(n >= 0L);\n}\nout (result)\
    \ {\n    assert(n >= 0L);\n}\nbody {\n    if (n == 0L) {\n        return 0L;\n\
    \    } else if (n == 1L) {\n        return 0L;\n    } else if (n == 2L) {\n  \
    \      return 1L;\n    } else {\n        return fibfib(n-1L) + fibfib(n-2L) +\
    \ fibfib(n-3L);\n    }\n}", "{\n    //precondition: n must be larger than or equal\
    \ to 0\n    assert(n >= 0);\n    //Base case:\n    if (n == 0) return 0;\n   \
    \ else if (n == 1) return 0;\n    else if (n == 2) return 1;\n    else\n    {\n\
    \        //Cached results of previous computations\n        //Initialized to a\
    \ dummy value of -1\n        long[] fibfibArray = new long[(int)n + 1];\n    \
    \    //Initialize first three values of fibfibArray\n        fibfibArray[0] =\
    \ 0;\n        fibfibArray[1] = 0;\n        fibfibArray[2] = 1;\n        for (long\
    \ i = 3; i <= n; i++)\n        {\n            //Compute fibfib values of current\
    \ index\n            fibfibArray[(int)i] = fibfibArray[(int)i - 1] + fibfibArray[(int)i\
    \ - 2] + fibfibArray[(int)i - 3];\n        }\n        return fibfibArray[(int)n];\n\
    \    }\n}\n//-----------------------------------------------------------------------------\n\
    // Unit tests\n//-----------------------------------------------------------------------------",
  "{\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 1;\n   \
    \ long prev1 = 0;\n    long prev2 = 1;\n    long res = 1;\n    while (n-- > 2)\
    \ \n    {\n        res = prev1 + prev2 + res;\n        prev1 = prev2;\n      \
    \  prev2 = res;\n    }\n    return res;\n}\n// http://www.sharejs.com/codes/d/742a3d98e2b51dba9eefde71613b4d4d",
  "{\n    //Your code here\n    return n < 3 ? n - 1 : fibfib(n - 1) + fibfib(n -\
    \ 2) + fibfib(n - 3);\n}", "{\n    long[] fibs = new long[n + 1];\n    fibs[0]\
    \ = 0;\n    fibs[1] = 0;\n    fibs[2] = 1;\n    foreach(i; 3..=n)\n    {\n   \
    \     fibs[i] = fibs[i-1] + fibs[i-2] + fibs[i-3];\n    }\n    return fibs[n];\n\
    }", "{\n    long a = 0L;\n    long b = 0L;\n    long c = 1L;\n    long d = 0L;\n\
    \    for (long i = 2L; i <= n; i++) \n    {\n        d = a + b + c;\n        a\
    \ = b;\n        b = c;\n        c = d;\n    }\n    return d;\n}\n/*\nTicTacToe\
    \ is a game played between two players on a 3x3 board, who take turns marking\
    \ a square. The first player to mark 3 squares in a row wins.", "{\n    if (n\
    \ == 0L) \n    {\n        return 0L;\n    } \n    else if (n == 1L) \n    {\n\
    \        return 0L;\n    } \n    else if (n == 2L) \n    {\n        return 1L;\n\
    \    }\n    else \n    {\n        long a = 0L;\n        long b = 0L;\n       \
    \ long c = 1L;\n        long d = 0L;\n        for (long i = 3L; i <= n; i++) \n\
    \        {\n            d = a + b + c;\n            a = b;\n            b = c;\n\
    \            c = d;\n        }\n        return d;\n    }\n}", "{\n    if (n <\
    \ 3)\n        return 0;\n    // Regular fibbonacci sequence, but with a zero at\
    \ the beginning\n    long[2] fibs = [0, 1];\n    long fib = 0;\n    for (int i\
    \ = 2; i < n; i++) \n    {\n        // Shift the fibbonacci sequence one to the\
    \ left\n        fibs[0] = fibs[1];\n        fibs[1] = fib;\n        // And add\
    \ the sum of the last two elements in the sequence\n        fib = fibs[0] + fibs[1];\n\
    \    }\n    return fib;\n}", "{\n    if (n == 0)\n        return 0;\n    if (n\
    \ == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n    else\n   \
    \     return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n    // Using a\
    \ CTFE to build an array of the first 1,000 Fibfib numbers and then return the\
    \ n-th element.\n    // This technique would not be suitable for numbers greater\
    \ than 1,000 due to the hard limit on compile-time evaluation.\n    long fibs[1000];\n\
    \    fibs[0] = 0;\n    fibs[1] = 0;\n    fibs[2] = 1;\n    foreach(i; 3..1000)\
    \ {\n        fibs[i] = fibs[i-1] + fibs[i-2] + fibs[i-3];\n    }\n    return fibs[n];\n\
    }", "{\n    long a = 0L;\n    long b = 0L;\n    long c = 1L;\n    long d = 0L;\n\
    \    while (n > 0L)\n    {\n        --n;\n        d = a + b + c;\n        a =\
    \ b;\n        b = c;\n        c = d;\n    }\n    return d;\n}\n/*\nThis problem\
    \ was asked by Uber.\nGiven an array of integers, return a new array such that\
    \ each element at index i of the new array is the product of all the numbers in\
    \ the original array except the one at i.\nFor example, if our input was [1, 2,\
    \ 3, 4, 5], the expected output would be [120, 60, 40, 30, 24]. If our input was\
    \ [3, 2, 1], the expected output would be [2, 3, 6].\nFollow-up: what if you can't\
    \ use division?\n*/\nlong[] createProductArray(long[] a) \n{\n    long[] result\
    \ = new long[a.length];\n    if (a.length <= 1L)\n    {\n        return result;\n\
    \    }\n    long product = 1L;\n    for (long l : a)\n    {\n        product *=\
    \ l;\n    }\n    for (long i = 0L; i < a.length; ++i)\n    {\n        result[i]\
    \ = product / a[i];\n    }\n    return result;\n}\n/*\nGiven a list of integers,\
    \ write a function that returns the largest sum of non-adjacent numbers. Numbers\
    \ can be 0 or negative.\nFor example, [2, 4, 6, 2, 5] should return 13, since\
    \ we pick 2, 6, and 5. [5, 1, 1, 5] should return 10, since we pick 5 and 5.\n\
    Follow-up: Can you do this in O(N) time and constant space?\n*/\nlong largestSumOfNonAdjacentNumbers(long[]\
    \ a) \n{\n    if (a.length == 0L)\n    {\n        return 0L;\n    }\n    long\
    \ temp = 0L;\n    long sum = 0L;\n    for (long l : a)\n    {\n        temp =\
    \ (sum >", "{\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n\
    \ == 2) return 1;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n\
    \    long a = 0L;\n    long b = 0L;\n    long c = 1L;\n    foreach(i; 0 .. n)\
    \ \n    {\n        long t = a;\n        a = b;\n        b = c;\n        c = t\
    \ + b + c;\n    }\n    return a;\n}", "{\n    if (n < 3)\n        return n ==\
    \ 0 ? 0 : 1;\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}", "{\n\
    \    const long fibonacci = [0L, 0L, 1L];\n    return fibonacci[cast(int)n]\n\
    \        + (n >= 3 ? fibfib(n - 1) + fibfib(n - 2) : 0L);\n}", "{\n    return\
    \ n < 3 ? n - 1 : fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}", "{\n   \
    \ int k = cast(int)n;\n    auto arr = new int[k+1];\n    arr[0] = 0;\n    arr[1]\
    \ = 0;\n    arr[2] = 1;\n    for(int i = 3; i <= k; i++)\n    {\n        arr[i]\
    \ = arr[i-1] + arr[i-2] + arr[i-3];\n    }\n    return arr[k];\n}", "{\n    return\
    \ n<3?\n        n-1:\n        fibfib(n-1)+fibfib(n-2)+fibfib(n-3);\n}\n//Faster\n\
    long fibfibFast(long n) \n{\n    if(n<3) return n-1;\n    auto v=tuple(0L,0L,1L);\n\
    \    for(long i=3;i<=n;i++)\n    {\n        v=tuple(v[1],v[2],v[0]+v[1]+v[2]);\n\
    \    }\n    return v[2];\n}", "{\n    struct FibFib\n    {\n\tlong get(){return\
    \ a;}\n\tauto opBinary(string op : \"+\")(FibFib b) \n\t{\n\t    if(op == \"+\"\
    ) return FibFib(a + b.a, b.a, b.b);\n\t    else return 0;\n\t}\n\tlong a, b, c;\n\
    \    }\n    FibFib f = FibFib(0, 0, 1);\n    for(long i = 0; i < n; i++)\n\tf\
    \ = f + f;\n    return f.get();\n}\n/*\nThese are the tests for the FibFib function.\n\
    */", "{\n    if (n <= 1) \n    {\n        return 0;\n    } \n    else if (n ==\
    \ 2) \n    {\n        return 1;\n    } \n    else \n    {\n        long i = 1;\n\
    \        long j = 1;\n        long k = 2;\n        long l = 2;\n        while\
    \ (k <= n) \n        {\n            long tmp = l;\n            l = i + j + l;\n\
    \            i = j;\n            j = tmp;\n            k++;\n        }\n     \
    \   return l;\n    }\n}\n/*\nThe FibFib number sequence is a sequence similar\
    \ to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n\
    \    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3).\n    Please write a function to efficiently compute the n-th\
    \ element of the fibfib number sequence.\n    >>> fibfib(1L)\n    0L\n    >>>\
    \ fibfib(5L)\n    4L\n    >>> fibfib(8L)\n    24L\n    \n*/\nlong fibfib(long\
    \ n) \n{\n    if (n <= 1) \n    {\n        return 0;\n    } \n    else if (n ==\
    \ 2) \n    {\n        return 1;\n    } \n    else \n    {\n        long i = 1;\n\
    \        long j = 1;\n        long k = 2;\n        long l = 2;\n        while\
    \ (k <= n) \n        {\n            long tmp = l;\n            l = i + j + l;\n\
    \            i = j;\n            j = tmp;\n            k++;\n        }\n     \
    \   return l;\n    }\n}\n/*\nThe FibFib number sequence is a sequence similar\
    \ to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n\
    \    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) ==", "{\n\treturn n < 3\
    \ ? n - 1 : fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n/*\n    The FibFib\
    \ numbers can be stored in a list.\n    >>> fibfibLst[0]\n    0L\n    >>> fibfibLst[1]\n\
    \    0L\n    >>> fibfibLst[2]\n    1L\n    >>> fibfibLst[8]\n    24L\n    >>>\
    \ fibfibLst[12]\n    233L\n    >>> fibfibLst[19]\n    17711L\n*/\nauto fibfibLst\
    \ = [0L, 0L, 1L] ~ copy() ~ generate!((a, b, c) => a + b + c)(0L, 0L, 1L);", "{\n\
    \    if (n <= 1) \n    {\n        return 0;\n    }\n    else if (n == 2) \n  \
    \  {\n        return 1;\n    }\n    auto fib_fib_n_minus_2 = 1L;\n    auto fib_fib_n_minus_3\
    \ = 0L;\n    auto fib_fib_n_minus_1 = 0L;\n    auto fib_fib_n = 0L;\n    for (auto\
    \ i = 3; i <= n; i++) \n    {\n        fib_fib_n = fib_fib_n_minus_1 + fib_fib_n_minus_2\
    \ + fib_fib_n_minus_3;\n        fib_fib_n_minus_3 = fib_fib_n_minus_2;\n     \
    \   fib_fib_n_minus_2 = fib_fib_n_minus_1;\n        fib_fib_n_minus_1 = fib_fib_n;\n\
    \    }\n    return fib_fib_n;\n}\n/*\n    The following is the definition of the\
    \ Lucas sequence:\n    lucas(0) == 2\n    lucas(1) == 1\n    lucas(n) == lucas(n-1)\
    \ + lucas(n-2)\n    Please write a function to efficiently compute the n-th element\
    \ of the Lucas sequence.\n    >>> lucas(1L)\n    1L\n    >>> lucas(2L)\n    3L\n\
    \    >>> lucas(5L)\n    11L\n*/\nlong lucas(long n) \n{\n    if (n == 0) \n  \
    \  {\n        return 2;\n    }\n    else if (n == 1) \n    {\n        return 1;\n\
    \    }\n    else \n    {\n        auto lucas_n_minus_2 = 1L;\n        auto lucas_n_minus_1\
    \ = 2L;\n        auto lucas_n = 0L;\n        for (auto i = 2; i <= n; i++) \n\
    \        {\n            lucas_n = lucas_n_minus_1 + lucas_n_minus_2;\n       \
    \    ", "{\n    if (n <= 1) return 0;\n    if (n == 2) return 1;\n    long f1\
    \ = 0, f2 = 0, f3 = 1;\n    for (long i = 2; i < n; i++) {\n        long sum =\
    \ f1 + f2 + f3;\n        f1 = f2;\n        f2 = f3;\n        f3 = sum;\n    }\n\
    \    return f1 + f2 + f3;\n}", "{\n    if (n < 3) return n;\n    long a = 0;\n\
    \    long b = 1;\n    long c = 2;\n    long temp;\n    long i = 2;\n    while\
    \ (i < n) \n    {\n        temp = a + b + c;\n        a = b;\n        b = c;\n\
    \        c = temp;\n        i++;\n    }\n    return c;\n}\n/*\nremove_consecutive_duplicates\n\
    Given a string of words, remove all the consecutive duplicate words. The output\
    \ string should contain only unique words.\nExample:\n    >>> remove_consecutive_duplicates(\"\
    alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta\"\
    )\n    \"alpha beta gamma delta alpha beta gamma delta\"\n    \n*/\nimport std.algorithm;\n\
    import std.array;\nimport std.string;", "{\n    if (n < 2) \n    {\n        return\
    \ 0;\n    } \n    else if (n == 2) \n    {\n        return 1;\n    }\n    long\
    \ a = 0;\n    long b = 0;\n    long c = 1;\n    for (long i = 3; i <= n; i++)\
    \ \n    {\n        long d = a + b + c;\n        a = b;\n        b = c;\n     \
    \   c = d;\n    }\n    return c;\n}", "{\n    if (n < 3) \n    {\n        return\
    \ n;\n    }\n    else \n    {\n        long a = 0, b = 1, c = 1;\n        for\
    \ (size_t i = 3; i <= n; i++) \n        {\n            a = b;\n            b =\
    \ c;\n            c = a + b + c;\n        }\n        return c;\n    }\n}", "{\n\
    \    if (n < 3)\n        return n - 1;\n    long a = 0, b = 0, c = 1;\n    for\
    \ (; n > 2; n--)\n    {\n        a = b;\n        b = c;\n        c = a + b + c;\n\
    \    }\n    return c;\n}", "{\n\tif (n == 0L) return 0L;\n\tif (n == 1L) return\
    \ 0L;\n\tif (n == 2L) return 1L;\n\t\n\treturn fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }", "{\n    long a = 0;\n    long b = 0;\n    long c = 1;\n    long d = 0;\n \
    \   if (n == 0)\n        return 0;\n    if (n == 1)\n        return 0;\n    if\
    \ (n == 2)\n        return 1;\n    while (n-- > 2)\n    {\n        d = a + b +\
    \ c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return d;\n}",
  "{\n\tlong ret = 0;\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn 0;\n\
    \tif (n == 2)\n\t\treturn 1;\n\treturn fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3);\n}", "{\n    /*\n    if (n == 0)\n        return 0;\n    if (n == 1)\n\
    \        return 0;\n    if (n == 2)\n        return 1;\n    else\n        return\
    \ fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n    */\n    long a = 0, b = 0, c =\
    \ 1, d = 0;\n    for (long i = 2; i <= n; i++)\n    {\n        d = a + b + c;\n\
    \        a = b;\n        b = c;\n        c = d;\n    }\n    return d;\n}\nunittest\n\
    {\n    for (long i = 0; i < 25; i++)\n    {\n        assert(fibfib(i) == fibfibTest(i));\n\
    \    }\n}\nlong fibfibTest(long n)\n{\n    if (n == 0)\n        return 0;\n  \
    \  if (n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n    else\n\
    \        return fibfibTest(n-1) + fibfibTest(n-2) + fibfibTest(n-3);\n}\n/*\n\
    Given a list of strings, write a function that returns a list of elements in the\
    \ same order as the input list, except for each element in the returned list that\
    \ has a matching element in the input list that is to the right of it.", "{\n\
    \    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 0;\n    if\
    \ (n == 2)\n        return 1;\n    n -= 2;\n    long f0 = 0;\n    long f1 = 1;\n\
    \    long f2 = 1;\n    long f3 = 2;\n    while (true) \n    {\n        if (n ==\
    \ 0)\n            return f3;\n        n--;\n        f0 = f1;\n        f1 = f2;\n\
    \        f2 = f3;\n        f3 = f0 + f1 + f2;\n    }\n}", "{\n    if (n < 3)\n\
    \        return n - 1;\n    \n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3);\n}", "{\n    if (n < 3)\n        return n;\n    else\n        return fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3);\n}", "{\n    long result = 0;\n    long a = 0;\n\
    \    long b = 0;\n    long c = 1;\n    if (n == 0) return result;\n    for (long\
    \ i = 2; i <= n; i++) \n    {\n        result = a + b + c;\n        a = b;\n \
    \       b = c;\n        c = result;\n    }\n    return result;\n}", "in \n{\n\
    \    return 0;\n}", "{\n    static long[long] cache;\n    static bool init;\n\
    \    if(!init) \n    {\n        init = true;\n        cache[0] = 0;\n        cache[1]\
    \ = 0;\n        cache[2] = 1;\n    }\n    if(cache.count) \n    {\n        return\
    \ cache[n];\n    }\n    else \n    {\n        long result = 0;\n        if(n >\
    \ 2) \n        {\n            result = fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    \        }\n        cache[n] = result;\n        return result;\n    }\n}", "{\n\
    \    if (n == 0) \n    {\n        return 0;\n    }\n    if (n == 1) \n    {\n\
    \        return 0;\n    }\n    if (n == 2) \n    {\n        return 1;\n    }\n\
    \    if (n > 2) \n    {\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3);\n    }\n}", "{\n  if (n == 0)\n  {\n    return 0;\n  }\n  else if (n ==\
    \ 1)\n  {\n    return 0;\n  }\n  else if (n == 2)\n  {\n    return 1;\n  }\n \
    \ else\n  {\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n  }\n}", "{\n\
    \tlong[] cache = new long[n + 1];\n\tcache[0] = 0;\n\tcache[1] = 0;\n\tcache[2]\
    \ = 1;\n\tfor (int i = 3; i <= n; i++)\n\t{\n\t\tcache[i] = cache[i - 1] + cache[i\
    \ - 2] + cache[i - 3];\n\t}\n\treturn cache[n];\n}", "{\n    if (n <= 2)\n   \
    \     return n - 1;\n    \n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3);\n}\n/*\nThis is a function which returns the sum of all elements of the\
    \ array.\n    >>> sum_array([1L,2L,3L])\n    6L\n    >>> sum_array([5L,2L,2L])\n\
    \    9L\n    >>> sum_array([1L,2L,3L,4L,5L,6L,7L,8L,9L,10L])\n    55L\n*/\nlong\
    \ sum_array(in long[] array) \n{\n    return array.sum;\n}\n/*\nAjacent elements\
    \ of an array are said to be in sequence if they are equal or in ascending order.\
    \ \nAn array is said to be in sequence if all of its elements are in sequence.\n\
    \    >>> is_in_sequence([0L,1L,2L,3L,4L,5L])\n    true\n    >>> is_in_sequence([0L,2L,1L,3L,4L,5L])\n\
    \    false\n    >>> is_in_sequence([0L,1L,2L,3L,4L,5L,6L,7L,8L,9L,10L])\n    true\n\
    \    >>> is_in_sequence([0L,1L,2L,3L,4L,5L,6L,7L,8L,9L,10L,11L,12L,13L,14L,15L,16L,17L,18L,19L,20L,21L,22L,23L,24L,25L,26L,27L,28L,29L,30L,31L,32L,33L,34L,35L,36L,37L,38L,39L,40L,41L,42L,43L,44L,45L,46L,47L,48L,49L,50L,51L,52L,53L,54L,55L,56L,57L,58L,59L,",
  "{\n    /*\n    The function computes the n-th fibfib number. As usual with functions\
    \ that can't return their result\n    immediately, it's best to start with a check\
    \ to see if we already know the answer.\n    */\n    if (n < 2)\n        return\
    \ 0;\n    else if (n == 2)\n        return 1;\n    \n    /* \n    To compute a\
    \ fibfib number, we'll need the last three fibfib numbers, so we'll store them\
    \ in a tuple.\n    Since a tuple can be easily constructed from a range, we'll\
    \ create one from the range n-3..n-1.\n    The initializer function will then\
    \ store the last three fibfib numbers in the tuple.\n    */\n    Tuple!(long,\
    \ long, long) fibfib = Tuple!(long, long, long)(iota(n-3, n)).init!((ref Tuple!(long,\
    \ long, long) t) {\n        /*\n        The first fibfib number is also the first\
    \ element of the tuple, so we start filling the tuple with the fibfib numbers.\n\
    \        */\n        t[0] = fibfib(n-3);\n        /*\n        The second fibfib\
    \ number is the sum of the first two fibfib numbers.\n        */\n        t[1]\
    \ = t[0] + fibfib(n-4);\n        /*\n        The third fibfib number is the sum\
    \ of the first three fibfib numbers.\n        */\n        t[2] = t[1] + t[0];\n\
    \        return t;\n    });\n    /*\n    The third fibfib number is the one we're\
    \ looking for, so we return it.\n    */\n    return fibfib[2];\n}", "{\n    long\
    \ a=0, b=0, c=1, d;\n    if(n <= 0)\n        return a;\n    if(n == 1)\n     \
    \   return b;\n    if(n == 2)\n        return c;\n    for(long i=3; i<=n; i++)\n\
    \    {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n\
    \    }\n    return d;\n}", "{\n    import std.math;\n    import std.typecons;\n\
    \    /*\n    The FibFib number sequence is a sequence similar to the Fibbonacci\
    \ sequnece that's defined as follows:\n        fibfib(0) == 0\n        fibfib(1)\
    \ == 0\n        fibfib(2) == 1\n        fibfib(n) == fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3).\n        Please write a function to efficiently compute the n-th\
    \ element of the fibfib number sequence.\n        >>> fibfib(1L)\n        0L\n\
    \        >>> fibfib(5L)\n        4L\n        >>> fibfib(8L)\n        24L\n   \
    \     \n    */\n    long fibfib(long n) \n    {\n        import std.math;\n  \
    \      import std.typecons;\n        /*\n        The FibFib number sequence is\
    \ a sequence similar to the Fibbonacci sequnece that's defined as follows:\n \
    \           fibfib(0) == 0\n            fibfib(1) == 0\n            fibfib(2)\
    \ == 1\n            fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  \
    \          Please write a function to efficiently compute the n-th element of\
    \ the fibfib number sequence.\n            >>> fibfib(1L)\n            0L\n  \
    \          >>> fibfib(5L)\n            4L\n            >>> fibfib(8L)\n      \
    \      24L\n            \n        */\n        long fibfib(long n) \n        {\n\
    \            import std.math;\n            import std.typecons;\n            /*\n\
    \            The FibFib number sequence is a sequence similar to the Fibbonacci\
    \ sequnece that's defined as follows:\n                fibfib(0) == 0\n      \
    \          fibfib(1) == 0\n                fibfib(2) == 1\n                fibfib(n)\
    \ == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n                Please write a\
    \ function to efficiently compute the n-th element of the fib", "{\n    if (n\
    \ < 0) \n    {\n        return -1;\n    } \n    else if (n == 0) \n    {\n   \
    \     return 0;\n    } \n    else if (n <= 2) \n    {\n        return 1;\n   \
    \ }\n    else \n    {\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3);\n    }\n}", "{\n    immutable long[] fibfib_1 = new long[3];\n    immutable\
    \ long[] fibfib_2 = new long[3];\n    return fibfib_iter(n, fibfib_1, fibfib_2);\n\
    }\nlong fibfib_iter(long n, in long[] fibfib_1, in long[] fibfib_2) \n{\n    if\
    \ (n <= 2) \n    {\n        return n - 1;\n    }\n    fibfib_1[0] = 0;\n    fibfib_1[1]\
    \ = 0;\n    fibfib_1[2] = 1;\n    for (size_t i = 3; i <= n; i++) \n    {\n  \
    \      fibfib_2[0] = fibfib_1[0] + fibfib_1[1] + fibfib_1[2];\n        fibfib_2[1]\
    \ = fibfib_1[0];\n        fibfib_2[2] = fibfib_1[1];\n        fibfib_1[0] = fibfib_2[0];\n\
    \        fibfib_1[1] = fibfib_2[1];\n        fibfib_1[2] = fibfib_2[2];\n    }\n\
    \    return fibfib_1[0];\n}\n/*\nWrite a function that returns the second largest\
    \ number in a list of integers. The function should assume that the size of the\
    \ list is at least 2.\n    >>> secondLargest([0, 5, 2, 3, 7, 5])\n    5\n    >>>\
    \ secondLargest([-2, 5, 2, 3, 7, 5])\n    5\n    >>> secondLargest([-2, 5, 2,\
    \ 3, 7, 5, 5])\n    5\n    >>> secondLargest([-2, 5, 2, 3, 7, 5, 5, 7])\n    7\n\
    */\nlong secondLargest(in long[] list) \n{\n    immutable long[] sorted_list =\
    \ list.sort();\n    return sorted_list[$ - 2];\n}\n/*\nWrite a function that returns\
    \ the largest and smallest integers in", "{\n    // if (n <= 2) \n    // {\n \
    \   //     return n;\n    // }\n    // auto a = 0, b = 1, c = 1;\n    // foreach\
    \ (i; 2..n) \n    // {\n    //     c = a + b + c;\n    //     a = b;\n    // \
    \    b = c;\n    // }\n    // return c;\n    if (n <= 2)\n    {\n        return\
    \ n;\n    }\n    auto a = 0, b = 1, c = 1;\n    for (long i = 2; i <= n; i++)\n\
    \    {\n        c = a + b + c;\n        a = b;\n        b = c;\n    }\n    return\
    \ c;\n}\n/*\n    Sieve of Eratosthenes:\n    Write an algorithm to generate all\
    \ prime numbers between 2 and a given number n.\n    Do not use the Sieve of Eratosthenes\
    \ algorithm, but generate all primes up to n as follows:\n    Start with an empty\
    \ list of primes p.\n    Starting with the number 2, incrementally append the\
    \ next higher number to p, \n    and remove from the list all multiples of the\
    \ number that you have just added.\n    Repeat this process until the list contains\
    \ all primes less than or equal to n.\n    >>> primes(10)\n    [2, 3, 5, 7]\n\
    \    >>> primes(20)\n    [2, 3, 5, 7, 11, 13, 17, 19]\n*/", "in {\n    assert(n\
    \ >= 0L);\n} \nout (result) {\n    assert(result >= 0L);\n}\nbody {\n    if (n\
    \ == 0L) {\n        return 0L;\n    } else if (n == 1L) {\n        return 0L;\n\
    \    } else if (n == 2L) {\n        return 1L;\n    } else {\n        return fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n    }\n}", "{\n    long prev = 0;\n    long\
    \ curr = 0;\n    long next = 1;\n    for (long i = 0; i < n; i++) \n    {\n  \
    \      prev = curr;\n        curr = next;\n        next = prev + curr + (i > 1\
    \ ? next : 0);\n    }\n    return curr;\n}", "{\n    int a, b, c, d;\n    a =\
    \ 0;\n    b = 0;\n    c = 1;\n    d = 1;\n    if (n < 3)\n        return a;\n\
    \    foreach (i; 3 .. n)\n    {\n        a = b;\n        b = c;\n        c = d;\n\
    \        d = a + b + c;\n    }\n    return d;\n}\n \n \n/*\n    (Medium)\n   \
    \ Please write a function which gets two strings as input,\n    and returns the\
    \ maximum possible number of different characters\n    between them.\n    >>>\
    \ maxDiffChars(\"kaabcd\",\"cbabcb\")\n    3\n    >>> maxDiffChars(\"a\",\"b\"\
    )\n    1\n    >>> maxDiffChars(\"\",\"\")\n    0\n*/", "{\n    long a, b, c, d;\n\
    \    a = 0;\n    b = 0;\n    c = 1;\n    d = 0;\n    foreach(i; 2..n)\n    {\n\
    \        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n\
    \    return d;\n}", "{\n    struct FibFib\n    {\n        long n;\n        long\
    \ value;\n    }\n    FibFib[] fib_arr = void;\n    if (n == 0L) \n    {\n    \
    \    return 0L;\n    }\n    else if (n == 1L) \n    {\n        return 0L;\n  \
    \  }\n    else if (n == 2L) \n    {\n        return 1L;\n    }\n    else if (n\
    \ == 3L) \n    {\n        return 1L;\n    }\n    else \n    {\n        if (n <\
    \ fib_arr.length) \n        {\n            return fib_arr[n].value;\n        }\n\
    \        else \n        {\n            long prev = fibfib(n - 1L);\n         \
    \   long prev2 = fibfib(n - 2L);\n            long prev3 = fibfib(n - 3L);\n \
    \           auto cur = FibFib(n, prev + prev2 + prev3);\n            fib_arr ~=\
    \ cur;\n            return cur.value;\n        }\n    }\n}\n/*\n>>> fibfib(100L)\n\
    354224848179261915075L\n>>> fibfib(200L)\n280571172992510140037611932413038677189525L\n\
    >>> fibfib(300L)\n222232244629420445529739893461909967206666939096499764990979600L\n\
    >>> fibfib(400L)\n176023680645013966468226945392411250770384383304492191886725992896575345044216019675L\n\
    */\nversion(optimize)\nlong fibfib(long n) {\n    switch (n) {\n        case 0L:\
    \ return 0L;\n        case 1L: return 0L;\n        case 2L: return 1L;\n     \
    \   case 3L: return 1L;\n        default:\n            // switch on the last two\
    \ bits of n,\n            // these are always 1 or 2\n            switch (n &\
    \ 3L) {\n                case 1L:\n                    // f(n) = f(n-", "{\n\t\
    if (n == 0) \n\t{\n\t\treturn 0;\n\t}\n\telse if (n == 1) \n\t{\n\t\treturn 0;\n\
    \t}\n\telse if (n == 2) \n\t{\n\t\treturn 1;\n\t}\n\telse \n\t{\n\t\treturn fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3);\n\t}\n}", "{\n    import std.stdio : writeln;\n\
    \    if (n == 0) return 0;\n    else if (n == 1) return 0;\n    else if (n ==\
    \ 2) return 1;\n    else return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}",
  "{\n    long a = 0L;\n    long b = 0L;\n    long c = 1L;\n    long d = 0L;\n   \
    \ long i = 2L;\n    while (i <= n)\n    {\n        d = a + b + c;\n        a =\
    \ b;\n        b = c;\n        c = d;\n        i += 1L;\n    }\n    return d;\n\
    }\n/*\nA palindrome is a word or phrase that reads the same forwards and backwards.\n\
    \    Given a string, s, return true if s is a palindrome.\n    >>> isPalindrome(\"\
    Hello\")\n    false\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"\
    a x a\")\n    true\n*/", "{\n    if (n <= 2) \n    {\n        return n - 1;\n\
    \    }\n    else \n    {\n        long x = 1;\n        long y = 1;\n        long\
    \ z = 2;\n        for (size_t i = 3; i < n; i++) \n        {\n            x =\
    \ y;\n            y = z;\n            z = x + y + z;\n        }\n        return\
    \ z;\n    }\n}\n/*\nWrite a function that takes the following text:\n\"Lorem ipsum\
    \ dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt\
    \ ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation\
    \ ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor\
    \ in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\
    \ Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\
    \ mollit anim id est laborum.\"\nand returns the top n words and their counts.\
    \ For example, if n was 5, the function would return something like:\n    [\n\
    \        (\"Lorem\", 1),\n        (\"ipsum\", 1),\n        (\"dolor\", 3),\n \
    \       (\"sit\", 1),\n        (\"amet\", 1)\n    ]\n*/\nTuple!(string, size_t)[]\
    \ topnWords(string input, size_t n) \n{\n    auto tokens = input.split(\" \");\n\
    \    auto counts = tokens.totuple.group.count;\n    auto sorted = sort(counts.by!(a\
    \ => a[1]));\n    return take(sorted, n);\n}\n/*\nIn the D language, a type can\
    \ be converted to an immutable type with \"immutable(type)\".\nA type can be converted\
    \ to a shared type with \"shared(type)\".\nPlease write a function that takes\
    \ a type \"T\" and returns a function that takes a variable of type T\nand returns\
    \ a shared variable.", "{\n    long[] newArray = new long[n+1];\n    newArray[0]\
    \ = 0;\n    newArray[1] = 0;\n    newArray[2] = 1;\n    for(int i = 3; i <= n;\
    \ i++) \n    {\n        newArray[i] = newArray[i-1] + newArray[i-2] + newArray[i-3];\n\
    \    }\n    return newArray[n];\n}", "{\n    long fib1 = 0;\n    long fib2 = 0;\n\
    \    long fib3 = 1;\n    long fib = 0;\n    if (n < 2) return 0;\n    if (n ==\
    \ 2) return 1;\n    for (int i = 3; i <= n; i++) {\n        fib = fib1 + fib2\
    \ + fib3;\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib;\n \
    \   }\n    return fib;\n}\n/*\nBy listing the first six prime numbers: 2, 3, 5,\
    \ 7, 11, and 13, we can see that the 6th prime is 13.\nWhat is the nth prime number?",
  "{\n\tversion(none)\n\t{\n\t\timport std.algorithm : map;\n\t\tauto fibfib = nth(map!((a,b,c)=>a+b+c)([0,0,1]));\n\
    \t\treturn fibfib(n);\n\t}\n\tif(n < 3) return 0;\n\tlong a = 0, b = 0, c = 1;\n\
    \tforeach(i; 3..n)\n\t{\n\t\tlong next = a + b + c;\n\t\ta = b;\n\t\tb = c;\n\t\
    \tc = next;\n\t}\n\treturn c;\n}\n// Test", "{\n    if (n == 0L)\n        return\
    \ 0L;\n    if (n == 1L)\n        return 0L;\n    if (n == 2L)\n        return\
    \ 1L;\n    return fibfib(n - 1L) + fibfib(n - 2L) + fibfib(n - 3L);\n}", "{\n\t\
    long pp = 0,p = 0, f = 1;\n\tforeach(i; 0 .. n) \n\t{\n\t\tpp = p;\n\t\tp = f;\n\
    \t\tf = pp + p + i;\n\t}\n\treturn f;\n}\n/*\nThe prime number sequence is a sequence\
    \ of numbers which are divisible only by 1 and themselves.\nThe n-th element of\
    \ the prime number sequence is the smallest prime number that is greater than\
    \ all\nthe first n-1 elements of the sequence. E.g.:\n    prime(1) == 2\n    prime(2)\
    \ == 3\n    prime(3) == 5\n    prime(4) == 7\n    prime(5) == 11\n    prime(6)\
    \ == 13\n    prime(7) == 17\n    Please write a function to efficiently compute\
    \ the n-th element of the prime number sequence.\n    >>> prime(1L)\n    2L\n\
    \    >>> prime(2L)\n    3L\n    >>> prime(3L)\n    5L\n    >>> prime(4L)\n   \
    \ 7L\n    >>> prime(5L)\n    11L\n*/", "{\n    long value = 0;\n    if (n == 0)\
    \ \n    {\n        value = 0;\n    } \n    else if (n == 1) \n    {\n        value\
    \ = 0;\n    } \n    else if (n == 2) \n    {\n        value = 1;\n    } \n   \
    \ else \n    {\n        value = fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n\
    \    }\n    return value;\n}", "{\n    if (n < 3)\n        return n;\n    else\
    \ \n    {\n        long f1 = 0;\n        long f2 = 1;\n        long f3 = 1;\n\
    \        long fn = f1 + f2 + f3;\n        for (long i = 3; i < n; i++) \n    \
    \    {\n            f1 = f2;\n            f2 = f3;\n            f3 = fn;\n   \
    \         fn = f1 + f2 + f3;\n        }\n        return fn;\n    }\n}", "{\n \
    \   if (n < 2) \n    {\n        return 0;\n    }\n    if (n == 2) \n    {\n  \
    \      return 1;\n    }\n    // by using long [int](n-1+2) instead of long [int](n+1)\
    \ we\n    // basically use an std.array.array that is initialized with 0\n   \
    \ // which is the default value for type T.\n    // std.array.array has a [0..$]\
    \ range which acts as a pointer\n    // and by assigning (fib[i-1] + fib[i-2]\
    \ + fib[i-3])\n    // we effectively compute the value for each index.\n    //\
    \ at the end we return fib[i-1]\n    auto fib = new long[int](n-1+2);\n    fib[2]\
    \ = 1;\n    foreach (i; 2..$fib) \n    {\n        fib[i] = fib[i-1] + fib[i-2]\
    \ + fib[i-3];\n    }\n    return fib[$fib-1];\n}\n \n/*\nNote:\n1. fibfib(long\
    \ n) and fibfib2(long n) both work, but fibfib2 is 10x faster\n2. fibfib2(long\
    \ n) is slightly faster than fibfib3(long n) (in a way fibfib3 is a slight optimization\
    \ of fibfib2)\n3. fibfib(long n) is 100x slower than fibfib2(long n)\n4. c(long\
    \ n) is much faster than fibfib2(long n)\n5. for c(long n) we have to use a cache\
    \ and c2(long n) is not much faster than c(long n)\n6. c3(long n) is as fast as\
    \ c(long n) \n*/", "{\n    if (n == 0) \n    {\n        return 0;\n    } \n  \
    \  else if (n == 1) \n    {\n        return 0;\n    } \n    else if (n == 2) \n\
    \    {\n        return 1;\n    } \n    else \n    {\n        return fibfib(n -\
    \ 1) + fibfib(n - 2) + fibfib(n - 3);\n    }\n}\n \n// Test\nunittest \n{\n  \
    \  import std.stdio;\n    import std.random;\n    writeln(fibfib(1L)); // 0L\n\
    \    writeln(fibfib(5L)); // 4L\n    writeln(fibfib(8L)); // 24L\n}\n \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\
    \ \n/*\nPlease write a program to generate a pattern like the following:\nInput:\n\
    \    3\nOutput:\n    A\n    BB\n    CCC\n*/", "{\n    long a = 0;\n    long b\
    \ = 0;\n    long c = 1;\n    for (long i = 0; i < n - 1; i++) \n    {\n      \
    \  long new = a + b + c;\n        a = b;\n        b = c;\n        c = new;\n \
    \   }\n    return c;\n}", "{\n    if (n < 3) return n;\n    return fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3);\n}\n/*\nA palindrome is a word, phrase, number,\
    \ or other sequence of characters which reads the same backward or forward.\n\
    \    Write a function to find the longest palindromic substring in a given string.\n\
    \    >>> longestPalindrome(\"a\")\n    \"a\"\n    >>> longestPalindrome(\"aa\"\
    )\n    \"aa\"\n    >>> longestPalindrome(\"baa\")\n    \"aa\"\n    >>> longestPalindrome(\"\
    aab\")\n    \"aa\"\n    >>> longestPalindrome(\"baabcd\")\n    \"baab\"\n    >>>\
    \ longestPalindrome(\"baablkj12345432133d\")\n    \"123454321\"\n*/\nstring longestPalindrome(string\
    \ s)\n{\n    // improve this algorithm, to avoid the extra cost\n    size_t start\
    \ = 0;\n    size_t end = s.length() - 1;\n    string tmp = s;\n    std.algorithm.reverse(tmp);\n\
    \    for (; start < end; start++, end--) {\n        if (s[start] != tmp[end])\
    \ {\n            break;\n        }\n    }\n    return s[start..end];\n}\n/*\n\
    You are given an n x n 2D matrix representing an image.\n    Rotate the image\
    \ by 90 degrees (clockwise).\n    Note:\n    You have to rotate the image in-place,\
    \ which means you have to modify the input 2D matrix directly. \n    DO NOT allocate\
    \ another 2D matrix and do the rotation.\n    >>> rotate([[1,2,3],[4,5,6],[7,8,9]])\n\
    \    [[7,4,1],[8,5,2],[9,6,3]]\n    >>> rotate([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])\n\
    \    [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n*/\n", "{\n    long a =\
    \ 0;\n    long b = 0;\n    long c = 1;\n    long d = 0;\n    auto i = 0L;\n  \
    \  auto j = 0L;\n    return n > 2\n        ? ( n % 2 == 0\n            ? fibfib(\
    \ n / 2 ) * fibfib( n / 2 + 1 ) + fibfib( n / 2 - 1 ) * fibfib( n / 2 - 1 )\n\
    \            : fibfib( n / 2 ) * fibfib( n / 2 + 1 ) + fibfib( n / 2 ) * fibfib(\
    \ n / 2 - 1 )\n          )\n        : n;\n}", "{\n    if (n < 2) \n    {\n   \
    \     return 0;\n    } \n    else if (n == 2) \n    {\n        return 1;\n   \
    \ }\n    else \n    {\n        long a = 0, b = 0, c = 1;\n        for (long i\
    \ = 3; i <= n; i++) \n        {\n            long d = a + b + c;\n           \
    \ a = b;\n            b = c;\n            c = d;\n        }\n        return c;\n\
    \    }\n}\n/*\n    Create a function with the following signature:\n        int\
    \ solve(int N);\n    where N is the number of rows in a triangle. The function\
    \ should return the maximum sum for a path from the top to the bottom.\n    Example:\
    \ solve(5) returns 14, because 2 + 4 + 6 + 4 = 16\n    >>> solve(5)\n    14\n\
    */", "{\n    long count = 0;\n    long a = 0;\n    long b = 0;\n    long c = 1;\n\
    \    long d = 0;\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if\
    \ (n == 2) return 1;\n    n = n - 2;\n    while (count < n)\n    {\n        d\
    \ = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n        count\
    \ = count + 1;\n    }\n    return d;\n}\n//  -----------------\n//  Example Tests.\n\
    //  -----------------\nUNIT_TEST_CASE(FibFibTest) \n{\n    // Basic test.\n  \
    \  TEST_EQUAL(fibfib(0L), 0L);\n    TEST_EQUAL(fibfib(1L), 0L);\n    TEST_EQUAL(fibfib(2L),\
    \ 1L);\n    TEST_EQUAL(fibfib(3L), 1L);\n    TEST_EQUAL(fibfib(4L), 2L);\n   \
    \ TEST_EQUAL(fibfib(5L), 4L);\n    TEST_EQUAL(fibfib(6L), 7L);\n    TEST_EQUAL(fibfib(7L),\
    \ 13L);\n    TEST_EQUAL(fibfib(8L), 24L);\n    TEST_EQUAL(fibfib(9L), 44L);\n\
    \    TEST_EQUAL(fibfib(10L), 81L);\n    TEST_EQUAL(fibfib(11L), 149L);\n    TEST_EQUAL(fibfib(12L),\
    \ 274L);\n    TEST_EQUAL(fibfib(13L), 504L);\n    TEST_EQUAL(fibfib(14L), 927L);\n\
    \    TEST_EQUAL(fibfib(15L), 1705L);\n    TEST_EQUAL(fibfib(16L), 3136L);\n  \
    \  TEST_EQUAL(fib", "{\n\tif (n <= 2)\n\t\treturn n == 2 ? 1 : 0;\n\tlong a, b,\
    \ c;\n\tlong i = 0;\n\tlong j = 3;\n\ta = 0;\n\tb = 0;\n\tc = 1;\n\twhile (i <\
    \ n - 3) \n\t{\n\t\tlong d = a + b + c;\n\t\ta = b;\n\t\tb = c;\n\t\tc = d;\n\t\
    \ti++;\n\t\tj++;\n\t}\n\treturn c;\n}", "{\n    static Tuple!(long, long, long)\
    \ fibfib(ulong n) \n    {\n        return n == 0 ? Tuple!(0L, 0L, 0L) :\n    \
    \        n == 1 ? Tuple!(0L, 0L, 1L) :\n            n == 2 ? Tuple!(0L, 1L, 1L)\
    \ :\n            Tuple!(fibfib(n - 1)[1], fibfib(n - 1)[2], fibfib(n - 1)[1] +\
    \ fibfib(n - 1)[2] + fibfib(n - 1)[0]);\n    }\n    return fibfib(cast(ulong)n)[2];\n\
    }", "{\n    auto dp = new long[n+1];\n    dp[0] = 0;\n    dp[1] = 0;\n    dp[2]\
    \ = 1;\n    for(int i = 3; i <= n; i++) \n    {\n        dp[i] = dp[i-1] + dp[i-2]\
    \ + dp[i-3];\n    }\n    return dp[n];\n}", "{\n  long[] fibfib_arr = new long[3];\n\
    \  fibfib_arr[0] = 0;\n  fibfib_arr[1] = 0;\n  fibfib_arr[2] = 1;\n  for (long\
    \ i = 3; i <= n; i++)\n  {\n    long temp = fibfib_arr[0] + fibfib_arr[1] + fibfib_arr[2];\n\
    \    fibfib_arr[0] = fibfib_arr[1];\n    fibfib_arr[1] = fibfib_arr[2];\n    fibfib_arr[2]\
    \ = temp;\n  }\n  return fibfib_arr[2];\n}", "{\n    if (n == 0) return 0;\n \
    \   if (n == 1) return 0;\n    if (n == 2) return 1;\n    return fibfib(n-1) +\
    \ fibfib(n-2) + fibfib(n-3);\n}\n//Fastest\nlong fibfib(long n) \n{\n    long[]\
    \ arr = [0, 0, 1];\n    for (long i = 3; i <= n; i++) \n    {\n        long a\
    \ = arr[0];\n        long b = arr[1];\n        long c = arr[2];\n        arr[0]\
    \ = b;\n        arr[1] = c;\n        arr[2] = a + b + c;\n    }\n    return arr[2];\n\
    }\nlong fibfib(long n) \n{\n    if (n <= 2) return n - 1;\n    else return fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\nlong fibfib(long n) \n{\n    if (n\
    \ <= 2) return n - 1;\n    long[] fibs = new long[n];\n    fibs[0] = 0;\n    fibs[1]\
    \ = 0;\n    fibs[2] = 1;\n    for (int i = 3; i < n; i++) \n    {\n        fibs[i]\
    \ = fibs[i - 1] + fibs[i - 2] + fibs[i - 3];\n    }\n    return fibs[n - 1];\n\
    }\nlong fibfib(long n) \n{\n    if (n <= 2) return n - 1;\n    long[] fibs = new\
    \ long[n];\n    fibs[0] = 0;\n    fibs[1] = 0;\n    fibs[2] = 1;\n    foreach\
    \ (i; 3 .. n) \n    {\n        fibs[i] = fibs[i - 1] + fibs[i - 2] + fibs[i -\
    \ 3];\n    }\n    return fibs[n - 1];\n}\nlong fibfib(long n) \n", "{\n    if\
    \ (n < 2) \n    {\n        return 0;\n    }\n    else if (n == 2) \n    {\n  \
    \      return 1;\n    }\n    else \n    {\n        long n_1 = 0;\n        long\
    \ n_2 = 0;\n        long n_3 = 1;\n        long curr = 0;\n        for (int i\
    \ = 3; i <= n; i++) \n        {\n            curr = n_1 + n_2 + n_3;\n       \
    \     n_1 = n_2;\n            n_2 = n_3;\n            n_3 = curr;\n        }\n\
    \        return curr;\n    }\n}", "{\n    if (n <= 2)\n        return n - 1;\n\
    \    auto a = 1L;\n    auto b = 1L;\n    auto c = 2L;\n    auto d = 4L;\n    auto\
    \ e = 6L;\n    auto m = (typeof(n))(uint.max - 1);\n    for (n -= 3; n > 0; n\
    \ >>= 1)\n    {\n        if (n & 1)\n        {\n            e = b * e + c * d\
    \ + a * d;\n            d = b * d + c * c;\n            c = b * c + a * c;\n \
    \           b = b * b;\n        }\n        a = a * a + b * c;\n        b = b *\
    \ (c + c) + a * d;\n        c = c * c + a * e;\n        d = d * (e + e) + c *\
    \ c;\n        e = e * e + d * d;\n        auto q = (a & m) + (b >> typeof(a).sizeof\
    \ * 8);\n        a = b & m;\n        b = q;\n        q = (c & m) + (d >> typeof(c).sizeof\
    \ * 8);\n        c = d & m;\n        d = q;\n        q = (e & m) + (a >> typeof(e).sizeof\
    \ * 8);\n        e = a & m;\n        a = q;\n    }\n    return e;\n}\n/*\nWrite\
    \ a function that takes a positive integer and returns the next palindromic number.\n\
    \    >>> palindrome(123)\n    131\n    >>> palindrome(1)\n    2\n    >>> palindrome(2)\n\
    \    3\n    >>> palindrome(11)\n    22\n    >>> palindrome(1354)\n    1441\n*/\n\
    long palindrome(long n)\n{\n    if (n <= 10)\n        return n;\n    n += 1;\n\
    \    auto s = to!string(n);\n    auto ss = s.dup;\n    if (ss.length % 2)\n  \
    \      ss.remove(0, 1);\n    while (true)\n    {", "{\n    if (n < 2) \n    {\n\
    \        return 0;\n    }\n    if (n == 2) \n    {\n        return 1;\n    }\n\
    \    long last = 0;\n    long current = 1;\n    long next = 1;\n    long tmp;\n\
    \    for (long i = 3; i <= n; i++) \n    {\n        tmp = current;\n        current\
    \ = next;\n        next = last + current + tmp;\n        last = tmp;\n    }\n\
    \    return next;\n}", "{\n    switch(n) \n    {\n        case 0:\n          \
    \  return 0;\n        case 1:\n            return 0;\n        case 2:\n      \
    \      return 1;\n        default:\n            return fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3);\n    }\n}", "{\n\tint[long] cache = [0L:0L, 1L:0L, 2L:1L];\n\t\
    return fibfib(n, cache);\n}", "{\n    static long first = 0;\n    static long\
    \ second = 0;\n    static long third = 1;\n    static long fib = 0;\n    for (long\
    \ i = 0; i < n; i++)\n    {\n        first = second;\n        second = third;\n\
    \        third = fib;\n        fib = first + second + third;\n    }\n    return\
    \ fib;\n}", "{\n    if (n < 3)\n        return n;\n    // We'll use an array to\
    \ keep track of the last 3 values.\n    long[3] fibs;\n    fibs[0] = 0;\n    fibs[1]\
    \ = 0;\n    fibs[2] = 1;\n    while (n-- > 3) \n    {\n        long next = fibs[0]\
    \ + fibs[1] + fibs[2];\n        fibs[0] = fibs[1];\n        fibs[1] = fibs[2];\n\
    \        fibs[2] = next;\n    }\n    return fibs[2];\n}", "{\n    int n0 = 0;\n\
    \    int n1 = 0;\n    int n2 = 1;\n    for (int i = 0; i < n - 1; i++)\n    {\n\
    \        int tmp = n0 + n1 + n2;\n        n0 = n1;\n        n1 = n2;\n       \
    \ n2 = tmp;\n    }\n    return n2;\n}", "{\n\tlong fibfib0 = 0L;\n\tlong fibfib1\
    \ = 0L;\n\tlong fibfib2 = 1L;\n\tif (n == 0L) return fibfib0;\n\tif (n == 1L)\
    \ return fibfib1;\n\tfor (long i = 2L; i <= n; i += 1L) \n\t{\n\t\timmutable long\
    \ fibfib3 = fibfib0 + fibfib1 + fibfib2;\n\t\tfibfib0 = fibfib1;\n\t\tfibfib1\
    \ = fibfib2;\n\t\tfibfib2 = fibfib3;\n\t}\n\treturn fibfib2;\n}\n//\nlong fibfib2(long\
    \ n) \n{\n\tlong fibfib0 = 0L;\n\tlong fibfib1 = 0L;\n\tlong fibfib2 = 1L;\n\t\
    while (n >= 0L) \n\t{\n\t\timmutable long fibfib3 = fibfib0 + fibfib1 + fibfib2;\n\
    \t\tfibfib0 = fibfib1;\n\t\tfibfib1 = fibfib2;\n\t\tfibfib2 = fibfib3;\n\t\tn\
    \ -= 1L;\n\t}\n\treturn fibfib2;\n}\n/*\nWrite a function in your favorite language\
    \ that implements the following rules:\nGiven a number n,\n    1. If n is divisible\
    \ by 3, return \"Fizz\"\n    2. If n is divisible by 5, return \"Buzz\"\n    3.\
    \ If n is divisible by 3 and 5, return \"FizzBuzz\"\n    4. Otherwise, return\
    \ the number.\n    \n    >>> fizzBuzz(0)\n    0\n    >>> fizzBuzz(1)\n    1\n\
    \    >>> fizzBuzz(3)\n    \"Fizz\"\n    >>> fizzBuzz(5)\n    \"Buzz\"\n    >>>\
    \ fizzBuzz(10)\n    \"Buzz\"\n    >>> fizzBuzz(15)\n    \"FizzBuzz\"\n    >>>\
    \ fizzBuzz(16)\n    16\n    >>> [fizzBuzz(n) for", "{\n    if (n <= 2)\n     \
    \   return n-1;\n    long a = 0;\n    long b = 1;\n    long c = 1;\n    for (long\
    \ i = 3; i <= n; i++)\n    {\n        auto tmp = c;\n        c = a + b + c;\n\
    \        a = b;\n        b = tmp;\n    }\n    return c;\n}\n/*\nThe FibFib number\
    \ sequence is a sequence similar to the Fibbonacci sequnece that's defined as\
    \ follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n)\
    \ == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to\
    \ efficiently compute the n-th element of the fibfib number sequence.\n    >>>\
    \ fibfib(1L)\n    0L\n    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n    24L\n\
    \    \n*/\nlong fibfib2(long n)\n{\n    if (n == 0)\n        return 0;\n    long\
    \ a = 0;\n    long b = 0;\n    long c = 1;\n    for (long i = 3; i <= n; i++)\n\
    \    {\n        long tmp = c;\n        c = a + b + c;\n        a = b;\n      \
    \  b = tmp;\n    }\n    return c;\n}\n/*\n        You are given a 2D array of\
    \ 1's and 0's. Please write a function that takes as input an array A and returns\
    \ an array B such that B[i][j] is the number of 1's in a subarray of A centered\
    \ around A[i][j].\n    >>> func2d([[1,0,1], [0,1,0], [1,0,1]])\n    [[3, 2, 3],\
    \ [2, 4, 2], [3, 2, 3]]\n    >>> func2d([[1,0,0], [0,0,0], [0,0,1]])\n    [[1,\
    \ 0, 0], [0", "{\n    if (n < 3) \n    {\n        return n == 0 ? 0 : 1;\n   \
    \ }\n    auto temp = Fibonacci!(3, long, long);\n    return temp.at(n);\n}\n//\n\
    long fibfib_v2(long n) \n{\n    if (n < 3) \n    {\n        return n == 0 ? 0\
    \ : 1;\n    }\n    long prev3 = 0;\n    long prev2 = 1;\n    long prev1 = 1;\n\
    \    long result = 2;\n    foreach (i; 3 .. n + 1) \n    {\n        result = prev1\
    \ + prev2 + prev3;\n        prev3 = prev2;\n        prev2 = prev1;\n        prev1\
    \ = result;\n    }\n    return result;\n}\n//\nlong fibfib_v3(long n) \n{\n  \
    \  if (n < 3) \n    {\n        return n == 0 ? 0 : 1;\n    }\n    auto tab = [0,\
    \ 1, 1];\n    foreach (i; 3 .. n + 1) \n    {\n        tab ~= tab[$ - 1] + tab[$\
    \ - 2] + tab[$ - 3];\n    }\n    return tab[$ - 1];\n}\n//\nlong fibfib_v4(long\
    \ n) \n{\n    if (n < 3) \n    {\n        return n == 0 ? 0 : 1;\n    }\n    long\
    \ prev3 = 0;\n    long prev2 = 1;\n    long prev1 = 1;\n    long result = 2;\n\
    \    auto tmp = prev3;\n    auto i = 3;\n    while (i <= n) \n    {\n        i++;\n\
    \        tmp = prev1;\n        prev1 = prev1 + prev2 + prev3;\n        prev3 =\
    \ prev2;\n        prev2 = tmp;\n    }\n    return prev1;\n}\n//\nlong fibfib_v5(long\
    \ n) \n{\n    if (n < 3) \n    {\n        return n == 0 ? 0 : 1;\n    }\n    long\
    \ prev3 = 0;\n    long prev2 =", "{\n    long a = 0;\n    long b = 0;\n    long\
    \ c = 1;\n    long tmp = 0;\n    while (n > 0) \n    {\n        tmp = a + b +\
    \ c;\n        a = b;\n        b = c;\n        c = tmp;\n        n -= 1;\n    }\n\
    \    return tmp;\n}", "{\n    if (n == 0L) return 0L;\n    if (n == 1L) return\
    \ 0L;\n    if (n == 2L) return 1L;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }", "{\n    import std.math;\n    import std.typecons;\n    struct FibFibFib \n\
    \    {\n        long fibfib1;\n        long fibfib2;\n        long fibfib3;\n\
    \        @property long fibfib() { return fibfib1 + fibfib2 + fibfib3; }\n   \
    \ }\n    auto fibfib = new FibFibFib();\n    if (n < 2) \n    {\n        return\
    \ n;\n    }\n    fibfib.fibfib1 = 0;\n    fibfib.fibfib2 = 1;\n    fibfib.fibfib3\
    \ = 1;\n    for (long i = 2; i < n; i++) \n    {\n        auto tmp = fibfib.fibfib;\n\
    \        fibfib.fibfib1 = fibfib.fibfib2;\n        fibfib.fibfib2 = fibfib.fibfib3;\n\
    \        fibfib.fibfib3 = tmp;\n    }\n    return fibfib.fibfib;\n}\n/*\nWrite\
    \ a function to print out all the divisors of a prime number except for 1 and\
    \ the number itself.\n    >>> divisors(1)\n    >>> divisors(2)\n    >>> divisors(3)\n\
    \    >>> divisors(4)\n    2\n    >>> divisors(9)\n    3\n    >>> divisors(15)\n\
    \    3 5\n    >>> divisors(241)\n    3 7 11 241\n*/", "{\n    //long prevprev\
    \ = 0;\n    //long prev = 0;\n    //long current = 1;\n    int prevprev = 0;\n\
    \    int prev = 0;\n    int current = 1;\n    for (int i = 2; i <= n; i++) \n\
    \    {\n        int temp = current;\n        current = prev + prevprev + current;\n\
    \        prevprev = prev;\n        prev = temp;\n    }\n    return current;\n}",
  "{\n    // Fibonacci:                  0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,\
    \ 144, 233, 377, 610, 987\n    // modified fibonacci:         0, 0, 1, 1, 2, 4,\
    \ 7, 12, 20, 33, 54, 88, 143, 232, 376, 609, 986\n    // modified fibonacci +\
    \ 2:     0, 0, 2, 3, 5, 9, 16, 28, 48, 81, 135, 224, 369, 603, 982, 1605\n   \
    \ // modified fibonacci + 3:     0, 0, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,\
    \ 377, 610, 987, 1597\n    // modified fibonacci + 4:     0, 0, 4, 7, 12, 20,\
    \ 33, 54, 88, 143, 232, 376, 609, 986, 1601\n    // modified fibonacci + 5:  \
    \   0, 0, 5, 9, 16, 28, 48, 81, 135, 224, 369, 603, 982, 1605, 2687\n    // modified\
    \ fibonacci + 6:     0, 0, 6, 11, 21, 39, 70, 121, 203, 334, 547, 881, 1428, 2310,\
    \ 3758\n    // modified fibonacci + 7:     0, 0, 7, 13, 24, 44, 79, 135, 230,\
    \ 385, 624, 1023, 1658, 2706, 4365\n    // modified fibonacci + 8:     0, 0, 8,\
    \ 16, 28, 48, 81, 135, 224, 369, 603, 982, 1605, 2687, 4393\n    // modified fibonacci\
    \ + 9:     0, 0, 9, 17, 30, 52, 89, 151, 250, 409, 659, 1069, 1731, 2802, 4533\n\
    \    // modified fibonacci + 10:    0, 0, 10, 19, 34, 58, 99, 167, 276, 455, 735,\
    \ 1191, 1953, 3179, 5132\n    // modified fibonacci + 11:    0, 0, 11, 21, 39,\
    \ 70, 121", "{\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n\
    \ == 2) return 1;\n    long[] fib = new long[3];\n    fib[0] = 0;\n    fib[1]\
    \ = 0;\n    fib[2] = 1;\n    for (size_t i = 3; i <= n; i++)\n    {\n        fib[0]\
    \ = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[1] + fib[0] + fib[2];\n\
    \    }\n    return fib[2];\n}\n/*\nIn the Fibonacci sequence, each term is the\
    \ sum of the previous two terms. The first few terms are 1, 1, 2, 3, 5, 8, 13,\
    \ 21, 34, 55, 89, 144.", "{\n\tlong[] Fibfib = new long[3];\n\tFibfib[0] = 0;\n\
    \tFibfib[1] = 0;\n\tFibfib[2] = 1;\n\tif (n <= 2)\n\t{\n\t\treturn Fibfib[(int)n];\n\
    \t}\n\telse\n\t{\n\t\treturn fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n\t\
    }\n}", "{\n\tif (n <= 1) return 0;\n\tif (n == 2) return 1;\n\tlong a = 0;\n\t\
    long b = 0;\n\tlong c = 1;\n\tlong res = 0;\n\tfor (long i = 2; i < n; i++) \n\
    \t{\n\t\tres = a + b + c;\n\t\ta = b;\n\t\tb = c;\n\t\tc = res;\n\t}\n\treturn\
    \ res;\n}", "{\n    if (n == 0L) \n    {\n        return 0L;\n    } \n    else\
    \ if (n == 1L) \n    {\n        return 0L;\n    } \n    else if (n == 2L) \n \
    \   {\n        return 1L;\n    } \n    else if (n > 2L) \n    {\n        return\
    \ fibfib(n - 1L) + fibfib(n - 2L) + fibfib(n - 3L);\n    }\n}", "{\n    long[]\
    \ fibfib_cache = new long[cast(int)n+1];\n    fibfib_cache[0] = 0;\n    fibfib_cache[1]\
    \ = 0;\n    fibfib_cache[2] = 1;\n    for(int i = 3; i <= n; i++)\n    {\n   \
    \     fibfib_cache[i] = fibfib_cache[i-1] + fibfib_cache[i-2] + fibfib_cache[i-3];\n\
    \    }\n    return fibfib_cache[cast(int)n];\n}\n/*\n    3.2 \n    Write a function\
    \ to find the nth element of the sequence defined by\n        a(0) = 1\n     \
    \   a(1) = 1\n        a(n) = a(n-1) + a(n-2)\n    which does not recurse.\n  \
    \  >>> findseq(0L)\n    1L\n    >>> findseq(1L)\n    1L\n    >>> findseq(2L)\n\
    \    2L\n    >>> findseq(3L)\n    3L\n    >>> findseq(4L)\n    5L\n    >>> findseq(5L)\n\
    \    8L\n*/\nlong findseq(long n)\n{\n    long[] cache = new long[cast(int)n+1];\n\
    \    cache[0] = 1;\n    cache[1] = 1;\n    for(int i = 2; i <= n; i++)\n    {\n\
    \        cache[i] = cache[i-1] + cache[i-2];\n    }\n    return cache[cast(int)n];\n\
    }\n/*\n    4.3 \n    Write a function to compute a(n), where a(0) = 1, and\n \
    \       a(n) = a(n-1) + n^2, if n is even\n        a(n) = a(n-1) + n, if n is\
    \ odd\n    >>> a(0L)\n    1L\n    >>> a(3L)\n    19L\n    >>> a(4L)\n    30L\n\
    \    >>> a(5L)\n    55L\n    >>> a", "{\n    if (n == 0) return 0;\n    if (n\
    \ == 1) return 0;\n    if (n == 2) return 1;\n    if (n == 3) return 1;\n    else\
    \ return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n\tif (n == 0)\n\t\t\
    return 0;\n\telse if (n == 1)\n\t\treturn 0;\n\telse if (n == 2)\n\t\treturn 1;\n\
    \telse\n\t\treturn fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}", "{\n  \
    \  // Write your code here\n    if (n < 0) {\n        assert(false, \"invalid\
    \ input\");\n    }\n    else if (n == 0 || n == 1) {\n        return 0;\n    }\n\
    \    else if (n == 2) {\n        return 1;\n    }\n    else {\n        return\
    \ fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n    }\n}\n/*\nFibonacci numbers are\
    \ a sequence in which each number is the sum of the two previous numbers.\nThe\
    \ first two Fibonacci numbers are 0 and 1.\nThe nth Fibonacci number is the sum\
    \ of the (n-1)th and (n-2)th Fibonacci numbers.\n    >>> fib(1)\n    0\n    >>>\
    \ fib(2)\n    1\n    >>> fib(8)\n    13\n*/\nlong fib(long n)\n{\n    // Write\
    \ your code here\n    if (n < 0) {\n        assert(false, \"invalid input\");\n\
    \    }\n    else if (n == 0 || n == 1) {\n        return 0;\n    }\n    else if\
    \ (n == 2) {\n        return 1;\n    }\n    else {\n        return fib(n-1) +\
    \ fib(n-2);\n    }\n}\n/*\nThe Fibonacci numbers, denoted f(n) form a sequence,\
    \ called the Fibonacci sequence, such that each number is the sum of the two preceding\
    \ ones, starting from 0 and 1. That is,\n    f(0) = 0, f(1) = 1\n    f(n) = f(n-1)\
    \ + f(n-2), for n > 1.", "{\n    if (n < 2) \n    {\n        return 0;\n    }\
    \ \n    else if (n == 2) \n    {\n        return 1;\n    } \n    else \n    {\n\
    \        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n    }\n}", "{\n\
    \    long res = 0;\n    long a = 0;\n    long b = 0;\n    long c = 1;\n    long\
    \ d = 0;\n    if (n <= 2)\n        return n - 1;\n    for (long i = 2; i < n;\
    \ i++) \n    {\n        res = a + b + c;\n        a = b;\n        b = c;\n   \
    \     c = res;\n    }\n    return res;\n}", "{\n    long a = 0;\n    long b =\
    \ 0;\n    long c = 1;\n    for (long i = 1; i < n; i++) \n    {\n        long\
    \ d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return\
    \ c;\n}\n/*\nThe FibFib number sequence is a sequence similar to the Fibbonacci\
    \ sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n\
    \    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\
    \    Please write a function to efficiently compute the n-th element of the fibfib\
    \ number sequence.\n    >>> fibfib(1L)\n    0L\n    >>> fibfib(5L)\n    4L\n \
    \   >>> fibfib(8L)\n    24L\n    \n*/\nlong fibfib(long n) \n{\n    if (n < 3)\
    \ \n    {\n        return n - 1;\n    }\n    long a = 0;\n    long b = 0;\n  \
    \  long c = 1;\n    for (long i = 1; i < n; i++) \n    {\n        long d = a +\
    \ b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n\
    }\nlong fibfib(long n) \n{\n    if (n < 3) \n    {\n        return n - 1;\n  \
    \  }\n    long n1 = 0;\n    long n2 = 0;\n    long n3 = 1;\n    foreach (i; 1\
    \ .. n) \n    {\n        long n4 = n1 + n2 + n3;\n        n1 = n2;\n        n2\
    \ = n3;\n        n3 = n4;\n    }\n    return n3;\n}\nlong fibfib(long n) \n{\n\
    \    if (n < 3) \n    {\n        return n - 1;\n    }\n", "{\n    if (n <= 1)\n\
    \        return 0;\n    if (n == 2)\n        return 1;\n    return fibfib(n -\
    \ 1) + fibfib(n - 2) + fibfib(n - 3);\n}", "{\n    struct FibFib\n    {\n    \
    \    long fib(long n)\n        {\n            if (n < 3)\n                return\
    \ n - 1;\n            return fib(n - 1) + fib(n - 2) + fib(n - 3);\n        }\n\
    \        /*\n        long fibfib(long n)\n        {\n            return fib(n\
    \ + 1);\n        }\n        */\n    }\n    return FibFib().fib(n + 1);\n}\n//\
    \ Computes the nth element of the FibFib sequence.\nlong fibfib_faster(long n)\
    \ \n{\n    struct FibFib \n    {\n        // The four most recent FibFib numbers.\n\
    \        long[] fibfibs = long[4];\n        FibFib()\n        {\n            fibfibs[0]\
    \ = 0;\n            fibfibs[1] = 0;\n            fibfibs[2] = 1;\n           \
    \ fibfibs[3] = 1;\n        }\n        long fibfib(long n)\n        {\n       \
    \     if (n < fibfibs.length)\n                return fibfibs[n];\n          \
    \  long result = 0;\n            foreach (i; 3..0)\n                result +=\
    \ fibfibs[i];\n            fibfibs.popFront();\n            fibfibs.pushBack(result);\n\
    \            return result;\n        }\n    }\n    return FibFib().fibfib(n);\n\
    }\n/*\n    >>> fibfib(1L)\n    0L\n    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n\
    \    24L\n*/", "{\n    if (n < 0) {\n        return 0;\n    }\n    if (n == 0)\
    \ {\n        return 0;\n    }\n    if (n == 1) {\n        return 0;\n    }\n \
    \   if (n == 2) {\n        return 1;\n    }\n    long fn = 0;\n    long fn_1 =\
    \ 1;\n    long fn_2 = 0;\n    long fn_3 = 0;\n    for (long i = 3; i <= n; i++)\
    \ {\n        fn = fn_1 + fn_2 + fn_3;\n        fn_3 = fn_2;\n        fn_2 = fn_1;\n\
    \        fn_1 = fn;\n    }\n    return fn;\n}\n/*\nGiven a list of strings, find\
    \ the longest substring common to all strings.\n    >>> longest_common_substring([\"\
    aabbaa\", \"ababab\"])\n    \"ab\"\n    >>> longest_common_substring([\"aabbaa\"\
    , \"babbab\"])\n    \"bb\"\n    >>> longest_common_substring([\"abcd\", \"cdef\"\
    , \"efgh\"])\n    \"\"\n    >>> longest_common_substring([\"aabbaa\", \"aabbaa\"\
    ])\n    \"aabbaa\"\n    >>> longest_common_substring([\"\", \"\"])\n    \"\"\n\
    \    >>> longest_common_substring([\"\", \"ab\"])\n    \"\"\n    >>> longest_common_substring([\"\
    a\", \"\"])\n    \"\"\n    \n*/\nstring longest_common_substring(in string[] strings)\
    \ \n{\n    long len(char[] str) \n    {\n        return std.string.length(str);\n\
    \    }\n    if (strings.length == 0) {\n        return \"\";\n    }\n    if (strings.length\
    \ == 1) {\n        return strings[0];\n    }\n    // Idea:\n    // * Build suffix\
    \ array for each string.\n    // * Build an array of arrays which contains an\
    \ index for each string for every suffix in the array.\n    // * Sort the array\
    \ of arrays by the suffixes\n    // * Walk the array, looking for the longest\
    \ prefix that all strings have", "{\n    /*\n    Use dynamic programming to compute\
    \ the nth fibfib number\n    */\n    long [] fibfibs = new long[3];\n    foreach(ref\
    \ it; fibfibs)\n    {\n        it = 0;\n    }\n    for(long i = 0; i <= n; i++)\n\
    \    {\n        long cur = fibfibs[0] + fibfibs[1] + fibfibs[2];\n        fibfibs[0]\
    \ = fibfibs[1];\n        fibfibs[1] = fibfibs[2];\n        fibfibs[2] = cur;\n\
    \    }\n    return fibfibs[2];\n}", "{\n    long fibfib(long n)\n    {\n     \
    \ alias Pair!(long, long) Nums;\n      static if (n <= 1)\n        return 0;\n\
    \      else if (n == 2)\n        return 1;\n      else\n      {\n        long\
    \ fibfib(long n)\n        {\n          n-=3;\n          long sum = 0;\n      \
    \    Nums[2] ret = [0, 1];\n          while (n > 0)\n          {\n           \
    \ sum = ret[0] + ret[1];\n            ret[0] = ret[1];\n            ret[1] = sum;\n\
    \            --n;\n          }\n          return sum;\n        }\n      }\n  \
    \  }\n}", "{\n\t\n\tauto fib = [](size_t n) {\n\t\tif (n <= 2)\n\t\t\treturn 1;\n\
    \t\tauto a = tuple(1, 1);\n\t\tfor (size_t i = 2; i < n; ++i)\n\t\t{\n\t\t\ta\
    \ = tuple(a[1], a[0] + a[1]);\n\t\t}\n\t\treturn a[1];\n\t};\n\t\n\treturn n <=\
    \ 2 ? 0 : fib(n) + fib(n - 1) + fib(n - 2);\n\t\n}\n/*\n\ttest\n*/", "{\n    if\
    \ (n < 2) \n    {\n\treturn 0;\n    }\n    else if (n == 2) \n    {\n\treturn\
    \ 1;\n    }\n    else \n    {\n\tlong a = 0;\n\tlong b = 0;\n\tlong c = 1;\n\t\
    long d = 0;\n\tlong i = 0;\n\tforeach(i; 2 .. n) \n\t{\n\t    d = a + b + c;\n\
    \t    a = b;\n\t    b = c;\n\t    c = d;\n\t}\n\treturn d;\n    }\n}", "{\n  \
    \  // Write your code here\n    return 0;\n}\n/*\nGiven a list of 32 bit integers,\
    \ write a function to find the highest number that can be made by combining the\
    \ given numbers with addition arithmetic.\n    >>> highest(1, 2, 3)\n    6\n \
    \   >>> highest(9, 8, 7)\n    17\n    >>> highest(100, 1, 2, 3)\n    106\n   \
    \ >>> highest(0, 0, 0, 0)\n    0\n*/\nlong highest(long[] nums) \n{\n    // Write\
    \ your code here\n    return 0;\n}\n/*\nWrite a function that takes a string as\
    \ input and returns the string reversed. \nE.g. \"cat\" => \"tac\" \"hello\" =>\
    \ \"olleh\"\n    >>> reverse(\"cat\")\n    \"tac\"\n    >>> reverse(\"hello\"\
    )\n    \"olleh\"\n*/\nstring reverse(string input) \n{\n    // Write your code\
    \ here\n    return \"\";\n}\n/*\nWrite a function to compute the digital root\
    \ of a non-negative integer.\n    >>> digitRoot(0)\n    0\n    >>> digitRoot(9)\n\
    \    9\n    >>> digitRoot(13)\n    4\n    >>> digitRoot(123)\n    6\n*/\nlong\
    \ digitRoot(long num) \n{\n    // Write your code here\n    return 0;\n}\n/*\n\
    Given a non-negative integer num, repeatedly add all its digits until the result\
    \ has only one digit.\n    >>> addDigits(0)\n    0\n    >>> addDigits(9)\n   \
    \ 9\n    >>> addDigits(13)\n    4\n    >>> addDigits(123)\n    6\n*/\nlong addDigits(long\
    \ num) \n{\n    // Write your code here\n    return 0;\n}\n/*\nThis is a problem\
    \ from Project Euler.\n    The sum of the squares of the first ten natural numbers\
    \ is,\n        1^2 + 2^2 + ... + 10^2 = 385\n    The square of the sum of the\
    \ first ten natural numbers is,\n        (1 + 2 + ... + 10)^2 = 55^2 = 3025\n\
    \    Hence the difference between the sum of the squares of the first", "{\n \
    \   long a = 0;\n    long b = 0;\n    long c = 1;\n    if (n == 0) return a;\n\
    \    if (n == 1) return b;\n    if (n == 2) return c;\n    return fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3);\n}", "in {\n    n > 0L;\n}\nout(result) {\n   \
    \ result >= 0L;\n}\n{\n    long f, f0, f1, f2;\n    f0 = 0L;\n    f1 = 0L;\n \
    \   f2 = 1L;\n    foreach (inout i; 2L .. n) {\n        f = f0 + f1 + f2;\n  \
    \      f0 = f1;\n        f1 = f2;\n        f2 = f;\n    }\n    return f;\n}",
  "{\n    if (n < 3)\n        return n - 1;\n    int i = 1;\n    long a = 0;\n   \
    \ long b = 0;\n    long c = 1;\n    long d = 0;\n    long e = 0;\n    while (i\
    \ < n) \n    {\n        d = a + b + c;\n        e = a;\n        a = b;\n     \
    \   b = c;\n        c = d;\n        i++;\n    }\n    return d;\n}\n/*\nOn a given\
    \ 2D grid find all the possible paths a robot can take to reach its destination.\n\
    A robot is initially positioned at the top-left corner of the grid. It can only\
    \ move either down or right at any point in time. The robot is trying to reach\
    \ the bottom-right corner of the grid.\nGrid limitations:\n    .: path\n    x:\
    \ obstacle\n    S: start\n    F: finish\n. . . . .\n. . . . .\n. . . . .\n. .\
    \ . . .\nS F . . .", "{\n    if (n <= 1) return 0;\n    if (n == 2) return 1;\n\
    \    long a = 0, b = 0, c = 1;\n    foreach(i; 0 .. n - 3) \n    {\n        long\
    \ d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return\
    \ c;\n}\n/*\nYou are given a choice of a, b, and c where:\n    a * b = m\n   \
    \ b * c = n\n    Find the minimum of a + b + c for a given m and n.\n    >>> findMinABC(0L,\
    \ 0L)\n    0L\n    >>> findMinABC(2L, 4L)\n    3L\n    >>> findMinABC(2L, 6L)\n\
    \    5L\n    >>> findMinABC(36L, 14L)\n    18L\n    >>> findMinABC(2L, 2L)\n \
    \   3L\n*/\nlong findMinABC(long m, long n)\n{\n    if (m == 0 && n == 0) return\
    \ 0;\n    if (m == 0) return n + 1;\n    if (n == 0) return m + 1;\n    if (m\
    \ == n) return m + n + 1;\n    if (m < n) return m + findMinABC(n % m, m);\n \
    \   else return n + findMinABC(m % n, n);\n}\n/*\nThere is a building of n floors.\
    \ If an egg drops from the k th floor or above, it will break. If it's dropped\
    \ from any floor below, it will not break.\nYou're given two eggs, Find k while\
    \ minimize the number of drops for the worst case. Return the number of drops\
    \ in the worst case.\nExample\n    Given n = 10, return 4.\nExplanation:\n   \
    \ Drop the egg from floor 7. If the egg breaks, drop the egg from floor 4. If\
    \ it doesn't break, drop it from floor 9. If it didn't break, drop it from floor\
    \ 10.\n    If it didn't break, it will not break from floor 8 or floor 6 either.\n\
    \    >>> dropEggs(100)\n    14\n    >>> dropEgg", "{\n    if (n < 0)\n       \
    \ return 0;\n    long a = 0;\n    long b = 0;\n    long c = 1;\n    long tmp;\n\
    \    while (n-- > 0) \n    {\n        tmp = c;\n        c = a + b + c;\n     \
    \   a = b;\n        b = tmp;\n    }\n    return a;\n}\n/*\nThe shortest\n#include\
    \ <stdio.h>\ntypedef long long int vlong;\nvlong fibfib(vlong n) {\n    return\
    \ (n==0) ? 0 : ((n==1) ? 0 : ( (n==2) ? 1 : (fibfib(n-1) + fibfib(n-2) + fibfib(n-3))));\n\
    }\n*/\n/*\nThe fastest\n#include <stdio.h>\ntypedef long long int vlong;\nvlong\
    \ fibfib(vlong n) {\n    vlong a = 0, b = 0, c = 1, i, tmp;\n    for (i = 0; i\
    \ < n; i++) {\n        tmp = c;\n        c = a + b + c;\n        a = b;\n    \
    \    b = tmp;\n    }\n    return a;\n}\n*/\n/*\nAn alternative solution in O(1)\
    \ time\nconst long fibfib(long n) {\n    return ((n>=0)?(n<=2)?0:(1L<<n)+~(n&3L)-3L:0L);\n\
    }\n*/\n/*\nconst long fibfib(long n)\n{\n    static real n_1 = 0, n_2 = 0, n_3\
    \ = 1;\n    if (n < 0)\n        return 0;\n    long result = n_1;\n    n_1 = n_2;\n\
    \    n_2 = n_3;\n    n_3 = result + n_1 + n_2;\n    return result;\n}\n*/\n/*\n\
    long fibfib(long n)\n{\n    static long fibfib_m1 = 0, fibfib_m2 = 0, fibfib_m3\
    \ = 1;\n    long", "in {\n\tassert(n >= 0L);\n}\nout (result) {\n\tassert(result\
    \ >= 0L);\n}\nbody {\n\tif (n == 0L)\n\t\treturn 0L;\n\telse if (n == 1L)\n\t\t\
    return 0L;\n\telse if (n == 2L)\n\t\treturn 1L;\n\telse \n\t\treturn fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n}", "{\n    if (n < 3)\n        return n-1;\n\
    \    else\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n \
    \   /*\n    // invalid input, throw\n    if (n < 0) \n    {\n        throw new\
    \ Exception(\"Negative number\");\n    }\n    // base case\n    if (n == 0 ||\
    \ n == 1) \n    {\n        return 0;\n    }\n    else if (n == 2) \n    {\n  \
    \      return 1;\n    }\n    // tail recursion, replace with iteration\n    return\
    \ fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n    */\n    long[3] fibfib;\n    fibfib[0]\
    \ = 0;\n    fibfib[1] = 0;\n    fibfib[2] = 1;\n    for (long i = 3; i <= n; i++)\
    \ \n    {\n        fibfib[0] = fibfib[1];\n        fibfib[1] = fibfib[2];\n  \
    \      fibfib[2] = fibfib[0] + fibfib[1] + fibfib[2];\n    }\n    return fibfib[2];\n\
    }", "{\n\tif (n <= 1) return 0;\n\telse if (n == 2) return 1;\n\telse return fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3);\n}", "{\n    /* TypeError */\n    version(\
    \ assert ) if (n < 0)\n    {\n        assert(false);\n    }\n    else static if\
    \ (n == 0)\n    {\n        return 0;\n    }\n    else static if (n == 1)\n   \
    \ {\n        return 0;\n    }\n    else static if (n == 2)\n    {\n        return\
    \ 1;\n    }\n    else\n    {\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    \    }\n}", "{\n    // Recursive Solution\n    if (n < 2) \n        return 0;\n\
    \    if (n == 2) \n        return 1;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }\nlong fibfib2(long n) \n{\n    // Static Memoization Solution\n    static long[][long]\
    \ mem;\n    if (!mem.empty) \n        return mem[n];\n    if (n < 2) \n      \
    \  return 0;\n    if (n == 2) \n        return 1;\n    mem[n] = fibfib2(n-1) +\
    \ fibfib2(n-2) + fibfib2(n-3);\n    return mem[n];\n}\nlong fibfib3(long n) \n\
    {\n    // Dynamic Memoization Solution\n    long[][long] mem;\n    if (!mem.empty)\
    \ \n        return mem[n];\n    if (n < 2) \n        return 0;\n    if (n == 2)\
    \ \n        return 1;\n    mem[n] = fibfib3(n-1) + fibfib3(n-2) + fibfib3(n-3);\n\
    \    return mem[n];\n}\nlong fibfib4(long n) \n{\n    // Bottom-Up Dynamic Memoization\
    \ Solution\n    long[][long] mem;\n    foreach (i; 0 .. n) \n    {\n        if\
    \ (i < 2) \n            mem[i] = 0;\n        else if (i == 2) \n            mem[i]\
    \ = 1;\n        else \n            mem[i] = mem[i-1] + mem[i-2] + mem[i-3];\n\
    \    }\n    return mem[n];\n}\nlong fibfib5(long n) \n{\n    // Bottom-Up Dynamic\
    \ Solution\n    if (n < 2) \n        return 0;\n    if (n == 2) \n        return\
    \ 1;\n    long[] fib = [0, 0, 1];\n    foreach (i; 3 .. n) \n    {\n", "{\n  \
    \  long a = 0L;\n    long b = 0L;\n    long c = 1L;\n    long d = a + b + c;\n\
    \    foreach(i; 0L .. n) \n    {\n        d = a + b + c;\n        a = b;\n   \
    \     b = c;\n        c = d;\n    }\n    return a;\n}\n/*\nGiven a string s and\
    \ an int k, return all unique substrings of s of size k with k distinct characters.\n\
    */\nstring[] ksub(string s, int k) \n{\n    auto res = appender!(string[])();\n\
    \    auto init = s[0 .. 0];\n    foreach(i; 1 .. s.length) \n    {\n        if(init.length\
    \ == k) \n        {\n            res.put(init);\n            init = init[1 ..\
    \ $] ~ s[i - 1 .. i - 1];\n        }\n        else \n        {\n            init\
    \ ~= s[i - 1 .. i - 1];\n        }\n    }\n    if(init.length == k) \n    {\n\
    \        res.put(init);\n    }\n    return res.data;\n}\n/*\nGiven an array of\
    \ integers and a number k, where 1 <= k <= length of the array, compute the maximum\
    \ values of each subarray of length k.\nFor example, given array = [10, 5, 2,\
    \ 7, 8, 7] and k = 3, we should get: [10, 7, 8, 8], since:\n10 = max(10, 5, 2)\n\
    7 = max(5, 2, 7)\n8 = max(2, 7, 8)\n8 = max(7, 8, 7)\nDo this in O(n) time and\
    \ O(k) space. You can modify the input array in-place and you do not need to store\
    \ the results. You can simply print them out as you compute them.\n*/", "{\n \
    \   auto arr = new Tuple!(long, long, long)(1, 1, 2);\n    foreach(i; 3..n)\n\
    \    {\n        arr = tuple(arr[0] + arr[1] + arr[2], arr[0], arr[1]);\n    }\n\
    \    return arr[0];\n}", "{\n    if (n < 3) return n - 1;\n    long n1 = 0, n2\
    \ = 1, n3 = 1;\n    for (n; n > 2; n--) \n    {\n        n1 = n2;\n        n2\
    \ = n3;\n        n3 = n1 + n2 + n3;\n    }\n    return n3;\n}\n/*\nThe minimum\
    \ coin change problem is given a value, n, and a set of coins with values, v1,\
    \ v2, v3, ..., vk,\nfind the minimum number of coins required to make change for\
    \ n.", "{\n    n -= 2; // no 0 and 1 in the sequence\n    long[3] fibfib = [0,\
    \ 1, 1]; // fibfib(2) == 1\n    for (; n > 0; n--) \n    {\n        // pull the\
    \ last item from the array\n        long f0 = fibfib[2];\n        // shift the\
    \ items down the array\n        fibfib[2] = fibfib[1];\n        fibfib[1] = fibfib[0];\n\
    \        // add the new item\n        fibfib[0] = f0 + fibfib[1] + fibfib[2];\n\
    \    }\n    return fibfib[0];\n}", "{\n    if (n <= 1) return 0;\n    if (n ==\
    \ 2) return 1;\n    long a = 0, b = 0, c = 1;\n    while (n > 2) {\n        long\
    \ next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n     \
    \   n--;\n    }\n    return c;\n}\n/*\n    std.random module has a function random()\
    \ which returns a uniform random double in the range [0, 1). Write a function\
    \ that\n    returns an exponential random number with mean \\lambda.\n    import\
    \ std.random;\n    >>> exponential(1.0)\n    0.1865369918285537\n    >>> exponential(1.0)\n\
    \    2.6010348244565054\n    >>> exponential(1.0)\n    1.6114968933532314\n  \
    \  >>> exponential(1.0)\n    1.3035570129111574\n    >>> exponential(1.0)\n  \
    \  0.5701708350601063\n*/\ndouble exponential(double lambda) \n{\n    if (lambda\
    \ <= 0)\n        return -1;\n    auto u = uniform(0.0, 1.0);\n    return -log(u)\
    \ / lambda;\n}\n/*\n    Write a function sumExponentials(lambda, n) which generates\
    \ n samples from the exponential distribution with mean\n    \\lambda and returns\
    \ the sum of these samples.\n    >>> sumExponentials(1.0, 10)\n    4.5698065100147875\n\
    \    >>> sumExponentials(1.0, 10)\n    6.744781057962605\n    >>> sumExponentials(1.0,\
    \ 10)\n    2.3569538692169817\n    >>> sumExponentials(1.0, 10)\n    4.895411843533112\n\
    \    >>> sumExponentials(1.0, 10)\n    3.613594612076581\n*/\ndouble sumExponentials(double\
    \ lambda, long n) \n{\n    if (lambda <= 0 || n <= 0)\n        return -1;\n  \
    \  double sum = 0;\n    foreach", "{\n    return n < 3 ? n < 2 ? 0 : 1 : fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n/*\nWrite a function that takes a\
    \ list of numbers and returns a list of tuples which contains the number and its\n\
    natural logarithm.\n    >>> import std.math : log;\n    >>> processLogs([1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10])\n    [([1], 0), ([2], 0.6931471805599453), ([3], 1.0986122886681098),\
    \ ([4], 1.3862943611198906), ([5], 1.6094379124341003), ([6], 1.791759469228055),\
    \ ([7], 1.9459101490553132), ([8], 2.0794415416798357), ([9], 2.1972245773362196),\
    \ ([10], 2.302585092994046)]\n    >>> processLogs(someBigList)\n    [([1], 0),\
    \ ([2], 0.6931471805599453), ([3], 1.0986122886681098), ([4], 1.3862943611198906),\
    \ ([5], 1.6094379124341003), ([6], 1.791759469228055), ([7], 1.9459101490553132),\
    \ ([8], 2.0794415416798357), ([9], 2.1972245773362196), ([10], 2.302585092994046)]\n\
    */\nauto processLogs(int[] numbers) \n{\n    return numbers.map!(a => tuple(a,\
    \ log(a)));\n}\n/*\n    What is the output of the following code?\n    class C\n\
    \    {\n        int x;\n    }\n    void main()\n    {\n        auto a = new C();\n\
    \        auto b = new C();\n        a.x = 5;\n        b.x = 5;\n        assert(a\
    \ == b);\n    }\n    Possible answers:\n    - a.x == b.x\n    - a == b\n    -\
    \ The code doesn't", "{\n    if (n < 3) \n    {\n        return n;\n    }\n  \
    \  else \n    {\n        long a = 0;\n        long b = 1;\n        long c = 1;\n\
    \        for (size_t i = 0; i < n - 2; i++) \n        {\n            long temp\
    \ = c;\n            c = a + b + c;\n            a = b;\n            b = temp;\n\
    \        }\n        return c;\n    }\n}\n/*\n    Write a function that takes an\
    \ integer array and returns the longest increasing sub-sequence within the array.\n\
    \    >>> getLongestIncreasingSubsequence([1,2,3,4,5])\n    [1,2,3,4,5]\n    >>>\
    \ getLongestIncreasingSubsequence([5,4,3,2,1])\n    [1]\n    >>> getLongestIncreasingSubsequence([1,2,3,5,4,3,5,6,3,6,5,6,5,6,7,8,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,",
  "{\n    //If n is less than 0, return 0\n    if(n < 0) \n    {\n        return 0;\n\
    \    }\n    //If n is less than 2, return n\n    if(n < 2) \n    {\n        return\
    \ n;\n    }\n    //Start a new Tuple with fibfib1, fibfib2, and fibfib3 all equal\
    \ to 0\n    auto tup = tuple(0L, 0L, 1L);\n    //For i in range 2 to n, add 1\
    \ to the tuple elements\n    foreach(i; 2 .. n+1) \n    {\n        tup = tuple(tup[1],\
    \ tup[2], tup[0] + tup[1] + tup[2]);\n    }\n    //Return fibfib3\n    return\
    \ tup[2];\n}", "{\n    auto a = 0L;\n    auto b = 0L;\n    auto c = 1L;\n    auto\
    \ d = 0L;\n    auto i = 0L;\n    auto ans = 0L;\n    for (i; i < n; i++) \n  \
    \  {\n        ans = a + b + c;\n        a = b;\n        b = c;\n        c = ans;\n\
    \    }\n    return ans;\n}", "{\n    long a = 0L;\n    long b = 0L;\n    long\
    \ c = 1L;\n    long d = 0L;\n    foreach (i; 0 .. n)\n    {\n        if (i ==\
    \ 0)\n        {\n            d = a;\n        }\n        else\n        {\n    \
    \        d = a + b + c;\n            a = b;\n            b = c;\n            c\
    \ = d;\n        }\n    }\n    return d;\n}", "{\n    long n0 = 0;\n    long n1\
    \ = 0;\n    long n2 = 1;\n    long n3 = 1;\n    long i = 2;\n    while (i < n)\
    \ {\n        n0 = n1;\n        n1 = n2;\n        n2 = n3;\n        n3 = n0 + n1\
    \ + n2;\n        i++;\n    }\n    return n3;\n}", "{\n    //return (n == 0) ?\
    \ 0 : nthFibonacci(n - 1) + nthFibonacci(n - 2) + nthFibonacci(n - 3);\n    long\
    \ prev = 0, current = 0, next = 1;\n    for (long i = 0; i < n; i++) \n    {\n\
    \        prev = current;\n        current = next;\n        next = prev + current\
    \ + ((i >= 2) ? next : 0);\n    }\n    return current;\n}", "{\n    enum long[]\
    \ cache = void;\n    if (n < 3)\n        return (long) (n - 1);\n    else\n  \
    \  {\n        cache = new long[cast(size_t) n];\n        for (size_t i = 0; i\
    \ < 3; i++)\n            cache[i] = i;\n        for (size_t i = 3; i < n; i++)\n\
    \            cache[i] = cache[i - 1] + cache[i - 2] + cache[i - 3];\n        return\
    \ cache[n - 1];\n    }\n}", "{\n    if (n < 3) return n-1;\n    long[] fibs =\
    \ new long[3];\n    fibs[0] = 0;\n    fibs[1] = 0;\n    fibs[2] = 1;\n    foreach\
    \ (i; 3..n) {\n        fibs[i % 3] = fibs[(i - 1) % 3] + fibs[(i - 2) % 3] + fibs[(i\
    \ - 3) % 3];\n    }\n    return fibs[(n - 1) % 3];\n}\n/*\nA number's Hamming\
    \ weight is a count of the number of 1 bits in its binary representation.\n  \
    \  For example, the Hamming weight of the integer 32 is 2, since 32 is 100000\
    \ in binary.\n    The Hamming weight of the integer 41 is 3, since 41 is 101001\
    \ in binary.\n    For any integer N, the following formula gives the Hamming weight\
    \ of N:\n    N & (N-1)\n    N & (N-1) is a bitwise operation that will reset the\
    \ rightmost 1 bit of N to zero.\n    For example, the following table shows the\
    \ value of N and N & (N-1) for the integers from 1 to 32:\n    N   N & (N-1)\n\
    \    1   0\n    2   1\n    3   2\n    4   3\n    5   4\n    6   5\n    7   6\n\
    \    8   7\n    9   8\n    10  9\n    11  10\n    12  11\n    13  12\n    14 \
    \ 13\n    15  14\n    16  15\n    17  16\n    18  17\n    19  18\n    20  19\n\
    \    21  20\n    22  21\n    23  22\n    24  23\n    25  24\n    26  25\n    27\
    \  26\n    28  27\n    29  28\n    30  29\n    31  30\n    32  31\n    We can\
    \ see that each time we reset a 1 bit to 0, the value of N & (N-1) decreases by\
    \ one.\n    Therefore, the Hamming weight of N is the number of times we can perform\
    \ the operation N & (N-1)", "{\n    long[] a = [0L, 0L, 1L];\n    long x = 0;\n\
    \    long y = 0;\n    for (; y < n; y++) \n    {\n        x = a[0] + a[1] + a[2];\n\
    \        a[0] = a[1];\n        a[1] = a[2];\n        a[2] = x;\n    }\n    return\
    \ x;\n}", "{\n    long result = 0;\n    if (n <= 2) \n    {\n        result =\
    \ n-1;\n    } \n    else \n    {\n        long a = 0;\n        long b = 1;\n \
    \       long c = 1;\n        for (int i = 3; i <= n; i++) \n        {\n      \
    \      result = a + b + c;\n            a = b;\n            b = c;\n         \
    \   c = result;\n        }\n    }\n    return result;\n}\n \nlong fibfib1(long\
    \ n)\n{\n    /*\n     * \u4F18\u5316\uFF1A\u5982\u679C n <= 2 \u5219\u8FD4\u56DE\
    \uFF0C\u4E0D\u7528\u8FDB\u884C\u8BA1\u7B97\n     */\n    if (n <= 2) \n    {\n\
    \        return n-1;\n    }\n    long a = 0;\n    long b = 1;\n    long c = 1;\n\
    \    for (int i = 3; i <= n; i++) \n    {\n        long d = a + b + c;\n     \
    \   a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n}\n \nlong fibfib2(long\
    \ n)\n{\n    /*\n     * \u4F18\u5316\uFF1A\u8BA1\u7B97\u8FC7\u7A0B\uFF0C\u76F4\
    \u63A5\u8C03\u7528\u51FD\u6570\uFF0C\u800C\u4E0D\u7528\u7EF4\u62A4\u5168\u5C40\
    \u53D8\u91CF\n     */\n    if (n <= 2) \n    {\n        return n-1;\n    }\n \
    \   return fibfib2(n-1) + fibfib2(n-2) + fibfib2(n-3);\n}\n \nlong fibfib3(long\
    \ n)\n{\n    /*\n     * \u4F18\u5316\uFF1A\u4F7F\u7528\u5B57\u5178\u5B58\u50A8\
    \u5DF2\u7ECF\u8BA1\u7B97\u8FC7\u7684\u503C\uFF0C\u5982\u679C\u627E\u5230\u5C31\
    \u76F4\u63A5\u8FD4\u56DE\uFF0C\n     * \u5982", "{\n    long a = 0L;\n    long\
    \ b = 0L;\n    long c = 1L;\n    long d = 0L;\n    foreach (i; 0 .. n)\n    {\n\
    \        if (i == 0)\n        {\n            a = 0L;\n        }\n        else\
    \ if (i == 1)\n        {\n            b = 0L;\n        }\n        else if (i ==\
    \ 2)\n        {\n            c = 1L;\n        }\n        else\n        {\n   \
    \         d = a + b + c;\n            a = b;\n            b = c;\n           \
    \ c = d;\n        }\n    }\n    return d;\n}\n/*\n>>> palindrome(19)\ntrue\n>>>\
    \ palindrome(1919)\ntrue\n>>> palindrome(19191)\nfalse\n>>> palindrome(1919191)\n\
    true", "{\n    if (n < 0)\n        return -1;\n    if (n == 0)\n        return\
    \ 0;\n    if (n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n\
    \    long temp;\n    long i = 1;\n    long j = 0;\n    long k = 0;\n    long sum\
    \ = 1;\n    while (n - 2 > 0) \n    {\n        temp = sum;\n        sum = sum\
    \ + i + j;\n        j = i;\n        i = temp;\n        n--;\n    }\n    return\
    \ sum;\n}", "{\n    if (n == 0L)\n        return 0L;\n    if (n == 1L)\n     \
    \   return 0L;\n    if (n == 2L)\n        return 1L;\n    return fibfib(n - 1L)\
    \ + fibfib(n - 2L) + fibfib(n - 3L);\n}", "{\n    long num = 0;\n    if (n ==\
    \ 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 0;\n    }\n\
    \    if (n == 2) {\n        return 1;\n    }\n    auto fibonacci = [=](long m)\
    \ {\n        long a = 0;\n        long b = 1;\n        long c = 0;\n        for\
    \ (int i = 0; i < m; i++) {\n            c = a + b;\n            a = b;\n    \
    \        b = c;\n        }\n        return c;\n    };\n    return fibonacci(n-1)\
    \ + fibonacci(n-2) + fibonacci(n-3);\n}", "{\n    return n<3? n==2 ? 1 : 0 : fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3);\n}", "{\n    long ret = 0;\n    if (n < 0) {\n\
    \        ret = -1;\n    }\n    else if (n == 0) {\n        ret = 0;\n    }\n \
    \   else if (n == 1) {\n        ret = 0;\n    }\n    else if (n == 2) {\n    \
    \    ret = 1;\n    }\n    else {\n        ret = fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    \    }\n    return ret;\n}", "{\n    if (n == 0) return 0;\n    if (n == 1) return\
    \ 0;\n    if (n == 2) return 1;\n    auto a = 0L;\n    auto b = 0L;\n    auto\
    \ c = 1L;\n    auto i = 3L;\n    foreach (i; 3..n) {\n        auto t = a + b +\
    \ c;\n        a = b;\n        b = c;\n        c = t;\n    }\n    return c;\n}",
  "{\n    long fibonacci(long n) \n    {\n      if (n < 1) \n      {\n        return\
    \ 0;\n      }\n      else if (n == 1) \n      {\n        return 1;\n      }\n\
    \      return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n    \n    if (n ==\
    \ 1 || n == 2)\n    {\n        return 0;\n    }\n    if (n == 3)\n    {\n    \
    \    return 1;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n\
    \ - 3);\n}", "{\n    if (n <= 1) return 0;\n    if (n == 2) return 1;\n    long[]\
    \ f = [0, 0, 1];\n    foreach (i; 1..n)\n    {\n        f[2] = f[1] + f[0] + f[2];\n\
    \        f[0] = f[1];\n        f[1] = f[2];\n    }\n    return f[2];\n}\n/*\n\
    \    Array: Sliding Window Maximum\n    Given an array of integers, there is a\
    \ sliding window of size k which is moving from the very left of the array to\
    \ the very right. You can only see the k numbers in the window. Each time the\
    \ sliding window moves right by one position.\n    For example, Given nums = [1,3,-1,-3,5,3,6,7],\
    \ and k = 3.\n    Window position                Max\n    ---------------    \
    \           -----\n    [1  3  -1] -3  5  3  6  7       3\n     1 [3  -1  -3] 5\
    \  3  6  7       3\n     1  3 [-1  -3  5] 3  6  7       5\n     1  3  -1 [-3 \
    \ 5  3] 6  7       5\n     1  3  -1  -3 [5  3  6] 7       6\n     1  3  -1  -3\
    \  5 [3  6  7]      7\n    Therefore, return the max sliding window as [3,3,5,5,6,7].\n\
    */", "{\n    if (n <= 2) \n    {\n        return n - 1;\n    }\n    auto a = long(0),\
    \ b = long(0), c = long(1);\n    foreach (i; 2 .. n) \n    {\n        a = b;\n\
    \        b = c;\n        c = a + b + c;\n    }\n    return c;\n}", "{\n    if\
    \ (n < 3)\n        return n > 0 ? 1 : 0;\n    else\n    {\n        return fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3);\n    }\n}\n//long fibfib(long n) {\n//\
    \    return n >= 3 ? fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3) : (n > 0 ?\
    \ 1 : 0);\n//}\n/*\nThe Collatz conjecture states that if you choose any positive\
    \ integer n as a starting point, then repeat the following operations as long\
    \ as n != 1:\n    if n is even, divide it by 2\n    if n is odd, triple it and\
    \ add 1\nyou will always eventually reach 1.\n    Write a function called collatz\
    \ which takes an int, n, and returns the number of steps required to reach 1 from\
    \ n.\n    Note: the 3n + 1 operation is also known as \"half or triple, plus one\"\
    \ and is sometimes written as n = (n / 2) * 3 + 1.\n    >>> collatz(1)\n    0\n\
    \    >>> collatz(7)\n    17\n    >>> collatz(4)\n    2\n    >>> collatz(2)\n \
    \   1\n*/", "{\n    long[3] fibfib_nums = [0L, 0L, 1L];\n    long[] fibfib_nums_tail\
    \ = fibfib_nums[1..$];\n    foreach (immutable i; 1..n-2)\n    {\n        fibfib_nums_tail\
    \ = fibfib_nums_tail.rotateLeft;\n        fibfib_nums_tail[0] = (fibfib_nums_tail[0]\
    \ + fibfib_nums_tail[1] + fibfib_nums_tail[2]);\n    }\n    return fibfib_nums_tail[0];\n\
    }", "{\n    if (n < 2) \n    {\n        return 0;\n    }\n    if (n == 2) \n \
    \   {\n        return 1;\n    }\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3);\n}\n//\nlong fibfibT(long n) \n{\n    if (n == 0) \n    {\n        return\
    \ 0;\n    }\n    Tuple!(long, long, long) fibfibSeq = tuple(0, 0, 1);\n    for\
    \ (int i = 0; i < n - 2; i++) \n    {\n        fibfibSeq = tuple(fibfibSeq[1],\
    \ fibfibSeq[2], fibfibSeq[0] + fibfibSeq[1] + fibfibSeq[2]);\n    }\n    return\
    \ fibfibSeq[2];\n}\n//\nlong fibfibT2(long n) \n{\n    if (n == 0) \n    {\n \
    \       return 0;\n    }\n    long fibfib1 = 0;\n    long fibfib2 = 0;\n    long\
    \ fibfib3 = 1;\n    for (int i = 0; i < n - 2; i++) \n    {\n        fibfib1 =\
    \ fibfib2;\n        fibfib2 = fibfib3;\n        fibfib3 = fibfib1 + fibfib2 +\
    \ fibfib3;\n    }\n    return fibfib3;\n}\n//\nlong fibfibT3(long n) \n{\n   \
    \ if (n == 0) \n    {\n        return 0;\n    }\n    long fibfib1 = 0;\n    long\
    \ fibfib2 = 0;\n    long fibfib3 = 1;\n    foreach(i; 0 .. n - 2) \n    {\n  \
    \      fibfib1 = fibfib2;\n        fibfib2 = fibfib3;\n        fibfib3 = fibfib1\
    \ + fibfib2 + fibfib3;\n    }\n    return fibfib3;\n}", "{\n    if (n == 0)\n\
    \        return 0;\n    if (n == 1)\n        return 0;\n    if (n == 2)\n    \
    \    return 1;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n\
    \    if (n < 2) \n    {\n        return 0;\n    } \n    else if (n == 2) \n  \
    \  {\n        return 1;\n    } \n    else \n    {\n        return fibfib(n - 1)\
    \ + fibfib(n - 2) + fibfib(n - 3);\n    }\n}", "{\n    if (n < 3)\n        return\
    \ n - 1;\n    auto a = 1L;\n    auto b = 1L;\n    auto c = 2L;\n    for (auto\
    \ i = 3L; i < n; ++i)\n    {\n        a = b;\n        b = c;\n        c = a +\
    \ b + c;\n    }\n    return c;\n}", "{\n    if (n < 3)\n        return n - 1;\n\
    \    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}", "{\n    if (n\
    \ <= 2)\n        return n-1;\n    else \n    {\n        auto t = tuple(0L, 0L,\
    \ 1L);\n        foreach(i; 3 .. n+1)\n        {\n            t[0] = t[1];\n  \
    \          t[1] = t[2];\n            t[2] = t[0] + t[1] + t[2];\n        }\n \
    \       return t[2];\n    }\n}", "{\n    auto fib = array(0L, 0L, 1L);\n    auto\
    \ result = 0L;\n    auto nums = tuple(0L, 0L, 1L);\n    auto nums_tmp = 0L;\n\
    \    if (n < 3)\n        return fib[n];\n    foreach (i; 3..n+1)\n    {\n    \
    \    result = tuple(nums).sum();\n        nums_tmp = nums[0];\n        nums[0]\
    \ = nums[1];\n        nums[1] = nums[2];\n        nums[2] = result;\n    }\n \
    \   return result;\n}", "{\n    return n < 3 ? n - 1 : fibfib(n - 1) + fibfib(n\
    \ - 2) + fibfib(n - 3);\n}\n/*\nThe prime factors of 13195 are 5, 7, 13 and 29.",
  "{\n    if (n <= 1) \n    {\n        return 0;\n    }\n    else if (n == 2) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        return fibfib(n - 1)\
    \ + fibfib(n - 2) + fibfib(n - 3);\n    }\n}", "{\n    \n    if (n < 2)\n    \
    \    return 0;\n    else if (n == 2)\n        return 1;\n    else\n    {\n   \
    \     return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n    }\n}", "{\n    int\
    \ max_num = (int)n;\n    int array[max_num];\n    if (n < 2)\n        return n;\n\
    \    else\n    {\n        array[0] = 0;\n        array[1] = 0;\n        array[2]\
    \ = 1;\n        for (int i = 3; i < max_num; i++)\n        {\n            array[i]\
    \ = array[i-1] + array[i-2] + array[i-3];\n        }\n        return array[max_num-1];\n\
    \    }\n}", "{\n    if (n < 2) \n    {\n        return 0;\n    }\n    if (n ==\
    \ 2) \n    {\n        return 1;\n    }\n    long fibnMin1 = 1;\n    long fibnMin2\
    \ = 0;\n    long fibnMin3 = 0;\n    long fibn = fibnMin1 + fibnMin2 + fibnMin3;\n\
    \    for (long i = 3; i < n; i++) \n    {\n        fibnMin3 = fibnMin2;\n    \
    \    fibnMin2 = fibnMin1;\n        fibnMin1 = fibn;\n        fibn = fibnMin1 +\
    \ fibnMin2 + fibnMin3;\n    }\n    return fibn;\n}", "{\n    // Keep track of\
    \ the last three numbers.\n    auto x = tuple(0L, 0L, 1L);\n    while (n--)\n\
    \    {\n        x = tuple(x[1], x[2], x[0] + x[1] + x[2]);\n    }\n    return\
    \ x[2];\n}", "{\n    if (n < 3)\n        return n-1;\n    long x = 0;\n    long\
    \ y = 1;\n    long z = 1;\n    long i = 3;\n    while (i <= n) \n    {\n     \
    \   const long w = x + y + z;\n        x = y;\n        y = z;\n        z = w;\n\
    \        i += 1;\n    }\n    return z;\n}\n/*\n    You are given a set of rectangles\
    \ in no particular order. They have varying widths and heights, but their bottom\
    \ edges are collinear, so that they look like buildings on a skyline. For each\
    \ rectangle, you\u2019re given the x position of the left edge, the x position\
    \ of the right edge, and the height. Your task is to compute the area of the skyline\
    \ depicted by these rectangles. For the purposes of this problem, a rectangle\
    \ is a parallelogram with a right angle at a corner p. The area of such a parallelogram\
    \ is equal to the product of the base and the height.\n    Example Input:", "{\n\
    \    if (n == 0L)\n        return 0L;\n    else if (n == 1L)\n        return 0L;\n\
    \    else if (n == 2L)\n        return 1L;\n    else\n        return fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n}", "{\n    static long[int] cache = [0:0, 1:0,\
    \ 2:1];\n    foreach(i; 3..n+1) \n    {\n        cache[i] = cache[i-1] + cache[i-2]\
    \ + cache[i-3];\n    }\n    return cache[n];\n}", "{\n    if (n == 0)\n      \
    \  return 0;\n    else if (n == 1)\n        return 0;\n    else if (n == 2)\n\
    \        return 1;\n    else if (n > 2)\n        return fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3);\n    else\n        return -1;\n}", "{\n    if (n <= 1)\n    \
    \    return 0;\n    if (n == 2)\n        return 1;\n    long first = 0;\n    long\
    \ second = 1;\n    long third = 1;\n    for (long i = 3; i <= n; i++)\n    {\n\
    \        third = first + second + third;\n        first = second;\n        second\
    \ = third - first - second;\n    }\n    return third;\n}\n/*\nImplement a function\
    \ that takes a list of tuples, which each tuple can be decomposed into two components.\
    \ \nPlease return a list of tuples, which each tuple is formed by the sum of the\
    \ first components from the input tuples, \nand the product of the second components\
    \ from the input tuples.", "{\n    if (n < 3) return n-1;\n    return fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3);\n}", "{\n    if (n == 0L)\n        return 0L;\n\
    \    else if (n == 1L)\n        return 0L;\n    else if (n == 2L)\n        return\
    \ 1L;\n    else \n    {\n        //initialize an array called 'storage' that stores\
    \ the last three elements of the fibfib sequence\n        long[] storage = new\
    \ long[3];\n        //populate storage with the first three elements of the fibfib\
    \ sequence\n        storage[0] = 0L;\n        storage[1] = 0L;\n        storage[2]\
    \ = 1L;\n        //instantiate the current element of the fibfib sequence\n  \
    \      long current = 0L;\n        //calculate the current element of the fibfib\
    \ sequence\n        for (long i = 3L; i <= n; i++) \n        {\n            current\
    \ = storage[0] + storage[1] + storage[2];\n            storage[0] = storage[1];\n\
    \            storage[1] = storage[2];\n            storage[2] = current;\n   \
    \     }\n        return current;\n    }\n}\n/*\nThis is a bonus problem.\n   \
    \ Stirling's approximation is a way to approximate n! for large n.\n    It's defined\
    \ as the following:\n    >>> stirling(5)\n    120.0\n    >>> stirling(10)\n  \
    \  3628800.0\n    >>> stirling(100)\n    9.33262154439441e+157\n    >>> stirling(1000)\n\
    \    4.02387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428",
  "{\n    long[] dp = new long[3];\n    dp[0] = 0;\n    dp[1] = 0;\n    dp[2] = 1;\n\
    \    for (long i = 2; i < n; i++) \n    {\n        dp[i % 3] = dp[(i - 1) % 3]\
    \ + dp[(i - 2) % 3] + dp[(i - 3) % 3];\n    }\n    return dp[(n - 1) % 3];\n}\n\
    /*\nGiven a string s, with the form 'XXXYYY', where X is a set of characters and\
    \ Y is also a set of characters,\n    find the longest sub-string that starts\
    \ with X and ends with Y.\n    >>> longestSubstring(\"abcdefg\")\n    'abcdefg'\n\
    \    >>> longestSubstring(\"abcdefgabcdefgabcdefg\")\n    'abcdefgabcdefgabcdefg'\n\
    \    >>> longestSubstring(\"aabbccddeeffgg\")\n    'ffgg'\n    >>> longestSubstring(\"\
    aabbccddeeffggaabbccddeeffggaabbccddeeffgg\")\n    'ffggaabbccddeeffggaabbccddeeffgg'\n\
    \    >>> longestSubstring(\"aabbccddeeffggaabbccddeeffggaabbccddeeffgg\")\n  \
    \  'ffggaabbccddeeffggaabbccddeeffgg'\n    >>> longestSubstring(\"abcaabcaabcaabca\"\
    )\n    'abcaabca'\n    >>> longestSubstring(\"abcaabcaabcaabcaabca\")\n    'abcaabcaabcaabca'\n\
    \    >>> longestSubstring(\"abcdefgabc\")\n    'abcdefgabc'\n    >>> longestSubstring(\"\
    abcdefgabcabc\")\n    'abcdefgabcabc'\n    >>> longestSubstring(\"abcdefgabcabcabc\"\
    )\n    'abcdefgabcabcabc'\n    >>> longestSubstring(\"abcdefgabcabcabcabc\")\n\
    \    'abcdefgabcabcabc'\n    >>> longestSubstring(\"abcdefgabcabcabcabcabc\")\n\
    \    'abcdefgabcabc"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
