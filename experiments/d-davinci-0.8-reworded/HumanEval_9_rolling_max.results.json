{
  "language": "d",
  "name": "HumanEval_9_rolling_max",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] res = new long[numbers.length];\n\tif (numbers.length > 0)\n\t{\n\t\tres[0] = numbers[0];\n\t\tfor (int i = 1; i < numbers.length; i++)\n\t\t{\n\t\t\tres[i] = max(res[i - 1], numbers[i]);\n\t\t}\n\t}\n\treturn res;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\tlong[] res = new long[numbers.length];\n\tif (numbers.length > 0)\n\t{\n\t\tres[0] = numbers[0];\n\t\tfor (int i = 1; i < numbers.length; i++)\n\t\t{\n\t\t\tres[i] = min(res[i - 1], numbers[i]);\n\t\t}\n\t}\n\treturn res;\n}\n/*\n  From a given array of integers, generate an array of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n\tlong[] res = new long[numbers.length];\n\tif (numbers.length > 0)\n\t{\n\t\tres[0] = numbers[0];\n\t\tfor (int i = 1; i < numbers.length; i++)\n\t\t{\n\t\t\tres[i] = res[i - 1] + numbers[i];\n\t\t}\n\t}\n\treturn res;\n}\n/*\n  From a given array of integers, generate an array of rolling average of elements found until given moment\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprkj11tis.d(63): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprkj11tis.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_until_now = numbers[0];\n    size_t n = numbers.length;\n    long[] result = new long[n];\n    result[0] = max_until_now;\n    foreach (i,number; numbers[1..$])\n    {\n        if (number > max_until_now)\n        {\n            max_until_now = number;\n        }\n        result[i] = max_until_now;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling average element found until given moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L, 3L, 3L]\n*/\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpqa9117du.d(12): Range violation\n----------------\n??:? _d_arrayboundsp [0x42858e]\n??:? long[] tmpqa9117du.rolling_max(long[]) [0x427e4b]\n??:? void tmpqa9117du.__unittest_L32_C1() [0x427f6e]\n??:? void tmpqa9117du.__modtest() [0x42825c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b44e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b88]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430665]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b425]\n??:? runModuleUnitTests [0x42c391]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    bool[] current_max_indices = new bool[numbers.length];\n    long[] rolling_max = new long[numbers.length];\n    for (long i = 0; i < numbers.length; i++) \n    {\n        current_max_indices[i] = true;\n        for (long j = 0; j < i; j++) \n        {\n            if (numbers[j] >= numbers[i]) \n            {\n                current_max_indices[i] = false;\n                break;\n            }\n        }\n        if (current_max_indices[i]) \n        {\n            rolling_max[i] = numbers[i];\n        } \n        else \n        {\n            rolling_max[i] = rolling_max[i - 1];\n        }\n    }\n    return rolling_max;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif (numbers.length == 0) return [];\n\tlong[] res = new long[numbers.length];\n\tres[0] = numbers[0];\n\tfor (size_t i = 1; i < numbers.length; i++)\n\t\tres[i] = max(res[i - 1], numbers[i]);\n\treturn res;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpts9840tx.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpts9840tx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in \n    {\n        assert(numbers.length > 0);\n    }\n    out \n    (\n        result.length == numbers.length\n    )\n{\n    // https://www.programiz.com/dsa/stack-in-cpp\n    import std.typecons;\n    import std.algorithm;\n    Stack!long stack = new Stack!long();\n    stack.push(numbers[0]);\n    auto max_num = numbers[0];\n    foreach(i, number; numbers[1..$])\n    {\n        if (number > max_num)\n        {\n            max_num = number;\n        }\n        stack.push(max_num);\n    }\n    long[] result = stack.array();\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphrsopd7a.d(17): Error: found `.` when expecting `)`\n/tmp/tmphrsopd7a.d(17): Error: statement expected to be `{ }`, not `length`\n/tmp/tmphrsopd7a.d(18): Error: found `)` when expecting `;` following statement\n/tmp/tmphrsopd7a.d(19): Error: missing `do { ... }` after `in` or `out`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphrsopd7a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (size_t i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyjpz_kgn.d(20): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyjpz_kgn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    static struct IndexedLong \n    {\n        size_t index;\n        long value;\n    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpysck8la_.d(17): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpysck8la_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    // Declaring a temporary buffer to keep track of the max found in the loop\n    long buffer;\n    // Initalizing the buffer with the first element of the array.\n    buffer = numbers[0];\n    // Initializing the array to be returned with the first element of the array.\n    long[] rolling_max = new long[1];\n    rolling_max[0] = numbers[0];\n    // Looping over the numbers in the array, if the buffer is less than the number, it is overwritten.\n    // This will be used to return the maximum number found in the array so far.\n    for (long i = 1; i < numbers.length; i++)\n    {\n        if (buffer < numbers[i])\n        {\n            buffer = numbers[i];\n        }\n        rolling_max ~= buffer;\n    }\n    return rolling_max;\n}\n// This algorithm doesn't achieve the best possible score because of the 'if' statement in the loop.\n// I will implement a solution that is O(n) after reviewing the solution.\n// Solution from the book (O(n)):\n// In the previous solution we needed to traverse the entire list to find the rolling max for\n// each element. This is becase we were always comparing the previous elements to find the max so far.\n// In this solution, we traverse the array only once, and for each element we record the max element\n// so far, and the current element. We then compare the two to determine which element is written to the\n// array to be returned. This allows us to only loop over the array once and also allows us to find the\n// rolling max for each element.\nlong[] rolling_max_better(long[] numbers) \n{\n    // Initializing the array to be returned with the first element of the array.\n    long[] rolling_max = new long[1];\n    rolling_max[0] = numbers[0];\n    // Declaring the max element found so far\n    long max_so_far = numbers[0];\n    // Looping over the array and comparing each element to the max found so far\n    for (long i = 1; i < numbers.length; i++)\n    {\n        // If the max so far is less than the current element, set\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4l2hwz5j.d(51): Error: found `unittest` instead of statement\n/tmp/tmp4l2hwz5j.d(60): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4l2hwz5j.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto N = numbers.length;\n    long[] output = new long[N];\n    output[0] = numbers[0];\n    for (auto index = 1; index < N; index++)\n    {\n        output[index] = max(output[index - 1], numbers[index]);\n    }\n    return output;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max_alt(long[] numbers) \n{\n    auto N = numbers.length;\n    long[] output = new long[N];\n    auto m = numbers[0];\n    for (auto index = 0; index < N; index++)\n    {\n        m = max(m, numbers[index]);\n        output[index] = m;\n    }\n    return output;\n}\n/*\n    From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    auto N = numbers.length;\n    long[] output = new long[N];\n    output[0] = numbers[0];\n    for (auto index = 1; index < N; index++)\n    {\n        output[index] = min(output[index - 1], numbers[index]);\n    }\n    return output;\n}\n/*\n    From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5iaz9ux7.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5iaz9ux7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] rollingMax;\n    long num = 0;\n    rollingMax.length = numbers.length;\n    if (numbers.length) \n    {\n        rollingMax[0] = numbers[0];\n        for (int i = 1; i < numbers.length; i++) \n        {\n            num = numbers[i];\n            if (num > rollingMax[i - 1]) \n            {\n                rollingMax[i] = num;\n            }\n            else \n            {\n                rollingMax[i] = rollingMax[i - 1];\n            }\n        }\n    }\n    return rollingMax;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    assert(numbers.length > 0);\n    auto result = new long[numbers.length];\n    immutable long max_so_far = 0;\n    foreach (index, number; numbers) {\n        if (number > max_so_far) {\n            max_so_far = number;\n        }\n        result[index] = max_so_far;\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpptvmb_vp.d(23): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpptvmb_vp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] output = numbers.dup;\n    foreach (i, e; output)\n    {\n        if (i > 0)\n        {\n            output[i] = max(output[i], output[i - 1]);\n        }\n    }\n    return output;\n}\n/*\n Given an array of integers, how many of them are unique?\n    >>> unique_elements([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    4L\n    \n*/\nsize_t unique_elements(long[] numbers) \n{\n    return set(numbers).length;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt6y1dcsp.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmpt6y1dcsp.d(30): Error: undefined identifier `set`, did you mean template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt6y1dcsp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    assert(numbers.length >= 1);\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, _; 1 .. numbers.length)\n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\n \n// From a given array of integers, generate an array of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n// [1L, 1L, 1L, 1L, 1L, 1L, 1L]\nlong[] rolling_min(long[] numbers) \n{\n    assert(numbers.length >= 1);\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, _; 1 .. numbers.length)\n    {\n        result[i] = min(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdflxiwob.d(15): Error: found `..` when expecting `)`\n/tmp/tmpdflxiwob.d(15): Error: found `)` when expecting `;` following statement\n/tmp/tmpdflxiwob.d(31): Error: found `..` when expecting `)`\n/tmp/tmpdflxiwob.d(31): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdflxiwob.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] ret = new long[numbers.length];\n    long[] val = new long[numbers.length];\n    ret[0] = numbers[0];\n    val[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++)\n    {\n        ret[i] = numbers[i] > val[i - 1] ? numbers[i] : val[i - 1];\n        val[i] = numbers[i];\n    }\n    return ret;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] ret = new long[numbers.length];\n    long[] val = new long[numbers.length];\n    ret[0] = numbers[0];\n    val[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++)\n    {\n        ret[i] = numbers[i] < val[i - 1] ? numbers[i] : val[i - 1];\n        val[i] = numbers[i];\n    }\n    return ret;\n}\n/*\n From a given array of integers, generate an array of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] ret = new long[numbers.length];\n    long[] val = new long[numbers.length];\n    ret[0] = numbers[0];\n    val[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++)\n    {\n        ret\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpex6cezks.d(59): Error: found `unittest` when expecting `;` following statement\n/tmp/tmpex6cezks.d(68): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpex6cezks.d(68): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpex6cezks.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto result = new long[](numbers.length);\n  auto current_max = numbers[0];\n  result[0] = current_max;\n  foreach (i, n; numbers[1 .. $]) \n  {\n    if (n > current_max)\n      current_max = n;\n    result[i + 1] = current_max;\n  }\n  return result;\n}\n/*\n    From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    */\nlong[] rolling_min(long[] numbers) \n{\n  auto result = new long[](numbers.length);\n  auto current_min = numbers[0];\n  result[0] = current_min;\n  foreach (i, n; numbers[1 .. $]) \n  {\n    if (n < current_min)\n      current_min = n;\n    result[i + 1] = current_min;\n  }\n  return result;\n}\n/*\n    From a given array of integers, generate an array of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    */\nlong[] rolling_sum(long[] numbers) \n{\n  auto result = new long[](numbers.length);\n  auto current_sum = numbers[0];\n  result[0] = current_sum;\n  foreach (i, n; numbers[1 .. $]) \n  {\n    current_sum += n;\n    result[i + 1] = current_sum;\n  }\n  return result;\n}\n/*\n    From a given array of integers, generate an array of rolling mean value of elements found until given moment\n    in the sequence.\n    >>> rolling_mean([\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5q6ujr1_.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5q6ujr1_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] rmax = new long[numbers.length];\n    rmax[0] = numbers[0];\n    foreach (i, v; numbers[1 .. $])\n    {\n        rmax[i + 1] = max(v, rmax[i]);\n    }\n    return rmax;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max_zip(long[] numbers) \n{\n    long[] rmax = new long[numbers.length];\n    rmax[0] = numbers[0];\n    foreach (i, v; zip(numbers[1 .. $], rmax[0 .. $]))\n    {\n        rmax[i + 1] = max(v[0], v[1]);\n    }\n    return rmax;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max_foreach(long[] numbers) \n{\n    long[] rmax = new long[numbers.length];\n    rmax[0] = numbers[0];\n    foreach (i, v; numbers[1 .. $])\n    {\n        rmax[i + 1] = max(v, rmax[i]);\n    }\n    return rmax;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdve41ghk.d(54): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdve41ghk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[];\n    foreach (index, x; numbers)\n    {\n        if (index == 0)\n        {\n            result ~= x;\n        }\n        else \n        {\n            result ~= max(x, result[$-1]);\n        }\n    }\n    return result;\n}\n/*\n    Finds all of the possible rolling maximums of `numbers` of size `window_size`\n    >>> rollings_max([1L, 2L, 3L, 2L, 3L, 4L, 2L], 2)\n    [[1L, 2L], [2L, 3L], [3L, 3L], [2L, 3L], [3L, 4L], [4L, 4L], [2L, 4L]]\n*/\nlong[][] rollings_max(long[] numbers, int window_size) \n{\n    assert(window_size != 0);\n    if (window_size < 0)\n    {\n        numbers = numbers[0..window_size];\n        window_size = -window_size;\n    }\n    auto result = new long[][](numbers.length - window_size + 1);\n    foreach (i; 0..numbers.length - window_size + 1)\n    {\n        result[i] = rolling_max(numbers[i..i + window_size]);\n    }\n    return result;\n}\n/*\n    Finds all of the possible rolling maximums of `numbers` of size `window_size`\n    >>> rollings_max([1L, 2L, 3L, 2L, 3L, 4L, 2L], 2)\n    [[1L, 2L], [2L, 3L], [3L, 3L], [2L, 3L], [3L, 4L], [4L, 4L], [2L, 4L]]\n*/\nlong[][] rollings_max_zip(long[] numbers, int window_size) \n{\n    assert(window_size != 0);\n    if (window_size < 0)\n    {\n        numbers = numbers[0..window_size];\n        window_size = -\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbbrob0le.d(58): Error: expression expected, not `unittest`\n/tmp/tmpbbrob0le.d(59): Error: found `{` when expecting `;` following statement\n/tmp/tmpbbrob0le.d(67): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbbrob0le.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if (numbers.length < 1) return new long[0];\n    if (numbers.length == 1) return numbers;\n    long[] result = new long[numbers.length];\n    auto max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (n, i; numbers[1 .. $])\n    {\n        if (n > max_so_far) max_so_far = n;\n        result[i] = max_so_far;\n    }\n    return result;\n}\n/*\n Given a number of seconds, return the time in minutes and seconds.\n    >>> minutes_and_seconds(3599)\n    Tuple!(int, int)(59, 59)\n    >>> minutes_and_seconds(0)\n    Tuple!(int, int)(0, 0)\n    >>> minutes_and_seconds(60)\n    Tuple!(int, int)(1, 0)\n    >>> minutes_and_seconds(3660)\n    Tuple!(int, int)(61, 0)\n*/\nauto minutes_and_seconds(long seconds)\n{\n    auto mins = seconds / 60;\n    auto secs = seconds % 60;\n    return tuple(mins, secs);\n}\n/*\n Given a phone number in international format, return the number in local format with a leading zero.\n    >>> local_number(\"+48123456789\")\n    \"0048123456789\"\n    >>> local_number(\"123456789\")\n    \"00123456789\"\n    >>> local_number(\"0048123456789\")\n    \"0048123456789\"\n*/\nstring local_number(string phone_number)\n{\n    if (phone_number.length == 0) return \"\";\n    if (phone_number[0] == '+') return \"00\" ~ phone_number[1 .. $];\n    if (phone_number[0 .. 1] == \"00\") return phone_number;\n    if (phone_number[0] == '0') return \"00\" ~ phone_number[1 .. $];\n    return \"00\" ~ phone_number;\n}\n/*\n Return\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbfo_w16q.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbfo_w16q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto ds = SinglyLinkedList!(Tuple!(long, long)).init;\n    auto result = new long[numbers.length];\n    foreach (i, e; numbers) {\n        int endIndex = ds.length;\n        //remove elements that are smaller than the element at hand\n        while (endIndex && ds[endIndex - 1].length > e) {\n            ds.removeAt(endIndex - 1);\n            endIndex--;\n        }\n        //append element\n        ds.append(tuple(e, i));\n        //set the value in the result\n        result[i] = endIndex ? ds[endIndex - 1].length : 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp24byj3cq.d(12): Error: template instance `SinglyLinkedList!(Tuple!(long, long))` template `SinglyLinkedList` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp24byj3cq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \nin {\n    for (i in 0 .. numbers.length - 1) \n        //assert(numbers[i] >= 0);\n    assert(numbers.length > 0);\n}\nout (result) {\n    assert(result.length == numbers.length);\n    for (i in 0 .. result.length - 1) \n        assert(result[i] >= 0);\n}\n{\n    long[] result = new long[numbers.length];\n    long maxSoFar = numbers[0];\n    for (i in 0 .. numbers.length - 1) {\n        if (maxSoFar < numbers[i]) {\n            maxSoFar = numbers[i];\n        }\n        result[i] = maxSoFar;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq2eg7hsj.d(12): Error: found `..` when expecting `;` following statement\n/tmp/tmpq2eg7hsj.d(12): Error: found `)` when expecting `;` following `for` condition\n/tmp/tmpq2eg7hsj.d(14): Error: found `;` when expecting `)`\n/tmp/tmpq2eg7hsj.d(15): Error: found `}` instead of statement\n/tmp/tmpq2eg7hsj.d(18): Error: found `..` when expecting `;` following statement\n/tmp/tmpq2eg7hsj.d(18): Error: found `)` when expecting `;` following `for` condition\n/tmp/tmpq2eg7hsj.d(19): Error: found `;` when expecting `)`\n/tmp/tmpq2eg7hsj.d(20): Error: found `}` instead of statement\n/tmp/tmpq2eg7hsj.d(21): Error: missing `do { ... }` after `in` or `out`\n/tmp/tmpq2eg7hsj.d(24): Error: found `..` when expecting `;` following statement\n/tmp/tmpq2eg7hsj.d(24): Error: found `)` when expecting `;` following `for` condition\n/tmp/tmpq2eg7hsj.d(30): Error: found `return` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq2eg7hsj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif (numbers.length == 0)\n\t\treturn [];\n\tif (numbers.length == 1)\n\t\treturn [numbers[0]];\n\t\n\tauto maxes = new long[numbers.length];\n\tmaxes[0] = numbers[0];\n\t\n\tforeach (idx, n; numbers[1..$]) \n\t{\n\t\tmaxes[idx] = max(maxes[idx-1], n);\n\t}\n\t\n\treturn maxes;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjvznjb75.d(22): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjvznjb75.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] res = new long[numbers.length];\n\tif (numbers.length == 0)\n\t{\n\t\treturn res;\n\t}\n\telse\n\t{\n\t\tres[0] = numbers[0];\n\t\tint i = 1;\n\t\twhile (i < numbers.length)\n\t\t{\n\t\t\tres[i] = max(res[i - 1], numbers[i]);\n\t\t\ti++;\n\t\t}\n\t\treturn res;\n\t}\n}\n// Generated by Dlang plug-in.\n@SuppressWarnings(\"unused\")\npublic static class tsl_TResult {\n    private static final tsl_TResult instance = new tsl_TResult();\n    public static tsl_TResult getInstance() {\n        return instance;\n    }\n    private static final Func2<Object, tsl_TResult, Object> __ctor = (Func2<Object, tsl_TResult, Object>)\n        ((Object o, tsl_TResult self) -> {\n            return null;\n        });\n    private static final Func2<Object, tsl_TResult, Object> __opAssign = (Func2<Object, tsl_TResult, Object>)\n        ((Object o, tsl_TResult self) -> {\n            return null;\n        });\n    public static final class tsl_TResultMembers {\n        public static final Func2<Object, tsl_TResult, Object> ctor = __ctor;\n        public static final Func2<Object, tsl_TResult, Object> opAssign = __opAssign;\n    }\n}\n// Generated by Dlang plug-in.\n@SuppressWarnings(\"unused\")\npublic static class tsl_TResult_0 {\n    private static final tsl_TResult_0 instance = new tsl_TResult_0();\n    public static tsl_TResult_0 getInstance() {\n        return instance;\n    }\n    private static final Func2<Object, tsl_TResult_0, Object> __ctor = (Func2<Object, tsl_TResult_0, Object>)\n        ((Object\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2otu4bcj.d(36): Error: no identifier for declarator `Func2`\n/tmp/tmp2otu4bcj.d(36): Error: declaration expected, not `<`\n/tmp/tmp2otu4bcj.d(39): Error: declaration expected, not `)`\n/tmp/tmp2otu4bcj.d(40): Error: no identifier for declarator `Func2`\n/tmp/tmp2otu4bcj.d(40): Error: declaration expected, not `<`\n/tmp/tmp2otu4bcj.d(43): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2otu4bcj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] maximums = new long[numbers.length];\n    long maximum = 0;\n    foreach (i, number; numbers) \n    {\n        maximum = std.math.max(maximum, number);\n        maximums[i] = maximum;\n    }\n    return maximums;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] minimums = new long[numbers.length];\n    long minimum = 0;\n    foreach (i, number; numbers) \n    {\n        minimum = std.math.min(minimum, number);\n        minimums[i] = minimum;\n    }\n    return minimums;\n}\n/*\n From a given array of integers, generate an array of rolling min/max elements found until given moment\n    in the sequence.\n    >>> rolling_minmax([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [(1L, 1L), (1L, 2L), (1L, 3L), (1L, 3L), (1L, 3L), (1L, 4L), (1L, 4L)]\n*/\nTuple!(long, long)[] rolling_minmax(long[] numbers) \n{\n    Tuple!(long, long)[] minmaxs = new Tuple!(long, long)[numbers.length];\n    long minimum = numbers[0];\n    long maximum = numbers[0];\n    foreach (i, number; numbers) \n    {\n        minimum = std.math.min(minimum, number);\n        maximum = std.math.max(maximum, number);\n        minmaxs[i] = std.typecons.tuple(minimum, maximum);\n    }\n    return minmaxs;\n}\n/*\n Given two arrays of integers, find the number of valid pairs\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqltda6ib.d(57): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqltda6ib.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpx0ai9t9j.d(13): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx0ai9t9j.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] ret = new long[];\n    long max;\n    if (numbers.length == 0) \n    {\n        return ret;\n    }\n    max = numbers[0];\n    ret ~= max;\n    foreach (i; 1 .. numbers.length) \n    {\n        if (numbers[i] > max) \n        {\n            max = numbers[i];\n        }\n        ret ~= max;\n    }\n    return ret;\n}\n/*\nWrite a function in D that will render an array of integers as a staircase.\n>>> staircase([2L,3L,4L,2L,3L,4L,5L,1L,2L,3L,4L,5L,6L,1L,2L,3L,4L,5L,6L,7L])\n>>> 2\n>>>   3\n>>>     4\n>>>   3\n>>>     4\n>>>       5\n>>> 1\n>>>   2\n>>>     3\n>>>       4\n>>>         5\n>>>           6\n>>> 1\n>>>   2\n>>>     3\n>>>       4\n>>>         5\n>>>           6\n>>>             7\n*/\nstring staircase(long[] numbers) \n{\n    string ret = \"\";\n    string space = \"\";\n    foreach (i; 0 .. numbers.length) \n    {\n        ret ~= space ~ numbers[i] ~ \"\\n\";\n        space ~= \" \";\n    }\n    return ret;\n}\n/*\n Create an array of constants for the given set of arguments passed.\n constants(1,2,3,4,5,6)\n output: [1L, 2L, 3L, 4L, 5L, 6L]\n */\nT[] constants(T)(T args...) \n{\n    T[] ret = new T[];\n    foreach (t; args) \n    {\n        ret ~= t;\n    }\n    return ret;\n}\n/*\n Create an array of the alternating elements, starting with the first element.\n alternating(1,2,3,4,5,6)\n output: [1L, 3L, 5L]\n*/\nT[] alternating(T)(T\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpskfja4ti.d(84): Error: found `unittest` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpskfja4ti.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.range;\n    import std.algorithm;\n    import std.array;\n    long[] acc = new long[](numbers.length);\n    acc[0] = numbers[0];\n    auto iter = numbers.save.dropOne.zip(acc.dropOne);\n    foreach(i, (long val, ref long res))\n    {\n        res = max(res, val);\n    }\n    return acc;\n}\n// Algorithms\n/*\n Find the longest sequence of consecutive elements in an array.\n    >>> longest_seq([1L, 2L, 3L, 4L, 5L, 5L, 6L, 7L, 8L, 1L, 2L, 2L, 3L, 5L, 6L, 7L,\n    8L, 10L, 11L, 9L, 8L, 8L, 7L, 6L, 5L, 4L, 3L, 2L, 1L])\n    [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]\n*/\nlong[] longest_seq(long[] in_arr) \n{\n    import std.array;\n    auto accum = new long[](in_arr.length);\n    auto index = new long[](in_arr.length);\n    accum[0] = 1;\n    index[0] = 0;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n    foreach(i, val; in_arr.dropOne.zip(accum.dropOne.zip(index.dropOne)))\n    {\n        int j = in_arr[i].lowerBound(in_arr[i - 1L + 1L .. $]);\n        if (j == in_arr[i].length) \n        {\n            in_arr[i + 1L] = in_arr[i];\n            index[i + 1L] = index[i];\n        }\n        else \n        {\n            in_arr[i + 1L] = in_arr[i].length - j;\n            index[i + 1L] = i + j;\n        }\n    }\n    return in\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpled883lr.d(18): Error: basic type expected, not `(`\n/tmp/tmpled883lr.d(18): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpled883lr.d(18): Error: no identifier for declarator `_error_(long val, ref long res)`\n/tmp/tmpled883lr.d(18): Error: found `)` when expecting `;`\n/tmp/tmpled883lr.d(22): Error: found `return` when expecting `)`\n/tmp/tmpled883lr.d(55): Error: expression expected, not `in`\n/tmp/tmpled883lr.d(56): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpled883lr.d(65): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpled883lr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    enum num_elements = numbers.length;\n    auto result = new long[num_elements];\n    auto max_found = numbers[0];\n    for (auto i = 0; i < num_elements; i++) \n    {\n        if (numbers[i] > max_found)\n            max_found = numbers[i];\n        result[i] = max_found;\n    }\n    return result;\n}\nlong[] rolling_max2(long[] numbers) \n{\n    auto result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..]) \n    {\n        result[i + 1] = max(result[i], number);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcxu_0h1r.d(27): Error: expression expected, not `]`\n/tmp/tmpcxu_0h1r.d(27): Error: found `)` when expecting `,`\n/tmp/tmpcxu_0h1r.d(31): Error: found `return` when expecting `,`\n/tmp/tmpcxu_0h1r.d(31): Error: found `;` when expecting `,`\n/tmp/tmpcxu_0h1r.d(32): Error: expression expected, not `}`\n/tmp/tmpcxu_0h1r.d(33): Error: found `unittest` when expecting `,`\n/tmp/tmpcxu_0h1r.d(42): Error: found `void` when expecting `,`\n/tmp/tmpcxu_0h1r.d(42): Error: found `{` when expecting `,`\n/tmp/tmpcxu_0h1r.d(42): Error: expression expected, not `}`\n/tmp/tmpcxu_0h1r.d(42): Error: found `End of File` when expecting `,`\n/tmp/tmpcxu_0h1r.d(42): Error: found `End of File` when expecting `]`\n/tmp/tmpcxu_0h1r.d(42): Error: found `End of File` when expecting `)`\n/tmp/tmpcxu_0h1r.d(42): Error: found `End of File` instead of statement\n/tmp/tmpcxu_0h1r.d(42): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcxu_0h1r.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in \n    {\n        assert(numbers.length > 0);\n    }\n    out\n    (\n        result.length == numbers.length\n    )\n{\n    long[] result = new long[];\n    result ~= numbers[0];\n    for (int i = 1; i < numbers.length; i++)\n    {\n        result ~= max(result[$-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxsgp990h.d(17): Error: found `.` when expecting `)`\n/tmp/tmpxsgp990h.d(17): Error: statement expected to be `{ }`, not `length`\n/tmp/tmpxsgp990h.d(18): Error: found `)` when expecting `;` following statement\n/tmp/tmpxsgp990h.d(19): Error: missing `do { ... }` after `in` or `out`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxsgp990h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif (numbers.length == 0) return [];\n\tlong curr_max = numbers[0];\n\tlong[] result = [curr_max];\n\tforeach (n; numbers[1..$])\n\t{\n\t\tcurr_max = max(curr_max, n);\n\t\tresult ~= curr_max;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph3syedki.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph3syedki.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.algorithm.sorting : sort;\n    auto result = numbers.dup;\n    foreach (i, num; numbers)\n    {\n        if (i > 0)\n        {\n            result[i] = max(result[i-1], num);\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp22p8sgmy.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp22p8sgmy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] results = new long[numbers.length];\n    int i = 1;\n    results[0] = numbers[0];\n    foreach(n; numbers[1..$]) {\n        if (n > results[i-1]) results[i] = n;\n        else results[i] = results[i-1];\n        i++;\n    }\n    return results;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpm28o5d0y.d(14): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285f6]\n??:? long[] tmpm28o5d0y.rolling_max(long[]) [0x427e69]\n??:? void tmpm28o5d0y.__unittest_L22_C1() [0x427fda]\n??:? void tmpm28o5d0y.__modtest() [0x4282c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c623]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430741]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bf0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b48d]\n??:? runModuleUnitTests [0x42c3f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long maxSoFar = numbers[0];\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] > maxSoFar) \n        {\n            maxSoFar = numbers[i];\n        }\n        result[i] = maxSoFar;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n   \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long minSoFar = numbers[0];\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] < minSoFar) \n        {\n            minSoFar = numbers[i];\n        }\n        result[i] = minSoFar;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling sum of all elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sumSoFar = numbers[0];\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        sumSoFar += numbers[i];\n        result[i] = sumSoFar;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling average of all elements found until given moment\n    in the sequence.\n    >>> rolling_av\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1d3s4x9_.d(63): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1d3s4x9_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto result = new long[numbers.length];\n  auto current_max = numbers[0];\n  auto i = 1;\n  foreach(v;numbers) \n  {\n    if (v > current_max) \n    {\n      current_max = v;\n    }\n    result[i] = current_max;\n    i++;\n  }\n  return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpbk22u0ld.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42853e]\n??:? long[] tmpbk22u0ld.rolling_max(long[]) [0x427e62]\n??:? void tmpbk22u0ld.__unittest_L26_C1() [0x427f22]\n??:? void tmpbk22u0ld.__modtest() [0x428210]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430689]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b38]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430615]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d5]\n??:? runModuleUnitTests [0x42c341]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto last_max = numbers[0];\n    auto result = new long[];\n    for (long number; numbers) {\n        number = numbers.front;\n        numbers.popFront;\n        last_max = max(last_max, number);\n        result ~= last_max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6sn_yt0y.d(14): Error: found `)` when expecting `;` following `for` condition\n/tmp/tmp6sn_yt0y.d(20): Error: found `return` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6sn_yt0y.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From given array of integers, count how many times each value occurs in the array.\n    >>> count_occurrences([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L: 1L, 2L: 3L, 3L: 2L, 4L: 1L]\n    In the case of ties, the order of elements in the tuple is unspecified.\n*/\nMap!(long, long) count_occurrences(long[] numbers) \n{\n    auto result = new Map!(long, long);\n    foreach (n; numbers)\n    {\n        if (result.contains(n))\n        {\n            result[n]++;\n        }\n        else\n        {\n            result[n] = 1;\n        }\n    }\n    return result;\n}\n/*\n    Return the number of occurrences of each character from the alphabet in a given string.\n    >>> count_characters(\"Hello world!\")\n    ['H': 1L, 'e': 1L, 'l': 3L, 'o': 2L, ' ': 1L, 'w': 1L, 'r': 1L, 'd': 1L, '!': 1L]\n*/\nMap!(char, long) count_characters(string s) \n{\n    auto result = new Map!(char, long);\n    foreach (n; s)\n    {\n        if (result.contains(n))\n        {\n            result[n]++;\n        }\n        else\n        {\n            result[n] = 1;\n        }\n    }\n    return result;\n}\n/*\n    Return the list of all possible subsequences of an input string.\n    >>> list_subsequences(\"abc\")\n    [\"\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp51mx2u1a.d(68): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp51mx2u1a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = numbers.dup;\n    foreach (i, e; result)\n    {\n        result[i] = max(result[0..i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt7fabzrx.d(15): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt7fabzrx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_value = numbers[0];\n    long[] r_max = new long[numbers.length];\n    r_max[0] = max_value;\n    foreach(i, v; numbers[1..$])\n    {\n        max_value = max(max_value, v);\n        r_max[i+1] = max_value;\n    }\n    return r_max;\n}\n/*\n Provide a function, which will return the value of the first element, when pushed by the provided\n    distance. As the array does not have to be large enough to accommodate the push, the function is\n    to complete the sequence with zeros.\n    >>> push([1L, 2L, 3L, 4L, 5L], -2)\n    [0L, 0L, 1L, 2L, 3L]\n    >>> push([1L, 2L, 3L, 4L, 5L], 1)\n    [0L, 0L, 0L, 0L, 1L]\n    >>> push([1L, 2L, 3L, 4L, 5L], 5)\n    [0L, 0L, 0L, 0L, 0L]\n*/\nlong[] push(long[] numbers, long distance) \n{\n    long n = 0;\n    foreach(i, v; numbers)\n    {\n        n = max(n, abs(i + distance));\n    }\n    long[] pushed = new long[n+1];\n    foreach(i, v; numbers)\n    {\n        pushed[i + distance] = v;\n    }\n    return pushed;\n}\n/*\nProvide a function, which will return the highest value found in the array, when pushed by the\n    provided distance. As the array does not have to be large enough to accommodate the push, the\n    function is to complete the sequence with zeros.\n    >>> max_push([1L, 2L, 3L, 4L, 5L], -2)\n    2L\n    >>> max_push([1L, 2L, 3L, 4L, 5L], 1)\n    1L\n    >>> max_push([1L, 2L, 3L, 4L, 5\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqs5nc3f1.d(47): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqs5nc3f1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_num = numbers[0];\n    long[] result = new long[numbers.length];\n    for (long i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] > max_num) \n        {\n            max_num = numbers[i];\n        }\n        result[i] = max_num;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp1augneng.d(12): Range violation\n----------------\n??:? _d_arrayboundsp [0x42856e]\n??:? long[] tmp1augneng.rolling_max(long[]) [0x427e4b]\n??:? void tmp1augneng.__unittest_L24_C1() [0x427f4e]\n??:? void tmp1augneng.__modtest() [0x42823c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c59b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b42e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430645]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b405]\n??:? runModuleUnitTests [0x42c371]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    if (numbers.length > 0)\n    {\n        auto result = new long[](numbers.length);\n        result[0] = numbers[0];\n        foreach (i, val; numbers[1 .. $])\n        {\n            result[i] = max(val, result[i - 1]);\n        }\n        return result;\n    }\n    else\n    {\n        return null;\n    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpabnbiot1.d(11): Error: cannot use function constraints for non-template functions. Use `static if` instead\n/tmp/tmpabnbiot1.d(11): Error: declaration expected, not `if`\n/tmp/tmpabnbiot1.d(14): Error: no identifier for declarator `result[0]`\n/tmp/tmpabnbiot1.d(14): Error: declaration expected, not `=`\n/tmp/tmpabnbiot1.d(15): Error: declaration expected, not `foreach`\n/tmp/tmpabnbiot1.d(15): Error: no identifier for declarator `numbers[1 .. __dollar]`\n/tmp/tmpabnbiot1.d(15): Error: declaration expected, not `)`\n/tmp/tmpabnbiot1.d(18): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpabnbiot1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] res = new long[numbers.length];\n    auto max = numbers[0];\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        res[i] = max;\n    }\n    return res;\n}\n/*\n  Given an array of integer and that all elements will be provided at once and \n  then a stream of requests to find the minimum element in a given range, do it efficiently, \n  with complexity ~O(logn) for each request.\n*/\nlong[] min_array_in_range(long[] array, size_t[][] ranges) \n{\n    size_t[][] sparse = sparse_table_creation(array);\n    immutable size_t N = array.length;\n    long[] res = new long[ranges.length];\n    for (size_t i = 0; i < ranges.length; i++) \n    {\n        immutable size_t L = ranges[i][0];\n        immutable size_t R = ranges[i][1];\n        immutable size_t K = ilog2(R - L + 1);\n        res[i] = min(sparse[L][K], sparse[R - (1 << K) + 1][K]);\n    }\n    return res;\n}\n/*\n Creation of the sparse table.\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8t8yf647.d(40): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8t8yf647.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    size_t i = 0;\n    long max_seen = -1;\n    foreach(n; numbers)\n    {\n        //if(n > max_seen)\n        //{\n        //    max_seen = n;\n        //}\n        // We can use max function\n        max_seen = max(max_seen, n);\n        result[i] = max_seen;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpthd_0m_p.d(22): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpthd_0m_p.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long current_max = numbers[0];\n    result[0] = current_max;\n    foreach (index, item; numbers[1..$]) \n    {\n        current_max = max(current_max, item);\n        result[index + 1] = current_max;\n    }\n    return result;\n}\n \n/*\n>| Given a sequence of numbers a_0, a_1, ... a_n, calculate the sum of k * a_k.\n   >>> sum_k_times_a_k([1L, 3L, 2L, 5L, 4L, 2L, 7L], 2L)\n   59L\n   \n>| Return the sum of k * a_k for k = 0 to n, with  n = min(k, len(numbers))\n   >>> sum_k_times_a_k([1L, 3L, 2L, 5L, 4L, 2L, 7L])\n   81L\n*/\nlong sum_k_times_a_k(long[] numbers, long k = 0L) \n{\n    long result = 0L;\n    foreach (index, item; numbers[0..min(k, numbers.length)]) \n    {\n        result += (index + 1L) * item;\n    }\n    return result;\n}\n \n/*\n>| Find the number of times number has to be added to itself to reach or exceed n.\n   >>> number_of_times_to_reach_or_exceed(2L, 10L)\n   5L\n*/\nlong number_of_times_to_reach_or_exceed(long number, long n) \n{\n    long sum = 0L;\n    long times = 0L;\n    while (sum < n) \n    {\n        sum += number;\n        times++;\n    }\n    return times;\n}\n \n/*\n>| Solve challenge\n    >>> solve(10L, 2L, 3L, 11L)\n    38L\n*/\nlong solve(long a, long b, long c, long n) \n{\n    long[] numbers\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpio93lfov.d(67): Error: semicolon expected, not `unittest`\n/tmp/tmpio93lfov.d(67): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpio93lfov.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto res = new long[];\n    res ~= numbers[0];\n    foreach(n; numbers[1..$]) \n    {\n        if (n > res[$-1]) \n        {\n            res ~= n;\n        } \n        else \n        {\n            res ~= res[$-1];\n        }\n    }\n    return res;\n}\n \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkjkdspi3.d(12): Error: new can only create structs, dynamic arrays or class objects, not `long[]`'s\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkjkdspi3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tauto result = new long[](numbers.length);\n\tforeach (i, number; numbers)\n\t{\n\t\tforeach (j; i + 1)\n\t\t{\n\t\t\tresult[i] = max(result[i], numbers[j]);\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz2skghf8.d(15): Error: invalid `foreach` aggregate `i + 1LU`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz2skghf8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[](numbers.length);\n    auto max_element = 0L;\n    auto i = 0;\n    foreach(n; numbers)\n    {\n        result[i] = max(max_element, n);\n        max_element = result[i];\n        i++;\n    }\n    return result;\n}\n \n/*\n  From a given array of integers, generate an array of rolling minimum element found until given moment\n  in the sequence.\n    \n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    auto result = new long[](numbers.length);\n    auto min_element = numbers[0];\n    auto i = 0;\n    foreach(n; numbers)\n    {\n        result[i] = min(min_element, n);\n        min_element = result[i];\n        i++;\n    }\n    return result;\n}\n \n/*\n  From a given array of integers, generate an array of rolling sum of elements found until given moment\n  in the sequence.\n    \n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    auto result = new long[](numbers.length);\n    auto sum = 0L;\n    auto i = 0;\n    foreach(n; numbers)\n    {\n        sum += n;\n        result[i] = sum;\n        i++;\n    }\n    return result;\n}\n \n/*\n  From a given array of integers, generate an array of rolling average of elements found until given moment\n  in the sequence.\n    \n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp20puouo4.d(66): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp20puouo4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, n; numbers[1 .. $]) \n    {\n        result[i] = max(result[i - 1], n);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp10x1hydq.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp10x1hydq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] results = new long[numbers.length];\n    long cur_max = long.min;\n    int i;\n    foreach(i,item;numbers)\n    {\n        results[i] = max(cur_max,item);\n        cur_max = results[i];\n    }\n    return results;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8a5bye8m.d(15): Error: variable `i` is shadowing variable `tmp8a5bye8m.rolling_max.i`\n/tmp/tmp8a5bye8m.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8a5bye8m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long [] result = [numbers[0]];\n    foreach(idx, number; numbers[1..$])\n    {\n        if(number > result[$-1])\n            result ~= number;\n        else\n            result ~= result[$-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpfr7p0f4j.d(12): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285e6]\n??:? long[] tmpfr7p0f4j.rolling_max(long[]) [0x427e5c]\n??:? void tmpfr7p0f4j.__unittest_L22_C1() [0x427fca]\n??:? void tmpfr7p0f4j.__modtest() [0x4282b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cfa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42be36]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430889]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d38]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430815]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be0d]\n??:? runModuleUnitTests [0x42cd79]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] ret = new long[numbers.length];\n\tlong max_num = -(ulong.max);\n\tfor (long i = 0; i < numbers.length; i++)\n\t{\n\t\tmax_num = max(max_num, numbers[i]);\n\t\tret[i] = max_num;\n\t}\n\treturn ret;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\tlong[] ret = new long[numbers.length];\n\tlong min_num = ulong.max;\n\tfor (long i = 0; i < numbers.length; i++)\n\t{\n\t\tmin_num = min(min_num, numbers[i]);\n\t\tret[i] = min_num;\n\t}\n\treturn ret;\n}\n/*\n From a given array of integers, generate an array of rolling sum of element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n\tlong[] ret = new long[numbers.length];\n\tlong current_sum = 0;\n\tfor (long i = 0; i < numbers.length; i++)\n\t{\n\t\tcurrent_sum += numbers[i];\n\t\tret[i] = current_sum;\n\t}\n\treturn ret;\n}\n/*\n Given a sequence of integers, generate an array of the same integers but with values\n    incremented by 1.\n    >>> increment_1([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [2L, 3L, 4L, 3\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpaqeolirb.d(57): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaqeolirb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  long[] res = new long[0];\n  foreach(i, val; numbers)\n  {\n    long[] temp = new long[res.length + 1];\n    temp[] = max(val, i == 0 ? -1 : res[$-1]);\n    res ~= temp;\n  }\n  return res;\n}\n \n/*\n  Given a number n return the minimal steps required to reach 1.\n  If a number is even divide it by 2 otherwise multiply it by 3 and add 1.\n  >>> collatz(6)\n  8\n  >>> collatz(7)\n  17\n  \n*/\nlong collatz(long n) \n{\n  int count = 0;\n  while(n != 1)\n  {\n    if(n % 2 == 0)\n    {\n      n /= 2;\n    }\n    else\n    {\n      n = 3 * n + 1;\n    }\n    count++;\n  }\n  return count;\n}\n/*\n  Flatten a linked list.\n  >>> ll = new std.container.SList!int([1,2,3,4,5]);\n  std.container.SList!int([1, 2, 3, 4, 5])\n  >>> flatten(ll);\n  std.container.SList!int([1, 2, 3, 4, 5])\n  >>> flatten(ll[3]);\n  std.container.SList!int([4, 5])\n*/\nSList!(int) flatten(SList!(int) l) \n{\n  SList!(int) res = new SList!(int)();\n  while(l !is null)\n  {\n    res.insertBack(l.head);\n    l = l.tail;\n  }\n  return res;\n}\n/*\n  A zigzag sequence is a sequence of integers that is made up\n  of alternating sequences of increasing and decreasing numbers.\n  Given a sequence of integers, return its zigzag sequence.\n  >>> zigzag([1,2,3,4,5,6,7,8,9])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpep21i2rm.d(67): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpep21i2rm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] result = new long[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpblj2amt_.d(13): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpblj2amt_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \n    auto result = new long[](numbers.length);\n    result[0] = numbers[0];\n    for (size_t i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpculc0qzd.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpculc0qzd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int length = numbers.length;\n    long[long[]] table = new long[length];\n    long[] maxarr = new long[length];\n    for (int i = 0; i < length; i++)\n    {\n        long[] inner = new long[length];\n        for (int j = 0; j < length; j++)\n        {\n            inner[j] = numbers[j];\n        }\n        table[i] = inner;\n    }\n    for (int i = 0; i < length; i++)\n    {\n        table[i] = table[i][0..i+1];\n        maxarr[i] = max(table[i]);\n    }\n    return maxarr;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmx3u0gy1.d(12): Error: cannot implicitly convert expression `numbers.length` of type `ulong` to `int`\n/tmp/tmpmx3u0gy1.d(13): Error: cannot implicitly convert expression `new long[](cast(ulong)length)` of type `long[]` to `long[const(long)[]]`\n/tmp/tmpmx3u0gy1.d(22): Error: cannot implicitly convert expression `i` of type `int` to `const(long)[]`\n/tmp/tmpmx3u0gy1.d(26): Error: cannot implicitly convert expression `i` of type `int` to `const(long)[]`\n/tmp/tmpmx3u0gy1.d(27): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmx3u0gy1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[numbers.length];\n    auto current_max = long.min;\n    foreach (i, number; numbers) {\n        current_max = max(current_max, number);\n        result[i] = current_max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb5833t6q.d(15): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb5833t6q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    // create a tuple type to store the maximum number found until current moment and the index of\n    // the first occurrence.\n    alias tuple = Tuple!(long, long);\n    // create a stack to store maximum numbers and their indices\n    Stack!tuple stack = new Stack!tuple;\n    // initialize output array\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        // check if the current number is greater than the top of the stack\n        if (stack.length && numbers[i] > stack.top.item1)\n        {\n            // if so, remove all elements smaller than current number\n            while (stack.length && numbers[i] > stack.top.item1)\n                stack.pop();\n            // add current number and its index to the stack\n            stack.push(tuple(numbers[i], i));\n        }\n        else\n        {\n            // if not, push the current number and its index to the stack\n            stack.push(tuple(numbers[i], i));\n        }\n        // check if the index of the top of the stack is smaller than or equal to the index of the\n        // current number\n        if (stack.top.item2 <= i)\n        {\n            // if so, the maximum number found until current moment is the top of the stack\n            result[i] = stack.top.item1;\n        }\n        else\n        {\n            // if not, there was no number greater than the current number until current moment\n            result[i] = -1;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3i4zcbuk.d(16): Error: template instance `Stack!tuple` template `Stack` is not defined\n/tmp/tmp3i4zcbuk.d(16): Error: template instance `Stack!tuple` template `Stack` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3i4zcbuk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t n = numbers.length;\n    assert(n >= 0);\n    if (n == 0)\n        return new long[0];\n    long[] output = new long[n];\n    output[0] = numbers[0];\n    for (size_t i = 1; i < n; i++)\n    {\n        output[i] = max(output[i - 1], numbers[i]);\n    }\n    return output;\n}\nlong[] rolling_max(in long[] numbers) \n{\n    size_t n = numbers.length;\n    assert(n >= 0);\n    if (n == 0)\n        return new long[0];\n    long[] output = new long[n];\n    output[0] = numbers[0];\n    for (size_t i = 1; i < n; i++)\n    {\n        output[i] = max(output[i - 1], numbers[i]);\n    }\n    return output;\n}\nlong[] rolling_max(in long[] numbers) \n{\n    size_t n = numbers.length;\n    assert(n >= 0);\n    if (n == 0)\n        return new long[0];\n    long[] output = new long[n];\n    output[0] = numbers[0];\n    for (size_t i = 1; i < n; i++)\n    {\n        output[i] = max(output[i - 1], numbers[i]);\n    }\n    return output;\n}\nlong[] rolling_max(in long[] numbers) \n{\n    size_t n = numbers.length;\n    assert(n >= 0);\n    if (n == 0)\n        return new long[0];\n    long[] output = new long[n];\n    output[0] = numbers[0];\n    for (size_t i = 1; i < n; i++)\n    {\n        output[i] = max(output[i - 1], numbers[i]);\n    }\n    return output;\n}\nlong[] rolling_max(in long[] numbers) \n{\n    size_t n = numbers.length;\n    assert(n >= 0);\n    if (n == 0\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvd120han.d(71): Error: found `unittest` when expecting `)`\n/tmp/tmpvd120han.d(80): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvd120han.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    auto max = n.front;\n    foreach (i, v; numbers) \n    {\n        if (v > max) \n        {\n            max = v;\n        }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    auto min = n.back;\n    foreach (i, v; numbers) \n    {\n        if (v < min) \n        {\n            min = v;\n        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    foreach (i, v; numbers) \n    {\n        result[i] = numbers[0..i].sum;\n    }\n    return result;\n}\n/*\n Calculate the maximum (value, index) pair in array.\n    >>> max_pair([1L, 3L, 6L, 8L, 11L, 15L, 17L])\n    (17L, 6)\n    \n*/\nTuple!(long, long) max_pair(long[] a) \n{\n    return a.enumerate.max;\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyf9ki22u.d(73): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyf9ki22u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164042
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if (numbers.length == 0)\n        return numbers;\n    return range(0, numbers.length).map!((i) {\n        long max;\n        if (i == 0)\n            max = numbers[i];\n        else\n            max = max(numbers[i], numbers[i - 1]);\n        return max;\n    }).array;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn0i4c6de.d(14): Error: undefined identifier `range`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn0i4c6de.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    enum size_t N = numbers.length;\n    long[] result;\n    if (N == 0)\n    {\n        return result;\n    }\n    else\n    {\n        result = new long[N];\n        result[0] = numbers[0];\n        for (size_t i = 1; i < N; i++)\n        {\n            result[i] = max(result[i - 1], numbers[i]);\n        }\n        return result;\n    }\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1tmh06u1.d(12): Error: variable `numbers` cannot be read at compile time\n/tmp/tmp1tmh06u1.d(24): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1tmh06u1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif (numbers.length == 0)\n\t\treturn numbers;\n\t// -- Create a sliding maximum element\n\tauto prev_max = numbers[0];\n\tforeach (i, ref el; numbers)\n\t{\n\t\tel = max(el, prev_max);\n\t\tprev_max = el;\n\t}\n\treturn numbers;\n}\n/*\n Inplace sum of two arrays, which sizes are equal.\n*/\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4axw8v44.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4axw8v44.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \nin\n{\n    assert(numbers.length > 0);\n}\nbody \n{\n    auto result = new long[](numbers.length);\n    long maximum = numbers[0];\n    result[0] = maximum;\n    foreach (i, v; numbers[1 .. $])\n    {\n        if (v > maximum)\n        {\n            maximum = v;\n        }\n        result[i + 1] = maximum;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzynbe5dg.d(13): Assertion failure\n----------------\n??:? _d_assertp [0x4284d5]\n??:? long[] tmpzynbe5dg.rolling_max(long[]) [0x427e6b]\n??:? void tmpzynbe5dg.__unittest_L30_C1() [0x427f9a]\n??:? void tmpzynbe5dg.__modtest() [0x428288]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c697]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b52a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430741]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b501]\n??:? runModuleUnitTests [0x42c46d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(ch",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \n    \n    auto size = numbers.length;\n    long[] result;\n    auto current_max = numbers[0];\n    result ~= current_max;\n    for(size_t i = 1; i < size; i++)\n    {\n        auto current_number = numbers[i];\n        if(current_number > current_max)\n        {\n            current_max = current_number;\n        }\n        result ~= current_max;\n    }\n    return result;\n    \n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpzo9dzy9y.d(16): Range violation\n----------------\n??:? _d_arrayboundsp [0x42856e]\n??:? long[] tmpzo9dzy9y.rolling_max(long[]) [0x427e60]\n??:? void tmpzo9dzy9y.__unittest_L30_C1() [0x427f4e]\n??:? void tmpzo9dzy9y.__modtest() [0x42823c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cf2b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bdbe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430811]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43079d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bd95]\n??:? runModuleUnitTests [0x42cd01]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, item; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i], item);\n    }\n    return result;\n}\n/*\n * From a given array of integers, generate a count-min sketch.\n * >>> count_min_sketch([1L, 2L, 3L, 4L, 1L, 2L, 5L], 0.001, 0.99)\n * CountMinSketch(0.001, 0.99, matrix([[0L, 1L, 0L, 0L, 0L, 0L, 0L], [0L, 0L, 1L, 0L, 0L, 0L, 0L], [0L, 0L, 0L, 1L, 0L, 0L, 0L], [0L, 0L, 0L, 0L, 1L, 0L, 0L], [1L, 0L, 0L, 0L, 0L, 0L, 0L], [0L, 1L, 0L, 0L, 0L, 0L, 0L], [0L, 0L, 0L, 0L, 0L, 0L, 1L]]), [2L, 2L, 1L, 1L, 1L, 2L, 1L])\n *\n * It is a tuple containing the epsilon and confidence values\n * of the algorithm, the matrix of hashes, and the count of each\n * bucket.\n *\n * This is the same algorithm as in the Python version, but adapted\n * to be used as a template.\n */\nCountMinSketch!(long) count_min_sketch(long[] numbers, double epsilon, double confidence) \n{\n    import std.range : empty;\n    import std.algorithm.iteration : minElement;\n    double delta = 1 - confidence;\n    int width = cast(int)(ceil(1 / epsilon));\n    int depth = cast(int)(ceil(log(1 / delta)));\n    int[][] hashes = new int[][](depth, width);\n    //\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7ko4ht03.d(41): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ko4ht03.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if(!numbers.length)\n    {\n        return [];\n    }\n    long[] res = new long[numbers.length];\n    long max_num = numbers[0];\n    for(size_t i = 0; i < numbers.length; i++)\n    {\n        max_num = max(max_num, numbers[i]);\n        res[i] = max_num;\n    }\n    return res;\n}\n/*\n    Given an array of integers, generate an array of sums of 2 elements in the order they were found.\n    >>> partial_sums([1L, 2L, 3L, 4L, 5L])\n    [3L, 5L, 7L, 9L, 7L]\n    \n*/\nlong[] partial_sums(long[] numbers) \n{\n    if(!numbers.length)\n    {\n        return [];\n    }\n    long[] res = new long[numbers.length];\n    for(size_t i = 0; i < numbers.length; i++)\n    {\n        if(i == 0)\n        {\n            res[i] = numbers[i];\n        }\n        else\n        {\n            res[i] = res[i - 1] + numbers[i];\n        }\n    }\n    return res;\n}\n/*\n    Given an array of integers, generate an array of sums of n consecutive elements in the order they were found.\n    >>> window_sums([1L, 2L, 3L, 4L, 5L], 1)\n    [1L, 2L, 3L, 4L, 5L]\n    >>> window_sums([1L, 2L, 3L, 4L, 5L], 2)\n    [3L, 5L, 7L, 9L]\n    >>> window_sums([1L, 2L, 3L, 4L, 5L], 3)\n    [6L, 9L, 12L]\n    >>> window_sums([1L, 2L, 3L, 4L, 5L], 4)\n    [10L, 14L]\n    >>> window_sums([1L, 2L, 3L, 4L, 5L],\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpukduqvri.d(51): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpukduqvri.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] output = new long[numbers.length];\n    output[0] = numbers[0];\n    foreach (i, n; numbers[1 .. $]) \n    {\n        output[i] = max(output[i - 1], n);\n    }\n    return output;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc9ao_lkx.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc9ao_lkx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[long[]] result = new long[long[]](2);\n    long max_so_far = -_DFL_LONG_MAX;\n    long n = numbers.length;\n    long i;\n    foreach(i; 0..n) \n    {\n        result.insert(max_so_far = max(max_so_far, numbers[i]));\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max2(long[] numbers) \n{\n    long[long[]] result = new long[long[]](2);\n    long max_so_far = -_DFL_LONG_MAX;\n    foreach(num; numbers) \n    {\n        result.insert(max_so_far = max(max_so_far, num));\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max3(long[] numbers) \n{\n    long[long[]] result = new long[long[]](2);\n    long max_so_far = -_DFL_LONG_MAX;\n    foreach(num; numbers) \n    {\n        if(max_so_far < num) \n        {\n            max_so_far = num;\n        }\n        result.insert(max_so_far);\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>>\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg474z4ja.d(12): Error: need size of rightmost array, not type `long[]`\n/tmp/tmpg474z4ja.d(31): Error: need size of rightmost array, not type `long[]`\n/tmp/tmpg474z4ja.d(48): Error: need size of rightmost array, not type `long[]`\n/tmp/tmpg474z4ja.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg474z4ja.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far = numbers[0];\n    return numbers.map!(number =>\n    {\n        if (number > max_so_far)\n        {\n            max_so_far = number;\n        }\n        return max_so_far;\n    });\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjavabcxo.d(13): Error: no property `map` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjavabcxo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in(numbers) out(result) {\n    import std.algorithm;\n    auto result = new long[](numbers.length);\n    result[0] = numbers[0];\n    foreach(i; 1..numbers.length) {\n        result[i] = max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnup8cu_x.d(10): Error: function `tmpnup8cu_x.rolling_max` `in` and `out` contracts can only appear without a body when they are virtual interface functions or abstract\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnup8cu_x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    //@assert(numbers.length > 0);\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    long currentMax = numbers[0];\n    foreach (i, x; numbers[1..$]) \n    {\n        if (x > currentMax) \n        {\n            currentMax = x;\n        }\n        result[i + 1] = currentMax;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpv8ncgqlh.d(14): Range violation\n----------------\n??:? _d_arrayboundsp [0x428596]\n??:? long[] tmpv8ncgqlh.rolling_max(long[]) [0x427e62]\n??:? void tmpv8ncgqlh.__unittest_L26_C1() [0x427f7a]\n??:? void tmpv8ncgqlh.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b456]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43066d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b42d]\n??:? runModuleUnitTests [0x42c399]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\timport std.algorithm;\n\treturn numbers.scan!(a => max(a, b => b))();\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpviwuxl3t.d(13): Error: no property `scan` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpviwuxl3t.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto n = numbers.length;\n    if (n <= 1)\n        return numbers;\n    long[] result = new long[n];\n    result[0] = numbers[0];\n    for (size_t i = 1; i < n; i++) \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpe1zkws9n.d(19): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe1zkws9n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\treturn numbers.isEmpty ? \n\t\t\tnew long[](0) : \n\t\t\tnumbers.take(1) ~ take_while!(numbers[0] >) ~ chain(repeat(numbers[0]))(numbers.drop(1));\n}\n/*\n    Return all tuples of consecutive elements in the given array and their\n    corresponding indices. Indices are 0-based.\n    >>> consecutive_tuples([1L, 2L, 3L, 5L, 6L, 7L, 8L])\n    [(1L, 2L, 0L, 1L), (2L, 3L, 1L, 2L), (5L, 6L, 3L, 4L), (6L, 7L, 4L, 5L), (7L, 8L, 5L, 6L)]\n*/\nauto consecutive_tuples(long[] numbers) \n{\n\t// Check if the resulting array is empty.\n\tif (numbers.length < 2)\n\t\treturn new tuple!(long, long, long, long)[](0);\n\t// It should be implemented using zip.\n\treturn numbers.drop(1).zip(numbers.dropRight(1)).zip(indices).map!(a => tuple(a[0][0], a[0][1], a[1], a[1] + 1L));\n}\n/*\n    Return a copy of the given array with the given item inserted at the given\n    index. The new item will be inserted *after* the given index.\n    >>> insert_at(3L, [1L, 2L, 4L, 5L], 2L)\n    [1L, 2L, 4L, 3L, 5L]\n*/\nlong[] insert_at(long item, long[] input, long index)\n{\n\treturn input.take(index + 1L) ~ [item] ~ input.drop(index + 1L);\n}\n/*\n    Return a copy of the given array with the given item inserted at the given\n    index. The new item will be inserted *before* the given index.\n    >>> insert_at(3L, [1L, 2L, 4L, 5L], 2L)\n    [1\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1nvxi0qm.d(14): Error: expression expected, not `)`\n/tmp/tmp1nvxi0qm.d(14): Error: found `;` when expecting `)` following template argument list\n/tmp/tmp1nvxi0qm.d(15): Error: found `}` when expecting `;` following `return` statement\n/tmp/tmp1nvxi0qm.d(40): Error: unterminated /* */ comment\n/tmp/tmp1nvxi0qm.d(54): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1nvxi0qm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \nin \n{\n    if(numbers.length == 0) \n    {\n        return [];\n    }\n}\nout\n{\n    import std.math;\n    import std.algorithm;\n    import std.array;\n    import std.range;\n    auto r = numbers.front;\n    foreach(i; 0 .. numbers.length) \n    {\n        r ~= max(r.back, numbers[i]);\n    }\n    return r[1 .. $];\n}\ndo \n{\n    import std.algorithm;\n    import std.array;\n    import std.range;\n    import std.typecons;\n    import std.math;\n    alias p = tuple!(long, long, long);\n    auto r = [0L];\n    foreach(i; 1 .. numbers.length) \n    {\n        if(numbers[i] > numbers[i - 1]) \n        {\n            r ~= numbers[i];\n        }\n        else \n        {\n            if(r.back > numbers[i]) \n            {\n                r ~= r.back;\n            }\n            else \n            {\n                r ~= numbers[i];\n            }\n        }\n    }\n    return r;\n}\n \n \n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \nin \n{\n    if(numbers.length == 0) \n    {\n        return [];\n    }\n}\nout\n{\n    import std.math;\n    import std.algorithm;\n    import std.array;\n    import std.range;\n    auto r = numbers.front;\n    foreach(i; 0 .. numbers.length) \n    {\n        r ~= min(r.back, numbers[i]);\n    }\n    return r[1 .. $];\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpol31kblv.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpol31kblv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] res = new long[numbers.length];\n    for (long i = 0; i < numbers.length; i++)\n    {\n        res[i] = max(numbers[0..i+1]);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbjpdjnbn.d(15): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbjpdjnbn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long[] nums = numbers.dup;\n    while (nums.length) \n    {\n        result ~= nums.max;\n        nums = nums[1 .. $];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwz4mrr2d.d(16): Error: no property `max` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwz4mrr2d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long current_max = numbers[0];\n    long[] max_elements = new long[numbers.length];\n    foreach (n; 0 .. numbers.length)\n    {\n        max_elements[n] = current_max;\n        if (numbers[n] > current_max)\n        {\n            current_max = numbers[n];\n        }\n    }\n    return max_elements;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpgobzh9ah.d(12): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpgobzh9ah.rolling_max(long[]) [0x427e4b]\n??:? void tmpgobzh9ah.__unittest_L24_C1() [0x427f5e]\n??:? void tmpgobzh9ah.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto r = numbers[];\n    foreach( i, n; numbers[1..$]) \n    {\n        r ~= max(n, r[$-1]);\n    }\n    return r;\n}\n \n/*\n What will be printed out by the following code?\n    void main() {\n        int[int] m;\n        m[0] = 7;\n        m[1] = 9;\n        int[int] n = m;\n        n[0] = 6;\n        writefln(\"%d %d\", m[0], n[0]);\n    }\n    6 6\n*/\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpib3em4lm.d(15): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpib3em4lm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\timmutable long[] max_so_far = new long[0];\n\timmutable long max = numbers[0];\n\tforeach(number; numbers)\n\t{\n\t\tif(number > max)\n\t\t{\n\t\t\tmax = number;\n\t\t}\n\t\tmax_so_far ~= max;\n\t}\n\treturn max_so_far;\n}\n/*\nGiven an array of n distinct elements, find all unique triplets (three numbers, a, b, c) in array \nsuch that a + b + c = 0\n    >>> find_triplets([-1L, 0L, 1L, 2L, -1L, -4L])\n    [[-1L, -1L, 2L], [-1L, 0L, 1L]]\n*/\nlong[][] find_triplets(long[] numbers)\n{\n\tauto result = new long[][](0);\n\tfor(immutable long i = 0; i < numbers.length; i++)\n\t{\n\t\tfor(immutable long j = i + 1; j < numbers.length; j++)\n\t\t{\n\t\t\tfor(immutable long k = j + 1; k < numbers.length; k++)\n\t\t\t{\n\t\t\t\tif(numbers[i] + numbers[j] + numbers[k] == 0)\n\t\t\t\t{\n\t\t\t\t\tresult ~= [numbers[i], numbers[j], numbers[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyziloib9.d(18): Error: cannot modify `immutable` expression `max`\n/tmp/tmpyziloib9.d(20): Error: cannot modify `immutable` expression `max_so_far`\n/tmp/tmpyziloib9.d(22): Error: cannot implicitly convert expression `max_so_far` of type `immutable(long[])` to `long[]`\n/tmp/tmpyziloib9.d(33): Error: cannot modify `immutable` expression `0L`\n/tmp/tmpyziloib9.d(35): Error: cannot modify `immutable` expression `1L`\n/tmp/tmpyziloib9.d(37): Error: cannot modify `immutable` expression `2L`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyziloib9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] result = new long[numbers.length];\n\tlong current_max = numbers[0];\n\tresult[0] = current_max;\n\tforeach(i, n; numbers[1..$]) \n\t{\n\t\tif (n > current_max)\n\t\t{\n\t\t\tcurrent_max = n;\n\t\t}\n\t\tresult[i + 1] = current_max;\n\t}\n\treturn result;\n}\nlong rolling_sum(long[] numbers) \n{\n\tlong result = 0;\n\tforeach(n; numbers) \n\t{\n\t\tresult += n;\n\t}\n\treturn result;\n}\nlong rolling_max(long[] numbers) \n{\n\tlong result = numbers[0];\n\tforeach(n; numbers) \n\t{\n\t\tif (n > result)\n\t\t{\n\t\t\tresult = n;\n\t\t}\n\t}\n\treturn result;\n}\nlong rolling_min(long[] numbers) \n{\n\tlong result = numbers[0];\n\tforeach(n; numbers) \n\t{\n\t\tif (n < result)\n\t\t{\n\t\t\tresult = n;\n\t\t}\n\t}\n\treturn result;\n}\nclass Piece \n{\n\t// Locations of all indexes\n\tsize_t[] indexes;\n\t// Size of the piece.\n\tsize_t size;\n\t// Number of cells left to fill by this piece\n\tlong[] pieces_left;\n\t// Number of cells which were filled by this piece\n\tlong[] pieces_done;\n\tlong[] pieces_max;\n\tlong[] pieces_sum;\n\t\n\t/*\n\t\tReturn amount of possible ways to fill the pattern.\n\t\t\n\t\tArgs:\n\t\t\tcapacity: Amount of cells which can be filled in a row.\n\t\t\t\n\t\tReturns:\n\t\t\tAmount of possible ways to fill the pattern.\n\t*/\n\tlong get_possibilities(size_t capacity)\n\t{\n\t\tlong temp = 0;\n\t\t\n\t\tif (pieces_max[0] > capacity)\n\t\t{\n\t\t\treturn 0\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvt20uf3l.d(87): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpvt20uf3l.d(96): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpvt20uf3l.d(96): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpvt20uf3l.d(96): Error: `}` expected following members in `class` declaration at /tmp/tmpvt20uf3l.d(58)\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvt20uf3l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    struct rmax {\n        long[] buffer;\n        size_t position;\n        property inout(long) max() inout {\n            return buffer[$-1];\n        }\n        void update(long value) {\n            if (buffer.length < position + 1) \n            {\n                buffer ~= value;\n            }\n            else \n            {\n                buffer[$-1] = max(buffer[$-1], value);\n            }\n            position += 1;\n        }\n    }\n    auto result = new long[];\n    auto r = rmax(result);\n    foreach (n; numbers) \n    {\n        r.update(n);\n        result ~= r.max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxudlkx9_.d(15): Error: no identifier for declarator `property`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxudlkx9_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n     auto result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i], number);\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling cumulative sum of element found in the\n    sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n     auto result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = result[i] + number;\n    }\n    return result;\n}\n/*\n Compute number of prime numbers below a certain limit.\n    \n*/\nlong compute_prime_numbers(long limit) \n{\n    long[] is_prime = new long[limit];\n    is_prime[0..limit] = 1;\n    long prime_numbers = 0;\n    foreach (i; 1..limit + 1) \n    {\n        if (is_prime[i - 1] == 1) \n        {\n            prime_numbers += 1;\n            foreach (j; i * i..limit + 1; i) \n            {\n                is_prime[j - 1] = 0;\n            }\n        }\n    }\n    return prime_numbers;\n}\n/*\n Compute a matrix of dot product of given two matrices.\n    >>> dot_product([[1, 2], [3, 4]], [[1, 0], [0, 1]])\n    [[1, 2], [3, 4]]\n    \n*/\nlong[][] dot_product(long[][] matrix_a, long[][] matrix_b) \n{\n    long[][] result = new long[matrix_a.length][mat\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp05bz0nuw.d(51): Error: found `;` when expecting `)`\n/tmp/tmp05bz0nuw.d(51): Error: found `)` when expecting `;` following statement\n/tmp/tmp05bz0nuw.d(68): Error: found `unittest` when expecting `]`\n/tmp/tmp05bz0nuw.d(69): Error: semicolon expected, not `{`\n/tmp/tmp05bz0nuw.d(77): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp05bz0nuw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[];\n    long max = 0;\n    foreach(num; numbers)\n    {\n        max = max(max, num);\n        result ~= max;\n    }\n    return result;\n}\n/*\n    2.a. Given a sequence of numbers, check if it is acyclic.\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbze7ndrl.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbze7ndrl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    static struct Buffer\n    {\n        long[] data;\n        void* p;\n        size_t size;\n        size_t capacity;\n    }\n    /*\n    Initialize buffer\n    */\n    auto init_buffer(size_t capacity)\n    {\n        Buffer result;\n        result.capacity = capacity;\n        result.size = 0;\n        result.data = new long[capacity];\n        result.p = result.data.ptr;\n        return result;\n    }\n    /*\n    Release buffer\n    */\n    void release_buffer(ref Buffer b)\n    {\n        b.data.ptr = null;\n        b.p = null;\n        b.size = 0;\n        b.capacity = 0;\n    }\n    /*\n    Push number to buffer.\n    If capacity is not enough to store new value, new buffer is created\n    */\n    bool push_buffer(ref Buffer b, long value)\n    {\n        if (b.size == b.capacity)\n        {\n            size_t new_capacity = b.capacity * 2;\n            long[] new_data = new long[new_capacity];\n            new_data[0..b.size] = b.data[0..b.size];\n            release_buffer(b);\n            b = init_buffer(new_capacity);\n            b.data = new_data;\n            b.p = b.data.ptr;\n        }\n        b.data[b.size] = value;\n        b.size++;\n        return true;\n    }\n    /*\n    Fills output with rolling maxima numbers.\n    Returns false if any error occured.\n    */\n    bool calculate_rolling_max(long[] input, long[] output)\n    {\n        Buffer buffer = init_buffer(128);\n        long max = input[0];\n        output[0] = max;\n        push_buffer(buffer, 0);\n        for (size_t i = 1; i < input.length; i++)\n        {\n            if (input[i] > max)\n            {\n                max = input[i];\n                output[i] = max;\n                buffer.size = 0;\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq4awpya7.d(79): Error: found `unittest` instead of statement\n/tmp/tmpq4awpya7.d(88): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpq4awpya7.d(88): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpq4awpya7.d(88): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq4awpya7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.algorithm.comparison : max;\n    import std.algorithm.iteration : scan, dropOne;\n    import std.typecons : tuple;\n    // auto maxNumbers = numbers.scan!(max)(tuple(0L, 0L)).dropOne;\n    auto maxNumbers = numbers.scan!(max)(tuple(0L, 0L));\n    return maxNumbers.map!(t => t[1]).dropOne;\n}\nlong[] find_max_sliding_window(long[] inputArray, size_t windowSize) \n{\n    if (windowSize > inputArray.length) \n    {\n        return new long[](0);\n    }\n    auto result = new long[](inputArray.length - windowSize + 1);\n    foreach (i, j; 0 .. result.length) \n    {\n        result[i] = inputArray[i .. i + windowSize].max;\n    }\n    return result;\n}\n/*\n    Given an array of integers, find the maximum sum of consecutive elements in the array.\n    >>> find_max_sum_subarray([1L, 2L, 3L, 2L, 5L, 2L, 1L])\n    [2L, 5L, 2L]\n*/\nlong[] find_max_sum_subarray(long[] array) \n{\n    import std.algorithm.comparison : max;\n    import std.algorithm.iteration : scan, dropOne;\n    import std.typecons : tuple;\n    auto maxNumbers = array.scan!(max)(tuple(0L, 0L));\n    return maxNumbers.map!(t => t[1]).dropOne;\n}\n/*\n    Given an array of integers and a number k, find maximum sum of a subarray of size k.\n    >>> find_max_subarray_sum([1L, 2L, 3L, 2L, 5L, 2L, 1L], 3)\n    10L\n*/\nlong find_max_subarray_sum(long[] array, size_t k) \n{\n    import std.algorithm.comparison : max;\n    import std.algorithm.iter\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz7vfknhc.d(26): Error: found `..` when expecting `)`\n/tmp/tmpz7vfknhc.d(26): Error: found `)` when expecting `;` following statement\n/tmp/tmpz7vfknhc.d(54): Error: `;` expected\n/tmp/tmpz7vfknhc.d(63): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz7vfknhc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] ret = new long[numbers.length];\n\tlong max = numbers[0];\n\tret[0] = max;\n\tfor (int i = 1; i < numbers.length; i++)\n\t{\n\t\tif (numbers[i] > max)\n\t\t{\n\t\t\tmax = numbers[i];\n\t\t}\n\t\tret[i] = max;\n\t}\n\treturn ret;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpk6jid_af.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428586]\n??:? long[] tmpk6jid_af.rolling_max(long[]) [0x427e62]\n??:? void tmpk6jid_af.__unittest_L25_C1() [0x427f66]\n??:? void tmpk6jid_af.__modtest() [0x428254]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b446]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43065d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]\n??:? runModuleUnitTests [0x42c389]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long currentMax = numbers[0];\n    result[0] = currentMax;\n    foreach (i, num; numbers[1..$]) \n    {\n        if (num > currentMax)\n        {\n            currentMax = num;\n        }\n        result[i + 1] = currentMax;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpc2drjsge.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpc2drjsge.rolling_max(long[]) [0x427e62]\n??:? void tmpc2drjsge.__unittest_L25_C1() [0x427f5e]\n??:? void tmpc2drjsge.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto max_until_now = Array!long();\n  max_until_now ~= numbers[0];\n  for (size_t i = 1; i < numbers.length; i++) \n  {\n    max_until_now ~= max(max_until_now[$ - 1], numbers[i]);\n  }\n  return max_until_now;\n}\nlong[] rolling_max2(long[] numbers) \n{\n  import std.algorithm.comparison : max;\n  return reduce!((a, b) => [a[$ - 1].max(b)])(numbers);\n}\nlong[] rolling_max3(long[] numbers) \n{\n  auto max_until_now = Array!long();\n  max_until_now ~= numbers[0];\n  foreach (n; numbers[1 .. $]) \n  {\n    max_until_now ~= max(max_until_now[$ - 1], n);\n  }\n  return max_until_now;\n}\nlong[] rolling_max4(long[] numbers) \n{\n  return scan!((a, b) => max(a, b))(numbers);\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphy3bdg27.d(12): Error: template instance `Array!long` template `Array` is not defined\n/tmp/tmphy3bdg27.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmphy3bdg27.d(23): Error: template instance `reduce!((a, b) => [a[__dollar - 1].max(b)])` template `reduce` is not defined\n/tmp/tmphy3bdg27.d(27): Error: template instance `Array!long` template `Array` is not defined\n/tmp/tmphy3bdg27.d(31): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmphy3bdg27.d(37): Error: template instance `scan!((a, b) => max(a, b))` template `scan` is not defined, did you mean tan?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphy3bdg27.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    return __rmd2.rolling_max(numbers);\n}\nlong[][] rolling_max_array(long[][] numbers) \n{\n    return __rmd3.rolling_max_array(numbers);\n}\nlong[][][] rolling_max_array(long[][][] numbers) \n{\n    return __rmd4.rolling_max_array(numbers);\n}\nlong[][][][] rolling_max_array(long[][][][] numbers) \n{\n    return __rmd5.rolling_max_array(numbers);\n}\nlong[][][][][] rolling_max_array(long[][][][][] numbers) \n{\n    return __rmd6.rolling_max_array(numbers);\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n*/\ndouble[] rolling_max(double[] numbers) \n{\n    return __rmd2.rolling_max(numbers);\n}\ndouble[][] rolling_max_array(double[][] numbers) \n{\n    return __rmd3.rolling_max_array(numbers);\n}\ndouble[][][] rolling_max_array(double[][][] numbers) \n{\n    return __rmd4.rolling_max_array(numbers);\n}\ndouble[][][][] rolling_max_array(double[][][][] numbers) \n{\n    return __rmd5.rolling_max_array(numbers);\n}\ndouble[][][][][] rolling_max_array(double[][][][][] numbers) \n{\n    return __rmd6.rolling_max_array(numbers);\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpj2ooey6q.d(57): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj2ooey6q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if(!numbers.length)\n        return numbers;\n    \n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(long i = 1L; i < numbers.length; i++) \n    {\n        result[i] = max(result[i - 1L], numbers[i]);\n    }\n    return result;\n}\n \n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    if(!numbers.length)\n        return numbers;\n    \n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(long i = 1L; i < numbers.length; i++) \n    {\n        result[i] = min(result[i - 1L], numbers[i]);\n    }\n    return result;\n}\n \n/*\n From a given array of integers, generate an array of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    if(!numbers.length)\n        return numbers;\n    \n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(long i = 1L; i < numbers.length; i++) \n    {\n        result[i] = result[i - 1L] + numbers[i];\n    }\n    return result;\n}\n \n/*\n From a given array of integers, generate an array of rolling product of elements found until given moment\n    in the sequence.\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo5q03okk.d(66): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo5q03okk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto result = new long[];\n  result ~= numbers[0];\n  foreach(i; 1 .. numbers.length) \n  {\n    result ~= max(result[$-1], numbers[i]);\n  }\n  return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp99cg8v5v.d(12): Error: new can only create structs, dynamic arrays or class objects, not `long[]`'s\n/tmp/tmp99cg8v5v.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp99cg8v5v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long current_max = numbers[0];\n    for (size_t i = 0; i < numbers.length; i++)\n    {\n        result[i] = max(current_max, numbers[i]);\n        current_max = result[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2rz5ayq4.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2rz5ayq4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long current_max = numbers[0];\n    result[0] = current_max;\n    foreach (i, e; numbers[1 .. $]) \n    {\n        current_max = max(current_max, e);\n        result[i + 1] = current_max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpky07m21c.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpky07m21c.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    // TODO: implement\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpw5j23lm4.d(21): unittest failure\n----------------\n??:? _d_unittestp [0x4283cd]\n??:? void tmpw5j23lm4.__unittest_L16_C1() [0x427f4d]\n??:? void tmpw5j23lm4.__modtest() [0x42814c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c437]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430555]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430a04]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4304e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2a1]\n??:? runModuleUnitTests [0x42c20d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42881c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] result = new long[numbers.length];\n\tresult[0] = numbers[0];\n\tfor (int i = 1; i < numbers.length; i++)\n\t{\n\t\tresult[i] = max(result[i - 1], numbers[i]);\n\t}\n\treturn result;\n}\n/*\n From a given array of numbers, generate a new array where each value is the\n sum of values from the original array up to and including it.\n    >>> cumsum([1L, 1L, 1L, 1L, 1L])\n    [1L, 2L, 3L, 4L, 5L]\n*/\nlong[] cumsum(long[] numbers) \n{\n\tlong[] result = new long[numbers.length];\n\tresult[0] = numbers[0];\n\tfor (int i = 1; i < numbers.length; i++)\n\t{\n\t\tresult[i] = result[i - 1] + numbers[i];\n\t}\n\treturn result;\n}\nlong[] cumsum_foreach(long[] numbers) \n{\n\tlong[] result = new long[numbers.length];\n\tresult[0] = numbers[0];\n\tint i = 1;\n\tforeach (ref long number; numbers[1 .. $])\n\t{\n\t\tresult[i] = result[i - 1] + number;\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw1x70csp.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw1x70csp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\t// Type tuple is used to bind the two variables\n\t// first one is the element and the second one is the max \n\t// of the sequence till that point.\n\t// Since we want to update the max each time we iterate,\n\t// we keep the max of the sequence in the second element\n\t// and update it when necessary.\n\tauto tuple = tuple(numbers[0], numbers[0]);\n\tlong[] arr = new long[];\n\tforeach(el; numbers)\n\t{\n\t\ttuple[1] = max(tuple[1], el);\n\t\tarr ~= tuple[1];\n\t}\n\treturn arr;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgms02fs7.d(19): Error: new can only create structs, dynamic arrays or class objects, not `long[]`'s\n/tmp/tmpgms02fs7.d(22): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgms02fs7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto result = new long[](numbers.length);\n  auto current_max = numbers[0];\n  foreach (i, ref e; numbers)\n  {\n    if (e > current_max)\n    {\n      current_max = e;\n    }\n    result[i] = current_max;\n  }\n  return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpmecwhu7a.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42853e]\n??:? long[] tmpmecwhu7a.rolling_max(long[]) [0x427e62]\n??:? void tmpmecwhu7a.__unittest_L24_C1() [0x427f22]\n??:? void tmpmecwhu7a.__modtest() [0x428210]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430689]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b38]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430615]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d5]\n??:? runModuleUnitTests [0x42c341]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] result = new long[numbers.length];\n\t\n\tlong max = numbers[0];\n\tfor(int i = 0; i < numbers.length; i++) \n\t{\n\t\tif(max < numbers[i]) \n\t\t{\n\t\t\tmax = numbers[i];\n\t\t}\n\t\tresult[i] = max;\n\t}\n\treturn result;\n}\n \n/*\n    from a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\tlong[] result = new long[numbers.length];\n\t\n\tlong min = numbers[0];\n\tfor(int i = 0; i < numbers.length; i++) \n\t{\n\t\tif(min > numbers[i]) \n\t\t{\n\t\t\tmin = numbers[i];\n\t\t}\n\t\tresult[i] = min;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpijsskwam.d(14): Range violation\n----------------\n??:? _d_arrayboundsp [0x4286ae]\n??:? long[] tmpijsskwam.rolling_max(long[]) [0x427ea2]\n??:? void tmpijsskwam.__unittest_L47_C1() [0x42808e]\n??:? void tmpijsskwam.__modtest() [0x42837c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b56e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ca8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430785]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b545]\n??:? runModuleUnitTests [0x42c4b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    size_t i = 1;\n    while (i < numbers.length) \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n        i++;\n    }\n    return result;\n}\n//\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    auto cumulative_max = numbers[0];\n    size_t i = 0;\n    while (i < numbers.length) \n    {\n        cumulative_max = max(cumulative_max, numbers[i]);\n        result[i] = cumulative_max;\n        i++;\n    }\n    return result;\n}\n//\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, x; numbers[1 .. $]) \n    {\n        result[i] = max(result[i - 1], x);\n    }\n    return result;\n}\n//\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    foreach (i, x; numbers[1 .. $]) \n    {\n        result[i] = max(result[i - 1], x);\n    }\n    return result;\n}\n//\nlong[] rolling_max(long[] numbers) \n{\n    return new long[numbers.length]\n    {\n        reduce!(max)(numbers[0 .. i])\n        foreach(i; 0 .. numbers.length)\n    };\n}\n//\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    foreach (i, x; numbers[1 .. $]) \n    {\n        result[i] = max(result[i - 1], x);\n    }\n    return result;\n}\n//\nlong[] rolling_max(long[] numbers) \n{\n    long[] result =\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjw9cdoq5.d(61): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpjw9cdoq5.d(63): Error: found `foreach` when expecting `;` following statement\n/tmp/tmpjw9cdoq5.d(63): Error: found `;` when expecting `)`\n/tmp/tmpjw9cdoq5.d(63): Error: found `0` when expecting `;` following statement\n/tmp/tmpjw9cdoq5.d(63): Error: found `..` instead of statement\n/tmp/tmpjw9cdoq5.d(65): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjw9cdoq5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    if (numbers.length > 0) \n    {\n        long maxValue = numbers[0];\n        result[0] = maxValue;\n        foreach (int index, long value; numbers[1 .. $]) \n        {\n            if (value > maxValue)\n                maxValue = value;\n            result[index + 1] = maxValue;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (long i = 1; i < numbers.length; i++)\n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp01_weqlg.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp01_weqlg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwi7sf92g.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwi7sf92g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg3d_i7mt.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg3d_i7mt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.stdio;\n    import std.algorithm;\n    static struct rolling_max_s \n    {\n        long value;\n        size_t index;\n        @property bool opEquals(const ref rolling_max_s rhs) \n        {\n            return value == rhs.value;\n        }\n        @property bool opCmp(const ref rolling_max_s rhs) \n        {\n            return value > rhs.value;\n        }\n    }\n    const rolling_max_s[] max_stack = numbers.map!(n => rolling_max_s(n, 0));\n    long[] result = new long[numbers.length];\n    foreach (ref r, const i; zip(result, max_stack)) \n    {\n        r = max_stack.take(i).max.value;\n    }\n    return result;\n}\n/*\n Given a string containing only the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\n \n    >>> is_valid_parentheses(\"()\")\n    true\n    \n    >>> is_valid_parentheses(\"()[]{}\")\n    true\n    \n    >>> is_valid_parentheses(\"(]\")\n    false\n    \n    >>> is_valid_parentheses(\"([)]\")\n    false\n*/\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp_5lmy5w.d(27): Error: cannot implicitly convert expression `map(numbers)` of type `MapResult!(__lambda3, long[])` to `const(rolling_max_s[])`\n/tmp/tmpp_5lmy5w.d(29): Error: undefined identifier `zip`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_5lmy5w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.range;\n    return numbers.zip(numbers.scan!((a, b) => max(a, b)));\n}\n \n \n \n \n/*\nGiven two arrays of integers, find the intersection.\n    >>> intersection([1L, 2L, 3L, 4L], [3L, 4L, 5L, 6L])\n    [3L, 4L]\n*/\nlong[] intersection(long[] a, long[] b) \n{\n    import std.algorithm.comparison : equal;\n    import std.algorithm.iteration : remove;\n    import std.algorithm.sorting : sort;\n    import std.container.array : array;\n    import std.range : uniq;\n    return a.sort.uniq.array.remove!(i => !(equal(i, b))).sort.uniq.array;\n}\n \n \n \n \n/*\nRemove duplicates from a sequence.\n    >>> remove_duplicates([1L, 2L, 3L, 3L, 4L, 4L, 4L, 5L])\n    [1L, 2L, 3L, 4L, 5L]\n*/\nlong[] remove_duplicates(long[] a) \n{\n    import std.algorithm.iteration : remove;\n    import std.container.array : array;\n    import std.range : uniq;\n    return a.uniq.array;\n}\n \n \n \n \n/*\nRemove zeros from a sequence.\n    >>> remove_zeros([1L, 2L, 0L, 3L, 0L, 4L, 0L, 5L])\n    [1L, 2L, 3L, 4L, 5L]\n*/\nlong[] remove_zeros(long[] a) \n{\n    import std.algorithm.iteration : remove;\n    import std.container.array : array;\n    return a.remove!(i => i == 0).array;\n}\n \n \n \n \n/*\n Remove elements from a given sequence that are divisible by 3.\n    >>> remove_divisible_by_3([1L, 2L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpr_r2oj_5.d(68): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr_r2oj_5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] result;\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp18_lcv9u.d(13): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18_lcv9u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in(numbers.length > 0) \n    out(result.length == numbers.length) \n    body\n{\n    enum n = numbers.length;\n    auto result = new long[](n);\n    result[0] = numbers[0];\n    foreach (idx; 1 .. n) \n    {\n        result[idx] = max(result[idx - 1], numbers[idx]);\n    }\n    return result;\n}\n \n/*\n Generate the answer given an array of rolling maximum elements and a query.\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(1, 4))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(2, 4))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(3, 4))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(1, 5))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(2, 5))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(3, 5))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(4, 5))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(5, 5))\n    3L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(1, 6))\n    4L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L, 4L], tuple(2, 6))\n    4L\n    >>> answer([1L, 2L, 3L, 3L, 3L, 4L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp76onc8js.d(12): Error: found `.` when expecting `)`\n/tmp/tmp76onc8js.d(12): Error: statement expected to be `{ }`, not `length`\n/tmp/tmp76onc8js.d(12): Error: found `)` when expecting `;` following statement\n/tmp/tmp76onc8js.d(25): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76onc8js.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in (numbers.length) out (result)\n    body\n    {\n        long[] result;\n        auto n = numbers.length;\n        foreach (i; 0 .. n) {\n            if (i == 0)\n                result ~= numbers[i];\n            else\n                result ~= max(result[$-1], numbers[i]);\n        }\n        return result;\n    }\n/*\n Given an array of integers, generate an array of rolling maximum integer found until given moment\n    in the sequence, given that the number is smaller than the previous one.\n    >>> rolling_max_if_less([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_max_if_less(long[] numbers) \n    in (numbers.length) out (result)\n    body\n    {\n        long[] result;\n        auto n = numbers.length;\n        foreach (i; 0 .. n) {\n            if (i == 0)\n                result ~= numbers[i];\n            else if (numbers[i] < result[$-1])\n                result ~= numbers[i];\n            else\n                result ~= result[$-1];\n        }\n        return result;\n    }\n/*\n Given an array of integers, generate an array of rolling maximum integer found until given moment\n    in the sequence, given that the number is smaller than the previous one.\n    >>> rolling_max_if_less([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_max_if_less(long[] numbers) \n    in (numbers.length) out (result)\n    body\n    {\n        long[] result;\n        auto n = numbers.length;\n        foreach (i; 0 .. n) {\n            if (i == 0)\n                result ~= numbers[i];\n            else if (numbers[i] < result[$-1])\n               \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd0w_lkwm.d(12): Error: statement expected to be `{ }`, not `body`\n/tmp/tmpd0w_lkwm.d(13): Error: found `{` when expecting `;` following statement\n/tmp/tmpd0w_lkwm.d(16): Error: declaration expected, not `foreach`\n/tmp/tmpd0w_lkwm.d(16): Error: declaration expected, not `0`\n/tmp/tmpd0w_lkwm.d(19): Error: declaration expected, not `else`\n/tmp/tmpd0w_lkwm.d(21): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd0w_lkwm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return numbers;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return numbers;\n}\n/*\n From a given array of integers, generate an array of rolling mean value found until given moment\n    in the sequence.\n    >>> rolling_mean([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1.0, 1.5, 2.0, 2.0, 2.5, 3.0, 2.857142857142857]\n    \n*/\ndouble[] rolling_mean(long[] numbers) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return numbers;\n}\n/*\n From a given array of integers, generate an array of rolling standard deviation value found until given moment\n    in the sequence.\n    >>> rolling_stddev([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [0.0, 0.5, 0.816496580927726, 0.47140452079103173, 0.6123724356957945, 0.816496580927726, 0.7249544498480476]\n    \n*/\ndouble[] rolling_stddev(long[] numbers) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return numbers;\n}\n/*\n From a given array of integers, generate an array of rolling sum of squares found until given moment\n    in the sequence.\n    >>> rolling_sum_of_squ\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsubwkmdm.d(95): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsubwkmdm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max;\n    long[] rollingMaxes;\n    //  max = maxElement(numbers.dup);\n    max = numbers[0];\n    rollingMaxes = new long[numbers.length];\n    for (long i = 0; i < numbers.length; i++)\n    {\n        max = std.math.max(max, numbers[i]);\n        rollingMaxes[i] = max;\n    }\n    return rollingMaxes;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpty53x3n8.d(19): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpty53x3n8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    // FIXME: use std.algorithm.move;\n    import std.array;\n    import std.algorithm;\n    long[] res = new long[numbers.length];\n    auto m = max(numbers[0], 0L);\n    for (size_t i = 0; i < numbers.length; i++)\n    {\n        res[i] = m;\n        m = max(m, numbers[i]);\n    }\n    return res;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    import std.array;\n    import std.algorithm;\n    long[] res = new long[numbers.length];\n    auto m = min(numbers[0], 0L);\n    for (size_t i = 0; i < numbers.length; i++)\n    {\n        res[i] = m;\n        m = min(m, numbers[i]);\n    }\n    return res;\n}\n//https://codegolf.stackexchange.com/questions/48340/help-me-with-these-little-totals\nlong[] rolling_totals(long[] numbers) \n{\n    import std.array;\n    import std.algorithm;\n    long[] res = new long[numbers.length];\n    auto m = numbers[0];\n    for (size_t i = 0; i < numbers.length; i++)\n    {\n        res[i] = m;\n        m += numbers[i];\n    }\n    return res;\n}\n/*\nFind the index of the largest element in the array.\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprymy5j4m.d(57): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprymy5j4m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  auto result = new long[numbers.length];\n  long current_max = long.min;\n  for (size_t i = 0; i < numbers.length; i++) \n  {\n    current_max = max(current_max, numbers[i]);\n    result[i] = current_max;\n  }\n  return result;\n}\n \n \n/*\n Given arrays of elements a, b, and a query array q of integer\n    indices, find for each query element q[i] the maximum value found\n    in a between the indices b[i] and q[i] inclusive.\n    >>> a = [1L, 2L, 3L, 4L, 5L]\n    >>> b = [0L, 0L, 0L, 3L, 3L, 3L, 3L]\n    >>> q = [1L, 2L, 3L, 0L, 1L, 2L, 3L, 4L, 5L]\n    >>> max_in_slice(a, b, q)\n    [2L, 3L, 4L, 4L, 4L, 4L, 5L, 5L, 5L]\n    \n    \n    Given arrays of elements a, b, and a query array q of integer\n    indices, find for each query element q[i] the maximum value found\n    in a between the indices b[i] and q[i] inclusive.\n    >>> a = [2L, 3L, 4L, 5L, 6L]\n    >>> b = [0L, 0L, 0L, 3L, 3L, 3L, 3L]\n    >>> q = [1L, 2L, 3L, 0L, 1L, 2L, 3L, 4L, 5L]\n    >>> max_in_slice(a, b, q)\n    [3L, 4L, 5L, 5L, 5L, 5L, 6L, 6L, 6L]\n    \n    \n    Given arrays of elements a, b, and a query array q of integer\n    indices, find for each query element q[i] the maximum value found\n    in a between the indices b[i] and q[i] inclusive.\n    >>> a =\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpab7h7o4p.d(23): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpab7h7o4p.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] out = new long[$];\n    auto rollingMax = new long[$];\n    auto numbersLength = numbers.length;\n    auto k = $;\n    foreach (i, e; numbers) \n    {\n        rollingMax[i % k] = e;\n        if (i >= k) \n        {\n            rollingMax[i % k] = max(rollingMax[i % k], numbers[i - k]);\n        }\n        out[i] = rollingMax[i % k];\n    }\n    return out;\n}\n \n \n/*\n    Write a function that generates all non-negative integers less than n by\n    repeatedly choosing maximum integer m <= n, such that m is coprime with n,\n    and subtracting m from n.\n    >>> geng(10)\n    [2L, 2L, 1L, 1L, 1L, 1L, 2L, 1L, 1L, 2L]\n*/\nlong[] geng(long n) \n{\n    long[] out = new long[$];\n    int out_i = 0;\n    long m = n;\n    while (m > 0) \n    {\n        out[out_i] = m;\n        m--;\n        while (m > 0 && n % m == 0) \n        {\n            m--;\n        }\n        n -= m;\n        out_i++;\n    }\n    return out;\n}\n \n/*\n    Given a string containing no duplicate characters, return\n    a sorted array of all its distinct characters.\n    >>> distinct_characters(\"abcd\")\n    ['a', 'b', 'c', 'd']\n    >>> distinct_characters(\"bbb\")\n    ['b']\n*/\nchar[] distinct_characters(string s) \n{\n    char[] distinct = new char[$];\n    auto distinct_i = 0;\n    distinct[distinct_i] = s[0];\n    distinct_i++;\n    foreach (c; s[1..$]) \n    {\n        if (distinct.canFind(c) == false) \n        {\n            distinct[distinct_i] = c;\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsty8gkjw.d(12): Error: no identifier for declarator `long[]`\n/tmp/tmpsty8gkjw.d(12): Error: found `out` instead of statement\n/tmp/tmpsty8gkjw.d(15): Error: `$` is valid only inside [] of index or slice\n/tmp/tmpsty8gkjw.d(23): Error: found `out` instead of statement\n/tmp/tmpsty8gkjw.d(25): Error: expression expected, not `out`\n/tmp/tmpsty8gkjw.d(38): Error: no identifier for declarator `long[]`\n/tmp/tmpsty8gkjw.d(38): Error: found `out` instead of statement\n/tmp/tmpsty8gkjw.d(43): Error: found `out` instead of statement\n/tmp/tmpsty8gkjw.d(52): Error: expression expected, not `out`\n/tmp/tmpsty8gkjw.d(74): Error: found `unittest` instead of statement\n/tmp/tmpsty8gkjw.d(83): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpsty8gkjw.d(83): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsty8gkjw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] rolling_max = numbers.dup;\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp17vtf2ra.d(13): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp17vtf2ra.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto deque = deque!long();\n    auto max_numbers = new long[numbers.length];\n    foreach (n; 0 .. numbers.length) \n    {\n        while (!deque.empty && numbers[deque.back] < numbers[n]) \n        {\n            deque.popBack();\n        }\n        deque.pushBack(n);\n        max_numbers[n] = numbers[deque.front];\n        if (deque.front == n - numbers.length) \n        {\n            deque.popFront();\n        }\n    }\n    return max_numbers;\n}\n \n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    auto deque = deque!long();\n    auto min_numbers = new long[numbers.length];\n    foreach (n; 0 .. numbers.length) \n    {\n        while (!deque.empty && numbers[deque.back] > numbers[n]) \n        {\n            deque.popBack();\n        }\n        deque.pushBack(n);\n        min_numbers[n] = numbers[deque.front];\n        if (deque.front == n - numbers.length) \n        {\n            deque.popFront();\n        }\n    }\n    return min_numbers;\n}\n/*\n Find all subarray prefix max.\n    >>> prefix_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n*/\nlong[] prefix_max(long[] items) \n{\n    auto max_items = new long[items.length];\n    foreach (n; 0 .. items.length) \n    {\n        if (\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsgxggpdh.d(66): Error: expression expected, not `unittest`\n/tmp/tmpsgxggpdh.d(67): Error: found `{` when expecting `)`\n/tmp/tmpsgxggpdh.d(75): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsgxggpdh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = std.typecons.minVal!long;\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = std.math.max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2kvcnu3l.d(13): Error: undefined identifier `minVal` in module `std.typecons`\n/tmp/tmp2kvcnu3l.d(16): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2kvcnu3l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    auto max = 0L;\n    size_t i = 0;\n    while (i < numbers.length)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsfntp9al.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsfntp9al.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (current, inout result[1 .. $])\n    {\n        if (numbers[current] > result[current - 1])\n            result[current] = numbers[current];\n        else\n            result[current] = result[current - 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpngfalfu8.d(14): Error: no identifier for declarator `result[1 .. __dollar]`\n/tmp/tmpngfalfu8.d(14): Error: found `)` when expecting `;`\n/tmp/tmpngfalfu8.d(21): Error: found `return` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpngfalfu8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto size = numbers.length;\n    long[size] result;\n    result[0] = numbers[0];\n    foreach (i, v; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i], v);\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    auto size = numbers.length;\n    long[size] result;\n    result[0] = numbers[0];\n    foreach (i, v; numbers[1..$]) \n    {\n        result[i + 1] = min(result[i], v);\n    }\n    return result;\n}\n/*\n For a given array, return the sum of all found elements.\n    >>> array_sum([1L, 2L, 3L, 4L, 5L])\n    15L\n*/\nlong array_sum(long[] array) \n{\n    long result = 0;\n    foreach (x; array) \n    {\n        result += x;\n    }\n    return result;\n}\n/*\n For a given array, return the sum of all found elements.\n    >>> array_sum([1, 2, 3, 4, 5])\n    15\n*/\nlong array_sum(int[] array) \n{\n    long result = 0;\n    foreach (x; array) \n    {\n        result += x;\n    }\n    return result;\n}\n/*\n Return an array containing a sequence of numbers from start to end\n    >>> array_range(1L, 4L)\n    [1L, 2L, 3L, 4L]\n*/\nlong[] array_range(long start, long end) \n{\n    assert(start <= end);\n    long[] result;\n    long range = end - start + 1\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwjqidj0o.d(77): Error: semicolon expected, not `unittest`\n/tmp/tmpwjqidj0o.d(77): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwjqidj0o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.range;\n    auto max_so_far = numbers[0..1].front;\n    return numbers.map!(n => {\n        max_so_far = max(max_so_far, n);\n        return max_so_far;\n    });\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpaky8wf93.d(14): Error: no property `map` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaky8wf93.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_up_to_now = 0;\n    foreach (i, number; numbers) \n    {\n        max_up_to_now = max(max_up_to_now, number);\n        result[i] = max_up_to_now;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdrjk6q7a.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdrjk6q7a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long rolling = numbers[0];\n    long[] res = new long[numbers.length];\n    res[0] = rolling;\n    foreach(const i, e; numbers[1..$])\n    {\n        rolling = max(rolling, e);\n        res[i] = rolling;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwtfxpb2d.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwtfxpb2d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n    long[] ret = new long[];\n    foreach(i, e; numbers)\n    {\n        max = max(max, e);\n        ret ~= max;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfx7pkaaa.d(13): Error: new can only create structs, dynamic arrays or class objects, not `long[]`'s\n/tmp/tmpfx7pkaaa.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfx7pkaaa.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \nin {\n    assert(numbers.length > 0);\n}\nout (result) {\n    result.length == numbers.length;\n    for (int i = 0; i < numbers.length; ++i) {\n        assert(result[i] >= numbers[i]);\n    }\n}\ndo \n{\n    long[] result = numbers[0..$];\n    for (int i = 1; i < numbers.length; ++i) {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplk9gf4nx.d(24): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmplk9gf4nx.d(15): Error: `result.length == numbers.length` has no effect\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplk9gf4nx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long maximum = numbers[0];\n    result[0] = maximum;\n    foreach (index, n; numbers[1..$]) \n    {\n        if (n > maximum) \n        {\n            maximum = n;\n        }\n        result[index + 1] = maximum;\n    }\n    return result;\n}\n/*\n Find the next element of the maximal subsequence in a given sequence\n    >>> next_max_element([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    4L\n*/\nlong next_max_element(long[] numbers) \n{\n    long next_max_element = numbers[0];\n    foreach (n; numbers) \n    {\n        if (n > next_max_element) \n        {\n            next_max_element = n;\n        }\n    }\n    return next_max_element;\n}\n/*\n Construct a bit sequence from a given sequence of integers.\n    >>> sequence_to_bit_sequence([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [0L, 1L, 0L, 1L, 0L, 1L, 0L]\n*/\nlong[] sequence_to_bit_sequence(long[] numbers) \n{\n    long[] bit_sequence = new long[numbers.length];\n    foreach (index, n; numbers) \n    {\n        bit_sequence[index] = n == next_max_element(numbers[index..$]) ? 1L : 0L;\n    }\n    return bit_sequence;\n}\n/*\n Convert a given integer to a binary number.\n    >>> to_binary(10L)\n    [1L, 0L, 1L, 0L]\n*/\nlong[] to_binary(long n) \n{\n    long[] binary = new long[];\n    while (n > 0) \n    {\n        binary ~= n % 2;\n        n /= 2;\n    }\n    return binary;\n}\n/*\n Convert a given binary number to an integer.\n    >>> from_\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpommth0mn.d(71): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpommth0mn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (i, x; numbers[1..$])\n    {\n        max_so_far = max(max_so_far, x);\n        result[i+1] = max_so_far;\n    }\n    return result;\n}\n \n/*\n Given an array of integers and a window size, generate another array containing the\n    rolling minimum element found until given moment in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L], 3L)\n    [1L, 1L, 2L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_min(long[] numbers, size_t window_size) \n{\n    assert(window_size <= numbers.length);\n    size_t n = numbers.length;\n    long[] result = new long[n];\n    long min_so_far = numbers[0];\n    result[0] = min_so_far;\n    for (size_t i = 1; i < n; i++)\n    {\n        if (i >= window_size)\n        {\n            min_so_far = numbers[i - window_size + 1..i].min;\n        }\n        min_so_far = min(min_so_far, numbers[i]);\n        result[i] = min_so_far;\n    }\n    return result;\n}\n \n/*\n Given an array of integers and a window size, generate another array containing the\n    rolling maximum element found until given moment in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L], 3L)\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n*/\nlong[] rolling_max(long[] numbers, size_t window_size) \n{\n    assert(window_size <= numbers.length);\n    size_t n = numbers.length;\n    long\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_ktlgrr6.d(59): Error: no identifier for declarator `long`\n/tmp/tmp_ktlgrr6.d(59): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ktlgrr6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwi7sf92g.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwi7sf92g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long i = 0;\n    long max_so_far = numbers[0];\n    long[] result = new long[numbers.length];\n    foreach(number; numbers) \n    {\n        if (number > max_so_far) \n        {\n            max_so_far = number;\n        }\n        result[i] = max_so_far;\n        i++;\n    }\n    return result;\n}\nlong[][] rolling_max2d(long[][] numbers) \n{\n    long[] temp;\n    long[][] result = new long[numbers.length][];\n    foreach(i, number; numbers) \n    {\n        temp = rolling_max(number);\n        result[i] = temp;\n    }\n    return result;\n}\n/*\n *  check if two arrays are equal\n */\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9yc9pszr.d(29): Error: variable `numbers` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9yc9pszr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tint length = numbers.length;\n\tlong[] maxs = new long[length];\n\tlong max = 0;\n\tfor (int i = 0; i < length; i++) \n\t{\n\t\tmax = max(max, numbers[i]);\n\t\tmaxs[i] = max;\n\t}\n\treturn maxs;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbn5dy9ne.d(12): Error: cannot implicitly convert expression `numbers.length` of type `ulong` to `int`\n/tmp/tmpbn5dy9ne.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbn5dy9ne.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] maxes = new long[numbers.length];\n    long currentMax = numbers[0];\n    foreach(index, value; numbers)\n    {\n        if(value > currentMax)\n        {\n            currentMax = value;\n        }\n        maxes[index] = currentMax;\n    }\n    return maxes;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp96lr69fc.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428536]\n??:? long[] tmp96lr69fc.rolling_max(long[]) [0x427e62]\n??:? void tmp96lr69fc.__unittest_L24_C1() [0x427f1a]\n??:? void tmp96lr69fc.__modtest() [0x428208]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c563]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430681]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b30]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43060d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3cd]\n??:? runModuleUnitTests [0x42c339]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t n = numbers.length;\n    auto result = new long[](n);\n    result[0] = numbers[0];\n    foreach (i; 1 .. n)\n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\n/*\n Given a sequence of numbers, find the second maximum element in the sequence.\n    >>> second_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    3L\n    >>> second_max([3L, 2L, 1L])\n    2L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpewokt25t.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpewokt25t.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  int N = numbers.length;\n  long[] result = new long[N];\n  result[0] = numbers[0];\n  for (int i = 1; i < N; i++) \n  {\n    result[i] = max(result[i - 1], numbers[i]);\n  }\n  return result;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n  int N = numbers.length;\n  long[] result = new long[N];\n  result[0] = numbers[0];\n  for (int i = 1; i < N; i++) \n  {\n    result[i] = min(result[i - 1], numbers[i]);\n  }\n  return result;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n  int N = numbers.length;\n  long[] result = new long[N];\n  result[0] = numbers[0];\n  for (int i = 1; i < N; i++) \n  {\n    result[i] = result[i - 1] + numbers[i];\n  }\n  return result;\n}\n/*\n From a given array of integers, generate an array of rolling product element found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph2mkl7su.d(57): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph2mkl7su.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (long i = 1; i < numbers.length; i++)\n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp01_weqlg.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp01_weqlg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in\n    {\n        assert(numbers.length >= 1);\n    }\n    out\n    (\n        result.length == numbers.length\n    )\n{\n    long[] result = new long[numbers.length];\n    // *IMPORTANT*: std.concurrency cannot be used in @safe code.\n    long max_value = numbers[0];\n    foreach(index, ref num; numbers)\n    {\n        max_value = max(max_value, num);\n        result[index] = max_value;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuy9vwrj6.d(17): Error: found `.` when expecting `)`\n/tmp/tmpuy9vwrj6.d(17): Error: statement expected to be `{ }`, not `length`\n/tmp/tmpuy9vwrj6.d(18): Error: found `)` when expecting `;` following statement\n/tmp/tmpuy9vwrj6.d(19): Error: missing `do { ... }` after `in` or `out`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuy9vwrj6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tint len = numbers.length;\n\tlong[] result = new long[len];\n\t\n\tif (len > 0)\n\t{\n\t\tlong currMax = numbers[0];\n\t\tresult[0] = currMax;\n\t\tfor (int i = 1; i < len; i++)\n\t\t{\n\t\t\tcurrMax = max(currMax, numbers[i]);\n\t\t\tresult[i] = currMax;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n// \n/*\n    From a given array of integers, generate a corresponding array of boolean values\n    which tells, whether the corresponding element in original array is a local maxima\n    or not.\n    >>> local_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [false, false, true, false, true, true, false]\n*/\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjnnqie14.d(12): Error: cannot implicitly convert expression `numbers.length` of type `ulong` to `int`\n/tmp/tmpjnnqie14.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjnnqie14.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = 0;\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        if (max < numbers[i]) \n        {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    long[] stack = new long[n];\n    int top = 0;\n    for (int i = 0; i < n; i++) \n    {\n        while (top > 0 && stack[top - 1] < numbers[i])\n            top--;\n        if (top == 0)\n            result[i] = numbers[i];\n        else\n            result[i] = stack[top - 1];\n        stack[top++] = numbers[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppjwhxa9x.d(12): Error: cannot implicitly convert expression `numbers.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppjwhxa9x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n    auto numbers_max = new long[numbers.length];\n    foreach (i, e; numbers) \n    {\n        if (e > max) \n        {\n            max = e;\n        }\n        numbers_max[i] = max;\n    }\n    return numbers_max;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  //std.algorithm.move(numbers.begin(), numbers.end(), max_numbers.begin());\n  return numbers;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpr82i8_tw.d(21): unittest failure\n----------------\n??:? _d_unittestp [0x4283cd]\n??:? void tmpr82i8_tw.__unittest_L15_C1() [0x427fee]\n??:? void tmpr82i8_tw.__modtest() [0x428150]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b26e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430401]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43038d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b245]\n??:? runModuleUnitTests [0x42c1b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42881c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    // Look for a max for a subsequence\n    for (int i = 0; i < numbers.length; i++) \n    {\n        // Slice subsequence\n        long[] sub_sequence = numbers[0..i];\n        // Calculate max element for subsequence\n        long max_element = reduce!max(sub_sequence);\n        // Fill result array\n        result[i] = max_element;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeayef5yl.d(19): Error: template instance `reduce!max` template `reduce` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeayef5yl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] window;\n    long[] result;\n    result.length = numbers.length;\n    immutable size = window.length;\n    for (immutable i = 0; i < numbers.length; i++)\n    {\n        window ~= numbers[i];\n        if (window.length > size)\n        {\n            window = window[1..$];\n        }\n        if (window.length == size)\n        {\n            immutable maximum = max(window);\n            result[i] = maximum;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp70py0bbc.d(16): Error: cannot modify `immutable` expression `0`\n/tmp/tmp70py0bbc.d(25): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp70py0bbc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.algorithm.iteration : map;\n    import std.algorithm.comparison : max;\n    import std.range : iota;\n    return iota(numbers.length).map!(i => numbers[0..i].max);\n}\n \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3z26opr_.d(15): Error: template `std.algorithm.comparison.max` cannot deduce function from argument types `!()(long[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/comparison.d(1550):        `std.algorithm.comparison.max(T...)(T args) if (T.length >= 2)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):        instantiated from here: `MapResult!(__lambda2, Result)`\n/tmp/tmp3z26opr_.d(15):        instantiated from here: `map!(Result)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3z26opr_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    // this is array of maximum elements found so far.\n    long[] running_maxes = new long[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsn_vix86.d(14): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsn_vix86.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto n = numbers.length;\n    long[] maxes = new long[n];\n    maxes[0] = numbers[0];\n    foreach (i, x; numbers[1..n]) \n    {\n        maxes[i] = max(maxes[i - 1], x);\n    }\n    return maxes;\n}\n//\n//     O(n)\n//\n// From a given array of integers, generate an array of rolling minimum element found until given moment\n//     in the sequence.\n//     >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n//     [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n//     \n//\nlong[] rolling_min(long[] numbers) \n{\n    auto n = numbers.length;\n    long[] mins = new long[n];\n    mins[0] = numbers[0];\n    foreach (i, x; numbers[1..n]) \n    {\n        mins[i] = min(mins[i - 1], x);\n    }\n    return mins;\n}\n//\n//     O(n)\n//\n// From a given array of integers, generate an array of rolling sum elements found until given moment\n//     in the sequence.\n//     >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n//     [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n//     \n//\nlong[] rolling_sum(long[] numbers) \n{\n    auto n = numbers.length;\n    long[] sums = new long[n];\n    sums[0] = numbers[0];\n    foreach (i, x; numbers[1..n]) \n    {\n        sums[i] = sums[i - 1] + x;\n    }\n    return sums;\n}\n//\n//     O(n)\n//\n// From a given array of integers, generate an array of rolling product elements found until given moment\n//     in the sequence.\n//     >>> rolling_product([1L, 2L, 3\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9_v4fxab.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmp9_v4fxab.d(37): Error: undefined identifier `min`, did you mean variable `mins`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9_v4fxab.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] d = new long[numbers.length];\n    d[0] = numbers[0];\n    foreach (i, n; numbers[1..$])\n    {\n        d[i] = max(d[i-1], n);\n    }\n    return d;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqsptc23t.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqsptc23t.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \n    \n    \n}\n \n/*\n Decorates input array with rolling maximum values.\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeyv7r674.d(17): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeyv7r674.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[](numbers.length);\n    long currentMax = numbers[0];\n    foreach (i, n; numbers) {\n        currentMax = max(currentMax, n);\n        result[i] = currentMax;\n    }\n    return result;\n}\nlong max_score(long[] arr)\n{\n    size_t n = arr.length;\n    long[] lmax = rolling_max(arr);\n    long[] rmax = rolling_max(arr[n-1..0]);\n    long score = 0;\n    foreach (i, e; arr) {\n        score += min(lmax[i], rmax[n-1-i]) - e;\n    }\n    return score;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp25fygjeo.d(15): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmp25fygjeo.d(27): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp25fygjeo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    in\n    {\n        assert(numbers.length > 0);\n    }\n    body\n    {\n        long[] result = new long[numbers.length];\n        long max = numbers[0];\n        foreach (idx, n; numbers)\n        {\n            if (n > max)\n            {\n                max = n;\n            }\n            result[idx] = max;\n        }\n        return result;\n    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmps7onisfn.d(13): Assertion failure\n----------------\n??:? _d_assertp [0x428495]\n??:? long[] tmps7onisfn.rolling_max(long[]) [0x427e6b]\n??:? void tmps7onisfn.__unittest_L29_C1() [0x427f56]\n??:? void tmps7onisfn.__modtest() [0x428244]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c657]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430775]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c24]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430701]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4c1]\n??:? runModuleUnitTests [0x42c42d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(ch",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[];\n    long local_max = 0;\n    foreach(n; numbers) \n    {\n        local_max = max(local_max, n);\n        result ~= local_max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp86yyx1_.d(12): Error: new can only create structs, dynamic arrays or class objects, not `long[]`'s\n/tmp/tmpp86yyx1_.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp86yyx1_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[](numbers.length);\n    auto it = numbers.save;\n    foreach (long current_value; numbers)\n    {\n        if (it == numbers.save) {\n            result ~= current_value;\n        } else {\n            result ~= max(current_value, result[$-1]);\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfhpjuprd.d(13): Error: no property `save` for type `long[]`\n/tmp/tmpfhpjuprd.d(16): Error: no property `save` for type `long[]`\n/tmp/tmpfhpjuprd.d(19): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfhpjuprd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, e; numbers[1 .. $])\n    {\n        result[i] = max(result[i - 1], e);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbpbg_0tf.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbpbg_0tf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (long i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nlong[] solve(long[] data, long start, long end) \n{\n    long[] result = new long[data.length];\n    long[] left = rolling_max(data[0..start]);\n    long[] right = rolling_max(data[end..$]);\n    for (long i = 0; i < start; i++) \n    {\n        result[i] = left[i];\n    }\n    for (long i = start; i < end; i++) \n    {\n        result[i] = data[i];\n    }\n    for (long i = end; i < data.length; i++) \n    {\n        result[i] = right[i - end];\n    }\n    return result;\n}\nlong[] solve(long[] data) \n{\n    long[] result = new long[data.length];\n    for (long i = 0; i < data.length; i++) \n    {\n        result[i] = data[i];\n    }\n    for (long start = 0; start < data.length; start++) \n    {\n        for (long end = start + 1; end <= data.length; end++) \n        {\n            long[] v = solve(data, start, end);\n            if (greater(v, result)) \n            {\n                result = v;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzpe9k2_m.d(16): Error: function expected before `()`, not `max` of type `long`\n/tmp/tmpzpe9k2_m.d(52): Error: undefined identifier `greater`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzpe9k2_m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t length = numbers.length;\n    return iota(length).map!(n => numbers[0..n].max);\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb5fdnabw.d(13): Error: undefined identifier `iota`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb5fdnabw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    // TODO: your code here\n    long[] array = new long[numbers.length];\n    long max = 0;\n    foreach(inout i; numbers)\n    {\n        if(i > max)\n        {\n            max = i;\n        }\n        array ~= max;\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5_5jrkw3.d(15): Error: variable `tmp5_5jrkw3.rolling_max.i` `inout` variables can only be declared inside `inout` functions\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5_5jrkw3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (n; numbers[1..$])\n    {\n        max_so_far = max(max_so_far, n);\n        result[n] = max_so_far;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt6p6xqz7.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt6p6xqz7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] ret;\n    long max = numbers[0];\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        ret ~= max;\n    }\n    return ret;\n}\n/*\nFrom a given array of integers, generate an array of rolling minimum element found until given moment\nin the sequence.\n>>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n[1L, 1L, 1L, 1L, 1L, 1L, 1L]\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzdtqlgpq.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzdtqlgpq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto subarrays = tuple(map!(a => numbers[0..a], iota(1, numbers.length + 1)));\n    auto maxs = map!(arr => arr.max)(subarrays);\n    return maxs.array;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7encta2o.d(12): Error: template instance `map!((a) => numbers[0..a], iota(1, numbers.length + 1))` template `map` is not defined\n/tmp/tmp7encta2o.d(13): Error: template instance `map!((arr) => arr.max)` template `map` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7encta2o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    enum MAX_CHUNK_SIZE = 64;\n    enum CMP = 0;\n    enum RESULT = 1;\n    size_t numbers_size = numbers.length;\n    // Tuple!(long, bool)[]\n    auto cmp_result = new Tuple!(long, bool)[](numbers_size);\n    cmp_result[] = tuple(numbers[], true);\n    for (size_t i = 1; i < numbers_size; i++) \n    {\n        if (cmp_result[i - 1][CMP] > numbers[i]) \n        {\n            cmp_result[i] = tuple(cmp_result[i - 1][CMP], false);\n        } \n        else \n        {\n            cmp_result[i] = tuple(numbers[i], true);\n        }\n    }\n    long[] result = new long[](numbers_size);\n    size_t b = MAX_CHUNK_SIZE;\n    for (size_t i = numbers_size - 1; i != size_t.max; i--) \n    {\n        if (cmp_result[i][RESULT]) \n        {\n            for (size_t a = b - 1; a != size_t.max; a--) \n            {\n                result[a] = cmp_result[i][CMP];\n            }\n            b = MAX_CHUNK_SIZE;\n        } \n        else \n        {\n            b--;\n        }\n    }\n    return result;\n}\nlong[] test_rolling_max() \n{\n    assert (rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L]) == [1L, 2L, 3L, 3L, 3L, 4L, 4L]);\n    assert (rolling_max([]) == []);\n    assert (rolling_max([1L]) == [1L]);\n    assert (rolling_max([1L, 2L]) == [1L, 2L]);\n    assert (rolling_max([2L, 1L]) == [2L, 2L]);\n    assert (rolling_max\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvfryagg3.d(57): Error: found `unittest` when expecting `)`\n/tmp/tmpvfryagg3.d(58): Error: found `{` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvfryagg3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    // Type inference failed in constrainded context\n    inout(size_t)[] positions = new size_t[numbers.length];\n    long[] result = new long[numbers.length];\n    auto max_element = std.typecons.scoped(long.max);\n    inout(size_t) max_index = size_t.max;\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] >= max_element) \n        {\n            max_element = numbers[i];\n            max_index = i;\n        }\n        positions[i] = max_index;\n    }\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        result[i] = numbers[positions[i]];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmple793hbc.d(13): Error: variable `tmple793hbc.rolling_max.positions` `inout` variables can only be declared inside `inout` functions\n/tmp/tmple793hbc.d(13): Error: cannot implicitly convert expression `new ulong[](numbers.length)` of type `ulong[]` to `inout(ulong)[]`\n/tmp/tmple793hbc.d(15): Error: template `std.typecons.scoped` cannot deduce function from argument types `!()(long)`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(7512):        `std.typecons.scoped(T) if (is(T == class))`\n/tmp/tmple793hbc.d(16): Error: variable `tmple793hbc.rolling_max.max_index` `inout` variables can only be declared inside `inout` functions\n/tmp/tmple793hbc.d(22): Error: cannot modify `inout` expression `max_index`\n/tmp/tmple793hbc.d(24): Error: cannot modify `inout` expression `positions[i]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmple793hbc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    alias I = size_t;\n    long[I] stack;\n    long[] result;\n    foreach (index, value; numbers) \n    {\n        while (!stack.empty && numbers[stack.back] < value) \n        {\n            stack.popBack();\n        }\n        stack ~= index;\n        if (index >= (I)stack.front) \n        {\n            result ~= numbers[stack.front];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfmagkc5e.d(22): Error: C style cast illegal, use `cast(I)stack.front`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmagkc5e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if (numbers.length == 0) \n    {\n        return numbers;\n    }\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeefz968i.d(20): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeefz968i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] res = new long[numbers.length];\n    res[0] = numbers[0];\n    for (long i = 1; i < numbers.length; i++)\n    {\n        res[i] = max(res[i - 1], numbers[i]);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptp8jl_hu.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptp8jl_hu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (long i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    for (long i = 0; i < numbers.length; i++)\n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling sum \n of elements found until given moment in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    for (long i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2pqusppx.d(16): Error: function expected before `()`, not `max` of type `long`\n/tmp/tmp2pqusppx.d(33): Error: function expected before `()`, not `min` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2pqusppx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.algorithm.iteration : max;\n    import std.algorithm.mutation : popFront;\n    import std.container.array : array;\n    import std.typecons : tuple;\n    import std.conv : to;\n    import std.range : until;\n    import std.math : max;\n    import std.array : split;\n    long[] result = numbers.map!(x => x.max(0L));\n    long[] prefix = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9z8dl3rj.d(22): Error: comma expected separating array initializers, not `unittest`\n/tmp/tmp9z8dl3rj.d(23): Error: semicolon expected, not `{`\n/tmp/tmp9z8dl3rj.d(31): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9z8dl3rj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    assert(!numbers.empty);\n    long[] result = new long[numbers.length];\n    auto max = numbers[0];\n    result[0] = max;\n    foreach(i, v; numbers[1 .. $]) \n    {\n        if (v > max) \n        {\n            max = v;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo7x_x5yu.d(12): Error: no property `empty` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo7x_x5yu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    if (numbers.length == 0)\n        return result;\n    // maximum element seen so far\n    // for the first element, we just assign it to the\n    // maximum element.\n    result[0] = numbers[0];\n    foreach (index, element; numbers[1 .. $]) \n    {\n        // next elements, we store the maximum of\n        // either the current maximum element or the\n        // current element.\n        result[index] = max(result[index - 1], element);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu_gl336i.d(24): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu_gl336i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    size_t index = 0;\n    long max = 0;\n    foreach(number; numbers) \n    {\n        max = max(max, number);\n        result[index] = max;\n        index++;\n    }\n    return result;\n}\n/*\n Given a string, returns a tuple where the first element is the part of the string\n without the last character, and the second element is the last character.\n    \n    >>> pop_last(\"dog\")\n    Tuple!(string, string)(\"do\", \"g\")\n    >>> pop_last(\"\")\n    Tuple!(string, string)(\"\", \"\")\n    \n*/\nTuple!(string, string) pop_last(string input)\n{\n    if(input.length == 0)\n    {\n        return tuple(\"\", \"\");\n    }\n    else\n    {\n        return tuple(input[0..$-1], input[$-1..$]);\n    }\n}\n/*\n Given a string, returns a tuple where the first element is the part of the string\n without the first character, and the second element is the first character.\n    \n    >>> pop_first(\"dog\")\n    Tuple!(string, string)(\"og\", \"d\")\n    >>> pop_first(\"\")\n    Tuple!(string, string)(\"\", \"\")\n    \n*/\nTuple!(string, string) pop_first(string input)\n{\n    if(input.length == 0)\n    {\n        return tuple(\"\", \"\");\n    }\n    else\n    {\n        return tuple(input[1..$], input[0..1]);\n    }\n}\n/*\n Write a function fib(n) which returns the n-th Fibonacci number\n    >>> fib(1)\n    1\n    >>> fib(2)\n    1\n    >>> fib(3)\n    2\n    >>> fib(4)\n    3\n    >>> fib(5)\n    5\n    >>> fib(6)\n    8\n    >>> fib(7)\n    13\n    >>> fib(8)\n    21\n    >>> fib(9)\n    34\n    >>> fib\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpghs16hlf.d(65): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpghs16hlf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    return iota(numbers.length).map!(a => take(a+1, numbers).max).array;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp25zljbp4.d(12): Error: undefined identifier `iota`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp25zljbp4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    auto max_element = new long(numbers[0]);\n    result[0] = max_element;\n    foreach (i, number; numbers[1..$]) \n    {\n        max_element = max(max_element, number);\n        result[i + 1] = max_element;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplykjb8m5.d(14): Error: cannot implicitly convert expression `max_element` of type `long*` to `long`\n/tmp/tmplykjb8m5.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmplykjb8m5.d(18): Error: cannot implicitly convert expression `max_element` of type `long*` to `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplykjb8m5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    size_t write_index = 0;\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n        if (i == 0) \n        {\n            result[write_index] = numbers[i];\n            write_index++;\n        } \n        else \n        {\n            auto new_max = max(result[write_index - 1], numbers[i]);\n            if (new_max != result[write_index - 1]) \n            {\n                result[write_index] = new_max;\n                write_index++;\n            }\n        }\n    }\n    return result[0 .. write_index];\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzy9hltjb.d(23): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzy9hltjb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n    { \n        if(numbers.length == 0) return numbers;\n        size_t size = numbers.length;\n        long[] result = new long[size];\n        size_t index = 0;\n        result[index] = numbers[index];\n        index++;\n        for(index; index < size; index++)\n        {\n            result[index] = max(result[index-1], numbers[index]);\n        }\n        return result;\n    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjqquqyzn.d(18): Error: `index` has no effect\n/tmp/tmpjqquqyzn.d(20): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjqquqyzn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.array;\n    import std.algorithm;\n    import std.range;\n    import std.typecons;\n    import std.math;\n    long[] result = new long[numbers.length];\n    foreach(i, number; numbers)\n    {\n        result[i] = max(numbers[0..i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpda2usquk.d(20): Error: template `std.algorithm.comparison.max` cannot deduce function from argument types `!()(long[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/comparison.d(1550):        `std.algorithm.comparison.max(T...)(T args) if (T.length >= 2)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpda2usquk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    ulong[] max_sequence = new ulong[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp17jymkun.d(13): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp17jymkun.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n     long[] result = new long[numbers.length];\n     foreach (i, e; numbers) \n     {\n         e = numbers[i];\n         result[i] = max(numbers[0..i]);\n     }\n     return result;\n}\n/*\n    rolling maximum 2\n*/\nlong[] rolling_max2(long[] numbers) \n{\n     long[] result = new long[numbers.length];\n     result[0] = numbers[0];\n     for (size_t i = 1; i < numbers.length; i++) \n     {\n         result[i] = max(result[i - 1], numbers[i]);\n     }\n     return result;\n}\n/*\n    rolling maximum 3\n*/\nlong[] rolling_max3(long[] numbers) \n{\n     struct max_history \n     {\n         long max;\n         long[] history;\n     }\n     return unfold!(max_history)(x => x.max, x => x.history, max_history(numbers[0], numbers[1..$]));\n}\n/*\n    rolling maximum 4\n*/\nlong[] rolling_max4(long[] numbers) \n{\n     long[] result = new long[numbers.length];\n     result[0] = numbers[0];\n     for (size_t i = 1; i < numbers.length; i++) \n     {\n         result[i] = max(result[i - 1], numbers[i]);\n     }\n     return result;\n}\n/*\n    rolling maximum 5\n*/\nlong[] rolling_max5(long[] numbers) \n{\n     long[] result = new long[numbers.length];\n     result[0] = numbers[0];\n     for (size_t i = 1; i < numbers.length; i++) \n     {\n         result[i] = max(result[i - 1], numbers[i]);\n     }\n     return result;\n}\n/*\n    rolling maximum 6\n*/\nlong[] rolling_max6(long[] numbers) \n{\n     long[] result = new long[numbers.length];\n     result[0] = numbers[0];\n     for (size_t\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiup3nxhp.d(79): Error: found `unittest` when expecting `;` following statement\n/tmp/tmpiup3nxhp.d(88): Error: found `void` when expecting `;` following `for` condition\n/tmp/tmpiup3nxhp.d(88): Error: found `{` when expecting `)`\n/tmp/tmpiup3nxhp.d(88): Error: found `}` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiup3nxhp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    // 1. find maximum element in an array\n    // 2. for each element of the array, do a slice of the array\n    // 3. each slice is compared to max value\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpluw8ftx_.d(15): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpluw8ftx_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] elements;\n    foreach(i; 0 .. numbers.length)\n    {\n        elements ~= numbers[i .. i + 1].max;\n    }\n    return elements;\n}\n// version 1.0.6\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgonq4kab.d(15): Error: no property `max` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgonq4kab.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] rolling_max_numbers = [];\n    long[] best_until_now = [];\n    foreach(n; numbers)\n    {\n        rolling_max_numbers ~= n;\n        best_until_now ~= max(n, best_until_now);\n    }\n    return rolling_max_numbers;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] rolling_max_numbers = [];\n    long best_until_now = 0;\n    foreach(n; numbers)\n    {\n        rolling_max_numbers ~= n;\n        best_until_now = max(n, best_until_now);\n    }\n    return rolling_max_numbers;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] rolling_max_numbers = [];\n    long best_until_now = 0;\n    foreach(n; numbers)\n    {\n        rolling_max_numbers ~= best_until_now;\n        best_until_now = max(n, best_until_now);\n    }\n    return rolling_max_numbers;\n}\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpivm53lkg.d(57): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpivm53lkg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    // If there are no numbers, then return an empty array.\n    if (numbers.length == 0)\n    {\n        return [];\n    }\n    long max = numbers[0];\n    // Create an array with the same length as numbers and initialize\n    // all elements to max.\n    long[] maxes = new long[numbers.length];\n    foreach (index, val; numbers)\n    {\n        maxes[index] = max;\n        if (val > max)\n        {\n            max = val;\n        }\n    }\n    return maxes;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpokf53t23.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmpokf53t23.__unittest_L31_C1() [0x428029]\n??:? void tmpokf53t23.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c583]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b416]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306a1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b50]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43062d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3ed]\n??:? runModuleUnitTests [0x42c359]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    import std.range;\n    import std.algorithm;\n    import std.array;\n    auto r = numbers.take(1);\n    foreach(i; 1..numbers.length)\n    {\n        r ~= max(numbers[i..$]);\n    }\n    return r;\n}\n/*\ntest \n*/\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpma9nxhos.d(18): Error: template `std.algorithm.comparison.max` cannot deduce function from argument types `!()(long[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/comparison.d(1550):        `std.algorithm.comparison.max(T...)(T args) if (T.length >= 2)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpma9nxhos.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] > max)\n            max = numbers[i];\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpgtrp4y43.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmpgtrp4y43.rolling_max(long[]) [0x427e62]\n??:? void tmpgtrp4y43.__unittest_L22_C1() [0x427f4a]\n??:? void tmpgtrp4y43.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if (numbers.length == 0)\n        return new long[0];\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (size_t i = 1; i < numbers.length; i++)\n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\n/*\n From a given array of integers, generate an array of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    if (numbers.length == 0)\n        return new long[0];\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (size_t i = 1; i < numbers.length; i++)\n    {\n        result[i] = min(result[i - 1], numbers[i]);\n    }\n    return result;\n}\n/*\n Find unique prime factors of a number, i.e. the set of prime factors\n    >>> unique_prime_factors(2L)\n    [2L]\n    >>> unique_prime_factors(27L)\n    [3L]\n    >>> unique_prime_factors(60L)\n    [2L, 3L, 5L]\n    >>> unique_prime_factors(180L)\n    [2L, 3L, 5L]\n    >>> unique_prime_factors(12L)\n    [2L, 3L]\n*/\nulong[] unique_prime_factors(ulong number) \n{\n    if (number == 1)\n        return new ulong[0];\n    auto factors = prime_factors(number);\n    return factors.dedup;\n}\n/*\n    Find all the prime factors of a number.\n    >>> prime_factors(2L)\n    [2L]\n    >>> prime_fact\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2j3vu9k6.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2j3vu9k6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n  return numbers.map!((n) => numbers[0..i].max)();\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeqk03q7b.d(12): Error: no property `map` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeqk03q7b.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] ret = new long[numbers.length];\n    auto maxIter = numbers.maxElement();\n    long max = *maxIter;\n    int maxIndex = maxIter - numbers.begin;\n    int index = 0;\n    foreach(e; numbers)\n    {\n        if(e >= max)\n        {\n            max = e;\n            maxIndex = index;\n        }\n        ret[index] = max;\n        index++;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpf72yjuwr.d(13): Error: no property `maxElement` for type `long[]`\n/tmp/tmpf72yjuwr.d(15): Error: no property `begin` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf72yjuwr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto t = tuple(0L, numbers[0]);\n    auto res = [t];\n    foreach(i, ref v; numbers[1..$])\n    {\n        auto tmp = t.field0;\n        if(t.field1 > v)\n        {\n            t.field0 = i;\n            t.field1 = v;\n        }\n        res ~= t;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuj60ej9p.d(16): Error: no property `field0` for type `Tuple!(long, long)`, did you mean `std.typecons.Tuple!(long, long).Tuple.field`?\n/tmp/tmpuj60ej9p.d(17): Error: no property `field1` for type `Tuple!(long, long)`, did you mean `std.typecons.Tuple!(long, long).Tuple.field`?\n/tmp/tmpuj60ej9p.d(19): Error: no property `field0` for type `Tuple!(long, long)`, did you mean `std.typecons.Tuple!(long, long).Tuple.field`?\n/tmp/tmpuj60ej9p.d(20): Error: no property `field1` for type `Tuple!(long, long)`, did you mean `std.typecons.Tuple!(long, long).Tuple.field`?\n/tmp/tmpuj60ej9p.d(24): Error: cannot implicitly convert expression `res` of type `Tuple!(long, long)[]` to `long[]`\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (size_t i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\n \n/*\n Find period of repetition in the time series.\n    >>> period_lookback([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    3L\n    >>> period_lookback([2L, 3L, 1L, 2L, 3L, 4L, 2L])\n    4L\n    >>> period_lookback([0L, 2L, 1L, 3L, 1L, 2L, 1L])\n    2L\n    >>> period_lookback([0L, 2L, 3L, 1L, 3L, 2L, 1L])\n    2L\n    >>> period_lookback([2L, 3L, 2L, 1L, 3L, 2L, 1L])\n    1L\n    >>> period_lookback([1L, 2L, 3L, 4L, 3L, 2L, 1L])\n    7L\n    >>> period_lookback([1L, 2L, 3L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 3L, 2L, 1L])\n    7L\n*/\nlong period_lookback(long[] numbers) \n{\n    long current_max = numbers[0];\n    size_t i = 1;\n    while (i < numbers.length && numbers[i] > current_max) \n    {\n        current_max = numbers[i];\n        i++;\n    }\n    return i;\n}\n \n/*\n From array of integers, find the period of the repeating subsequence inside the array.\n    >>> period([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    3L\n    >>> period([0L, 2L, 1L, 3L, 1L, 2L, 1L])\n    2L\n    >>> period([2\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6xx2rtj5.d(50): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6xx2rtj5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    enum size_t const size = numbers.length;\n    size_t i = 0;\n    long[] result = new long[size];\n    if(size) \n    {\n        auto max = numbers[0];\n        result[0] = max;\n        for(i = 1; i < size; ++i) \n        {\n            if(numbers[i] > max) \n            {\n                max = numbers[i];\n            }\n            result[i] = max;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp23fxwr4t.d(12): Error: no identifier for declarator `size_t`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp23fxwr4t.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n    long[] result = [];\n    foreach(i, num; numbers)\n    {\n        max = max(max, num);\n        result ~= max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplrylo_sk.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplrylo_sk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[](numbers.length);\n    // manual loop without std.algorithm.max\n    foreach (index, x; numbers) \n    {\n        if (index == 0) \n        {\n            result[index] = x;\n        }\n        else \n        {\n            result[index] = max(result[index - 1], x);\n        }\n    }\n    return result;\n}\n/*\n    From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> max_with_index([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nTuple!(long, long)[] max_with_index(long[] numbers) \n{\n    auto result = new Tuple!(long, long)[](numbers.length);\n    auto maximum = std.algorithm.max(numbers);\n    auto index = numbers.indexOf(maximum);\n    // manual loop without std.algorithm.max\n    foreach (index, x; numbers) \n    {\n        if (index == 0) \n        {\n            result[index] = tuple(x, index);\n        }\n        else \n        {\n            result[index] = result[index - 1];\n            if (maximum < x) \n            {\n                result[index] = tuple(x, index);\n            }\n        }\n    }\n    return result;\n}\n/*\n    From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> min_with_index([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nTuple!(long, long)[] min_with_index(long[] numbers) \n{\n    auto result = new Tuple!(long, long)[](numbers.length);\n    auto minimum = std.\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbzbcx2fc.d(68): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpbzbcx2fc.d(69): Error: semicolon expected following auto declaration, not `{`\n/tmp/tmpbzbcx2fc.d(77): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbzbcx2fc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] ret = new long[numbers.length];\n    long max = long.min;\n    for (size_t i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        ret[i] = max;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpe9cnxb58.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe9cnxb58.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[0];\n    result ~= numbers[0];\n    foreach(i; 1..numbers.length)\n    {\n        result ~= max(result[$-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5shewbve.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5shewbve.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t sz = numbers.length;\n    auto ret = new long[](sz);\n    static if (sz > 0)\n    {\n        ret[0] = numbers[0];\n        for (size_t i = 1; i < sz; i++)\n        {\n            ret[i] = max(ret[i - 1], numbers[i]);\n        }\n    }\n    return ret;\n}\n \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdy5on413.d(14): Error: variable `sz` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdy5on413.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    if (numbers.length == 0) return long.init[];\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (index, number; numbers[1 .. $])\n    {\n        result[index] = max(result[index - 1], number);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgv1cs9_9.d(12): Error: only one index allowed to index `long`\n/tmp/tmpgv1cs9_9.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgv1cs9_9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tint len = numbers.length;\n\tlong[] res = new long[len];\n\t\n\tif (len >= 1) \n\t{\n\t\tres[0] = numbers[0];\n\t\tfor (int i = 1; i < len; i++) \n\t\t{\n\t\t\tif (numbers[i] > res[i - 1])\n\t\t\t\tres[i] = numbers[i];\n\t\t\telse\n\t\t\t\tres[i] = res[i - 1];\n\t\t}\n\t}\n\treturn res;\n}\n/*\n The following function takes a strin and returns the number of vowels in the string.\n The function is case insensitive.\n */\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9nvetexi.d(12): Error: cannot implicitly convert expression `numbers.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9nvetexi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tlong[] result = new long[numbers.length];\n\tlong max_element = numbers[0];\n\tfor (uint i = 0; i < numbers.length; i++) \n\t{\n\t\tmax_element = max(max_element, numbers[i]);\n\t\tresult[i] = max_element;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy5s7365k.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy5s7365k.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif (numbers.length == 0) \n\t{\n\t\treturn [];\n\t}\n\t\n\tauto rolling_max = [=](in long[] numbers) \n\t{\n\t\tlong[] result;\n\t\tresult ~= numbers[0];\n\t\tforeach (i, val; numbers[1 .. $]) \n\t\t{\n\t\t\tif (val > result[$ - 1]) \n\t\t\t{\n\t\t\t\tresult ~= val;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tresult ~= result[$ - 1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\t\n\tlong[] result = rolling_max(numbers);\n\t\n\tassert(result.length == numbers.length);\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tdfxwmh.d(17): Error: expression expected, not `=`\n/tmp/tmp_tdfxwmh.d(17): Error: expression expected, not `in`\n/tmp/tmp_tdfxwmh.d(17): Error: found `long` when expecting `,`\n/tmp/tmp_tdfxwmh.d(17): Error: found `numbers` when expecting `,`\n/tmp/tmp_tdfxwmh.d(18): Error: semicolon expected following auto declaration, not `{`\n/tmp/tmp_tdfxwmh.d(33): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tdfxwmh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        result[i] = max(numbers[0..i]);\n    }\n    return result;\n}\n/*\n This is the sliding window approach.\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max2(long[] numbers) \n{\n    int size = numbers.length;\n    long[] maxSliding = new long[size];\n    auto deque = new Deque!long();\n    deque.insertFront(0);\n    maxSliding[0] = numbers[0];\n    for (int i = 1; i < size; i++) \n    {\n        if (numbers[i] > maxSliding[i - 1]) \n        {\n            maxSliding[i] = numbers[i];\n            deque.clear();\n            deque.insertFront(i);\n        } \n        else \n        {\n            maxSliding[i] = maxSliding[i - 1];\n        }\n        while (!deque.empty && numbers[deque.back] < numbers[i]) \n        {\n            deque.removeBack();\n        }\n        deque.insertBack(i);\n        while (deque.front < i - 3) \n        {\n            deque.removeFront();\n        }\n        maxSliding[i] = max(maxSliding[i], numbers[deque.front]);\n    }\n    return maxSliding;\n}\n// TESTS\nunittest \n{\n    static assert(rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L]) == [1L, 2L, 3L, 3L, 3L, 4L, 4L]);\n    static assert(rolling_max2\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvnrkfvpz.d(64): Error: found `unittest` when expecting `)`\n/tmp/tmpvnrkfvpz.d(65): Error: found `{` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvnrkfvpz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_value = numbers[0];\n    foreach(long i, ref long val; typeof(numbers).init)\n    {\n        max_value = max(max_value, val);\n        result[i] = max_value;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps391xbnr.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps391xbnr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] rolling_maxes = new long[numbers.length];\n    long cur_max = 0;\n    foreach (idx, number; numbers) \n    {\n        if (number > cur_max) \n        {\n            cur_max = number;\n        }\n        rolling_maxes[idx] = cur_max;\n    }\n    return rolling_maxes;\n}\n/*\n    Given an array of integers, and a number 'k', find the maximum for each and every contiguous subarray of size 'k'.\n    >>> max_sliding_window([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L], 4)\n    [4L, 5L, 6L, 7L, 8L, 9L, 10L]\n    \n*/\nlong[] max_sliding_window(long[] numbers, size_t k) \n{\n    long[] max_sliding_window = new long[numbers.length - k + 1];\n    long[] rolling_maxes = rolling_max(numbers);\n    long[] rolling_maxes_window = rolling_maxes[0 .. $ - k + 1];\n    long[] rolling_maxes_window_next = rolling_maxes[k .. $];\n    foreach (idx, rolling_max; rolling_maxes_window) \n    {\n        long next_rolling_max = rolling_maxes_window_next[idx];\n        max_sliding_window[idx] = max(rolling_max, next_rolling_max);\n    }\n    return max_sliding_window;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsbm78ub_.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsbm78ub_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    size_t size = numbers.length;\n    long[] result = new long[size];\n    if (size == 0) return result;\n    result[0] = numbers[0];\n    foreach (i, n; numbers[1 .. $])\n    {\n        if (n >= result[i - 1])\n            result[i] = n;\n        else\n            result[i] = result[i - 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpttmf1c81.d(18): Range violation\n----------------\n??:? _d_arrayboundsp [0x42860e]\n??:? long[] tmpttmf1c81.rolling_max(long[]) [0x427f23]\n??:? void tmpttmf1c81.__unittest_L25_C1() [0x42807a]\n??:? void tmpttmf1c81.__modtest() [0x4282e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c63b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4a5]\n??:? runModuleUnitTests [0x42c411]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long current_max = 0;\n    foreach (i, number; numbers) {\n        if (number > current_max) {\n            current_max = number;\n        }\n        result[i] = current_max;\n    }\n    return result;\n}\n/*\n    Given two parallel arrays:\n    >>> a = [1L, 2L, 3L, 2L, 1L, 2L, 1L]\n    >>> b = [4L, 1L, 2L, 2L, 3L, 1L, 3L]\n    These arrays store the indices of a pair of elements in another array.\n    In this case,\n    >>> a = [1L, 2L, 3L, 2L, 1L, 2L, 1L]\n    >>> b = [4L, 1L, 2L, 2L, 3L, 1L, 3L]\n    For each pair, the element with lower index comes first.\n    Given those two arrays, generate\n    >>> [3L, 4L, 4L, 3L, 1L, 3L, 1L]\n    where each number indicates the length of the longest non-decreasing subsequence,\n    starting from the element in the first array and ending with the element in the second array.\n    If the number is 1, it means that there is no such subsequence.\n    To build this sequence, you will have to maintain an array of the longest non-decreasing subsequence\n    so far for each element.\n    For example, for the sequence\n    >>> [4L, 3L, 2L, 1L, 1L, 2L, 3L, 4L]\n    you will compute the length of the longest non-decreasing subsequence ending at each position:\n    >>> [1L, 1L, 1L, 1L, 1L, 2L, 2L, 3L]\n    and then you will add the result of the longest non-decreasing subsequence starting at each position\n    >>> [1L, 1L, 1L, 1L, 1L, 2L, 2L, 3L]\n    >>> [1L, 1L, 1L, 1L, 1L, 1\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpe8u4jrol.d(22): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe8u4jrol.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n\tif (numbers.length == 0)\n\t\treturn [];\n\t\n\treturn std.algorithm.scan!((a, b) => max(a, b))(numbers).dropOne;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphpijmrdq.d(15): Error: undefined identifier `algorithm` in package `std`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphpijmrdq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    }
  ]
}