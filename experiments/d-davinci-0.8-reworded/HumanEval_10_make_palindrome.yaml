name: HumanEval_10_make_palindrome
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Find the shortest palindrome\
  \ that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find\
  \ the longest postfix of supplied string that is a palindrome.\n    - Append to\
  \ the end of the string reverse of a string prefix that comes before the palindromic\
  \ suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\"\
  )\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \n*/\nstring\
  \ make_palindrome(string string) \n"
tests: "unittest\n{\n    alias candidate = make_palindrome;\n\n    assert(candidate(\"\
  \") == \"\");\n    assert(candidate(\"x\") == \"x\");\n    assert(candidate(\"xyz\"\
  ) == \"xyzyx\");\n    assert(candidate(\"xyx\") == \"xyx\");\n    assert(candidate(\"\
  jerry\") == \"jerryrrej\");\n}\nvoid main(){}"
completions: ["{\n    enum prefix_len = longest_palindrome_end(string);\n    return\
    \ string ~ reverse(string[0 .. $ - prefix_len]);\n}", "{\n    auto len = string.length;\n\
    \    auto prefix = string[0..(len+1)/2];\n    auto reversed_prefix = string[0..(len+1)/2].dup.reverse;\n\
    \    auto postfix = string[(len+1)/2..$];\n    auto prefix_length = longest_common_prefix(prefix,\
    \ reversed_prefix);\n    auto palindrome_postfix = string[(len+1)/2-prefix_length..];\n\
    \    return string ~ reversed_prefix[prefix_length..$];\n}", "{\n    auto palindrome_suffix\
    \ = string.suffixArray.filter!(x => is_palindrome(x));\n    return string ~ string.suffixArray.filter!(x\
    \ => is_palindrome(x)).front.front.reversed.idup;\n}\n// Algorithm taken from\
    \ Programming in D chapter 6", "{\n    auto suffix = string[$-length(string)/2..$];\n\
    \    foreach (i; 0..length(suffix))\n    {\n        auto prefix = string[0..length(string)\
    \ - i];\n        if (suffix == prefix[$-i..$])\n        {\n            return\
    \ string ~ prefix[0..$-i];\n        }\n    }\n    return string;\n}\n/*\nFind\
    \ a shortest palindrome that begins with a supplied string.\n    Algorithm idea\
    \ is simple:\n    - Reverse the supplied string.\n    - Find the longest postfix\
    \ of the reversed string that is a prefix of the original string.\n    - Append\
    \ to the end of the string reverse of a string prefix that comes before the longest\
    \ prefix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \n\
    */\nstring make_palindrome2(string string) \n{\n    auto reversed = string[$-1..0];\n\
    \    foreach (i; 0..length(string))\n    {\n        auto prefix = string[0..i];\n\
    \        if (prefix == reversed[$-i..$])\n        {\n            return string\
    \ ~ reversed[0..$-i];\n        }\n    }\n    return string;\n}\n/*\nFind the longest\
    \ common prefix of two strings.\n    Algorithm idea is simple:\n    - Look for\
    \ a string in another string.\n    - Return the shortest match.\n    >>> longest_common_prefix(\"\
    cat\", \"cata\")\n    \"cat\"\n    >>> longest_common_prefix(\"cata\", \"cat\"\
    )\n    \"cat\"\n    >>> longest_common_prefix(\"cat\", \"dog\")\n    \"\"\n  \
    \  \n*/\nstring longest_common_prefix(string a, string b) \n{\n    foreach (i;\
    \ 0..length(a))\n    {\n        auto prefix = a[0..i];\n        if (b.find(prefix)\
    \ == 0)\n        {\n            return prefix;\n        }\n    }\n    return \"\
    \";\n}\n/*\nFind the longest common suffix of two strings.", "{\n    // Create\
    \ a reversed copy of the string.\n    string reversed;\n    reversed.length =\
    \ string.length;\n    foreach (i, c; string)\n    {\n        reversed[i] = c;\n\
    \    }\n    reversed = reversed.reverse;\n    // Find the longest suffix-palindrome\
    \ of the string.\n    ulong suffix_length = longest_common_substring(string, reversed);\n\
    \    // Build a palindrome out of a string prefix.\n    string prefix = string[0\
    \ .. string.length - suffix_length];\n    return string ~ prefix.reverse;\n}\n\
    /*\n Finds the longest common substring of two strings a and b.\n    See also:\
    \ http://en.wikipedia.org/wiki/Longest_common_substring_problem\n*/\nulong longest_common_substring(string\
    \ a, string b)\n{\n    // Precompute a table of mismatch values.\n    auto table\
    \ = compute_mismatch_table(a, b);\n    // Find the longest common suffix.\n  \
    \  ulong suffix_length = 0;\n    foreach (row; b.length + 1)\n    {\n        if\
    \ (table[row][a.length] > suffix_length)\n        {\n            suffix_length\
    \ = table[row][a.length];\n        }\n    }\n    return suffix_length;\n}\n/*\n\
    \ Computes a table of mismatch values for two strings a and b.\n    For example:\n\
    \        a = \"ab\"\n        b = \"bab\"\n    The output would be:\n        2\
    \ 0 1\n        1 1 0\n        0 2 0\n    See also: http://en.wikipedia.org/wiki/Longest_common_substring_problem\n\
    */\nTuple!(Tuple!(ulong), Tuple!(ulong)) compute_mismatch_table(string a, string\
    \ b)\n{\n    auto table = typeof(return)();\n    // First column contains all\
    \ zeros.\n    table.length = b.length + 1;\n    table[0] = typeof(table[0])();\n\
    \    table[0].length = a.length + 1;\n    // Process each character of string\
    \ b.\n    foreach (row;", "{\n    auto postfix = longest_palindromic_suffix(string);\n\
    \    // reverse a string prefix that comes before the palindromic suffix\n   \
    \ auto prefix = string[0..$-postfix].dup.idup.reverse;\n    // append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix\n\
    \    return string ~ prefix;\n}", "{\n    auto stringLength = string.length;\n\
    \    // A single character string is already a palindrome.\n    if (stringLength\
    \ <= 1)\n        return string;\n    // First calculate the longest palindromic\
    \ suffix of the string.\n    auto longestPalindromicSuffixLength = longestPalindromicSuffix(string).length;\n\
    \    // If that length equals to the length of the string, then the string is\
    \ a palindrome.\n    if (longestPalindromicSuffixLength == stringLength)\n   \
    \     return string;\n    // Calculate the length of the part to be appended.\n\
    \    auto appendLength = stringLength - longestPalindromicSuffixLength;\n    //\
    \ Append the string without the prefix that is a palindrome to the end of the\
    \ string.\n    return string ~ string[0 .. appendLength].dup.reverse;\n}\n \n\
    Tuple!(size_t, size_t) longestPalindromicSuffix(string string) \n{\n    // All\
    \ strings of length 1 are palindromes.\n    if (string.length == 1)\n        return\
    \ tuple(0, 1);\n    // All strings of length 2 are palindromes if they are equal.\n\
    \    if (string.length == 2)\n        return tuple(0, string[0] == string[1] ?\
    \ 2 : 1);\n    // If the first and last characters of the string are equal and\
    \ the string without the first and last\n    // characters is a palindrome, the\
    \ string is a palindrome.\n    if (string[0] == string[$ - 1] && longestPalindromicSuffix(string[1\
    \ .. $ - 1]).length == string.length - 2)\n        return tuple(0, string.length);\n\
    \    // If the first and last characters of the string are not equal, the longest\
    \ palindromic suffix is either\n    // the longest palindromic suffix of the substring\
    \ that omits the first character or the substring that omits\n    // the last\
    \ character. Whichever is the larger.\n    auto left = longestPalindromicSuffix(string[1\
    \ .. $]);\n    auto right = longestPalindromicSuffix(string[0 .. $", "{\n    string\
    \ prefix = string[0..$/2];\n    string suffix = string[($/2 + $ % 2)..$];\n  \
    \  string reverse_prefix = reverse(prefix);\n    string reverse_suffix = reverse(suffix);\n\
    \    string[int] suffix_indexes = suffix.indexOfEach(suffix);\n    string[int]\
    \ reverse_suffix_indexes = reverse_suffix.indexOfEach(reverse_suffix);\n    int\
    \ longest_suffix_palindrome_length = 0;\n    int longest_suffix_palindrome_index\
    \ = 0;\n    foreach (i, index; suffix_indexes) \n    {\n        int length = (index\
    \ + reverse_suffix_indexes[i] + $) - index;\n        if (length > longest_suffix_palindrome_length)\
    \ \n        {\n            longest_suffix_palindrome_length = length;\n      \
    \      longest_suffix_palindrome_index = index;\n        }\n    }\n    return\
    \ prefix ~ string[longest_suffix_palindrome_index..(longest_suffix_palindrome_index\
    \ + longest_suffix_palindrome_length)] ~ reverse_prefix;\n}", "{ \n  if(string.length()\
    \ <= 1) \n  { \n    return string; \n  } \n  else \n  { \n    string postfix =\
    \ make_palindrome(string[1..$]); \n    string s = string + postfix.front; \n \
    \   if(s.length() % 2 == 0) \n    { \n      string prefix = make_palindrome(string[0..$-1]);\
    \ \n      return string + prefix.reverse; \n    } \n    else \n    { \n      string\
    \ prefix = make_palindrome(string[0..$-2]); \n      return string + prefix.reverse;\
    \ \n    } \n  } \n} \n ", "{ \n  int N = string.length; \n  int max_prefix_length;\
    \ \n  for (int i = N-1; i >= 0; i--) \n  { \n    if (string[0..i] == string[i..$].dup.reverse)\
    \ \n    { \n      max_prefix_length = i; \n      break; \n    } \n  } \n  return\
    \ string ~ string[N-1..max_prefix_length].dup.reverse; \n} \n/*\n Compute the\
    \ number of steps required to transform one string into another, where each step\
    \ is the replacement, deletion, or insertion of a single character.\n    \n  \
    \  >>> min_edit_distance(\"cat\", \"cut\")\n    1\n    >>> min_edit_distance(\"\
    sunday\", \"saturday\")\n    3\n    \n*/", "{ \n    auto longest_palindrome_suffix_indices\
    \ = longest_palindrome_suffix(string);\n    auto longest_palindrome_suffix_index\
    \ = longest_palindrome_suffix_indices[0];\n    auto length_of_palindrome_suffix\
    \ = longest_palindrome_suffix_indices[1];\n    auto string_prefix = string[0..$-length_of_palindrome_suffix];\n\
    \    auto string_prefix_reversed = string_prefix.dup.reverse;\n    return string\
    \ ~ string_prefix_reversed;\n}\n/*\nReturn the first index and length of the longest\
    \ palindromic suffix of a string.\n    >>> longest_palindrome_suffix(\"\")\n \
    \   [0, 0]\n    >>> longest_palindrome_suffix(\"cat\")\n    [1, 1]\n    >>> longest_palindrome_suffix(\"\
    cata\")\n    [1, 3]\n    >>> longest_palindrome_suffix(\"abcabcabcabcabcabcabcabcabcabcabc\"\
    )\n    [1, 3]\n*/\n/*\nThe algorithm is based on the observation that the longest\
    \ suffix that is palindrome is\na suffix that also satisfies KMP failure function.\n\
    */\nTuple!(size_t, size_t) longest_palindrome_suffix(string string) \n{\n    size_t\
    \ first_index;\n    size_t length;\n    if (string.length == 0)\n    {\n     \
    \   first_index = 0;\n        length = 0;\n    } \n    else\n    {\n        size_t[]\
    \ failure_function;\n        failure_function.length = string.length;\n      \
    \  size_t prefix_length = 0;\n        size_t suffix_length = 1;\n        failure_function[0]\
    \ = 0;\n        while (suffix_length < string.length)\n        {\n           \
    \ if (string[prefix_length] == string[suffix_length])\n            {\n       \
    \         prefix_length += 1;\n                failure_function[suffix_length]\
    \ = prefix_length;\n                suffix_length += 1;\n            }\n     \
    \       else if (prefix_length != 0", "{\n    static auto longest_palindrome_postfix(string\
    \ string) -> Tuple!(uint, string)((true, \"\"));\n    if (string.empty)\n    \
    \    return tuple!(true, \"\")(0, \"\");\n    if (string.length == 1)\n      \
    \  return tuple!(true, \"\")(1, string);\n    foreach (begin, end; range(string.length,\
    \ 0))\n    {\n        string postfix = string[begin .. end];\n        if (postfix\
    \ == postfix.dup.reverse)\n            return tuple!(true, \"\")(end, postfix);\n\
    \    }\n    return tuple!(true, \"\")(0, \"\");\n}\n \nstring make_palindrome(string\
    \ string) \n{\n    alias Node = Tuple!(bool, string);\n    Node longest_palindrome_postfix(string\
    \ string) \n    {\n        if (string.empty)\n            return tuple!(true,\
    \ \"\")(0, \"\");\n        if (string.length == 1)\n            return tuple!(true,\
    \ \"\")(1, string);\n        foreach (begin, end; range(string.length, 0))\n \
    \       {\n            string postfix = string[begin .. end];\n            if\
    \ (postfix == postfix.dup.reverse)\n                return tuple!(true, \"\")(end,\
    \ postfix);\n        }\n        return tuple!(true, \"\")(0, \"\");\n    }\n \
    \   auto t = longest_palindrome_postfix(string);\n    return string ~ string[0\
    \ .. t[0]].dup.reverse;\n}", "{\n    string front = string[0 .. $/2];\n    string\
    \ back = string[$/2 .. $];\n    int len = front.length;\n    for (int i = len\
    \ - 1; i >= 0; i--) {\n        if (front[i .. i + len - i] == back[0 .. len -\
    \ i]) {\n            return (front ~ back ~ front[0 .. i].dup.reverse).idup;\n\
    \        }\n    }\n    return \"\".idup;\n}\n//test", "{\n    string longest_prefix\
    \ = \"\";\n    string longest_suffix = \"\";\n    string current_prefix = \"\"\
    ;\n    string current_suffix = \"\";\n    uint string_length = string.length;\n\
    \    foreach(i; 0 .. string_length)\n    {\n        current_prefix = string[0\
    \ .. i];\n        current_suffix = string[string_length - i .. $];\n        if(current_prefix\
    \ == current_suffix)\n        {\n            longest_prefix = current_prefix;\n\
    \            longest_suffix = current_suffix;\n        }\n    }\n    return string\
    \ ~ longest_prefix[0 .. longest_prefix.length - longest_suffix.length].reverse;\n\
    }", "{\n    string output = string;\n    uint prefix_size = 0;\n    uint postfix_size\
    \ = 0;\n    /*\n     Find the longest postfix of supplied string that is a palindrome.\n\
    \    */\n    for (uint i = 0; i < string.length; i++) \n    {\n        uint size\
    \ = min(i + 1, string.length - i);\n        if (string[0 .. size] == string[size\
    \ .. $].reverse) \n        {\n            postfix_size = size;\n        }\n  \
    \  }\n    if (postfix_size == 0) \n    {\n        return string;\n    }\n    else\
    \ \n    {\n        /*\n        Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n        */\n        output\
    \ ~= string[postfix_size .. $].reverse;\n    }\n    return output;\n}", "{\n \
    \   string::size_type n = string.length();\n    string::size_type k = 0;\n   \
    \ string::size_type len = 0;\n    if (n == 0) \n    {\n        return string;\n\
    \    }\n    foreach (string::size_type i; 1 .. n + 1)\n    {\n        string::size_type\
    \ j = n - i;\n        if (string[k] == string[j]) \n        {\n            k++;\n\
    \            len++;\n        } \n        else \n        {\n            len = 0;\n\
    \            k = 0;\n        }\n    }\n    string result = string + string[0 ..\
    \ n - k].idup.reverse;\n    return result;\n}\n//Algorithm Description:\n/*\n\
    This algorithm works by slowly building up the solution from left to right. The\
    \ palindrome\nitself is built up in a lagged Fibonacci generator fashion using\
    \ two iterators which step\nat different rates. An iterator is used since with\
    \ one character known, there are two\npossible solutions and we cannot determine\
    \ which one is correct without more information.\nThis is resolved by jumping\
    \ the slower iterator past the entire left hand side of the\nsolution so it is\
    \ ready to accept the next character to the right.", "{\n    // 1) First check\
    \ if the string is already a palindrome - if it is, return it.\n    if (is_palindrome(string))\n\
    \        return string;\n    // 2) Otherwise we have to fix it by adding some\
    \ stuff to the end.\n    // So first get the length of the string.\n    size_t\
    \ n = string.length;\n    // 3) Now we have to find the longest palindromic suffix\
    \ (starting from the end) of the string.\n    // So we can use the z-function\
    \ for this.\n    // We construct an array and a string that is equal to the original\
    \ string reversed.\n    size_t[] z;\n    string reversed;\n    // Then we fill\
    \ the array and the string.\n    reversed = reverse(string);\n    z = z_function(reversed);\n\
    \    // Now we find the longest palindromic suffix.\n    auto longest_palindromic_suffix\
    \ = 0;\n    foreach (i, elem; z)\n    {\n        if (elem + i == n)\n        {\n\
    \            longest_palindromic_suffix = elem;\n            break;\n        }\n\
    \    }\n    // 4) Now we have to append to the end of the string the prefix of\
    \ the string reversed\n    // that comes before the palindromic suffix.\n    //\
    \ So we get a substring of the reversed string, reverse it,\n    // and append\
    \ it to the original string.\n    string prefix = reverse(reversed[0 .. n - longest_palindromic_suffix]);\n\
    \    string += prefix;\n    return string;\n}", "{\n    auto length = string.length;\n\
    \    // Find longest postfix that is a palindrome\n    int longest = 0;\n    foreach\
    \ (i; 0 .. length) \n    {\n        if (string[0 .. length - i] == string[length\
    \ - 1 .. length - i - 1].reverse)\n        {\n            longest = length - i;\n\
    \            break;\n        }\n    }\n    // Append reverse of the string prefix\n\
    \    return string ~ string[0 .. length - longest].reverse;\n}", "{\n    string\
    \ prefix; \n    string postfix;\n    string rev_prefix;\n    string rev_postfix;\n\
    \    string rev_prefix_prefix;\n    size_t prefix_len;\n    size_t postfix_len;\n\
    \    size_t rev_prefix_len;\n    size_t rev_postfix_len;\n    size_t rev_prefix_prefix_len;\n\
    \    size_t string_len;\n    size_t pos;\n    int iter;\n    int k;\n    int j;\n\
    \    int i;\n    iter = 0;\n    string_len = string.length;\n    while (iter <\
    \ string_len && string[iter] == string[string_len - 1 - iter])\n    {\n      \
    \  iter = iter + 1;\n    }\n    postfix = string[0..iter];\n    rev_postfix =\
    \ postfix.dup;\n    rev_postfix.reverse;\n    postfix_len = postfix.length;\n\
    \    rev_postfix_len = rev_postfix.length;\n    pos = string_len - iter;\n   \
    \ if (pos == 0)\n    {\n        prefix = postfix.dup;\n        prefix.reverse;\n\
    \        return prefix ~ postfix;\n    }\n    prefix = string[pos..string_len];\n\
    \    k = 0;\n    while (k < postfix_len && k < prefix.length && postfix[k] ==\
    \ prefix[k])\n    {\n        k = k + 1;\n    }\n    rev_prefix = prefix[k..prefix.length];\n\
    \    rev_prefix.reverse;\n    rev_prefix_len = rev_prefix.length;\n    prefix_len\
    \ = prefix.length;\n    rev_prefix_prefix = rev_prefix[0..(prefix_len - rev_prefix_len)];\n\
    \    rev_prefix_prefix_len = rev_prefix_prefix.length;\n    if (rev_prefix_prefix_len\
    \ == 0)\n    {\n        return prefix ~ rev_postfix;\n    }\n    i = 0;\n    j\
    \ = 0;\n    while (i < rev_prefix_prefix_len && j < postfix_len && rev_prefix_prefix[i",
  "{\n    /*\n        Find the longest suffix that is a palindrome using the KMP algorithm.\n\
    \        This is a nice application of KMP as we need to find the longest suffix\
    \ that matches the prefix.\n        Thus, we can use the KMP fail function to\
    \ find the longest proper suffix that is a proper prefix too.\n        This is\
    \ the same as solving KMP for the reverse of the string.\n    */\n    auto rev\
    \ = string.dup.dup.chomp.reverse;\n    auto pi = kmp(rev);\n    return string\
    \ ~ rev[0..$-pi[$-1]];\n}\n \n \n/*\n    Calculate the KMP fail function for string.\n\
    \    pi[i] = max{k: k < i and s[0:k] == s[i-k:i]}\n*/", "{\n    //\"cata\"\n \
    \   // [ 0, 1, 2, 3 ]\n    // [ \"c\", \"a\", \"t\", \"a\" ]\n    // return [0..1]\n\
    \    size_t[size_t] char_to_index;\n    foreach(index, ch; string)\n    {\n  \
    \      char_to_index[ch] = index;\n    }\n    // char_to_index = [ \"a\": 3, \"\
    c\": 0, \"t\": 2 ]\n    // [ 0, 2, 3 ]\n    size_t[] indices = string.byChunk(char_to_index.byValue);\n\
    \    //string.byChunk(char_to_index.byValue)\n    // byChunk is a built-in function\
    \ defined in std.range\n    /*\n     [ \"c\", \"a\", \"t\", \"a\" ]\n     [ 0,\
    \ 2, 3 ]\n     [ \"c\", \"a\", \"t\", \"a\" ]\n     */\n    assert(string == string.byChunk(char_to_index.byValue));\n\
    \    // Find the longest postfix of supplied string that is a palindrome.\n  \
    \  //size_t longest_palindrome_index = longestPalindromeIndex(string);\n    size_t\
    \ longest_palindrome_index = indices.find(i => !indices.canFind(i, -1));\n   \
    \ // [ 0, 2, 3 ]\n    assert(longest_palindrome_index == 2);\n    string prefix\
    \ = string[0..longest_palindrome_index];\n    assert(prefix == \"ca\");\n    string\
    \ palindrome = prefix ~ reverse(prefix);\n    // palindrome = \"catac\"\n    return\
    \ palindrome;\n}", "{\n    if (string.empty) return string;\n    auto result =\
    \ string;\n    auto longest_postfix = string.getLongestPalindromicSuffix;\n  \
    \  result ~= string[0..$-longest_postfix].dup.reverse;\n    return result;\n}",
  "{\n    if(string.length == 0) \n        return \"\";\n    if(string.length == 1)\
    \ \n        return string ~ string;\n    auto rev_string = string.dup.reverse;\n\
    \    auto first_part = string.join(rev_string[0..$/2]);\n    auto second_part\
    \ = rev_string[$/2..$].reverse;\n    auto longest_suffix = first_part.find(second_part);\n\
    \    auto prefix = string[0..longest_suffix];\n    return string ~ prefix.reverse;\n\
    }", "{ \n    string postfix = \"\"; \n    foreach (i; 0 .. string.length) \n \
    \   { \n        if (string[0 .. i] == string[$ - i .. $]) \n        { \n     \
    \       postfix = string[0 .. i]; \n        } \n    } \n    return string ~ postfix[$\
    \ .. 0]; \n}", "{\n    // Turn the string into a reversed string\n    auto revString\
    \ = string.dup.idup.reverse;\n    auto suffix = string.findOverlap(revString);\n\
    \    // Calculate length of the prefix and the difference between length of the\
    \ string and the length of the prefix\n    auto lenPrefix = string.length - suffix.length;\n\
    \    // Return string with the reverse of the prefix concatenated to the end of\
    \ the string\n    return string ~ revString[0..lenPrefix];\n}\n \n/*\n Find the\
    \ longest common substring between two strings.\n    Idea is to find a matrix\
    \ such that [i, j] entry is 1 iff prefixes of lengths i and j of s1 and s2 are\
    \ equal.\n    To find the longest common substring one needs to find a matrix\
    \ cell with the largest i + j.", "{\n  auto longest_suffix = longest_palindromic_suffix(string);\n\
    \  return string ~ string[0..longest_suffix];\n}\n/*\n    Longest palindromic\
    \ suffix is the longest suffix that is a palindrome.\n    The longest palindromic\
    \ suffix of a string is a suffix that is also\n    a prefix and a palindrome:\n\
    \    >>> longest_palindromic_suffix(\"cat\")\n    0\n    >>> longest_palindromic_suffix(\"\
    cata\")\n    1\n    >>> longest_palindromic_suffix(\"abcba\")\n    4\n*/\nsize_t\
    \ longest_palindromic_suffix(string string)\n{\n  size_t length = string.length;\n\
    \  size_t start = 0;\n  size_t end = length;\n  for (; end > start; end--) \n\
    \  {\n    if (is_palindrome(string[start..end]))\n    {\n      return end - start;\n\
    \    }\n  }\n  return 0;\n}", "{\n\tstring result = null;\n\tint count = 0;\n\t\
    string first_half = null;\n\tstring last_half = null;\n\t\n\tint length = string.length;\n\
    \tint mid = length / 2;\n\twhile (mid >= 0) \n\t{\n\t\tif (mid >= length - 1 -\
    \ mid) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (string[mid] == string[length - 1\
    \ - mid]) \n\t\t{\n\t\t\t++count;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tbreak;\n\t\t\
    }\n\t\t--mid;\n\t}\n\tfirst_half = string[0..mid];\n\tlast_half = string[(length\
    \ - mid)..$];\n\tresult = first_half ~ reverse(first_half) ~ last_half;\n\treturn\
    \ result;\n}", "{\n    int count = string.length;\n    size_t[string.length +\
    \ 1] z;\n    for (int i = 1; i <= count; i++) {\n        z[i] = 0;\n    }\n  \
    \  int l = 0;\n    int r = 0;\n    for (int i = 1; i < count; i++) {\n       \
    \ if (i <= r) \n        {\n            z[i] = min(r - i + 1, z[i - l]);\n    \
    \    }\n        while (i + z[i] < count && string[z[i]] == string[i + z[i]]) \n\
    \        {\n            z[i]++;\n        }\n        if (i + z[i] - 1 > r) \n \
    \       {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n\
    \    int palindrome_length = r + 1;\n    string a = string[0..palindrome_length];\n\
    \    string b = string[palindrome_length..$];\n    string c = b.dup.reverse;\n\
    \    return a ~ c;\n}\n//", "{\n    string longest_palindrome;\n    string prefix;\n\
    \    if (string.length > 0) {\n        longest_palindrome = string[0 .. 0];\n\
    \        foreach (idx; 1 .. string.length) {\n            if (string[0 .. idx]\
    \ == string[$ - idx .. $]) {\n                longest_palindrome = string[0 ..\
    \ idx];\n            }\n        }\n        prefix = string[longest_palindrome.length\
    \ .. $];\n    }\n    return string ~ reverse(prefix);\n}", "{ \n    string longest_prefix\
    \ = longest_palindromic_prefix(string); \n    return string ~ reverse(longest_prefix[0\
    \ ..$-1]); \n} \n ", "{\n    static  int lookup_table(int,int) =\n    {\n    \
    \    {\n            {\n                return 0;\n            }\n        }\n \
    \   };\n    int start = 0;\n    int end = string.length - 1;\n    while (start\
    \ < end) \n    {\n        if (string[start] != string[end]) \n        {\n    \
    \        break;\n        }\n        start++;\n        end--;\n    }\n    if (start\
    \ == end) \n    {\n        return string;\n    }\n    string prefix = make_palindrome(string[0..start]);\n\
    \    string result = prefix[0..$ - (start - end) - 1] ~ string;\n    return result;\n\
    }", "{\n    if (string.empty)\n    {\n        return string;\n    }\n    string\
    \ reversed = string.dup.idup.reverse;\n    auto longest_common_subsequence = longestCommonSubsequence(string,\
    \ reversed);\n    return string ~ longest_common_subsequence.dup.idup.reverse;\n\
    }", "in {\n    import std.algorithm : chunk, zip, countUntil, isEqual;\n    import\
    \ std.functional : flipped;\n    import std.array : array;\n    import std.conv\
    \ : to;\n    import std.range : iterate, zip;\n    import std.typecons : tuple;\n\
    \    import std.range : cycle;\n    import std.array : array;\n} out (result)\
    \ {\n    import std.algorithm : chunk, zip, countUntil, isEqual;\n    import std.functional\
    \ : flipped;\n    import std.array : array;\n    import std.conv : to;\n    import\
    \ std.range : iterate, zip;\n    import std.typecons : tuple;\n    import std.range\
    \ : cycle;\n    import std.array : array;\n} body {\n    import std.algorithm\
    \ : chunk, zip, countUntil, isEqual;\n    import std.functional : flipped;\n \
    \   import std.array : array;\n    import std.conv : to;\n    import std.range\
    \ : iterate, zip;\n    import std.typecons : tuple;\n    import std.range : cycle;\n\
    \    import std.array : array;\n    \n    auto c = string.countUntil;\n    auto\
    \ is_palindrome = (string s) {\n        return c(chunk(s.zip(s.retro), tuple(flipped(isEqual))),\
    \ (t) => !t[0]);\n    };\n    auto palindrome_postfix = (string s) {\n       \
    \ size_t len = s.length;\n        size_t max_len = 2 * len - 1;\n        auto\
    \ idx = array(iterate!(iota(size_t.max), a => a + 1).take(max_len).map!(x => x\
    \ % len).filter!(x => s[x] == s[0]));\n        size_t max_palindrome_length =\
    \ idx.map!(x => is_palindrome(s[x..$])).map!(x => len - x).max;\n        return\
    \ s[len - max_palindrome_length..$];\n    };\n    auto palindrome_postfix_and_",
  "{\n    auto a = string.dup;\n    reverse(a);\n    auto r = string.dup;\n    r ~=\
    \ a;\n    foreach(i;0..string.length)\n    {\n        if(string[i..$] == a[0..a.length-i])\n\
    \        {\n            return r[0..string.length+i];\n        }\n    }\n    return\
    \ r;\n}", "{ \n    immutable len = string.length;\n    auto s = string[0..$/2];\n\
    \    immutable prefix_len = s.length;\n    auto postfix = string[$/2..$];\n  \
    \  immutable postfix_len = postfix.length;\n    static if(string.length % 2 ==\
    \ 0)\n    {\n        postfix ~= string[$/2 - 1..0];\n    }\n    else\n    {\n\
    \        postfix ~= string[$/2..0];\n    }\n    auto pattern = postfix.idup;\n\
    \    immutable pattern_len = pattern.length;\n    auto prefix_suffix_lengths =\
    \ new int[prefix_len + 1];\n    auto suffix_len = 0;\n    auto prefix_iter = 0;\n\
    \    while(prefix_iter < prefix_len)\n    {\n        if(prefix_suffix_lengths[suffix_len]\
    \ == 0 && string[prefix_iter] == string[suffix_len])\n        {\n            suffix_len\
    \ += 1;\n            prefix_suffix_lengths[prefix_iter + 1] = suffix_len;\n  \
    \          prefix_iter += 1;\n        }\n        else if(suffix_len > 0)\n   \
    \     {\n            suffix_len = prefix_suffix_lengths[suffix_len];\n       \
    \ }\n        else\n        {\n            prefix_suffix_lengths[prefix_iter +\
    \ 1] = 0;\n            prefix_iter += 1;\n        }\n    }\n    auto prefix_suffix_length\
    \ = prefix_suffix_lengths[prefix_len];\n    auto max_prefix_suffix_length = 0;\n\
    \    auto pattern_pos = 0;\n    while(prefix_suffix_length > 0)\n    {\n     \
    \   if(pattern_pos == pattern_len)\n        {\n            max_prefix_suffix_length\
    \ = prefix_suffix_length;\n            prefix_suffix_length = prefix_suffix_lengths[prefix_suffix_length];\n\
    \        }\n        else if(prefix_suffix_length > 0 && pattern[pattern_pos] ==\
    \ string[prefix_suffix_length])\n        {\n            pattern_pos += 1;\n",
  "{\n    auto _string = string;\n    size_t l = _string.length;\n    size_t lp =\
    \ 1;\n    size_t i;\n    while (lp <= l) \n    {\n        // Skip characters which\
    \ have already been checked.\n        if (lp > 1) \n        {\n            _string\
    \ = _string[$-l + lp - 1 .. $];\n        }\n        if (isPalindrome(_string))\
    \ \n        {\n            break;\n        }\n        ++lp;\n    }\n    string\
    \ prefix = string[0 .. $ - lp];\n    return string ~ reverse(prefix);\n}", "{\n\
    \    auto copy = string;\n    reverse(copy);\n    for (; !string.startsWith(copy);\
    \ copy = copy[1 .. $])\n    {\n    }\n    return string ~ copy[0 .. $ - copy.lengthOf(string)];\n\
    }\n/*\n    A type that wraps a sequence and provides a move-only access to the\
    \ elements of a sequence.\n    The sequence can't be accessed directly through\
    \ a proxy object.\n    >>> auto m = Proxy!(int[])([1, 2, 3]);\n    >>> foreach\
    \ (i; m) writeln(i);\n    1\n    2\n    3\n    >>> auto p = Proxy!(int[])([1,\
    \ 2, 3]);\n    >>> foreach (i; p) writeln(i);\n    1\n    2\n    3\n    >>> auto\
    \ n = m.take(2);\n    >>> writeln(n);\n    [1, 2]\n    >>> writeln(m);\n    [3]\n\
    \    >>> writeln(n + m);\n    [1, 2, 3]\n    >>> auto k = p.take(2);\n    >>>\
    \ writeln(k);\n    [1, 2]\n    >>> writeln(p);\n    [1, 2, 3]\n*/\nalias MutableProxy(T)\
    \ = Proxy!(T, true);\ntemplate MutableProxy(T) Proxy(T, bool mutable = false)\n\
    {\n    @property auto take(size_t n)\n    {\n        auto result = array(n);\n\
    \        if (n > 0)\n        {\n            foreach (i; 0 .. n)\n            {\n\
    \                auto elem = popFront();\n                if (elem.empty)\n  \
    \              {\n                    break;\n                }\n            \
    \    result[i] = elem.front;\n            }\n        }\n        return result;\n\
    \    }\n    \n    @property auto front()\n    {\n        return popFront().front;\n\
    \    }\n    \n    struct Entry(E)\n    {\n        this(E el, bool first)\n   \
    \     {\n            this.front = el;\n            this.empty = !first;\n    \
    \    }\n        E front;\n        bool empty;\n   ", "{ \n    \n    string rev_string\
    \ = (string.reversed).idup;\n    string longest_prefix = common_prefix!string(string,\
    \ rev_string).idup;\n    return (string ~ (string[longest_prefix.length..$].reversed)).idup;\n\
    }", "{\n    string rev_string = string.dup.reverse;\n    string postfix = rev_string[$-string.length\
    \ .. $];\n    string prefix = string[0 .. $-postfix.length];\n    return string\
    \ ~ postfix.reverse;\n}\n \n/*\n    Manacher's algorithm to find the longest palindrome\
    \ within a string\n    https://en.wikipedia.org/wiki/Longest_palindromic_substring\n\
    \    The idea is to preprocess the string by adding sentinel symbols around each\
    \ character of the string.\n    This way we guarantee that all palindromes are\
    \ of odd lengths (all centers of palindromes will be sentinel symbols).\n    Then\
    \ we can construct palindromes around each symbol in linear time.\n    >>> find_longest_palindrome(\"\
    \")\n    \"\"\n    >>> find_longest_palindrome(\"cat\")\n    \"c\"\n    >>> find_longest_palindrome(\"\
    abba\")\n    \"abba\"\n*/\nstring find_longest_palindrome(string string)\n{\n\
    \    // add sentinel symbols\n    int sentinel = '*';\n    string processed =\
    \ map!(ch => sentinel ~ ch ~ sentinel)(string);\n    // array for storing the\
    \ radius of palindrome around each center\n    int[] radius;\n    radius.length\
    \ = processed.length;\n    // bounds of the longest palindrome found so far\n\
    \    int lower_bound;\n    int upper_bound;\n    // center of the longest palindrome\
    \ found so far\n    int center;\n    // right boundary of the longest palindrome\
    \ found so far\n    int right;\n    // index of the first character of the currently\
    \ processed palindrome\n    int index;\n    // center of the currently processed\
    \ palindrome\n    int i;\n    for (i = 0; i < processed.length; i++)\n    {\n\
    \        // first character of the currently processed palindrome\n        if\
    \ (i < right)\n        {\n            // check what is the index of reflection\
    \ of current position in the previously\n            // calculated palindrome\n\
    \            index = center * 2 - i;\n            // check what is the radius\
    \ of the palindrome around the reflected index\n            int reflected_radius\
    \ = radius", "{\n    auto ps = longest_prefix_suffix(string);\n    auto prefix\
    \ = string[0..($ - ps.length)];\n    return string ~ prefix.reverse;\n}\n \n//\
    \ Find longest prefix of s that is also a suffix of s.\nauto longest_prefix_suffix(string\
    \ s) \n{\n    enum n = s.length;\n    auto z = z_values(s);\n    auto z1 = z[1..$\
    \ - 1];\n    //auto z1 = z[1..$ - 1].map!(a => a.to!int);\n    auto max = z1.maximum;\n\
    \    //auto max = maxElement(z1);\n    if (max == 0)\n        return null;\n \
    \   int index = distance(z1.begin, find(z1.begin, z1.end, max));\n    auto lps\
    \ = s[0..max];\n    return lps;\n}\n \n// Calculate Z-values for supplied string.\n\
    // Z-values describe how much prefix matches with postfix of a string.\n// http://en.wikipedia.org/wiki/Z-algorithm\n\
    auto z_values(string s) \n{\n    enum n = s.length;\n    auto z = new ubyte[n]();\n\
    \    auto zl = 0;\n    auto zr = 0;\n    for (auto i = 1; i < n; i++) \n    {\n\
    \        auto zi = 0;\n        if (i <= zr) \n        {\n            zi = min(zr\
    \ - i + 1, z[i - zl]);\n        }\n        while (i + zi < n && s[zi] == s[i +\
    \ zi]) \n        {\n            zi++;\n        }\n        if (i + zi - 1 > zr)\
    \ \n        {\n            zl = i;\n            zr = i + zi - 1;\n        }\n\
    \        z[i] = zi;\n    }\n    return z;\n}\n \n//std::string make_palindrome(std::string\
    \ string) \n//{\n//    std::string ps = longest_prefix_suffix(string);\n//   ",
  "{\n    // initialize\n    int n = string.length;\n    // make string of concatenated\
    \ string and reverse of itself\n    string x = string ~ string[$ - 1 .. 0];\n\
    \    // take two prefix sums\n    int[] z = x.length.iota.map!(i => ((i > 0) ?\
    \ z[i - 1] : 0) + (x[i] == x[0])).array;\n    // the longest postfix that is palindrome\n\
    \    int[] y = x.length.iota.map!(i => z[i] - (i + 1)).array;\n    // find the\
    \ maximum\n    int max_index = 0;\n    foreach (i; 0 .. n) {\n        max_index\
    \ = (y[i] > y[max_index]) ? i : max_index;\n    }\n    // and return\n    return\
    \ string ~ string[$ - 1 .. max_index];\n}", "{\n    if (string.empty) \n    {\n\
    \        return string;\n    }\n    int index_of_last_char_in_palindrome_postfix\
    \ = 0;\n    size_t i = 0;\n    while (i != string.length) \n    {\n        if\
    \ (string[i] == string[string.length - 1 - i]) \n        {\n            ++index_of_last_char_in_palindrome_postfix;\n\
    \        }\n        else \n        {\n            index_of_last_char_in_palindrome_postfix\
    \ = 0;\n        }\n        ++i;\n    }\n    return string ~ string[0..string.length\
    \ - index_of_last_char_in_palindrome_postfix].dup.reverse;\n}", "{\n    auto len\
    \ = string.length;\n    auto longest_prefix_for_suffix = new int[len];\n    longest_prefix_for_suffix[0]\
    \ = 0;\n    for (int i = 1; i < len; i++) {\n        int current_index = longest_prefix_for_suffix[i\
    \ - 1];\n        while (current_index > 0 && string[i] != string[current_index])\
    \ {\n            current_index = longest_prefix_for_suffix[current_index - 1];\n\
    \        }\n        if (string[i] == string[current_index]) {\n            longest_prefix_for_suffix[i]\
    \ = current_index + 1;\n        } else {\n            longest_prefix_for_suffix[i]\
    \ = 0;\n        }\n    }\n    auto last_prefix_length = longest_prefix_for_suffix[len\
    \ - 1];\n    auto result = string ~ string[0 .. longest_prefix_for_suffix[len\
    \ - 1]];\n    return result;\n}", "{\n    // auto [t, beg, end] = std.algorithm.manacher(string);\n\
    \    auto [t, beg, end] = Manacher.manacher(string);\n    // debug std.conv.to!string(t);\n\
    \    // debug std.conv.to!string(beg);\n    // debug std.conv.to!string(end);\n\
    \    auto S = string[0 .. end].dup;\n    // debug S;\n    return S ~ string[0\
    \ .. end].reverse;\n}\nunittest\n{\n    assert(make_palindrome(\"\") == \"\");\n\
    \    assert(make_palindrome(\"cat\") == \"catac\");\n    assert(make_palindrome(\"\
    cata\") == \"catac\");\n}\n// https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/\n\
    // https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/\n\
    // https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-2/\n\
    // https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-3-2/\n\
    /*\n The idea is to generate all even length and odd length palindromes and keep\
    \ track of the longest palindrome seen so far. \n    - Step to generate odd length\
    \ palindrome:\n        Fix a centre and expand in both directions for longer palindromes.\n\
    \    - Step to generate even length palindrome\n        Fix two centre ( low and\
    \ high ) and expand in both directions for longer palindromes.\n */\nstring longestPalindrome(string\
    \ S)\n{\n    // auto [t, beg, end] = std.algorithm.manacher(S);\n    auto [t,\
    \ beg, end] = Manacher.manacher(S);\n    // debug std.conv.to!string(t);\n   \
    \ // debug std.conv.to!string(beg);\n    // debug std.conv.to!string(end", "{\n\
    \    /*\n    string.take(1) returns the first character of string\n    */\n  \
    \  string prefix = string.take(iMax(1, size_t(ceil(string.length/2))));\n    string\
    \ palindrome = prefix;\n    if (string.length & 1) \n    {\n        palindrome\
    \ = prefix[0..$-1];\n    }\n    return prefix ~ reverse(palindrome);\n}", "{\n\
    \tif (string.empty) \n\t{\n\t\treturn string;\n\t}\n\tsize_t suffix_pos = string.length;\n\
    \tforeach (suffix_len; 1 .. string.length + 1) \n\t{\n\t\tsuffix_pos = string.length\
    \ - suffix_len;\n\t\tif (is_palindrome(string[suffix_pos .. $])) \n\t\t{\n\t\t\
    \tbreak;\n\t\t}\n\t}\n\treturn string ~ string[0 .. suffix_pos].dup.reverse;\n\
    }\n/*\n Find the longest palindrome that begins with a supplied string.\n    Algorithm\
    \ idea is the same as in `make_palindrome`.\n    However, we only need to append\
    \ the reversed prefix if it is longer than the supplied string.\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"cat\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n    \n*/\nstring make_longest_palindrome(string string)\
    \ \n{\n\tif (string.empty) \n\t{\n\t\treturn string;\n\t}\n\tsize_t suffix_pos\
    \ = string.length;\n\tforeach (suffix_len; 1 .. string.length + 1) \n\t{\n\t\t\
    suffix_pos = string.length - suffix_len;\n\t\tif (is_palindrome(string[suffix_pos\
    \ .. $])) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn string ~ (suffix_pos !=\
    \ 0 ? string[0 .. suffix_pos].dup.reverse : \"\");\n}\n// ============================================================================\n\
    /*\n Find the shortest palindrome using KMP string search algorithm.\n    >>>\
    \ make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\
    \n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \n*/\nstring make_palindrome(string\
    \ string) \n{\n\tif (string.empty) \n\t{\n\t\treturn string;\n\t}\n\tauto prefix_pos\
    \ = longest", "{\n    int len = string.length;\n    int i = 0;\n    int j = len\
    \ - 1;\n    string suffix = \"\";\n    string prefix = \"\";\n    for (i = 0;\
    \ i < len; i++, j--) {\n        int k = 0;\n        for (k = 0; k <= i; k++) {\n\
    \            if (string[k] != string[len - k - 1]) break;\n        }\n       \
    \ if (k > i) {\n            break;\n        }\n    }\n    if (i >= len) return\
    \ string;\n    int k = 0;\n    while (i < len) {\n        suffix ~= string[i];\n\
    \        i++;\n    }\n    while (j >= 0) {\n        prefix ~= string[j];\n   \
    \     j--;\n    }\n    return string ~ prefix;\n}\n/*\nFind the longest palindrome\
    \ substring within a string.\nAlgorithm idea is simple:\n- Find the longest prefix\
    \ of a supplied string that is a palindrome.\n- Find the longest postfix of a\
    \ supplied string that is a palindrome.\n- If both prefix and postfix are present,\
    \ append the postfix to the prefix.\n- If only prefix is present, return it.\n\
    - If only postfix is present, return it.\n*/\nstring max_palindrome(string string)\n\
    {\n    int len = string.length;\n    int i = 0;\n    int j = len - 1;\n    string\
    \ suffix = \"\";\n    string prefix = \"\";\n    for (i = 0; i < len; i++, j--)\
    \ {\n        int k = 0;\n        for (k = 0; k <= i; k++) {\n            if (string[k]\
    \ != string[len - k - 1]) break;\n        }\n        if (k > i) {\n          \
    \  break;\n        }\n    }\n    if (i >= len) return string;\n    int k = 0;\n\
    \    while (i < len) {\n        suffix ~= string[i];\n        i++;\n    }\n  \
    \  while (j >= 0) {\n        prefix ~= string[j];\n        j--;\n    }\n    return\
    \ prefix ~ suffix;", "{\n    // Find the index of longest palindromic substring\
    \ in string.\n    int max_len = -1;\n    int max_i = -1;\n    string_ref tmp_ref;\n\
    \    foreach (size_t i; 0 ..= string.length) \n    {\n        int len = 1;\n \
    \       tmp_ref = string[i .. $];\n        while (len <= min(i, string.length\
    \ - i)) \n        {\n            auto ref = tmp_ref[0 .. len];\n            if\
    \ (ref.length == 0) \n            {\n                break;\n            }\n \
    \           if (ref != ref.reversed) \n            {\n                break;\n\
    \            }\n            len += 1;\n        }\n        len -= 1;\n        if\
    \ (len > max_len) \n        {\n            max_len = len;\n            max_i =\
    \ i;\n        }\n    }\n    // Append the reverse of the prefix to the end of\
    \ string.\n    string result = string;\n    result ~= string[0 .. max_i - max_len].reversed;\n\
    \    return result;\n}", "{\n    auto is_palindrome = [&](size_t begin, size_t\
    \ end) {\n        assert(begin <= end);\n        while (begin < end) {\n     \
    \       if (string[begin] != string[end]) {\n                return false;\n \
    \           }\n            begin++;\n            end--;\n        }\n        return\
    \ true;\n    };\n    size_t ssize = string.size();\n    size_t j = 0;\n    for\
    \ (size_t i = ssize; i > 0; --i) {\n        if (is_palindrome(0, i - 1)) {\n \
    \           j = i;\n            break;\n        }\n    }\n    return string +\
    \ std.algorithm.copy(string[j..ssize].rev);\n}", "{\n    if (string.empty)\n \
    \   {\n        return string;\n    }\n    string reversed;\n    if (string.length\
    \ <= 1)\n    {\n        reversed = string;\n    }\n    else\n    {\n        reversed\
    \ = make_palindrome(string[1..$-1]);\n    }\n    return string ~ string[0] ~ reversed;\n\
    }", "{\n    // Find the longest palindromic suffix.\n    auto suffix = string.suffixArray.filter!(a\
    \ => \n    {\n        int length = a.length;\n        return a[0 .. length / 2]\
    \ == a[length / 2 .. $].retro;\n    });\n    // Append reverse of the prefix that\
    \ comes before the suffix.\n    return string ~ string[0 .. string.length - suffix[0].length].retro;\n\
    }", "{\n    string rev_string = reverse(string);\n    string result = string ~\
    \ rev_string;\n    int string_len = string.length;\n    int suffix_len = 0;\n\
    \    foreach(i; 0 .. string_len)\n    {\n        if(string[0 .. i] == rev_string[string_len\
    \ - i .. $])\n        {\n            suffix_len = i;\n        }\n    }\n    result\
    \ = string ~ rev_string[0 .. string_len - suffix_len];\n    return result;\n}",
  "    if (string.empty)\n        return string;\n    \n    auto longest_palindrome_indices\
    \ = longest_palindrome_indices(string);\n    auto append_prefix = string[0..$\
    \ - longest_palindrome_indices.y];\n    return string ~ append_prefix.dup.reverse;",
  "{\n    auto len = string.length;\n    if (len == 0) \n    {\n        return \"\"\
    ;\n    }\n    auto suffix_len = len;\n    auto prefix_len = 0;\n    while (suffix_len\
    \ > 0) \n    {\n        auto prefix = string[0 .. $ - suffix_len];\n        auto\
    \ suffix = string[$ - suffix_len .. $];\n        if (suffix == suffix.idup) \n\
    \        {\n            prefix_len = prefix.length;\n            break;\n    \
    \    }\n        suffix_len--;\n    }\n    return string ~ string[0 .. prefix_len].idup;\n\
    }", "{\n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    size_t longest_postfix_palindrome_length = 0;\n    for (size_t i = 0; i <\
    \ string.length; ++i) \n    {\n        // Look for a postfix of supplied string\
    \ that is a palindrome.\n        bool is_palindrome = true;\n        for (size_t\
    \ first = 0, last = string.length - i - 1; first < last; ++first, --last) \n \
    \       {\n            if (string[first] != string[last]) \n            {\n  \
    \              is_palindrome = false;\n                break;\n            }\n\
    \        }\n        if (is_palindrome) \n        {\n            longest_postfix_palindrome_length\
    \ = string.length - i;\n            break;\n        }\n    }\n    // Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    return string ~ string[string.length - longest_postfix_palindrome_length\
    \ ..$];\n}", "{\n    return string.array();\n}\n/*\n    >>> parse_pgn_date(\"\
    2012.12.03\")\n    (2012, 12, 3)\n*/\nTuple!(int, int, int) parse_pgn_date(string\
    \ date) \n{\n    return tuple(0, 0, 0);\n}\n/*\n    >>> assert(quadratic_roots(1,\
    \ -3, 2) == (2, 1));\n    >>> assert(quadratic_roots(1, 0, -4) == (2, -2));\n\
    \    >>> assert(quadratic_roots(1, 0, 0) == (0, 0));\n    >>> assert(quadratic_roots(1,\
    \ 0, 4) == (-0.0, -4.0));\n    >>> assert(quadratic_roots(0, 0, 4) == (0, 0));\n\
    \    >>> assert(quadratic_roots(0, 0, 0) == (0, 0));\n    >>> assert(quadratic_roots(1,\
    \ 1, 0) == (-0.0, -0.0));\n    >>> assert(quadratic_roots(0, 1, 0) == (0, 0));\n\
    \    >>> assert(quadratic_roots(0, 1, 1) == (-1.0, -1.0));\n*/\nTuple!(double,\
    \ double) quadratic_roots(double a, double b, double c) \n{\n    return tuple(0.0,\
    \ 0.0);\n}\n/*\n    >>> assert(nand(true, true) == false);\n    >>> assert(nand(true,\
    \ false) == true);\n    >>> assert(nand(false, true) == true);\n    >>> assert(nand(false,\
    \ false) == true);\n*/", "{\n    auto is_palindrome = (string s) \n    {\n   \
    \     return s == s.idup.reverse;\n    };\n    auto longest_palindrome_suffix\
    \ = (string s) \n    {\n        for (auto i = s.length; i > 0; i--) \n       \
    \ {\n            auto suffix = s[$-i..$];\n            if (is_palindrome(suffix))\
    \ \n            {\n                return suffix;\n            }\n        }\n\
    \        return \"\";\n    };\n    auto palindrome_prefix = longest_palindrome_suffix(string.idup.reverse);\n\
    \    return string ~ palindrome_prefix.reverse;\n}\n/*\n    ------------------------------\n\
    \    ------------------------------\n    ------------------------------\n    ------------------------------\n\
    \    ------------------------------\n    Find the shortest palindrome that ends\
    \ with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest\
    \ prefix of supplied string that is a palindrome.\n    - Append to the beginning\
    \ of the string reverse of a string suffix that comes after the palindromic prefix.\n\
    \    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n \
    \   \"taccat\"\n    >>> make_palindrome(\"tac\")\n    \"taccat\"\n*/\nstring make_palindrome(string\
    \ string)\n{\n    auto is_palindrome = (string s) \n    {\n        return s ==\
    \ s.idup.reverse;\n    };\n    auto longest_palindrome_prefix = (string s) \n\
    \    {\n        for (auto i = s.length; i > 0; i--) \n        {\n            auto\
    \ prefix = s[0..i];\n            if (is_palindrome(prefix)) \n            {\n\
    \                return prefix;\n            }\n        }\n        return \"\"\
    ;\n    };\n    auto palindrome_suffix = longest_palindrome_prefix(string.idup.reverse);\n\
    \    return palindrome_suffix.reverse ~ string;\n}\n/*\n    ------------------------------\n\
    \    ------------------------------\n    ------------------------------\n    ------------------------------\n\
    \    ------------------------------\n    Use two pointers, one at the beginning\
    \ of the", "{ \n    /*\n    // This function is used only once,\n    // but it's\
    \ better to generalize it into make_palindrome_of_any_kind().\n    alias Range=Unqual!(Range);\n\
    \    template make_palindrome_of_any_kind(Range)(Range string) if(isInputRange!Range)\n\
    \    {\n        auto length = string.length;\n        if(length == 0) return string;\n\
    \        size_t shift;\n        auto result = string.idup;\n        // Find the\
    \ longest palindromic suffix of the string.\n        // This is equivalent to\
    \ finding the shortest prefix of the string that is a palindrome.\n        //\
    \ By the way, this is a standard approach to solve the problem of finding longest\
    \ common substrings of two strings.\n        // It's called the Suffix Tree.\n\
    \        shift = result.find_longest_palindromic_suffix();\n        if(shift ==\
    \ length) return result;\n        // The string doesn't end with a palindrome.\n\
    \        // So, let's append to the end of it a reverse of a string prefix that\
    \ comes before the palindromic suffix.\n        result.append(result[0 .. shift].reverse.idup);\n\
    \        return result;\n    }\n    */\n    import std.stdio : writeln;\n    writeln(string.find_longest_palindromic_suffix());\n\
    \    import std.algorithm : find;\n    size_t max_index = 0;\n    size_t length\
    \ = string.length;\n    if(length > 1)\n    {\n        size_t [string.length]\
    \ prefix_lengths;\n        /*\n        The idea is simple:\n        - Find the\
    \ suffix of a string that is a palindrome and store the length of its prefix.\n\
    \        - The lengths of string prefixes are stored in array prefix_lengths[]\n\
    \        - Recursive formula:\n            prefix_lengths[i] = max(prefix_lengths[i-1]\
    \ + 1, 1)\n        - Base case: prefix_lengths[0] = 1\n        - The longest palindromic\
    \ suffix of a string ends at the index max_index = prefix_lengths.maxIndex;\n\
    \       ", "{\n    // Find palindromic suffix.\n    auto is_palindrome = (string\
    \ s)\n    {\n        auto n = s.length;\n        for (int i = 0; i < n / 2; i++)\n\
    \        {\n            if (s[i] != s[n - i - 1])\n            {\n           \
    \     return false;\n            }\n        }\n        return true;\n    };\n\
    \    int n = string.length;\n    for (int i = n; i >= 0; i--)\n    {\n       \
    \ auto suffix = string[i .. n];\n        if (is_palindrome(suffix))\n        {\n\
    \            auto prefix = string[0 .. i];\n            return string ~ prefix.dup.reverse;\n\
    \        }\n    }\n    assert(false);\n}", "{\n    enum start_suffix = find_longest_palindrome_postfix(string);\n\
    \    return string ~ to!string(string[0 .. start_suffix].reverse);\n}\n/*\n Find\
    \ the longest palindromic postfix of a string\n    >>> find_longest_palindrome_postfix(\"\
    \")\n    0\n    >>> find_longest_palindrome_postfix(\"aa\")\n    2\n    >>> find_longest_palindrome_postfix(\"\
    abc\")\n    0\n    >>> find_longest_palindrome_postfix(\"aba\")\n    3\n    >>>\
    \ find_longest_palindrome_postfix(\"tattarrattat\")\n    12\n    >>> find_longest_palindrome_postfix(\"\
    tattarrattatt\")\n    12\n    >>> find_longest_palindrome_postfix(\"tattarrattatto\"\
    )\n    12\n    >>> find_longest_palindrome_postfix(\"tattarrattattoo\")\n    12\n\
    */\nsize_t find_longest_palindrome_postfix(string string) \n{\n    if (string.length\
    \ < 2)\n        return 0;\n    // Take a shortcut if the whole string is a palindrome,\
    \ in order to\n    // avoid an extra reverse and step though each char in a loop.\n\
    \    if (is_palindrome(string))\n        return string.length;\n    // Start from\
    \ the end of the string and build palindromes.\n    // The longest palindrome\
    \ index is recorded and returned.\n    size_t longest_palindrome_end_pos = 0;\n\
    \    size_t start_pos = string.length - 1;\n    foreach (size_t end_pos; start_pos.retro;\
    \ --start_pos)\n    {\n        // There is a chance that a substring from start_pos\
    \ to end_pos\n        // is a palindrome. Let's check if it is.\n        end_pos\
    \ = min(start_pos + longest_palindrome_end_pos, string.length - 1);\n        if\
    \ (is_palindrome(string[start_pos .. end_pos + 1]))\n            longest_palind",
  "{\n    assert(string.isMutable);\n    auto len = string.length;\n    for (size_t\
    \ i = 0; i < len; i++) {\n        if (string[i .. len] == string[i .. len].dup.chunks.reverse.join)\
    \ {\n            return string ~ string[0 .. i].dup.chunks.reverse.join;\n   \
    \     }\n    }\n    return string;\n}", "{\n    auto len = string.length;\n  \
    \  if(len == 0)\n        return \"\";\n    // if (IsPalindrome(string)) \n   \
    \ // {\n    //     return string;\n    // }\n    auto s = string.length;\n   \
    \ auto p = string.dup;\n    auto revp = p.dup;\n    auto p_len = p.length;\n \
    \   auto revp_len = revp.length;\n    auto p_offset = 0;\n    auto revp_offset\
    \ = 0;\n    for(int i = 0; i < p_len; i++)\n    {\n        if(!isPalindrome(string[0..s-i]))\n\
    \        {\n            p_offset = i;\n            revp_offset = p_len - p_offset;\n\
    \            break;\n        }\n    }\n    if(p_offset == 0)\n        return string;\n\
    \    auto revp_tail = revp[revp_offset..revp_len];\n    return string ~ revp_tail.reverse;\n\
    }", "{\n    ulong length = string.length;\n    auto palindrome_length = length;\n\
    \    if (length == 0)\n        return string;\n    ulong suffix_length = 0;\n\
    \    while (true) \n    {\n        if (is_palindrome(string[$-suffix_length..$]))\
    \ \n        {\n            palindrome_length = length - suffix_length;\n     \
    \       break;\n        }\n        suffix_length += 1;\n    }\n    return make_palindrome_fast(string,\
    \ palindrome_length);\n}", "{\n    /* Finds longest postfix that is a palindrome.\
    \ */\n    string longest_postfix_palindrome(string string) \n    {\n        auto\
    \ it = string.begin();\n        for (; it != string.end(); it++) \n        {\n\
    \            string postfix = string(it, string.end);\n            string reversed_postfix\
    \ = reverse(postfix);\n            if (postfix == reversed_postfix) \n       \
    \     {\n                return postfix;\n            }\n        }\n        return\
    \ \"\";\n    }\n    string postfix = longest_postfix_palindrome(string);\n   \
    \ if (postfix.length == string.length) \n    {\n        return string;\n    }\n\
    \    string prefix = string(string.begin, string.end - postfix.length);\n    return\
    \ prefix ~ reverse(prefix) ~ postfix;\n}", "{\n    return string.\n\t    dup.\n\
    \t    idup.\n\t    reverse.\n\t    idup.\n\t    idup.\n\t    idup.\n\t    longest_common_substring.\n\
    \t    length.\n\t    opCall(\n\t    S => \n\t\tstring.\n\t\t    dup.\n\t\t   \
    \ idup.\n\t\t    idup.\n\t\t    take(\n\t\t    string.\n\t\t\tdup.\n\t\t\tlength\
    \ - S.\n\t\t\tlength).\n\t\t    reverse).\n\t    opCall(string);\n}", "{\n   \
    \ auto l = string.length;\n    l = min(l, l/2);\n    foreach(i; 0 .. l)\n    {\n\
    \        if(string[0 .. l-i] == string[l .. $-i])\n        {\n            return\
    \ string ~ string[0 .. l-i].idup.reverse;\n        }\n    }\n    return string;\n\
    }\n/*\n  Find a longest palindromic substring that can be found in a supplied\
    \ string.\n    >>> longest_palindrome(\"\")\n    \"\"\n    >>> longest_palindrome(\"\
    cat\")\n    \"a\"\n    >>> longest_palindrome(\"cata\")\n    \"ata\"\n*/\nstring\
    \ longest_palindrome(string string) \n{\n    if(string.length < 2)\n    {\n  \
    \      return string;\n    }\n    auto l = string.length;\n    l = min(l, l/2);\n\
    \    foreach(i; 0 .. l)\n    {\n        if(string[0 .. l-i] == string[l .. $-i])\n\
    \        {\n            return string[0 .. l-i];\n        }\n    }\n    return\
    \ string[0 .. 1];\n}\n/*\n  Pack a string into a form where consecutive duplicate\
    \ characters are removed and replaced by a count.\n    >>> pack(\"a\")\n    \"\
    a\"\n    >>> pack(\"aaa\")\n    \"a3\"\n    >>> pack(\"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc",
  "{\n    string suffix;\n    int i;\n    int n = string.length;\n    static if(!is(typeof(string[0])\
    \ == char))\n    {\n        for(i = 0; i < n; i++) \n        {\n            if(string[i]\
    \ != string[n - i - 1]) \n            {\n                break;\n            }\n\
    \        }\n    }\n    else\n    {\n        for(i = 0; i < n; i++) \n        {\n\
    \            if(tolower(string[i]) != tolower(string[n - i - 1])) \n         \
    \   {\n                break;\n            }\n        }\n    }\n    return string\
    \ ~ string[0 .. i - 1].backwards;\n}", "{\n    auto check_palindrome = [&string](int\
    \ start, int end) \n    {\n        import std.array;\n        auto mid = (start\
    \ + end) / 2;\n        auto len = end - start;\n        auto is_odd = len % 2;\n\
    \        foreach (idx,ch; string[mid..$] )\n        {\n            auto reverse_idx\
    \ = len - idx - 1;\n            if (is_odd && idx == 0)\n                continue;\n\
    \            if (ch != string[reverse_idx])\n                return false;\n \
    \       }\n        return true;\n    };\n    import std.algorithm.iteration :\
    \ enumerate;\n    int longest_palindrome_length = -1;\n    foreach (idx,c; string.enumerate)\n\
    \    {\n        if (check_palindrome(idx,string.length))\n        {\n        \
    \    longest_palindrome_length = string.length - idx;\n            break;\n  \
    \      }\n    }\n    if (longest_palindrome_length == -1)\n        return string;\n\
    \    else\n        return string ~ string[0..longest_palindrome_length].idup.reverse;\n\
    }\n/*\n  Longest palindromic substring\n  Given a string s, find the longest palindromic\
    \ substring in s. \n  Algorithm:\n  - Given a string of length N, we can find\
    \ in O(N) all possible palindromes of length <= 2N\n  - It can be done by using\
    \ suffix tree in O(N)\n  - Then in O(N) we can build a suffix tree with all strings\
    \ of length <= 2N\n  - Then we can traverse the suffix tree in O(N) and find the\
    \ deepest leaf\n  - We need constant time lookup into the leaf node\n  >>> longest_palindrome(\"\
    aabac\")\n  \"aba\"\n  >>> longest_palindrome(\"aaba\")\n  \"aba\"\n  >>> longest_palindrome(\"\
    cbbd\")\n  \"bb\"\n*/\nstring longest_palindrome(string string) \n{\n    import\
    \ std.algorithm.iteration : filter;\n    import std.", "{\n    auto iter = findLast(string,\
    \ is_palindrome);\n    auto prefix = string[0..$-distance(string.begin, iter)];\n\
    \    return string ~ prefix.retro;\n}\n/*\n Find the shortest palindrome that\
    \ begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the\
    \ longest postfix of supplied string that is a palindrome.\n    - Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    >>>\
    \ make_palindrome(\"catastrophe\")\n    \"catastropheecaratsac\"\n    >>> make_palindrome(\"\
    a\")\n    \"a\"\n    >>> make_palindrome(\"ab\")\n    \"bab\"\n    >>> make_palindrome(\"\
    abc\")\n    \"cbac\"\n*/\nstring make_palindrome(string string) \n{\n    if (string.empty)\
    \ return string;\n    auto iter = findLast(string, is_palindrome);\n    auto prefix\
    \ = string[0..$-distance(string.begin, iter)];\n    return string ~ prefix.retro;\n\
    }\n/*\n Find the shortest palindrome that begins with a supplied string.\n   \
    \ Algorithm idea is simple:\n    - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n    >>> make_palindrome(\"catastrophe\")\n    \"catastropheecaratsac\"\
    \n    >>> make_palindrome(\"a\")\n    \"a\"\n    >>> make_palindrome(\"ab\")\n\
    \    \"bab\"\n    >>> make_palindrome(\"abc\")\n    \"cbac\"\n    >>> make_palind",
  "{\n    auto stringLength = string.length;\n    if (stringLength == 0)\n       \
    \ return \"\";\n    \n    auto suffix = string[stringLength - 1..$];\n    auto\
    \ suffixPalindrome = find_largest_palindrome(suffix);\n    auto prefix = string[0..$\
    \ - suffixPalindrome.length];\n    auto prefixReversed = prefix.dup.retro;\n \
    \   return string ~ prefixReversed;\n}\n/*\n    Find the largest palindrome among\
    \ the string postfixes.\n    Complexity: O(n^2)\n    >>> find_largest_palindrome(\"\
    \")\n    \"\"\n    >>> find_largest_palindrome(\"cat\")\n    \"t\"\n    >>> find_largest_palindrome(\"\
    cata\")\n    \"ata\"\n    >>> find_largest_palindrome(\"abracadabra\")\n    \"\
    ababa\"\n*/\nstring find_largest_palindrome(string string) \n{\n    auto stringLength\
    \ = string.length;\n    if (stringLength <= 1)\n        return string;\n    \n\
    \    auto longestPalindrome = string[0..1];\n    for (size_t i = 1; i < stringLength;\
    \ i++) \n    {\n        for (size_t j = i; j < stringLength; j++) \n        {\n\
    \            auto candidate = string[i..j + 1];\n            if (candidate.isPalindrome\
    \ && candidate.length > longestPalindrome.length)\n                longestPalindrome\
    \ = candidate;\n        }\n    }\n    return longestPalindrome;\n}", "{\n    if\
    \ (string.empty)\n    {\n        return string;\n    }\n    auto it = string.end;\n\
    \    do\n    {\n        if (it.compare(string.begin) <= 0)\n        {\n      \
    \      return string + string.head(string.length - (it - string.begin));\n   \
    \     }\n        if (it.compare(string.begin) == 0)\n        {\n            break;\n\
    \        }\n        --it;\n    }\n    while (!is_palindrome(string.head(it - string.begin)));\n\
    \    return string + string.head(string.length - (it - string.begin));\n}", "{\n\
    \    alias string_tuple = Tuple!(string);\n    // Is it an empty string?\n   \
    \ if (string.empty) return string;\n    import std.algorithm.comparison : equal;\n\
    \    auto count = string.length;\n    int i = 0;\n    int j = count - 1;\n   \
    \ bool changed = false;\n    while(i < j) \n    {\n        if (string[i] != string[j])\
    \ \n        {\n            // Is the prefix that comes before the non-equal characters\
    \ a palindrome?\n            if (equal(string[0..i].reverse, string[j..count]))\n\
    \            {\n                changed = true;\n                break;\n    \
    \        }\n            else\n            {\n                // Is the suffix\
    \ that comes after the non-equal characters a palindrome?\n                if\
    \ (equal(string[i..count].reverse, string[0..j]))\n                {\n       \
    \             changed = true;\n                    break;\n                }\n\
    \            }\n        }\n        i++;\n        j--;\n    }\n    if (changed)\
    \ \n    {\n        // What part of the string (prefix or suffix) is a palindrome?\n\
    \        return string ~ ((string[i..count].reverse)[]).idup;\n    }\n    return\
    \ string;\n}\n \n/*\n    Find the longest common substring in two strings.\n \
    \   >>> longest_common_substring(\"\", \"\")\n    \"\"\n    >>> longest_common_substring(\"\
    cat\", \"cat\")\n    \"cat\"\n    >>> longest_common_substring(\"cat\", \"hat\"\
    )\n    \"at\"\n    >>> longest_common_substring(\"CAT\", \"HAT\")\n    \"AT\"\n\
    \    >>> longest_common_substring(\"abcd\", \"abcd\")\n    \"abcd\"\n    >>> longest_common_substring(\"\
    abcd\", \"abce\")\n    \"abc\"\n    >>> longest_common_substring(\"helo\", \"\
    hello\")\n    \"hello\"\n    >>> longest_common_substring(\"hello\", \"helo\"\
    )\n    \"helo\"\n    >>> longest_common_substring(\"david\", \"eddie\")\n    \"\
    die\"\n*/\n", "{\n    debug static assert(is(typeof(equal(string.front, string.back))));\n\
    \    size_t i = string.length();\n    for (; i > 0; --i) \n    {\n        if (equal(string[0\
    \ .. i].front, string[i - 1 .. $].back))\n            break;\n    }\n    return\
    \ string ~ string[i .. $].reverse;\n}\n/*\n Check whether a string is a palindrome.\n\
    \    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"a\")\n    true\n\
    \    >>> is_palindrome(\"ab\")\n    false\n    >>> is_palindrome(\"aba\")\n  \
    \  true\n    >>> is_palindrome(\"abba\")\n    true\n    >>> is_palindrome(\"abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba\"\
    )\n    true\n*/", "{\n    auto suffix_length = size_t.init;\n    if (string.empty)\
    \ {\n        return string;\n    }\n    while (true) {\n        if (is_palindrome(string[$-suffix_length..$]))\
    \ {\n            break;\n        }\n        suffix_length++;\n    }\n    return\
    \ string~string[$-suffix_length..$].reversed;\n}", "{\n  int start_index;\n  int\
    \ end_index;\n  int string_length;\n  string_length = string.length;\n  end_index\
    \ = string_length - 1;\n  for (start_index = 0; start_index < string_length; ++start_index)\
    \ \n  {\n    if (string[start_index] == string[end_index]) \n    {\n      end_index\
    \ -= 1;\n    }\n    else \n    {\n      end_index = string_length - 1;\n    }\n\
    \  }\n  return string ~ string[string[$-1 .. end_index].retro];\n}\nsize_t find_min_palindrome_len(ref\
    \ string string) \n{\n  int palindrome_length;\n  size_t string_length;\n  size_t\
    \ half_length;\n  int left_index;\n  int right_index;\n  size_t i;\n  string_length\
    \ = string.length;\n  palindrome_length = 0;\n  half_length = cast(size_t)(string_length\
    \ / 2);\n  for (i = 0; i < half_length; ++i) \n  {\n    left_index = i;\n    right_index\
    \ = string_length - i - 1;\n    if (string[left_index] == string[right_index])\
    \ \n    {\n      palindrome_length += 2;\n    }\n    else \n    {\n      break;\n\
    \    }\n  }\n  return palindrome_length;\n}\nstring make_palindrome_string(ref\
    \ string string) \n{\n  size_t min_palindrome_len;\n  size_t string_length;\n\
    \  size_t palindrome_start_index;\n  string_length = string.length;\n  min_palindrome_len\
    \ = find_min_palindrome_len(string);\n  if (min_palindrome_len == string_length)\
    \ \n  {\n    return string;\n  }\n  palindrome_start_index = string_length - min_palindrome_len;\n\
    \  return string[palindrome_start_index .. string_", "{\n    // Wri", "{\n   \
    \ \n    int begin = 0;\n    int end = string.length;\n    while(begin < end) \n\
    \    {\n        if(string[begin] == string[end - 1]) \n        {\n           \
    \ begin++;\n            end--;\n        }\n        else \n        {\n        \
    \    break;\n        }\n    }\n    return string[0..begin] + string[0..begin].reverse.idup\
    \ ~ string[begin..$];\n}", "{\n    if (string.empty) \n    {\n        return string;\n\
    \    }\n    auto palindrome = string;\n    auto to_reverse = slice(string, 0,\
    \ palindrome.length.half);\n    palindrome ~= reverse(to_reverse);\n    return\
    \ palindrome;\n}", "in\n{\n    enforce(isValidRange!(string), \"Input string is\
    \ null.\");\n    return string ~ string[0 .. find_longest_palindrome_suffix(string)].idup.retro;\n\
    }", "{\n\t// Find the longest postfix of supplied string that is a palindrome.\n\
    \tauto reversed = string.retro; // Reverse the string\n\tauto palindrome_end =\
    \ isSuffixArray(string, reversed);\n\t// Get substring before the palindromic\
    \ suffix\n\tauto prefix = string[0..$-palindrome_end];\n\t// Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \treturn string ~ prefix.retro;\n}\n/*\n Compare two strings and returns a index\
    \ of a character where first string is a suffix of a second string.\n If a second\
    \ string is not a suffix of a first string it returns 0.\n*/\nsize_t isSuffixArray(string\
    \ a, string b)\n{\n\tsize_t i = 0;\n\tforeach(index, c; a)\n\t{\n\t\tif(b[index]\
    \ == c)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\
    \treturn i;\n}\n// Unit test", "{\n    string result = string;\n    //var i =\
    \ string.length - 1;\n    auto r = reverse(string);\n    //while (i >= 0 && !(string[0..i+1]\
    \ == r[0..i+1])) i--;\n    //i++;\n    //result ~= r[i..$];\n    //return result;\n\
    \    return result ~ r[0..$-1];\n}", "{\n    if (string.empty) return string;\n\
    \    auto palindrome_index = string.lowest_common_substring_right_to_left_index();\n\
    \    auto prefix = string[0..$-palindrome_index];\n    return string ~ prefix.front_extract.reverse;\n\
    }", "{\n    // Find longest postfix that is a palindrome\n    auto longest_postfix\
    \ = find_longest_postfix_palindrome(string);\n    // Take substring of string\
    \ before palindromic postfix\n    auto prefix = string[0..$-longest_postfix.length];\n\
    \    // Concatenate the prefix, reverse of prefix and the postfix\n    return\
    \ prefix ~ prefix.dup.reverse ~ longest_postfix;\n}\n// Simple function to calculate\
    \ the longest palindromic postfix of a string\nstring find_longest_postfix_palindrome(string\
    \ string) \n{\n    // Calculate a string reversed\n    auto string_reversed =\
    \ string.dup.reverse;\n    // Calculate the longest postfix that is a palindrome\n\
    \    return longest_substring(string, string_reversed);\n}\n// Find the longest\
    \ substring of two strings\nstring longest_substring(string string1, string string2)\
    \ \n{\n    // Convert strings to arrays\n    auto string1_array = string1.to!(dchar[]);\n\
    \    auto string2_array = string2.to!(dchar[]);\n    // Calculate the lengths\
    \ of strings\n    auto length1 = string1_array.length;\n    auto length2 = string2_array.length;\n\
    \    // Maximum length so far is 0\n    auto max_length = 0;\n    // Start index\
    \ of the longest substring\n    auto start_index = 0;\n    // Create 2D array\
    \ of lengths\n    auto len = new int[][](length1 + 1, length2 + 1);\n    // Loop\
    \ over 2D array of lengths\n    foreach (row; 0..=length1) \n    {\n        foreach\
    \ (column; 0..=length2) \n        {\n            // Check if one of the strings\
    \ is 0\n            if (row == 0 || column == 0) \n            {\n           \
    \     // Set 0 at that position\n                len[row][column] = 0;\n     \
    \       }\n            // Check if characters are the same\n            else if\
    \ (string1_array[row - 1] == string2_array[column - 1]) \n            {\n    \
    \            // Increase the length\n                len", "{\n    auto lps =\
    \ longest_palindromic_suffix(string);\n    return string ~ lps[0 .. $ - lps.length]\n\
    \        .retro;\n}", "{\n    if (string.empty)\n    {\n        return string;\n\
    \    }\n    auto N = string.length;\n    // try to find a suffix that is a palindrome\n\
    \    auto suffix = string.back;\n    while (suffix.length < N && !is_palindrome(suffix))\n\
    \    {\n        suffix ~= string[$ - suffix.length - 1];\n    }\n    // if it\
    \ is the whole string we already have a palindrome\n    if (suffix.length == N)\n\
    \    {\n        return string;\n    }\n    // otherwise add a reverse of prefix\
    \ that is not included in suffix\n    else\n    {\n        return string ~ reverse(string[0\
    \ .. $ - suffix.length]);\n    }\n}", "{\n\t\n\tuint l = string.length;\n\tint[]\
    \ z = z_function!(string)();\n\tint p = 0;\n\tint s = 0;\n\tint q = 0;\n\tfor\
    \ (int i = 1; i < l; i++)\n\t{\n\t\tif (i + z[i] == l)\n\t\t{\n\t\t\ts = i;\n\t\
    \t\tq = z[i];\n\t\t\tif (p < q)\n\t\t\t{\n\t\t\t\tp = q;\n\t\t\t}\n\t\t}\n\t}\n\
    \tif (p > 0)\n\t{\n\t\treturn string ~ string[$-p .. $].idup;\n\t}\n\treturn string\
    \ ~ string[$-1 .. $].idup;\n}\n/*\n Implement a simple DNS server.\n    \n   \
    \ The server should listen on loopback interface port 53 and respond to queries\
    \ for A and PTR records \n    with a supplied map of records. Records are supplied\
    \ as a map of record name to record data.\n    The server should answer with an\
    \ NXDOMAIN response to all other queries. \n    \n    The server should respond\
    \ to questions with a unicast answer and listen for queries on all interfaces,\n\
    \    regardless of what addresses are configured on them.\n    \n    >>>\n   \
    \ >>> DnsPacketData req = DnsPacketData([DnsQuestion(DnsQuestionType.A, \"www.example.com\"\
    )]);\n    >>> byte[] requestData = cast(byte[]) req;\n    >>> import std.socket:\
    \ Socket, SocketAddressFamily, SocketType, IPPROTO_UDP, INADDR_LOOPBACK, loopbackAddress,\
    \ htons, udpSend, udpRecv, socketBind;\n    >>> import std.net.curl: Curl;\n \
    \   >>> auto s = Socket(SocketAddressFamily.INET, SocketType.DGRAM, IPPROTO_UDP);\n\
    \    >>> s.socketBind(loopbackAddress(INADDR_LOOPBACK, htons(53)));\n    >>>\n\
    \    >>> s.udpSend(loopbackAddress(INADDR_LOOPBACK, htons(53)), requestData);\n\
    \    >>>\n    >>> auto responseData =", "{\n    // Find the longest postfix that\
    \ is a palindrome.\n    string suffix = string;\n    while (suffix.length > 0\
    \ && !is_palindrome(suffix))\n    {\n        suffix = suffix[1..$];\n    }\n \
    \   // Build a prefix that is the reverse of the suffix.\n    string prefix =\
    \ reverse(suffix);\n    return prefix ~ string;\n}\n/*\n   Returns true if a string\
    \ is a palindrome.\n   >>> is_palindrome(\"\")\n   true\n   >>> is_palindrome(\"\
    a\")\n   true\n   >>> is_palindrome(\"cat\")\n   false\n   >>> is_palindrome(\"\
    cac\")\n   true\n*/", "{\n    auto reverse_string = string.dup.dup.reverse;\n\
    \    auto longe", "{\n\t// TODO: implement this function\n}", "{\n    auto length\
    \ = string.length;\n    auto is_palindrome = (int i, int j) { return string[i\
    \ .. j] == string[i .. j].reverse; };\n    foreach (i; 0 .. length) \n    {\n\
    \        if (is_palindrome(0, i)) \n        {\n            return string ~ string[i\
    \ .. $].reverse;\n        }\n    }\n    return string;\n}\n/*\n Initialize a 2D\
    \ matrix with a default value.\n    >>> square_matrix!int(3, 4, -1)\n    [[-1,\
    \ -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]\n    >>> square_matrix!int(3,\
    \ 3, 1)\n    [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n*/\nT[][] square_matrix(T)(in\
    \ size_t rows, in size_t columns, T default_value) \n{\n    auto result = new\
    \ T[][](rows, columns);\n    foreach (row; 0 .. rows) \n    {\n        foreach\
    \ (column; 0 .. columns) \n        {\n            result[row][column] = default_value;\n\
    \        }\n    }\n    return result;\n}\n/*\n Transpose a 2D matrix.\n    >>>\
    \ matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    >>> transpose(matrix)\n    [[1,\
    \ 4, 7], [2, 5, 8], [3, 6, 9]]\n*/\nT[][] transpose(T)(T[][] matrix) \n{\n   \
    \ enum rows = matrix.length;\n    enum columns = matrix[0].length;\n    auto result\
    \ = new T[][](columns, rows);\n    foreach (row; 0 .. rows) \n    {\n        foreach\
    \ (column; 0 .. columns) \n        {\n            result[column][row] = matrix[row][column];\n\
    \        }\n    }\n    return result;\n}\n/*\n Converts supplied text to pig latin.\n",
  "    @safe pure nothrow\n{\n    // Find the longest suffix of the string that is\
    \ a palindrome\n    bool is_palindrome(string x)\n    {\n        return x.isempty\
    \ || x.front == x.back && is_palindrome(x[1 .. $ - 1]);\n    }\n    size_t suffix_size\
    \ = 0;\n    while (suffix_size < string.length && !is_palindrome(string[suffix_size\
    \ .. $]))\n    {\n        ++suffix_size;\n    }\n    // If the whole string is\
    \ a palindrome, then nothing needs to be done\n    if (suffix_size == string.length)\n\
    \    {\n        return string;\n    }\n    // Reverse the prefix of the string\
    \ and append it to the end\n    auto result = string ~ string[0 .. $ - suffix_size].reverse;\n\
    \    return result;\n}\n/*\n Find the longest common prefix of two strings.\n\
    \    >>> lcp(\"cat\", \"cata\")\n    \"cat\"\n    >>> lcp(\"cat\", \"cute\")\n\
    \    \"c\"\n    >>> lcp(\"cat\", \"dog\")\n    \"\"\n*/\nstring lcp(string a,\
    \ string b)\n    @safe pure nothrow\n{\n    size_t i = 0;\n    while (i < a.length\
    \ && i < b.length && a[i] == b[i])\n    {\n        ++i;\n    }\n    return a[0\
    \ .. i];\n}\n/*\n Find the longest common substring of two strings.\n    >>> lcs(\"\
    cat\", \"cata\")\n    \"cat\"\n    >>> lcs(\"cat\", \"cute\")\n    \"c\"\n   \
    \ >>> lcs(\"cat\", \"dog\")\n    \"\"\n*/\nstring lcs(string a, string b)\n  \
    \  @safe pure nothrow\n{\n    // If both strings are empty, the common substring\
    \ is the empty string\n    if (a.isempty && b.isempty)\n    {\n        return\
    \ \"\";\n    }\n    // If one of the strings is empty, then the longest common\
    \ substring of\n    // a and b is empty.\n    if (a.is", "{\n\tstring[int] mem;\n\
    \tbool[int] palindrome;\n\t// Initialization\n\tmem[0] = string[0..$/2];\n\tpalindrome[0]\
    \ = true;\n\t// Build table\n\tforeach (i; 1..string.length) \n\t{\n\t\tmem[i]\
    \ = mem[i-1] ~ string[i..$/2];\n\t\tpalindrome[i] = true;\n\t\tforeach (j; 0..mem[i].length-1)\
    \ \n\t\t{\n\t\t\tif (mem[i][j] != mem[i][$-j-1]) \n\t\t\t{\n\t\t\t\tpalindrome[i]\
    \ = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// Find the longest palindrome\
    \ in the table\n\tint longest = 0;\n\tforeach (i; 0..palindrome.length) \n\t{\n\
    \t\tif (palindrome[i]) \n\t\t{\n\t\t\tlongest = i;\n\t\t}\n\t}\n\t// Append to\
    \ the end of the string its reversed prefix\n\tstring result = string ~ reverse(string[0..longest]);\n\
    \treturn result;\n}\n/*\n Find the longest palindrome that begins with a supplied\
    \ string.\n    - Find the longest postfix of supplied string that is a palindrome.\n\
    \    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n \
    \   \"cat\"\n    >>> make_palindrome(\"cata\")\n    \"cata\"\n    \n*/\nstring\
    \ find_longest_palindrome(string string) \n{\n\tstring[int] mem;\n\tbool[int]\
    \ palindrome;\n\t// Initialization\n\tmem[0] = string[0..$/2];\n\tpalindrome[0]\
    \ = true;\n\t// Build table\n\tforeach (i; 1..string.length) \n\t{\n\t\tmem[i]\
    \ = mem[i-1] ~ string[i..$/2];\n\t\tpalindrome[i] = true;\n\t\tfore", "{\n   \
    \ string longest_palindrome = longest_palindrome_suffix(string);\n    return longest_palindrome\
    \ == \"\"\n        ? string.idup\n        : string.idup ~ string[0 .. $ - longest_palindrome.length].reverse;\n\
    }\n/*\n Compute the longest palindromic suffix of a string.\n    Algorithm idea\
    \ is simple:\n    - We go through all character indexes, keeping track of the\
    \ current index.\n    - For each index we match the character at the index with\
    \ the character at the reverse index,\n        and extend the palindrome length\
    \ while they match.\n    - We just return the longest palindrome we find.\n  \
    \  >>> longest_palindrome_suffix(\"\")\n    \"\"\n    >>> longest_palindrome_suffix(\"\
    abcd\")\n    \"\"\n    >>> longest_palindrome_suffix(\"aa\")\n    \"aa\"\n   \
    \ >>> longest_palindrome_suffix(\"a\")\n    \"a\"\n*/\nstring longest_palindrome_suffix(string\
    \ string) \n{\n    string palindrome_suffix = \"\";\n    foreach (index, character;\
    \ string) \n    {\n        size_t count = 0;\n        foreach (reverse_index,\
    \ reverse_character; string[$ - 1 .. index]) \n        {\n            if (character\
    \ == reverse_character) \n            {\n                ++count;\n          \
    \  } \n            else \n            {\n                break;\n            }\n\
    \        }\n        if (count > palindrome_suffix.length) \n        {\n      \
    \      palindrome_suffix = string[index .. index + count];\n        }\n    }\n\
    \    return palindrome_suffix;\n}", "{\n\tauto suffix = string.suffixOfLength(longest_palindrome_size(string));\n\
    \treturn string ~ reverse(string[0 .. $ - suffix.length]);\n}\n \nsize_t longest_palindrome_size(string\
    \ string) \n{\n\tauto max = 0;\n\tfor (size_t i = 0; i < string.length; i++) \n\
    \t{\n\t\tsize_t j = 0;\n\t\twhile (i - j >= 0 && i + j < string.length && string[i\
    \ - j] == string[i + j]) \n\t\t{\n\t\t\tmax = max(max, 2 * j + 1);\n\t\t\tj++;\n\
    \t\t}\n\t\tj = 0;\n\t\twhile (i - j >= 0 && i + j + 1 < string.length && string[i\
    \ - j] == string[i + j + 1]) \n\t\t{\n\t\t\tmax = max(max, 2 * j + 2);\n\t\t\t\
    j++;\n\t\t}\n\t}\n\treturn max;\n}\n \nstring longest_palindrome(string string)\
    \ \n{\n\tsize_t size = longest_palindrome_size(string);\n\tfor (size_t i = 0;\
    \ i < string.length; i++) \n\t{\n\t\tsize_t j = 0;\n\t\twhile (i - j >= 0 && i\
    \ + j < string.length && string[i - j] == string[i + j]) \n\t\t{\n\t\t\tif (2\
    \ * j + 1 == size) \n\t\t\t{\n\t\t\t\treturn string[i - j .. i + j];\n\t\t\t}\n\
    \t\t\tj++;\n\t\t}\n\t\tj = 0;\n\t\twhile (i - j >= 0 && i + j + 1 < string.length\
    \ && string[i - j] == string[i + j + 1]) \n\t\t{\n\t\t\tif (2 * j + 2 == size)\
    \ \n\t\t\t{\n\t\t\t\treturn string[i - j .. i + j + 1];\n\t\t\t}\n\t\t\tj++;\n\
    \t\t}\n\t}\n\treturn", "{\n    auto l = make_palindrome_postfix(string);\n   \
    \ auto r = reverse(string[0..$-l]);\n    return string ~ r;\n}\n/*\n Finds the\
    \ longest palindromic postfix.\n    >>> make_palindrome_postfix(\"cata\")\n  \
    \  1\n    >>> make_palindrome_postfix(\"cat\")\n    0\n    >>> make_palindrome_postfix(\"\
    \")\n    0\n*/\nsize_t make_palindrome_postfix(string string) {\n    size_t[string.length]\
    \ f;\n    size_t j = string.length;\n    for (size_t i = string.length - 1; i\
    \ >= 0; i--) {\n        if (string[i] == string[j]) {\n            f[i] = f[j];\n\
    \            j--;\n        } else {\n            j = string.length;\n        \
    \    f[i] = j - i;\n        }\n    }\n    return f[0];\n}", "{\n    static string\
    \ reverse(string string) \n    {\n        return string.dup.mirror.idup;\n   \
    \ }\n    static size_t find_longest_palindrome_suffix(string string) \n    {\n\
    \        size_t l = 0;\n        foreach (size_t r; r < string.length; r++) \n\
    \        {\n            for (; l <= r; l++) \n            {\n                if\
    \ (string[l] != string[r]) \n                {\n                    break;\n \
    \               }\n            }\n            if (l > r) \n            {\n   \
    \             break;\n            }\n            l = max(0, l - 1);\n        }\n\
    \        return l;\n    }\n    auto x = string.popFrontN(find_longest_palindrome_suffix(string));\n\
    \    return string ~ reverse(x);\n}\n/*\n \nhttps://rosettacode.org/wiki/Longest_common_subsequence#D\n\
    \ \n A subsequence of a given sequence is just the given sequence with some elements\
    \ left out.\n Given a sequence X = < x1, x2, ..., xm > another sequence Z = <\
    \ z1, z2, ..., zk > is a subsequence of X if there exists a strictly increasing\
    \ sequence < i1, i2, ..., ik > of indices of X such that for all j = 1,2,...,k,\
    \ xij = zj.\n For example, Z = < a, b, f, c > is a subsequence of X = < a, b,\
    \ c, f, b, c > with index sequence < 1, 2, 4, 6 >.\n \n A common subsequence of\
    \ two sequences X and Y is a subsequence of both X and Y.\n For example, < a,\
    \ b, c > is a common subsequence of < a, b, c, f, b, c > and < f, b, a, c, a,\
    \ d, b, c >.\n \n*/", "{\n    auto last_it = string.length;\n    /*\n     find\
    \ last element of the string.\n    */\n    auto mid_pos = string.length / 2;\n\
    \    /*\n    find middle position of the string.\n    */\n    for (int j = 0;\
    \ j < mid_pos; j++) \n    {\n        /*\n        Compare each element of a left\
    \ part of a string with the same element of a right part.\n        */\n      \
    \  if (string[j] != string[last_it])\n        {\n            /*\n            If\
    \ those elements are not equal, it means that we found the first position where\
    \ a part of string that is not a palindrome begins.\n            So that position\
    \ minus 1 is the last position of a palindromic suffix.\n            */\n    \
    \        auto last_pos = j - 1;\n            /*\n            According to this\
    \ value create a slice of string which contains the found palindromic suffix.\n\
    \            */\n            auto palindrome_slice = string[j .. last_it];\n \
    \           /*\n            Reverse it to get prefix of string which is not a\
    \ palindrome.\n            */\n            auto reverse_palindrome_slice = palindrome_slice.reversed;\n\
    \            /*\n            Append it to the end of a string.\n            */\n\
    \            return string ~ reverse_palindrome_slice;\n        }\n        else\n\
    \        {\n            /*\n            If values are equal, we need to advance\
    \ the last iterator, to compare the next element from the left with the next element\
    \ from the right.\n            */\n            last_it--;\n        }\n    }\n\
    }\n/*\nThis function is made just for tests.\n*/", "{ \n    if (string.length\
    \ == 0) \n        return \"\";\n    if (string.length == 1) \n        return string\
    \ ~ string;\n    \n    auto concat = string ~ string.reverse;\n    auto z_arr\
    \ = z_function(concat);\n    auto z_length = z_arr.length;\n    auto longest_palindrome_begin\
    \ = z_length / 2;\n    auto longest_palindrome_length = z_arr[longest_palindrome_begin];\n\
    \    auto max_possible_length = min(string.length, longest_palindrome_length)\
    \ * 2;\n    if (longest_palindrome_length == max_possible_length) \n        return\
    \ string;\n    else \n        return string ~ string[0..string.length - longest_palindrome_length].reverse;\n\
    }\n ", "    /*\n    - Find the longest postfix of supplied string that is a palindrome.\n\
    \    - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    */\n    if (string.length == 0) \n        return\
    \ \"\"\n    else if (string.length == 1) \n        return string ~ string\n  \
    \  else \n        int n = string.length\n        /*\n        Find the longest\
    \ postfix of supplied string that is a palindrome.\n        */\n        int longest_palindrome_suffix_length\
    \ = n - argmax!(length => string[0 .. $ - length] == string[length .. $].idup).length\n\
    \        /*\n        Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n        */\n        return string\
    \ ~ string[0 .. n - longest_palindrome_suffix_length].idup.idup.reverse\n/*\n\
    \ Testing", "{\n    if(string.length == 0) \n    {\n        return \"\";\n   \
    \ }\n    else \n    {\n        immutable int length = string.length;\n       \
    \ immutable int i = length - 1;\n        for(; i >= 0; i--) \n        {\n    \
    \        immutable int left = i;\n            immutable int right = length - 1;\n\
    \            for(; left >= 0 && right >= 0; left--, right--) \n            {\n\
    \                if(string[left] != string[right]) \n                {\n     \
    \               break;\n                }\n            }\n            if(left\
    \ == -1) \n            {\n                break;\n            }\n        }\n \
    \       immutable int start = i + 1;\n        return string ~ string[start..length].dup.reverse;\n\
    \    }\n}", "{ \n  auto is_palindrome(uint i, uint j) \n  { \n    return i >=\
    \ j ? true : string[i] == string[j] && is_palindrome(i + 1, j - 1); \n  } \n \
    \ auto shortest_palindrome_length(uint i) \n  { \n    return is_palindrome(0,\
    \ i) ? i + 1 : shortest_palindrome_length(i - 1); \n  } \n  return string ~ string[0\
    \ .. shortest_palindrome_length(string.length - 1) - 1].reverse; \n}", "{ \n \
    \ string palindrome = string;\n  string suffix = \"\";\n  foreach(char c; palindrome)\n\
    \    suffix = c ~ suffix;\n  return palindrome ~ suffix;\n}\n/*\n Find the longest\
    \ palindrome that is a suffix of a supplied string.\n    >>> find_longest_palindrome_suffix(\"\
    \")\n    \"\"\n    >>> find_longest_palindrome_suffix(\"cat\")\n    \"\"\n   \
    \ >>> find_longest_palindrome_suffix(\"cac\")\n    \"cac\"\n    >>> find_longest_palindrome_suffix(\"\
    catac\")\n    \"cac\"\n    >>> find_longest_palindrome_suffix(\"cacatac\")\n \
    \   \"cacatac\"\n    >>> find_longest_palindrome_suffix(\"ccacatac\")\n    \"\
    cacatac\"\n*/\nstring find_longest_palindrome_suffix(string str) \n{\n    int\
    \ length = str.length;\n    int i = 0;\n    int j = 1;\n    int longest = 0;\n\
    \    int longest_pos = 0;\n    if (length < 2)\n        return \"\";\n    while\
    \ (j < length) \n    {\n        while (j < length && str[i] == str[j]) \n    \
    \    {\n            i++;\n            j++;\n        }\n        int k = 0;\n  \
    \      while (k < i && str[k] == str[i - k - 1])\n            k++;\n        if\
    \ (k == i && longest < i) \n        {\n            longest = i;\n            longest_pos\
    \ = j - i;\n        }\n        i = 0;\n        j++;\n    }\n    return str[longest_pos\
    \ .. longest_pos + longest];\n}", "{\n\tauto postfix_size = longest_palindrome_size(string);\n\
    \treturn string ~ string[0..$-postfix_size].dup.mirror;\n}", "{\n    string prefix\
    \ = string[0..$ - min(1, find(string[0..$],\"\").length)];\n    string reverse_prefix\
    \ = prefix[0..$ - 1].dup.reverse;\n    return string ~ reverse_prefix;\n}\n \n\
    \ \n \n \n/*\n Returns a pair of arrays of integers (positions) where the first\
    \ array is a\n    list of positions where the first string has *unique* characters\n\
    \    and the second array is a list of positions where the second string has *unique*\
    \ characters.\n    >>> find_unique_characters(\"abcd\", \"cdef\")\n    ([0, 1,\
    \ 3], [0, 1, 2])\n    >>> find_unique_characters(\"abcd\", \"abc\")\n    ([3],\
    \ [])\n    >>> find_unique_characters(\"abc\", \"abc\")\n    ([], [])\n    >>>\
    \ find_unique_characters(\"abcd\", \"abcd\")\n    ([], [])\n*/\nauto find_unique_characters(string\
    \ first, string second) \n{\n    size_t num = max(first.length, second.length);\n\
    \    int[] first_positions;\n    int[] second_positions;\n    for (size_t i =\
    \ 0; i < num; i++) \n    {\n        if (i >= first.length || i >= second.length)\
    \ \n        {\n            if (i >= first.length) \n            {\n          \
    \      second_positions ~= i;\n            }\n            else \n            {\n\
    \                first_positions ~= i;\n            }\n        }\n        else\
    \ \n        {\n            if (first[i] != second[i]) \n            {\n      \
    \          first_positions ~= i;\n                second_positions ~= i;\n   \
    \         }\n        }\n    }\n    return tuple(first_positions, second_positions);\n\
    }\n \n \n \n \n/*\n Return the longest common substring of two strings.\n    >>>\
    \ common_substring(\"abcd\", \"cdef\")\n    \"cd\"\n    >>> common_substring(\"\
    abcd\", \"a\")\n    \"a\"\n    >>> common_substring(\"abcd\", \"bc", "{\n\tsize_t\
    \ postfix_size = longest_palindromic_suffix(string);\n\tsize_t prefix_size = string.length\
    \ - postfix_size;\n\treturn string[prefix_size..$] ~ string[0..prefix_size].dup.reverse;\n\
    }", "{\n    if(string.length == 0)\n        return \"\";\n    //Find the longest\
    \ palindromic suffix\n    enum length = string.length;\n    size_t offset;\n \
    \   //Iterator over string in reverse order\n    for(offset = length; offset >\
    \ 0; offset--) \n    {\n        //Check if substring of length `offset` is a palindrome\n\
    \        if(is_palindrome(string[$-offset..$]))\n            break;\n    }\n \
    \   //string[$-offset..$] is a palindrome. Now append reverse of prefix to string\n\
    \    return string ~ string[0..$-offset].reverse;\n}\n/*\n    Check whether string\
    \ is a palindrome or not.\n*/", "{ \n    auto length = string.length;\n    if\
    \ (length <= 1) \n        return string; \n    auto half = (int) floor(length\
    \ / 2); \n    auto i = half; \n    auto end = length - 1; \n    for (; i >= 0;\
    \ --i) \n    { \n        if (string[i] == string[end]) \n            --end; \n\
    \        else \n            break; \n    } \n    if (i < 0) \n        return string;\
    \ \n    string result = string; \n    if (end + 1 < length) \n        result ~=\
    \ string[0 .. end]; \n    else \n        result ~= string[1 .. $]; \n    reverse(result);\
    \ \n    return result; \n} \n/*\n Find the shortest palindrome that begins with\
    \ a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    - Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    >>>\
    \ make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\
    \n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \n*/\nstring make_palindrome_x(string\
    \ string) \n{ \n    auto length = string.length;\n    if (length <= 1) \n    \
    \    return string; \n    auto half = (int) floor(length / 2); \n    auto i =\
    \ half; \n    auto end = length - 1; \n    for (; i >= 0; --i) \n    { \n    \
    \    if (string[i] == string[end]) \n            --end; \n        else \n    \
    \        break; \n    } \n    if (i < 0) \n        return string; \n    string\
    \ result = string; \n    if (end + 1 < length) \n        result ~= string[0 ..\
    \ end]; \n    else \n        result ~= string[1 .. $]; \n    reverse(result);\
    \ \n    return result; \n} ", "{\n    // is_palindrome: Predicate that returns\
    \ true if a supplied string is a palindrome.\n    bool is_palindrome(string string)\
    \ \n    {\n        bool result = false;\n        int low = 0;\n        int high\
    \ = string.length() - 1;\n        while(low < high) \n        {\n            if(string[low]\
    \ != string[high]) \n            {\n                return false;\n          \
    \  }\n            low++;\n            high--;\n        }\n        return true;\n\
    \    }\n    string result = \"\";\n    string temp = \"\";\n    // longest_palindrome_index:\
    \ Finds the length of the longest palindrome that is a postfix of a supplied string.\n\
    \    int longest_palindrome_index(string string) \n    {\n        int index =\
    \ 0;\n        int high = string.length() - 1;\n        while(high >= 0) \n   \
    \     {\n            temp = string[0..high];\n            if(is_palindrome(temp))\
    \ \n            {\n                index = temp.length();\n                break;\n\
    \            }\n            high--;\n        }\n        return index;\n    }\n\
    \    string reversed = \"\";\n    // reverse: Return a reverse of a supplied string.\n\
    \    string reverse(string string) \n    {\n        string string_copy = string;\n\
    \        return string_copy.reverse;\n    }\n    int index = longest_palindrome_index(string);\n\
    \    // If all the characters in the string form a palindrome, we are done.\n\
    \    if(index == string.length()) \n    {\n        return string;\n    }\n   \
    \ temp = string[0..string.length() - index];\n    // Reversing the string prefix\
    \ that comes before the palindromic suffix.\n    reversed = reverse(temp);\n \
    \   result = string ~ reversed;\n    return result;\n}", "{\n\tif(string.empty)\
    \ \n\t{\n\t\treturn string;\n\t}", "{\n    auto suffix = string[0..0];\n    for\
    \ (int i = 1; i < string.length; ++i) {\n        if (string[0..i] == string[i..$].reverse)\
    \ {\n            suffix = string[0..i];\n        }\n    }\n    if (suffix == string)\
    \ {\n        return string;\n    }\n    else {\n        return string ~ string[0..string.length\
    \ - suffix.length].reverse;\n    }\n}", "{\n    size_t L = string.length;\n  \
    \  size_t longest = 1;\n    for (size_t i = L / 2; i > 0; i--) \n    {\n     \
    \   size_t c = L - i;\n        if (i + c < L && string[0 .. i] == string[c ..\
    \ $]) \n        {\n            longest = i;\n            break;\n        }\n \
    \   }\n    return string ~ string[$ - longest .. $].reverse;\n}\n/*\n Find the\
    \ shortest palindrome that begins with a supplied string.\n    \n    \n*/\nstring\
    \ make_palindrome_v2(string string) \n{\n    size_t L = string.length;\n    if\
    \ (L < 2) \n    {\n        return string;\n    }\n    size_t longest = 0;\n  \
    \  for (size_t i = 0; i < L; i++) \n    {\n        if (string[0 .. i + 1] == string[i\
    \ + 1 .. $].reverse) \n        {\n            longest = i + 1;\n        }\n  \
    \  }\n    return string ~ string[$ - longest .. $].reverse;\n}\n/*\n Find the\
    \ shortest palindrome that begins with a supplied string.\n    \n    \n*/\nsize_t\
    \ get_reverse_string_index(string string, size_t i) \n{\n    return string.length\
    \ - i - 1;\n}", "{ \n\t// return string if empty or a single char \n\tif (string.length\
    \ == 0 || string.length == 1) \n\t\treturn string; \n\tsize_t n = string.length;\
    \ \n\tsize_t mid = n / 2; \n\tsize_t start = mid; \n\tsize_t end = mid; \n\tsize_t\
    \ j; \n\tsize_t i; \n\t// find the longest palindromic suffix \n\twhile (start\
    \ > 0 && end < n - 1) \n\t{ \n\t\tif (string[start - 1] == string[end + 1]) \n\
    \t\t{ \n\t\t\tstart--; \n\t\t\tend++; \n\t\t} \n\t\telse \n\t\t\tbreak; \n\t}\
    \ \n\t// If entire string is palindrome, then return it \n\tif (start == 0 &&\
    \ end == n - 1) \n\t\treturn string; \n\t// Now start to construct the palindrome\
    \ \n\tstring s = new string; \n\t// Append the reverse of string after the longest\
    \ palindromic suffix \n\tfor (i = end + 1; i < n; i++) \n\t\ts ~= string[i]; \n\
    \t// Now append the remaining prefix \n\tfor (i = start - 1; i >= 0; i--) \n\t\
    \ts ~= string[i]; \n\treturn s; \n} \nstring check(string s)\n{\n\treturn s.make_palindrome();\n\
    }", "{\n    if (string.empty) return string;\n    foreach (i, sub; reverse(string))\n\
    \    {\n        if (string.startsWith(sub)) break;\n        else i += sub.length;\n\
    \    }\n    return string ~ string[i..$];\n}", "{\n    if (string.empty) \n  \
    \  {\n        return string;\n    }", "{\n    import std.algorithm;\n    import\
    \ std.conv;\n    import std.range;\n    import std.stdio;\n    import std.string;\n\
    \    import std.uni;\n    import std.array;\n    /*\n     - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    */\n    /*\n     * Returns longest\
    \ possible palindrome postfix\n     *\n     * @param string input string\n   \
    \  * @return longest possible palindrome postfix\n     */\n    string longest_palindrome_postfix(string\
    \ string) \n    {\n        import std.conv;\n        import std.range;\n     \
    \   import std.stdio;\n        import std.string;\n        import std.uni;\n \
    \       import std.array;\n        /*\n         * @param string input string\n\
    \         * @return all possible suffixes of a string, longest first\n       \
    \  */\n        auto all_suffixes(string string) \n        {\n            import\
    \ std.conv;\n            import std.range;\n            import std.stdio;\n  \
    \          import std.string;\n            import std.uni;\n            import\
    \ std.array;\n            /*\n             * @param string input string\n    \
    \         * @return length of a string\n             */\n            auto len(string\
    \ string)\n            {\n                import std.conv;\n                import\
    \ std.range;\n                import std.stdio;\n                import std.string;\n\
    \                import std.uni;\n                import std.array;\n        \
    \        return string.length;\n            }\n            /*\n             *\
    \ @param string input string\n             * @return all possible suffixes of\
    \ a string, longest first\n             */\n            auto suffixes(string string)\
    \ \n            {\n                import std.conv;\n                import std.range;\n\
    \                import std.stdio;\n                import std.string;\n     \
    \           import std.uni;\n                import std.array;\n             \
    \   return iota(len(string), 0).map!(i => string[i ..]);\n            }\n    \
    \        return suffixes(string);\n        }\n        /*\n         * @param string\
    \ input string\n         * @return true if a string is a palindrome\n        \
    \ */\n        auto is_palindrome(", "{\n    ulong longest_palindrome_suffix_end_idx\
    \ = 0;\n    foreach(ulong idx, ulong start_idx; longest_subpalindrome(string,\
    \ start_idx))\n    {\n        if (idx > longest_palindrome_suffix_end_idx)\n \
    \       {\n            longest_palindrome_suffix_end_idx = idx;\n        }\n \
    \   }\n    if (longest_palindrome_suffix_end_idx == string.length)\n    {\n  \
    \      return string;\n    }\n    return string ~ reverse(string[0 .. longest_palindrome_suffix_end_idx]);\n\
    }\n/*\n Find the longest subpalindrome in a string, starting from a given index.\n\
    \    Finds the longest palindrome starting from the given index, and returns\n\
    \    a tuple containing the index of the last character in the palindrome and\n\
    \    the index of the first character in the palindrome. The input string is\n\
    \    expected to be non-empty.\n    >>> longest_subpalindrome(\"\", 0)\n    (0,\
    \ 0)\n    >>> longest_subpalindrome(\"cat\", 0)\n    (0, 0)\n    >>> longest_subpalindrome(\"\
    cat\", 1)\n    (2, 1)\n    >>> longest_subpalindrome(\"cata\", 1)\n    (2, 1)\n\
    \    >>> longest_subpalindrome(\"catac\", 2)\n    (4, 2)\n    >>> longest_subpalindrome(\"\
    catac\", 3)\n    (3, 3)\n    >>> longest_subpalindrome(\"catac\", 4)\n    (4,\
    \ 4)\n*/\ntuple!(ulong, ulong) longest_subpalindrome(string string, ulong start_idx)\
    \ nothrow @safe pure \n{\n    if (start_idx >= string.length)\n    {\n       \
    \ return tuple(start_idx, start_idx);\n    }\n    // check for a single character\
    \ palindrome\n    ulong char_idx = string.countUntil(string[start_idx]);\n   \
    \ if (char_idx == string", "{\n    string reversed_prefix = string.dup.dup[0..-$-(string.length/2)].idup.retro;\n\
    \    string palindromic_suffix = string.dup.dup[-$(string.length/2)..$];\n   \
    \ size_t palindromic_suffix_size = palindromic_suffix.length;\n    size_t i =\
    \ 1;\n    while (i < palindromic_suffix_size) {\n        size_t prefix_begin =\
    \ 0;\n        size_t prefix_end = palindromic_suffix_size - i;\n        size_t\
    \ suffix_begin = palindromic_suffix_size - i;\n        size_t suffix_end = palindromic_suffix_size;\n\
    \        if (palindromic_suffix[prefix_begin..prefix_end] ==\n            palindromic_suffix[suffix_begin..suffix_end])\
    \ {\n            break;\n        }\n        i++;\n    }\n    return string ~ reversed_prefix[$-i..$];\n\
    }", "{\n    if (string.empty)\n        return string;\n    auto start_index =\
    \ 0;\n    auto end_index = string.length - 1;\n    while (end_index >= 0)\n  \
    \  {\n        if (string[start_index] == string[end_index])\n        {\n     \
    \       start_index++;\n        }\n        end_index--;\n    }\n    if (start_index\
    \ == string.length)\n        return string;\n    string prefix = string[0..start_index];\n\
    \    return prefix ~ make_palindrome(string[start_index..$]) ~ prefix.mirror;\n\
    }", "{\n    string p = string;\n    ulong len = string.length;\n    string s =\
    \ \"\";\n    for (ulong i = len; i > 0; i--) {\n        s ~= p[i-1];\n    }\n\
    \    string a = string + s;\n    string b = string;\n    ulong j = 1;\n    for\
    \ (ulong i = 0; i < len; i++) {\n        b = string[0..j-1] ~ s[j-1..$];\n   \
    \     j++;\n        auto kmp = KnuthMorrisPratt(b);\n        ulong pos = kmp.find(a);\n\
    \        if (pos < 0) {\n            break;\n        }\n    }\n    return b;\n\
    }", "{\n    \n}", "{ \n    string original = string;\n    string reverse = string.dup.reverse;\n\
    \    string palindrome = \"\";\n    foreach(element;original)\n    {\n       \
    \ string curr = original.idup.take(element);\n        if(curr.length==0)\n   \
    \     {\n            continue;\n        }\n        else if(original.length==curr.length)\n\
    \        {\n            break;\n        }\n        else if(curr.idup.reverse ==\
    \ curr)\n        {\n            string more = reverse.idup.take(reverse.length-curr.length);\n\
    \            string temp = curr~more;\n            if(temp.length<palindrome.length\
    \ || palindrome.length==0)\n            {\n                palindrome = temp;\n\
    \            }\n        }\n    }\n    return palindrome;\n}", "{\n    string rev\
    \ = string.dup.reverse();\n    size_t n = string.length;\n    size_t i = string.length;\n\
    \    while (i--) \n    {\n        if (string[i..$] == rev[0..n - i])\n       \
    \     break;\n    }\n    return string ~ rev[n - i..$];\n}\n/*\n Find the shortest\
    \ palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n\
    \    - Find the longest postfix of supplied string that is a palindrome.\n   \
    \ - Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    \n\
    */\nstring make_palindrome(string string) \n{\n    string rev = string.dup.reverse;\n\
    \    size_t n = string.length;\n    size_t i = string.length;\n    while (i--)\
    \ \n    {\n        if (string[i..$] == rev[0..n - i])\n            break;\n  \
    \  }\n    return string ~ rev[n - i..$];\n}\n/*\n Converts a floating point number\
    \ to a string with the specified precision.\n    It uses exponential notation\
    \ if that's more compact.\n    >>> ftoa(1.2)\n    \"1.2\"\n    >>> ftoa(1.2e-5)\n\
    \    \"1.2e-5\"\n    \n*/\nstring ftoa(double d, uint prec = 6) \n{\n    string\
    \ result;\n    d_to_string(result, d, prec);\n    return result;\n}\n/*\n Converts\
    \ a floating point number to a string with the specified precision.\n    It uses\
    \ exponential notation if that's more compact.\n    >>> ftoa(1.2)\n    \"1.2\"\
    \n    >>> ftoa(1.2e-5)\n    \"1.2e-5\"\n    \n*/\nstring ftoa(double d, uint prec",
  "{\n    \n    \n    string prefix = string[0..$-1];\n    string suffix = string[$-1..0];\n\
    \    //gather the longest common prefix and postfix\n    size_t i = 0;\n    for\
    \ (; i < min(prefix.length, suffix.length); i++) {\n        if (prefix[i] != suffix[i])\n\
    \            break;\n    }\n    string common = prefix[0..i];\n    //a given string\
    \ is already a palindrome\n    if (common.length == string.length)\n        return\
    \ string;\n    //append reverse of a string prefix that comes before the palindromic\
    \ suffix\n    return string ~ reverse(prefix[i..$]);\n}\n/*\n Generate possible\
    \ permutations of a supplied string.\n    Algorithm idea is simple:\n    - Create\
    \ a set of all possible characters for the string.\n    - For each character in\
    \ the set, generate all permutations of the string excluding the character.\n\
    \    - For each permutation, add the character to the start and to the end of\
    \ the string.\n    >>> list(permutations(\"\"))\n    []\n    >>> list(permutations(\"\
    a\"))\n    [\"a\"]\n    >>> list(permutations(\"ab\"))\n    [\"ab\", \"ba\"]\n\
    \    >>> list(permutations(\"abc\"))\n    [\"abc\", \"acb\", \"bac\", \"bca\"\
    , \"cab\", \"cba\"]\n    >>> list(permutations(\"aabb\"))\n    [\"aabb\", \"abab\"\
    , \"abba\", \"baab\", \"baba\", \"bbaa\"]\n    \n*/\nimport std.algorithm;\nimport\
    \ std.array;\nimport std.exception;\nimport std.stdio;\nimport std.range;\nimport\
    \ std.string;\nimport std.typecons;\nstring[] permutations(string string) \n{\n\
    \    //if the string is empty, only one (empty) permutation exists\n    if (string.length\
    \ == 0)\n        return [string];\n    //set of all possible characters for the\
    \ string\n    string[char[]] chars = group(string);\n    //generate all permutations\
    \ for the string excluding the character\n    string[][] result = new string[][];\n\
    \    foreach (", "{\n    int n = string.length;\n    foreach (i; 0 .. (2 * n))\
    \ \n    {\n        int j = i / 2;\n        int k = (i + 1) / 2;\n        bool\
    \ fail = false;\n        while (k < n) \n        {\n            if (string[j]\
    \ != string[k]) \n            {\n                fail = true;\n              \
    \  break;\n            }\n            j -= 1;\n            k += 1;\n        }\n\
    \        if (!fail) \n        {\n            string suffix = string[k .. $];\n\
    \            string middle = \"\";\n            if (j >= 0) \n            {\n\
    \                middle = string[0 .. j + 1];\n            }\n            return\
    \ middle ~ suffix ~ reverse(suffix) ~ middle;\n        }\n    }\n    assert(false);\n\
    }", "{\n  auto len = string.length;\n  if (len == 0) return \"\";\n  /*\n    Initialize\
    \ a table of booleans for the longest palindromic suffix of each prefix\n    of\
    \ the supplied string.\n  */\n  bool[string.length] table;\n  /* \n    Initialize\
    \ first element of the table to true as\n    empty string is a palindrome.\n \
    \ */\n  table[0] = true;\n  /* \n    Initialize second element to true if the\
    \ first two characters\n    of the string is palindrome.\n  */\n  table[1] = string[0]\
    \ == string[1];\n  /* \n    Start filling the table from the third element:\n\
    \    table[i] is true if\n    - string[i-1] is equal to string[len-1]\n    - table[i-2]\
    \ is true, i.e. string[i-1..len-1] is a palindrome.\n  */\n  for (int i = 2; i\
    \ < len; i++) \n  {\n    table[i] = (string[i-1] == string[len-1]) && table[i-2];\n\
    \  }\n  /* \n    if whole string is a palindrome return it,\n    otherwise return\
    \ it appended with reversed prefix \n    that comes before the palindromic suffix.\n\
    \  */\n  if (table[len-1]) return string;\n  return string ~ reverse(string[0..findNot(table[0..len-1],\
    \ true)]);\n}\n/*\n    Make a palindrome string from a series of words and\n \
    \   a supplied separator.\n    >>> make_palindrome_words([\"cat\", \"bat\", \"\
    rat\"], \" \")\n    \"rat tab cat bat cat\"\n    >>> make_palindrome_words([\"\
    cat\", \"bat\", \"rat\"], \"\")\n    \"rattabcatbatcat\"\n    >>> make_palindrome_words([\"\
    cat\", \"bat\", \"rat\"], \"*\")\n    \"rat*tab*cat*bat*cat\"\n*/\nstring make_palindrome_words(string[]\
    \ words, string sep) \n{\n  if (words.length ==", "{\n    int longest_suffix_palindrome\
    \ = 0;\n    int possible_suffix_palindrome = 1;\n    foreach(q, i; string[0 ..\
    \ $]) {\n        longest_suffix_palindrome = \n            longest_suffix_palindrome\
    \ - 1 <= 0 ? \n            0 : \n            possible_suffix_palindrome > longest_suffix_palindrome\
    \ ? \n            possible_suffix_palindrome : \n            longest_suffix_palindrome;\n\
    \        if(i >= q) {\n            if(string[q] == string[i]) {\n            \
    \    possible_suffix_palindrome = max(possible_suffix_palindrome + 2, 2);\n  \
    \          } else {\n                possible_suffix_palindrome = 1;\n       \
    \     }\n        }\n    }\n    string result = string;\n    for(auto s = string[0\
    \ .. longest_suffix_palindrome]; s; s = s[1 .. $]) {\n        result ~= s;\n \
    \   }\n    return result;\n}", "{ \n    auto length = string.length; \n    if\
    \ (length == 0) \n    { \n        return \"\"; \n    } \n    else if (length ==\
    \ 1) \n    { \n        return string; \n    } \n    else if (length == 2) \n \
    \   { \n        return string ~ string.reverse; \n    } \n    else \n    { \n\
    \        auto suffix_length = length; \n        for (suffix_length = length; suffix_length\
    \ > 0; --suffix_length) \n        { \n            if (string[0 .. $ - suffix_length].equal(string[suffix_length\
    \ .. $].reverse)) \n            { \n                break; \n            } \n\
    \        } \n        return string ~ string[0 .. $ - suffix_length].reverse; \n\
    \    } \n} \n/*\n    A template that takes two integers, where one is the number\
    \ of integers in a sequence, and other is the actual integer in question.\n  \
    \  The template returns the position of that integer in the sequence.\n    The\
    \ algorithm is based on solving the Pell equation:\n    http://en.wikipedia.org/wiki/Pell%27s_equation\n\
    \    The solution is found using the continued fraction algorithm that finds the\
    \ minimal solution for the Pell equation.\n    >>> get_indexOf(3, 1)\n    1\n\
    \    >>> get_indexOf(3, 2)\n    5\n    >>> get_indexOf(3, 3)\n    9\n    >>> get_indexOf(5,\
    \ 1)\n    1\n    >>> get_indexOf(5, 2)\n    13\n    >>> get_indexOf(5, 3)\n  \
    \  45\n    >>> get_indexOf(5, 4)\n    109\n    >>> get_indexOf(5, 5)\n    193\n\
    \    >>> get_indexOf(6, 1)\n    1\n    >>> get_indexOf(6, 2)\n    17\n    >>>\
    \ get_indexOf(6, 3)\n    85\n    >>> get_indexOf(6, 4)\n    377\n    >>> get_indexOf(6,\
    \ 5)\n    1365\n    >>> get_indexOf(6, 6)\n   ", "{\n    import std.algorithm.searching\
    \ : best_fit;\n    import std.algorithm.comparison : startsWith;\n    import std.algorithm.mutation\
    \ : reverse;\n    if(string.length == 0)\n        return \"\";\n    else if(string.length\
    \ == 1)\n        return string ~ string;\n    else \n    {\n        ulong length\
    \ = string.length;\n        string reverse_string = string.slice(1, string.length);\n\
    \        reverse_string.reverse;\n        auto suffix = best_fit!(\"startsWith\"\
    )(reverse_string);\n        if(suffix == reverse_string.length)\n            return\
    \ string ~ string.reverse;\n        else\n            return string ~ string.slice(suffix,\
    \ string.length).reverse;\n    }\n}\n/*\n Find the longest palindrome that begins\
    \ with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    - Append to the end of\
    \ the string copy of a string postfix that comes after the palindromic suffix.\n\
    \    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n \
    \   \"catcat\"\n    >>> make_palindrome(\"cata\")\n    \"catacata\"\n*/\nstring\
    \ make_longest_palindrome(string string) \n{\n    import std.algorithm.searching\
    \ : best_fit;\n    import std.algorithm.comparison : startsWith;\n    import std.algorithm.mutation\
    \ : reverse;\n    if(string.length == 0)\n        return \"\";\n    else if(string.length\
    \ == 1)\n        return string ~ string;\n    else \n    {\n        ulong length\
    \ = string.length;\n        string reverse_string = string.slice(1, string.length);\n\
    \        reverse_string.reverse;\n        auto suffix = best_fit!(\"startsWith\"\
    )(reverse_string);\n        if(suffix == reverse_string.length)\n            return\
    \ string ~ string.reverse;\n        else\n            return string ~ string.slice(suffix,\
    \ string.length);\n    }\n}", "{\n    int string_size = string.length;\n    if\
    \ (string_size == 0) \n    {\n        return \"\";\n    }\n    // Find longest\
    \ palindromic suffix of the string\n    string longest_palindromic_suffix;\n \
    \   longest_palindromic_suffix = longest_palindromic_suffix_of(string);\n    //\
    \ Append reverse of the string prefix to the palindromic suffix\n    longest_palindromic_suffix\
    \ ~= string[0..$ - longest_palindromic_suffix.length].reverse;\n    return longest_palindromic_suffix;\n\
    }", "{\n    // find the longest palindromic suffix\n    string rev = string.idup.reverse;\n\
    \    auto pal = lcs(string, rev);\n    // append prefix in reverse\n    string\
    \ pal_string = string[0..$-pal.length]~pal;\n    return pal_string;\n}", "{\n\
    \    string suffix(string);\n    string prefix = \"\";\n    while (suffix != suffix.front.idup)\
    \ {\n        if (suffix == suffix.reverse) {\n            break;\n        }\n\
    \        prefix ~= suffix.front;\n        suffix = suffix[1 .. $];\n    }\n  \
    \  return string ~ suffix.reverse;\n}", "{\n    if (string.empty)\n        return\
    \ string;\n    auto max_palindrome_postfix = string.length;\n    for (auto i =\
    \ string.length - 1; i >= 0; --i)\n    {\n        if (string[i] == string[max_palindrome_postfix])\n\
    \            --max_palindrome_postfix;\n    }\n    if (max_palindrome_postfix\
    \ == 0)\n        return string;\n    return string ~= string[max_palindrome_postfix..$].dup.reverse;\n\
    }", "{\n    // create a list of pairs that consist of a postfix string and its\
    \ reverse\n    auto postfixes = zip(string.retro(), string.retro.dropOne);\n \
    \   // Filter the ones that are palindromes\n    postfixes = filter!(isPalindrome)(postfixes);\n\
    \    // Get the longest one\n    auto longest = reduce!max(postfixes);\n    //\
    \ Cut the string from the longest palindromic postfix to the end\n    auto prefix\
    \ = string[0..$-longest.length];\n    // Append the reverse of the prefix to the\
    \ original string\n    return string ~ prefix.retro;\n}\n/*\n    >>> make_palindrome(\"\
    \")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"\
    cata\")\n    \"catac\"\n*/", "{\n    if (string.empty) \n    {\n        return\
    \ string;\n    }\n    auto prefix_start = 0;\n    auto suffix_start = string.length\
    \ - 1;\n    while (suffix_start > 0) \n    {\n        if (string[prefix_start]\
    \ == string[suffix_start]) \n        {\n            ++prefix_start;\n        }\n\
    \        --suffix_start;\n    }\n    auto palindrome_suffix = string[0..suffix_start\
    \ + 1];\n    if (palindrome_suffix.empty) \n    {\n        return string;\n  \
    \  }\n    auto palindrome_prefix = palindrome_suffix[palindrome_suffix.length\
    \ - 1..0].idup;\n    return string ~ palindrome_prefix;\n}", "{ \n  if (string.empty)\
    \ \n    return string; \n  //Find the postfix of the string that is a palindrome\
    \ \n  //and is as long as possible. \n  size_t palindrome_length = 0; \n  for\
    \ (size_t i = 0; i < string.length; ++i) \n  { \n    if (is_palindrome(string[0..i]))\
    \ \n      palindrome_length = i + 1; \n  } \n  //Add prefix to the end of the\
    \ string \n  //and then append it reversed. \n  string += string[0..string.length\
    \ - palindrome_length].reverse; \n  return string; \n} \n ", "{\n    string res\
    \ = string;\n    size_t j = 0;\n    for (size_t i = string.length; i != 0; --i)\
    \ \n    {\n        if (string[i - 1] == string[j]) \n        {\n            j\
    \ += 1;\n        }\n    }\n    if (j == string.length) \n    {\n        return\
    \ res;\n    }\n    for (size_t i = j; i != 0; --i) \n    {\n        res ~= string[i\
    \ - 1];\n    }\n    return res;\n}\n/*\n Substring of string composed of characters\
    \ not in the supplied set.\n    >>> chars_not_in_set(\"fizzbuzz\", \"uz\")\n \
    \   \"fb\"\n    >>> chars_not_in_set(\"fizzbuzz\", \"fb\")\n    \"izuz\"\n   \
    \ >>> chars_not_in_set(\"fizzbuzz\", \"\")\n    \"fizzbuzz\"\n    >>> chars_not_in_set(\"\
    fizzbuzz\", \"fizzbuzz\")\n    \"\"\n*/\nstring chars_not_in_set(string string,\
    \ string chars) \n{\n    string res;\n    foreach (c; string) \n    {\n      \
    \  if (chars.canFind(c)) \n        {\n            continue;\n        }\n     \
    \   res ~= c;\n    }\n    return res;\n}\n/*\n Find the length of the longest\
    \ prefix that is a palindrome.\n    >>> longest_palindrome_prefix(\"abcdedcba\"\
    )\n    9\n    >>> longest_palindrome_prefix(\"cdedcba\")\n    1\n    >>> longest_palindrome_prefix(\"\
    a\")\n    1\n    >>> longest_palindrome_prefix(\"\")\n    0\n*/\nsize_t longest_palindrome_prefix(string\
    \ string) \n{\n    if (string.length == 0) \n    {\n        return 0;\n    }\n\
    \    size_t length = 0;\n    for (size_t i = 0; i < string.length / 2; ++i) \n\
    \    {\n        if (string[i] != string[string.length - i", "{\n    // Find the\
    \ longest palindromic postfix:\n    size_t position = 0;\n    for (; position\
    \ < string.length; ++position) \n    {\n        if (!is_palindrome(string[position..$]))\
    \ \n        {\n            break;\n        }\n    }\n    return string ~ string[0..position].idup.front.idup.reverse;\n\
    }\n//Helper", "{\n    auto len = string.length;\n    string prefix = string[0..len/2],\n\
    \           postfix = string[len-len/2..$];\n    auto pal_start = find_longest_palindrome(postfix);\n\
    \    postfix = postfix[pal_start..$];\n    return string~reverse(prefix[0..$-pal_start]);\n\
    }", "{\n    assert(!isNull(string));\n    auto k = 1; // The index of the leftmost\
    \ character of the longest palindromic suffix of the string.\n    auto len = string.length;\n\
    \    for (int i = 0; i < len; ++i) \n    {\n        auto reversed = string[$[len\
    \ - 1 - i .. len]].idup;\n        if (reversed == string[$[i .. len]]) \n    \
    \    {\n            k = i + 1;\n        }\n    }\n    auto prefix = string[$[0\
    \ .. k]].idup;\n    auto reversed_prefix = prefix.dup.idup.reverse;\n    return\
    \ string ~ reversed_prefix;\n}", "{\n    // Reverse the string.\n    auto rev\
    \ = string.dup.idup.reverse;\n    // Find the length of a longest prefix that\
    \ is also a suffix.\n    // Example: catac => 4\n    auto prefix_len = (rev.find(string)\
    \ + 1).idup;\n    // Cut it off from the original string.\n    // Example: catac\
    \ => cat\n    auto cut_off = string[0..$-prefix_len];\n    // Append it to the\
    \ reverse of the original string.\n    // Example: catac => catac + tac => catacatac\n\
    \    return string ~ rev[$-prefix_len..$];\n}", "{\n\tstring palindrome = \"\"\
    ;\n\tauto rev_string = string.dup.reverse();\n\tauto find_string = string[0..$-1];\n\
    \tforeach(offset; 0..find_string.length) \n\t{\n\t\tif(find_string[offset..$]\
    \ == rev_string[0..$-offset]) \n\t\t{\n\t\t\tpalindrome = string ~ rev_string[$-offset..$];\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\treturn palindrome;\n}", "{\n    if (string.empty)\
    \ \n    {\n        return string;\n    }\n    size_t longest_palindrome_prefix_length\
    \ =\n    longest_palindrome_suffix_prefix_match(string);\n    return string ~string[0..longest_palindrome_prefix_length].idup.mirror.idup;\n\
    }", "{\n    auto suffix = string.size;\n    while (suffix > 0) {\n        if (is_palindrome(string[0\
    \ .. suffix])) {\n            return string ~ string[suffix .. $].reverse;\n \
    \       }\n        --suffix;\n    }\n    return string;\n}\n/*\n    Phobos std.algorithm\
    \ has a built-in palindrome checker.\n    >>> import std.algorithm;\n    >>> isPalindrome(\"\
    catac\")\n    true\n    >>> isPalindrome(\"cat\")\n    false\n    >>> isPalindrome(\"\
    atac\")\n    false\n    >>> isPalindrome(\"\")\n    true\n    >>> make_palindrome(\"\
    cat\")\n    \"catac\"\n*/", "{\n    //return result;\n    return \"\";\n}\n/*\n\
    \ Returns a string with the words in reversed order.\n    >>> reverse_words(\"\
    \")\n    \"\"\n    >>> reverse_words(\"cat dog bird\")\n    \"bird dog cat\"\n\
    \    >>> reverse_words(\"cat\\ndog\\nbird\")\n    \"bird\\ndog\\ncat\"\n    >>>\
    \ reverse_words(\"Dogs, Cats, and Mice\")\n    \"Mice, Cats, and Dogs\"\n    >>>\
    \ reverse_words(\"Cat\\nDog\\nbird\")\n    \"bird\\nDog\\nCat\"\n    \n*/\nstring\
    \ reverse_words(string string) \n{\n    //return result;\n    return \"\";\n}\n\
    /*\n    Returns the factorial of a number.\n    \n    >>> factorial(0)\n    1\n\
    \    >>> factorial(1)\n    1\n    >>> factorial(2)\n    2\n    >>> factorial(3)\n\
    \    6\n    >>> factorial(4)\n    24\n    >>> factorial(5)\n    120\n    >>> factorial(6)\n\
    \    720\n    >>> factorial(7)\n    5040\n    >>> factorial(8)\n    40320\n  \
    \  >>> factorial(9)\n    362880\n    >>> factorial(10)\n    3628800\n    >>> factorial(11)\n\
    \    39916800\n    >>> factorial(12)\n    479001600\n    >>> factorial(13)\n \
    \   6227020800\n    >>> factorial(14)\n    87178291200\n    >>> factorial(15)\n\
    \    1307674368000\n    >>> factorial(16)\n    20922789888000\n    >>> factorial(17)\n\
    \    355687428096000\n    >>> factorial(18)\n    6402373705728000\n    >>> factorial(19)\n\
    \    121645100408832000\n    >>> factorial(20)\n    2432902008176640000\n    >>>\
    \ factorial(21)\n    51090942171709440000\n    >>> factorial(22)\n    1124000727777607680000\n\
    \    >>> factorial(23)\n    258520167388849", "{\n    \n    \n    auto end_pos\
    \ = string.length;\n    int p1 = 0;\n    int p2 = end_pos;\n    for (; p1 < p2;\
    \ p1++) \n    {\n        auto lp = string[p1..p2];\n        auto rp = lp.dup.reverse;\n\
    \        if (lp == rp) \n        {\n            break;\n        }\n    }\n   \
    \ return string ~ string[0..p1].reverse;\n}\n/*\n Check whether a string is a\
    \ palindrome.\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"\
    a\")\n    true\n    >>> is_palindrome(\"aa\")\n    true\n    >>> is_palindrome(\"\
    aab\")\n    false\n    >>> is_palindrome(\"abb\")\n    false\n    >>> is_palindrome(\"\
    abcba\")\n    true\n*/", "{\n    string rev;\n    // Reverse a string in O(n)\
    \ time and O(1) space\n    foreach (i, c; string) {\n        rev[$-i] = c;\n \
    \   }\n    // Find the longest suffix of the reversed string that is a prefix\
    \ of the original string\n    auto suffix_len = longest_common_prefix(string,\
    \ rev);\n    // Reverse a string prefix that comes before the palindromic suffix\n\
    \    auto rev_prefix = rev[0..$-suffix_len];\n    // Concatenate the string, its\
    \ reverse prefix and the palindromic suffix\n    return string ~ rev_prefix;\n\
    }\n// Find the longest common prefix of two strings\nsize_t longest_common_prefix(string\
    \ x, string y)\n{\n    size_t n = min(x.length, y.length);\n    foreach (i; 0..n)\n\
    \        if (x[i] != y[i])\n            return i;\n    return n;\n}", "{\n   \
    \ if (string.empty)\n    {\n        return string;\n    }\n    else\n    {\n \
    \       return string + reverse(string.take(string.length.iota.reverse.takeWhile!(\"\
    a != b\")(string)));\n    }\n}\nstatic assert(make_palindrome(\"A\") == \"A\"\
    );\nstatic assert(make_palindrome(\"AA\") == \"AA\");\nstatic assert(make_palindrome(\"\
    cat\") == \"catac\");\nstatic assert(make_palindrome(\"cata\") == \"catac\");\n\
    static assert(make_palindrome(\"catac\") == \"catac\");\nstatic assert(make_palindrome(\"\
    cataca\") == \"catacataca\");\nstatic assert(make_palindrome(\"catacat\") == \"\
    catacatacat\");\nstatic assert(make_palindrome(\"catacata\") == \"catacatacatacata\"\
    );\nstatic assert(make_palindrome(\"aab\") == \"aabaab\");\nstatic assert(make_palindrome(\"\
    aabaa\") == \"aabaaabaa\");\nstatic assert(make_palindrome(\"aabaac\") == \"aabaacbaabaa\"\
    );\nstatic assert(make_palindrome(\"aabaacaa\") == \"aabaacaacbaabaa\");\nstatic\
    \ assert(make_palindrome(\"satorarepatranet\") == \"satorarepatranetartarepatranetsatorarepatranet\"\
    );\nstatic assert(make_palindrome(\"kayak\") == \"kayak\");\nstatic assert(make_palindrome(\"\
    aaab\") == \"aaabaaa\");\nstatic assert(make_palindrome(\"aaaab\") == \"aaaabaaaa\"\
    );\nstatic assert(make_palindrome(\"abcd\") == \"abcdcba\");", "{\n    auto prefix_size\
    \ = string.size();\n    for (size_t i = 0; i < string.size(); ++i) \n    {\n \
    \       if (string[i] == string[string.size() - 1 - i]) \n        {\n        \
    \    prefix_size = string.size() - i - 1;\n        }\n        else \n        {\n\
    \            break;\n        }\n    }\n    return string ~ string[0 .. prefix_size].idup.reverse;\n\
    }", "{\n    // Find the longest postfix that is a palindrome\n    int suffix_size\
    \ = longest_common_suffix(string, reverse(string)).length;\n    // Append the\
    \ reverse of a prefix that comes before palindromic suffix\n    string result\
    \ = string ~ reverse(string[0 .. $ - suffix_size]);\n    return result;\n}\n/*\n\
    \ Finds the common suffix of two strings. \n    Algorithm idea is simple:\n  \
    \  - Find the smallest one of two strings.\n    - Iterate through the smallest\
    \ string and compare the char at the same position with the corresponding char\
    \ in the longest string.\n    - Keep track of the longest common suffix.\n   \
    \ - Return it.\n    >>> longest_common_suffix(\"fog\", \"foggy\")\n    \"fog\"\
    \n    >>> longest_common_suffix(\"fog\", \"dog\")\n    \"\"\n    >>> longest_common_suffix(\"\
    foo\", \"baz\")\n    \"\"\n*/\nstring longest_common_suffix(string a, string b)\n\
    {\n    auto smallest = a.length > b.length ? b : a;\n    auto longest = smallest\
    \ is a ? b : a;\n    auto longest_common_suffix = \"\";\n    foreach (i, c; smallest)\n\
    \    {\n        if (c == longest[i])\n        {\n            longest_common_suffix\
    \ ~= c;\n        }\n        else\n        {\n            break;\n        }\n \
    \   }\n    return longest_common_suffix;\n}\n/*\nReturns a string with the same\
    \ length, containing the same characters, but in reversed order.\n    >>> reverse(\"\
    \")\n    \"\"\n    >>> reverse(\"foo\")\n    \"oof\"\n    >>> reverse(\"ab\")\n\
    \    \"ba\"\n*/\nstring reverse(string string)\n{\n    string result = string[$];\n\
    \    for (int i = $ - 1; i >= 0; i--)\n    {\n        result ~= string[i];\n \
    \   }\n    return result;\n}", "{\n    string reverse = string.dup.idup.idup.reverse;\n\
    \    string result = string;\n    size_t prefixLength = string.length;\n    while(!strcmp(string[0..prefixLength],\
    \ reverse[string.length - prefixLength..$]))\n    {\n        prefixLength--;\n\
    \    }\n    string prefix = string[0..prefixLength].idup.idup.reverse;\n    result\
    \ ~= prefix;\n    return result;\n}", "{\n    import std.algorithm : startsWith;\n\
    \    // reverse the string itself\n    auto reversed = string.copy.idup.reverse();\n\
    \    // find the longest palindromic suffix\n    string palindrome_suffix = \"\
    \";\n    for (size_t i = 0; i < string.length; i++) \n    {\n        string suffix\
    \ = string[i..$];\n        if (reversed.startsWith(suffix)) \n        {\n    \
    \        palindrome_suffix = suffix;\n        }\n    }\n    // append the reversed\
    \ prefix to the original string\n    return string ~ reversed[string.length -\
    \ palindrome_suffix.length..$];\n}", "{\n    // find the longest postfix of supplied\
    \ string that is a palindrome\n    size_t len = string.length;\n    // loop index\
    \ over the string.\n    size_t i;\n    // data to be stored in the MinMax index.\n\
    \    size_t minsup;\n    size_t maxs;\n    // Store the MinMax values of the loop\
    \ index i\n    typeof(index(pair(0,0), i)) minmax;\n    // Find the index i that\
    \ has the largest size_t value of the Max.\n    typeof(reduce!\"a.b[1] > a.a[1]\"\
    (pair(pair(0,0), 0), minmax)) maxind;\n    /*\n        Find the index i that has\
    \ the largest size_t value of the Max.\n    */\n    maxind = reduce!\"a.b[1] >\
    \ a.a[1]\"(pair(pair(0,0), 0), minmax);\n    // To find the longest postfix of\
    \ a string that is a palindrome\n    // we only consider the postfix of the string\
    \ that starts after the Min.\n    size_t start = minmax[0];\n    // calculate\
    \ the length of the prefix that comes before the palindromic suffix.\n    size_t\
    \ prefixlen = len - minmax[1] - 1;\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    return string\
    \ ~ string[len - 1 .. start].dup.mirror;\n}", "{\n    string suffix = string;\n\
    \    string prefix = \"\";\n    int last_index = string.length;\n    while(true)\n\
    \    {\n        if(is_palindrome(suffix))\n        {\n            break;\n   \
    \     }\n        last_index -= 1;\n        prefix += string[last_index];\n   \
    \     suffix = string[0..last_index];\n    }\n    return string + reverse(prefix);\n\
    }", "{\n    struct PalindromeInfo\n    {\n        size_t end;\n        size_t\
    \ len;\n    }\n    struct PalindromeInfo pal_info;\n    struct ManacherResult\n\
    \    {\n        size_t[] pal_end;\n        size_t[] pal_len;\n    }\n    struct\
    \ ManacherResult manacher_result;\n    manacher_result = manacher(string);\n \
    \   pal_info = max(manacher_result.pal_end.map!(a => PalindromeInfo(a, manacher_result.pal_len[a])));\n\
    \    return string ~ string[0 .. pal_info.end - pal_info.len].idup.idup.reverse;\n\
    }", "{\n\tauto pos = min(find(rrange(string), string[]));\n\tstring result = string;\n\
    \tresult ~= result[0..pos].idup;\n\treturn result;\n}", "{\n    auto len = string.length;\n\
    \    foreach (i; 0 .. min(len, len - i)) {\n        if (string[i] != string[len\
    \ - i - 1]) {\n            continue;\n        }\n        return string ~ reverse(string[0\
    \ .. len - i - 1]);\n    }\n    return string;\n}", "{\n    // Returns the longest\
    \ palindromic suffix of given string.\n    string longest_palindromic_suffix(string\
    \ string) \n    {\n        foreach (size_t start; 0 .. string.length) \n     \
    \   {\n            size_t mx_len = min(start, string.length - start);\n      \
    \      foreach (size_t len; 1 .. mx_len + 1) \n            {\n               \
    \ if (string[start - len] != string[start + len - 1]) \n                {\n  \
    \                  break;\n                }\n                return string[start\
    \ .. start + len - 1];\n            }\n        }\n        return \"\";\n    }\n\
    \    if (string.empty) \n    {\n        return \"\";\n    }\n    // Find the longest\
    \ palindromic suffix\n    auto suffix = longest_palindromic_suffix(string);\n\
    \    if (suffix.length == string.length) \n    {\n        return string;\n   \
    \ }\n    auto prefix = string[0 .. string.length - suffix.length].reverse;\n \
    \   return suffix ~ prefix;\n}", "{\n\tstring s = string.idup;\n\tint i = (s.length\
    \ + 1) / 2;\n\twhile (i--) {\n\t\tif (s[0 .. i] == s[i .. $].idup.retro) {\n\t\
    \t\tbreak;\n\t\t}\n\t}\n\treturn string ~ s[i .. $].idup.retro;\n}", "{ \n\tauto\
    \ rev_suffix = string[$-1..$];\n\tforeach(i; 0..string.length)\n\t{\n\t\tif(string[i..$]\
    \ == rev_suffix[0..$-i])\n\t\t{\n\t\t\treturn string ~ reverse(string[0..i]);\n\
    \t\t}\n\t}\n\treturn string;\n}", "{\n    auto result = string[].idup;\n    size_t\
    \ max_postfix_len = 0;\n    size_t max_common_prefix_len = 0;\n    if(string.length\
    \ <= 1)\n    {\n        return result;\n    }\n    size_t common_prefix_len =\
    \ 0;\n    foreach(index; 0 .. string.length)\n    {\n        common_prefix_len\
    \ = min(string.length,common_prefix_len + 1);\n        while(common_prefix_len\
    \ > 0 && string[common_prefix_len - 1] != string[string.length - common_prefix_len])\n\
    \        {\n            common_prefix_len -= 1;\n        }\n        if(index +\
    \ common_prefix_len == string.length)\n        {\n            max_common_prefix_len\
    \ = common_prefix_len;\n            break;\n        }\n    }\n    result ~= string[max_common_prefix_len\
    \ .. $].reverse;\n    return result;\n}", "{\n    auto s = string.length;\n  \
    \  if (s == 0) return \"\";\n    if (s == 1) return string ~ string.reverse;\n\
    \    return string ~ get_complement(string);\n}\n/*\n    Returns prefix complement\
    \ of a given string or the reverse of the string if it is already a palindrome.\n\
    \    >>> get_complement(\"\")\n    \"\"\n    >>> get_complement(\"a\")\n    \"\
    a\"\n    >>> get_complement(\"aa\")\n    \"\"\n    >>> get_complement(\"ab\")\n\
    \    \"ba\"\n    >>> get_complement(\"cata\")\n    \"c\"\n*/\nstring get_complement(string\
    \ string)\n{\n    auto suffix = string.suffixArray;\n    // build LCP from SA\
    \ to find longest prefix that is also a suffix\n    // lcp[i] - longest common\
    \ prefix of suffix[i] and suffix[i-1]\n    // lcp[0] = 0 for all strings\n   \
    \ auto lcp = build_lcp(string, suffix);\n    auto l = lcp.length;\n    auto s\
    \ = string.length;\n    // get the index of the largest LCP value\n    auto imax\
    \ = max_index(lcp);\n    // if string is a palindrome\n    if (lcp[imax] == s)\n\
    \        return \"\";\n    // if LCP is larger than the string, return reversed\
    \ string\n    if (lcp[imax] > s)\n        return string.reverse;\n    // find\
    \ first LCP value that is smaller than previous one,\n    // the prefix of the\
    \ string up to this index will be the complement of the suffix\n    // example:\n\
    \    //     string: c a t a c\n    //             0 1 2 3 4\n    //     sufix\
    \ : a c a c t\n    //             0 1 2 3 4\n    //     lcp   : 0 1 1 0 0\n  \
    \  //     imax  : 2\n    //     i     : 1\n    //     complement is  \"ca\"\n\
    \    auto i = 0;\n    while (i < l-1 && lcp[i] >= lcp[i+1])\n        i++;\n  \
    \  // get the complementary string\n   ", "{\n    assert(string.length >= 0);\n\
    \    if (string.length <= 1)\n        return string;\n    \n    auto substring_length\
    \ = string.length;\n    for (; substring_length > 0; --substring_length) \n  \
    \  {\n        if (is_palindrome(string[0 .. substring_length]))\n            break;\n\
    \    }\n    assert(substring_length > 0);\n    return string ~ reverse(string[0\
    \ .. string.length - substring_length]);\n}", "{\n    auto is_palindrome = (string)\
    \ => \n    {\n        foreach (i, ch; string) \n        {\n            if (ch\
    \ != string[$ - i - 1]) \n            {\n                return false;\n     \
    \       }\n        }\n        return true;\n    };\n    foreach (i; 0 .. string.length)\
    \ \n    {\n        if (is_palindrome(string[i .. $])) \n        {\n          \
    \  return string ~ string[0 .. i];\n        }\n    }\n    return string;\n}\n\
    /*\n Find the longest palindrome in the string.\n    Algorithm idea is simple:\n\
    \    - Find the longest postfix of supplied string that is a palindrome.\n   \
    \ - Find the longest prefix of supplied string that is a palindrome.\n    - Return\
    \ the palindrome of maximum length.\n    >>> find_longest_palindrome(\"\")\n \
    \   \"\"\n    >>> find_longest_palindrome(\"ab\")\n    \"\"\n    >>> find_longest_palindrome(\"\
    a\")\n    \"a\"\n    >>> find_longest_palindrome(\"aba\")\n    \"aba\"\n    >>>\
    \ find_longest_palindrome(\"cat\")\n    \"a\"\n    >>> find_longest_palindrome(\"\
    catac\")\n    \"aca\"\n    >>> find_longest_palindrome(\"catatatg\")\n    \"atat\"\
    \n    >>> find_longest_palindrome(\"catatatgatatatg\")\n    \"atatatgatatat\"\n\
    */\nstring find_longest_palindrome(string string) \n{\n    enum bool is_palindrome(string\
    \ string) \n    {\n        foreach (i, ch; string) \n        {\n            if\
    \ (ch != string[$ - i - 1]) \n            {\n                return false;\n \
    \           }\n        }\n        return true;\n    }\n    foreach (i; 0 .. string.length)\
    \ \n    {\n        if (is_palindrome(string[i .. $])) \n        {\n          \
    \  foreach (j; 0 .. string.length - i) \n            {\n                if", "{\n\
    \    auto suffix = longest_palindromic_suffix(string);\n    auto prefix = reverse(string[0..$-suffix.length]);\n\
    \    return string ~ prefix;\n}", "{\n    auto k = size_t(0);\n    auto l = size_t(1);\n\
    \    auto r = size_t(1);\n    auto n = string.length;\n    while (r < n) {\n \
    \       if (string[r - l] == string[r]) {\n            ++r;\n            ++l;\n\
    \        } else {\n            k = max(k, l);\n            l = 1;\n          \
    \  ++r;\n        }\n    }\n    k = max(k, l);\n    return string + string[(k ..\
    \ n)].reverse;\n}", "{\n    return string ~ reverse(string[0 .. cast(int)(floor(string.length\
    \ / 2))]);\n}", "{\n    import std.algorithm : find, canFind;\n    import std.array\
    \ : reverse;\n    import std.range : zip;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.algorithm : equal;\n    import\
    \ std.algorithm : sort;\n    import std.conv : to;\n    string the_palindrome\
    \ = \"\";\n    if (string.length == 0)\n    {\n        return the_palindrome;\n\
    \    }\n    if (string.length == 1)\n    {\n        return string;\n    }\n  \
    \  string ret = string;\n    int i = 0;\n    int j = 0;\n    string the_prefix;\n\
    \    auto a = zip(string, string.reverse);\n    foreach (item; a)\n    {\n   \
    \     if (item[0] == item[1])\n        {\n            i++;\n        }\n      \
    \  else\n        {\n            break;\n        }\n    }\n    if (i == string.length)\n\
    \    {\n        return string;\n    }\n    // find the longest suffix that is\
    \ a palindrome\n    for (int k = string.length - 1; k >= 0; k--)\n    {\n    \
    \    if (string[0..i] == string[k..$].reverse)\n        {\n            j = k;\n\
    \            break;\n        }\n    }\n    if (j == 0)\n    {\n        return\
    \ string + string[i..$].reverse;\n    }\n    else\n    {\n        return string\
    \ + string[j..$].reverse;\n    }\n}", "{\n    foreach(i; 0 .. string.length +\
    \ 1)\n    {\n        auto start_reverse = string[0 .. i];\n        auto end_reverse\
    \ = string[i .. $];\n        if(is_palindrome(start_reverse) && end_reverse.length\
    \ >= 1) \n        {\n            return string ~ std.array.array(end_reverse).reverse.join;\n\
    \        }\n    }\n    throw new Exception(\"Cannot make palindrome from input\"\
    );\n}", "{\n\tint l = string.length;\n\tint fp = l;\n\tfor (int i = 0; i < l;\
    \ i++) {\n\t\tif (string[i] == string[l - 1]) {\n\t\t\tfp = i;\n\t\t}\n\t}\n\t\
    if (fp == l) {\n\t\treturn string;\n\t}\n\telse {\n\t\treturn string ~ string[fp..$-1].mirror;\n\
    \t}\n}", "{\n    // finding the longest postfix of supplied string that is a palindrome\n\
    \    immutable pos = maxElement(iota(0, string.length)\n        .map!((string)\
    \ { return is_palindrome(string); })\n        .array);\n    // appending to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix\n    // concatenating the rest of the string and reversing it\n    return\
    \ string ~ string[0..$-pos].idup.retro;\n}\n \n// helper functions", "{\n    auto\
    \ is_palindrome = (in string) \n    {\n        return string.equal!(string.idup.reverse);\n\
    \    };\n    auto is_prefix = (in string, in prefix) \n    {\n        return string.startsWith(prefix);\n\
    \    };\n    auto longest_palindrome_suffix_length = (in string) \n    {\n   \
    \     immutable n = string.length;\n        immutable midpoint = n / 2;\n    \
    \    immutable right_half = string[midpoint..$];\n        return right_half.canFind(string[0..midpoint].idup.reverse);\n\
    \    };\n    auto prefix_to_append = (in string) \n    {\n        immutable n\
    \ = string.length;\n        immutable longest_palindrome_suffix_length = string.longest_palindrome_suffix_length;\n\
    \        immutable longest_palindrome_suffix = string[n - longest_palindrome_suffix_length..$];\n\
    \        immutable prefix_to_append = string[0..(n - longest_palindrome_suffix_length)];\n\
    \        return prefix_to_append.idup.reverse;\n    };\n    auto append_string\
    \ = (in string, in prefix) \n    {\n        return string ~ prefix;\n    };\n\
    \    return make_palindrome(string);\n}", "{\n    // Find the longest palindromic\
    \ suffix\n    int[] z_function = zFunction(string);\n    int start = z_function.length\
    \ - z_function[z_function.length - 1];\n    return string ~ reverse(string[0 ..\
    \ start]);\n}\n/* \n zFunction is a function that finds the lengths of the longest\
    \ common prefixes of the string and each of its suffixes.\n    For example, for\
    \ string \"abcab\" it's `[0, 0, 3, 0, 5]` because:\n        There is no common\
    \ prefix for the string and it's first suffix.\n        There is no common prefix\
    \ for the string and it's second suffix.\n        There is a common prefix of\
    \ length 3 for the string and it's third suffix \"cab\".\n        There is no\
    \ common prefix for the string and it's fourth suffix.\n        There is a common\
    \ prefix of length 5 for the string and it's fifth suffix \"abcab\".\n    Algorithm\
    \ is quite efficient: O(n) time complexity.\n    >>> zFunction(\"abcab\")\n  \
    \  [0, 0, 3, 0, 5]\n    >>> zFunction(\"a\")\n    [1]\n    >>> zFunction(\"abacaba\"\
    )\n    [0, 0, 1, 0, 7, 0, 3, 0]\n*/", "{\n    auto result = appender!string();\n\
    \    result.data ~= string;\n    auto it = string.rfind(\"\");\n    if (it.empty)\
    \ \n    {\n        return string;\n    }\n    auto prefix = string[0..it.base];\n\
    \    prefix.reverse;\n    result.data ~= prefix;\n    return result.data;\n}\n\
    /*\n Find all the strings that can be formed from phone keypad number strings.\n\
    \    >>> get_possible_strings([\"123\"], [\"45\", \"6\"])\n    [\"ad\", \"ae\"\
    , \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n*/\nstring[] get_possible_strings(string[]\
    \ number_combinations)() \n{\n    auto result = appender!(string[])();\n    if\
    \ (number_combinations.empty) \n    {\n        return result.data;\n    }\n  \
    \  string[] first_combinations = get_char_combinations(number_combinations[0]);\n\
    \    if (number_combinations.length == 1) \n    {\n        return first_combinations;\n\
    \    }\n    auto other_combinations = get_possible_strings(number_combinations[1..$]);\n\
    \    foreach (first_combination; first_combinations) \n    {\n        foreach\
    \ (other_combination; other_combinations) \n        {\n            result.data\
    \ ~= first_combination ~ other_combination;\n        }\n    }\n    return result.data;\n\
    }\n/*\n Find all the characters that could be associated with a phone keypad digit\
    \ string.\n    >>> get_char_combinations(\"\")\n    [\"\"]\n    >>> get_char_combinations(\"\
    1\")\n    [\"1\"]\n    >>> get_char_combinations(\"2\")\n    [\"a\", \"b\", \"\
    c\"]\n    >>> get_char_combinations(\"12\")\n    [\"1a\", \"1b\", \"1c\", \"2a\"\
    , \"2b\", \"2c\"]\n*/\nstring[] get_char_combinations(string number_combination)()\
    \ \n{\n    auto result = appender!(string[])();\n    if", "{\n    static assert(isSomeString!string);\n\
    \    static assert(!is(string == wstring));", "{\n    static string default_palindrome;\n\
    \    if (string.empty) \n    {\n        return default_palindrome;\n    }\n  \
    \  string::iterator start = string.begin();\n    string::iterator end = string.end();\n\
    \    string::iterator middle = start + distance(start, end) / 2;\n    if (distance(start,\
    \ end) % 2 == 0) \n    {\n        middle = prev(middle);\n    }\n    for (; middle\
    \ != start - 1; --middle) \n    {\n        if (equal(middle, end, start)) \n \
    \       {\n            break;\n        }\n    }\n    return string + reverse(string[start..=middle]);\n\
    }\nstatic assert(make_palindrome(\"\") == \"\");\nstatic assert(make_palindrome(\"\
    cata\") == \"catac\");\nstatic assert(make_palindrome(\"cat\") == \"catac\");\n\
    static assert(make_palindrome(\"xyz\") == \"xyzzyx\");\nstatic assert(make_palindrome(\"\
    abac\") == \"abacaba\");\nstatic assert(make_palindrome(\"racecar\") == \"racecar\"\
    );\nstatic assert(make_palindrome(\"abcdefghijklmnopqrstuvwxyz\") == \"abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba\"\
    );\nstatic assert(make_palindrome(\"abcdefghijklmnopqrstuvwxyz0123456789\") ==\
    \ \"abcdefghijklmnopqrstuvwxyz01234567899876543210zyxwvutsrqponmlkjihgfedcba\"\
    );\nstatic assert(make_palindrome(\"abcdefghijklmnopqrstuvwxyz0123456789/\") ==\
    \ \"abcdefghijklmnopqrstuvwxyz0123456789/9876543210zyxwvutsrqponmlkjihgfedcba\"\
    );\nstatic assert(make_palindrome(\"abcdefghijklmnopqrstuvwxyz0123456789.abcdefghijklmnopq",
  "{\n    // Find the longest postfix that is a palindrome.\n    size_t pos = 0;\n\
    \    while (pos != string.length) \n    {\n        // Check if string[pos:] is\
    \ a palindrome.\n        auto [is_palindrome, length] = is_palindrome_at(string,\
    \ pos);\n        if (is_palindrome) \n        {\n            break;\n        }\n\
    \        pos += length;\n    }\n    // Append reverse of a string prefix.\n  \
    \  return string ~ string[0..$-pos].idup.idup.mirror;\n}", "{\n\tauto length =\
    \ string.length;\n\tif (length < 2) return string;", "{\n    auto palindrome_len\
    \ = string.length;\n    for (int end = string.length; end >= 0; --end) \n    {\n\
    \        if (string[0 .. end] == string[end .. $].dup.retro) \n        {\n   \
    \         palindrome_len = end;\n            break;\n        }\n    }\n    auto\
    \ palindrome_prefix = string[0 .. palindrome_len];\n    auto reverse_prefix =\
    \ string[palindrome_len .. $].dup.retro;\n    return string ~ reverse_prefix;\n\
    }\n ", "{\n    auto v = string.dup;\n    string prefix, suffix;\n    string.palindrome_suffix(prefix,\
    \ suffix);\n    v ~= prefix.reverse;\n    return v;\n}\n/*\n Find the longest\
    \ palindromic suffix and its corresponding prefix.\n    >>> \"\".palindrome_suffix()\n\
    \    \"\"\n    >>> \"cat\".palindrome_suffix()\n    \"c\"\n    >>> \"cata\".palindrome_suffix()\n\
    \    \"ata\"\n*/\nstring palindrome_suffix(string)(ref string string) \n{\n  \
    \  auto v = string.dup;\n    string prefix, suffix;\n    string.palindrome_suffix(prefix,\
    \ suffix);\n    return suffix;\n}", "{\n    auto make_palindrome_aux(string string,\
    \ size_t i, size_t j) {\n        if (i >= j)\n            return i - j;\n    \
    \    auto offset = make_palindrome_aux(string, i + 1, j - 1);\n        if (string[i]\
    \ == string[j])\n            return offset;\n        return j - i + offset;\n\
    \    }\n    if (string.empty)\n        return string;\n    auto offset = make_palindrome_aux(string,\
    \ 0, string.length - 1);\n    return string ~ string[0..offset].idup.reversed;\n\
    }", "{\n\tstatic assert(is(ElementType!(string) == dchar));\n\tstring palindrome\
    \ = string ~ reverse(string[0 .. min(find_palindrome_suffix(string), length(string))]);\n\
    \treturn palindrome;\n}", "{\n    if (string.empty)\n        return string;\n\
    \    auto rev_string = string.retro;\n    auto postfix = rev_string.indexOf(string);\n\
    \    if (postfix == -1)\n        return string ~ rev_string;\n    return string\
    \ ~ string[0..$-postfix].retro;\n}", "{\n    auto len = string.length;\n    if\
    \ (len < 2) \n    {\n        return string;\n    }\n    auto idx = len;\n    while\
    \ (idx > 0) \n    {\n        auto temp = string[0 .. idx];\n        if (temp ==\
    \ temp.reverse) \n        {\n            break;\n        }\n        idx--;\n \
    \   }\n    if (idx == len) \n    {\n        return string;\n    }\n    return\
    \ string ~ string[(len - idx) .. $].reverse;\n}", "{\n    auto suffix = palindromic_suffix(string);\n\
    \    // Look for the prefix that comes before the palindromic suffix\n    auto\
    \ prefix = string[0..$-suffix.length];\n    return string ~ reverse(prefix);\n\
    }", "{\n    //base case\n    if (string.length == 0) \n    {\n        return \"\
    \";\n    }\n    auto prefix = \"\";\n    auto suffix = \"\";\n    if (is_palindrome(string))\
    \ \n    {\n        return string;\n    }\n    for (size_t i = 0; i < string.length;\
    \ i++) \n    {\n        prefix ~= string[i];\n        suffix = string[i .. $]\
    \ ~ suffix;\n        if (prefix == suffix) \n        {\n            return prefix\
    \ ~ make_palindrome(string[prefix.length .. $ - suffix.length]);\n        }\n\
    \    }\n    return string;\n}", "{\n    auto maybe_postfix = longest_palindromic_suffix(string);\n\
    \    if(maybe_postfix.isSome) \n    {\n        return string ~ maybe_postfix.get\
    \ ~ reverse(string[0..$-maybe_postfix.get.length]);\n    }\n    else \n    {\n\
    \        return string ~ reverse(string);\n    }\n}\n// void main()\n// {\n//\
    \     // auto s = \"aacecaaa\";\n//     // auto size = s.length;\n//     // auto\
    \ z = longest_palindromic_suffix(s);\n//     // if(z.isSome)\n//     // {\n//\
    \     //     writeln(s);\n//     //     writeln(s[0..(size-z.get.length)]);\n\
    //     //     writeln(reverse(s[0..(size-z.get.length)]));\n//     //     writeln(make_palindrome(s));\n\
    //     // }\n//     writeln(make_palindrome(\"cata\"));\n// }", "{\n    // find\
    \ the longest palindromic suffix\n    int m = string.length;\n    if (m == 0)\
    \ \n    {\n        return \"\";\n    }\n    int start = m;\n    for (int i = 0;\
    \ i < m - 1; i++) \n    {\n        if (string[i] == string[m - 1]) \n        {\n\
    \            start = i;\n            break;\n        }\n    }\n    // append the\
    \ reverse of the prefix that precedes the palindromic suffix\n    string result\
    \ = string[0 .. start] ~ string[start .. $].reverse;\n    return result;\n}",
  "{\n    // Manacher's Algorithm\n    string processed_string;\n    foreach(i, item;\
    \ string) \n    {\n        processed_string ~= '^';\n        processed_string\
    \ ~= item;\n        processed_string ~= '#';\n    }\n    processed_string ~= '$';\n\
    \    int n = processed_string.length;\n    int[] palindrome_length = new int[n];\n\
    \    int c = 0, r = 0;\n    for(int i = 1; i < n - 1; i++) \n    {\n        int\
    \ i_mirror = 2 * c - i;\n        palindrome_length[i] = (r > i) ? min(r - i, palindrome_length[i_mirror])\
    \ : 0;\n        while(processed_string[i + 1 + palindrome_length[i]] == processed_string[i\
    \ - 1 - palindrome_length[i]]) \n        {\n            palindrome_length[i]++;\n\
    \        }\n        if(i + palindrome_length[i] > r) \n        {\n           \
    \ c = i;\n            r = i + palindrome_length[i];\n        }\n    }\n    c =\
    \ 0;\n    r = 1;\n    for(int i = 1; i < n - 1; i++) \n    {\n        if(palindrome_length[i]\
    \ > r) \n        {\n            c = i;\n            r = palindrome_length[i];\n\
    \        }\n    }\n    string prefix;\n    foreach(i, item; string[0 .. c / 2\
    \ - 1]) \n    {\n        prefix ~= item;\n    }\n    string postfix;\n    foreach(i,\
    \ item; string[c / 2 + r / 2 .. $]) \n    {\n        postfix ~= item;\n    }\n\
    \    return postfix ~ string ~ reverse(prefix);\n}", "{\n    string tmp = string;\n\
    \    auto postfix_size = string.length;\n    while(postfix_size > 0) \n    {\n\
    \        if(is_palindrome(tmp[0 .. postfix_size])) \n        {\n            return\
    \ string ~ reverse(string[0 .. string.length - postfix_size]);\n        }\n  \
    \      else \n        {\n            --postfix_size;\n        }\n    }\n    return\
    \ string;\n}\n/*\n/// Tests\nunittest \n{\n    assert(make_palindrome(\"\") ==\
    \ \"\");\n    assert(make_palindrome(\"cat\") == \"catac\");\n    assert(make_palindrome(\"\
    cata\") == \"catac\");\n}\n*/", "{\n    string_builder sb = new string_builder();\n\
    \    int n = string.length;\n    int i = 0;\n    while (i < n) {\n        int\
    \ j = n;\n        while (j > i) {\n            if (string[i..j] == string[j..i].idup)\
    \ {\n                sb.append(string[i..j]);\n                i = j;\n      \
    \          break;\n            }\n            j--;\n        }\n        if (j ==\
    \ i) {\n            sb.append(string[i]);\n            i++;\n        }\n    }\n\
    \    return sb.data;\n}\n// Low level function for computing the minimum number\
    \ of palindromic\n// decompositions.", "{\n    string reversed_prefix = string[0..$-max(string.min(1),\
    \ longest_common_prefix(string, reverse(string)))];\n    return string ~ reverse(reversed_prefix);\n\
    }", "{\n    auto index = string.length - 1;\n    while (index > 0) \n    {\n \
    \       if (string[0 .. index] == string[$-index .. $]) \n        {\n        \
    \    return string ~ string[$-index .. $-1].reverse;\n        }\n        index--;\n\
    \    }\n    return string ~ string.reverse;\n}\n/*\n Check if a string is a palindrome.\n\
    \    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"a\")\n    true\n\
    \    >>> is_palindrome(\"ab\")\n    false\n    >>> is_palindrome(\"aba\")\n  \
    \  true\n    >>> is_palindrome(\"abba\")\n    true\n*/", "{\n\tstring rev = string.idup.reverse;\n\
    \tint i = string.findLast(rev);\n\tif (i == -1) \n\t{\n\t\treturn string.idup\
    \ ~ rev;\n\t}\n\telse \n\t{\n\t\tstring z = rev[i + string.length .. $];\n\t\t\
    return string.idup ~ z ~ string[0 .. string.length - i - 1];\n\t}\n}\n/*\n Find\
    \ the longest palindromic substring.\n    Algorithm idea is simple:\n    - For\
    \ each character of the string check for the longest palindrome centered at that\
    \ character.\n    - Consider two cases:\n    - Palindrome can have even length,\
    \ in that case its centered on two characters\n    - Palindrome can have odd length,\
    \ in that case it is centered on one character\n    >>> palindrome(\"\")\n   \
    \ \"\"\n    >>> palindrome(\"c\")\n    \"c\"\n    >>> palindrome(\"cc\")\n   \
    \ \"cc\"\n    >>> palindrome(\"bb\")\n    \"bb\"\n    >>> palindrome(\"aba\")\n\
    \    \"aba\"\n    >>> palindrome(\"abba\")\n    \"abba\"\n    >>> palindrome(\"\
    catac\")\n    \"cata\"\n    >>> palindrome(\"catacac\")\n    \"catac\"\n    >>>\
    \ palindrome(\"catacaca\")\n    \"catacaca\"\n    >>> palindrome(\"acaca\")\n\
    \    \"acaca\"\n    >>> palindrome(\"acacac\")\n    \"acaca\"\n    >>> palindrome(\"\
    acacaca\")\n    \"acacaca\"\n*/\nstring palindrome(string string) \n{\n\tint longest\
    \ = 0;\n\tint i = 0;\n\tint l;\n\tint start;\n\tint end;\n\twhile (i < string.length)\
    \ \n\t{\n\t\t// The palindrome can be of odd length (centered on one character)\n\
    \t\t// Find the longest palindrome centered on the current character\n\t\tl =\
    \ 1;\n\t\tstart = i - 1;\n\t\tend = i + 1;\n\t\twhile (start >= 0 && end < string.length\
    \ && string[start] == string", "    in\n    {\n    }\n    body\n    {\n    return\
    \ \"\";\n    }\n    out\n    (\n    )\n{\n}", "    in\n    {\n    assert(string.length\
    \ <= 9999);\n    }\n    body\n    {\n    auto leng = string.length;\n    if (leng\
    \ == 0)\n        return \"\";\n    if (leng == 1)\n        return string[0 ..\
    \ 1] ~ string[0 .. 1];\n    static if (is(typeof(string[0]) == dchar))\n    {\n\
    \        auto lstring = string.toLower;\n        string[0 .. $] = lstring[0 ..\
    \ $];\n    }\n    size_t radius[string.length];\n    size_t c = 0;\n    size_t\
    \ r = 0;\n    size_t i = 0;\n    while (i < string.length)\n    {\n        if\
    \ (i <= r)\n            radius[i] = min(r - i, radius[2 * c - i]);\n        else\n\
    \            radius[i] = 0;\n        while (i + radius[i] + 1 < string.length\
    \ && i - radius[i] - 1 >= 0)\n        {\n            if (string[i + radius[i]\
    \ + 1] == string[i - radius[i] - 1])\n                radius[i]++;\n         \
    \   else\n                break;\n        }\n        if (i + radius[i] > r)\n\
    \        {\n            c = i;\n            r = i + radius[i];\n        }\n  \
    \      i++;\n    }\n    size_t maxi = 0;\n    for (size_t i = 1; i < string.length;\
    \ i++)\n    {\n        if (radius[i] > radius[maxi])\n            maxi = i;\n\
    \    }\n    string rev = string[0 .. $ - radius[maxi] - 1].idup.idup.idup.reverse;\n\
    \    return string ~ rev;\n    }\nunittest\n{\n    static assert(make_palindrome(\"\
    \") == \"\");\n    static assert(make_palindrome(\"cat\") == \"catac\");\n   \
    \ static assert(make_palindrome(\"cata\") == \"catac\");\n    static assert(make_palindrome(\"\
    cac\") == \"cac\");\n    static assert(", "{\n    if (string.empty) return string;\n\
    \    size_t[2] palindrome = [-1,0];\n    for (int i = 0; i < string.length; i++)\
    \ \n    {\n        int j = 0;\n        while(j < min(i+1, string.length-i)) \n\
    \        {\n            if (string[i-j] != string[i+j]) break;\n            j++;\n\
    \        }\n        if (j*2 > palindrome[1]) palindrome = [i-j+1, j*2];\n    }\n\
    \    return string[0..palindrome[0]] ~ string.reverse;\n}\n//A function that generates\
    \ the longest prefix that is a palindrome.\nTuple!(string, size_t, size_t) longest_palindrome_prefix(string\
    \ string) \n{\n    if (string.empty) return tuple(\"\",0,0);\n    if (string.length\
    \ == 1) return tuple(string,0,1);\n    size_t[2] palindrome = [-1,0];\n    for\
    \ (int i = 0; i < string.length; i++) \n    {\n        int j = 0;\n        while(j\
    \ < min(i+1, string.length-i)) \n        {\n            if (string[i-j] != string[i+j])\
    \ break;\n            j++;\n        }\n        if (j*2 > palindrome[1]) palindrome\
    \ = [i-j+1, j*2];\n    }\n    return tuple(string[0..palindrome[0]], palindrome[0],\
    \ palindrome[1]);\n}", "{\n    if(string.length == 0)\n    {\n        return \"\
    \";\n    }\n    else\n    {\n        return make_palindrome_string(string);\n\
    \    }\n}\nstring make_palindrome_string(string string) \n{\n    string str_reversed\
    \ = string[$-1..$].dup.reverse;\n    string res = string ~ str_reversed;\n   \
    \ if(res.length == string.length)\n    {\n        return res;\n    }\n    else\n\
    \    {\n        return make_palindrome_string(string[0..$-1]);\n    }\n}\n/*\n\
    \    - Find the longest prefix of supplied string that is a palindrome.\n    -\
    \ Prepend to the beginning of the string reverse of a string suffix that comes\
    \ after the palindromic prefix.\n    >>> make_palindrome_reversed(\"\")\n    \"\
    \"\n    >>> make_palindrome_reversed(\"cat\")\n    \"tacat\"\n    >>> make_palindrome_reversed(\"\
    cata\")\n    \"tacat\"\n*/\nstring make_palindrome_reversed(string string) \n\
    {\n    if(string.length == 0)\n    {\n        return \"\";\n    }\n    else\n\
    \    {\n        return make_palindrome_reversed_string(string);\n    }\n}\nstring\
    \ make_palindrome_reversed_string(string string) \n{\n    string str_reversed\
    \ = string[0..$-1].dup.reverse;\n    string res = str_reversed ~ string;\n   \
    \ if(res.length == string.length)\n    {\n        return res;\n    }\n    else\n\
    \    {\n        return make_palindrome_reversed_string(string[1..$]);\n    }\n\
    }\n/*\n    >>> make_palindrome_by_suffix(\"\")\n    \"\"\n    >>> make_palindrome_by_suffix(\"\
    cat\")\n    \"catac\"\n    >>> make_palindrome_by_suffix(\"cata\")\n    \"catac\"\
    \n*/\nstring make_palindrome_", "{\n    int i = 0;\n    int j = string.length\
    \ - 1;\n    while(i < j) \n    {\n        if(string[i] != string[j]) \n      \
    \  {\n            return string.dup[0..i].idup.reverse ~ string;\n        }\n\
    \        ++i;\n        --j;\n    }\n    return string;\n}", "{ \n\tstring reversed_string\
    \ = string.dup.idup.reverse;\n\t// check if the reversed prefix is the postfix\
    \ of the string \n\tint string_length = string.length;\n\tint prefix_end = 0;\n\
    \tforeach(size_t i, char c; string)\n\t{\n\t\tauto reversed_string_slice = reversed_string[0..$-i];\n\
    \t\tauto string_slice = string[i..$];\n\t\tif(reversed_string_slice == string_slice)\n\
    \t\t{\n\t\t\tprefix_end = i;\n\t\t\tbreak;\n\t\t}\n\t}", "{\n    auto original_str_len\
    \ = string.length;\n    string reversed_string = string.dup.reverse;\n    auto\
    \ result = string ~ reversed_string[$ - (original_str_len + 1) .. $];\n    //say\
    \ result;\n    //result.length;\n    if(result.length == original_str_len)\n \
    \   {\n        return result;\n    }\n    else\n    {\n        auto substring\
    \ = result[0 .. (floor(result.length/2))];\n        //say substring;\n       \
    \ if(substring == result[$ - (floor(result.length/2)) .. $])\n        {\n    \
    \        return result;\n        }\n        else\n        {\n            return\
    \ make_palindrome(substring);\n        }\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
