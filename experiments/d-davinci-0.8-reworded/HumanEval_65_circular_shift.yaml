name: HumanEval_65_circular_shift
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nCircular shift the digits of\
  \ the integer x, shift the digits right by shift\n    and return the result as a\
  \ string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12L,\
  \ 1L)\n    \"21\"\n    >>> circular_shift(12L, 2L)\n    \"12\"\n    \n*/\nstring\
  \ circular_shift(long x, long shift) \n"
tests: "unittest\n{\n    alias candidate = circular_shift;\n\n    assert(candidate(100L,\
  \ 2L) == \"001\");\n    assert(candidate(12L, 2L) == \"12\");\n    assert(candidate(97L,\
  \ 8L) == \"79\");\n    assert(candidate(12L, 1L) == \"21\");\n    assert(candidate(11L,\
  \ 101L) == \"11\");\n}\nvoid main(){}"
completions: ["{\n  string result = \"\";\n  string str_x = to!string(x);\n  int len\
    \ = str_x.length;\n  if (shift >= len)\n  {\n    for (int i = len-1; i >= 0; i--)\n\
    \    {\n      result ~= str_x[i];\n    }\n  }\n  else\n  {\n    string prefix\
    \ = str_x[len-shift..$];\n    string suffix = str_x[0..len-shift-1];\n    result\
    \ = prefix ~ suffix;\n  }\n  return result;\n}\n/*\n    Helper function: checks\
    \ if the ith place of the number x is odd. \n    Positions are numbered right\
    \ to left.\n    >>> is_odd(12L, 1L)\n    false\n    >>> is_odd(12L, 2L)\n    true\n\
    \    >>> is_odd(12L, 3L)\n    false\n    >>> is_odd(12345L, 5L)\n    true\n*/",
  "{\n\tconst long number_of_digits = log10(x);", "{\n    string result;\n    string\
    \ tmp = to!string(x);\n    int length = tmp.length;\n    if (shift > length) \n\
    \    {\n        tmp = tmp.dup.reverse;\n        return tmp;\n    } \n    else\n\
    \    {\n        for (int i = 0; i < length; i++) \n        {\n            if (i\
    \ + shift > length) \n            {\n                int index = i + shift - length;\n\
    \                result ~= tmp[index];\n            } \n            else\n   \
    \         {\n                result ~= tmp[i + shift];\n            }\n      \
    \  }\n        return result;\n    }\n}", "{\n    assert(shift >= 0);\n    auto\
    \ digits = to!string(x);\n    if (shift >= digits.length) {\n        return digits.reversed;\n\
    \    }\n    return digits[shift .. $].idup ~ digits[0 .. shift].idup;\n}\n/*\n\
    Take the string str, split on spaces and sort lexicographically.\nReturn a tuple\
    \ of the sorted version, str, and the sorted version joined\n    by spaces.\n\
    */\nstatic Tuple!(string, string, string) sort_with_original(string str) \n{\n\
    \    string[] sort_str = str.split.sort;\n    return tuple(sort_str.joined(\"\
    \ \"), str, sort_str.joined(\" \"));\n}\n/*\nTake the integer x and return its\
    \ prime factors as a tuple.\nFactorization is returned as a tuple of tuples with\
    \ the prime number and\n    its power.\n>>> prime_factors(18L)\n((2L, 1L), (3L,\
    \ 2L))\n*/\nTuple!(Tuple!(long, long)) prime_factors(long x) \n{\n    long denom\
    \ = 2L;\n    long idx = 0L;\n    Tuple!(Tuple!(long, long)) factors = new Tuple!(Tuple!(long,\
    \ long))();\n    while (x > 1L) {\n        if (x % denom == 0L) {\n          \
    \  x /= denom;\n            if (idx > 0L && factors[idx-1].field[0] == denom)\
    \ {\n                auto temp = new Tuple!(long, long)(denom, factors[idx-1].field[1]\
    \ + 1L);\n                factors[idx-1] = temp;\n            } else {\n     \
    \           auto temp = new Tuple!(long, long)(denom, 1L);\n                factors[idx]\
    \ = temp;\n                idx++;\n            }\n        } else {\n         \
    \   denom++;\n        }\n    }\n    return factors;\n}\n/*\nReturn the harmonic\
    \ mean of the sequence seq.\n>>> harmonic_mean([1L, 2L, 3L])\n1.6363636363636365\n",
  "{\n    import std.algorithm;\n    import std.conv;\n    import std.range;\n   \
    \ auto str = x.to!string;\n    if (shift > str.length)\n        return str.retro;\n\
    \    return (str[shift .. $] ~ str[0 .. shift]).idup;\n}", "{\n    string s =\
    \ to!string(x);\n    shift %= s.length;\n    if (shift == 0) return s;\n    s\
    \ = s[shift .. $] ~ s[0 .. shift];\n    return s;\n}", "{\n    auto result = to!string(x);\n\
    \    if (shift < result.length) \n    {\n        result = result[$-shift .. $]\
    \ ~ result[0 .. $-shift];\n    } \n    else \n    {\n        result = result[$\
    \ .. 0];\n    }\n    return result;\n}", "{\n    enum x_digits = max(1, log10(abs(x))\
    \ + 1);\n    long x_shifted = x;\n    shift %= x_digits;\n    if (shift != 0)\n\
    \    {\n        x_shifted = ((long) x / (long) pow(10, shift))\n             \
    \   + (x % (long) pow(10, shift)) * (long) pow(10, x_digits - shift);\n    }\n\
    \    return format(\"%s\", x_shifted);\n}\n/*\n    Do all the steps to get the\
    \ solution.\n    The tricky part is finding the first number that works.\n   \
    \ Since the digits of the sequence will get smaller we start from the\n    largest\
    \ possible number and work our way down.\n    It is not hard to show that the\
    \ first number should be the number of\n    digits squared.\n    The second number\
    \ should be one less than the first number.\n    >>> solve(12L)\n    1234526\n\
    */\nstring solve(long digits)\n{\n    enum first_number = pow(digits, 2);\n  \
    \  for (long second_number = first_number - 1;\n            second_number >= digits;\n\
    \            second_number--)\n    {\n        long number = first_number;\n  \
    \      string sequence = circular_shift(number, second_number);\n        long\
    \ next_number = to!long(sequence);\n        while (next_number != first_number)\n\
    \        {\n            if (next_number < number)\n            {\n           \
    \     break;\n            }\n            number = next_number;\n            sequence\
    \ ~= circular_shift(number, second_number);\n            next_number = to!long(sequence);\n\
    \        }\n        if (next_number == first_number)\n        {\n            return\
    \ sequence;\n        }\n    }\n    return \"\";\n}", "{\n    auto digits = to!string(x);\n\
    \    if (shift >= digits.length) {\n        return digits.reverse;\n    }\n  \
    \  auto suffix = digits[$ - shift .. $];\n    return format(\"%s%s\", suffix,\
    \ digits[0 .. $ - shift]);\n}\n/*\nReturn the element i of sequence s.\n    If\
    \ i is out of range, return a none.\n    >>> at(iota(1L, 10L), 4L)\n    Some(5L)\n\
    \    >>> at(iota(1L, 10L), 10L)\n    None\n*/\nauto at(T)(T s, long i)\nif (isInputRange!T\
    \ && is(typeof(front(s)) == long))\n{\n    if (i < 0)\n        return none;\n\
    \    auto result = front(s);\n    for (i -= 1; i >= 0; i -= 1) {\n        if (!empty(s))\
    \ {\n            result = front(s);\n            popFront(s);\n        } else\
    \ {\n            return none;\n        }\n    }\n    return some(result);\n}\n\
    /*\nMultiply the given 2*2 matrix a by the given 2*2 matrix b\n    >>> matrix_multiply([[1L,\
    \ 2L], [3L, 4L]], [[5L, 6L], [7L, 8L]])\n    [[19L, 22L], [43L, 50L]]\n*/\nlong[][]\
    \ matrix_multiply(long[][] a, long[][] b) \n{\n    return [a[0][0] * b[0][0] +\
    \ a[0][1] * b[1][0],\n            a[0][0] * b[0][1] + a[0][1] * b[1][1],\n   \
    \         a[1][0] * b[0][0] + a[1][1] * b[1][0],\n            a[1][0] * b[0][1]\
    \ + a[1][1] * b[1][1]];\n}\n/*\nConvert the given integer x to a string in any\
    \ base\n    >>> to_base(123L,", "{\n    string s = to!string(x);\n    long n =\
    \ s.length;\n    if (shift > n) \n    {\n        char[] result = to!(char[])(s);\n\
    \        result.reverse;\n        return to!string(result);\n    }\n    return\
    \ s[shift..n] ~ s[0..shift];\n}\n/*\nDecode a circular shift.\n    >>> circular_shift_decode(12L,\
    \ \"21\")\n    1L\n    >>> circular_shift_decode(12L, \"12\")\n    2L\n*/\nlong\
    \ circular_shift_decode(long x, string s) \n{\n    return to!long(circular_shift(x,\
    \ s.length - to!long(s)));\n}\n/*\nEncode a message using a code.\n    >>> code\
    \ = [10L, 11L, 12L, 13L, 14L, 15L, 16L, 17L, 18L, 19L, 20L, 21L, 22L, 23L, 24L,\
    \ 25L, 26L, 27L, 28L, 29L, 30L, 31L, 32L, 33L, 34L, 35L, 36L, 37L, 38L, 39L, 40L,\
    \ 41L, 42L, 43L, 44L, 45L, 46L, 47L, 48L, 49L, 50L, 51L, 52L, 53L, 54L, 55L, 56L,\
    \ 57L, 58L, 59L, 60L, 61L, 62L, 63L, 64L, 65L, 66L, 67L, 68L, 69L, 70L, 71L, 72L,\
    \ 73L, 74L, 75L, 76L, 77L, 78L, 79L, 80L, 81L, 82L, 83L, 84L, 85L, 86L, 87L, 88L,\
    \ 89L, 90L, 91L, 92L, 93L, 94L, 95L, 96L, 97L, 98L, 99L, 100L, 101L, 102L, 103L,\
    \ 104L, 105L, 106L, 107L, 108L, 109L, 110L, 111L, 112L, 113L, 114L,", "pure nothrow\
    \ @safe @nogc { \n    alias Digits = Tuple!(char, \"0\", \"1\", \"2\", \"3\",\
    \ \"4\", \"5\", \"6\", \"7\", \"8\", \"9\");\n    if (shift == 0)\n        return\
    \ x.text;\n    string s = x.text;\n    if (shift > s.length) {\n        reverse(s);\n\
    \        return s;\n    }\n    auto first = s[0 .. $ - shift];\n    auto last\
    \ = s[$ - shift .. $];\n    return last ~ first;\n}", "{\n    string digits =\
    \ to!string(x);\n    long len = digits.length;\n    shift %= len;\n    if (shift\
    \ == 0) \n    {\n        return digits;\n    }\n    if (shift > len) \n    {\n\
    \        return digits[$ - 1 .. $];\n    }\n    return digits[shift .. $] ~ digits[0\
    \ .. shift - 1];\n}\n/*\nPowers of 10 returned as strings rather than longs.",
  "{\n    // Shift value must be positive.\n    shift = shift % digits(x);\n    long\
    \ n_reversed = reverse(x);\n    long n_shifted = n_reversed / pow(10L, shift);\n\
    \    return to!string(n_shifted);\n}", "{\n    if (x < 0L)\n    {\n        x =\
    \ -x;\n    }\n    long len = 1L;\n    long x1 = x;\n    while (x1 >= 10L)\n  \
    \  {\n        x1 /= 10L;\n        len *= 10L;\n    }\n    long y = x;\n    long\
    \ z = 0L;\n    long pow10 = 1L;\n    for (long i = 0L; i < shift; i++)\n    {\n\
    \        long mod = y % 10L;\n        y /= 10L;\n        z += mod * len;\n   \
    \     len /= 10L;\n    }\n    z += y;\n    return to!string(z);\n}", "{\n    //\
    \ calculate the number of digits\n    long number_of_digits = cast(long) x.stringof.length;\n\
    \    return x.rotateRight(shift).format(\"%0\" ~ number_of_digits.stringof ~ \"\
    d\");\n}\n/*\nGiven an array of strings return a map of the strings to the\n \
    \   number of times they occur.\n    >>> count_occurrences([\"a\", \"b\", \"a\"\
    , \"c\", \"b\"])\n    [\"a\": 2, \"b\": 2, \"c\": 1]\n    \n*/\nMap!(string,long)\
    \ count_occurrences(string[] arr) \n{\n    Map!(string,long) map = [];\n    for\
    \ (string s ; arr) \n    {\n        map[s] = (map[s] is null) ? 1 : map[s] + 1;\n\
    \    }\n    return map;\n}\n/*\nGiven a string return true if it is composed only\
    \ of digits.\n    >>> only_digits(\"123\")\n    true\n    >>> only_digits(\"123a\"\
    )\n    false\n    \n*/", "{\n    int length = to!string(x).length;\n    if (shift\
    \ > length)\n    {\n        return to!string(x)[$-1:-1:-1];\n    }\n    else\n\
    \    {\n        auto a = to!string(x)[$-1:-1:-length+shift];\n        auto b =\
    \ to!string(x)[$-1:-1-length+shift:-1];\n        return a ~ b;\n    }\n}", "{\n\
    \    string result = \"\";\n    string cur = to!string(x);\n    int length = cur.length;\n\
    \    int pos = shift % length;\n    if (pos != 0)\n    {\n        result = cur[pos..$];\n\
    \        result ~= cur[0..pos];\n    }\n    else\n    {\n        result = cur;\n\
    \    }\n    return result;\n}", "{\n    long l = x.length;\n    int s = shift.to!int;\n\
    \    auto result = new string[l];\n    if (s < l) \n    {\n        result = x.to!string.dup[0..s].dup;\n\
    \        result ~= x.to!string.dup[s..$];\n    }\n    else \n    {\n        result\
    \ = x.to!string.dup.dup;\n        result.reverse;\n    }\n    return result;\n\
    }", "{\n    enum shift_type = shift > numDigits(x);\n    return to!string(shift_type\
    \ ? iota(shift).map!(a => x[a]).reverse : iota(shift).map!(a => x[a]));\n}\n/*\n\
    Return the reversal of the digits of the integer x.\n    >>> reverse(123L)\n \
    \   \"321\"\n*/\nstring reverse(long x) \n{\n    return to!string(iota(numDigits(x)).map!(a\
    \ => x[a]).reverse);\n}\n/*\nReturn the value of the digits of the integer x rotated\
    \ left by the number\n    of digits of x.\n    >>> rotate_left(123L)\n    \"2341\"\
    \n    >>> rotate_left(321L)\n    \"1234\"\n*/\nstring rotate_left(long x) \n{\n\
    \    return to!string(iota(numDigits(x)).map!(a => x[a]).rotateLeft);\n}\n/*\n\
    Return the value of the digits of the integer x rotated right by the number\n\
    \    of digits of x.\n    >>> rotate_right(123L)\n    \"4321\"\n    >>> rotate_right(321L)\n\
    \    \"4321\"\n*/\nstring rotate_right(long x) \n{\n    return to!string(iota(numDigits(x)).map!(a\
    \ => x[a]).rotateRight);\n}\n/*\nReturn True if the integer x is a prime number,\
    \ False otherwise.\n    >>> isprime(17L)\n    True\n    >>> isprime(18L)\n   \
    \ False\n*/", "{\n    assert(x >= 0L);\n    assert(shift >= 0L);\n    long n =\
    \ number_of_digits(x);\n    shift %= n;\n    string s = to!string(x);\n    return\
    \ s[$-shift..$] ~ s[0..$-shift-1];\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
