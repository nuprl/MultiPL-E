name: HumanEval_120_maximum
language: d
prompt: "import std.math;\n/*\n\n    Given an array arr of integers and a positive\
  \ integer k, return a sorted array \n    of length k with the maximum k numbers\
  \ in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L,\
  \ 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n\
  \    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\
  \n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n\
  \        2. The elements in the array will be in the range of [-1000, 1000].\n \
  \       3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n"
tests: "unittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L,\
  \ -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) ==\
  \ [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n\
  \    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n\
  \    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n\
  \    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L,\
  \ 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L,\
  \ 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L,\
  \ -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n\
  \    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid\
  \ main(){}"
completions: ["{\n    immutable int N = arr.length;\n    assert(k > 0 && k <= N);\n\
    \    long[] temp = arr[0..$ - k];\n    std.algorithm.sort(temp);\n    for (int\
    \ i = N - k; i < N; i++)\n    {\n        if (arr[i] > temp[0])\n        {\n  \
    \          temp[0] = arr[i];\n            std.algorithm.sort(temp);\n        }\n\
    \    }\n    return temp;\n}", "{\n    if (k == 0)\n        return [].array();\n\
    \    auto arr_s = sort(arr);\n    auto result = new long[k];\n    foreach (i,\
    \ element; arr_s[$ - k .. $])\n        result[i] = element;\n    return result;\n\
    }", "{\n    auto n = arr.length;\n    auto maxHeap = new max_heap_long;\n    auto\
    \ i = 0L;\n    auto result = new long[](k);\n    foreach(el; arr)\n    {\n   \
    \     if(i < k)\n        {\n            maxHeap.push(el);\n            i++;\n\
    \        }\n        else\n        {\n            if(el > maxHeap.top())\n    \
    \        {\n                maxHeap.pop();\n                maxHeap.push(el);\n\
    \            }\n        }\n    }\n    for(auto j = n - 1L; j >= 0L; j--)\n   \
    \ {\n        result[j] = maxHeap.top();\n        maxHeap.pop();\n    }\n    return\
    \ result;\n}", "{\n    long[] firstK = new long[(int)k];\n    int i = 0;\n   \
    \ while (i < k) {\n        firstK[i] = arr[i];\n        i += 1;\n    }\n    std.sort(firstK);\n\
    \    int len = arr.length;\n    i = k;\n    while (i < len) {\n        long x\
    \ = arr[i];\n        if (x > firstK[0]) {\n            long j = 0;\n         \
    \   while (j < k) {\n                if (x > firstK[j]) {\n                  \
    \  long tmp = firstK[j];\n                    firstK[j] = x;\n               \
    \     x = tmp;\n                }\n                j += 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    return firstK;\n}", "{\n    return arr[$-k\
    \ .. $].sort().reverse();\n}", "{\n    auto heap = PriorityQueue!(long)();\n \
    \   for (a; arr)\n    {\n        if (heap.length == k)\n        {\n          \
    \  if (a > heap.front)\n            {\n                heap.removeFront();\n \
    \               heap.add(a);\n            }\n        }\n        else\n       \
    \ {\n            heap.add(a);\n        }\n    }\n    return heap.array.reverse();\n\
    }", "{\n    arr.sort();\n    long[] r = new long[k];\n    for (long i = 0; i <\
    \ k; i++) \n    {\n        r[i] = arr[arr.length - 1 - i];\n    }\n    return\
    \ r;\n}", "{\n    long[] sortedArray = arr.copy();\n    quickSort(sortedArray,\
    \ 0, arr.length - 1);\n    long[] result = new long[k];\n    for (long i = 0;\
    \ i < k; i++) \n    {\n        result[i] = sortedArray[arr.length - 1 - i];\n\
    \    }\n    return result;\n}", "{\n    if (k == 0)\n        return new long[0];\n\
    \    if (k == arr.length)\n        return arr;\n    \n    long[] maxArr = new\
    \ long[(int)k];\n    Heap<long> heap = new Heap<long>(less);\n    foreach (long\
    \ i; arr)\n        heap.insert(i);\n    \n    for (int i = 0; i < k; i++)\n  \
    \      maxArr[i] = heap.removeFront();\n    \n    return maxArr;\n}", "{\n   \
    \ if ( k <= 0L )\n        return [];\n    else if ( k == 1L )\n        return\
    \ [ max(arr) ];\n    else if ( k == arr.length )\n        return sort(arr);\n\
    \    else\n    {\n        int i = 0;\n        long tmp;\n        for (i = 0; i\
    \ < k; i++)\n        {\n            for (int j = i; j < arr.length; j++)\n   \
    \         {\n                if ( arr[i] < arr[j] )\n                {\n     \
    \               tmp = arr[i];\n                    arr[i] = arr[j];\n        \
    \            arr[j] = tmp;\n                }\n            }\n        }\n    }\n\
    \    return arr[0..(int)k];\n}", "{\n    long len = arr.length;\n    // return\
    \ arr;\n    long num;\n    long[] ans = new long[k];\n    long[] sorted = new\
    \ long[len];\n    long[] reversed = new long[len];\n    for (long i = 0; i < len;\
    \ i++)\n    {\n        sorted[i] = arr[i];\n    }\n    sort(sorted);\n    for\
    \ (long i = 0; i < len; i++)\n    {\n        reversed[i] = sorted[len - i - 1];\n\
    \    }\n    for (long i = 0; i < k; i++)\n    {\n        ans[i] = reversed[i];\n\
    \    }\n    return ans;\n}", "{\n    // If k == 1 return the maximum number\n\
    \    if (k == 1L)\n    {\n        return [max(arr)];\n    }\n    // If k == arr.length\
    \ return the sorted array\n    else if (k == arr.length)\n    {\n        return\
    \ sort(arr);\n    }\n    // Else use a priority queue to sort the array\n    else\n\
    \    {\n        Queue!(long) myQueue = new Queue!(long)();\n        auto tempArr\
    \ = new long[](k);\n        foreach (i; 0..k)\n        {\n            myQueue.put(arr[i]);\n\
    \        }\n        foreach (i; k..arr.length)\n        {\n            auto num\
    \ = myQueue.get();\n            if (arr[i] > num)\n            {\n           \
    \     myQueue.put(arr[i]);\n            }\n            else\n            {\n \
    \               myQueue.put(num);\n            }\n        }\n        tempArr =\
    \ myQueue.getArray();\n        return sort(tempArr);\n    }\n}", "{\n    long[]\
    \ copy = new long[k];\n    for (long i = 0; i < k; i++) \n    {\n        copy[i]\
    \ = arr[i];\n    }\n    std.sort(copy);\n    for (long i = k; i < arr.length;\
    \ i++) \n    {\n        if (arr[i] < copy[0]) \n        {\n            continue;\n\
    \        }\n        else \n        {\n            copy[0] = arr[i];\n        \
    \    std.sort(copy);\n        }\n    }\n    return copy;\n}", "{\n    long[] result\
    \ = new long[cast(size_t)k];\n    foreach(i, x; arr)\n    {\n        if(k > 0)\n\
    \        {\n            auto idx = binarySearch([result], x);\n            if(idx\
    \ < 0)\n            {\n                idx = -idx - 1;\n            }\n      \
    \      if(idx < k)\n            {\n                arrayMove(result, idx + 1,\
    \ idx, k - idx - 1);\n                result[idx] = x;\n            }\n      \
    \  }\n    }\n    return result;\n}", "{\n    long[] ret = new long[cast(int)k];\n\
    \    ret[] = numeric_limits.minL;\n    foreach(e; arr)\n    {\n        if(e >\
    \ ret[0])\n        {\n            ret[0] = e;\n            std.algorithm.sort(ret);\n\
    \        }\n    }\n    return ret;\n}", "{\n    qsort(arr);\n    long[] r = new\
    \ long[k];\n    for (long i = 0L; i < k; i++) {\n        r[i] = arr[arr.length\
    \ - 1L - i];\n    }\n    return r;\n}", "{\n    assert(k <= arr.length);\n   \
    \ long[] ret = new long[k];\n    std.heap.priority_queue!(long, \"a > b\") q =\
    \ new std.heap.priority_queue!(long, \"a > b\")();\n    foreach(e; arr)\n    {\n\
    \        if(q.length < k)\n        {\n            q.push(e);\n        }\n    \
    \    else\n        {\n            if(e > q.top)\n            {\n             \
    \   q.pop();\n                q.push(e);\n            }\n        }\n    }\n  \
    \  foreach(e; q)\n    {\n        ret ~= e;\n    }\n    return ret;\n}", "{\n \
    \   return arr.sort.drop(arr.length - k);\n}", "{\n    long[] subset = new long[(int)k];\n\
    \    arr.sort;\n    foreach(i, v; arr)\n    {\n        subset[i] = v;\n    }\n\
    \    return subset;\n}", "{\n    sort(arr);\n    long[] max = new long[(int)k];\n\
    \    for (long i = 0; i < k; i++)\n    {\n        max[(int)i] = arr[(int)(arr.length\
    \ - 1 - i)];\n    }\n    return max;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
