name: HumanEval_120_maximum
language: d
prompt: "import std.math;\n/*\n\n    Given an array arr of integers and a positive\
  \ integer k, return a sorted array \n    of length k with the maximum k numbers\
  \ in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L,\
  \ 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n\
  \    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\
  \n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n\
  \        2. The elements in the array will be in the range of [-1000, 1000].\n \
  \       3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n"
tests: "unittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L,\
  \ -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) ==\
  \ [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n\
  \    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n\
  \    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n\
  \    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L,\
  \ 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L,\
  \ 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L,\
  \ -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n\
  \    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid\
  \ main(){}"
completions: ["{\n    immutable int N = arr.length;\n    assert(k > 0 && k <= N);\n\
    \    long[] temp = arr[0..$ - k];\n    std.algorithm.sort(temp);\n    for (int\
    \ i = N - k; i < N; i++)\n    {\n        if (arr[i] > temp[0])\n        {\n  \
    \          temp[0] = arr[i];\n            std.algorithm.sort(temp);\n        }\n\
    \    }\n    return temp;\n}", "{\n    if (k == 0)\n        return [].array();\n\
    \    auto arr_s = sort(arr);\n    auto result = new long[k];\n    foreach (i,\
    \ element; arr_s[$ - k .. $])\n        result[i] = element;\n    return result;\n\
    }", "{\n    auto n = arr.length;\n    auto maxHeap = new max_heap_long;\n    auto\
    \ i = 0L;\n    auto result = new long[](k);\n    foreach(el; arr)\n    {\n   \
    \     if(i < k)\n        {\n            maxHeap.push(el);\n            i++;\n\
    \        }\n        else\n        {\n            if(el > maxHeap.top())\n    \
    \        {\n                maxHeap.pop();\n                maxHeap.push(el);\n\
    \            }\n        }\n    }\n    for(auto j = n - 1L; j >= 0L; j--)\n   \
    \ {\n        result[j] = maxHeap.top();\n        maxHeap.pop();\n    }\n    return\
    \ result;\n}", "{\n    long[] firstK = new long[(int)k];\n    int i = 0;\n   \
    \ while (i < k) {\n        firstK[i] = arr[i];\n        i += 1;\n    }\n    std.sort(firstK);\n\
    \    int len = arr.length;\n    i = k;\n    while (i < len) {\n        long x\
    \ = arr[i];\n        if (x > firstK[0]) {\n            long j = 0;\n         \
    \   while (j < k) {\n                if (x > firstK[j]) {\n                  \
    \  long tmp = firstK[j];\n                    firstK[j] = x;\n               \
    \     x = tmp;\n                }\n                j += 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    return firstK;\n}", "{\n    return arr[$-k\
    \ .. $].sort().reverse();\n}", "{\n    auto heap = PriorityQueue!(long)();\n \
    \   for (a; arr)\n    {\n        if (heap.length == k)\n        {\n          \
    \  if (a > heap.front)\n            {\n                heap.removeFront();\n \
    \               heap.add(a);\n            }\n        }\n        else\n       \
    \ {\n            heap.add(a);\n        }\n    }\n    return heap.array.reverse();\n\
    }", "{\n    arr.sort();\n    long[] r = new long[k];\n    for (long i = 0; i <\
    \ k; i++) \n    {\n        r[i] = arr[arr.length - 1 - i];\n    }\n    return\
    \ r;\n}", "{\n    long[] sortedArray = arr.copy();\n    quickSort(sortedArray,\
    \ 0, arr.length - 1);\n    long[] result = new long[k];\n    for (long i = 0;\
    \ i < k; i++) \n    {\n        result[i] = sortedArray[arr.length - 1 - i];\n\
    \    }\n    return result;\n}", "{\n    if (k == 0)\n        return new long[0];\n\
    \    if (k == arr.length)\n        return arr;\n    \n    long[] maxArr = new\
    \ long[(int)k];\n    Heap<long> heap = new Heap<long>(less);\n    foreach (long\
    \ i; arr)\n        heap.insert(i);\n    \n    for (int i = 0; i < k; i++)\n  \
    \      maxArr[i] = heap.removeFront();\n    \n    return maxArr;\n}", "{\n   \
    \ if ( k <= 0L )\n        return [];\n    else if ( k == 1L )\n        return\
    \ [ max(arr) ];\n    else if ( k == arr.length )\n        return sort(arr);\n\
    \    else\n    {\n        int i = 0;\n        long tmp;\n        for (i = 0; i\
    \ < k; i++)\n        {\n            for (int j = i; j < arr.length; j++)\n   \
    \         {\n                if ( arr[i] < arr[j] )\n                {\n     \
    \               tmp = arr[i];\n                    arr[i] = arr[j];\n        \
    \            arr[j] = tmp;\n                }\n            }\n        }\n    }\n\
    \    return arr[0..(int)k];\n}", "{\n    long len = arr.length;\n    // return\
    \ arr;\n    long num;\n    long[] ans = new long[k];\n    long[] sorted = new\
    \ long[len];\n    long[] reversed = new long[len];\n    for (long i = 0; i < len;\
    \ i++)\n    {\n        sorted[i] = arr[i];\n    }\n    sort(sorted);\n    for\
    \ (long i = 0; i < len; i++)\n    {\n        reversed[i] = sorted[len - i - 1];\n\
    \    }\n    for (long i = 0; i < k; i++)\n    {\n        ans[i] = reversed[i];\n\
    \    }\n    return ans;\n}", "{\n    // If k == 1 return the maximum number\n\
    \    if (k == 1L)\n    {\n        return [max(arr)];\n    }\n    // If k == arr.length\
    \ return the sorted array\n    else if (k == arr.length)\n    {\n        return\
    \ sort(arr);\n    }\n    // Else use a priority queue to sort the array\n    else\n\
    \    {\n        Queue!(long) myQueue = new Queue!(long)();\n        auto tempArr\
    \ = new long[](k);\n        foreach (i; 0..k)\n        {\n            myQueue.put(arr[i]);\n\
    \        }\n        foreach (i; k..arr.length)\n        {\n            auto num\
    \ = myQueue.get();\n            if (arr[i] > num)\n            {\n           \
    \     myQueue.put(arr[i]);\n            }\n            else\n            {\n \
    \               myQueue.put(num);\n            }\n        }\n        tempArr =\
    \ myQueue.getArray();\n        return sort(tempArr);\n    }\n}", "{\n    long[]\
    \ copy = new long[k];\n    for (long i = 0; i < k; i++) \n    {\n        copy[i]\
    \ = arr[i];\n    }\n    std.sort(copy);\n    for (long i = k; i < arr.length;\
    \ i++) \n    {\n        if (arr[i] < copy[0]) \n        {\n            continue;\n\
    \        }\n        else \n        {\n            copy[0] = arr[i];\n        \
    \    std.sort(copy);\n        }\n    }\n    return copy;\n}", "{\n    long[] result\
    \ = new long[cast(size_t)k];\n    foreach(i, x; arr)\n    {\n        if(k > 0)\n\
    \        {\n            auto idx = binarySearch([result], x);\n            if(idx\
    \ < 0)\n            {\n                idx = -idx - 1;\n            }\n      \
    \      if(idx < k)\n            {\n                arrayMove(result, idx + 1,\
    \ idx, k - idx - 1);\n                result[idx] = x;\n            }\n      \
    \  }\n    }\n    return result;\n}", "{\n    long[] ret = new long[cast(int)k];\n\
    \    ret[] = numeric_limits.minL;\n    foreach(e; arr)\n    {\n        if(e >\
    \ ret[0])\n        {\n            ret[0] = e;\n            std.algorithm.sort(ret);\n\
    \        }\n    }\n    return ret;\n}", "{\n    qsort(arr);\n    long[] r = new\
    \ long[k];\n    for (long i = 0L; i < k; i++) {\n        r[i] = arr[arr.length\
    \ - 1L - i];\n    }\n    return r;\n}", "{\n    assert(k <= arr.length);\n   \
    \ long[] ret = new long[k];\n    std.heap.priority_queue!(long, \"a > b\") q =\
    \ new std.heap.priority_queue!(long, \"a > b\")();\n    foreach(e; arr)\n    {\n\
    \        if(q.length < k)\n        {\n            q.push(e);\n        }\n    \
    \    else\n        {\n            if(e > q.top)\n            {\n             \
    \   q.pop();\n                q.push(e);\n            }\n        }\n    }\n  \
    \  foreach(e; q)\n    {\n        ret ~= e;\n    }\n    return ret;\n}", "{\n \
    \   return arr.sort.drop(arr.length - k);\n}", "{\n    long[] subset = new long[(int)k];\n\
    \    arr.sort;\n    foreach(i, v; arr)\n    {\n        subset[i] = v;\n    }\n\
    \    return subset;\n}", "{\n    sort(arr);\n    long[] max = new long[(int)k];\n\
    \    for (long i = 0; i < k; i++)\n    {\n        max[(int)i] = arr[(int)(arr.length\
    \ - 1 - i)];\n    }\n    return max;\n}", "{\n    long n = arr.length;\n    k\
    \ = min(k, n);\n    if (k == 0) \n        return new long[0];\n    return arr[0..n].sort()[n\
    \ - k..n];\n}", "{\n    auto a = sort(arr);\n    return a[a.length - k .. $];\n\
    }", "{\n    int[] maxs = new int[cast(int)k];\n    int maxs_len = 0;\n    int\
    \ begin = 0;\n    foreach(i, x; arr)\n    {\n        if(maxs_len == 0)\n     \
    \   {\n            maxs[0] = i;\n            maxs_len = 1;\n        }\n      \
    \  else if(maxs_len == cast(int)k)\n        {\n            if(arr[maxs[0]] < x)\n\
    \            {\n                maxs[0] = i;\n                begin = 0;\n   \
    \         }\n        }\n        else\n        {\n            maxs[maxs_len] =\
    \ i;\n            maxs_len++;\n        }\n        while(begin + 1 < maxs_len &&\
    \ arr[maxs[begin]] < arr[maxs[begin + 1]])\n        {\n            swap(maxs[begin],\
    \ maxs[begin + 1]);\n            begin++;\n        }\n    }\n    return arr[maxs];\n\
    }", "{\n    long[] result = new long[(int)k];\n    result[0] = std.stdio.__promptLineOfLongs(arr);\n\
    \    for (int i = 1; i < arr.length; i++)\n    {\n        if (arr[i] > result[0])\n\
    \        {\n            result[0] = arr[i];\n        }\n    }\n    for (int i\
    \ = 1; i < k; i++)\n    {\n        result[i] = std.stdio.__promptLineOfLongs(arr);\n\
    \        for (int j = 0; j < i; j++)\n        {\n            if (result[i] > result[j])\n\
    \            {\n                result[j] = result[i];\n            }\n      \
    \  }\n    }\n    return result;\n}", "{\n    std.sort(arr);\n    long[] res =\
    \ new long[cast(int)k];\n    long index = cast(long)arr.length - 1;\n    foreach(long\
    \ i; 0..k)\n    {\n        res[i] = arr[index];\n        index--;\n    }\n   \
    \ return res;\n}", "{\n    if (k == 0) \n    {\n        return new long[0];\n\
    \    }\n    int n = arr.length;\n    if (k >= n) \n    {\n        arr = arr.dup;\n\
    \        arr.sort;\n        return arr;\n    }\n    long[] stk = new long[k];\n\
    \    long top = -1;\n    for (int i = 0; i < n; i++) \n    {\n        long x =\
    \ arr[i];\n        if (top < k - 1) \n        {\n            stk[++top] = x;\n\
    \        } \n        else \n        {\n            long j = top;\n           \
    \ while (j >= 0 && stk[j] < x) \n            {\n                j--;\n       \
    \     }\n            if (j < k - 1) \n            {\n                stk[j + 1]\
    \ = x;\n            }\n        }\n    }\n    return stk;\n}", "{\n    long[] res\
    \ = new long[cast(int)k];\n    for (long i = 0; i < arr.length; i++) \n    {\n\
    \        long j = max(0L, k - arr.length + i);\n        while (j < k && arr[cast(int)i]\
    \ > res[cast(int)j]) \n        {\n            j++;\n        }\n        if (j <\
    \ k) \n        {\n            res[cast(int)j] = arr[cast(int)i];\n        }\n\
    \    }\n    return res;\n}", "{\n    long[] retArr = new long[(int)k];\n    int\
    \ n = 0;\n    while (n < k)\n    {\n        long max = 0;\n        int maxI =\
    \ 0;\n        for (int i = 0; i < arr.length; i++)\n        {\n            if\
    \ (arr[i] >= max)\n            {\n                max = arr[i];\n            \
    \    maxI = i;\n            }\n        }\n        retArr[n] = max;\n        arr[maxI]\
    \ = -1001;\n        n++;\n    }\n    return retArr;\n}", "{\n    long[] max =\
    \ new long[k];\n    foreach(i; 0..k)\n    {\n        max[i] = arr[i];\n    }\n\
    \    sort(max);\n    for(long i = k; i < arr.length; i++)\n    {\n        foreach(j;\
    \ 0..k)\n        {\n            if(arr[i] > max[j])\n            {\n         \
    \       max[j] = arr[i];\n                sort(max);\n                break;\n\
    \            }\n        }\n    }\n    return max;\n}", "{\n    // For ascending\
    \ array\n    if (arr[0] < arr[arr.length - 1])\n    {\n        sort(arr);\n  \
    \      return arr[arr.length - k..arr.length];\n    }\n    // For descending array\n\
    \    else\n    {\n        sort(arr);\n        return arr[0..k];\n    }\n}", "{\n\
    \    auto n = arr.length;\n    if (n < k)\n    {\n        return null;\n    }\n\
    \    else if (n == k)\n    {\n        return arr;\n    }\n    else\n    {\n  \
    \      auto count = 0L;\n        auto result = new long[cast(ulong)k];\n     \
    \   sort(arr);\n        for (n--; n >= 0; n--)\n        {\n            if (count\
    \ < k)\n            {\n                result[count] = arr[n];\n             \
    \   count++;\n            }\n            else\n            {\n               \
    \ break;\n            }\n        }\n        return result;\n    }\n}", "{\n  \
    \  long[] max = new long[k];\n    foreach(i; 0 .. k)\n    {\n        max[i] =\
    \ -1001L;\n    }\n    foreach(i; 0 .. arr.length)\n    {\n        if(arr[i] >=\
    \ max[0])\n        {\n            max[0] = arr[i];\n            sort(max);\n \
    \       }\n    }\n    return max;\n}", "{\n    if (k == arr.length)\n        return\
    \ arr;\n    int n = arr.length;\n    for (int i = 0; i < n-1; i++)\n    {\n  \
    \      int max_idx = i;\n        for (int j = i+1; j < n; j++)\n            if\
    \ (arr[j] > arr[max_idx])\n                max_idx = j;\n        long temp = arr[max_idx];\n\
    \        arr[max_idx] = arr[i];\n        arr[i] = temp;\n    }\n    return arr[n-k..$];\n\
    }", "{\n    long[] answer = new long[(int)k];\n    std.sort(arr);\n    for (long\
    \ i = 0; i < k; i++)\n    {\n        answer[(int)i] = arr[(int)(arr.length - i\
    \ - 1)];\n    }\n    return answer;\n}", "{\n    if (k > arr.length) \n    {\n\
    \        throw new RuntimeException(\"K should be less than equal to Array length\"\
    );\n    }\n    if (k == arr.length)\n    {\n        return arr;\n    }\n    long[]\
    \ result = new long[(int)k];\n    sort(arr);\n    long[] temp = arr[$-1 .. $];\n\
    \    int index = 0;\n    for (int i = 0; i < k; i++)\n    {\n        result[index++]\
    \ = temp[i];\n    }\n    return result;\n}", "{\n    sort(arr);\n    long[] res\
    \ = new long[to!int(k)];\n    for (int i = 0; i < k; i++)\n    {\n        res[i]\
    \ = arr[$ - 1 - i];\n    }\n    return res;\n}", "{\n    auto r = appender!(long[])();\n\
    \    foreach(i; 0 .. arr.length)\n    {\n        if(i < k)\n        {\n      \
    \      r.put(arr[i]);\n        }\n        else\n        {\n            long max\
    \ = r[0];\n            long max_index = 0;\n            foreach(j; 0 .. k)\n \
    \           {\n                if(r[j] > max)\n                {\n           \
    \         max = r[j];\n                    max_index = j;\n                }\n\
    \            }\n            if(arr[i] < max)\n            {\n                r[max_index]\
    \ = arr[i];\n            }\n        }\n    }\n    sort(r.data);\n    return r.data[$\
    \ .. 0 .. $ - k];\n}", "{\n    auto result = new long[k];\n    int pos = 0;\n\
    \    while (k > 0) \n    {\n        auto max = arr[0];\n        int index = 0;\n\
    \        for (int i = 1; i < arr.length; i++) \n        {\n            if (arr[i]\
    \ > max) \n            {\n                max = arr[i];\n                index\
    \ = i;\n            }\n        }\n        result[pos++] = max;\n        arr[index]\
    \ = -1000000L;\n        k--;\n    }\n    return result;\n}", "{\n    const long\
    \ int arrLen = arr.length;\n    if (k == arrLen)\n        return arr;\n    if\
    \ (k == 0)\n        return [];\n    if (k == 1)\n    {\n        long int max =\
    \ -2147483648L;\n        foreach (i; arr)\n            if (i > max)\n        \
    \        max = i;\n        return [max];\n    }\n    const long int k_1 = k -\
    \ 1L;\n    long[] newArr = arr[0L..k_1];\n    // heapify\n    for (long int i\
    \ = k_1 / 2L; i >= 0L; i--)\n        shiftDown(newArr, i, k_1);\n    for (long\
    \ int i = k_1; i < arrLen; i++)\n    {\n        if (arr[i] > newArr[0L])\n   \
    \     {\n            newArr[0L] = arr[i];\n            shiftDown(newArr, 0L, k_1);\n\
    \        }\n    }\n    return newArr;\n}", "{\n    ArrayList<Long> res = new ArrayList<Long>();\n\
    \    for (long i : arr) \n    {\n        if (res.size() < k) \n        {\n   \
    \         res.add(i);\n        }\n        else \n        {\n            if (i\
    \ > res.get(0)) \n            {\n                res.set(0, i);\n            }\n\
    \        }\n        sort(res);\n    }\n    return res.stream().mapToLong(i ->\
    \ i).toArray();\n}", "{\n    // loop over all items in arr, saving the maximum\
    \ \n    long max = arr[0];\n    foreach(idx, item; arr)\n    {\n        if(item\
    \ > max)\n        {\n            max = item;\n        }\n    }\n    // build a\
    \ new array using the maxium value, k times\n    long[] newArr = new long[k];\n\
    \    foreach(idx, item; newArr)\n    {\n        newArr[idx] = max;\n    }\n  \
    \  // return the new array\n    return newArr;\n}", "{\n    // if k > arr.length\
    \ return the sorted array\n    if (k > arr.length) return arr.sort();\n    //\
    \ if k <= 0 return empty array\n    if (k <= 0) return [];\n    // else create\
    \ a set\n    set!int set;\n    // create a range of 0 to arr.length\n    foreach\
    \ (i; 0 .. arr.length)\n    {\n        // if set size is greater than or equal\
    \ to k\n        if (set.size >= k)\n        {\n            // get min from set\
    \ \n            long min = set.min;\n            // if arr[i] is greater than\
    \ min\n            if (arr[i] > min)\n            {\n                // remove\
    \ the min value from set\n                set.remove(min);\n                //\
    \ add the arr[i] to set\n                set.insert(arr[i]);\n            }\n\
    \        }\n        else\n        {\n            // if set size is less than k\
    \ add to set\n            set.insert(arr[i]);\n        }\n    }\n    // create\
    \ empty array\n    long[] out = [];\n    // convert set to array\n    out = set.toArray();\n\
    \    // sort the array and return\n    return out.sort();\n}", "{\n    sort(arr);\n\
    \    long[] result = new long[k];\n    result[0 .. $] = arr[arr.length - k ..\
    \ arr.length];\n    return result;\n}", "{\n    int n = arr.length;\n    long[]\
    \ result = new long[k];\n    if (n <= k) {\n        sort(arr);\n        return\
    \ arr;\n    }\n    for (int i = 0; i < k; i++) {\n        result[i] = arr[i];\n\
    \    }\n    sort(result);\n    for (int i = k; i < n; i++) {\n        if (arr[i]\
    \ > result[0]) {\n            result[0] = arr[i];\n            for (int j = 1;\
    \ j < k; j++) {\n                if (result[j] < result[j - 1]) {\n          \
    \          long tmp = result[j];\n                    result[j] = result[j - 1];\n\
    \                    result[j - 1] = tmp;\n                }\n            }\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = new long[to!int(k)];\n\
    \    std.sort(arr);\n    for (int i = arr.length - 1; i >= 0; i--)\n    {\n  \
    \      if (k == 0) break;\n        result[arr.length - (int)k] = arr[i];\n   \
    \     k--;\n    }\n    return result;\n}", "{\n    long[] maxs = new long[(int)k];\n\
    \    maxs[0] = arr[0];\n    uint i = 1;\n    while (i < k)\n    {\n        if\
    \ (arr[i] > maxs[i - 1])\n        {\n            maxs[i] = arr[i];\n        }\n\
    \        else\n        {\n            maxs[i] = maxs[i - 1];\n        }\n    \
    \    i++;\n    }\n    i = k;\n    while (i < arr.length)\n    {\n        if (arr[i]\
    \ > maxs[(int)k - 1])\n        {\n            maxs[(int)k - 1] = arr[i];\n   \
    \         maxs.sort();\n        }\n        i++;\n    }\n    return maxs;\n}",
  "{\n    quickSort(arr, 0, arr.length - 1);\n    return arr[arr.length - (int)k ..\
    \ arr.length];\n}", "{\n    if (k == 0L) return new long[0];\n    // Since we\
    \ want a sorted array, it is easier to sort in descending order\n    sort(arr);\n\
    \    reverse(arr);\n    long[] result = new long[cast(int)k];\n    foreach (i,\
    \ ref x; result)\n    {\n        result[i] = arr[i];\n    }\n    return result;\n\
    }", "{\n    long length = arr.length;\n    if (length == k) \n    {\n        return\
    \ arr;\n    }\n    else if (k == 1) \n    {\n        long max = arr[0];\n    \
    \    foreach (i; arr)\n        {\n            if (i > max) \n            {\n \
    \               max = i;\n            }\n        }\n        return [max];\n  \
    \  }\n    else if (k == 0) \n    {\n        return null;\n    }\n    else \n \
    \   {\n        foreach (i; 0 .. length)\n        {\n            long max = arr[i];\n\
    \            long position = i;\n            foreach (j; i .. length)\n      \
    \      {\n                if (arr[j] > max) \n                {\n            \
    \        max = arr[j];\n                    position = j;\n                }\n\
    \            }\n            long temp = arr[i];\n            arr[i] = max;\n \
    \           arr[position] = temp;\n        }\n        return arr[$ - k .. $];\n\
    \    }\n}", "{\n    long[] result = new long[arr.length];\n    result = arr.dup;\n\
    \    result.sort;\n    result.reverse;\n    long[] k_element = new long[k];\n\
    \    for (long i = 0; i < k; i++)\n    {\n        k_element[i] = result[i];\n\
    \    }\n    return k_element;\n}", "{\n    long[] result = new long[to!int(k)];\n\
    \    sort(arr);\n    for (int i = 0; i < k; i++)\n    {\n        result[i] = arr[arr.length\
    \ - 1 - i];\n    }\n    return result;\n}", "{\n    long[] result = new long[(int)k];\n\
    \    sort(arr);\n    for (int i = 0; i < k; i++)\n    {\n        result[i] = arr[arr.length\
    \ - 1 - i];\n    }\n    return result;\n}", "{\n\tauto n = arr.length;\n\tif (k\
    \ == n) return arr;\n\t\n\tstd.sort(arr);\n\tlong[] result = new long[k];\n\t\
    for (auto i = 0L; i < k; i++)\n\t\tresult[i] = arr[n - i - 1];\n\treturn result;\n\
    }", "{\n    // sort the array\n    sort(arr);\n    // -1 because of the zero indexing\n\
    \    long index = k - 1L;\n    // create a new array of size k\n    long[] array\
    \ = new long[k];\n    // loop from k to 0\n    for (int i = cast(int)index; i\
    \ >= 0; i--)\n    {\n        // add the elements to the new array\n        array[i]\
    \ = arr[i];\n    }\n    // return the array\n    return array;\n}", "{\n    int[]\
    \ output = new int[k];\n    int lastIndex = 0;\n    int max = int.min;\n    foreach(int\
    \ i, ref int elem; arr)\n    {\n        if(i >= k)\n            break;\n     \
    \   if(elem > max)\n        {\n            max = elem;\n            lastIndex\
    \ = i;\n        }\n        output[i] = elem;\n    }\n    if(k <= arr.length)\n\
    \    {\n        foreach(int i, ref int elem; arr[lastIndex + 1 ..])\n        {\n\
    \            if(elem > max)\n            {\n                int j = 0;\n     \
    \           while(j < k)\n                {\n                    if(elem > output[j])\n\
    \                    {\n                        int temp = output[j];\n      \
    \                  output[j] = elem;\n                        elem = temp;\n \
    \                   }\n                    j++;\n                }\n         \
    \   }\n        }\n    }\n    else\n    {\n        int j = 0;\n        while(j\
    \ < k)\n        {\n            if(j > arr.length)\n                output[j] =\
    \ output[arr.length - 1];\n            j++;\n        }\n    }\n    return output;\n\
    }", "{\n    long[] result = new long[k];\n    for (int i = 0; i < k; i++) {\n\
    \        result[i] = max(arr);\n        arr = removeLast(arr);\n    }\n    return\
    \ result;\n}", "{\n    // Find the maximum number of times we are going to iterate\
    \ over arr.\n    auto maxIterations = k < arr.length ? k : arr.length;\n    //\
    \ Create the result array.\n    long[] result;\n    // Create the array of indexes\
    \ for the result array.\n    long[] indexes;\n    // Initialize the indexes array.\n\
    \    indexes.length = maxIterations;\n    // Populate the indexes array.\n   \
    \ for (auto i = 0L; i < maxIterations; i++)\n    {\n        indexes[i] = i;\n\
    \    }\n    // Sort the indexes array.\n    indexes.sort!((a, b) => arr[a] < arr[b]);\n\
    \    // Populate the result array.\n    for (auto i = 0L; i < maxIterations; i++)\n\
    \    {\n        result ~= arr[indexes[i]];\n    }\n    // Return the result array.\n\
    \    return result;\n}", "{\n    long[] result = new long[k];\n    for (long i\
    \ = 0; i < k; i++)\n    {\n        result[i] = arr[i];\n    }\n    sort(result);\n\
    \    for (long i = k; i < arr.length; i++)\n    {\n        if (arr[i] > result[0])\n\
    \        {\n            result[0] = arr[i];\n            sort(result);\n     \
    \   }\n    }\n    return result;\n}", "{\n    long[] result = new long[cast(int)k];\n\
    \    if (k == 0)\n        return result;\n    sort(arr);\n    result[$-1] = arr[$-1];\n\
    \    long current = result[$-1];\n    long i = $-2;\n    while (i >= 0 && k >\
    \ 1)\n    {\n        if (arr[cast(int)i] != current)\n        {\n            result[$-k]\
    \ = arr[cast(int)i];\n            current = arr[cast(int)i];\n            k--;\n\
    \        }\n        i--;\n    }\n    return result;\n}", "{\n    int i = 0;\n\
    \    int j = (int)k - 1;\n    long[] res = new long[k];\n    if (k == 0) \n  \
    \  {\n        return res;\n    }\n    else \n    {\n        for (int m = 0; m\
    \ < (int)k; m++) \n        {\n            res[m] = arr[m];\n        }\n      \
    \  sort(res);\n        while (j < arr.length) \n        {\n            if (arr[j]\
    \ > res[0]) \n            {\n                res[0] = arr[j];\n              \
    \  sort(res);\n            }\n            j++;\n        }\n        return res;\n\
    \    }\n}", "{\n    long[] result = new long[k];\n    long[] sort = arr.dup;\n\
    \    sort.sort();\n    auto limit = min(k, arr.length);\n    foreach(i; 0..limit)\n\
    \    {\n        result[i] = sort[arr.length - 1 - i];\n    }\n    return result;\n\
    }", "{\n    // Do your magic here\n    long[] output = new long[(int)k];\n   \
    \ int outputLen = 0;\n    if (k == 0) {\n        return output;\n    }\n    for\
    \ (long num : arr) {\n        if (outputLen < k) {\n            output[outputLen]\
    \ = num;\n            outputLen++;\n            continue;\n        }\n       \
    \ for (int i = 0; i < k; i++) {\n            if (num > output[i]) {\n        \
    \        long tmp = output[i];\n                output[i] = num;\n           \
    \     num = tmp;\n            }\n        }\n    }\n    return output;\n}", "{\n\
    \    long[] result = new long[k];\n    sort(arr);\n    for (int i = 0; i < k;\
    \ i++)\n    {\n        result[i] = arr[$ - i - 1];\n    }\n    return result;\n\
    }", "{\n    if (arr.length == k)\n        return arr;\n    else if (arr.length\
    \ > k)\n    {\n        long min = arr[0];\n        long indexOfMin = 0;\n    \
    \    long[] result = new long[cast(int)k];\n        for (int i = 0; i < k; i++)\n\
    \        {\n            for (int j = 1; j < arr.length; j++)\n            {\n\
    \                if (arr[j] < min)\n                {\n                    min\
    \ = arr[j];\n                    indexOfMin = j;\n                }\n        \
    \    }\n            result[i] = min;\n            arr[indexOfMin] = arr[0];\n\
    \            min = arr[0];\n        }\n        return result;\n    }\n    else\n\
    \        return arr;\n}", "{\n    auto length = arr.length;\n    if (k >= length)\n\
    \    {\n        return arr;\n    }\n    // https://github.com/blackwhale/blackwhale/blob/master/src/blackwhale/blackwhale.d#L435\n\
    \    auto maxHeap = blackwhale.newHeap!((a, b) => b < a);\n    // add element\
    \ to max heap\n    foreach (e; arr)\n    {\n        maxHeap.insert(e);\n    }\n\
    \    long[] ans = new long[k];\n    long i = 0;\n    while (i < k)\n    {\n  \
    \      ans[i] = maxHeap.popFront;\n        i += 1;\n    }\n    return ans;\n}",
  "{\n    const n = arr.length;\n    const result = new long[k];\n    long sz = 0L;\n\
    \    for (long i = 0L; i < n; i++) \n    {\n        long j = sz - 1L;\n      \
    \  for (; j >= 0L && result[j] < arr[i]; j--)\n            result[j + 1L] = result[j];\n\
    \        if (j + 1L < k) \n        {\n            result[j + 1L] = arr[i];\n \
    \           sz++;\n        }\n    }\n    return result;\n}", "{\n    long[] copy\
    \ = new long[arr.length];\n    foreach(i, val; arr)\n        copy[i] = val;\n\
    \    quickSort(copy, 0, arr.length-1);\n    long[] result = new long[k];\n   \
    \ foreach(i, val; copy)\n    {\n        if(i >= arr.length-k)\n            result[i-(arr.length-k)]\
    \ = val;\n    }\n    return result;\n}", "{\n    long temp;\n    for (long i =\
    \ 0; i < k; i++) \n    {\n        for (long j = 0; j < arr.length - i - 1; j++)\
    \ \n        {\n            if (arr[j] > arr[j + 1]) \n            {\n        \
    \        temp = arr[j];\n                arr[j] = arr[j + 1];\n              \
    \  arr[j + 1] = temp;\n            }\n        }\n    }\n    return arr[arr.length\
    \ - (int)k .. arr.length];\n}", "{\n    long[] res = new long[cast(int)k];\n \
    \   int pos = 0;\n    while (k > 0)\n    {\n        res[pos] = arr[cast(int)k-1];\n\
    \        k--;\n        pos++;\n    }\n    sort(res);\n    return res;\n}", "{\n\
    \    long[] result = new long[cast(ulong)k];\n    foreach(el; arr)\n    {\n  \
    \      bool isInserted = false;\n        foreach(i, val; result)\n        {\n\
    \            if(!isInserted && el > val)\n            {\n                isInserted\
    \ = true;\n                result[i] = el;\n            }\n            else if(isInserted)\n\
    \            {\n                result[i] = val;\n            }\n        }\n \
    \   }\n    return result;\n}", "{\n    if (arr.length == 0)\n        return arr;\n\
    \    \n    if (k == arr.length)\n        return arr;\n    \n    auto pivot = arr[arr.length\
    \ / 2];\n    auto left = [];\n    auto right = [];\n    \n    foreach (i, val;\
    \ arr)\n    {\n        if (val <= pivot)\n            left ~= val;\n        else\n\
    \            right ~= val;\n    }\n    \n    if (left.length == k)\n        return\
    \ left;\n    else if (left.length > k)\n        return maximum(left, k);\n   \
    \ else if (left.length + right.length > k)\n        return left ~ maximum(right,\
    \ k - left.length);\n    else\n        return left ~ right;\n}\n/*\n    Test\n\
    */", "{\n    long[] result = new long[k];\n    quicksort(arr, 0, arr.length -\
    \ 1);\n    foreach(i; 0 .. k)\n    {\n        result[i] = arr[i];\n    }\n   \
    \ return result;\n}", "{\n    long len = arr.length;\n    long[] sorted = arr[0\
    \ .. len];\n    std.sort(sorted);\n    return sorted[len - cast(int)k .. len];\n\
    }", "{\n    long len = arr.length;\n    long[] result = new long[k];\n    if (k\
    \ > len)\n    {\n        return arr;\n    }\n    if (k == len)\n    {\n      \
    \  return sort(arr);\n    }\n    if (k == 1)\n    {\n        return [max(arr)];\n\
    \    }\n    auto bucket = new long[1000L][0L];\n    long maxi = max(arr);\n  \
    \  long mini = min(arr);\n    foreach (el; arr)\n    {\n        bucket[el - mini]\
    \ ~= el;\n    }\n    ulong i = 1000L;\n    foreach (b; bucket[])\n    {\n    \
    \    if (b.length > 0)\n        {\n            i--;\n            if (i == 1000L\
    \ - k)\n            {\n                break;\n            }\n        }\n    }\n\
    \    long[] copy = new long[k];\n    ulong j = 0L;\n    foreach (b; bucket[])\n\
    \    {\n        if (b.length > 0)\n        {\n            i++;\n            if\
    \ (i >= 1000L - k)\n            {\n                foreach (el; b)\n         \
    \       {\n                    result[j] = el;\n                    j++;\n   \
    \             }\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    size_t len = arr.length;\n    size_t i, j;\n    long tmp;\n    for (i = 1;\
    \ i < len; i++) {\n        tmp = arr[i];\n        for (j = i; j > 0 && arr[j -\
    \ 1] < tmp; j--) {\n            arr[j] = arr[j - 1];\n        }\n        arr[j]\
    \ = tmp;\n    }\n    return arr[len - k .. len];\n}", "{\n    int length = cast(int)k;\n\
    \    if (length > arr.length) \n    {\n        length = arr.length;\n    }\n \
    \   long[] max = new long[length];\n    for (int i = 0; i < length; i++) \n  \
    \  {\n        long tmp = -1.0L;\n        int index = -1;\n        for (int j =\
    \ 0; j < arr.length; j++) \n        {\n            if (arr[j] > tmp) \n      \
    \      {\n                tmp = arr[j];\n                index = j;\n        \
    \    }\n        }\n        arr[index] = -1.0L;\n        max[i] = tmp;\n    }\n\
    \    return max;\n}", "{\n    long[] result = new long[(int)k];\n    result[0]\
    \ = arr[0];\n    result[1] = arr[1];\n    if (k == 1)\n    {\n        return result;\n\
    \    }\n    int i = 0;\n    while (k > 1)\n    {\n        while (i < arr.length)\n\
    \        {\n            if (arr[i] > result[0])\n            {\n             \
    \   result[0] = arr[i];\n            }\n            if (arr[i] < result[1])\n\
    \            {\n                result[1] = arr[i];\n            }\n         \
    \   i++;\n        }\n        k--;\n    }\n    sort(result);\n    return result;\n\
    }", "{\n    long[] result = new long[k];\n    long tmp;\n    for (long i = 0;\
    \ i < k; i++)\n    {\n        result[i] = arr[i];\n    }\n    mergeSort(result);\n\
    \    for (long i = k; i < arr.length; i++)\n    {\n        if (arr[i] > result[0])\n\
    \        {\n            result[0] = arr[i];\n            for (long j = 0; j <\
    \ k-1; j++)\n            {\n                if (result[j] > result[j+1])\n   \
    \             {\n                    tmp = result[j];\n                    result[j]\
    \ = result[j+1];\n                    result[j+1] = tmp;\n                }\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    for (uint i\
    \ = 0; i < k; i++)\n    {\n        for (uint j = i + 1; j < arr.length; j++)\n\
    \        {\n            if (arr[i] < arr[j])\n            {\n                auto\
    \ temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n\
    \            }\n        }\n    }\n    return arr[0..(int)k];\n}", "{\n    const\
    \ auto len = arr.length;\n    auto list = list();\n    auto res = new long[k];\n\
    \    foreach(v; arr) list.push(v);\n    sort(list);\n    res[$-1] = list[$-1];\n\
    \    foreach(i; 0..k-1) \n    {\n        res[$-1] = list[$-1];\n    }\n    return\
    \ res;\n}", "{\n    // QuickSOrt the array \n    arr.sort();\n    // Select the\
    \ last k elements\n    return arr[$ - k .. $];\n}", "{\n    long[] result = new\
    \ long[k];\n    for (int i = 0; i < k; i++)\n    {\n        result[i] = -1000L;\n\
    \    }\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] >\
    \ result[0])\n        {\n            result[0] = arr[i];\n            result.sort();\n\
    \        }\n    }\n    return result;\n}", "{\n    // D's slice is a subarray,\
    \ so it's \n    // the same thing as that in Python.\n    auto len = arr.length;\n\
    \    assert(k <= len);\n    auto A = arr[0..k];\n    auto B = A.dup;\n    sort(A);\n\
    \    auto sortedByAscending = true;\n    // Check if `arr` is sorted in ascending\
    \ order.\n    for (long i = 0; i < len - 1; i++) \n    {\n        if (arr[i] >\
    \ arr[i + 1]) \n        {\n            sortedByAscending = false;\n          \
    \  break;\n        }\n    }\n    if (sortedByAscending) \n    {\n        // Just\
    \ return `arr` if it's already sorted.\n        return arr[len - k..len];\n  \
    \  }\n    auto max = 0L;\n    auto j = 0L;\n    for (long i = k; i < len; i++)\
    \ \n    {\n        if (arr[i] > A[0]) \n        {\n            max = 0;\n    \
    \        j = 0;\n            // Find the index of `arr[i]` in `A`.\n         \
    \   for (long m = 0; m < k; m++) \n            {\n                if (arr[i] ==\
    \ A[m]) \n                {\n                    max = arr[i];\n             \
    \       j = m;\n                    break;\n                }\n            }\n\
    \            if (max != 0) \n            {\n                // Remove the element\
    \ in `A` that is\n                // less than `arr[i]` and add `arr[i]`\n   \
    \             // to the end of `A`.\n                A = array(A[0..j], A[j +\
    \ 1..$]);\n                A ~= arr[i];\n                sort(A);\n          \
    \  }\n        }\n    }\n    return B;\n}", "{\n    foreach(i; 0 .. k)\n    {\n\
    \        long max = arr[i];\n        long max_index = i;\n        foreach(j; i\
    \ + 1 .. arr.length)\n        {\n            if(arr[j] > max)\n            {\n\
    \                max = arr[j];\n                max_index = j;\n            }\n\
    \        }\n        (arr[i], arr[max_index]) = (arr[max_index], arr[i]);\n   \
    \ }\n    return arr[0 .. cast(size_t)k];\n}", "{\n    // Apply heap sort, which\
    \ is O(n*log(n))\n    // and find out the last k numbers.\n    long tmp;\n   \
    \ long parent;\n    long child;\n    long[] output = new long[k];\n    output[0]\
    \ = arr[0];\n    output[1] = arr[1];\n    // start the heap sort.\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        // if the index is k and parent\
    \ is smaller than arr[i], then swap them.\n        if (i > 1 && i <= k)\n    \
    \    {\n            if (arr[i] > output[1])\n            {\n                tmp\
    \ = output[1];\n                output[1] = arr[i];\n                output[2]\
    \ = tmp;\n            }\n            else if (arr[i] > output[0])\n          \
    \  {\n                tmp = output[0];\n                output[0] = arr[i];\n\
    \                output[1] = tmp;\n            }\n        }\n        // Assume\
    \ parent is the current number.\n        parent = arr[i];\n        child = 2 *\
    \ i + 1;\n        // Heapify the tree.\n        while (child < arr.length)\n \
    \       {\n            // if the right child exists, and is bigger than the left\
    \ one,\n            // then choose the right one to be compared with parent.\n\
    \            if (child + 1 < arr.length && arr[child] < arr[child + 1])\n    \
    \        {\n                child++;\n            }\n            // if the parent\
    \ is bigger than the child, then swap them.\n            if (parent < arr[child])\n\
    \            {\n                tmp = arr[child];\n                arr[child]\
    \ = parent;\n                arr[(child - 1) / 2] = tmp;\n                child\
    \ = 2 * child + 1;\n            }\n            else\n            {\n         \
    \       break;\n            }\n        }\n    }\n    // After get the max k numbers,\
    \ then sort them.\n    // apply bubble sort here.\n    for (long i = 0; i < k;\
    \ i++)\n    {\n        for (long j = i + 1; j < k; j++)\n        {\n         \
    \   if (", "{\n    quickSort(arr, 0, arr.length - 1);\n    long[] max = new long[to!int(k)];\n\
    \    for (int i = 0; i < to!int(k); i++) \n    {\n        max[i] = arr[i];\n \
    \   }\n    return max;\n}", "{\n    return arr.sort(__lambda0__).take(k);\n}",
  "{\n    int n = arr.length;\n    long[] result = new long[n];\n    for (int i =\
    \ 0; i < n; i++) \n    {\n        if (i < k) \n        {\n            result[i]\
    \ = arr[i];\n        }\n        else \n        {\n            if (arr[i] > result[0])\
    \ \n            {\n                result[0] = arr[i];\n            }\n      \
    \      int j = 1;\n            while (j < k && result[j - 1] > result[j]) \n \
    \           {\n                long tmp = result[j - 1];\n                result[j\
    \ - 1] = result[j];\n                result[j] = tmp;\n                j++;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    int n = arr.length;\n\
    \    ArrayList<Long> res = new ArrayList<Long>();\n    // pq1 is MaxHeap\n   \
    \ PriorityQueue<Long> pq1 = new PriorityQueue<Long>(n, (a, b) -> {\n        if\
    \ (a < b)\n            return 1;\n        else if (a > b)\n            return\
    \ -1;\n        else\n            return 0;\n    });\n    // pq2 is MinHeap\n \
    \   PriorityQueue<Long> pq2 = new PriorityQueue<Long>(n, (a, b) -> {\n       \
    \ if (a < b)\n            return -1;\n        else if (a > b)\n            return\
    \ 1;\n        else\n            return 0;\n    });\n    for (int i = 0; i < n;\
    \ i++) {\n        pq1.add(arr[i]);\n        if (pq1.size() > k) {\n          \
    \  pq2.add(pq1.poll());\n        }\n    }\n    while (!pq1.isEmpty()) {\n    \
    \    res.add(pq1.poll());\n    }\n    while (!pq2.isEmpty()) {\n        res.add(pq2.poll());\n\
    \    }\n    // Reverse the arraylist\n    Collections.reverse(res);\n    return\
    \ res.stream().mapToLong(i -> i).toArray();\n}", "{\n    long[] result = new long[k];\n\
    \    // TODO: implement\n    return result;\n}", "{\n    int len = arr.length;\n\
    \    long[] result = new long[k];\n    for (int i = 0; i < k; i++) \n    {\n \
    \       result[i] = arr[i];\n    }\n    if (k == len) \n    {\n        return\
    \ result;\n    }\n    for (int i = k; i < len; i++) \n    {\n        for (int\
    \ j = 0; j < k; j++) \n        {\n            if (arr[i] > result[j]) \n     \
    \       {\n                for (int m = 0; m < k; m++) \n                {\n \
    \                   if (m == k - 1) \n                    {\n                \
    \        result[m] = arr[i];\n                    }\n                    else\
    \ \n                    {\n                        result[m] = result[m + 1];\n\
    \                    }\n                }\n                break;\n          \
    \  }\n        }\n    }\n    return result;\n}", "{\n    long[] result = new long[k];\n\
    \    priority_queue!(long)(\"a > b\", result);\n    foreach(elem; arr)\n    {\n\
    \        if(result.length < k)\n        {\n            result.put(elem);\n   \
    \     }\n        else\n        {\n            if(elem > result.front)\n      \
    \      {\n                result.popFront();\n                result.put(elem);\n\
    \            }\n        }\n    }\n    return result.data;\n}", "{\n    if (arr.length\
    \ < k)\n        return arr;\n    // init array\n    long[] maxs = new long[(int)k];\n\
    \    // init heap\n    std.priority_queue!(long[])();\n    foreach (i, v; arr)\n\
    \    {\n        long min = maxs[0];\n        if (min > v)\n            continue;\n\
    \        maxs[0] = v;\n        // make heap\n        std.make_heap(maxs.ptr, maxs.ptr\
    \ + k);\n    }\n    // sort array\n    std.sort(maxs.ptr, maxs.ptr + k);\n   \
    \ return maxs;\n}", "{\n    int n = arr.length;\n    if (n == k)\n        return\
    \ arr;\n    else if (k == 1)\n    {\n        auto max = arr[0];\n        for (int\
    \ i = 1; i < n; i++)\n            max = max(max, arr[i]);\n        return [max];\n\
    \    }\n    else\n    {\n        sort(arr);\n        long[] res = new long[k];\n\
    \        for (int i = 0; i < k; i++)\n            res[i] = arr[n - i - 1];\n \
    \       return res;\n    }\n}", "{\n    long[] result = new long[(int)k];\n  \
    \  sort(arr);\n    arr = arr.array();\n    for (int i = (int)k - 1; i >= 0; i--)\
    \ {\n        result[i] = arr[i];\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[cast(int)k];\n    long p = 0L;\n    long t;\n    if (k >=\
    \ arr.length)\n    {\n        arr.sort;\n        return arr;\n    }\n    while\
    \ (p < k)\n    {\n        long max = arr[cast(int)p];\n        foreach (i; p+1..arr.length)\n\
    \        {\n            if (arr[cast(int)i] > max)\n            {\n          \
    \      max = arr[cast(int)i];\n                t = i;\n            }\n       \
    \ }\n        result[cast(int)p] = max;\n        arr[cast(int)t] = arr[cast(int)p];\n\
    \        arr[cast(int)p] = max;\n        p++;\n    }\n    return result;\n}",
  "{\n    return qsort(arr)[$ - (cast(size_t)k) .. $];\n}", "{\n    arr.sort;\n  \
    \  long[] ret = new long[k];\n    for (size_t i = arr.length - k; i < arr.length;\
    \ i++)\n    {\n        ret[i - arr.length + k] = arr[i];\n    }\n    return ret;\n\
    }", "{\n    auto size = max(0L, min(k, arr.length));\n    auto sorted = arr.dup.sort();\n\
    \    return sorted[$ - size .. $];\n}", "{\n    /*\n        We are going to use\
    \ a min heap to keep track of the maximum\n        k numbers in the array. This\
    \ algorithm runs in O(N*log(k)) time\n        complexity.", "{\n    return quickSelect(arr,\
    \ 0, arr.length - 1, (int)k);\n}", "{\n    quickSort(arr, 0, arr.length - 1);\n\
    \    arr = arr[arr.length - k .. $];\n    return arr;\n}", "{\n    long[] result\
    \ = new long[(int)k];\n    int cntr = 0;\n    int j = 0;\n    int[][] arr2 = new\
    \ int[arr.length][2];\n    for (int i = 0; i < arr.length; i++)\n    {\n     \
    \   arr2[i][0] = (int)arr[i];\n        arr2[i][1] = i;\n    }\n    Arrays.sort(arr2,\
    \ new Comparator<int[]>() {\n        @Override\n        public int compare(int[]\
    \ o1, int[] o2) {\n            if (o1[0] == o2[0]) {\n                return o1[1]\
    \ - o2[1];\n            }\n            return o2[0] - o1[0];\n        }\n    });\n\
    \    while (cntr < arr.length && j < k)\n    {\n        result[j] = arr2[cntr][0];\n\
    \        cntr++;\n        j++;\n    }\n    return result;\n}", "{\n    long[]\
    \ ret;\n    ret.length = cast(int)k;\n    k = min(k, cast(long)arr.length);\n\
    \    assert(k > 0);\n    foreach(i, elt; arr)\n    {\n        const bool bInsert\
    \ = (ret.length == 0) || (elt > ret[$-1]);\n        const bool bDelete = (ret.length\
    \ == k) && (elt < ret[0]);\n        if(bInsert)\n        {\n            ret ~=\
    \ elt;\n            ret.sort;\n        }\n        else if(bDelete)\n        {\n\
    \            ret[0 .. 1] = ret[1 .. $];\n        }\n    }\n    return ret;\n}",
  "{\n    const int len = arr.length;\n    const int m = min(len, k);\n    long[]\
    \ res = new long[m];\n    int i = 0;\n    int j = 0;\n    foreach(a; arr)\n  \
    \  {\n        if(res[i] < a)\n        {\n            res[i] = a;\n           \
    \ int t = i;\n            while(t > 0 && res[t - 1] < res[t])\n            {\n\
    \                swap(res[t - 1], res[t]);\n                t--;\n           \
    \ }\n            i = (i + 1) % m;\n        }\n    }\n    return res;\n}\n/*\n\
    \    Test\n*/", "{\n    const long N = arr.length;\n    if (k == N) return arr;\n\
    \    if (k > N) k = N;\n    long[] result = new long[k];\n    long j = 0;\n  \
    \  for (long i = N-1; i >= N-k; i--) \n    {\n        result[j] = arr[i];\n  \
    \      j++;\n    }\n    return result;\n}", "{\n    k = min(k, arr.length);\n\
    \    if (k == 0) return new long[0];\n    long[] result = new long[k];\n    result[0]\
    \ = arr[0];\n    int idx = 1;\n    for (int i = 1; i < arr.length; i++)\n    {\n\
    \        if (arr[i] > result[0])\n        {\n            if (idx < k)\n      \
    \      {\n                result[idx] = arr[i];\n                idx++;\n    \
    \        }\n            else\n            {\n                for (int j = 0; j\
    \ < k; j++)\n                {\n                    if (result[j] < result[j +\
    \ 1])\n                    {\n                        result[j] = result[j + 1];\n\
    \                    }\n                    else break;\n                }\n \
    \               result[k - 1] = arr[i];\n            }\n        }\n    }\n   \
    \ return result;\n}", "{\n    long[] temp = new long[k];\n    long i = 0L;\n \
    \   long j = 0L;\n    long n = arr.length;\n    for (; i < n; i++)\n    {\n  \
    \      if (arr[i] > temp[j])\n        {\n            if (j < k - 1L)\n       \
    \     {\n                j++;\n                temp[j] = arr[i];\n           \
    \ }\n            else\n            {\n                temp[j] = arr[i];\n    \
    \            for (j = 0L; j < k; j++)\n                {\n                   \
    \ long a = temp[j];\n                    long b = temp[j + 1L];\n            \
    \        if (a > b)\n                    {\n                        long c = temp[j];\n\
    \                        temp[j] = temp[j + 1L];\n                        temp[j\
    \ + 1L] = c;\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return temp;\n}", "{\n    struct max_item\n    {\n        long\
    \ value;\n        long index;\n    };\n    const size_t N = (size_t)k;\n    long\
    \ length = (long)arr.length;\n    if (N > length) return arr;\n    auto max_arr\
    \ = new max_item[](N);\n    max_arr[0].value = arr[0];\n    max_arr[0].index =\
    \ 0;\n    for (long i = 1; i < N; ++i)\n    {\n        max_arr[i].value = max(arr[i],\
    \ max_arr[i - 1].value);\n        max_arr[i].index = i;\n    }\n    for (long\
    \ i = N; i < length; ++i)\n    {\n        if (arr[i] > max_arr[N - 1].value)\n\
    \        {\n            max_arr[N - 1].value = arr[i];\n            max_arr[N\
    \ - 1].index = i;\n            for (long j = N - 1; j > 0; --j)\n            {\n\
    \                if (max_arr[j].value > max_arr[j - 1].value)\n              \
    \  {\n                    std.swap(max_arr[j], max_arr[j - 1]);\n            \
    \    }\n                else\n                {\n                    break;\n\
    \                }\n            }\n        }\n    }\n    auto result = new long[](N);\n\
    \    foreach (item; max_arr)\n    {\n        result[item.index] = item.value;\n\
    \    }\n    return result;\n}", "{\n    long[] res = new long[k];\n    long[]\
    \ temp;\n    if (k <= 0) \n    {\n        return res;\n    }\n    temp = arr[0..(k\
    \ + 1)];\n    temp.sort();\n    for (long i = k; i < arr.length; i++) \n    {\n\
    \        if (arr[i] > temp[0]) \n        {\n            temp[0] = arr[i];\n  \
    \          temp.sort();\n        }\n    }\n    res = temp[0..k];\n    return res;\n\
    }", "{\n    assert (arr.length > 0);\n    return arr[0..int(k)].sort[$-1];\n}",
  "{\n    int len = arr.length;\n    std.sort(arr);\n    long[] max = new long[k];\n\
    \    for (int i = len - 1; i >= len - k; i--) \n    {\n        max[len - i - 1]\
    \ = arr[i];\n    }\n    return max;\n}", "{\n    int len = arr.length;\n    long[]\
    \ retArr = new long[(int)k];\n    //retArr = heapSort(arr);\n    retArr = quickSort(arr);\n\
    \    return retArr;\n}", "{\n    long[] ret = new long[(int)k];\n    int i, j;\n\
    \    long temp;\n    for (i = 0; i < k; i++)\n        ret[i] = arr[i];\n    for\
    \ (i = k / 2; i >= 0; i--) \n    {\n        for (j = i; j < k;)\n        {\n \
    \           long left = 2 * j + 1;\n            long right = 2 * j + 2;\n    \
    \        long max = j;\n            if (left < k && ret[(int)left] > ret[(int)max])\n\
    \                max = left;\n            if (right < k && ret[(int)right] > ret[(int)max])\n\
    \                max = right;\n            if (max == j)\n                break;\n\
    \            temp = ret[(int)j];\n            ret[(int)j] = ret[(int)max];\n \
    \           ret[(int)max] = temp;\n            j = max;\n        }\n    }\n  \
    \  for (i = k; i < arr.length; i++)\n    {\n        if (arr[i] > ret[0])\n   \
    \     {\n            ret[0] = arr[i];\n            for (j = 0; j < k;)\n     \
    \       {\n                long left = 2 * j + 1;\n                long right\
    \ = 2 * j + 2;\n                long max = j;\n                if (left < k &&\
    \ ret[(int)left] > ret[(int)max])\n                    max = left;\n         \
    \       if (right < k && ret[(int)right] > ret[(int)max])\n                  \
    \  max = right;\n                if (max == j)\n                    break;\n \
    \               temp = ret[(int)j];\n                ret[(int)j] = ret[(int)max];\n\
    \                ret[(int)max] = temp;\n                j = max;\n           \
    \ }\n        }\n    }\n    //for (i = 0; i < k / 2; i++)\n    //{\n    //    temp\
    \ = ret[i];\n    //    ret[i] = ret[(int)(k - i - 1)];\n    //", "{\n    if (arr.length\
    \ == k) \n    {\n        return arr;\n    }\n    else if (arr.length < k) \n \
    \   {\n        return new long[0];\n    }\n    else \n    {\n        long[] lk\
    \ = new long[to!int(k)];\n        long max = arr[0];\n        int lkIndex = 0;\n\
    \        lk[lkIndex] = max;\n        for (int i = 1; i < arr.length; i++) \n \
    \       {\n            if (arr[i] >= max) \n            {\n                max\
    \ = arr[i];\n                lk[lkIndex] = max;\n                lkIndex++;\n\
    \                if (lkIndex == lk.length) \n                {\n             \
    \       break;\n                }\n            }\n        }\n        return lk;\n\
    \    }\n}", "{\n    long[] tempres = new long[k];\n    long[] res = new long[k];\n\
    \    foreach(i,d; 0..k) tempres[i] = d;\n    long max = -10000;\n    long index\
    \ = 0;\n    foreach(i,d; arr)\n    {\n        if(d > max)\n        {\n       \
    \     max = d;\n            index = i;\n        }\n    }\n    tempres[0] = arr[index];\n\
    \    arr[index] = -1000;\n    foreach(i,d; 1..k)\n    {\n        long max = -10000;\n\
    \        long index = 0;\n        foreach(j,e; arr)\n        {\n            if(e\
    \ > max)\n            {\n                max = e;\n                index = j;\n\
    \            }\n        }\n        tempres[i] = arr[index];\n        arr[index]\
    \ = -1000;\n    }\n    foreach(i,d; tempres)\n    {\n        res[i] = d;\n   \
    \ }\n    return res;\n}", "{\n    if (arr.length == 0)\n        return new long[0];\n\
    \    \n    long[] result = new long[(int)k];\n    int resultIndex = 0;\n    int\
    \ arrIndex = 0;\n    int i = 0;\n    while (arrIndex < arr.length && k > 0)\n\
    \    {\n        if (resultIndex == k)\n        {\n            if (arr[arrIndex]\
    \ < result[0])\n            {\n                arrIndex++;\n                continue;\n\
    \            }\n            else\n            {\n                resultIndex =\
    \ 0;\n                continue;\n            }\n        }\n        else\n    \
    \    {\n            if (arr[arrIndex] > result[resultIndex])\n            {\n\
    \                for (int j = 0; j < resultIndex; j++)\n                {\n  \
    \                  if (arr[arrIndex] < result[j])\n                    {\n   \
    \                     continue;\n                    }\n                    else\n\
    \                    {\n                        for (int l = 0; l < j; l++)\n\
    \                        {\n                            result[l] = result[l +\
    \ 1];\n                        }\n                        result[j] = arr[arrIndex];\n\
    \                        arrIndex++;\n                        break;\n       \
    \             }\n                }\n            }\n            else\n        \
    \    {\n                result[resultIndex] = arr[arrIndex];\n               \
    \ arrIndex++;\n                resultIndex++;\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    if (k == 0) return [];\n    long[] out = new\
    \ long[k];\n    long[] a = arr.sort();\n    out[0] = a[$ - 1];\n    foreach (i,\
    \ v; a[$ - k + 1 .. $])\n    {\n        out[i] = v;\n    }\n    return out;\n}",
  "{\n    long[] result = new long[(int)k];\n    int[] indexes = new int[(int)k];\n\
    \    long[] mins = new long[(int)k];\n    for (int i = 0; i < k; i++) {\n    \
    \    indexes[i] = i;\n        mins[i] = arr[i];\n    }\n    for (int i = k; i\
    \ < arr.length; i++) {\n        int maxIndex = 0;\n        for (int j = 1; j <\
    \ k; j++) {\n            if (mins[j] > mins[maxIndex]) {\n                maxIndex\
    \ = j;\n            }\n        }\n        if (arr[i] < mins[maxIndex]) {\n   \
    \         continue;\n        }\n        indexes[maxIndex] = i;\n        mins[maxIndex]\
    \ = arr[i];\n    }\n    int index = 0;\n    for (int i = 0; i < k; i++) {\n  \
    \      result[index++] = arr[indexes[i]];\n    }\n    return result;\n}", "{\n\
    \    long[] max = new long[cast(int)k];\n    int maxIndex = cast(int)k - 1;\n\
    \    for (long elem; elem = arr.popFront;) \n    {\n        for (int i = maxIndex;\
    \ i >= 0; i--) \n        {\n            if (elem <= max[i]) \n            {\n\
    \                if (i == 0) \n                {\n                    continue;\n\
    \                }\n                continue;\n            }\n            max.insert(i,\
    \ elem);\n            max.popBack;\n            break;\n        }\n    }\n   \
    \ return max;\n}", "{\n    sort(arr);\n    return arr[arr.length - k .. $];\n}",
  "{\n    long[] sorted = new long[arr.length];\n    if (k <= 0)\n        return new\
    \ long[0];\n    if (k == 1) {\n        if (arr.length == 1)\n            return\
    \ arr;\n        else {\n            long max = arr[0];\n            for (int i\
    \ = 1; i < arr.length; i++) {\n                if (arr[i] > max)\n           \
    \         max = arr[i];\n            }\n            return [max];\n        }\n\
    \    }\n    if (k >= arr.length)\n        return arr;\n    for (int i = 0; i <\
    \ arr.length; i++) {\n        long j = i;\n        while (j > 0 && arr[j - 1]\
    \ < arr[j]) {\n            long tmp = arr[j];\n            arr[j] = arr[j - 1];\n\
    \            arr[j - 1] = tmp;\n            j--;\n        }\n    }\n    for (int\
    \ i = 0; i < k; i++) {\n        sorted[i] = arr[i];\n    }\n    return sorted;\n\
    }", "{\n    List!long maxK = new List!long;\n    foreach(value; arr)\n    {\n\
    \        maxK.insert(abs(value))[0..$] = abs(value);\n        if(maxK.length >\
    \ k)\n        {\n            maxK.remove(maxK.length - 1);\n        }\n    }\n\
    \    foreach(index, value; maxK)\n    {\n        maxK[index] = -value;\n    }\n\
    \    return maxK.sort().take(k).array;\n}", "{\n    if (k > arr.length) \n   \
    \ {\n        throw new Exception(\"k is greater than the length of the array\"\
    );\n    }\n    auto r = new long[k];\n    for (int i = 0; i < k; i++)\n    {\n\
    \        r[i] = arr[i];\n    }\n    r.sort();\n    for (int i = k; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] > r[0])\n        {\n            r[0] = arr[i];\n\
    \            r.sort();\n        }\n    }\n    return r;\n}", "{\n    auto n =\
    \ arr.length;\n    long[] copy = arr.dup;\n    sort(copy);\n    return copy[$-k..$];\n\
    }", "{\n    long index;\n    long[] result = new long[k];\n    for (index = 0L;\
    \ index < k; index++) \n    {\n        result[index] = -std.int.max;\n    }\n\
    \    for (index = 0L; index < arr.length; index++) \n    {\n        if (arr[index]\
    \ > result[k - 1L]) \n        {\n            result[k - 1L] = arr[index];\n  \
    \          result.sort();\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[(int)k];\n    long temp;\n    long i, j;\n    long smallerIndex;\n\
    \    for (i = 0; i < k; i++) \n    {\n        smallerIndex = i;\n        for (j\
    \ = i + 1; j < arr.length; j++) \n        {\n            if (arr[(int)j] > arr[(int)smallerIndex])\
    \ \n            {\n                smallerIndex = j;\n            }\n        }\n\
    \        if (smallerIndex != i) \n        {\n            temp = arr[(int)i];\n\
    \            arr[(int)i] = arr[(int)smallerIndex];\n            arr[(int)smallerIndex]\
    \ = temp;\n        }\n        result[(int)i] = arr[(int)i];\n    }\n    return\
    \ result;\n}", "{\n    import std.array;\n    auto result = new long[k];\n   \
    \ foreach(idx, el; arr)\n    {\n        if(el > result[$-1])\n        {\n    \
    \        auto l = idx;\n            auto r = k - 1;\n            while(l < r)\n\
    \            {\n                auto m = (l + r) / 2;\n                if(result[m]\
    \ >= el)\n                    l = m + 1;\n                else\n             \
    \       r = m;\n            }\n            array.insert(result, r, el);\n    \
    \        array.remove(result, k);\n        }\n    }\n    return result;\n}", "{\n\
    \    return std.sort(arr.takeExactly(k));\n}", "{\n    // arr.sort();\n    //\
    \ \n    // const auto sz = size_t(k);\n    // \n    // return arr[arr.length -\
    \ sz .. arr.length];\n    // \n    // \n    // \n    // const auto len = arr.length;\n\
    \    // const auto sz = size_t(k);\n    // \n    // if (sz == len)\n    // {\n\
    \    //     return arr.sort();\n    // }\n    // \n    // if (sz == 1)\n    //\
    \ {\n    //     long mx = arr[0];\n    //     for (size_t i = 1; i < len; ++i)\n\
    \    //     {\n    //         mx = max(mx, arr[i]);\n    //     }\n    // \n \
    \   //     return [mx];\n    // }\n    // \n    // long[] res;\n    // res.length\
    \ = sz;\n    // \n    // auto j = sz - 1;\n    // \n    // for (size_t i = len\
    \ - 1; i >= len - sz; --i)\n    // {\n    //     res[j--] = arr[i];\n    // }\n\
    \    // \n    // for (size_t i = len - sz - 1; i < len; --i)\n    // {\n    //\
    \     if (arr[i] > res[0])\n    //     {\n    //         // replace smallest element\
    \ in result array\n    //         res[0] = arr[i];\n    //         for (size_t\
    \ j = 1; j < sz; ++j)\n    //         {\n    //             if (res[j - 1] > res[j])\n\
    \    //             {\n    //                 // bubble up\n    //           \
    \      std.swap(res[j - 1], res[j]);\n    //             }\n    //           \
    \  else\n    //             {\n    //                 break;\n    //         \
    \    }\n    //         }\n    //     }\n    // }\n    // \n    // return res;\n\
    \    // \n    const auto len = arr.length;\n    const auto s", "{\n    long[]\
    \ result = new long[k];\n    foreach(i; 0 .. k)\n    {\n        long index = 0;\n\
    \        long max = arr[0];\n        foreach(j; 1 .. arr.length)\n        {\n\
    \            if(arr[j] > max)\n            {\n                max = arr[j];\n\
    \                index = j;\n            }\n        }\n        result[i] = max;\n\
    \        arr[index] = long.min;\n    }\n    sort(result);\n    return result;\n\
    }", "{\n    if (arr.length == k)\n        return arr;\n    \n    int startIndex\
    \ = 0;\n    int endIndex = arr.length - 1;\n    int requiredSize = (int)k;\n \
    \   while (endIndex > startIndex)\n    {\n        int pivotIndex = partition(arr,\
    \ startIndex, endIndex);\n        if (pivotIndex < requiredSize)\n        {\n\
    \            startIndex = pivotIndex + 1;\n        }\n        else if (pivotIndex\
    \ > requiredSize)\n        {\n            endIndex = pivotIndex - 1;\n       \
    \ }\n        else\n        {\n            return slice(arr, 0, (int)k);\n    \
    \    }\n    }\n    return slice(arr, 0, (int)k);\n}", "{\n    if (k == 0)\n  \
    \      return new long[0];\n    if (k == arr.length)\n        return arr;\n  \
    \  long[] result = new long[cast(int)k];\n    for (int i = 0; i < result.length;\
    \ i++)\n        result[i] = -INFINITY;\n    foreach (int i, long num; arr)\n \
    \   {\n        if (num > result[0])\n        {\n            result[0] = num;\n\
    \            result.sort(cast(int a, int b) => result[a] > result[b] ? -1 : 1);\n\
    \        }\n    }\n    return result;\n}", "{\n    if (arr.length < k)\n     \
    \   return null;\n    else if (arr.length == k)\n        return arr;\n    \n \
    \   if (k == 1)\n    {\n        auto aMax = arr[0];\n        foreach (i, a; arr)\n\
    \            if (a > aMax)\n                aMax = a;\n        return [aMax];\n\
    \    }\n    \n    size_t n = arr.length;\n    // we need to find k largest elements;\n\
    \    long[] maxArr = new long[k];\n    for (int i = 0; i < k; i++)\n        maxArr[i]\
    \ = arr[i];\n    \n    for (int i = 0; i < k/2; i++)\n    {\n        if (maxArr[2*i+1]\
    \ > maxArr[2*i])\n            swap(maxArr[2*i], maxArr[2*i+1]);\n        if (maxArr[2*i+2]\
    \ > maxArr[2*i])\n            swap(maxArr[2*i], maxArr[2*i+2]);\n    }\n    \n\
    \    for (int i = k; i < n; i++)\n    {\n        if (arr[i] > maxArr[0])\n   \
    \     {\n            maxArr[0] = arr[i];\n            // restore heap\n      \
    \      int curr = 0;\n            while (2*curr+1 < k)\n            {\n      \
    \          auto j = 2*curr+1;\n                if (j+1 < k && maxArr[j+1] > maxArr[j])\n\
    \                    j++;\n                if (maxArr[curr] > maxArr[j])\n   \
    \                 break;\n                swap(maxArr[curr], maxArr[j]);\n   \
    \             curr = j;\n            }\n        }\n    }\n    \n    return maxArr;\n\
    }", "{\n    long[] sorted = sort(arr);\n    long[] result = new long[k];\n   \
    \ int c = 0;\n    int l = arr.length - 1;\n    while (c < k)\n    {\n        result[c]\
    \ = sorted[l];\n        l--;\n        c++;\n    }\n    return result;\n}", "{\n\
    \    import std.algorithm.comparison : sort;\n    long[] sortedArray = arr.sort();\n\
    \    return sortedArray[arr.length - k .. $];\n}", "{\n    long[] temp = new long[k];\n\
    \    long[] ret = new long[k];\n    for (long i = 0L; i < k; i++)\n    {\n   \
    \     temp[i] = arr[i];\n    }\n    qsort(temp);\n    for (long i = k; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] > temp[0])\n        {\n            temp[0] =\
    \ arr[i];\n            qsort(temp);\n        }\n    }\n    for (long i = 0L; i\
    \ < k; i++)\n    {\n        ret[i] = temp[i];\n    }\n    return ret;\n}", "{\n\
    \    int length = arr.length;\n    k = min(k, length);\n    return insertionSort(arr,\
    \ k);\n}", "{\n    return arr[$-k .. $];\n}", "{\n    sort(arr);\n    long[] result\
    \ = new long[k];\n    for (long i = 0; i < k; i++) \n    {\n        result[i]\
    \ = arr[arr.length - 1 - i];\n    }\n    return result;\n}", "{\n    auto s =\
    \ sort(arr);\n    return s[arr.length - k .. $];\n}", "{\n    if (k <= 0)\n  \
    \      return new long[0];\n    if (k >= arr.length)\n        return arr;\n  \
    \  long[] heap = new long[k];\n    foreach (i, val; arr)\n    {\n        if (i\
    \ < k)\n        {\n            heap[i] = val;\n            up(heap, i);\n    \
    \    }\n        else\n        {\n            if (val > heap[0])\n            {\n\
    \                heap[0] = val;\n                down(heap, 0);\n            }\n\
    \        }\n    }\n    return heap;\n}", "{\n    long[] res = new long[(int)k];\n\
    \    for (long i = 0; i < k; i++) \n    {\n        res[(int)i] = arr[(int)i];\n\
    \    }\n    sort(res);\n    for (long i = k; i < arr.length; i++) \n    {\n  \
    \      long j = 0;\n        while (j < k && res[(int)j] > arr[(int)i]) \n    \
    \    {\n            j++;\n        }\n        if (j < k) \n        {\n        \
    \    memmove(res, (int)j, res, (int)(j + 1), (int)(k - j - 1));\n            res[(int)j]\
    \ = arr[(int)i];\n        }\n    }\n    return res;\n}", "{\n    long[] temp =\
    \ new long[k];\n    int n = arr.length;\n    for (int i = 0; i < k; i++) {\n \
    \       long max = arr[i];\n        int index = i;\n        for (int j = i + 1;\
    \ j < n; j++) {\n            if (arr[j] > max) {\n                max = arr[j];\n\
    \                index = j;\n            }\n        }\n        temp[i] = max;\n\
    \        arr[index] = arr[i];\n        arr[i] = max;\n    }\n    return temp;\n\
    }", "{\n    long[] bucket = new long[1001];\n    foreach(i; arr) bucket[i + 1000]++;\n\
    \    long[] res = new long[k];\n    k--;\n    foreach(i; 1000 - k .. 1001)\n \
    \   {\n        while(bucket[i]-- > 0)\n        {\n            res[k--] = i - 1000;\n\
    \            if(k < 0) return res;\n        }\n    }\n    return res;\n}", "{\n\
    \    long len = arr.length;\n    if (k == 0)\n        return [];\n    else if\
    \ (k >= len)\n        return arr;\n    else\n    {\n        long[] res = [uninitialized];\n\
    \        for (int i = 0; i < k; i++)\n            res ~= arr[i];\n        res\
    \ = res.sort();\n        for (int i = k; i < len; i++)\n        {\n          \
    \  if (arr[i] > res[0])\n            {\n                res[0] = arr[i];\n   \
    \             res = res.sort();\n            }\n        }\n        return res;\n\
    \    }\n}", "{\n    if (k == 0L)\n        return new long[0L];\n    \n    long[]\
    \ max = new long[k];\n    foreach (i, e; arr)\n    {\n        long j = i;\n  \
    \      while (j > 0L && e > max[j - 1L])\n        {\n            max[j] = max[j\
    \ - 1L];\n            j--;\n        }\n        max[j] = e;\n    }\n    return\
    \ max;\n}", "{\n    long[] res = new long[cast(int)k];\n    int j = 0;\n    foreach(y;\
    \ arr)\n    {\n        if(j == 0)\n        {\n            res[j] = y;\n      \
    \      j++;\n        }\n        else\n        {\n            if(y > res[j-1])\n\
    \            {\n                res[j] = y;\n                j++;\n          \
    \  }\n            else\n            {\n                for(int i = 0; i < j; i++)\n\
    \                {\n                    if(y > res[i])\n                    {\n\
    \                        for(int h = j; h > i; h--)\n                        {\n\
    \                            res[h] = res[h-1];\n                        }\n \
    \                       res[i] = y;\n                        break;\n        \
    \            }\n                }\n            }\n        }\n        if(j == k)\n\
    \        {\n            break;\n        }\n    }\n    return res;\n}", "{\n  \
    \  sort(arr);\n    long[] result = new long[k];\n    for (long i = 0; i < k; i++)\n\
    \    {\n        result[i] = arr[arr.length - 1 - i];\n    }\n    return result;\n\
    }", "{\n    long[] copy = new long[arr.length];\n    long length = arr.length\
    \ - k;\n    long min;\n    long minIndex;\n    int i = 0;\n    int j = 0;\n  \
    \  int count = 0;\n    int copySize = 0;\n    copy = copy(arr);\n    while (count\
    \ != length)\n    {\n        min = copy[0];\n        minIndex = 0;\n        for\
    \ (i = 0; i < copy.length; i++)\n        {\n            if (copy[i] != Long.MIN_VALUE)\n\
    \            {\n                min = copy[i];\n                minIndex = i;\n\
    \                break;\n            }\n        }\n        for (i = 0; i < copy.length;\
    \ i++)\n        {\n            if (copy[i] < min && copy[i] != Long.MIN_VALUE)\n\
    \            {\n                min = copy[i];\n                minIndex = i;\n\
    \            }\n        }\n        copy[minIndex] = Long.MIN_VALUE;\n        count++;\n\
    \    }\n    long[] newArray = new long[k];\n    for (i = 0; i < copy.length; i++)\n\
    \    {\n        if (copy[i] != Long.MIN_VALUE)\n        {\n            newArray[j]\
    \ = copy[i];\n            j++;\n        }\n    }\n    return newArray;\n}", "{\n\
    \    long[] result = new long[(int)k];\n    int[] dict = new int[1001];\n    foreach(long\
    \ num; arr)\n    {\n        dict[(int)num + 1000]++;\n    }\n    int index = 0;\n\
    \    for(int i = 1000; i >= 0; i--)\n    {\n        while(dict[i] > 0)\n     \
    \   {\n            if(index < k)\n            {\n                result[index]\
    \ = i - 1000;\n                index++;\n            }\n            else\n   \
    \         {\n                break;\n            }\n            dict[i]--;\n \
    \       }\n    }\n    return result;\n}", "{\n    long[] a = new long[k];\n  \
    \  long[] ret = new long[k];\n    long[] tmp = new long[arr.length];\n    long\
    \ max = 0L;\n    long index = 0L;\n    long n = 0L;\n    long i = 0L;\n    long\
    \ j = 0L;\n    long arrIdx = 0L;\n    long aIdx = 0L;\n    for (; j < k; j++)\
    \ {\n        tmp[j] = arr[j];\n    }\n    qsort(tmp);\n    for (; i < k; i++)\
    \ {\n        ret[i] = tmp[i];\n    }\n    for (; arrIdx < arr.length; arrIdx++)\
    \ {\n        if (arr[arrIdx] > ret[k - 1L]) {\n            tmp[index] = arr[arrIdx];\n\
    \            qsort(tmp);\n            if (index == k - 1L) {\n               \
    \ for (; aIdx < k; aIdx++) {\n                    ret[aIdx] = tmp[aIdx];\n   \
    \             }\n            }\n            index++;\n        }\n    }\n    return\
    \ ret;\n}", "{\n    int[] sorted = arr.sort.array;\n    long[] max = new long[k];\n\
    \    long j = 0;\n    for (int i = arr.length - 1; i >= 0; i--)\n    {\n     \
    \   if (j == k)\n        {\n            break;\n        }\n        max[j] = sorted[i];\n\
    \        j++;\n    }\n    return max;\n}", "{\n    long[] ret = new long[(int)k];\n\
    \    long[] tmp = new long[arr.length];\n    if (k == 0)\n        return ret;\n\
    \    for (int i = 0; i < arr.length; i++)\n        tmp[i] = arr[i];\n    sort(tmp);\n\
    \    for (int i = 0; i < k; i++)\n        ret[i] = tmp[tmp.length - 1 - i];\n\
    \    return ret;\n}", "{\n    if (k > arr.length) \n    {\n        k = arr.length;\n\
    \    }\n    quickSort(arr, 0, arr.length - 1);\n    return arr[arr.length - cast(int)k\
    \ .. arr.length];\n}", "{\n    if (arr.length == 0 || k < 1 || k > arr.length)\
    \ return new long[0];\n    if (k == arr.length) return arr;\n    long[] max_k\
    \ = new long[(int)k];\n    long[] min_k = new long[(int)k];\n    for (int i =\
    \ 0; i < k; i++) max_k[i] = min_k[i] = arr[i];\n    for (int i = (int)k; i < arr.length;\
    \ i++)\n    {\n        int max_k_i = maxElementIndex(max_k);\n        if (arr[i]\
    \ > max_k[max_k_i]) max_k[max_k_i] = arr[i];\n        int min_k_i = minElementIndex(min_k);\n\
    \        if (arr[i] < min_k[min_k_i]) min_k[min_k_i] = arr[i];\n    }\n    return\
    \ max_k;\n}", "{\n    long[] h = new long[k];\n    long[] res = new long[k];\n\
    \    if (k == 0L) \n    {\n        return res;\n    }\n    if (k == arr.length)\
    \ \n    {\n        sort(arr);\n        return arr;\n    }\n    if (k > arr.length)\
    \ \n    {\n        return res;\n    }\n    auto n = arr.length;\n    int r = 0;\n\
    \    for (long i = 0L; i < k; i++) \n    {\n        h[i] = arr[i];\n    }\n  \
    \  buildHeap(h);\n    for (long i = k; i < n; i++) \n    {\n        long x = arr[i];\n\
    \        if (x > h[0]) \n        {\n            h[0] = x;\n            heapify(h,\
    \ 0L);\n        }\n    }\n    sort(h);\n    for (long i = k - 1L; i >= 0L; i--)\
    \ \n    {\n        res[r] = h[i];\n        r++;\n    }\n    return res;\n}", "{\n\
    \    long[long] maxHeap = new long[1024L];\n    long maxIndex = -1L;\n    foreach(item;\
    \ arr)\n    {\n        if(maxIndex < k - 1L)\n        {\n            ++maxIndex;\n\
    \            maxHeap[maxIndex] = item;\n            shiftUp(maxHeap, maxIndex);\n\
    \        }\n        else if(item > maxHeap[0L])\n        {\n            maxHeap[0L]\
    \ = item;\n            shiftDown(maxHeap, maxIndex);\n        }\n    }\n    long[]\
    \ result = new long[k];\n    result[$ - 1L] = maxHeap[0L];\n    for(long i = 1L;\
    \ i < k; ++i)\n    {\n        maxHeap[0L] = maxHeap[maxIndex];\n        --maxIndex;\n\
    \        shiftDown(maxHeap, maxIndex);\n        result[$ - 1L] = maxHeap[0L];\n\
    \    }\n    return result;\n}", "{\n    // long[] result = new long[k];\n    //\
    \ long[] aux = new long[k];\n    // long val, auxVal;\n    // long n = arr.length;\n\
    \    // assert(k < n);\n    // assert(k >= 0);\n    // assert(n <= 1000);\n  \
    \  // foreach(val; arr)\n    // {\n    //     if(val < -1000 || val > 1000)\n\
    \    //     {\n    //         assert(false);\n    //     }\n    // }\n    // aux[0]\
    \ = arr[0];\n    // for(long i = 1L; i < k; i++)\n    // {\n    //     aux[i]\
    \ = max(aux[i - 1L], arr[i]);\n    // }\n    // for(long i = k; i < n; i++)\n\
    \    // {\n    //     auxVal = arr[i];\n    //     if(auxVal > aux[k - 1L])\n\
    \    //     {\n    //         aux[k - 1L] = auxVal;\n    //         for(long j\
    \ = k - 2L; j >= 0L; j--)\n    //         {\n    //             aux[j] = max(aux[j],\
    \ aux[j + 1L]);\n    //         }\n    //     }\n    // }\n    // return aux;\n\
    \    // \n    //\n    long n = arr.length;\n    long[] result = new long[k];\n\
    \    long[] aux = new long[k];\n    assert(k < n);\n    assert(k >= 0);\n    assert(n\
    \ <= 1000);\n    foreach(val; arr)\n    {\n        if(val < -1000 || val > 1000)\n\
    \        {\n            assert(false);\n        }\n    }\n    aux[0] = arr[0];\n\
    \    for(long i = 1L; i < k; i++)\n    {\n        aux[i] = max(aux[i - 1L], arr[i]);\n\
    \    }\n    for(long i = k; i < n; i++)\n    {\n        auto auxVal = arr[i];\n\
    \        if(auxVal > aux[k -", "{\n    long[] maximums = new long[int(k)];\n \
    \   for (long i = 0; i < k; i++) \n    {\n        maximums[int(i)] = arr[int(i)];\n\
    \    }\n    maximums = array(maximums).sort((a, b) => b - a);\n    for (long i\
    \ = k; i < arr.length; i++) \n    {\n        if (arr[int(i)] < maximums[int(maximums.length\
    \ - 1)]) \n        {\n            continue;\n        }\n        for (long j =\
    \ 0; j < maximums.length; j++) \n        {\n            if (arr[int(i)] > maximums[int(j)])\
    \ \n            {\n                maximums[int(j)] = arr[int(i)];\n         \
    \       maximums = array(maximums).sort((a, b) => b - a);\n                break;\n\
    \            }\n        }\n    }\n    return maximums;\n}", "{\n    import std.array;\n\
    \    long[][] result = new long[][](1, k);\n    long[] res = new long[k];\n  \
    \  long i = 0L;\n    long j = 1L;\n    long ind = 0L;\n    long temp = 0L;\n \
    \   long temp2 = 0L;\n    long count = 0L;\n    for (long n = 0L; n < k; n++)\n\
    \    {\n        result[0][n] = arr[n];\n    }\n    qsort(result[0]);\n    for\
    \ (; i < (arr.length - k); i++)\n    {\n        result[0][0] = arr[k + i];\n \
    \       qsort(result[0]);\n    }\n    for (long z = 0L; z < k; z++)\n    {\n \
    \       res[z] = result[0][z];\n    }\n    return res;\n}", "{\n    int len =\
    \ arr.length;\n    if (k > len)\n        k = len;\n    long[] res = new long[k];\n\
    \    for (int i = 0; i < k; i++)\n        res[i] = arr[i];\n    for (int i = k;\
    \ i < len; i++)\n    {\n        int idx = 0;\n        for (int j = 1; j < k; j++)\n\
    \            if (res[j] > res[idx])\n                idx = j;\n        if (arr[i]\
    \ > res[idx])\n            res[idx] = arr[i];\n    }\n    res.sort();\n    return\
    \ res;\n}", "{\n    long[] result = new long[k];\n    if (k < 1 || k > arr.length)\
    \ return result;\n    long[] sorted = arr[0..$];\n    sort(sorted);\n    for (long\
    \ i = 0; i < k; i++)\n    {\n        result[i] = sorted[$ - i - 1];\n    }\n \
    \   return result;\n}", "{\n    long n = arr.length;\n    if (k == n)\n      \
    \  return arr;\n    \n    long top = k - 1;\n    long start = 0;\n    long end\
    \ = n - 1;\n    while (start <= end)\n    {\n        long pivot = arr[end];\n\
    \        long left = start;\n        long right = end - 1;\n        while (left\
    \ <= right)\n        {\n            if (arr[left] < pivot)\n            {\n  \
    \              arr[right] = arr[left];\n                arr[left] = arr[right\
    \ - 1];\n                arr[right - 1] = pivot;\n                right -= 2;\n\
    \            }\n            else\n                left++;\n        }\n       \
    \ if (left == top)\n            break;\n        else if (left < top)\n       \
    \     start = left + 1;\n        else\n            end = left - 1;\n    }\n  \
    \  return arr[0..cast(int)k];\n}", "{\n    auto L = arr.length;\n    if (k < L)\
    \ \n    {\n        struct MyStruct \n        {\n            long p;\n        \
    \    long n;\n        }\n        auto s = new MyStruct[L];\n        foreach (p,\
    \ i; arr)\n        {\n            s[i].p = p;\n            s[i].n = i;\n     \
    \   }\n        sort(s[0 .. L], (a, b) => a.p < b.p);\n        auto idx = new long[k];\n\
    \        foreach (i; 0 .. k)\n        {\n            idx[i] = s[i].n;\n      \
    \  }\n        sort(idx[0 .. k]);\n        auto res = new long[k];\n        foreach\
    \ (i; 0 .. k)\n        {\n            res[i] = arr[idx[i]];\n        }\n     \
    \   return res;\n    }\n    return arr;\n}", "{\n    long[] ret = new long[k];\n\
    \    for (long i = 0; i < k; i++)\n    {\n        long max = arr[0];\n       \
    \ long loc = 0;\n        for (long j = 1; j < arr.length; j++)\n        {\n  \
    \          if (arr[j] > max)\n            {\n                max = arr[j];\n \
    \               loc = j;\n            }\n        }\n        ret[i] = max;\n  \
    \      arr[loc] = -9000;\n    }\n    sort(ret);\n    return ret;\n}", "{\n   \
    \ // Sliding window \n    // Complexity: O(N) time, O(K) space\n    //       \
    \      O(NlogK) time, O(K) space with max heap\n    //             O(N) time,\
    \ O(1) space with selection algorithm (quickSelect)\n    long[] res = new long[k];\n\
    \    long max = INT_MIN;\n    long maxIndex = 0;\n    long min = INT_MAX;\n  \
    \  long minIndex = 0;\n    // find max\n    for (long i = 0; i < k; i++)\n   \
    \ {\n        if (arr[i] > max)\n        {\n            max = arr[i];\n       \
    \     maxIndex = i;\n        }\n    }\n    // find min\n    for (long i = 0; i\
    \ < k; i++)\n    {\n        if (arr[i] < min)\n        {\n            min = arr[i];\n\
    \            minIndex = i;\n        }\n    }\n    res[0] = max;\n    for (long\
    \ i = 1; i < k; i++)\n    {\n        if (i != maxIndex)\n        {\n         \
    \   res[i] = min;\n        }\n        else\n        {\n            res[i] = arr[maxIndex];\n\
    \        }\n    }\n    // sliding window\n    long i = k;\n    while (i < arr.length)\n\
    \    {\n        long index = 0;\n        // delete the largest one\n        if\
    \ (arr[i] < max)\n        {\n            res[index] = arr[i];\n            index++;\n\
    \        }\n        else\n        {\n            max = arr[i];\n            maxIndex\
    \ = i;\n        }\n        // check the largest one\n        long j = index;\n\
    \        while (j < k)\n        {\n            if (res[j] < min)\n           \
    \ {\n                min = res[j];\n                minIndex = j;\n          \
    \  }\n            j++;\n        }\n        if (index != 0)\n        {\n      \
    \      res[index] = max;\n            index++;\n        }\n        // delete the\
    \ smallest one\n        j = index;\n        while (j < k)\n", "{\n    auto pq\
    \ = new std.PriorityQueue!(std.less, long[])();\n    foreach (v; arr)\n    {\n\
    \        pq.insert(v);\n        if (pq.length > k)\n            pq.popFront();\n\
    \    }\n    return pq.data;\n}", "{\n    if (arr.length <= k) return arr;\n  \
    \  long[] max = new long[cast(int)k];\n    for (int i = 0; i < k; i++)\n    {\n\
    \        max[i] = arr[i];\n    }\n    maxheap(max);\n    for (int i = cast(int)k;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] > max[0])\n        {\n     \
    \       max[0] = arr[i];\n            maxheap(max);\n        }\n    }\n    return\
    \ max;\n}", "{\n    // create an array to store results\n    long[] result = new\
    \ long[(int)k];\n    // create a priority queue with a comparator to compare negatives\n\
    \    auto pq = new priority_queue!((a, b) => a > b);\n    // put all integers\
    \ into the priority queue\n    foreach(e; arr)\n    {\n        pq.put(e);\n  \
    \  }\n    // put the next k largest numbers into result\n    foreach(e; 0..k)\n\
    \    {\n        result[e] = pq.get();\n    }\n    // return the result\n    return\
    \ result;\n}", "{\n    const int BUCKET_SIZE = 1001;\n    long[][] buckets = new\
    \ long[BUCKET_SIZE][];\n    long[][] sorted = new long[BUCKET_SIZE][];\n    foreach\
    \ (var num; arr)\n    {\n        if (buckets[num + 1000] is null)\n          \
    \  buckets[num + 1000] = new long[0];\n        buckets[num + 1000] ~= num;\n \
    \   }\n    int index = 0;\n    foreach (var bucket; buckets)\n    {\n        if\
    \ (bucket !is null)\n        {\n            sorted[index] = bucket;\n        \
    \    index++;\n        }\n    }\n    sorted = sorted[0..index];\n    long[] ret\
    \ = new long[0];\n    for (int i = sorted.length - 1; i >= 0; i--)\n    {\n  \
    \      if (ret.length + sorted[i].length <= k)\n            ret ~= sorted[i];\n\
    \        else\n        {\n            ret ~= sorted[i][0..k - ret.length];\n \
    \           break;\n        }\n    }\n    return ret;\n}", "{\n    long[] max_array\
    \ = new long[cast(int)k];\n    auto index = 0;\n    for (i, n; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] < arr[index])\n        {\n            index\
    \ = i;\n        }\n    }\n    max_array[0] = arr[index];\n    foreach (i, e; arr)\n\
    \    {\n        if (max_array.length == k)\n        {\n            break;\n  \
    \      }\n        if (index == i)\n        {\n            continue;\n        }\n\
    \        if (e > max_array[$-1])\n        {\n            max_array[$] = e;\n \
    \       }\n    }\n    max_array.sort(max);\n    return max_array;\n}", "{\n  \
    \  long[] result = new long[k];\n    for (long i = 0; i < k; i++)\n    {\n   \
    \     result[i] = arr[i];\n    }\n    sort(result);\n    for (long i = k; i <\
    \ arr.length; i++)\n    {\n        if (arr[i] > result[0])\n        {\n      \
    \      result[0] = arr[i];\n            sort(result);\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] array = arr.dup;\n    array.sort();\n    long[]\
    \ result = new long[k];\n    size_t i = 0;\n    while (i < k)\n    {\n       \
    \ result[i] = array[$ - 1 - i];\n        i++;\n    }\n    return result;\n}",
  "{\n    std.sort(arr);\n    return arr[arr.length-k..arr.length];\n}", "{\n    //\
    \ Initialize empty array\n    long[] res = new long[k];\n    // Iterate through\
    \ all elements in the array\n    for (long i = 0; i < arr.length; i++)\n    {\n\
    \        // If the current element is less than the last of the result array,\
    \ replace it\n        if (arr[i] > res[$-1])\n        {\n            res[$-1]\
    \ = arr[i];\n            // Sort the result array\n            sort(res);\n  \
    \      }\n    }\n    return res;\n}", "{\n    int N = arr.length;\n    long[]\
    \ heap = new long[k + 1];\n    int heapSize = 0;\n    foreach (i; 0 .. k) {\n\
    \        heap[++heapSize] = arr[i];\n        siftUp(heap, heapSize);\n    }\n\
    \    for (int i = k; i < N; i++) {\n        long cur = arr[i];\n        if (cur\
    \ > heap[1]) {\n            heap[1] = cur;\n            siftDown(heap, heapSize);\n\
    \        }\n    }\n    return heap[1 .. heapSize + 1];\n}", "{\n    int n = cast(int)\
    \ k;\n    int[] A = to!int[](arr);\n    int[] ans = new int[];\n    int[] tmp\
    \ = new int[n];\n    std.algorithm.sort(A);\n    for (int i = 0; i < n; i++) \n\
    \    {\n        tmp[i] = A[i];\n    }\n    int i = n;\n    int start = A[0];\n\
    \    int end = A[n-1];\n    while (i < A.length) \n    {\n        start = A[i];\n\
    \        end = A[i-1];\n        if (abs(start - tmp[0]) >= abs(end - tmp[n-1]))\
    \ \n        {\n            for (int j = 0; j < n; j++) \n            {\n     \
    \           tmp[j] = A[i - j];\n            }\n        }\n        i++;\n    }\n\
    \    return to!long[](tmp);\n}", "{\n    auto res = new long[];\n    foreach(j;\
    \ 0 .. k)\n    {\n        long i = 0L;\n        foreach(q; arr)\n        {\n \
    \           if(q > arr[i])\n            {\n                i = q;\n          \
    \  }\n        }\n        res ~= arr[i];\n        arr[i] = arr[0] - 1;\n    }\n\
    \    return res;\n}", "{\n    int len = arr.length;\n    long[] result = new long[k];\n\
    \    for (int i = 0; i < k; i++)\n    {\n        int maxIndex = i;\n        for\
    \ (int j = i + 1; j < len; j++)\n        {\n            if (arr[j] > arr[maxIndex])\n\
    \            {\n                maxIndex = j;\n            }\n        }\n    \
    \    result[i] = arr[maxIndex];\n        arr[maxIndex] = arr[i];\n        arr[i]\
    \ = result[i];\n    }\n    return result;\n}", "{\n    // you're given k and arr.length\
    \ < 1000\n    // long[] result = new long[arr.length];\n    // int size = 0;\n\
    \    // for (int i = 0; i < arr.length; i++)\n    // {\n    //     if (size ==\
    \ 0)\n    //     {\n    //         result[size++] = arr[i];\n    //     }\n  \
    \  //     else if (size == k)\n    //     {\n    //         int index = 0;\n \
    \   //         for (int j = 1; j < size; j++)\n    //         {\n    //      \
    \       if (result[j] < result[index])\n    //             {\n    //         \
    \        index = j;\n    //             }\n    //         }\n    //         if\
    \ (arr[i] > result[index])\n    //         {\n    //             result[index]\
    \ = arr[i];\n    //         }\n    //     }\n    //     else\n    //     {\n \
    \   //         result[size++] = arr[i];\n    //     }\n    // }\n    // return\
    \ result[..cast(int)k];\n    // TODO: can sort\n    // sort(arr, (x, y) => x >\
    \ y);\n    // return arr[0..cast(int)k];\n    // std.algorithm.sort does not work\
    \ (as of now)\n    long[] sorted = new long[cast(int)k];\n    for (int i = 0;\
    \ i < k; i++)\n    {\n        sorted[i] = arr[i];\n    }\n    for (int i = 0;\
    \ i < k; i++)\n    {\n        for (int j = i + 1; j < k; j++)\n        {\n   \
    \         if (sorted[i] > sorted[j])\n            {\n                long temp\
    \ = sorted[i];\n                sorted[i] = sorted[j];\n                sorted[j]\
    \ = temp;\n            }\n        }\n    }\n    for (int i = cast(int)k; i < arr.length;\
    \ i++)\n    {\n        int j = 0;\n        while (j < k && arr[i] <= sorted[j])\n",
  "{\n    long n = arr.length;\n    long[] sorted = arr[0..n];\n    qsort(sorted);\n\
    \    return sorted[n-k..n];\n}", "{\n    long[] ret = new long[(int)k];\n    int\
    \ max_ind = 0;\n    // find the max element\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] > arr[max_ind])\n        {\n            max_ind\
    \ = i;\n        }\n    }\n    // now we need to split the arr into two\n    //\
    \ first let's see how big the two arrays are\n    int sz = arr.length;\n    int\
    \ sz1 = max_ind;\n    int sz2 = sz - max_ind - 1;\n    // now lets create the\
    \ arrays\n    long[] arr1 = new long[sz1];\n    long[] arr2 = new long[sz2];\n\
    \    // now we'll populate the arrays\n    for (int i = 0; i < sz1; i++)\n   \
    \ {\n        arr1[i] = arr[i];\n    }\n    for (int i = 0; i < sz2; i++)\n   \
    \ {\n        arr2[i] = arr[i + max_ind + 1];\n    }\n    // now we'll do the merge\
    \ sort\n    // we'll keep the first k elements and push the rest into ret\n  \
    \  int in1 = 0;\n    int in2 = 0;\n    for (int i = 0; i < k; i++)\n    {\n  \
    \      if (in1 < sz1 && in2 < sz2)\n        {\n            if (arr1[in1] > arr2[in2])\n\
    \            {\n                ret[i] = arr1[in1];\n                in1++;\n\
    \            }\n            else\n            {\n                ret[i] = arr2[in2];\n\
    \                in2++;\n            }\n        }\n        else if (in1 < sz1)\n\
    \        {\n            ret[i] = arr1[in1];\n            in1++;\n        }\n \
    \       else if (in2 < sz2)\n        {\n            ret[i] = arr2[in2];\n    \
    \        in2++;\n        }\n    }\n    return ret;\n}", "{\n    sort!((a, b) =>\
    \ b - a)(arr);\n    return arr[0..k];\n}", "{\n    size_t n = arr.length;\n  \
    \  size_t i, j;\n    auto revArr = arr.dup;\n    // build the priority queue\n\
    \    for (i = n/2; i > 0; i--)\n    {\n        for (j = i; j*2 < n; j = j*2)\n\
    \        {\n            if (j*2+1 < n && revArr[j*2] < revArr[j*2+1])\n      \
    \          j = j*2+1;\n            if (revArr[j] > revArr[j/2])\n            \
    \    swap(revArr[j], revArr[j/2]);\n        }\n    }\n    // extract the k maximum\
    \ elements\n    for (i = n; i > n-k; i--)\n    {\n        swap(revArr[1], revArr[i]);\n\
    \        for (j = 1; j*2 < i; j = j*2)\n        {\n            if (j*2+1 < i &&\
    \ revArr[j*2] < revArr[j*2+1])\n                j = j*2+1;\n            if (revArr[j]\
    \ > revArr[j/2])\n                swap(revArr[j], revArr[j/2]);\n        }\n \
    \   }\n    revArr = revArr[$-k:$];\n    revArr.reverse;\n    return revArr;\n}",
  "{\n    k = max(0L, min(k, arr.length));\n    qsort(arr);\n    return arr[arr.length\
    \ - (int)k .. $];\n}", "{\n    // This array sortDescending() method works like\
    \ a charm!\n    return arr.sortDescending()[0..(int)k];\n}", "{\n    long[] res\
    \ = new long[k];\n    for (long i = 0; i < k; i++)\n    {\n        res[i] = arr[i];\n\
    \    }\n    sort(res);\n    return res;\n}", "{\n    auto result = new long[k];\n\
    \    long len = arr.length;\n    if (len < k) \n    {\n        k = len;\n    }\n\
    \    auto sorted = sort(arr);\n    for (long i = 0; i < k; i++) \n    {\n    \
    \    result[i] = sorted[len - i - 1];\n    }\n    return result;\n}", "{\n   \
    \ assert(k <= arr.length);\n    assert(k > 0);\n    assert(arr.length <= 1000);\n\
    \    assert(k <= 1000);\n    long maxElem = arr[0];\n    foreach(idx, elem; arr)\n\
    \    {\n        assert(elem <= 1000);\n        assert(elem >= -1000);\n      \
    \  if(elem > maxElem)\n        {\n            maxElem = elem;\n        }\n   \
    \ }\n    long[] result = new long[cast(int)k];\n    auto count = new int[cast(int)maxElem\
    \ + 1];\n    foreach(idx, elem; arr)\n    {\n        count[cast(int)elem]++;\n\
    \    }\n    for(int i = cast(int)maxElem, j = cast(int)k - 1; i >= 0 && j >= 0;\
    \ --i)\n    {\n        while(count[i] > 0 && j >= 0)\n        {\n            result[j--]\
    \ = i;\n            count[i]--;\n        }\n    }\n    return result;\n}", "{\n\
    \    int n = arr.length;\n    if (n < 2) \n        return arr;\n    if (k == n)\
    \ \n        return arr;\n    // Create a min heap of k elements\n    auto pq =\
    \ new PriorityQueue!(a => a, (a, b) => a > b)(arr[0 .. k]);\n    // Replace the\
    \ element if it is greater than the smallest\n    // element in the heap\n   \
    \ foreach (i, el; arr[k .. $]) \n    {\n        if (el > pq.front) \n        {\n\
    \            pq.replaceFront(el);\n        }\n    }\n    return pq.toArray();\n\
    }", "{\n    long[] res = new long[to!long(k)];\n    long[] copy = arr.dup;\n \
    \   quickSort(copy);\n    copy = copy[copy.length - to!long(k) .. copy.length];\n\
    \    return copy;\n}", "{\n    long[] ret = new long[k];\n    assert(arr.length\
    \ >= k);\n    foreach(immutable i, ref j; ret)\n    {\n        ret[i] = arr[i];\n\
    \    }\n    sort(ret);\n    for(long i = k; i < arr.length; i++)\n    {\n    \
    \    if(arr[i] > ret[0])\n        {\n            for(long j = 1; j < k; j++)\n\
    \            {\n                if(arr[i] > ret[j])\n                {\n     \
    \               ret[j - 1] = ret[j];\n                }\n                else\n\
    \                {\n                    ret[j - 1] = arr[i];\n               \
    \     break;\n                }\n            }\n        }\n    }\n    return ret;\n\
    }", "{\n    // You need to return an array of length k that contains the maximum\
    \ \n    // numbers from the given array in a sorted order.\n    long[] r = new\
    \ long[k];\n    const long len = arr.length;\n    if (len <= k)\n    {\n     \
    \   sort(arr);\n        return arr;\n    }\n    else\n    {\n        long[] heap\
    \ = new long[k];\n        int n = k;\n        const int ln = len;\n        int\
    \ i = 0;\n        for (i = 0; i < k; i++)\n        {\n            heap[i] = arr[i];\n\
    \        }\n        buildMaxHeap(heap, k);\n        for (i = k; i < ln; i++)\n\
    \        {\n            if (arr[i] > heap[0])\n            {\n               \
    \ heap[0] = arr[i];\n                maxHeapify(heap, 0, k);\n            }\n\
    \        }\n        for (i = 0; i < k; i++)\n        {\n            r[i] = heap[0];\n\
    \            heap[0] = heap[k - 1];\n            k--;\n            maxHeapify(heap,\
    \ 0, k);\n        }\n        return r;\n    }\n}", "{\n    const size_t n = arr.length;\n\
    \    if (n < k) return arr;\n    if (k == 0) return [];\n    if (k == 1)\n   \
    \ {\n        long m = arr[0];\n        for (size_t i = 1; i < n; ++i)\n      \
    \      m = max(m, arr[i]);\n        return [m];\n    }\n    return [_maximum(arr,\
    \ k)];\n}", "{\n    if (arr.length == 0) return new long[0];\n    if (k == 0)\
    \ return new long[0];\n    if (k >= arr.length) return arr;\n    auto pivotIndex\
    \ = (arr.length + 1) / 2;\n    auto pivot = arr[pivotIndex];\n    auto less =\
    \ [];\n    auto greater = [];\n    foreach (e; arr) {\n        if (e < pivot)\
    \ less ~= e;\n        else if (e > pivot) greater ~= e;\n    }\n    if (less.length\
    \ + 1 == k) return less ~ [pivot];\n    if (less.length >= k) return maximum(less,\
    \ k);\n    if (less.length + 1 + greater.length >= k) return less ~ [pivot] ~\
    \ maximum(greater, k - (less.length + 1));\n    return less ~ [pivot] ~ greater;\n\
    }", "{\n    long i, j, tmp;\n    for (i = 0; i < k; i++) \n    {\n        for\
    \ (j = 0; j < arr.length-i-1; j++) \n        {\n            if (arr[j] > arr[j+1])\
    \ \n            {\n                tmp = arr[j];\n                arr[j] = arr[j+1];\n\
    \                arr[j+1] = tmp;\n            }\n        }\n    }\n    return\
    \ arr[arr.length-k .. arr.length];\n}", "{\n    long[] max = new long[(int)k];\n\
    \    for (long i = 0; i < k; i++)\n    {\n        max[(int)i] = arr[(int)i];\n\
    \    }\n    for (long i = k; i < arr.length; i++)\n    {\n        long smallest\
    \ = arr[(int)k-1];\n        long smallestPos = k-1;\n        for (long j = 0;\
    \ j < k; j++)\n        {\n            if (max[(int)j] < smallest)\n          \
    \  {\n                smallest = max[(int)j];\n                smallestPos = j;\n\
    \            }\n        }\n        if (arr[(int)i] > smallest)\n        {\n  \
    \          max[(int)smallestPos] = arr[(int)i];\n        }\n    }\n    sort!(\"\
    a < b\")(max);\n    return max;\n}", "{\n    long[] result = new long[(int)k];\n\
    \    auto index = 0;\n    foreach(i; arr)\n    {\n        if(index == 0)\n   \
    \     {\n            result[index] = i;\n            index++;\n        }\n   \
    \     else\n        {\n            for(auto j = index - 1; j >= 0; j--)\n    \
    \        {\n                if(i < result[j])\n                {\n           \
    \         result[j + 1] = result[j];\n                    if(j == 0)\n       \
    \             {\n                        result[j] = i;\n                    }\n\
    \                }\n                else\n                {\n                \
    \    result[j + 1] = i;\n                    break;\n                }\n     \
    \       }\n            index++;\n        }\n        if(index > k)\n        {\n\
    \            result = result[1..$];\n        }\n    }\n    return result;\n}",
  "{\n    long[] big = new long[k];\n    long[] ret = new long[k];\n    foreach(i,\
    \ v; arr)\n    {\n        if(k > 0)\n        {\n            long index = 0;\n\
    \            while(index < k && big[index] > v)\n            {\n             \
    \   index++;\n            }\n            if(index < k)\n            {\n      \
    \          big[index..k] = big[index..k-1];\n                big[index] = v;\n\
    \            }\n        }\n    }\n    return big;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
