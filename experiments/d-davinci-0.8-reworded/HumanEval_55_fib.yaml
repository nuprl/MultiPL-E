name: HumanEval_55_fib
language: d
prompt: "import std.math;\n/*\nReturn n-th Fibonacci number.\n    >>> fib(10L)\n \
  \   55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = fib;\n\n    assert(candidate(10L) == 55L);\n\
  \    assert(candidate(1L) == 1L);\n    assert(candidate(8L) == 21L);\n    assert(candidate(11L)\
  \ == 89L);\n    assert(candidate(12L) == 144L);\n}\nvoid main(){}"
completions: ["{\n    if (n < 2)\n    {\n        return n;\n    }\n    return fib(n\
    \ - 1) + fib(n - 2);\n}", "{\n    if (n < 2)\n        return n;\n    else\n  \
    \      return fib(n - 1) + fib(n - 2);\n}\n/*\nReturn the factorial of n.", "{\n\
    \    if (n <= 1L) \n    {\n        return n;\n    }\n    else \n    {\n      \
    \  return fib(n - 1L) + fib(n - 2L);\n    }\n}", "{\n    if (n < 0) \n    {\n\
    \        return -1;\n    }\n    else if (n == 0) \n    {\n        return 0;\n\
    \    }\n    else if (n == 1) \n    {\n        return 1;\n    }\n    else \n  \
    \  {\n        return fib(n - 1) + fib(n - 2);\n    }\n}", "{\n    if (n == 0)\
    \ \n        return 0;\n    else if (n == 1) \n        return 1;\n    else \n \
    \       return fib(n - 1) + fib(n - 2);\n}", "{\n    assert(n >= 0L);\n    if\
    \ (n <= 1L)\n        return n;\n    return fib(n - 1L) + fib(n - 2L);\n}\n/*\n\
    Iterative version of fib.\n    >>> fib_iter(10L)\n    55L\n    >>> fib_iter(1L)\n\
    \    1L\n    >>> fib_iter(8L)\n    21L\n    \n*/\nlong fib_iter(long n) \n{\n\
    \    assert(n >= 0L);\n    if (n <= 1L)\n        return n;\n    long a = 0L;\n\
    \    long b = 1L;\n    long tmp = 0L;\n    for (long i = 2L; i <= n; i++)\n  \
    \  {\n        tmp = a + b;\n        a = b;\n        b = tmp;\n    }\n    return\
    \ b;\n}\n/*\nCreate a roman numeral string from an integer.\n    >>> roman(1)\n\
    \    'I'\n    >>> roman(4)\n    'IV'\n    >>> roman(5)\n    'V'\n    >>> roman(9)\n\
    \    'IX'\n    >>> roman(10)\n    'X'\n    >>> roman(11)\n    'XI'\n    >>> roman(42)\n\
    \    'XLII'\n    >>> roman(64)\n    'LXIV'\n    >>> roman(77)\n    'LXXVII'\n\
    \    >>> roman(123)\n    'CXXIII'\n    >>> roman(138)\n    'CXXXVIII'\n    >>>\
    \ roman(999)\n    'CMXCIX'\n    >>> roman(1002)\n    'MII'\n    >>> roman(1785)\n\
    \    'MDCCLXXXV'\n    >>> roman(1815)\n    'MDCCCXV'\n    >>> roman(1984)\n  \
    \  'MCMLXXXIV'\n    \n*/\nstring roman(long n) \n{\n    assert(n > 0L);\n    struct\
    \ Symbol\n    {\n        long value;\n        string roman;\n    };\n    Symbol\
    \ symbols[] = { {1000", "{\n    if (n < 2)\n    {\n        return n;\n    }\n\
    \    else\n    {\n        return fib(n - 1) + fib(n - 2);\n    }\n}", "{\n\tif\
    \ (n <= 1)\n\t\treturn n;\n\treturn fib(n - 1) + fib(n - 2);\n}\n/*\nCalls ``func``\
    \ for the first ``n`` integers.\n*/", "{\n    long a = 0L;\n    long b = 1L;\n\
    \    long i = 0L;\n    for (i; i < n; i++) {\n        long t = a + b;\n      \
    \  a = b;\n        b = t;\n    }\n    return a;\n}", "{\n\tif (n<=2) return 1;\n\
    \treturn fib(n-1)+fib(n-2);\n}", "{\n    assert(n >= 0L);\n    return (n <= 1L)\
    \ ? n : fib(n - 1L) + fib(n - 2L);\n}", "{\n    if (n < 2) return n;\n    long\
    \ n1 = 0;\n    long n2 = 1;\n    long n3 = n1 + n2;\n    int i = 2;\n    while\
    \ (i < n) \n    {\n        n1 = n2;\n        n2 = n3;\n        n3 = n1 + n2;\n\
    \        i++;\n    }\n    return n3;\n}", "{\n    long a, b;\n    long tmp;\n\
    \    long i;\n    i = 1L;\n    a = 1L;\n    b = 1L;\n    while ((i < n)) \n  \
    \  {\n        tmp = a;\n        a = b;\n        b = tmp + b;\n        i = i +\
    \ 1L;\n    }\n    return a;\n}", "{\n\tif (n < 2) return n;\n\telse return fib(n\
    \ - 1) + fib(n - 2);\n}", "{\n    if (n <= 2L) \n    {\n        return 1L;\n \
    \   } \n    else \n    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n}",
  "    if (n < 0L) \n        return 0L;\n    else if (n == 0L) \n        return 0L;\n\
    \    else if (n == 1L) \n        return 1L;\n    else \n        return fib(n -\
    \ 1L) + fib(n - 2L);", "{\n    if (n <= 1L) return n;\n    return fib(n - 1L)\
    \ + fib(n - 2L);\n}", "{\n    if (n < 2) \n        return n;\n    else \n    \
    \    return fib(n - 1) + fib(n - 2);\n}", "{\n    return (n < 2L) ? n : fib(n\
    \ - 1L) + fib(n - 2L);\n}\n/*\nCompute a length of the list.\n    >>> len([1,\
    \ 2, 3])\n    3\n    >>> len([])\n    0\n    \n*/", "{\n    if (n <= 1L)\n   \
    \     return n;\n    else\n        return fib(n - 1L) + fib(n - 2L);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
