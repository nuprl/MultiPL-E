name: HumanEval_55_fib
language: d
prompt: "import std.math;\n/*\nReturn n-th Fibonacci number.\n    >>> fib(10L)\n \
  \   55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = fib;\n\n    assert(candidate(10L) == 55L);\n\
  \    assert(candidate(1L) == 1L);\n    assert(candidate(8L) == 21L);\n    assert(candidate(11L)\
  \ == 89L);\n    assert(candidate(12L) == 144L);\n}\nvoid main(){}"
completions: ["{\n    if (n < 2)\n    {\n        return n;\n    }\n    return fib(n\
    \ - 1) + fib(n - 2);\n}", "{\n    if (n < 2)\n        return n;\n    else\n  \
    \      return fib(n - 1) + fib(n - 2);\n}\n/*\nReturn the factorial of n.", "{\n\
    \    if (n <= 1L) \n    {\n        return n;\n    }\n    else \n    {\n      \
    \  return fib(n - 1L) + fib(n - 2L);\n    }\n}", "{\n    if (n < 0) \n    {\n\
    \        return -1;\n    }\n    else if (n == 0) \n    {\n        return 0;\n\
    \    }\n    else if (n == 1) \n    {\n        return 1;\n    }\n    else \n  \
    \  {\n        return fib(n - 1) + fib(n - 2);\n    }\n}", "{\n    if (n == 0)\
    \ \n        return 0;\n    else if (n == 1) \n        return 1;\n    else \n \
    \       return fib(n - 1) + fib(n - 2);\n}", "{\n    assert(n >= 0L);\n    if\
    \ (n <= 1L)\n        return n;\n    return fib(n - 1L) + fib(n - 2L);\n}\n/*\n\
    Iterative version of fib.\n    >>> fib_iter(10L)\n    55L\n    >>> fib_iter(1L)\n\
    \    1L\n    >>> fib_iter(8L)\n    21L\n    \n*/\nlong fib_iter(long n) \n{\n\
    \    assert(n >= 0L);\n    if (n <= 1L)\n        return n;\n    long a = 0L;\n\
    \    long b = 1L;\n    long tmp = 0L;\n    for (long i = 2L; i <= n; i++)\n  \
    \  {\n        tmp = a + b;\n        a = b;\n        b = tmp;\n    }\n    return\
    \ b;\n}\n/*\nCreate a roman numeral string from an integer.\n    >>> roman(1)\n\
    \    'I'\n    >>> roman(4)\n    'IV'\n    >>> roman(5)\n    'V'\n    >>> roman(9)\n\
    \    'IX'\n    >>> roman(10)\n    'X'\n    >>> roman(11)\n    'XI'\n    >>> roman(42)\n\
    \    'XLII'\n    >>> roman(64)\n    'LXIV'\n    >>> roman(77)\n    'LXXVII'\n\
    \    >>> roman(123)\n    'CXXIII'\n    >>> roman(138)\n    'CXXXVIII'\n    >>>\
    \ roman(999)\n    'CMXCIX'\n    >>> roman(1002)\n    'MII'\n    >>> roman(1785)\n\
    \    'MDCCLXXXV'\n    >>> roman(1815)\n    'MDCCCXV'\n    >>> roman(1984)\n  \
    \  'MCMLXXXIV'\n    \n*/\nstring roman(long n) \n{\n    assert(n > 0L);\n    struct\
    \ Symbol\n    {\n        long value;\n        string roman;\n    };\n    Symbol\
    \ symbols[] = { {1000", "{\n    if (n < 2)\n    {\n        return n;\n    }\n\
    \    else\n    {\n        return fib(n - 1) + fib(n - 2);\n    }\n}", "{\n\tif\
    \ (n <= 1)\n\t\treturn n;\n\treturn fib(n - 1) + fib(n - 2);\n}\n/*\nCalls ``func``\
    \ for the first ``n`` integers.\n*/", "{\n    long a = 0L;\n    long b = 1L;\n\
    \    long i = 0L;\n    for (i; i < n; i++) {\n        long t = a + b;\n      \
    \  a = b;\n        b = t;\n    }\n    return a;\n}", "{\n\tif (n<=2) return 1;\n\
    \treturn fib(n-1)+fib(n-2);\n}", "{\n    assert(n >= 0L);\n    return (n <= 1L)\
    \ ? n : fib(n - 1L) + fib(n - 2L);\n}", "{\n    if (n < 2) return n;\n    long\
    \ n1 = 0;\n    long n2 = 1;\n    long n3 = n1 + n2;\n    int i = 2;\n    while\
    \ (i < n) \n    {\n        n1 = n2;\n        n2 = n3;\n        n3 = n1 + n2;\n\
    \        i++;\n    }\n    return n3;\n}", "{\n    long a, b;\n    long tmp;\n\
    \    long i;\n    i = 1L;\n    a = 1L;\n    b = 1L;\n    while ((i < n)) \n  \
    \  {\n        tmp = a;\n        a = b;\n        b = tmp + b;\n        i = i +\
    \ 1L;\n    }\n    return a;\n}", "{\n\tif (n < 2) return n;\n\telse return fib(n\
    \ - 1) + fib(n - 2);\n}", "{\n    if (n <= 2L) \n    {\n        return 1L;\n \
    \   } \n    else \n    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n}",
  "    if (n < 0L) \n        return 0L;\n    else if (n == 0L) \n        return 0L;\n\
    \    else if (n == 1L) \n        return 1L;\n    else \n        return fib(n -\
    \ 1L) + fib(n - 2L);", "{\n    if (n <= 1L) return n;\n    return fib(n - 1L)\
    \ + fib(n - 2L);\n}", "{\n    if (n < 2) \n        return n;\n    else \n    \
    \    return fib(n - 1) + fib(n - 2);\n}", "{\n    return (n < 2L) ? n : fib(n\
    \ - 1L) + fib(n - 2L);\n}\n/*\nCompute a length of the list.\n    >>> len([1,\
    \ 2, 3])\n    3\n    >>> len([])\n    0\n    \n*/", "{\n    if (n <= 1L)\n   \
    \     return n;\n    else\n        return fib(n - 1L) + fib(n - 2L);\n}", "{\n\
    \tlong i, a = 0L, b = 1L;\n\tfor (i = 1L; i < n; i += 1L) \n\t{\n\t\tlong c =\
    \ a + b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn b;\n}", "{\n\tlong a, b, fib;\n\
    \tif (n < 2)\n\t\treturn n;\n\telse {\n\t\ta = fib(n - 1);\n\t\tb = fib(n - 2);\n\
    \t\tfib = a + b;\n\t\treturn fib;\n\t}\n}", "{\n    return n == 0 ? 0 : n == 1\
    \ ? 1 : fib(n - 1) + fib(n - 2);\n}", "{\n    if (n == 0L) return 0L;\n    if\
    \ (n == 1L) return 1L;\n    return fib(n - 1L) + fib(n - 2L);\n}", "{\n    if\
    \ (n <= 1L) \n    {\n        return n;\n    } \n    else \n    {\n        return\
    \ fib(n - 1L) + fib(n - 2L);\n    }\n}", "{\n    if (n == 0L)\n    {\n       \
    \ return 0L;\n    }\n    else\n    {\n        return (n == 1L || n == 2L) ? 1L\
    \ : fib(n - 1L) + fib(n - 2L);\n    }\n}", "{\n  if (n <= 1L)\n    return n;\n\
    \  else\n    return fib(n - 1L) + fib(n - 2L);\n}", "{\n    if (n <= 1L) \n  \
    \      return n;\n    else \n        return fib(n - 1L) + fib(n - 2L);\n}", "{\n\
    \    if (n == 0L)\n    {\n        return 0L;\n    }\n    else if (n == 1L)\n \
    \   {\n        return 1L;\n    }\n    else\n    {\n        return fib(n - 1L)\
    \ + fib(n - 2L);\n    }\n}", "{\n    if (n < 2) \n        return n;\n    return\
    \ fib(n - 1) + fib(n - 2);\n}", "{\n    if (n<=1) \n        return n;\n    else\
    \ \n        return fib(n-1) + fib(n-2);\n}\n/*\n    >>> fib_list(10L)\n    [0L,\
    \ 1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L, 34L, 55L]\n    >>> fib_list(1L)\n    [0L,\
    \ 1L]\n    >>> fib_list(8L)\n    [0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L]\n    >>>\
    \ fib_list(0L)\n    [0L]\n*/\nlong[] fib_list(long n) \n{\n    long[] result;\n\
    \    result.length = cast(long)n + 1L;\n    foreach (i; 0..n) \n        result[i]\
    \ = fib(i);\n    return result;\n}", "{\n    if (n == 0L) \n    {\n        return\
    \ 0L;\n    }\n    else if (n == 1L) \n    {\n        return 1L;\n    }\n    else\
    \ \n    {\n        auto F_2 = 0L;\n        auto F_1 = 1L;\n        auto F_n =\
    \ F_2 + F_1;\n        foreach (i; 1L .. n - 1L) \n        {\n            F_2 =\
    \ F_1;\n            F_1 = F_n;\n            F_n = F_2 + F_1;\n        }\n    \
    \    return F_n;\n    }\n}", "{\n    if (n <= 1L) \n        return n;\n    else\n\
    \        return fib(n - 1L) + fib(n - 2L);\n}", "{\n    return n < 2 ? 1 : fib(n\
    \ - 1) + fib(n - 2);\n}", "{\n    if (n <= 1L) \n    {\n        return n;\n  \
    \  } \n    else \n    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n}",
  "{\n    switch (n) {\n      case 0L:\n        return 0L;\n      case 1L:\n     \
    \   return 1L;\n      default:\n        return fib(n - 1L) + fib(n - 2L);\n  \
    \  }\n}", "{\n    if (n <= 1L)\n        return n;\n    else\n        return fib(n\
    \ - 1L) + fib(n - 2L);\n}", "    if (n > 2L) {\n        return fib(n - 1L) + fib(n\
    \ - 2L);\n    }\n    else if (n == 2L) {\n        return 1L;\n    }\n    else\
    \ if (n == 1L) {\n        return 1L;\n    }\n    else {\n        return 0L;\n\
    \    }\n}\n/*\nReturn a list of Fibonacci numbers from 0 to n.\n    >>> fibList(10L)\n\
    \    [0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L, 34L, 55L]\n*/\nlong[] fibList(long\
    \ n) \n    long[] result = new long[(int)(n + 1L)];\n    for (long i = 0L; i <=\
    \ n; i += 1L) {\n        result[(int)(i)] = fib(i);\n    }\n    return result;\n\
    }", "{\n    if (n <= 2L)\n        return 1L;\n    else\n        return fib(n -\
    \ 1L) + fib(n - 2L);\n}\n// Function  for cos(x)\nlong cos(long x)\n{\n    long\
    \ i = 0L;\n    long z = 1L;\n    long y = 0L;\n    long num = 1L;\n    long fact\
    \ = 1L;\n    long cosx = 0L;\n    while (i <= 4L)\n    {\n        z = z * x *\
    \ x;\n        fact = fact * num * (num + 1L);\n        y = z / fact;\n       \
    \ if (i % 2L == 0L)\n            cosx = cosx + y;\n        else\n            cosx\
    \ = cosx - y;\n        i = i + 2L;\n        num = num + 2L;\n    }\n    return\
    \ cosx;\n}\n// Function  for sin(x)\nlong sin(long x)\n{\n    long i = 0L;\n \
    \   long z = x;\n    long y = 0L;\n    long num = 2L;\n    long fact = 2L;\n \
    \   long sinx = 0L;\n    while (i <= 4L)\n    {\n        z = z * x * x;\n    \
    \    fact = fact * num * (num + 1L);\n        y = z / fact;\n        if (i % 2L\
    \ == 0L)\n            sinx = sinx + y;\n        else\n            sinx = sinx\
    \ - y;\n        i = i + 2L;\n        num = num + 2L;\n    }\n    return sinx;\n\
    }\nlong sin2(long x)\n{\n    long sum = 0L;\n    long term = 0L;\n    long mul\
    \ = 0L;\n    long fact = 0L;\n    long i = 0L;\n    long j = 0L;\n    while (i\
    \ <= 4L)\n    {\n        term = x;\n        mul = x;\n        fact = 1L;\n   \
    \     j = 1L;\n        while (j < 2L * i + 1L)\n        {\n            mul = mul\
    \ * x * x;", "{\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n  \
    \      return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}", "{\n\
    \    return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}", "{\n    return n < 2 ?\
    \ n : fib(n - 1) + fib(n - 2);\n}", "{\n    if (n <= 1L)\n    {\n        return\
    \ n;\n    }\n    else\n    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n\
    }", "{\n  if (n < 2) \n  {\n    return n;\n  }\n  else \n  {\n    long fib_n_1\
    \ = fib(n - 1);\n    long fib_n_2 = fib(n - 2);\n    return fib_n_1 + fib_n_2;\n\
    \  }\n}\n/*\nnth fibonacci number\n*/\nlong fibonacci(long n) \n{\n  if (n ==\
    \ 0) \n  {\n    return 0;\n  }\n  else if (n == 1) \n  {\n    return 1;\n  }\n\
    \  else \n  {\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  }\n}\n/*\nCompute\
    \ the nth number in the fibonacci sequence.\n*/\nlong fib(long n) \n{\n  if (n\
    \ < 2) \n  {\n    return n;\n  }\n  else \n  {\n    return fib(n - 1) + fib(n\
    \ - 2);\n  }\n}\n// Compute the nth number in the fibonacci sequence.\nlong fib(long\
    \ n) \n{\n  if (n < 2) \n  {\n    return n;\n  }\n  else \n  {\n    return fib(n\
    \ - 1) + fib(n - 2);\n  }\n}\n/*\nCompute the nth number in the fibonacci sequence.\n\
    */\nlong fib(long n) \n{\n  if (n < 2) \n  {\n    return n;\n  }\n  else \n  {\n\
    \    return fib(n - 1) + fib(n - 2);\n  }\n}\n// Compute the nth number in the\
    \ fibonacci sequence.\nlong fib(long n) \n{\n  if (n < 2) \n  {\n    return n;\n\
    \  }\n  else \n  {\n    return fib(n - 1) + fib(n - 2);\n  }\n}\n/*\nCompute the\
    \ nth number in the fibonacci sequence.\n*/\nlong fib(long n) \n{\n  if (n < 2)\
    \ \n ", "{\n    long i = 1L;\n    long a = 0L;\n    long b = 1L;\n    while (i\
    \ < n) {\n        long tmp = a;\n        a = b;\n        b = tmp + b;\n      \
    \  i = i + 1L;\n    }\n    return a;\n}", "{\n    if (n < 0)\n    {\n        return\
    \ -1;\n    }\n    if (n == 0 || n == 1)\n    {\n        return n;\n    }\n   \
    \ long prev = 0;\n    long curr = 1;\n    foreach(i; 2..n)\n    {\n        long\
    \ temp = curr;\n        curr = prev + curr;\n        prev = temp;\n    }\n   \
    \ return curr;\n}", "{\n    if (n < 3) return 1;\n    return fib(n - 1) + fib(n\
    \ - 2);\n}", "{\n\treturn n <= 2 ? 1 : fib(n - 1) + fib(n - 2);\n}", "{\n    if\
    \ (n < 2) \n    {\n        return n;\n    } \n    else \n    {\n        return\
    \ fib(n - 1) + fib(n - 2);\n    }\n}", "{\n    if (n == 0L)\n        return 0L;\n\
    \    if (n == 1L)\n        return 1L;\n    return fib(n - 1L) + fib(n - 2L);\n\
    }", "{\n    return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n/*\n    >>> f1\n\
    \    4L\n    >>> f2\n    21L\n*/\nlong f1 = fib(3);\nlong f2 = fib(6);", "{\n\
    \    if (n < 2)\n        return n;\n    else\n        return fib(n - 1) + fib(n\
    \ - 2);\n}", "{\n    if (n == 0L)\n    {\n        return 0L;\n    }\n    if (n\
    \ == 1L)\n    {\n        return 1L;\n    }\n    return fib(n - 1L) + fib(n - 2L);\n\
    }", "{\n    if (n <= 2L) return 1L;\n    return fib(n - 1L) + fib(n - 2L);\n}",
  "{\n    long result = 0;\n    if (n <= 1)\n        result = n;\n    else\n     \
    \   result = fib(n - 1) + fib(n - 2);\n    return result;\n}", "{\n    if (n <\
    \ 2) \n    {\n        return n;\n    } \n    else \n    {\n        long a = fib(n\
    \ - 1);\n        long b = fib(n - 2);\n        return a + b;\n    }\n}", "{\n\
    \    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 1;\n    return\
    \ fib(n - 1) + fib(n - 2);\n}", "{\n    long[] fibs = new long[n+1];\n    fibs[0]\
    \ = 0;\n    fibs[1] = 1;\n    foreach (i; 2..n+1) {\n        fibs[i] = fibs[i-1]\
    \ + fibs[i-2];\n    }\n    return fibs[n];\n}", "{\n    if (n < 2)\n    {\n  \
    \      return n;\n    }\n    else\n    {\n        long a = 0L;\n        long b\
    \ = 1L;\n        long i = 2L;\n        while (i < n)\n        {\n            long\
    \ t = a + b;\n            a = b;\n            b = t;\n            i = i + 1L;\n\
    \        }\n        return a + b;\n    }\n}\n/*\nReturn the sum of all primes\
    \ below n.\n    >>> sum_primes(10L)\n    17L\n    >>> sum_primes(2L)\n    2L\n\
    */\nlong sum_primes(long n) \n{\n    long sum = 0L;\n    long i = 2L;\n    while\
    \ (i < n)\n    {\n        if (is_prime(i))\n        {\n            sum = sum +\
    \ i;\n        }\n        i = i + 1L;\n    }\n    return sum;\n}", "{\n    if (n\
    \ < 2)\n        return n;\n    else\n        return fib(n - 1) + fib(n - 2);\n\
    }", "{\n    long a = 0L;\n    long b = 1L;\n    long i = 2L;\n    while (i <=\
    \ n) {\n        auto t = a + b;\n        a = b;\n        b = t;\n        i = i\
    \ + 1L;\n    }\n    return b;\n}", "{\n  long a = 0L;\n  long b = 1L;\n  long\
    \ i = 0L;\n  while (i < n) \n  {\n    long temp = a;\n    a = b;\n    b = temp\
    \ + b;\n    i++;\n  }\n  return a;\n}", "{\n    switch (n) {\n    case 0L: return\
    \ 0L;\n    case 1L: return 1L;\n    default: return fib(n - 1L) + fib(n - 2L);\n\
    \    }\n}", "{\n\treturn (n <= 2) ? 1 : fib(n - 1) + fib(n - 2);\n}", "{\n   \
    \ if (n <= 1L)\n    {\n        return n;\n    }\n    else\n    {\n        return\
    \ fib(n - 1L) + fib(n - 2L);\n    }\n}\n/*\nReturn the n-th Fibonacci number.\n\
    \    >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n\
    */\nlong fib(long n) \n{\n    if (n <= 1L)\n    {\n        return n;\n    }\n\
    \    else\n    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n}\n/*\nReturn\
    \ the n-th Fibonacci number.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n   \
    \ 1L\n    >>> fib(8L)\n    21L\n*/\nlong fib(long n) \n{\n    if (n <= 1L)\n \
    \   {\n        return n;\n    }\n    else\n    {\n        return fib(n - 1L) +\
    \ fib(n - 2L);\n    }\n}\n/*\nReturn the n-th Fibonacci number.\n    >>> fib(10L)\n\
    \    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n*/\nlong fib(long\
    \ n) \n{\n    if (n <= 1L)\n    {\n        return n;\n    }\n    else\n    {\n\
    \        return fib(n - 1L) + fib(n - 2L);\n    }\n}\n/*\nReturn the n-th Fibonacci\
    \ number.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n\
    \    21L\n*/\nlong fib(long n) \n{\n    if (n <= 1L)\n    {\n        return n;\n\
    \    }\n    else\n    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n}\n\
    /*\nReturn the n-th Fibonacci number.\n    >>> fib(10L)", "{\n    if (n < 2) \n\
    \    {\n        return n;\n    } \n    else \n    {\n        long[2] prev = [1L,\
    \ 0L];\n        for (long i = 0; i < n; i++) \n        {\n            long temp\
    \ = prev[0] + prev[1];\n            prev[1] = prev[0];\n            prev[0] =\
    \ temp;\n        }\n        return prev[0];\n    }\n}", "{\n    if (n <= 1L)\n\
    \        return n;\n    else \n        return fib(n - 1L) + fib(n - 2L);\n}",
  "{\n    if (n <= 2L) \n    {\n        return 1L;\n    } \n    else \n    {\n   \
    \     return fib(n - 1L) + fib(n - 2L);\n    }\n}", "{\n    if (n <= 1L)\n   \
    \     return n;\n    else\n        return fib(n - 1L) + fib(n - 2L);\n}", "{\n\
    \tswitch (n) \n\t{\n\t\tcase 0L:\n\t\tcase 1L:\n\t\t\treturn n;\n\t\tdefault:\n\
    \t\t\treturn fib(n - 1L) + fib(n - 2L);\n\t}\n}", "{\n    return (n == 0L) ? 0L\
    \ : (n == 1L) ? 1L : fib(n - 1L) + fib(n - 2L);\n}", "{\n\tlong first = 0L;\n\t\
    long second = 1L;\n\tlong tmp;\n\tlong i;\n\tfor (i = 1L; i < n; i++) \n\t{\n\t\
    \ttmp = first;\n\t\tfirst = second;\n\t\tsecond = tmp + second;\n\t}\n\treturn\
    \ second;\n}\n/*\nReturn list of all prime numbers in the range (2, n].\n    >>>\
    \ primes(40L)\n    [2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L]\n\
    */\nimport std.math;\nimport std.typecons;\nlong[] primes(long n)\n{\n\tauto numbers\
    \ = iota(2L, n);\n\tforeach (i; 2 .. trunc(n ^ 0.5) + 1) \n\t{\n\t\tnumbers =\
    \ numbers.filter!(a => a % i != 0 || a == i);\n\t}\n\treturn numbers;\n}\n/*\n\
    There is a right triangle. Two cathetuses are given. \nFind a hypotenuse.\n  \
    \  >>> hypotenuse(3, 4)\n    5.0\n    >>> hypotenuse(3.0, 4.0)\n    5.0\n*/\n\
    real hypotenuse(long a, long b) \n{\n\treturn sqrt(a ^^ 2 + b ^^ 2);\n}\n/*\n\
    There is a right triangle. Hypotenuse and one cathetus are given. \nFind another\
    \ cathetus.\n    >>> cathetus(3, 4)\n    (6.0, 8.0)\n    >>> cathetus(3.0, 4.0)\n\
    \    (6.0, 8.0)\n*/\nTuple!(real, real) cathetus(long a, long b) \n{\n\treal c\
    \ = sqrt(a ^^ 2 - b ^^ 2);\n\treturn tuple(c, b);\n}\n/*\nReturn the greatest\
    \ common divisor of a and b.\n    >>> gcd(36, 63)\n    9\n*/\nlong gcd(long a,\
    \ long b) \n{\n\t", "{\n    if (n == 0L)\n        return 0L;\n    if (n == 1L)\n\
    \        return 1L;\n    return fib(n - 1L) + fib(n - 2L);\n}\n/*\nReturn a list\
    \ containing the Fibonacci series up to n.\n    >>> fibSeries(8L)\n    [0L, 1L,\
    \ 1L, 2L, 3L, 5L, 8L, 13L]\n*/\nlong[] fibSeries(long n) \n{\n    long[] result\
    \ = new long[(int)n];\n    long m = 0L;\n    while (m < n) \n    {\n        result[(int)m]\
    \ = fib(m);\n        m = m + 1L;\n    }\n    return result;\n}\n/*\nReturn the\
    \ number of series that are required to\nreach a given sum, including the final\
    \ number.\n    >>> sumTo(3L)\n    4L\n    >>> sumTo(10L)\n    7L\n    >>> sumTo(13L)\n\
    \    7L\n    >>> sumTo(14L)\n    8L\n    >>> sumTo(15L)\n    8L\n    >>> sumTo(100L)\n\
    \    12L\n    >>> sumTo(1000L)\n    17L\n*/\nlong sumTo(long n) \n{\n    long\
    \ m = 0L;\n    long currentSum = 0L;\n    while (currentSum < n) \n    {\n   \
    \     m = m + 1L;\n        currentSum = currentSum + fib(m);\n    }\n    return\
    \ m;\n}\n/*\nReturn the smallest number whose sum of digits is equal to the sum\
    \ of\ndigits of the given number.\n    >>> smallestWithSumOfDigits(1L)\n    1L\n\
    \    >>> smallestWithSumOfDigits(2L)\n    2L\n    >>> smallestWithSumOfDigits(10L)\n\
    \    10L\n    >>> smallestWithSumOfDigits(11L)\n    11L\n    >>> smallestWithSumOfDigits(12L)\n\
    \    12L\n    >>> smallestWithSumOfDigits(13L)\n    22L\n    >>> smallestWithSumOfDigits(100L",
  "{\n    if (n < 2) \n        return n;\n    return fib(n - 1) + fib(n - 2);\n}",
  "{\n    if (n < 2)\n    {\n        return n;\n    }\n    else\n    {\n        long\
    \ a = 0;\n        long b = 1;\n        for (long i = 2; i <= n; i++)\n       \
    \ {\n            long c = a + b;\n            a = b;\n            b = c;\n   \
    \     }\n        return b;\n    }\n}", "{\n    if (n <= 2L)\n        return 1L;\n\
    \    return fib(n - 1L) + fib(n - 2L);\n}", "{\n    if (n <= 2L) \n    {\n   \
    \     return 1L;\n    }\n    else \n    {\n        long x, y;\n        x = fib(n-1L);\n\
    \        y = fib(n-2L);\n        return x + y;\n    }\n}", "{\n    return n <=\
    \ 1 ? n : fib(n - 1) + fib(n - 2);\n}", "{\n\tlong cur = 1;\n\tlong prev = 0;\n\
    \tlong i = 0;\n\tfor (i = 0; i < n; i++) \n\t{\n\t\tlong temp = cur;\n\t\tcur\
    \ = cur + prev;\n\t\tprev = temp;\n\t}\n\treturn prev;\n}", "{\n    long i;\n\
    \    long a = 0;\n    long b = 1;\n    if (n <= 0)\n    {\n        return 0;\n\
    \    }\n    else if (n == 1)\n    {\n        return 1;\n    }\n    else\n    {\n\
    \        for (i = 2; i <= n; i++)\n        {\n            a += b;\n          \
    \  swap(a, b);\n        }\n        return b;\n    }\n}", "{\n    if (n < 2)\n\
    \        return n;\n    else \n        return fib(n - 1) + fib(n - 2);\n}", "{\n\
    \    if (n <= 1L) \n        return n;\n    long a = 0L;\n    long b = 1L;\n  \
    \  foreach (i; 1 .. n) \n    {\n        long c = a + b;\n        a = b;\n    \
    \    b = c;\n    }\n    return a;\n}\n \n/*\nReturn a list of the first n Fibonacci\
    \ numbers.\n    >>> fibs(10L)\n    [0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L, 34L]\n\
    \    >>> fibs(1L)\n    [0L]\n    >>> fibs(8L)\n    [0L, 1L, 1L, 2L, 3L, 5L, 8L,\
    \ 13L]\n*/\nlong[] fibs(long n) \n{\n    long[] result;\n    result.length = n;\n\
    \    foreach (i; 0 .. n) \n        result[i] = fib(i);\n    return result;\n}\n\
    \ \n/*\nReturn a list of the first n Fibonacci numbers.\nThis version uses immutable\
    \ values and is therefore pure.\n    >>> fibs_pure(10L)\n    [0L, 1L, 1L, 2L,\
    \ 3L, 5L, 8L, 13L, 21L, 34L]\n    >>> fibs_pure(1L)\n    [0L]\n    >>> fibs_pure(8L)\n\
    \    [0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L]\n*/\nlong[] fibs_pure(long n) \n{\n   \
    \ if (n == 0L) \n        return new long[](0);\n    else if (n == 1L) \n     \
    \   return [0L];\n    long[] fibs = fibs_pure(n - 1L);\n    fibs ~= fibs[$ - 1L]\
    \ + fibs[$ - 2L];\n    return fibs;\n}\n \n/*\nReturn a list of the first n prime\
    \ numbers.\n    >>> primes(10L)\n    [2L, 3L, 5L, 7", "{\n    if (n <= 1L) \n\
    \    {\n        return n;\n    }\n    return fib(n - 1L) + fib(n - 2L);\n}", "{\n\
    \    if (n < 2) return n;\n    return fib(n - 1) + fib(n - 2);\n}", "{\n    if\
    \ (n < 2)\n        return n;\n    return fib(n - 1) + fib(n - 2);\n}", "{\n  \
    \  long result = 0;\n    if (n <= 1)\n    {\n        result = n;\n    }\n    else\
    \ \n    {\n        result = fib(n - 1) + fib(n - 2);\n    }\n    return result;\n\
    }", "{\n    if (n < 2) \n    {\n        return n;\n    }\n    return fib(n - 1)\
    \ + fib(n - 2);\n}", "{\n\tif (n <= 1) return n;\n\telse return fib(n - 1) + fib(n\
    \ - 2);\n}", "{\n    if (n <= 2L)\n        return 1L;\n    return fib(n - 1L)\
    \ + fib(n - 2L);\n}", "{\n    long n0 = 0L;\n    long n1 = 1L;\n    if (n == 0L)\
    \ {\n        return n0;\n    }\n    else if (n == 1L) {\n        return n1;\n\
    \    }\n    else {\n        long i = 2L;\n        while (i <= n) {\n         \
    \   long tmp = n0 + n1;\n            n0 = n1;\n            n1 = tmp;\n       \
    \     i += 1L;\n        }\n        return n1;\n    }\n}\n/*\nReturn the factorial\
    \ of n.\n    >>> fact(5L)\n    120L\n    >>> fact(1L)\n    1L\n    >>> fact(5L)\n\
    \    120L\n    \n*/\nlong fact(long n) \n{\n    long res = 1L;\n    long i = 1L;\n\
    \    while (i <= n) {\n        res *= i;\n        i += 1L;\n    }\n    return\
    \ res;\n}\n/*\nCompute the n-th Harmonic number.\n    >>> harmonic(10L)\n    2.9289682539682538\n\
    \    >>> harmonic(2L)\n    1.5\n    >>> harmonic(5L)\n    2.283333333333333\n\
    \    \n*/\ndouble harmonic(long n) \n{\n    double res = 0.0;\n    long i = 1L;\n\
    \    while (i <= n) {\n        res += 1.0 / (double)i;\n        i += 1L;\n   \
    \ }\n    return res;\n}\n/*\nCompute all prime numbers less than `max`.\n    >>>\
    \ sieve(50L)\n    [2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L,\
    \ 43L, 47L]\n    >>> sieve(10L)\n    [2L, 3L, 5L, 7L]\n    >>> sieve(15L)\n  \
    \  [2L, 3L, 5L, 7L, 11L, 13L]\n    \n*/\nvec_long sieve(long max) \n{\n   ", "{\n\
    \    long fib1 = 1;\n    long fib2 = 1;\n    long cnt = 2;\n    while (cnt < n)\
    \ \n    {\n        long tmp = fib1;\n        fib1 = fib2;\n        fib2 = tmp\
    \ + fib2;\n        cnt++;\n    }\n    return fib2;\n}", "{\n    if (n == 0) return\
    \ 0;\n    if (n == 1) return 1;\n    long a = 0;\n    long b = 1;\n    long c\
    \ = a + b;\n    for (long i = 2; i < n; i++) {\n        a = b;\n        b = c;\n\
    \        c = a + b;\n    }\n    return c;\n}", "{\n    if (n == 0)\n        return\
    \ 0;\n    if (n == 1)\n        return 1;\n    else\n        return fib(n - 1)\
    \ + fib(n - 2);\n}\n/*\nReturn a list of the Fibonacci sequence.\n    >>> [1L,\
    \ 1L, 2L, 3L, 5L, 8L, 13L, 21L, 34L, 55L]\n    >>> fibs(10L)\n    \n*/\nlong[]\
    \ fibs(long n) \n{\n    long[] result = new long[n];\n    for (long i = 0; i <\
    \ n; i++)\n        result[i] = fib(i);\n    return result;\n}", "{\n    if (n\
    \ < 2)\n    {\n        return n;\n    }\n    else\n    {\n        long a, b;\n\
    \        a = 0;\n        b = 1;\n        foreach (i; 0..n)\n        {\n      \
    \      long tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n\
    \        return a;\n    }\n}", "{\n    long first = 0L;\n    long second = 1L;\n\
    \    long tmp;\n    for (int i = 0; i < n; i++) \n    {\n        tmp = first;\n\
    \        first = second;\n        second = tmp + second;\n    }\n    return first;\n\
    }", "{\n    if (n < 2)\n        return n;\n    else \n        return fib(n - 1)\
    \ + fib(n - 2);\n}", "{\n    n = n+1;\n    long result;\n    if (n < 2) \n   \
    \ {\n\treturn n;\n    } \n    else \n    {\n\tresult = fib(n-1) + fib(n-2);\n\t\
    return result;\n    }\n}", "{\n    return n < 2 ? n : fib(n - 1) + fib(n - 2);\n\
    }\nstatic assert(fib(10L) == 55L);\nstatic assert(fib(1L) == 1L);\nstatic assert(fib(8L)\
    \ == 21L);", "{\n    if (n <= 2L)\n    {\n        return 1L;\n    }\n    else\n\
    \    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n}", "{\n    long f0\
    \ = 0;\n    long f1 = 1;\n    long temp;\n    for (int i = 0; i < n; i++) \n \
    \   {\n        temp = f0;\n        f0 = f1;\n        f1 = temp + f1;\n    }\n\
    \    return f0;\n}", "{\n    return (n <= 2L) ? 1L : fib(n - 1L) + fib(n - 2L);\n\
    }\n/*\nReturn a list of first n Fibonacci numbers.\n    \n    >>> fibs_list(10L)\n\
    \    [1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L, 34L, 55L]\n    >>> fibs_list(2L)\n   \
    \ [1L, 1L]\n    >>> fibs_list(1L)\n    [1L]\n    \n*/\nList!long fibs_list(long\
    \ n) \n{\n    return n > 0L ? fibs_list(n - 1L) ~ [fib(n)] : [];\n}\n/*\nPrint\
    \ a list of first n Fibonacci numbers.\n    \n    >>> fibs_print(10L)\n    1\n\
    \    1\n    2\n    3\n    5\n    8\n    13\n    21\n    34\n    55\n    >>> fibs_print(1L)\n\
    \    1\n    >>> fibs_print(0L)\n    \n    \n*/", "{\n    long a = 0L;\n    long\
    \ b = 1L;\n    for (int i = 0; i < n; i++) {\n        long c = a + b;\n      \
    \  a = b;\n        b = c;\n    }\n    return a;\n}", "{\n    if (n <= 1L)\n  \
    \      return n;\n    long a = 0L;\n    long b = 1L;\n    long i = 2L;\n    while\
    \ (i < n) {\n        long tmp = a + b;\n        a = b;\n        b = tmp;\n   \
    \     i = i + 1L;\n    }\n    return a + b;\n}\n/*\nReturn a list with the first\
    \ n Fibonacci numbers.\n    >>> fibs(10L)\n    [0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L,\
    \ 21L, 34L]\n    >>> fibs(1L)\n    [0L]\n    >>> fibs(8L)\n    [0L, 1L, 1L, 2L,\
    \ 3L, 5L, 8L, 13L]\n*/\nlazy List fibs(long n) \n{\n    List result = toList(0L);\n\
    \    long a = 0L;\n    long b = 1L;\n    long i = 2L;\n    while (i < n) {\n \
    \       long tmp = a + b;\n        a = b;\n        b = tmp;\n        i = i + 1L;\n\
    \        result.add(b);\n    }\n    return result;\n}\n/*\nReturn the greatest\
    \ common divisor of a and b.\n    >>> gcd(255L, 165L)\n    15L\n    >>> gcd(1L,\
    \ 1L)\n    1L\n    >>> gcd(25L, 6L)\n    1L\n    >>> gcd(21L, 6L)\n    3L\n*/\n\
    long gcd(long a, long b) \n{\n    if (a < b)\n        return gcd(b, a);\n    long\
    \ r = a % b;\n    if (r == 0L)\n        return b;\n    return gcd(b, r);\n}\n\
    /*\nReturn the greatest common divisor of a and b using iteration.\n    >>> gcd_iter(255L,\
    \ 165L)\n    15L\n    >>> gcd_iter(1L, 1L)\n    1L\n    >>> gcd", "{\n    if (n\
    \ <= 2L)\n        return 1L;\n    return fib(n - 1L) + fib(n - 2L);\n}\n/*\nReturn\
    \ sum of all elements in the array.\n    >>> count([1, 2, 3])\n    6\n    >>>\
    \ count([])\n    0\n    >>> count([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    55\n \
    \   \n*/", "{\n    long result, a, b;\n    if (n < 2L) {\n        result = n;\n\
    \    }\n    else {\n        a = fib(n - 1L);\n        b = fib(n - 2L);\n     \
    \   result = a + b;\n    }\n    return result;\n}", "{\n    long a = 0L;\n   \
    \ long b = 1L;\n    long i = 0L;\n    for (; i < n; i++) {\n        long c = a\
    \ + b;\n        a = b;\n        b = c;\n    }\n    return a;\n}", "{\n    if (n\
    \ < 2)\n        return n;\n    return fib(n - 1) + fib(n - 2);\n}\n/*\nReturn\
    \ x + y + z.\n    >>> c(1, 2, 3)\n    6\n    >>> c(64, 128, 256)\n    448\n  \
    \  >>> c(1, 2, 0)\n    3\n*/", "{\n    long a = 0;\n    long b = 1;\n    while\
    \ (n > 0) \n    {\n        auto t = a + b;\n        a = b;\n        b = t;\n \
    \       n--;\n    }\n    return a;\n}\n/*\nImplement binary search algorithm.\
    \ Return index of found element or -1 if element is not found. \n    >>> binary_search([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10], 8)\n    7\n    >>> binary_search([1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10], 0)\n    -1\n    >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10], -1)\n    -1\n    >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\
    \ 999)\n    -1\n    >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n  \
    \  2\n*/", "{\n\tlong i;\n\tlong a = 0L;\n\tlong b = 1L;\n\tfor (i = 0L; i < n;\
    \ i++) \n\t{\n\t\tconst long t = a + b;\n\t\ta = b;\n\t\tb = t;\n\t}\n\treturn\
    \ a;\n}", "{\n    static long[long] cache;\n    static long[long] cache2;\n  \
    \  alias Result=typeof(cache[0]);\n    if (n <= 1) return n;\n    auto i = cache.find(n);\n\
    \    if (i !is null) return i.value;\n    Result x = fib(n - 1);\n    Result y\
    \ = fib(n - 2);\n    cache[n] = x + y;\n    cache2[n] = cache2[n - 1] + cache2[n\
    \ - 2];\n    return x + y;\n}\n/*\nTesting the results of the algorithm\n*/\n\
    unittest\n{\n    static assert(fib(0) == 0);\n    static assert(fib(1) == 1);\n\
    \    static assert(fib(2) == 1);\n    static assert(fib(3) == 2);\n    static\
    \ assert(fib(4) == 3);\n    static assert(fib(5) == 5);\n    static assert(fib(6)\
    \ == 8);\n    static assert(fib(7) == 13);\n    static assert(fib(8) == 21);\n\
    \    static assert(fib(9) == 34);\n    static assert(fib(10) == 55);\n    static\
    \ assert(fib(11) == 89);\n    static assert(fib(12) == 144);\n    static assert(fib(13)\
    \ == 233);\n    static assert(fib(14) == 377);\n    static assert(fib(15) == 610);\n\
    \    static assert(fib(16) == 987);\n    static assert(fib(17) == 1597);\n   \
    \ static assert(fib(18) == 2584);\n    static assert(fib(19) == 4181);\n    static\
    \ assert(fib(20) == 6765);\n    static assert(fib(21) == 10946);\n    static assert(fib(22)\
    \ == 17711);\n    static assert(fib(23) == 28657);\n    static assert(fib(24)\
    \ == 46368);\n    static assert(fib(25) == 75025);\n    static assert(fib(26)\
    \ == 1213", "{\n\tstatic long prev = 1L;\n\tstatic long next = 1L;\n\tlong i =\
    \ 2L;\n\tlong tmp;\n\tif (n < 3L)\n\t\treturn 1L;\n\tfor (; i < n; i++) \n\t{\n\
    \t\ttmp = prev;\n\t\tprev = next;\n\t\tnext = tmp + next;\n\t}\n\treturn next;\n\
    }", "{\n    return (n <= 2L) ? 1L : fib(n - 1L) + fib(n - 2L);\n}\n/*\nPrint the\
    \ Fibonacci series up to n.\n    >>> fibseries(10L)\n    1L\n    1L\n    2L\n\
    \    3L\n    5L\n    8L\n    13L\n    21L\n    34L\n    55L\n    >>> fibseries(2L)\n\
    \    1L\n    1L\n    >>> fibseries(1L)\n    1L\n    >>> fibseries(0L)\n    \n\
    \    \n*/", "{\n    if (n < 0) \n    {\n        return -1;\n    }\n    else if\
    \ (n < 2) \n    {\n        return n;\n    }\n    else \n    {\n        long x\
    \ = fib(n - 1);\n        long y = fib(n - 2);\n        return x + y;\n    }\n\
    }\n/*\nReturn n-th Fibonacci number.\n*/\nlong fib_iter(long n)\n{\n    if (n\
    \ < 0)\n    {\n        return -1;\n    }\n    else if (n < 2)\n    {\n       \
    \ return n;\n    }\n    else\n    {\n        long a = 0;\n        long b = 1;\n\
    \        long c = 0;\n        for (long i = 0; i < n; i++)\n        {\n      \
    \      c = a + b;\n            a = b;\n            b = c;\n        }\n       \
    \ return c;\n    }\n}", "{\n    return n < 2 ? n : fib(n - 1) + fib(n - 2);\n}",
  "{\n\tif (n < 2)\n\t\treturn n;\n\telse\n\t\treturn fib(n - 1) + fib(n - 2);\n}",
  "{\n  long a = 0L;\n  long b = 1L;\n  long c = 1L;\n  long i = 1L;\n  while (i <\
    \ n) {\n    c = a + b;\n    a = b;\n    b = c;\n    i = i + 1L;\n  }\n  return\
    \ c;\n}", "{\n    if (n < 2) \n    {\n        return n;\n    }\n    return fib(n\
    \ - 1) + fib(n - 2);\n}", "{\n    if (n <= 1L) return n;\n    return fib(n - 1L)\
    \ + fib(n - 2L);\n}", "{\n    long a = 0L;\n    long b = 1L;\n    long tmp;\n\
    \    long i;\n    foreach (i ; 0L..n) \n    {\n        tmp = a;\n        a = b;\n\
    \        b = tmp + b;\n    }\n    return a;\n}", "{\n    // TODO: Implement\n\
    \    return n < 2 ? n : fib(n - 1) + fib(n - 2);\n}", "{\n    if (n <= 2L) \n\
    \        return 1L;\n    return fib(n - 1L) + fib(n - 2L);\n}\n/*\nReturn greatest\
    \ common divisor of two numbers.\n    >>> gcd(42L, 30L)\n    6L\n    >>> gcd(0L,\
    \ 1L)\n    1L\n*/\nlong gcd(long x, long y) \n{\n    if (y == 0L) \n        return\
    \ x;\n    return gcd(y, x % y);\n}\n/*\nReturn greatest common divisor of two\
    \ numbers.\n    >>> gcd(42L, 30L)\n    6L\n    >>> gcd(0L, 1L)\n    1L\n*/\nlong\
    \ gcd(long x, long y) \n{\n    while (y != 0L) {\n        long tmp = x;\n    \
    \    x = y;\n        y = tmp % y;\n    }\n    return x;\n}\n/*\n    Compute pi\
    \ by starting with an initial estimate and iteratively improving\n    this estimate\
    \ by calculating pi/4 = 4*arctan(1/5) - arctan(1/239).\n    >>> pi(5)\n    3.3396825396825403\n\
    \    >>> pi(10)\n    3.0418396189294032\n    >>> pi(20)\n    3.1315929035585537\n\
    \    >>> pi(100)\n    3.1315929035585537\n*/\ndouble pi(int n) \n{\n    double\
    \ result = 0.0;\n    for (int i = 0; i < n; i++) {\n        result += pow(-1.0,\
    \ i) * (4.0 / (2.0 * i + 1.0));\n    }\n    return result;\n}\n/*\n    Compute\
    \ pi by starting with an initial estimate and iteratively improving\n    this\
    \ estimate by calculating pi/4 = 4*arctan(1/5) - arctan(1/239).\n    >>> pi(5)\n\
    \    3.3396825396825403\n    >>> pi(10)\n    3.0418396189294032\n    >>> pi(20",
  "{\n    if (n < 3) \n    {\n        return 1;\n    }\n    return fib(n - 1) + fib(n\
    \ - 2);\n}", "{\n    if (n < 2) return n;\n    long prev = 0L;\n    long curr\
    \ = 1L;\n    for (long i = 0L; i < n - 1L; i++) \n    {\n        long tmp = prev;\n\
    \        prev = curr;\n        curr = tmp + curr;\n    }\n    return curr;\n}",
  "{\n    long (curr, next) = (0L, 1L);\n    for (long i = 0L; i < n; i++) \n    {\n\
    \        (curr, next) = (next, curr + next);\n    }\n    return curr;\n}", "{\n\
    \    if (n == 0L) \n    {\n        return 0L;\n    }\n    else if (n == 1L) \n\
    \    {\n        return 1L;\n    }\n    else \n    {\n        return fib(n - 1L)\
    \ + fib(n - 2L);\n    }\n}\n/*\nReturn n-th factorial.\n    >>> fact(5L)\n   \
    \ 120L\n    >>> fact(1L)\n    1L\n    >>> fact(10L)\n    3628800L\n*/\nlong fact(long\
    \ n) \n{\n    if (n == 0L) \n    {\n        return 1L;\n    }\n    else \n   \
    \ {\n        return n * fact(n - 1L);\n    }\n}\nlong fac(long n) \n{\n    if\
    \ (n == 0L) \n    {\n        return 1L;\n    }\n    else \n    {\n        return\
    \ n * fac(n - 1L);\n    }\n}\nlong facv1(long n) \n{\n    if (n == 0L) \n    {\n\
    \        return 1L;\n    }\n    else \n    {\n        return n * facv1(n - 1L);\n\
    \    }\n}\nlong facv2(long n) \n{\n    if (n == 0L) \n    {\n        return 1L;\n\
    \    }\n    else \n    {\n        return n * facv2(n - 1L);\n    }\n}\nlong facv3(long\
    \ n) \n{\n    if (n == 0L) \n    {\n        return 1L;\n    }\n    else \n   \
    \ {\n        return n * facv3(n - 1L);\n    }\n}\n/*\nCalculate the greatest common\
    \ divisor.\n    >>> gcd(6L, 9L)\n    3L\n    >>> gcd(12L, 18L)\n    6L\n    >>>\
    \ gcd(78L, 90L)\n    6L\n    >>> gcd(10L, 25L)\n    5L\n*/\nlong gcd(long x, long\
    \ y) \n{", "{\n    int n0=0;\n    int n1=1;\n    int n2=0;\n    if (n<=0)\n  \
    \      return 0;\n    if (n==1)\n        return 1;\n    for (int i=2;i<=n;i++)\n\
    \    {\n        n2=n0+n1;\n        n0=n1;\n        n1=n2;\n    }\n    return n2;\n\
    }\n/*\nRecursive solution.\n    >>> fib_rec(10L)\n    55L\n    >>> fib_rec(1L)\n\
    \    1L\n    >>> fib_rec(8L)\n    21L\n*/\nlong fib_rec(long n) \n{\n    if (n==0)\n\
    \        return 0;\n    if (n==1)\n        return 1;\n    return fib_rec(n-1)+fib_rec(n-2);\n\
    }\n/*\n    >>> fib_rec(0L)\n    0L\n    >>> fib_rec(1L)\n    1L\n    >>> fib_rec(2L)\n\
    \    1L\n    >>> fib_rec(8L)\n    21L\n*/", "{\n    long i = 0;\n    long j =\
    \ 1;\n    for (; n > 0; n--) \n    {\n        j = i + j;\n        i = j - i;\n\
    \    }\n    return i;\n}", "{\n    if (n <= 2L)\n        return 1L;\n    return\
    \ fib(n - 1L) + fib(n - 2L);\n}", "{\n\tif (n < 2) return n;\n\treturn fib(n -\
    \ 1) + fib(n - 2);\n}", "{\n    if (n < 2)\n        return n;\n    return fib(n\
    \ - 1) + fib(n - 2);\n}", "{\n    if (n <= 2L) return 1L;\n    return fib(n -\
    \ 1L) + fib(n - 2L);\n}", "{\n    if (n <= 1L)\n    {\n        return n;\n   \
    \ }\n    else\n    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n}", "{\n\
    \    if (n < 2)\n        return n;\n    long a = 0;\n    long b = 1;\n    for\
    \ (long i = 2; i <= n; i++) \n    {\n        b = a + b;\n        a = b - a;\n\
    \    }\n    return b;\n}", "{\n    if (n<2)\n        return n;\n    else\n   \
    \     return fib(n-1) + fib(n-2);\n}", "{\n    if (n < 2) \n        return n;\n\
    \    return fib(n - 1) + fib(n - 2);\n}", "{\n    if (n == 0L) return 0L;\n  \
    \  if (n == 1L) return 1L;\n    return fib(n - 1L) + fib(n - 2L);\n}\n/*\nReturn\
    \ n-th Lucas number.\n    >>> lucas(10L)\n    123L\n    >>> lucas(1L)\n    1L\n\
    \    >>> lucas(5L)\n    11L\n*/\nlong lucas(long n) \n{\n    if (n == 0L) return\
    \ 2L;\n    if (n == 1L) return 1L;\n    return lucas(n - 1L) + lucas(n - 2L);\n\
    }\n/*\nReturn n-th generalized Fibonacci number.\n    >>> genfib(0L, 0L, 1L, 1L,\
    \ 10L)\n    1L\n    >>> genfib(1L, 1L, 1L, 1L, 10L)\n    1L\n    >>> genfib(0L,\
    \ 0L, 2L, 1L, 10L)\n    5L\n    >>> genfib(0L, 0L, 2L, -1L, 10L)\n    -3L\n  \
    \  >>> genfib(0L, 0L, 2L, 3L, 10L)\n    15L\n    >>> genfib(0L, 0L, 2L, -3L, 10L)\n\
    \    -15L\n    >>> genfib(1L, 1L, -1L, -1L, 10L)\n    -1L\n    >>> genfib(1L,\
    \ 1L, -1L, -1L, 30L)\n    -536870911L\n    >>> genfib(1L, 1L, -1L, -1L, 40L)\n\
    \    -17179869183L\n*/\nlong genfib(long a, long b, long p, long q, long n) \n\
    {\n    if (n == 0L) return a;\n    if (n == 1L) return b;\n    return p * genfib(a,\
    \ b, p, q, n - 1L) + q * genfib(a, b, p, q,", "    if (n <= 1L)\n        return\
    \ n;\n    else\n        return fib(n - 1L) + fib(n - 2L);\n    \n/*\nReturn the\
    \ greatest common divisor of two non-negative integers.\n    >>> gcd(24L, 16L)\n\
    \    8L\n    >>> gcd(24L, 0L)\n    24L\n    >>> gcd(24L, 36L)\n    12L\n*/\nlong\
    \ gcd(long x, long y)\n    while (y != 0L)\n        if (x > y)\n            x\
    \ = x - y;\n        else\n            y = y - x;\n    return x;", "{\n    if (n\
    \ == 0L) return 0L;\n    if (n == 1L) return 1L;\n    long i = 2L;\n    long f1\
    \ = 0L;\n    long f2 = 1L;\n    while (i++ < n) {\n        long tmp = f1 + f2;\n\
    \        f1 = f2;\n        f2 = tmp;\n    }\n    return f2;\n}", "{\n    if (n\
    \ < 2)\n        return n;\n    else\n        return fib(n - 1) + fib(n - 2);\n\
    }", "{\n    long[] table = new long[n + 1];\n    for (long i = 0; i <= n; i++)\
    \ \n    {\n        if (i <= 1)\n            table[i] = i;\n        else\n    \
    \        table[i] = table[i - 1] + table[i - 2];\n    }\n    return table[n];\n\
    }", "{\n    if (n < 3) return 1;\n    return fib(n - 1) + fib(n - 2);\n}", "{\n\
    \    if (n < 2)\n    {\n        return n;\n    }\n    else\n    {\n        return\
    \ fib(n - 1) + fib(n - 2);\n    }\n}", "{\n    if (n < 3) \n    {\n        return\
    \ 1;\n    }\n    else \n    {\n        return fib(n - 1) + fib(n - 2);\n    }\n\
    }", "{\n    return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n/*\nReturn n-th Triangular\
    \ number.\n    >>> tri(2L)\n    3L\n    >>> tri(6L)\n    21L\n    >>> tri(10L)\n\
    \    55L\n*/\nlong tri(long n)\n{\n    return n * (n + 1) / 2;\n}\n/*\nReturn\
    \ n-th Pentagonal number.\n    >>> pent(2L)\n    5L\n    >>> pent(5L)\n    25L\n\
    \    >>> pent(7L)\n    41L\n*/\nlong pent(long n)\n{\n    return n * (3 * n -\
    \ 1) / 2;\n}\n/*\nReturn n-th Hexagonal number.\n    >>> hex(2L)\n    6L\n   \
    \ >>> hex(6L)\n    42L\n    >>> hex(10L)\n    82L\n*/\nlong hex(long n)\n{\n \
    \   return n * (2 * n - 1);\n}\n/*\nReturn n-th Heptagonal number.\n    >>> hept(2L)\n\
    \    7L\n    >>> hept(6L)\n    51L\n    >>> hept(10L)\n    91L\n*/\nlong hept(long\
    \ n)\n{\n    return n * (5 * n - 3) / 2;\n}\n/*\nReturn n-th Octagonal number.\n\
    \    >>> oct(2L)\n    8L\n    >>> oct(6L)\n    56L\n    >>> oct(10L)\n    106L\n\
    */\nlong oct(long n)\n{\n    return n * (3 * n - 2);\n}", "{\n    /*\n       \
    \ Please add your code here.\n    */\n    long a = 0L;\n    long b = 1L;\n   \
    \ long c = 0L;\n    if (n == 0L)\n        return 0L;\n    if (n == 1L)\n     \
    \   return 1L;\n    for (int i = 0; i < n; i++)\n    {\n        c = a + b;\n \
    \       a = b;\n        b = c;\n    }\n    return c;\n}", "{\n    long a = 0;\n\
    \    long b = 1;\n    while (n-- > 0) \n    {\n        a += b;\n        b = a\
    \ - b;\n    }\n    return a;\n}\n/*", "{\n    long i = 1;\n    long j = 0;\n \
    \   foreach (l; 0..n) {\n        long tmp = i;\n        i += j;\n        j = tmp;\n\
    \    }\n    return j;\n}", "{\n\tif (n == 0L) return 0L;\n\tif (n == 1L) return\
    \ 1L;\n\tif (n < 0L) return -1L;\n\treturn fib(n - 1L) + fib(n - 2L);\n}", "{\n\
    \    if (n <= 1L) \n        return n;\n    else \n        return fib(n - 1L) +\
    \ fib(n - 2L);\n}", "{\n\tlong i, a = 0L, b = 1L;\n\tif (n <= 1L)\n\t\treturn\
    \ n;\n\tfor (i = 2L; i <= n; i++) {\n\t\tlong c = a + b;\n\t\ta = b;\n\t\tb =\
    \ c;\n\t}\n\treturn b;\n}", "{\n    if (n < 3) \n    {\n        return 1;\n  \
    \  }\n    return fib(n - 1) + fib(n - 2);\n}\n/*\nCompute the factorial of a number.\n\
    \    >>> factorial(5L)\n    120L\n    >>> factorial(0L)\n    1L\n*/\nlong factorial(long\
    \ n) \n{\n    if (n == 0) \n    {\n        return 1;\n    }\n    return n * factorial(n\
    \ - 1);\n}", "{\n    if (n <= 1L)\n        return n;\n    long a = 0L;\n    long\
    \ b = 1L;\n    long i = 2L;\n    while (i <= n) \n    {\n        long old_b =\
    \ b;\n        b = a + b;\n        a = old_b;\n        i += 1L;\n    }\n    return\
    \ b;\n}", "{\n    long fibo = 1;\n    long fibo1 = 1;\n    long fibo2 = 1;\n \
    \   long i = 2;\n    while (i < n) \n    {\n        fibo = fibo1 + fibo2;\n  \
    \      fibo2 = fibo1;\n        fibo1 = fibo;\n        i++;\n    }\n    return\
    \ fibo;\n}", "{\n    long fib0 = 0L;\n    long fib1 = 1L;\n    if (n <= 1L) {\n\
    \        return n;\n    }\n    long i = 2L;\n    while (i <= n) {\n        long\
    \ tmp = fib0 + fib1;\n        fib0 = fib1;\n        fib1 = tmp;\n        i = i\
    \ + 1L;\n    }\n    return fib1;\n}\n//\n//", "{\n    if (n <= 1L) \n    {\n \
    \       return n;\n    } \n    else \n    {\n        return fib(n - 1L) + fib(n\
    \ - 2L);\n    }\n}", "{\n\tif (n<2) return n;\n\treturn fib(n-1) + fib(n-2);\n\
    }", "{\n    return (n < 2L) ? n : fib(n - 1L) + fib(n - 2L);\n}", "    pure nothrow\
    \ @nogc\n{\n    if (n <= 2L)\n        return 1L;\n    return fib(n - 1L) + fib(n\
    \ - 2L);\n}", "{\n    if (n <= 1L) \n    {\n        return n;\n    }\n    else\
    \ \n    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n}\n/*\nReturn the\
    \ sum of first n Fibonacci numbers.\n    >>> sum_fib(5L)\n    12L\n    >>> sum_fib(2L)\n\
    \    2L\n    >>> sum_fib(8L)\n    143L\n    >>> sum_fib(21L)\n    2178309L\n*/\n\
    long sum_fib(long n) \n{\n    long sum = 0L;\n    long i = 0L;\n    while (i <\
    \ n) \n    {\n        sum += fib(i);\n        i++;\n    }\n    return sum;\n}\n\
    /*\nPrint out ``Hello World`` and return a value of ``1`` to the C compiler.",
  "{\n    switch (n) {\n        case 0L:\n            return 0L;\n        case 1L:\n\
    \            return 1L;\n        default:\n            return fib(n - 1L) + fib(n\
    \ - 2L);\n    }\n}", "{\n    long a, b;\n    long i;\n    a = 1L;\n    b = 1L;\n\
    \    i = 2L;\n    while (i <= n) {\n        b = a + b;\n        a = b - a;\n \
    \       i += 1L;\n    }\n    return a;\n}", "    if (n <= 2L) \n        return\
    \ 1L;\n    else \n        return fib(n - 1L) + fib(n - 2L);\n    ", "{\n    long\
    \ a = 0;\n    long b = 1;\n    foreach(i; 0..n)\n    {\n        long t = a;\n\
    \        a = b;\n        b = t + b;\n    }\n    return a;\n}", "{\n    long t0\
    \ = 0L;\n    long t1 = 1L;\n    long s;\n    while (--n >= 0L) \n    {\n     \
    \   s = t0 + t1;\n        t0 = t1;\n        t1 = s;\n    }\n    return t0;\n}",
  "{\n    if (n <= 2L) return 1L;\n    return fib(n - 1L) + fib(n - 2L);\n}", "{\n\
    \    long a = 0L;\n    long b = 1L;\n    long c = 0L;\n    long i = 0L;\n    for\
    \ (i = 0L; i < n; i++) \n    {\n        c = a + b;\n        a = b;\n        b\
    \ = c;\n    }\n    return c;\n}", "{\n    if (n < 0)\n        return 0;\n    if\
    \ (n == 0)\n        return 0;\n    if (n == 1)\n        return 1;\n    return\
    \ fib(n - 1) + fib(n - 2);\n}", "{\n    if (n <= 2L)\n        return 1L;\n   \
    \ return fib(n - 1L) + fib(n - 2L);\n}", "{\n    if (n < 2)\n        return n;\n\
    \    long a = 0L;\n    long b = 1L;\n    long result = 0L;\n    foreach (i; 0L\
    \ .. n) \n    {\n        result = a + b;\n        a = b;\n        b = result;\n\
    \    }\n    return result;\n}", "{\n    return (n < 2) ? n : fib(n - 1) + fib(n\
    \ - 2);\n}", "{\n    if (n == 0L)\n        return 0L;\n    else\n        return\
    \ _fib(n, 0L, 1L);\n}", "{\n    if (n < 2)\n    {\n        return n;\n    }",
  "{\n    if (n < 2) \n    {\n        return n;\n    }\n    else \n    {\n       \
    \ return fib(n - 1) + fib(n - 2);\n    }\n}", "{\n    assert(n > 0);\n    long\
    \ a = 0;\n    long b = 1;\n    long i = 0;\n    while (i < n) {\n        long\
    \ sum = a + b;\n        a = b;\n        b = sum;\n        i = i + 1;\n    }\n\
    \    return a;\n}", "{\n    if (n < 3)\n        return 1;\n    else \n       \
    \ return fib(n - 1) + fib(n - 2);\n}", "{\n    return n < 2 ? n : fib(n - 1) +\
    \ fib(n - 2);\n}", "{\n    long y = 0;\n    long x = 1;\n    for (long i = 0;\
    \ i < n; i++) \n    {\n        y = x;\n        x = x + y;\n    }\n    return y;\n\
    }\n/*\nSolve the quadratic equation of the form:\nax^2 + bx + c = 0\n    \n  \
    \  >>> x1, x2 = solveQuadratic(1L, 2L, -3L)\n    >>> x1\n    1L\n    >>> x2\n\
    \    -3L\n    \n*/", "{\n    if (n < 2)\n        return n;\n    else\n       \
    \ return fib(n - 1) + fib(n - 2);\n}", "{\n\tlong i;\n\tlong a = 0;\n\tlong b\
    \ = 1;\n\tfor (i = 0; i < n; i++) \n\t{\n\t\tlong c = a + b;\n\t\ta = b;\n\t\t\
    b = c;\n\t}\n\treturn a;\n}", "{\n    if (n <= 2L) \n    {\n        return 1L;\n\
    \    }\n    else \n    {\n        return fib(n - 1L) + fib(n - 2L);\n    }\n}",
  "{\n    if (n < 2)\n        return n;\n    return fib(n - 1) + fib(n - 2);\n}",
  "{\n    long x = 0L;\n    long y = 1L;\n    long z = 0L;\n    long i = 0L;\n   \
    \ while (i < n) \n    {\n        z = x + y;\n        x = y;\n        y = z;\n\
    \        i = i + 1L;\n    }\n    return x;\n}\n/*", "{\n    static long* F;\n\
    \    static long M = 0;\n    if(M < n)\n    {\n        F = new long[n+1];\n  \
    \      F[0] = 0;\n        F[1] = 1;\n        foreach(i; 2 .. n+1)\n          \
    \  F[i] = F[i-1] + F[i-2];\n        M = n;\n    }\n    return F[n];\n}\n/*\nFibonacci\
    \ numbers are defined recursively.\n   F(0) = 0\n   F(1) = 1\n   F(n) = F(n-1)\
    \ + F(n-2)\n*/\nlong fibRec(long n)\n{\n    if(n == 0) return 0;\n    if(n ==\
    \ 1) return 1;\n    return fibRec(n-1) + fibRec(n-2);\n}\n/*\nCount the number\
    \ of ways to make change for a given amount.\n    >>> makeChange(100, [1, 5, 10,\
    \ 25, 50])\n    292\n*/\nlong makeChange(long amount, long[] denoms) \n{\n   \
    \ long[long] table = new long[amount+1];\n    table[0] = 1;\n    foreach(denom;\
    \ denoms)\n    {\n        foreach(i; denom .. amount+1)\n            table[i]\
    \ += table[i-denom];\n    }\n    return table[amount];\n}\n/*\nFind longest common\
    \ subsequence of two strings.\n    >>> lcs(\"ABC\", \"ACE\")\n    3\n    >>> lcs(\"\
    ABCD\", \"AEBD\")\n    3\n*/\nlong lcs(string a, string b) \n{\n    long[long]\
    \ table = new long[b.length];\n    foreach(i; 1 .. a.length+1)\n    {\n      \
    \  long prev = 0;\n        foreach(j; 1 .. b.length+1)\n        {\n          \
    \  long temp = table[j];\n            if(a[i-1] == b[j-1])\n                table[j]\
    \ = prev + 1;\n            else\n                table[j] = max(table", "{\n \
    \   long a = 0L;\n    long b = 1L;\n    long i = 1L;\n    while (i < n) \n   \
    \ {\n        long temp = a;\n        a = b;\n        b = temp + b;\n        i\
    \ = i + 1L;\n    }\n    return b;\n}\n/*\nReturn the n-th prime number.\n    >>>\
    \ prime(0L)\n    2L\n    >>> prime(1L)\n    3L\n    >>> prime(2L)\n    5L\n  \
    \  >>> prime(6L)\n    17L\n*/\nlong prime(long n) \n{\n    long i = 0L;\n    long\
    \ count = 0L;\n    long num = 2L;\n    while (count < n) \n    {\n        long\
    \ isPrime = 1L;\n        long j = 2L;\n        while (j <= sqrt(num)) \n     \
    \   {\n            if (num % j == 0L) \n            {\n                isPrime\
    \ = 0L;\n                break;\n            }\n            j = j + 1L;\n    \
    \    }\n        if (isPrime == 1L) \n        {\n            count = count + 1L;\n\
    \        }\n        num = num + 1L;\n    }\n    return num - 1L;\n}\n/*\nReturn\
    \ the greatest prime factor of a number.\n    >>> greatestPrimeFactor(0L)\n  \
    \  0L\n    >>> greatestPrimeFactor(1L)\n    1L\n    >>> greatestPrimeFactor(2L)\n\
    \    2L\n    >>> greatestPrimeFactor(8L)\n    2L\n    >>> greatestPrimeFactor(11L)\n\
    \    11L\n    >>> greatestPrimeFactor(26L)\n    13L\n    >>> greatestPrimeFactor(36L)\n\
    \    5L\n    >>> greatestPrimeFactor(4004L)\n    61L\n*/\nlong greatestPrimeFactor(long\
    \ n) \n{\n    long num = n;\n    long i = 2L;\n    while (i <= sqrt(num)) \n \
    \   {\n        if (num % i == 0L) \n        {\n            num = num / i;\n  \
    \      }\n        else \n        {\n            i", "{\n  long a = 0;\n  long\
    \ b = 1;\n  foreach(i; 1 .. n)\n  {\n    long c = a + b;\n    a = b;\n    b =\
    \ c;\n  }\n  return a;\n}", "{\n    return (n <= 2) ? 1 : fib(n - 1) + fib(n -\
    \ 2);\n}\n/*\nReturn n-th Fibonacci number.\n    >>> fib(10L)\n    55L\n    >>>\
    \ fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib_on(long n) \n\
    {\n    int i;\n    long n1 = 1;\n    long n2 = 1;\n    long n3 = 0;\n    for (i\
    \ = 3; i <= n; i++) \n    {\n        n3 = n1 + n2;\n        n1 = n2;\n       \
    \ n2 = n3;\n    }\n    return n3;\n}\n/*\n    Return factorial of n.\n    >>>\
    \ fact(1L)\n    1L\n    >>> fact(4L)\n    24L\n    >>> fact(10L)\n    3628800L\n\
    */\nlong fact(long n) \n{\n    return (n <= 1) ? 1 : n * fact(n - 1);\n}", "{\n\
    \    if (n <= 1L)\n        return n;\n    else\n        return fib(n - 1L) + fib(n\
    \ - 2L);\n}", "{\n    long i = 0;\n    long j = 1;\n    while (n--) {\n      \
    \  auto t = i + j;\n        i = j;\n        j = t;\n    }\n    return i;\n}\n\
    /*\nFind the sum of the first n Fibonacci numbers.\n    >>> sum_fib(10L)\n   \
    \ 143L\n*/\nlong sum_fib(long n) \n{\n    if (n == 0) return 0;\n    if (n ==\
    \ 1) return 1;\n    return sum_fib(n - 1) + fib(n);\n}\n/*\nFind the largest Fibonacci\
    \ number less than m.\n    >>> find_fib(55L)\n    34L\n    >>> find_fib(1L)\n\
    \    0L\n    >>> find_fib(5000L)\n    3178L\n*/\nlong find_fib(long m) \n{\n \
    \   long n = 0;\n    while (fib(n) < m) n++;\n    return n - 1;\n}\n/*\nCheck\
    \ if n is a prime number.\n    >>> is_prime(10L)\n    False\n    >>> is_prime(7L)\n\
    \    True\n    >>> is_prime(1L)\n    False\n*/", "{\n   if (n<2)\n      return\
    \ n;\n   else\n      return fib(n-1)+fib(n-2);\n}", "{\n    long v = 0;\n    for\
    \ (int i = 0; i < n; i++)\n    {\n        v = (v + 1) % 3;\n        v = min(v,\
    \ 2);\n    }\n    if (v == 0)\n        return 0;\n    else if (v == 1)\n     \
    \   return 1;\n    else\n        return 2;\n}", "{\n    if (n < 2) \n    {\n \
    \       return n;\n    }\n    long a = 1L;\n    long b = 1L;\n    foreach (immutable\
    \ i; 1..n-1) \n    {\n        long c = a + b;\n        a = b;\n        b = c;\n\
    \    }\n    return b;\n}\n/*\nReturn the number of possible combinations when\
    \ choosing n objects from a collection of size k.\n    >>> nCk(10L, 5L)\n    252L\n\
    \    >>> nCk(1L, 3L)\n    0L\n    >>> nCk(5L, 5L)\n    1L\n    \n*/\nlong nCk(long\
    \ n, long k) \n{\n    if (n < k) \n    {\n        return 0L;\n    }\n    long\
    \ p = 1L;\n    long m = max(k, n-k);\n    for (long i = m+1L; i <= n; i += 1L)\
    \ \n    {\n        p *= i;\n    }\n    for (long i = 2L; i <= n-m; i += 1L) \n\
    \    {\n        p /= i;\n    }\n    return p;\n}\n/*\nCalculate the number of\
    \ combinations with repetition when choosing n objects from a collection of size\
    \ k.\n    >>> nCkr(10L, 5L)\n    2002L\n    >>> nCkr(1L, 3L)\n    3L\n    >>>\
    \ nCkr(5L, 5L)\n    1L\n    \n*/\nlong nCkr(long n, long k) \n{\n    return nCk(n+k-1L,\
    \ k);\n}\n/*\nCalculate the n-th Bell number.\n    >>> bell(10L)\n    115975L\n\
    \    >>> bell(1L)\n    1L\n    >>> bell(8L)\n    4140L\n    \n*/\nlong bell(long\
    \ n) \n{\n    if (n < 1L) \n    {\n        return 0L;\n    }\n    long p = 1L;\n\
    \    for (long i = 1L", "{\n    long a = 0L;\n    long b = 1L;\n    foreach (i;\
    \ 0 .. n) {\n        long temp = a;\n        a = b;\n        b = temp + b;\n \
    \   }\n    return a;\n}", "{\n  if (n < 2) return n;\n  long f1 = 1;\n  long f2\
    \ = 0;\n  long temp;\n  foreach(int i; 0 .. n) \n  {\n    temp = f1;\n    f1 =\
    \ f1 + f2;\n    f2 = temp;\n  }\n  return f2;\n}", "{\n    if (n <= 1L) \n   \
    \ {\n        return n;\n    }\n    long i = 0L;\n    long a = 0L;\n    long b\
    \ = 1L;\n    long c = 0L;\n    for (; i < n - 1L; i++) \n    {\n        c = a\
    \ + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}", "{\n    if (n\
    \ <= 1L) return n;\n    else return fib(n - 1L) + fib(n - 2L);\n}", "{\n\tlong\
    \ a, b, i;\n\ta = 0;\n\tb = 1;\n\tif (n == 0)\n\t\treturn a;\n\tif (n == 1)\n\t\
    \treturn b;\n\tfor (i = 2; i <= n; i++) \n\t{\n\t\tlong temp = a + b;\n\t\ta =\
    \ b;\n\t\tb = temp;\n\t}\n\treturn b;\n}", "    if (n <= 1L) \n        return\
    \ n;\n    return fib(n - 1L) + fib(n - 2L);", "{\n    long fn_2 = 0L;\n    long\
    \ fn_1 = 1L;\n    long fn;\n    if (n <= 2L) \n    {\n        return 1L;\n   \
    \ }\n    for (long i = 3L; i <= n; i++) \n    {\n        fn = fn_1 + fn_2;\n \
    \       fn_2 = fn_1;\n        fn_1 = fn;\n    }\n    return fn;\n}\n/*\nReturn\
    \ n-th prime number.\n    >>> prime(10L)\n    29L\n    >>> prime(1L)\n    2L\n\
    \    >>> prime(8L)\n    19L\n*/\nlong prime(long n) \n{\n    long p = 2L;\n  \
    \  long count = 0L;\n    while (true) \n    {\n        long i = 2L;\n        for\
    \ (; i < p; i++) \n        {\n            if (p % i == 0L) \n            {\n \
    \               break;\n            }\n        }\n        if (i == p) \n     \
    \   {\n            count = count + 1L;\n            if (count == n) \n       \
    \     {\n                return p;\n            }\n        }\n        p = p +\
    \ 1L;\n    }\n}", "{\n    if (n < 2) \n    {\n        return n;\n    }\n    else\
    \ \n    {\n        return fib(n - 1) + fib(n - 2);\n    }\n}", "{\n    if (n <=\
    \ 2L)\n        return 1L;\n    else\n        return fib(n - 1L) + fib(n - 2L);\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
