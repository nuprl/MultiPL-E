name: HumanEval_25_factorize
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
  \ of given integer in the order from smallest to largest.\n    Each of the factors\
  \ should be arrayed number of times corresponding to how many times it appeares\
  \ in factorization.\n    Input number should be equal to the product of all factors\n\
  \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
  \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n) \n"
tests: "unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
  \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
  \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
  \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L,\
  \ 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
  \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
completions: ["{\n\tlong[] res = [];\n\tlong d = 2;\n\twhile (d*d <= n)\n\t{\n\t\t\
    while (n % d == 0)\n\t\t{\n\t\t\tres ~= d;\n\t\t\tn /= d;\n\t\t}\n\t\td += 1;\n\
    \t}\n\tif (n > 1)\n\t\tres ~= n;\n\treturn res;\n}", "{\n\t long[] primes = new\
    \ long[1];\n\t long p = 2;\n\t long fCount = 0;\n\t long i = 0;\n\t \n\t \n\t\
    \ foreach(long i; 0 ..^  n)\n\t {\n\t\t if(n % p == 0)\n\t\t {\n\t\t\t primes[i]\
    \ = p;\n\t\t\t p = 2;\n\t\t\t i++;\n\t\t\t fCount++;\n\t\t }\n\t\t else\n\t\t\
    \ {\n\t\t\tp++;\n\t\t }\n\t }\n\treturn primes;\n}", "{\n    long[] factorArray\
    \ = new long[0];\n    long j = 2;\n    if (n <= 2)\n    {\n        factorArray\
    \ = new long[1];\n        factorArray[0] = n;\n        return factorArray;\n \
    \   }\n    if (n % 2 == 0)\n    {\n        factorArray = new long[1];\n      \
    \  factorArray[0] = 2;\n        return factorArray ~ factorize(n / 2);\n    }\n\
    \    else\n    {\n        for (long i = 3; i <= cast(long)ceil(sqrt(n)); i +=\
    \ 2)\n        {\n            if (n % i == 0)\n            {\n                factorArray\
    \ = new long[1];\n                factorArray[0] = i;\n                return\
    \ factorArray ~ factorize(n / i);\n            }\n        }\n    }\n    factorArray\
    \ = new long[1];\n    factorArray[0] = n;\n    return factorArray;\n}\n/*\n *\
    \ Return the minimal number of integer factors that contain all of the prime factors\
    \ that are in given integer.\n *\n * >>> bestSubset(3L)\n * [3L]\n * >>> bestSubset(6L)\n\
    \ * [2L, 3L]\n * >>> bestSubset(7L)\n * [7L]\n * >>> bestSubset(70L)\n * [5L,\
    \ 7L]\n * >>> bestSubset(45L)\n * [3L, 5L]\n * >>> bestSubset(140L)\n * [2L, 5L,\
    \ 7L]\n * >>> bestSubset(132L)\n * [2L, 3L, 11L]\n * >>> bestSubset(1096L)\n *\
    \ [2L, 4L, 7L, 13L]\n * >>> bestSubset(3125L)\n * [5L, 5L, 5L, 5L]\n * >>> bestSubset(24L)\n\
    \ * [2L, 2L, 2L, 3L]\n *\n */\nlong[] bestSubset(long n)\n{\n    long[] array\
    \ = new long[0];\n    long[] factorArray = factorize(n);\n    foreach (i; 0",
  "{\n    long[] res;\n    bool isPrime = false;\n    foreach(factor; res)\n    {\n\
    \        if(n % factor == 0)\n        {\n            n = n / factor;\n       \
    \     res ~= factor;\n        }\n        else\n        {\n            isPrime\
    \ = true;\n        }\n    }\n    if(isPrime)\n    {\n        res ~= n;\n    }\n\
    \    return res;\n}\n ", "{\n    long[] result = [];\n    foreach(prime; Primes())\
    \ \n    {\n        while(n % prime == 0) \n        {\n            result ~= prime;\n\
    \            n /= prime;\n        }\n        if(n == 1) \n        {\n        \
    \    break;\n        }\n    }\n    return result;\n}", "{\n    int i = 2;\n  \
    \  long[] result = new long[];\n    while (n != 1)\n    {\n        if (n % i ==\
    \ 0)\n        {\n            n /= i;\n            result ~= i;\n        }\n  \
    \      else\n        {\n            i += 1;\n        }\n    }\n    return result;\n\
    }", "{\n    import std.math;\n    import std.typecons;\n    long[] factors;\n\
    \    if (n < 2)\n        return new long[](0);\n    foreach (i; 2 .. sqrt(n) +\
    \ 1)\n    {\n        while (n % i == 0)\n        {\n            n /= i;\n    \
    \        factors ~= i;\n        }\n    }\n    if (n > 1)\n        factors ~= n;\n\
    \    return factors;\n}\nlong[] factorize(long n)\n{\n    import std.math;\n \
    \   import std.typecons;\n    long[] factors;\n    if (n < 2)\n        return\
    \ new long[](0);\n    while (n % 2 == 0)\n    {\n        n /= 2;\n        factors\
    \ ~= 2;\n    }\n    foreach (i; 3 .. sqrt(n) + 1)\n    {\n        while (n % i\
    \ == 0)\n        {\n            n /= i;\n            factors ~= i;\n        }\n\
    \    }\n    if (n > 1)\n        factors ~= n;\n    return factors;\n}\nlong[]\
    \ factorize(long n)\n{\n    import std.math;\n    import std.typecons;\n    long[]\
    \ factors;\n    if (n < 2)\n        return new long[](0);\n    while (n % 2 ==\
    \ 0)\n    {\n        n /= 2;\n        factors ~= 2;\n    }\n    foreach (i; 3\
    \ .. isqrt(n) + 1, 2)\n    {\n        while (n % i == 0)\n        {\n        \
    \    n /= i;\n            factors ~= i;\n        }\n    }\n    if (n > 1)\n  \
    \      factors ~= n;\n    return factors;\n}\nlong[] factorize(long n)\n{\n  \
    \  import std.math;\n    import std.typecons;\n    long[] factors;\n    if (n\
    \ < 2)\n        return new long[](0);\n    while (n % 2 == 0)\n    {\n       \
    \ n /= 2;\n        factors ~= 2;\n    }\n    foreach (i;", "{\n    auto f = new\
    \ long[](0);\n    for (int i = 2; i < sqrt(n); i++)\n    {\n        auto j = 0;\n\
    \        while (n % i == 0)\n        {\n            j++;\n            n /= i;\n\
    \        }\n        f = f ~ repeat(i, j);\n    }\n    return f;\n}", "{\n    long[]\
    \ result = [];\n    if (n < 0) \n    {\n        result ~= -1;\n        n = -n;\n\
    \    }\n    while (n > 1) \n    {\n        long div = 2;\n        while (n % div\
    \ != 0) \n        {\n            div++;\n        }\n        result ~= div;\n \
    \       n /= div;\n    }\n    return result;\n}", "{\n    long[] factors = [];\n\
    \    long[] primes = [2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L,\
    \ 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L, 97L, 101L, 103L,\
    \ 107L, 109L, 113L, 127L, 131L, 137L, 139L, 149L, 151L, 157L, 163L, 167L, 173L,\
    \ 179L, 181L, 191L, 193L, 197L, 199L, 211L, 223L, 227L, 229L, 233L, 239L, 241L,\
    \ 251L, 257L, 263L, 269L, 271L, 277L, 281L, 283L, 293L, 307L, 311L, 313L, 317L,\
    \ 331L, 337L, 347L, 349L, 353L, 359L, 367L, 373L, 379L, 383L, 389L, 397L, 401L,\
    \ 409L, 419L, 421L, 431L, 433L, 439L, 443L, 449L, 457L, 461L, 463L, 467L, 479L,\
    \ 487L, 491L, 499L, 503L, 509L, 521L, 523L, 541L, 547L, 557L, 563L, 569L, 571L,\
    \ 577L, 587L, 593L, 599L, 601L, 607L, 613L, 617L, 619L, 631L, 641L, 643L, 647L,\
    \ 653L, 659L, 661L, 673L, 677L, 683L, 691L, 701L, 709L, 719L, 727L, 733L, 739L,\
    \ 743L, 751L, 757L, 761L, 769L, 773L, 787L, 797L, 809L, 811L, 821L, 823L, 827L,\
    \ 829L, 839L", "{\n    long[] res = [];\n    foreach(i; 2 .. n)\n    {\n     \
    \   while(n % i == 0)\n        {\n            res ~= i;\n            n /= i;\n\
    \        }\n    }\n    return res;\n}", "{\n    long[] res = [2L];\n    long i\
    \ = 3L;\n    long last = 2L;\n    long[] primes = [2L];\n    while (n % 2L ==\
    \ 0L) \n    {\n        n /= 2L;\n    }\n    while (i * i <= n) \n    {\n     \
    \   if (n % i == 0L) \n        {\n            while (n % i == 0L) \n         \
    \   {\n                n /= i;\n            }\n            last = i;\n       \
    \     primes ~= i;\n        }\n        i += 2L;\n    }\n    if (n > 1L) \n   \
    \ {\n        last = n;\n        primes ~= n;\n    }\n    return primes;\n}\n/*\n\
    \    Return the number of divisors of the given integer.\n    >>> numDivisors(1L)\n\
    \    1\n    >>> numDivisors(4L)\n    3\n    >>> numDivisors(12L)\n    6\n    >>>\
    \ numDivisors(70L)\n    8\n    \n*/\nlong numDivisors(long n) \n{\n    if (n ==\
    \ 1L) \n    {\n        return 1L;\n    }\n    return product(map!\"a.second +\
    \ 1L\"(enumerate(factorize(n))));\n}\n/*\n    Return an array of prime factors\
    \ of given integer in the order from smallest to largest.\n    The array should\
    \ be filled as much as possible with prime factors,\n    and remaining space in\
    \ the array should be filled with -1.\n    If n is 1, return an array of length\
    \ 1 with -1.\n    >>> primeFactors(1L)\n    [-1L]\n    >>> primeFactors(4L)\n\
    \    [2L, -1L]\n    >>> primeFactors(12L)\n    [2L, 2L, 3L]\n    >>> primeFactors(70L)\n\
    \    [2L, 5L, 7L, -1L]\n    \n*/\nlong[] primeFactors(long n) \n{\n    if (n ==\
    \ 1L) \n    {\n        return [-1L];\n", "{\n    long[] array;\n    for (long\
    \ i = 2; i <= n; i++)\n    {\n\tif (n % i == 0)\n\t{\n\t    n /= i;\n\t    array\
    \ ~= i;\n\t    i--;\n\t}\n    }\n    return array;\n}", "{\n\tlong[] res;\n\t\n\
    \twhile(n % 2 == 0)\n\t{\n\t\tn /= 2;\n\t\tres ~= 2;\n\t}\n\t\n\tfor(long i =\
    \ 3; i * i <= n; i += 2)\n\t{\n\t\twhile(n % i == 0)\n\t\t{\n\t\t\tn /= i;\n\t\
    \t\tres ~= i;\n\t\t}\n\t}\n\t\n\tif(n > 2)\n\t\tres ~= n;\n\t\t\n\treturn res;\n\
    }", "{\n  if (n<2) return [n];\n  long[] factors;\n  foreach(x; [2L, 3L, 5L, 7L,\
    \ 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L,\
    \ 73L, 79L, 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L,\
    \ 149L, 151L, 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L,\
    \ 223L, 227L, 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L,\
    \ 283L, 293L, 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L,\
    \ 373L, 379L, 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L,\
    \ 449L, 457L, 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L,\
    \ 541L, 547L, 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L,\
    \ 617L, 619L, 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L,\
    \ 701L, 709L, 719L, 727L, 733L, 739L, 743L, 751L, 757L, 761L, 769L, 773L, 787L,\
    \ 797L, 809L, 811L, 821L, 823L,", "{\n\tlong[] res = [];\n\tforeach(i;iota(2L,n/2L+1L))\n\
    \t{\n\t\twhile(!mod(n,i))\n\t\t{\n\t\t\tn /= i;\n\t\t\tres ~= i;\n\t\t}\n\t}\n\
    \tassert(product(res) == n);\n\treturn res;\n}\n/*\n Same as above, but should\
    \ use function primes() returning a lazy list of all primes.\n    >>> factorize2(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize2(25L)\n    [5L, 5L]\n    >>> factorize2(70L)\n\
    \    [2L, 5L, 7L]", "{\n\tlong[] array = new long[0];\n\tfor (long i = 2; i <\
    \ n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tarray = array ~ array(i);\n\t\
    \t\tn = n / i;\n\t\t\ti = 1;\n\t\t}\n\t}\n\treturn array;\n}", "{ \n    long[]\
    \ factors = new long[0];\n    foreach(p; primes(n + 1L)) \n    { \n        while\
    \ (n % p == 0) \n        { \n            n /= p; \n            factors ~= p; \n\
    \        } \n    } \n    return factors; \n} \n// since we use factorize() to\
    \ test for primeness, there is no need for caching", "{\n    long[] result = [];\n\
    \    long prime = 2L;\n    long power = 0L;\n    long sqrtN = cast(long)Math.sqrt(n);\n\
    \    while (n &gt; 1 &amp;&amp; prime &lt;= sqrtN) \n    {\n        while (n %\
    \ prime == 0) \n        {\n            n /= prime;\n            power++;\n   \
    \     }\n        if (power &gt; 0) \n        {\n            result ~= repeat(prime,\
    \ power);\n            power = 0;\n        }\n        prime++;\n    }\n    if\
    \ (n &gt; 1) \n    {\n        result ~= n;\n    }\n    return result;\n}", "{\n\
    \    long[] factors;\n    while (n % 2 == 0) \n    {\n        n /= 2;\n      \
    \  factors ~= 2;\n    }\n    for (long i = 3; i <= sqrt(n); i += 2) \n    {\n\
    \        while (n % i == 0) \n        {\n            n /= i;\n            factors\
    \ ~= i;\n        }\n    }\n    if (n > 2) \n    {\n        factors ~= n;\n   \
    \ }\n    return factors;\n}\n/*\n Return all divisors of given integer\n    >>>\
    \ divisors(8L)\n    [1L, 2L, 4L, 8L]\n    >>> divisors(7L)\n    [1L, 7L]\n*/\n\
    long[] divisors(long n) \n{\n    long[] factors = factorize(n);\n    return generateDivisors(factors,\
    \ n);\n}", "{\n    // write your code here\n    long[] list = new long[100];\n\
    \    long[] result = new long[100];\n    int i = 0;\n    while(n % 2 == 0)\n \
    \   {\n        list[i] = 2;\n        n = n / 2;\n        i++;\n    }\n    for(long\
    \ j = 3; j <= sqrt(n); j = j + 2)\n    {\n        while(n % j == 0)\n        {\n\
    \            list[i] = j;\n            n = n / j;\n            i++;\n        }\n\
    \    }\n    if(n > 2)\n    {\n        list[i] = n;\n        i++;\n    }\n    result\
    \ = list[0..i];\n    return result;\n}", "{\n    static long[] factorize(long\
    \ n, long d)\n    {\n        if (n % d == 0)\n        {\n            auto factors\
    \ = factorize(n / d, d);\n            return [d] ~ factors;\n        }\n     \
    \   else if (d * d > n)\n        {\n            return [n];\n        }\n     \
    \   else\n        {\n            return factorize(n, d + 1);\n        }\n    }\n\
    \    return factorize(n, 2);\n}", "{\n    long[] res = [2L,2L,2L];\n    return\
    \ res;\n}\n \n/*\n Return the first item from given range that matches the predicate.\n\
    \ If no item matches the predicate then None is returned\n \n    >>> first(10\
    \ .. 20, (i => i > 20))\n    None\n    >>> first(5 .. 15, (i => i % 3 == 0))\n\
    \    Some(6)\n*/\nauto first(R, alias pred) (R r, pred) \n{\n    foreach (i; r)\
    \ \n    {\n        if (pred(i)) \n        {\n            return Some(i);\n   \
    \     }\n    }\n    return None;\n}\n \n/*\n Determine how many items from the\
    \ given range match the predicate\n \n    >>> count(10 .. 15, (i => i % 3 == 0))\n\
    \    2\n    >>> count(0 .. 100, (i => i % 5 == 0))\n    20\n*/\nsize_t count(R,\
    \ alias pred) (R r, pred) \n{\n    size_t res = 0;\n    foreach (i; r) \n    {\n\
    \        if (pred(i)) \n        {\n            res += 1;\n        }\n    }\n \
    \   return res;\n}\n \n/*\n Return set of items from given range that match the\
    \ predicate\n \n    >>> filter(5 .. 20, (i => i % 3 == 0))\n    [6, 9, 12, 15,\
    \ 18]\n    >>> filter(0 .. 100, (i => i % 5 == 0))\n    [0, 5, 10, 15, 20, 25,\
    \ 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]\n*/\nR filter(R,\
    \ alias pred) (R r, pred) \n{\n    R res;\n    foreach (i; r) \n    {\n      \
    \  if (pred(i)) \n        {\n            res ~= i;\n        }\n    }\n    return\
    \ res;\n}\n \n/*\n Return array of fibonacci sequence numbers of the given length\n\
    \    Numbers in array should start from the 1st item and go", "{\n\tlong[] factors\
    \ = new long[0];\n\tlong i = 2;\n\twhile (i * i <= n) \n\t{\n\t\tif (n % i ==\
    \ 0) \n\t\t{\n\t\t\tfactors ~= i;\n\t\t\tn /= i;\n\t\t}\n\t\telse \n\t\t{\n\t\t\
    \ti++;\n\t\t}\n\t}\n\tfactors ~= n;\n\treturn factors;\n}", "{\n    long[] factors\
    \ = new long[];\n    while(n%2 == 0)\n    {\n        factors ~= 2;\n        n\
    \ = n/2;\n    }\n    long i = 3;\n    while(i <= n)\n    {\n        if(n%i ==\
    \ 0)\n        {\n            factors ~= i;\n            n = n/i;\n        }\n\
    \        else\n        {\n            i += 2;\n        }\n    }\n    return factors;\n\
    }", "{\n    long[] res = [];\n    if (n <= 0) return res;\n    res ~= 1;\n   \
    \ foreach (i; 2..sqrt(n)+1) \n    {\n        while (n % i == 0) \n        {\n\
    \            res ~= i;\n            n /= i;\n        }\n    }\n    if (n > 1)\
    \ res ~= n;\n    return res;\n}", "{\n    long[] results;\n    long i;\n    long\
    \ count;\n    long rem;\n    for (i = 2; i <= n; i++)\n    {\n        rem = n\
    \ % i;\n        count = 0;\n        while (rem == 0)\n        {\n            count\
    \ = count + 1;\n            n = n / i;\n            rem = n % i;\n        }\n\
    \        if (count != 0)\n        {\n            results ~= repeat(i, count);\n\
    \        }\n    }\n    return results;\n}", "{\n    long i = 2;\n    long[] result\
    \ = new long[0];\n    long[] temp = new long[0];\n    foreach(k; 2..n+1)\n   \
    \ {\n        if(n%k == 0)\n        {\n            result ~= k;\n            n\
    \ = n/k;\n            --k;\n        }\n    }\n    temp = result[0..$-1];\n   \
    \ int count = 0;\n    while(result[$-1] == temp[$-1])\n    {\n        temp = temp[0..$-1];\n\
    \        ++count;\n    }\n    long[] res = new long[0];\n    foreach(n; 0..count)\n\
    \    {\n        res ~= result[$-1];\n    }\n    return res;\n}", "{\n    assert(n\
    \ > 0L);\n    auto factors = [];\n    foreach(i; 2L .. ceil(sqrt(n)) + 1L)\n \
    \   {\n        while(n % i == 0L)\n        {\n            n /= i;\n          \
    \  factors ~= i;\n        }\n    }\n    if(n > 1L)\n        factors ~= n;\n  \
    \  return factors;\n}\n/*\n    Return array of prime factors of the given integer.\n\
    \    Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    The method should return a tuple\
    \ containing the prime factors and their multiplicities\n    Input number should\
    \ be equal to the product of all factors\n    >>> factorizeWithCount(8L)\n   \
    \ [(2L, 3L)]\n    >>> factorizeWithCount(25L)\n    [(5L, 2L)]\n    >>> factorizeWithCount(70L)\n\
    \    [(2L, 1L), (5L, 1L), (7L, 1L)]\n*/\ntuple!(long, long)[] factorizeWithCount(long\
    \ n) \n{\n    assert(n > 0L);\n    auto factors = [];\n    foreach(i; 2L .. ceil(sqrt(n))\
    \ + 1L)\n    {\n        auto count = 0L;\n        while(n % i == 0L)\n       \
    \ {\n            n /= i;\n            count++;\n        }\n        if(count >\
    \ 0L)\n            factors ~= tuple(i, count);\n    }\n    if(n > 1L)\n      \
    \  factors ~= tuple(n, 1L);\n    return factors;\n}", "{\n    if (n <= 1L) return\
    \ [n];", "{\n\tlong[] res = [];\n\tforeach(long i; [2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])\n\t{\n\t\
    \tif(n % i == 0)\n\t\t{\n\t\t\tres ~= i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\tif(n !=\
    \ 1)\n\t\tres ~= n;\n\treturn res;\n}\n/*\n    Test if given int is a prime\n\
    \    >>> isPrime(8L)\n    false\n    >>> isPrime(3L)\n    true\n*/", "{\n    long[]\
    \ res = [];\n    foreach(i; 2..n) {\n        while(n % i == 0) {\n           \
    \ res ~= i;\n            n /= i;\n        }\n    }\n    return res;\n}\n/*\n \
    \   Primes\n    ======\n    By listing the first six prime numbers: 2, 3, 5, 7,\
    \ 11, and 13, we can see that the 6th prime is 13.\n    What is the 10001st prime\
    \ number?\n*/\nauto primes(size_t n)\n{\n    // return the nth prime number\n\
    \    // \n    long min = 1, max = 1000000;\n    long step = 1;\n    if(n > 10000)\
    \ {\n        step = 10;\n        if(n > 100000) {\n            step = 100;\n \
    \           if(n > 1000000) {\n                step = 1000;\n            }\n \
    \       }\n    }\n    int i = 0;\n    for(size_t i = 1; ; i += step) {\n     \
    \   // check all numbers between min and max\n        for(long j = min; j < max;\
    \ j++) {\n            long[] fac = factorize(j);\n            if(fac.length ==\
    \ 1) {\n                if(fac[0] == j) {\n                    n--;\n        \
    \            if(n == 0) {\n                        return j;\n               \
    \     }\n                }\n            }\n        }\n        min = max;\n   \
    \     max = min + step * 1000;\n    }\n}\n/*\n    Distinct primes factors\n  \
    \  =======================\n    The first two consecutive numbers to have two\
    \ distinct prime factors are:\n    14 = 2 \xD7 7\n    15 = 3 \xD7 5\n    The first\
    \ three consecutive numbers to have three distinct prime factors are:\n    644\
    \ = 2\xB2 \xD7 7 \xD7 23\n    645 = 3 \xD7 5 \xD7 43\n    646 = 2 \xD7 17 \xD7\
    \ 19.\n    Find the first four consecutive integers to have four distinct prime\
    \ factors. What is the first of these numbers?\n*/\nauto dpf(size_t n)\n{\n  \
    \  long max = 2000000;\n    long step = 1;\n    if(n > 10000) {\n        step\
    \ = 10;\n        if", "{\n    if (n==1) return [1L];\n    long[] factors = [];\n\
    \    while (n % 2 == 0) \n    {\n        factors ~= 2L;\n        n /= 2;\n   \
    \ }\n    for (long i = 3; i <= n; i += 2) \n    {\n        while (n % i == 0)\
    \ \n        {\n            factors ~= i;\n            n /= i;\n        }\n   \
    \ }\n    return factors;\n}\nassert(factorize(8L) == [2L, 2L, 2L]);\nassert(factorize(25L)\
    \ == [5L, 5L]);\nassert(factorize(70L) == [2L, 5L, 7L]);", "{\n\tlong n2 = n;\n\
    \tint nn = int(sqrt(n));\n\tint[] prim = new int[nn];\n\tint k = 1;\n\tprim[0]\
    \ = 2;\n\tfor (int i = 3; i < nn; i += 2)\n\t{\n\t\tbool ok = true;\n\t\tfor (int\
    \ j = 0; j < k; j++)\n\t\t{\n\t\t\tif (i % prim[j] == 0)\n\t\t\t{\n\t\t\t\tok\
    \ = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok)\n\t\t{\n\t\t\tprim[k]\
    \ = i;\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\tlong[] fct = new long[10];\n\tint ct = 0;\n\
    \tfor (int i = 0; i < k; i++)\n\t{\n\t\tif (n2 % prim[i] == 0)\n\t\t{\n\t\t\t\
    while (n2 % prim[i] == 0)\n\t\t\t{\n\t\t\t\tn2 /= prim[i];\n\t\t\t\tfct[ct] =\
    \ prim[i];\n\t\t\t\tct++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n2 != 1)\n\t{\n\t\tfct[ct]\
    \ = n2;\n\t\tct++;\n\t}\n\treturn fct[0..ct];\n}", "{\n    auto factors = [];\n\
    \    foreach(i; 2 .. ceil(sqrt(n)) + 1)\n    {\n        while(n % i == 0)\n  \
    \      {\n            n /= i;\n            factors ~= i;\n        }\n    }\n \
    \   if(n != 1)\n        factors ~= n;\n    return factors;\n}\n/*\n    Return\
    \ tuple (p, q, g, x, y) such that\n    p = g**x mod q and g**y mod q = p**-1 mod\
    \ q.\n    >>> generate_keypair(420L)\n    (311L, 431L, 7L, 5L, 103L)\n    >>>\
    \ (g, p, q, x, y) = generate_keypair(420L)\n    >>> g**x % q\n    311L\n    >>>\
    \ g**y % q\n    311L\n*/\nTuple!(long, long, long, long, long) generate_keypair(long\
    \ x)\n{\n    //x = phi(n)\n    auto primes = factorize(x);\n    auto p = min(primes);\n\
    \    auto q = x / p;\n    foreach(i; 1 .. x)\n    {\n        if(i.powmod(x, p\
    \ * q) != 1)\n        {\n            return tuple(i.powmod(x, p), i.powmod(x,\
    \ q), i, x, x);\n        }\n    }\n    return tuple(0L, 0L, 0L, 0L, 0L);\n}\n\
    /*\n    Return tuple (p, q, g, x, y) such that\n    p = g**x mod q and g**y mod\
    \ q = p**-1 mod q.\n    >>> generate_keypair(420L)\n    (311L, 431L, 7L, 5L, 103L)\n\
    \    >>> (g, p, q, x, y) = generate_keypair(420L)\n    >>> g**x % q\n    311L\n\
    \    >>> g**y % q\n    311L\n*/\nTuple!(long, long, long, long, long) generate_keypair(long\
    \ p, long", "{\n    long[] factors;\n    while (n != 1)\n    {\n        long[]\
    \ pair = factorize(n);\n        if (pair[0] == 0)\n        {\n            factors\
    \ ~= pair[1];\n            n /= pair[1];\n        }\n        else\n        {\n\
    \            long[] smaller = factorize(pair[0]);\n            factors ~= smaller;\n\
    \            n /= pair[0];\n        }\n    }\n    return factors;\n}", "{\n  \
    \  long[] factors = [];\n    while(n % 2 == 0) \n    {\n        factors ~= 2;\n\
    \        n /= 2;\n    }\n    // Now n is odd.\n    while(n > 1) \n    {\n    \
    \    bool found = false;\n        foreach(p; take(1000, primes(3, n / 2))) \n\
    \        {\n            if(n % p == 0) \n            {\n                factors\
    \ ~= p;\n                n /= p;\n                found = true;\n            \
    \    break;\n            }\n        }\n        if(!found) \n        {\n      \
    \      // We've exhausted the list of primes, no factor found.\n            //\
    \ Must be a prime, itself.\n            factors ~= n;\n            break;\n  \
    \      }\n    }\n    return factors;\n}\n// https://stackoverflow.com/questions/5250500/how-to-implement-string-replace-in-dlang/5250520#5250520\n\
    string replace(string input, string find, string replace)\n{\n    string[] parts\
    \ = input.split(find);\n    return parts.join(replace);\n}", "{\n\tauto res =\
    \ new Appender!(long[])();\n\t\n\tforeach(prime; primeFactorize(n)) {\n\t\tauto\
    \ occurences = 0;\n\t\twhile(n % prime == 0) {\n\t\t\tn /= prime;\n\t\t\toccurences++;\n\
    \t\t}\n\t\tres.put(repeat(prime, occurences));\n\t}\n\treturn res.data;\n}", "{\n\
    \tauto result = new long[](0);\n\twhile(n % 2 == 0) \n\t{\n\t\tresult ~= 2;\n\t\
    \tn /= 2;\n\t}\n\tfor(long i = 3; i <= n; i += 2) \n\t{\n\t\twhile(n % i == 0)\
    \ \n\t\t{\n\t\t\tresult ~= i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\treturn result;\n}\n\
    /*\n    isPrime function returns true if given integer is prime, otherwise returns\
    \ false.\n    >>> isPrime(5L)\n    true\n    >>> isPrime(13L)\n    true\n    >>>\
    \ isPrime(15L)\n    false\n*/", "{ \n    auto primes = sieve(n); \n    long[]\
    \ factors; \n    foreach(factor; primes) \n    { \n        while(!(n % factor))\
    \ \n        { \n            n /= factor; \n            factors ~= factor; \n \
    \       } \n    } \n    return factors; \n}\n/*\nThe most efficient way to sieve\
    \ all primes below N is using the sieve of Eratosthenes \nwhich uses a wheel to\
    \ reduce memory useage. \nThe wheel is a cyclic list of \"spokes\" consisting\
    \ of the first few prime numbers. \nThe wheel has 6 spokes, consisting of the\
    \ primes 2, 3, 5, 7, 11, and 13. \nThe wheel is a cycle because it is periodic.\
    \ \nFor example, the wheel contains 6*1, 6*2, 6*3, ..., 6*6, and then starts over\
    \ with 6*1. \nIn other words, it contains 2, 3, 5, 7, 11, 13, 2, 3, 5, 7, 11,\
    \ 13, 2, 3, 5, 7, 11, 13, ..., \nand so on. You can see that after the wheel covers\
    \ the first multiples of the prime numbers \nthat are its spokes, the wheel starts\
    \ over and re-covers the same multiples. \nFor example, the wheel re-covers all\
    \ the multiples of 13, even though 13 is a prime. \nThe wheel contains only the\
    \ multiples of the primes that are its spokes. \nThus, we can use the wheel to\
    \ sieve the multiples of 13 without sieving multiples of any other primes. \n\
    The wheel is very useful because it is smaller than the primes being sieved. \n\
    For example, the wheel contains only 6 numbers, even though it is used to sieve\
    \ the first \nmultiples of 6 primes (2, 3, 5, 7, 11, and 13). ", "{\n  long[]\
    \ factors = [];\n  long f = 2;\n  while (n > 1)\n  {\n    while (n % f == 0)\n\
    \    {\n      factors ~= f;\n      n /= f;\n    }\n    f++;\n  }\n  return factors;\n\
    }\n \n/*\n Returns a list of prime factors of a given integer\n*/\nlong[] primeFactors(long\
    \ n)\n{\n  long[] factors = [];\n  long f = 2;\n  while (n > 1)\n  {\n    while\
    \ (n % f == 0)\n    {\n      factors ~= f;\n      n /= f;\n    }\n    f++;\n \
    \ }\n  return factors;\n}\n \n/*\nReturns a list of all factors of a given integer\n\
    */\nlong[] allFactors(long n)\n{\n  long[] factors = [];\n  for (long f = 1; f\
    \ <= n; f++)\n  {\n    if (n % f == 0)\n    {\n      factors ~= f;\n    }\n  }\n\
    \  return factors;\n}\n \n/*\nReturn True if input number is a prime\n*/", "{\n\
    \    long[] factors = [];\n    if (n < 2) \n    {\n        return [n];\n    }",
  "{\n    import std.range;\n    import std.algorithm;\n    import std.array;\n  \
    \  import std.bigint;\n    import std.conv;\n    import std.typecons;\n    import\
    \ std.math;\n    auto sieve = new bool[cast(int)(n)];\n    for (size_t i = 0;\
    \ i < n; i++)\n        sieve[i] = true;\n    sieve[0] = false;\n    sieve[1] =\
    \ false;\n    for (long i = 2; i * i < n; i++)\n    {\n        if (sieve[i])\n\
    \        {\n            for (long j = i * i; j < n; j += i)\n                sieve[j]\
    \ = false;\n        }\n    }\n    auto primes = new long[][2]().init;\n    for\
    \ (long i = 0; i < n; i++)\n    {\n        if (sieve[i])\n            primes ~=\
    \ [i, 0];\n    }\n    auto mutable new_n = n;\n    foreach (i; 0 .. primes.length)\n\
    \    {\n        while (new_n % primes[i][0] == 0)\n        {\n            new_n\
    \ /= primes[i][0];\n            primes[i][1]++;\n        }\n    }\n    auto mutable\
    \ fac = new long[]().init;\n    foreach (i; 0 .. primes.length)\n    {\n     \
    \   for (int j = 0; j < primes[i][1]; j++)\n            fac ~= primes[i][0];\n\
    \    }\n    return fac;\n}\n/*\n Return next higher permutation of passed in array\n\
    \    >>> permutation([1, 2, 3])\n    [1, 3, 2]\n    >>> permutation([1, 3, 2])\n\
    \    [2, 1, 3]\n    >>> permutation([3, 2, 1])\n    [1, 2, 3]\n    \n*/\nlong[]\
    \ permutation(long[] A) \n{\n    import std.algorithm;\n    import std.array;\n\
    \    auto mutable i = A.length - 1;", "{\n\tlong[] factors = new long[];\n\tlong\
    \ i = 2;\n\twhile (i <= n)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tfactors ~=\
    \ i;\n\t\t\tn /= i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn\
    \ factors;\n}", "{ \n    long[] result = new long[];\n    while (n % 2 == 0) \n\
    \    { \n        result ~= 2; \n        n = n / 2; \n    } \n    for (long i =\
    \ 3; i <= sqrt(n); i = i + 2) \n    { \n        while (n % i == 0) \n        {\
    \ \n            result ~= i; \n            n = n / i; \n        } \n    } \n \
    \   if (n > 2) \n        result ~= n; \n    return result; \n}\n ", "{\n    long[]\
    \ factors;\n    factors.length = 0;\n    foreach(long i; 2 .. sqrt(n)) \n    {\n\
    \        while(n % i == 0) \n        {\n            n /= i;\n            factors\
    \ ~= i;\n        }\n    }\n    if(n != 1) \n    {\n        factors ~= n;\n   \
    \ }\n    return factors;\n}\n// \"Dart is an object-oriented language with C-style\
    \ syntax which can optionally transcompile into JavaScript.\" ", "{\n    long[]\
    \ result;\n    foreach(prime; PrimePrimes) \n    {\n        size_t count = 0;\n\
    \        while(n % prime == 0) \n        {\n            n /= prime;\n        \
    \    count++;\n        }\n        if(count)\n            result ~= PrimeTuple!(prime,\
    \ count);\n    }\n    return result;\n}\n/*\n    Return number of disjoint subsets\
    \ of integers [1..n] with given sum\n    >>> countSubsets(5, 6)\n    1\n    >>>\
    \ countSubsets(5, 7)\n    0\n    >>> countSubsets(5, 10)\n    2\n    >>> countSubsets(10,\
    \ 10)\n    1\n    >>> countSubsets(10, 20)\n    12\n    >>> countSubsets(100,\
    \ 100)\n    242\n    >>> countSubsets(1000, 1000)\n    2438\n*/", "{\n    long\
    \ factor = 2L;\n    long[] factors = new long[0];\n    while (n > 1)\n    {\n\
    \        //while(n % factor == 0)\n        foreach(i; 0 .. iota(n/factor+1))\n\
    \        {\n            if(n % factor == 0)\n            {\n                n\
    \ /= factor;\n                factors ~= factor;\n            }\n            else\n\
    \            {\n                factor++;\n                break;\n          \
    \  }\n        }\n    }\n    return factors;\n}", "{\n    long[] b = [];\n    long\
    \ d = 2;\n    while (n > 1) \n    {\n        while (n % d == 0) \n        {\n\
    \            b ~= d;\n            n /= d;\n        }\n        d += 1;\n    }\n\
    \    return b;\n}\n/*\n Return the sum of all given numbers.\n >>> sum(1, 2, 3)\n\
    \ 6\n */", "{\n    import std.algorithm;\n    import std.math;\n    import std.typecons;\n\
    \    long[] res = [];\n    long d = 2;\n    while (n > 1) \n    {\n        while\
    \ ((n % d) == 0) \n        {\n            res ~= d;\n            n /= d;\n   \
    \     }\n        d++;\n    }\n    return res;\n}", "{\n\tlong[] ret = null;\n\t\
    if (n<=3) \n\t{\n\t\tret = new long[1];\n\t\tret[0] = n;\n\t\treturn ret;\n\t\
    }\n\tlong d = 2;\n\tlong[] nums = new long[128];\n\tlong num = 0;\n\twhile (n\
    \ > 1) \n\t{\n\t\tlong count = 0;\n\t\twhile (n % d == 0) \n\t\t{\n\t\t\tcount++;\n\
    \t\t\tn /= d;\n\t\t}\n\t\tif (count != 0)\n\t\t{\n\t\t\tif (count == 1) \n\t\t\
    \t{\n\t\t\t\tnums[num] = d;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\
    \t\tnums[num] = d;\n\t\t\t\tnums[num+1] = count;\n\t\t\t\tnum += 2;\n\t\t\t}\n\
    \t\t}\n\t\td++;\n\t}\n\tret = new long[num];\n\tfor (long i = 0; i < num; i++)\n\
    \t\tret[i] = nums[i];\n\treturn ret;\n}\n/*\n\tBinary exponentiation is a method\
    \ of calculating an exponent by repeatedly squaring.\n\t\t>>> bpow(2L, 5L)\n\t\
    \t32L\n\t\t>>> bpow(5L, 5L)\n\t\t3125L\n\t\t>>> bpow(5L, 10L)\n\t\t9765625L\n\
    */\nlong bpow(long a, long n) \n{\n\tlong res = 1;\n\twhile (n > 0) \n\t{\n\t\t\
    if (n & 1)\n\t\t\tres *= a;\n\t\ta *= a;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\
    /*\n\tReturn the period of the rational number with numerator N and denominator\
    \ D (as a pair, e.g. (1, 2)). \n\tIf the period is too long to store as an array,\
    \ return an empty array.\n\tA rational", "{\n  long[] ret = new long[];\n  \n\
    \  foreach(immutable p; factorialPrime(n))\n  {\n    foreach(immutable i; iota(0,\
    \ p.count))\n    {\n      ret ~= p.value;\n    }\n  }\n  \n  return ret;\n}",
  "{\n    long[] primes = new long[0];\n    long[] result = new long[0];\n    foreach(i;\
    \ 2 .. ceil(sqrt(n)))\n    {\n        long r = 0;\n        while(n % i == 0)\n\
    \        {\n            n /= i;\n            r++;\n        }\n        if(r !=\
    \ 0)\n        {\n            primes ~= i;\n            result ~= r;\n        }\n\
    \    }\n    if(n != 1)\n    {\n        primes ~= n;\n        result ~= 1;\n  \
    \  }\n    return primes.zip(result).map!(a => a[0]^a[1]).array;\n}", "{\n\tlong[]\
    \ factors = [];\n\tfor (long i = 2; i <= sqrt(n); i++) \n\t{\n\t\twhile (n % i\
    \ == 0) \n\t\t{\n\t\t\tfactors ~= i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\tif (n > 1)\
    \ \n\t{\n\t\tfactors ~= n;\n\t}\n\treturn factors;\n}\n/*\n Return tuple of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be tuple element number of times corresponding to how many\
    \ times it appeares in factorization.\n    Input number should be equal to the\
    \ product of all factors\n    >>> factorize(8L)\n    (2L, 2L, 2L)\n    >>> factorize(25L)\n\
    \    (5L, 5L)\n    >>> factorize(70L)\n    (2L, 5L, 7L)\n    \n*/\nTuple!(long[])\
    \ factorize2(long n) \n{\n\tlong[] factors = [];\n\tfor (long i = 2; i <= sqrt(n);\
    \ i++) \n\t{\n\t\twhile (n % i == 0) \n\t\t{\n\t\t\tfactors ~= i;\n\t\t\tn /=\
    \ i;\n\t\t}\n\t}\n\tif (n > 1) \n\t{\n\t\tfactors ~= n;\n\t}\n\treturn tuple(factors);\n\
    }\n/*\n Return set of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be set number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    {2L, 2L, 2L}\n\
    \    >>> factorize(25L)\n    {5L, 5L}\n    >>> factorize(70L)\n    {2L, 5L, 7L}\n\
    \    \n*/\nSet!(long) factorize3(long n) \n{\n\tlong[] factors = [];\n\tfor (long\
    \ i = 2; i <= sqrt(n); i++) \n\t", "{\n    long[] factors = [];\n    for (long\
    \ i = 2; i <= n; ++i)\n    {\n        if(isPrime(i))\n        {\n            auto\
    \ t = tuple(i, 0);\n            while(n % i == 0)\n            {\n           \
    \     n /= i;\n                t[1]++;\n            }\n            if(t[1] !=\
    \ 0)\n            {\n                append(factors, replicate(t[0], t[1]));\n\
    \            }\n        }\n    }\n    return factors;\n}", "{\n    long[] res;\n\
    \    long[] cur;\n    long[] primeFactors;\n    int j;\n    bool[] arr;\n    cur\
    \ = [n];\n    res = [];\n    primeFactors = [];\n    arr = [];\n    if (n <= 1L)\n\
    \    {\n        return [n];\n    }\n    else\n    {\n        while (true)\n  \
    \      {\n            cur = new long[](cur.length / 2 + 1);\n            j = 0;\n\
    \            for (int i = 0; i < cur.length; i++)\n            {\n           \
    \     if (cur[i] != 1L)\n                {\n                    cur[j] = cur[i];\n\
    \                    j++;\n                }\n            }\n            if (j\
    \ == 0)\n            {\n                break;\n            }\n            cur\
    \ = cur[0 .. j];\n            for (int i = 0; i < cur.length; i++)\n         \
    \   {\n                if (isPrime(cur[i]))\n                {\n             \
    \       primeFactors ~= cur[i];\n                    for (int k = 0; k < arr.length;\
    \ k++)\n                    {\n                        if (arr[k] && cur[i] %\
    \ k == 0)\n                        {\n                            for (int a =\
    \ 0; a < primeFactors.length; a++)\n                            {\n          \
    \                      if (primeFactors[a] == k)\n                           \
    \     {\n                                    primeFactors.remove(a);\n       \
    \                             break;\n                                }\n    \
    \                        }\n                        }\n                    }\n\
    \                    arr[cur[i]] = true;\n                }\n            }\n \
    \           cur = primeFactors;\n            primeFactors = [];\n        }\n \
    \       primeFactors = [1L];\n        for (int i = 0; i < cur.length; i++)\n \
    \       {\n            primeFactors ~= cur[i];\n            for (int k = 0; k\
    \ < primeFactors.length; k++)\n            {\n                if (primeFactors[k]\
    \ % cur[i] == 0)\n                {\n                    primeFactors.remove(k);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return primeFactors;\n    }\n}", "{\n    long divisor = 2L;\n    long[]\
    \ factors = [];\n    while (n > 1L) \n    {\n        if (n % divisor == 0L) \n\
    \        {\n            factors ~= divisor;\n            n /= divisor;\n     \
    \   } \n        else \n        {\n            divisor += 1L;\n        }\n    }\n\
    \    return factors;\n}", "{\n    long[] result = new long[0];\n    if (n <= 3)\
    \ \n    {\n        result ~= n;\n        return result;\n    }\n    long i = 2;\n\
    \    while (n != 1) \n    {\n        while (n % i == 0) \n        {\n        \
    \    result ~= i;\n            n /= i;\n        }\n        ++i;\n    }\n    return\
    \ result;\n}", "{\n    long[] factors = [];\n    foreach(factor; std.numeric.factorize(n))\n\
    \    {\n        foreach(i; 0 .. factor.numTimes)\n        {\n            factors\
    \ ~= factor.value;\n        }\n    }\n    return factors;\n}", "{\n    long[]\
    \ res;\n    int sqrt = cast(int) sqrt(n);\n    res ~= div(n, 1L);\n    foreach(i;\
    \ 2..sqrt)\n    {\n        while(n % i == 0)\n        {\n            res ~= div(n,\
    \ i);\n            n /= i;\n        }\n    }\n    return res;\n}\nunittest\n{\n\
    \    assert(factorize(70L) == [2L, 5L, 7L]);\n    assert(factorize(25L) == [5L,\
    \ 5L]);\n    assert(factorize(10L) == [2L, 5L]);\n    assert(factorize(8L) ==\
    \ [2L, 2L, 2L]);\n}", "{\n    n = n.abs;\n    long[] res = [];\n    long[] primes\
    \ = sievePrimes(min(n,1000L));\n    foreach(i; 0..primes.length)\n    {\n    \
    \    if(n%primes[i] == 0)\n        {\n            res ~= primes[i];\n        \
    \    n /= primes[i];\n            i--;\n        }\n    }\n    if(n == 1)\n   \
    \     return res;\n    else\n        return [n];\n}\nunittest\n{\n    assert(factorize(8L)\
    \ == [2L, 2L, 2L]);\n    assert(factorize(25L) == [5L, 5L]);\n    assert(factorize(70L)\
    \ == [2L, 5L, 7L]);\n}", "{\n    if (n == 0L)\n        return typeof(return).init;\n\
    \    long[] ret = new long[n];\n    size_t i = 0;\n    while (n % 2L == 0L) \n\
    \    {\n        ret[i] = 2L;\n        n /= 2L;\n        i++;\n    }\n    foreach\
    \ (p; iota(3L, cast(long)sqrt(n) + 1L, 2L)) \n    {\n        while (n % p == 0L)\
    \ \n        {\n            ret[i] = p;\n            n /= p;\n            i++;\n\
    \        }\n    }\n    if (n > 2L) \n    {\n        ret[i] = n;\n        i++;\n\
    \    }\n    return ret[0 .. i];\n}", "{\n    long[] factors = [];\n    long max\
    \ = floor(sqrt(n));\n    foreach(i; iota(2L, max + 1L)) {\n        while(n % i\
    \ == 0) {\n            factors ~= i;\n            n /= i;\n        }\n    }\n\
    \    if(n > 1) factors ~= n;\n    return factors;\n}\n/*\n    Function to generate\
    \ a random number in the range of n using Seed as input\n*/\nsize_t randomize(size_t\
    \ Seed, size_t n) \n{\n    uint r = uniform(0u, Seed, Seed);\n    return r % n;\n\
    }", "{\n    static assert(n > 0L);\n    static assert(isProbablePrime(n) == false);\n\
    \    long[] result;\n    long x = n;\n    for (int i = 2; i <= cast(int)n; i++)\
    \ \n    {\n        if (x % i == 0) \n        {\n            auto factor = factorize(i);\n\
    \            foreach (y; factor) \n            {\n                result ~= y;\n\
    \            }\n            x /= i;\n            i--;\n        }\n    }\n    return\
    \ result;\n}\n ", "{ \n    long i;\n    long[] m=new long[2];\n    m[0]=1;\n \
    \   m[1]=n;\n    n=n-1;\n    while(n>1)\n    {\n        while(m[1]%n==0)\n   \
    \     {\n            m[0]=n;\n            m[1]=m[1]/n;\n        }\n        n=n-1;\n\
    \    }\n    return m;\n}", "{\n\tlong[] result = new long[];\n\tif (n <= 1) \n\
    \t{\n\t\treturn result;\n\t}\n\twhile (n % 2 == 0) \n\t{\n\t\tn /= 2;\n\t\tresult\
    \ ~= 2;\n\t}\n\t\n\tlong divisor = 3;\n\twhile (n != 1) \n\t{\n\t\tif (n % divisor\
    \ == 0) \n\t\t{\n\t\t\tn /= divisor;\n\t\t\tresult ~= divisor;\n\t\t}\n\t\telse\
    \ \n\t\t{\n\t\t\tdivisor += 2;\n\t\t}\n\t}\n\treturn result;\n}", "{\n  long[]\
    \ result = new long[0];\n  if (n <= 1) \n  {\n    return result;\n  }\n  //assert(n\
    \ > 1);\n  long div = 2;\n  while (n > 1) \n  {\n    if (n % div == 0) \n    {\n\
    \      result ~= div;\n      n /= div;\n    }\n    else \n    {\n      ++div;\n\
    \    }\n  }\n  return result;\n}\n/*\nReturn the sum of the numbers in the array,\
    \ returning 0 for an empty array. Except the number 13 is very unlucky, so it\
    \ does not count and numbers that come immediately after a 13 also do not count.\n\
    \    >>> sum13([1, 2, 2, 1])\n    6\n    >>> sum13([1, 1])\n    2\n    >>> sum13([1,\
    \ 2, 2, 1, 13])\n    6\n    >>> sum13([1, 2, 13, 2, 1, 13])\n    4\n    >>> sum13([13,\
    \ 1, 2, 13, 2, 1, 13])\n    3\n    >>> sum13([])\n    0\n    >>> sum13([13])\n\
    \    0\n    >>> sum13([13, 13])\n    0\n    >>> sum13([13, 0, 13])\n    0\n  \
    \  >>> sum13([13, 1, 13])\n    0\n    >>> sum13([5, 7, 2])\n    14\n    >>> sum13([5,\
    \ 13, 2])\n    5\n    >>> sum13([0])\n    0\n    >>> sum13([13, 0])\n    0\n*/",
  "{\n    long[] res = new long[];\n    int i = 2;\n    while (i <= n) \n    {\n \
    \       if (n % i == 0) \n        {\n            res ~= i;\n            n /= i;\n\
    \        } \n        else \n        {\n            i++;\n        }\n    }\n  \
    \  return res;\n}", "{ \n    long[] res = [];\n    if (n % 2 == 0) \n    { \n\
    \        res ~= 2; \n        n = n / 2; \n    } \n    for (long i = 3; i <= sqrt(n);\
    \ i = i + 2) \n    { \n        if (n % i == 0) \n        { \n            res ~=\
    \ i; \n            n = n / i; \n        } \n    } \n    if (n > 2) res ~= n;\n\
    \    return res;\n}", "{\n    long[] res = [];\n    long i = 2;\n    while (n\
    \ > 1)\n    {\n        while (n % i == 0)\n        {\n            res ~= i;\n\
    \            n /= i;\n        }\n        i += 1;\n    }\n    return res;\n}",
  "{\n    long[] factors;\n    foreach(p; primes(n+1))\n    {\n        if(n%p==0)\n\
    \        {\n            //n=n/p;\n            n/=p;\n            factors~=p;\n\
    \        }\n    }\n    return factors;\n}\n//Example of applyng n=n/p (p=3)\n\
    //n=6/3=2;\n \n//return primes from 0 to n in array \nlong[] primes(long n)\n\
    {\n    long[] primes;\n    foreach(i;2..n)\n    {\n        if(isPrime(i))\n  \
    \      {\n            primes~=i;\n        }\n    }\n    return primes;\n}\n \n\
    /*\n    Examples of applyng factorize\n    >>> factorize(100L)\n    [2L, 2L, 5L,\
    \ 5L]\n    >>> factorize(101L)\n    [101L]\n    >>> factorize(12L)\n    [2L, 2L,\
    \ 3L]\n*/\n \n//check if number is prime ", "{\n    return n==1? new long[0] :\
    \ \n           n<=3? new long[]{n} : \n           typeof(n).primes.takeWhile!(a=>a<=n).filter!(a=>n%a==0L).map!(a=>a~(factorize(n/a))).array();\n\
    }", "{\n\tint i = 2;\n\tint[] arr = new int[64];\n\tint j = 0;\n\twhile(n>1)\n\
    \t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\tarr[j] = i;\n\t\t\tj++;\n\t\t\tn = n/i;\n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn arr;\n}", "{\n    n = n.abs;\n\
    \    long[] factors = [];\n    foreach(q; iota(2L, n+1))\n    {\n        if(n%q\
    \ == 0)\n        {\n            while(n%q == 0)\n            {\n             \
    \   factors ~= q;\n                n /= q;\n            }\n        }\n    }\n\
    \    return factors;\n}", "{\n    long[] primeFactors;\n    foreach(factor; iota(2L,\
    \ n + 1L).array())\n    {\n        if (isPrime(factor) && n % factor == 0)\n \
    \       {\n            auto times = n % factor == 0;\n            primeFactors\
    \ ~= factor;\n            n /= factor;\n        }\n    }\n    return primeFactors;\n\
    }\n/*\n Return number of prime factors of given integer.\n Input number should\
    \ be equal to the product of all factors\n >>> primeFactorsNumber(8L)\n 3\n >>>\
    \ primeFactorsNumber(25L)\n 2\n >>> primeFactorsNumber(70L)\n 3\n */\nlong primeFactorsNumber(long\
    \ n) \n{\n    long primeFactorsNumber = 0;\n    foreach(factor; iota(2L, n + 1L).array())\n\
    \    {\n        if (isPrime(factor) && n % factor == 0)\n        {\n         \
    \   primeFactorsNumber++;\n            n /= factor;\n        }\n    }\n    return\
    \ primeFactorsNumber;\n}\n/*\n Return greatest prime factor of given integer.\n\
    \ Input number should be equal to the product of all factors\n >>> greatestPrimeFactor(8L)\n\
    \ 2\n >>> greatestPrimeFactor(25L)\n 5\n >>> greatestPrimeFactor(70L)\n 7\n */\n\
    long greatestPrimeFactor(long n) \n{\n    long greatestPrimeFactor = 0;\n    foreach(factor;\
    \ iota(2L, n + 1L).array())\n    {\n        if (isPrime(factor) && n % factor\
    \ == 0)\n        {\n            greatestPrimeFactor = factor;\n            n /=\
    \ factor;\n        }\n    }\n    return greatestPrimeFactor;\n}\n/*\n Return array\
    \ of prime numbers up to given integer in ascending order.\n >>> primes(10L)\n\
    \ [2L, 3L, 5L, 7L]\n >>> primes(13L)\n [2L, 3L, 5L, 7L, 11L, 13L]\n >>> primes(2L)\n\
    \ [2L]\n >>> primes(1L)\n []\n >>> primes(0L)\n []\n */\nlong[] primes(long n)",
  "{\n    long[] factors = new long[];\n    while (n > 1) \n    {\n        foreach\
    \ (long i; 2..n + 1) \n        {\n            if (n % i == 0) \n            {\n\
    \                factors ~= i;\n                n /= i;\n                break;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n    >>> new Tree!(int)([1,2,[3,[4,5,6],7,8],9,[10,11,12]])\n\
    \         \u250C\u2500\u2500 1\n         \u2502\n         \u2514\u2500\u2500 2\n\
    \             \u2502\n             \u251C\u2500\u2500 3\n             \u2502 \
    \  \u2502\n             \u2502   \u251C\u2500\u2500 4\n             \u2502   \u2502\
    \n             \u2502   \u251C\u2500\u2500 5\n             \u2502   \u2502\n \
    \            \u2502   \u2514\u2500\u2500 6\n             \u2502\n            \
    \ \u251C\u2500\u2500 7\n             \u2502\n             \u251C\u2500\u2500 8\n\
    \             \u2502\n             \u2514\u2500\u2500 9\n                 \u2502\
    \n                 \u251C\u2500\u2500 10\n                 \u2502\n          \
    \       \u251C\u2500\u2500 11\n                 \u2502\n                 \u2514\
    \u2500\u2500 12\n*/\n/*\n    >>> string(new Tree!(int)([1,2,[3,[4,5,6],7,8],9,[10,11,12]]))\n\
    \    \"\u250C\u2500\u2500 1\\n\u2502\\n\u2514\u2500\u2500 2\\n    \u2502\\n  \
    \  \u251C\u2500\u2500 3\\n    \u2502   \u2502\\n    \u2502   \u251C\u2500\u2500\
    \ 4\\n    \u2502   \u2502\\n    \u2502   \u251C\u2500\u2500 5\\n    \u2502   \u2502\
    \\n    \u2502   \u2514\u2500\u2500 6\\n    \u2502\\n    \u251C\u2500\u2500 7\\\
    n    \u2502\\n    \u251C\u2500\u2500 8\\n    \u2502\\n    \u2514\u2500\u2500 9\\\
    n        \u2502\\n        \u251C\u2500\u2500 10\\n        \u2502\\n        \u251C\
    \u2500\u2500 11\\n        \u2502\\n        \u2514\u2500\u2500 12\"\n*/\nstruct\
    \ Tree(T)\n{\n    private T val;\n    private Tree!(T)[] children;\n    alias\
    \ val this;\n    this(T value, Tree!(T)[] children)\n    {\n        this.val =\
    \ value;\n        this.children = children;\n    }\n    this(T[] value)\n    {\n\
    \        this.val = value[0];\n        this.children = value[1..$].map!(sub =>\
    \ new Tree!(T)(sub", "{\n  long[] res = new long[];\n  while (n%2 == 0) \n  {\n\
    \    res ~= 2;\n    n /= 2;\n  }\n  long p = 3;\n  while (p <= n) \n  {\n    if\
    \ (n%p == 0) \n    {\n      res ~= p;\n      n /= p;\n    }\n    else \n    {\n\
    \      p += 2;\n    }\n  }\n  return res;\n}", "{\n    long[] res;\n    long[]\
    \ prime_factors = getPrimeFactors(n);", "{\n\tlong[] primes = new long[64];\n\t\
    int ind = 0;\n\t\n\tforeach(i; 0 .. 15) \n\t{\n\t\tif (n % ((long)i) == 0) \n\t\
    \t{\n\t\t\tprimes[ind] = i;\n\t\t\tind++;\n\t\t}\n\t}\n\t\n\treturn primes[0 ..\
    \ ind];\n}\n/*\n    Implement the function that returns a n-th char of the given\
    \ string if it exists, and throws a custom exception if it does not.\n    >>>\
    \ getChar(\"abc\", 1)\n    'b'\n    >>> getChar(\"abc\", 2)\n    'c'\n    >>>\
    \ import std.conv;\n    >>> try getChar(\"abc\", 3) catch(StringIndexOutOfBoundsException\
    \ e) writeln(e.msg)\n    String index out of bounds\n*/\nchar getChar(string s,\
    \ int index) \n{\n\tint len = s.length;\n\tif (index >= len)\n\t\tthrow new StringIndexOutOfBoundsException(\"\
    String index out of bounds\");\n\treturn s[index];\n}", "{\n    long[] result;\n\
    \    long m = n;\n    int i;\n    foreach(i; 2..(int)sqrt(n)) \n    {\n      \
    \  if(n % i == 0) \n        {\n            n /= i;\n            m /= i;\n    \
    \        if(m == 1)\n                break;\n            result ~= i;\n      \
    \      i = 1;\n        }\n    }\n    if(m > 1)\n        result ~= m;\n    return\
    \ result;\n}\n/*\n Given an array of integers print out all combinations of 3\
    \ numbers that sum to 0.\n    Examples:\n    >>> getZeroSum([-1, 1, 2, 3, 4, 5,\
    \ -5, -2, -3, -4])\n    [[-1, 1, 0], [-1, 3, -2], [-5, 2, 3], [-5, -3, 4], [-2,\
    \ -3, 5]]\n    >>> getZeroSum([1, 2, 3, 4, 5])\n    []\n    \n*/", "{\n    int[]\
    \ res;\n    if (n % 2 == 0) \n    {\n        res ~= 2;\n        n /= 2;\n    }\n\
    \    if (n % 2 == 0) \n    {\n        res ~= 2;\n        n /= 2;\n    }\n    long\
    \ factor = 3;\n    while (factor * factor <= n) \n    {\n        if (n % factor\
    \ == 0) \n        {\n            res ~= factor;\n            n /= factor;\n  \
    \      }\n        else \n        {\n            factor += 2;\n        }\n    }\n\
    \    if (n > 1) \n    {\n        res ~= n;\n    }\n    return res;\n}\n/*\n#2\n\
    Sum of the elements of matrix\n*/\nlong sum_of_matrix(long[][] matrix) \n{\n \
    \   long sum = 0;\n    foreach (item; matrix) \n    {\n        sum += item.sum;\n\
    \    }\n    return sum;\n}\n/*\n#3\nCheck if given number is a prime\n*/", "{\n\
    \    long[] res = new long[];\n    if (n == 1)\n    {\n        return res;\n \
    \   }\n    long d = 2;\n    for (; d <= n; ++d)\n    {\n        if (n % d == 0)\n\
    \        {\n            break;\n        }\n    }\n    if (d == n)\n    {\n   \
    \     res ~= n;\n    }\n    else\n    {\n        res ~= d;\n        res ~= factorize(n\
    \ / d);\n    }\n    return res;\n}", "{\n    assert(n > 0);\n    long[] result\
    \ = [];\n    long nextFactor = 2;\n    while (n > 1) \n    {\n        int count\
    \ = 0;\n        while (n % nextFactor == 0) \n        {\n            n /= nextFactor;\n\
    \            count++;\n        }\n        result ~= repeat(nextFactor, count);\n\
    \        nextFactor++;\n    }\n    return result;\n}", "{\n    long[] factors\
    \ = [];\n    int i = 2;\n    while (n > 1) \n    {\n        if (n % i == 0) \n\
    \        {\n            n /= i;\n            factors ~= i;\n        }\n      \
    \  else\n        {\n            i++;\n        }\n    }\n    return factors;\n}",
  "{\n    long[] factors = [n];\n    long[] res;\n    foreach(i; 2..n) \n    {\n \
    \       if (n % i == 0)\n        {\n            factors ~= factorize(i);\n   \
    \         factors ~= factorize(n / i);\n            break;\n        }\n    }\n\
    \    if (factors.length == 1)\n    {\n        res = [n];\n    }\n    else\n  \
    \  {\n        res = sort(uniq(factors));\n    }\n    return res;\n}", "{\n   \
    \ long[] factors = long[];\n    bool[] sieve = new bool[n];\n    foreach(i; 0..n)\n\
    \        sieve[i] = true;\n    sieve[0] = false;\n    sieve[1] = false;\n    for(int\
    \ i = 2; i < n; i++)\n    {\n        if(sieve[i])\n        {\n            while(n\
    \ % i == 0)\n            {\n                factors ~= i;\n                n /=\
    \ i;\n            }\n            for(int j = i; j < n; j += i)\n             \
    \   sieve[j] = false;\n        }\n    }\n    return factors;\n}\n \n/*\n    Converts\
    \ tuple to string\n    >>> tupleToString((1,2,3))\n    \"(1, 2, 3)\"\n    >>>\
    \ tupleToString((1,))\n    \"(1,)\"\n    >>> tupleToString(())\n    \"()\"\n*/\n\
    string tupleToString(T...)(T a) \n{\n    auto tmp = Tuple!T(a);\n    return tupleToString(tmp);\n\
    }\n \nstring tupleToString(T...)(Tuple!T a) \n{\n    string res = \"(\";\n   \
    \ foreach(i, v; a)\n    {\n        if(i != 0)\n            res ~= \", \";\n  \
    \      res ~= v.to!string;\n    }\n    res ~= \")\";\n    return res;\n}\n \n\
    /*\n    Converts tuple to array\n    >>> tupleToArray((1,2,3))\n    [1, 2, 3]\n\
    \    >>> tupleToArray((1,))\n    [1]\n    >>> tupleToArray(())\n    []\n*/\nT[]\
    \ tupleToArray(T...)(Tuple!T a) \n{\n    T[] res = new T[a.length];\n    foreach(i,\
    \ v; a)\n        res[i] = v;\n    return res;\n}\n \n/*\n    Converts tuple to\
    \ array\n    >>> tupleToArray(3, (1,2,3))\n    [1, 2, 3]\n    >>>", "{ \n    /*\n\
    \    int i, j, k;\n    int ans = 0;\n    int[] ans_arr = [];\n    int[] ans_arr2\
    \ = [];\n    int check = 0;\n    */\n    int count = 0;\n    long[] result = [];\n\
    \    while(n % 2 == 0) \n    { \n        //System.out.print(2 + \" \"); \n   \
    \     result ~= 2;\n        n /= 2; \n    } \n    for (long i = 3; i <= sqrt(n);\
    \ i+= 2) \n    { \n        // While i divides n, print i and divide n \n     \
    \   while (n % i == 0) \n        { \n            //System.out.print(i + \" \"\
    ); \n            result ~= i;\n            n /= i; \n        } \n    } \n    //\
    \ This condition is to handle the case when n  \n    // is a prime number greater\
    \ than 2 \n    if (n > 2) \n        //System.out.print(n); \n        result ~=\
    \ n;\n    \n    return result;\n} ", "{ \n    import std.range;\n    long [] arr\
    \ = [];\n    for (long i = 2; i <= n / i; i++) \n    { \n        while (n % i\
    \ == 0) \n        { \n            n /= i; \n            arr ~= i;\n        } \n\
    \    } \n    if (n > 1) arr ~= n;\n    return arr;\n} ", "{\n    static import\
    \ std.math : sqrt;\n    static import std.algorithm : takeWhile, map, reduce;\n\
    \    static import std.array : replicate;\n    static import std.conv : to;\n\
    \    static import std.range : iota;\n    static import std.typecons : tuple;\n\
    \    static import std.algorithm.iteration : chunkBy;\n    static import std.algorithm.comparison\
    \ : equal;\n    static import std.meta : AliasSeq;\n    static import std.typecons\
    \ : Tuple;\n    struct S\n    {\n        long n;\n        static ref ref S opCall(in\
    \ ref S s)()\n        {\n            s.n += 2;\n            return s;\n      \
    \  }\n        bool opEquals(ref const(S) s)\n        {\n            return s.n\
    \ == n;\n        }\n        long opCast(alias T)()\n        {\n            return\
    \ n;\n        }\n    }\n    static ref S opCall(in ref S s)()\n    {\n       \
    \ s.n += 2;\n        return s;\n    }\n    static bool opEquals(ref const(S) a,\
    \ in ref S b)\n    {\n        return a.n == b.n;\n    }\n    static long opCast(alias\
    \ T)(ref const(S) a)\n    {\n        return a.n;\n    }\n    static ref S opCall(in\
    \ ref S s,long n)()\n    {\n        s.n += n;\n        return s;\n    }\n    static\
    \ bool opEquals(ref const(S) a, ref const(S) b)\n    {\n        return a.n ==\
    \ b.n;\n    }\n    static long opCast(alias T)(ref const(S) a)\n    {\n      \
    \  return a.n;\n    }\n    static S s = S(3);\n    static struct F\n    {\n  \
    \      static void opCall(long n, ref long count)\n        {\n            ++count;\n\
    \        }\n    }\n    static void opCall(long n, ref long count)\n    {\n   \
    \     ++count;\n    }\n    static long f(long n)\n   ", "{\n    long[] factors\
    \ = [ 2L ];\n    long[] res = [];\n    long i = 1;\n    long count = 0;\n    while\
    \ (n > 1)\n    {\n        while (n % factors[i] == 0)\n        {\n           \
    \ count++;\n            n /= factors[i];\n        }\n        if (count > 0)\n\
    \        {\n            res ~= replicate(count, factors[i]);\n            count\
    \ = 0;\n        }\n        else\n        {\n            i++;\n            factors\
    \ ~= factors[i-1] + 1;\n        }\n    }\n    return res;\n}", "{\n    auto ret\
    \ = long[];", "{\n    /*\n    Prime numbers are numbers greater than 1 and without\
    \ positive divisors except 1 and itself.\n    For example, 2, 3, 5, 7 and 11 are\
    \ prime numbers.\n    */\n    /*\n    In the future this task can be optimized\
    \ by using a Sieve of Eratosthenes.\n    */\n    /*\n    static if(is(typeof(n))\
    \ == long)\n    {\n        long[long] dict = new long[long];\n    }\n    else\n\
    \    {\n        long[int] dict = new long[int];\n    }\n    */\n    long[long]\
    \ dict = new long[long];\n    long[long] primes;\n    long temp = n;\n    while(n\
    \ > 1)\n    {\n        foreach(i; 0 .. primes.length)\n        {\n           \
    \ if(n % primes[i] == 0)\n            {\n                dict[primes[i]]++;\n\
    \                n /= primes[i];\n                break;\n            }\n    \
    \    }\n    }\n    long[] toReturn;\n    foreach(i; dict.byKey)\n    {\n     \
    \   foreach(j; 0 .. dict[i])\n        {\n            toReturn ~= i;\n        }\n\
    \    }\n    assert(reduce!(\"a * b\")(toReturn) == temp);\n    return toReturn;\n\
    }", "{\n    long[] pf = [2L];\n    while (n > 1) \n    {\n        foreach (long\
    \ divisor; pf) \n        {\n            if (n % divisor == 0) \n            {\n\
    \                n /= divisor;\n                pf ~= divisor;\n             \
    \   break;\n            }\n        }\n    }\n    return pf;\n}\n/*\nreturns a\
    \ tuple of the sum of the squares of the numbers from 1 to n inclusive and the\
    \ sum of the numbers from 1 to n inclusive\n    >>> sum_of_squares_and_sum(4)\n\
    \    Tuple!(int, int)(30, 10)\n*/\nTuple!(int, int) sum_of_squares_and_sum(int\
    \ n)\n{\n    int sum = n * (n + 1) / 2;\n    int sum_of_squares = n * (n + 1)\
    \ * (2 * n + 1) / 6;\n    return Tuple!(int, int)(sum_of_squares, sum);\n}\n/*\n\
    returns a tuple containing the array of the integers from 1 to n inclusive and\
    \ the sum of the squares of the numbers from 1 to n inclusive\n    >>> sum_of_squares_and_array(4)\n\
    \    Tuple!(int[], int)([1, 2, 3, 4], 30)\n*/\nTuple!(int[], int) sum_of_squares_and_array(int\
    \ n)\n{\n    int[] array = [1..n];\n    int sum_of_squares = n * (n + 1) * (2\
    \ * n + 1) / 6;\n    return Tuple!(int[], int)(array, sum_of_squares);\n}\n/*\n\
    Change one element in the array so that the sum of the elements of the array will\
    \ increase by 1\n    >>> change_array([1, 2, 3])\n    [1, 2, 4]\n    >>> change_array([5,\
    \ 2, 3])\n    [5, 2, 4]\n    >>> change_array([5, 6, 3])\n    [5, 7, 3]\n    >>>\
    \ change_array([5, 6,", "{\n\tlong[] res;\n\tint x = 0;\n\tint y = 0;\n\tlong[]\
    \ temp = [1L];\n\tif (n == 1L)\n\t{\n\t\treturn [1L];\n\t}\n\telse\n\t{\n\t\t\n\
    \t\twhile (n % 2L == 0L)\n\t\t{\n\t\t\tres ~= 2L;\n\t\t\tn /= 2L;\n\t\t}\n\t\t\
    while (n % 3L == 0L)\n\t\t{\n\t\t\tres ~= 3L;\n\t\t\tn /= 3L;\n\t\t}\n\t\tfor\
    \ (y = 5; y <= sqrt(n); y+= 6)\n\t\t{\n\t\t\tif (n % y == 0L)\n\t\t\t{\n\t\t\t\
    \tres ~= y;\n\t\t\t\tn /= y;\n\t\t\t}\n\t\t\tif (n % (y + 2L) == 0L)\n\t\t\t{\n\
    \t\t\t\tres ~= y + 2L;\n\t\t\t\tn /= y + 2L;\n\t\t\t}\n\t\t}\n\t\tif (n > 2L)\n\
    \t\t{\n\t\t\tres ~= n;\n\t\t}\n\t\treturn res;\n\t}\n}\n/*\n Return array of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be arrayed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n\
    \    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long\
    \ n) \n{\n\tlong[] res;\n\tint x = 0;\n\tint y = 0;\n\tlong[] temp = [1L];\n\t\
    if (n == 1L)\n\t{\n\t\treturn [1L];\n\t}\n\telse\n\t{\n\t\t\n\t\twhile (n % 2",
  "{\n    long[] result;\n    foreach(prime; primes(n))\n    {\n        while(n %\
    \ prime == 0)\n        {\n            result ~= prime;\n            n /= prime;\n\
    \        }\n    }\n    return result;\n}", "{\n    import std.conv;\n    import\
    \ std.range;\n    import std.stdio;\n    import std.math;\n    import std.typecons;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.numeric;\n \
    \   import std.string;\n    import std.algorithm;\n    import std.algorithm.iteration;\n\
    \    import std.algorithm.comparison;\n    import std.math.prime;\n    import\
    \ std.bigint;\n    import std.exception;\n    import std.math.bigint;\n    import\
    \ std.typecons;\n    import std.traits;\n    import std.array;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.algorithm.iteration;\n    import std.typecons;\n\
    \    import std.bigint;\n    import std.exception;\n    import std.math.bigint;\n\
    \    import std.typecons;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.algorithm.iteration;\n    import std.algorithm.comparison;\n \
    \   import std.bigint;\n    import std.math.bigint;\n    import std.typecons;\n\
    \    import std.exception;\n    import std.string;\n    import std.range;\n  \
    \  import std.array;\n    import std.algorithm;\n    import std.algorithm.iteration;\n\
    \    import std.algorithm.comparison;\n    import std.algorithm.sorting;\n   \
    \ import std.math.prime;\n    import std.bigint;\n    import std.math.bigint;\n\
    \    import std.typecons;\n    import std.exception;\n    import std.math.bigint;\n\
    \    import std.typecons;\n    import std.string;\n    import std.range;\n   \
    \ import std.array;\n    import std.algorithm;\n    import std.algorithm.iteration;\n\
    \    import std.algorithm.comparison;\n    import std.algorithm.sorting;\n   \
    \ import std.math.prime;\n    import std.bigint;\n    import std.math.bigint;",
  "{ \n    long[] result; \n    long[] factors; \n    long[] pow; \n    int i; \n\
    \    int j; \n    bool found; \n    long d; \n \n    // factorize n \n    d =\
    \ 2; \n    factors = new long[]; \n    pow = new long[]; \n    while (n > 1) \n\
    \    { \n        if (n % d == 0) \n        { \n            // divisible \n   \
    \         found = false; \n            for (i = 0; i < factors.length; i++) \n\
    \            { \n                if (factors[i] == d) \n                { \n \
    \                   pow[i]++; \n                    found = true; \n         \
    \           break; \n                } \n            } \n            if (!found)\
    \ \n            { \n                factors ~= d; \n                pow ~= 1;\
    \ \n            } \n            n /= d; \n        } \n        else \n        {\
    \ \n            d++; \n        } \n    } \n \n    // build result \n    result\
    \ = new long[]; \n    for (i = 0; i < factors.length; i++) \n    { \n        for\
    \ (j = 0; j < pow[i]; j++) \n        { \n            result ~= factors[i]; \n\
    \        } \n    } \n    return result; \n} ", "{\n    import std.algorithm :\
    \ while;\n    import std.math : ceil, log2;\n    import std.range : generate;\n\
    \    import std.range : while;\n    import std.typecons : tuple;\n    auto primes\
    \ = iota(2L, cast(long)ceil(log2(n)) + 1L).\n        filter!(x => n % x == 0).\n\
    \        generate!(() => tuple(x, x)).\n        while!(p => n % p[0] == 0).\n\
    \        map!(p => p[1]);\n    return primes;\n}\n/*\n Function that calculates\
    \ multiplication table of given prime numbers.\n    Table should be represented\
    \ as a list of lists containing number in table cells.\n    All numbers except\
    \ from the primes should be equal to 0.\n    Examples:\n    >>> mul_table([2,\
    \ 3, 5])\n    [[0, 0, 0, 0, 0, 0],\n     [0, 2, 3, 5, 6, 10],\n     [0, 3, 6,\
    \ 9, 10, 15],\n     [0, 5, 9, 15, 15, 25],\n     [0, 6, 10, 15, 18, 30],\n   \
    \  [0, 10, 15, 25, 30, 50]]\n    \n    >>> mul_table([5, 7, 11])\n    [[0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n     [0, 5, 7, 11, 14, 21, 25, 35, 37, 55, 49,\
    \ 77],\n     [0, 7, 14, 22, 28, 42, 49, 70, 77, 111, 98, 154],\n     [0, 11, 22,\
    \ 33, 44, 66, 77, 110, 121, 165, 143, 231],\n     [0, 14, 28, 44, 56, 84, 98,\
    \ 140, 154, 222, 196, 308],\n     [0, 21, 42, 66, 84, 126, 147, 210, 231, 333,\
    \ 294, 462],\n     [0, 25, 49, 77, 98, 147, 175, 250, 275, 413, 350, 550],\n \
    \    [0, 35, 70, 110, 140,", "{ \n    long i;\n    long[] result = [];\n    for\
    \ (i = 2; i <= n / i; i++) \n    { \n        while (n % i == 0) \n        { \n\
    \            result ~= i; \n            n /= i; \n        } \n    } \n    if (n\
    \ > 1) \n    {\n        result ~= n; \n    }\n    return result;\n}\n/*\n    Return\
    \ number of unique factors of given integer.\n    Note: 1 is a non-unique factor\n\
    \    >>> number_of_factors(8L)\n    2L\n    >>> number_of_factors(25L)\n    2L\n\
    \    >>> number_of_factors(70L)\n    3L\n*/\nlong number_of_factors(long n) \n\
    { \n    long i;\n    long count = 0;\n    for (i = 2; i <= n / i; i++) \n    {\
    \ \n        while (n % i == 0) \n        { \n            count++; \n         \
    \   n /= i; \n        } \n    } \n    if (n > 1) \n    {\n        count++; \n\
    \    }\n    return count;\n}\n/*\n    Return a tuple of integers from interval\
    \ [start, end], inclusively.\n    >>> create_interval(2L, 5L)\n    (2L, 3L, 4L,\
    \ 5L)\n*/\ntuple(long, long, long, long) create_interval(long start, long end)\
    \ \n{ \n    return tuple(start, start + 1, start + 2, end);\n}\n/*\n    Return\
    \ tuple of tuples, which describe all unique factors of given integer (tuples\
    \ of prime factors).\n    Note: 1 is a non-unique factor\n    >>> unique_factors(8L)\n\
    \    ((2L,), (2L, 2L), (2L, 2L, 2L))\n    >>> unique_factors(25L)\n    ((5L,),\
    \ (5L, 5L))\n    >>> unique_factors(70L)\n    ((2L,), (2L, 5L), (", "{\n    auto\
    \ f = new long[];\n    for (size_t i = 2; i <= n; i++) \n    {\n        while\
    \ (n % i == 0) \n        {\n            f ~= i;\n            n /= i;\n       \
    \ }\n    }\n    return f;\n}", "{\n    long[] ret = [];\n    for (long i = 2;\
    \ i * i <= n; i++) \n    {\n        while (n % i == 0) \n        {\n         \
    \   ret ~= i;\n            n /= i;\n        }\n    }\n    if (n > 1) \n    {\n\
    \        ret ~= n;\n    }\n    return ret;\n}\n/*\nConcatenate all elements of\
    \ the argument array of arrays into one array.\n    Input array may be empty or\
    \ null\n    >>> flatten([])\n    []\n    >>> flatten([[2L, 3L], [4L, 5L]])\n \
    \   [2L, 3L, 4L, 5L]\n    >>> flatten([[[1L, 2L]], [[3L, 4L]]])\n    [1L, 2L,\
    \ 3L, 4L]\n*/\nT[] flatten(T)(T[][] array)\n{\n    import std.array;\n    return\
    \ array.assumeSorted.flatten;\n}\n/*\n    Calculate the sum of integer elements\
    \ in the array\n    >>> sum([2L, 3L, 4L])\n    9L\n    >>> sum([])\n    0L\n*/\n\
    long sum(long[] array)\n{\n    long sum = 0;\n    foreach (i; array) \n    {\n\
    \        sum += i;\n    }\n    return sum;\n}\n/*\n    Check whether given string\
    \ is a palindrome\n    >>> isPalindrome(\"abba\")\n    true\n    >>> isPalindrome(\"\
    madam\")\n    true\n    >>> isPalindrome(\"aa\")\n    true\n    >>> isPalindrome(\"\
    ab\")\n    false\n    >>> isPalindrome(\"\")\n    true\n*/", "{\n    long[] factors\
    \ = [];\n    if (n <= 1)\n    {\n        factors ~= n;\n        return factors;\n\
    \    }\n    while (n % 2 == 0)\n    {\n        factors ~= 2;\n        n /= 2;\n\
    \    }\n    for (long i = 3; i <= ceil(sqrt(n)); i += 2)\n    {\n        while\
    \ (n % i == 0)\n        {\n            factors ~= i;\n            n /= i;\n  \
    \      }\n    }\n    if (n > 2)\n    {\n        factors ~= n;\n    }\n    return\
    \ factors;\n}\n/*\n    Array of prime factors of given integer from smallest to\
    \ largest.\n    If a factor is repeated, the number of times it appears is omitted.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n*/\nlong[] factorize2(long n) \n{\n    long[] factors = [];\n\
    \    if (n <= 1)\n    {\n        factors ~= n;\n        return factors;\n    }\n\
    \    while (n % 2 == 0)\n    {\n        factors ~= 2;\n        n /= 2;\n    }\n\
    \    for (long i = 3; i <= ceil(sqrt(n)); i += 2)\n    {\n        if (n % i ==\
    \ 0)\n        {\n            factors ~= i;\n            n /= i;\n        }\n \
    \   }\n    if (n > 2)\n    {\n        factors ~= n;\n    }\n    return factors;\n\
    }", "{\n    enum int c = 0;\n    enum long[] res = new long[16];\n    while(n\
    \ % 2 == 0)\n    {\n        res[c] = 2;\n        c++;\n        n /= 2;\n    }\n\
    \    for(long i = 3; i * i <= n; i += 2)\n    {\n        while(n % i == 0)\n \
    \       {\n            res[c] = i;\n            c++;\n            n /= i;\n  \
    \      }\n    }\n    if(n > 2)\n    {\n        res[c] = n;\n        c++;\n   \
    \ }\n    return res[0..c];\n}", "{\n    // result contains unique prime factors\
    \ and their exponents\n    auto result = long[];\n    auto prime = long.init;\n\
    \    // find prime factorization for n\n    for (prime = 2; n > 1; ++prime)\n\
    \    {\n        // exponent of prime factor\n        auto exp = long.init;\n \
    \       // divide n by prime as long as it divides evenly\n        for (; n %\
    \ prime == 0; n /= prime)\n            ++exp;\n        // prime factor is found,\
    \ add it to result\n        if (exp > 0)\n            result ~= repeat(prime,\
    \ exp);\n    }\n    return result;\n}", "{\n    long[] result = [];\n    foreach(i;\
    \ 2 .. isqrt(n) + 1)\n    {\n        long j = i;\n        while(n % j == 0)\n\
    \        {\n            result ~= i;\n            n /= j;\n        }\n    }\n\
    \    if(n > 1)\n        result ~= n;\n    return result;\n}", "{\n  if (n <= 0)\
    \ \n  {\n    throw new IllegalArgumentException(\"n should be positive number\"\
    );\n  }\n  auto factors = new long[];\n  foreach (i; 1 .. sqrt(n) + 1) \n  {\n\
    \    if (n % i == 0) \n    {\n      if (i * i == n) \n      {\n        factors\
    \ ~= i;\n      } \n      else \n      {\n        factors ~= i;\n        factors\
    \ ~= n / i;\n      }\n    }\n  }\n  factors.sort;\n  return factors;\n}", "{\n\
    \tif (n == 0L)\n\t{\n\t\treturn [0L];\n\t}\n\tlong[] factors = [1L];\n\tint i\
    \ = 2;\n\twhile (n > 1)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tn /= i;\n\t\t\t\
    factors ~= i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti += 1;\n\t\t}\n\t}\n\treturn factors;\n\
    }", "{\n\tassert(n >= 1);\n\tauto result = new long[](0);\n\t\n\tforeach(d; 2\
    \ .. n + 1) \n\t{\n\t\twhile(n % d == 0) \n\t\t{\n\t\t\tresult ~= d;\n\t\t\tn\
    \ /= d;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    long[] res = [];\n    while\
    \ (n % 2 == 0) \n    {\n        res ~= 2;\n        n /= 2;\n    }\n    long factor\
    \ = 3;\n    while (factor <= sqrt(n)) \n    {\n        if (n % factor == 0) \n\
    \        {\n            res ~= factor;\n            n /= factor;\n        }\n\
    \        else \n        {\n            factor += 2;\n        }\n    }\n    if\
    \ (n > 1)\n        res ~= n;\n    return res;\n}", "{\n    if (n == 0L)\n    \
    \    return [0L];\n    if (n == 1L)\n        return [1L];\n    if (n == 2L)\n\
    \        return [2L];\n    if (n == 3L)\n        return [3L];\n    if (n == 4L)\n\
    \        return [2L, 2L];\n    if (n == 5L)\n        return [5L];\n    if (n ==\
    \ 6L)\n        return [2L, 3L];\n    if (n == 7L)\n        return [7L];\n    if\
    \ (n == 8L)\n        return [2L, 2L, 2L];\n    if (n == 9L)\n        return [3L,\
    \ 3L];\n    if (n == 10L)\n        return [2L, 5L];\n    if (n == 11L)\n     \
    \   return [11L];\n    if (n == 12L)\n        return [2L, 2L, 3L];\n    if (n\
    \ == 13L)\n        return [13L];\n    if (n == 14L)\n        return [2L, 7L];\n\
    \    if (n == 15L)\n        return [3L, 5L];\n    if (n == 16L)\n        return\
    \ [2L, 2L, 2L, 2L];\n    if (n == 17L)\n        return [17L];\n    if (n == 18L)\n\
    \        return [2L, 3L, 3L];\n    if (n == 19L)\n        return [19L];\n    if\
    \ (n == 20L)\n        return [2L, 2L, 5L];\n    if (n == 21L)\n        return\
    \ [3L, 7L];\n    if (n == 22L)\n        return [2L, 11L];\n    if (n == 23L)\n\
    \        return [23L];\n    if (n == 24L)\n        return [2L, 2L, 2L, 3L];\n\
    \    if (n == 25L)\n        return [5L, 5L];\n    if (n == 26L)\n        return\
    \ [2L, 13L];\n    if (n ==", "{\n    if (n <= 0L) \n    {\n        throw new Error(\"\
    n must be positive\");\n    }\n    const long MAX = cast(long) sqrt(n);\n    long[]\
    \ fact = new long[][] {};\n    while (n % 2L == 0L) \n    {\n        fact ~= 2L;\n\
    \        n /= 2L;\n    }\n    long p = 3L;\n    while (p <= MAX) \n    {\n   \
    \     while (n % p == 0L) \n        {\n            fact ~= p;\n            n /=\
    \ p;\n        }\n        p += 2L;\n    }\n    if (n > 1L) \n    {\n        fact\
    \ ~= n;\n    }\n    return fact;\n}", "{\n    long[] primeFactors = [];\n    for\
    \ (long i = 2; i <= sqrt(n); i++) \n    {\n        if (n % i == 0) \n        {\n\
    \            n /= i;\n            primeFactors ~= i;\n            i = 1;\n   \
    \     }\n    }\n    primeFactors ~= n;\n    return primeFactors;\n}\n/*\n Return\
    \ dict of prime factors of given integer.\n    Each key of the dict is a prime\
    \ factor, value is how many times it apperas in factorization.\n    Input number\
    \ should be equal to the product of all factors.\n    >>> factors(8L)\n    [2L:\
    \ 3,]\n    >>> factors(25L)\n    [5L: 2,]\n    >>> factors(70L)\n    [2L: 1, 5L:\
    \ 1, 7L: 1,]\n*/\nimmutable(long[long]) factors(long n) \n{\n    auto primeFactors\
    \ = factorize(n);\n    auto numFactors = sort(primeFactors);\n    return tuple(numFactors[0],\
    \ numFactors.count(numFactors[0]));\n}\n/*\n Return list of prime numbers that\
    \ are less than given integer.\n    >>> [2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L,\
    \ 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L, 97L,\
    \ 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L, 149L, 151L, 157L, 163L,\
    \ 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L, 223L, 227L, 229L, 233L,\
    \ 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L, 283L, 293L, 307L, 311L,\
    \ 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L,", "{\n    int i = 2;\n\
    \    long[] result = new long[0];\n    auto iter = new int(0);\n    while (i <=\
    \ n / i) \n    {\n        auto temp = new long[0];\n        if (n % i == 0) \n\
    \        {\n            auto j = new int(0);\n            temp ~= i;\n       \
    \     n /= i;\n            while (n % i == 0) \n            {\n              \
    \  n /= i;\n                temp ~= i;\n            }\n            result ~= temp;\n\
    \        }\n        i++;\n    }\n    if (n > 1)\n        result ~= n;\n    return\
    \ result;\n}", "{\n\tlong[] primeFactors = [];\n\twhile (n % 2 == 0) \n\t{\n\t\
    \tprimeFactors ~= 2;\n\t\tn /= 2;\n\t}\n\tfor (int i = 3; i <= sqrt(n); i += 2)\
    \ \n\t{\n\t\twhile (n % i == 0) \n\t\t{\n\t\t\tprimeFactors ~= i;\n\t\t\tn /=\
    \ i;\n\t\t}\n\t}\n\tif (n > 2)\n\t\tprimeFactors ~= n;\n\treturn primeFactors;\n\
    }\n/*\n\tGiven an integer, return true if and only if it is a prime number.\n\t\
    >>> isPrime(2)\n\ttrue\n\t>>> isPrime(5)\n\ttrue\n\t>>> isPrime(9)\n\tfalse\n\
    */", "{\n\t\n\tlong[] result = new long[];\n\tif (n==0L)\n\t\tresult = [0L];\n\
    \t\n\tif (n==1L)\n\t\tresult = [1L];\n\t\n\t\n\twhile(n!=1L) \n\t{\n\t\tforeach(num;\
    \ [2L..n])\n\t\t{\n\t\t\tif(n%num==0L)\n\t\t\t{\n\t\t\t\tresult ~= num;\n\t\t\t\
    \tn = n/num;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n\
    \    return [i for (i=2L..n) if ((n%i)==0L)]\n        .map!(m => iota(1L,n/m).reduce!((x,y)\
    \ => x*y)==n?m:0L)\n        .filter!(m => m != 0L);\n}", "{\n    long[] factors\
    \ = [];\n    while (n % 2 == 0) \n    {\n        factors ~= 2;\n        n /= 2;\n\
    \    }\n    long i = 3;\n    while (i * i <= n) \n    {\n        while (n % i\
    \ == 0) \n        {\n            factors ~= i;\n            n /= i;\n        }\n\
    \        i += 2;\n    }\n    if (n > 1) \n    {\n        factors ~= n;\n    }\n\
    \    return factors;\n}", "{ \n    long[] result = new long[0]; \n    long[] tmp\
    \ = new long[1]; \n    long sqrt = (long)sqrt(n); \n    //for(size_t i = 2; i\
    \ <= n; i++) \n    for(size_t i = 2; i <= sqrt; i++) \n    { \n        if(n %\
    \ i == 0) \n        { \n            tmp[0] = i; \n            result ~= tmp; \n\
    \            //std.stdio.writeln(i); \n            //std.stdio.writeln(result);\
    \ \n            result ~= factorize(n / i); \n            break; \n        } \n\
    \    } \n    if(result.length == 0) \n    { \n        tmp[0] = n; \n        result\
    \ ~= tmp; \n    } \n    return result; \n} ", "{\n    long[] a = new long[3];\n\
    \    long d = 2;\n    long i = 0;\n    while (n > 1) \n    {\n        if (n %\
    \ d == 0) \n        {\n            a[i] = d;\n            i++;\n            n\
    \ /= d;\n        } \n        else\n        {\n            d++;\n        }\n  \
    \  }\n    return a[0..i];\n}", "{\n  import std.algorithm : find, map, copy;\n\
    \  long[] fact;", "{\n    long[] arr;\n    int index = 0;\n    foreach(f; primes(n))\
    \ {\n        if(n % f == 0) {\n            n /= f;\n            arr ~= f;\n  \
    \      }\n    }\n    return arr;\n}", "{\n\treturn [].init;\n}", "{ \n    if (n\
    \ <= 1) \n        return new long[0]; \n    else \n    { \n        long p = 2;\
    \ \n        while (p <= n) \n        { \n            if (n % p == 0) \n      \
    \      { \n                long[] f = factorize(n / p); \n                f ~=\
    \ p; \n                return f; \n            } \n            else \n       \
    \         p++; \n        } \n    } \n    return new long[0]; \n} \n/*\n Return\
    \ array of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n) \n{ \n    if (n <= 1) \n        return new long[0];\
    \ \n    else \n    { \n        long p = 2; \n        while (p <= n) \n       \
    \ { \n            if (n % p == 0) \n            { \n                long[] f =\
    \ factorize(n / p); \n                f ~= p; \n                return f; \n \
    \           } \n            else \n                p++; \n        } \n    } \n\
    \    return new long[0]; \n} \n/*\n This function will be called to test your\
    \ solution. \n    >>> build_hash(8L)\n    {2L: 3L}\n    >>> build_hash(25L)\n\
    \    {5L: 2L}\n    >>> build_hash(70L)\n    {2L: 1L, 5L: 1L, 7L: 1L}\n    >>>\
    \ build_hash(16L)\n    {2L: 4L}\n    >>> build_hash(12L)\n    {2L: 2L, 3L: 1L}\n\
    \   ", "{\n    int size = 0;\n    long[] temp = null;\n    while (n%2 == 0)\n\
    \    {\n        n = n/2;\n        size = size + 1;\n        temp = temp ~ 2L;\n\
    \    }\n    foreach (i; 3 .. sqrt(n) + 1 by 2)\n    {\n        while (n%i == 0)\n\
    \        {\n            n = n/i;\n            size = size + 1;\n            temp\
    \ = temp ~ i;\n        }\n    }\n    if (n > 2)\n    {\n        size = size +\
    \ 1;\n        temp = temp ~ n;\n    }\n    long[] res = new long[size];\n    res[]\
    \ = temp[];\n    return res;\n}", "{\n    long[] factors = [];\n    for (long\
    \ i = 2; i <= n; ++i) \n    {\n        if (n % i == 0) \n        {\n         \
    \   factors ~= i;\n            n /= i;\n            i -= 1;\n        }\n    }\n\
    \    return factors;\n}\n/*\n Given a matrix and a pair of indices, the function\
    \ should return true, if the elements of the indices are equal, and false otherwise.\n\
    \    >>> isequal([\"a\", \"b\", \"c\"], 0, 1)\n    false\n    >>> isequal([\"\
    a\", \"b\", \"c\"], 0, 0)\n    true\n    >>> isequal([[\"a\", \"c\"], [\"b\",\
    \ \"d\"]], 1, 1)\n    true\n    \n*/", "{\n\tlong[] factors;\n\tlong factor;\n\
    \t\n\tassert(n > 0);\n\t\n\tfactors = [];\n\t\n\twhile(n > 1) \n\t{\n\t\tfactor\
    \ = 2;\n\t\t\n\t\twhile(true) \n\t\t{\n\t\t\tassert(factor <= n);\n\t\t\t\n\t\t\
    \tif (n % factor == 0)\n\t\t\t{\n\t\t\t\tfactors ~= factor;\n\t\t\t\tn /= factor;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t\tfactor += 1;\n\t\t}\n\t}\n\t\n\treturn factors;\n\
    }\n/*\n    Return next prime number after given one.\n    >>> next_prime(5L)\n\
    \    7L\n    >>> next_prime(8L)\n    11L\n    >>> next_prime(14L)\n    17L\n \
    \   >>> next_prime(15L)\n    17L\n*/\nlong next_prime(long n) \n{\n\tassert(n\
    \ > 0);\n\t\n\tif (n == 1)\n\t{\n\t\treturn 2;\n\t}\n\t\n\tn += 1 + n % 2;\n\t\
    \n\twhile(true) \n\t{\n\t\tbool is_prime = true;\n\t\t\n\t\tforeach(long i; 2..sqrt(n)\
    \ + 1) \n\t\t{\n\t\t\tif (n % i == 0) \n\t\t\t{\n\t\t\t\tis_prime = false;\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (is_prime)\n\t\t{\n\t\t\treturn n;\n\
    \t\t}\n\t\t\n\t\tn += 2;\n\t}\n}\n//\n//  \u0412\u044B\u0447\u0438\u0441\u043B\
    \u044F\u0435\u0442 \u0441\u0443\u043C\u043C\u0443 \u043F\u0440\u043E\u0441\u0442\
    \u044B\u0445 \u0447\u0438\u0441\u0435\u043B \u043E\u0442 1 \u0434\u043E n (\u0447\
    \u0438\u0441\u043B\u043E \u043F\u0440\u043E\u0441\u0442\u043E\u0435, \u0435\u0441\
    \u043B\u0438 \u043E\u043D\u043E \u0434\u0435\u043B\u0438\u0442\u0441\u044F \u0442\
    \u043E\u043B\u044C\u043A\u043E \u043D\u0430 1 \u0438 \u043D\u0430 \u0441", "{\n\
    \    long[] ret;", "{\n    long[] factors = new long[];\n    long temp = n;\n\
    \    long i = 2;\n    for ( ; i < n; ++i) \n    {\n        if (temp % i == 0)\
    \ \n        {\n            factors ~= i;\n            temp /= i;\n           \
    \ --i;\n        }\n    }\n    if (i == n) \n    {\n        factors ~= i;\n   \
    \ }\n    return factors;\n}\n/*\n    Given a list of integers return the sum of\
    \ the first prime numbers.\n    Exclude the prime numbers that are greater than\
    \ 100.\n    >>> sum_of_first_primes([1,2,3,4,5,6,7,8,9,10])\n    17\n    >>> sum_of_first_primes([5,\
    \ 2, 8, 100, 14, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5,\
    \ 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9,\
    \ 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11,\
    \ 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10,\
    \ 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5,\
    \ 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9,\
    \ 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2, 9, 5, 10, 11, 9, 5, 14, 2, 9, 5, 20, 2,",
  "{\n    long[] res;\n    foreach(i; 2 .. n + 1) \n    {\n        while(n % i ==\
    \ 0) \n        {\n            res ~= i;\n            n /= i;\n        }\n    }\n\
    \    return res;\n}", "{\n    // TODO: implement\n}\n/*\n Return array of prime\
    \ numbers in the given range.\n    >>> prime_numbers(10L, 15L)\n    [11L, 13L]\n\
    \    >>> prime_numbers(10L, 11L)\n    [11L]\n    >>> prime_numbers(10L, 10L)\n\
    \    []\n*/\nlong[] prime_numbers(long start, long end) \n{\n    // TODO: implement\n\
    }\n/*\n Return the number of real roots of a quadratic equation with given coeficients.\n\
    \    Use complex roots to check if they are real.\n    >>> num_real_roots(1L,\
    \ 2L, 1L)\n    1\n    >>> num_real_roots(1L, 1L, 1L)\n    0\n    >>> num_real_roots(1L,\
    \ -2L, 1L)\n    2\n    >>> num_real_roots(1L, 0L, 0L)\n    2\n*/\nlong num_real_roots(long\
    \ a, long b, long c) \n{\n    // TODO: implement\n}\n/*\n Return square root of\
    \ a given positive real number (cannot use .sqrt()).\n    >>> square_root(4L)\n\
    \    2L\n    >>> square_root(2L)\n    1L\n    >>> square_root(0L)\n    0L\n  \
    \  >>> square_root(25L)\n    5L\n*/\nlong square_root(long n) \n{\n    // TODO:\
    \ implement\n}\n/*\n Return an array of the square roots of a given positive real\
    \ number (cannot use .sqrt()).\n    >>> square_roots(81L)\n    [3L, 9L]\n    >>>\
    \ square_roots(1L)\n    [1L]\n    >>> square_roots(10L)\n    [1L, 10L]\n    >>>\
    \ square_roots(100L)\n    [1L, 10L, 100L]\n*/\nlong[] square_roots(long n) \n\
    {\n    // TODO: implement\n}\n/*\n Return true if the given array of sorted numbers\
    \ contains a given number.\n    >>> binary_search([],", "{\n    long[] divisors\
    \ = new long[0];\n    while (n % 2 == 0) \n    {\n        n = n / 2;\n       \
    \ divisors ~= 2;\n    }\n    // n is odd now\n    for (long i = 3; i <= n; i +=\
    \ 2) \n    {\n        while (n % i == 0) \n        {\n            n = n / i;\n\
    \            divisors ~= i;\n        }\n    }\n    return divisors;\n}\n/*\n Create\
    \ list of tuples of prime factor and its exponent.\n Input number should be equal\
    \ to the product of all factors.\n >>> prime_factor_exponent(8L)\n [(2L, 3L)]\n\
    \ >>> prime_factor_exponent(25L)\n [(5L, 2L)]\n >>> prime_factor_exponent(70L)\n\
    \ [(2L, 1L), (5L, 1L), (7L, 1L)]\n*/\nTuple!(long,long)[] prime_factor_exponent(long\
    \ n) \n{\n    Tuple!(long,long)[] factor_exponent = new Tuple!(long,long)[0];\n\
    \    long[] divisors = factorize(n);\n    for (size_t i = 0; i < divisors.length;\
    \ ++i) \n    {\n        if (i == 0) \n        {\n            factor_exponent ~=\
    \ tuple(divisors[i], 1);\n        } \n        else if (divisors[i] == divisors[i\
    \ - 1]) \n        {\n            factor_exponent[$ - 1].exponent++;\n        }\
    \ \n        else \n        {\n            factor_exponent ~= tuple(divisors[i],\
    \ 1);\n        }\n    }\n    return factor_exponent;\n}\n/*\n Create list of all\
    \ prime numbers smaller than or equal to n.\n >>> prime_sieve(25L)\n [2L, 3L,\
    \ 5L, 7L, 11L, 13L, 17L, 19L, 23L]\n*/\nlong[] prime_sieve(long n) \n{\n    long[]\
    \ primes = new", "{\n    long[] res = [];\n    for (long d = 2; d <= n; d++)\n\
    \    {\n        int ntimes = 0;\n        while (n % d == 0)\n        {\n     \
    \       n /= d;\n            ntimes++;\n        }\n        if (ntimes > 0) res\
    \ ~= repeat(d, ntimes);\n    }\n    return res;\n}", "{\n    auto factors = [];\n\
    \    while (n % 2 == 0) {\n        factors ~= 2;\n        n /= 2;\n    }\n   \
    \ foreach (d; 3..n / 2 + 1) {\n        while (n % d == 0) {\n            factors\
    \ ~= d;\n            n /= d;\n        }\n    }\n    if (n > 1)\n        factors\
    \ ~= n;\n    return factors;\n}", "{ \n    long[] res = new long[];\n    while\
    \ (n % 2 == 0) \n    { \n        res ~= 2; \n        n = n / 2; \n    } \n   \
    \ for (long i = 3; i <= sqrt(n); i = i + 2) \n    { \n        while (n % i ==\
    \ 0) \n        { \n            res ~= i; \n            n = n / i; \n        }\
    \ \n    } \n    if (n > 2) \n        res ~= n; \n    return res; \n} ", "{\n \
    \   if (n == 0)\n    {\n        return new long[0];\n    }\n    else if (n ==\
    \ 1)\n    {\n        return new long[1];\n    }\n    else\n    {\n        long[]\
    \ primeFactors = new long[20];\n        long[] primes = {2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71};\n        int i = 0;\n \
    \       while (n > 1)\n        {\n            while (n % primes[i] == 0)\n   \
    \         {\n                primeFactors[i] = primes[i];\n                n /=\
    \ primes[i];\n            }\n            i++;\n        }\n        return primeFactors.filter!(a\
    \ => a != 0).array;\n    }\n}", "{\n    long[] res = [];\n    foreach(i; 2..n\
    \ + 1)\n    {\n        if (n % i == 0)\n        {\n            while (n % i ==\
    \ 0)\n            {\n                res ~= i;\n                n /= i;\n    \
    \        }\n        }\n    }\n    return res;\n}", "{\n    long[] factors = [];\n\
    \    while (n % 2 == 0) \n    {\n        factors ~= 2;\n        n /= 2;\n    }\n\
    \    long i = 3;\n    long max = cast(long)sqrt(n);\n    while (i <= max) \n \
    \   {\n        while (n % i == 0) \n        {\n            factors ~= i;\n   \
    \         n /= i;\n        }\n        i += 2;\n    }\n    if (n > 1) \n    {\n\
    \        factors ~= n;\n    }\n    return factors;\n}\n/*\nReturn two points of\
    \ the line in the form (a, b) where a is the slope and b is the y-intercept.\n\
    >>line = linePoints((3, 2), (7, 8))\n>>assert(line == (1, 2))\n*/\nTuple!(real,\
    \ real) linePoints(Tuple!(real, real) point1, Tuple!(real, real) point2)\n{\n\
    \    real a = (point2[1] - point1[1]) / (point2[0] - point1[0]);\n    real b =\
    \ point1[1] - a * point1[0];\n    return tuple(a, b);\n}\n/*\nReturn the sum of\
    \ the digits of the given integer.\n>>> sumDigits(12)\n3\n>>> sumDigits(12345)\n\
    15\n*/", "{ \n    // Your code goes here \n    long[] factors=new long[100];\n\
    \    long[] res=new long[100];\n    int k=0;\n    int c=0;\n    int i=0;\n   \
    \ long p=2;\n    long mul=1;\n    for(long j=2;j<=n;j++)\n    {\n        if(n%j==0)\n\
    \        {\n            factors[k]=j;\n            k++;\n        }\n    }\n  \
    \  while(i<k)\n    {\n        p=factors[i];\n        while(factors[i]==p)\n  \
    \      {\n            c++;\n            i++;\n        }\n        mul=pow(p,c);\n\
    \        res[i]=mul;\n        c=0;\n    }\n    long[] rres=new long[k];\n    for(int\
    \ u=0;u<k;u++)\n    {\n        rres[u]=res[u];\n    }\n    return rres;\n} ",
  "{\n    long[] factors = [2];\n    long[] powers = [0];\n    long prime = 2;\n \
    \   long power = 0;\n    while (n != 1) \n    {\n        while (n % prime == 0)\
    \ \n        {\n            power++;\n            n /= prime;\n        }\n    \
    \    if (power != 0) \n        {\n            factors ~= prime;\n            powers\
    \ ~= power;\n        }\n        prime++;\n        power = 0;\n    }\n    long[]\
    \ result = [];\n    for (int i = 0; i < factors.length; i++) \n    {\n       \
    \ for (int j = 0; j < powers[i]; j++) \n        {\n            result ~= factors[i];\n\
    \        }\n    }\n    return result;\n}", "{\n    // TODO: Implement\n    long[]\
    \ prime_factors;\n    return prime_factors;\n}\n/*\n    Print n prime numbers\n\
    \    >>> primes(10)\n    2 3 5 7 11 13 17 19 23 29\n*/", "{\n    long[] result\
    \ = new long[0];\n    foreach(factor; primeFactors(n))\n    {\n        foreach(i;\
    \ 0 .. factor.count)\n        {\n            result ~= factor.prime;\n       \
    \ }\n    }\n    return result;\n}", "{\n\tlong[] res;\n\tlong x = n;\n\tforeach(i;2..n)\n\
    \t{\n\t\twhile(x%i==0)\n\t\t{\n\t\t\tres ~= i;\n\t\t\tx/=i;\n\t\t}\n\t}\n\treturn\
    \ res;\n}", "{\n    import std.algorithm;\n    import std.conv;\n    import std.array;\n\
    \    import std.math;\n    import std.typecons;\n    import std.math : isPrime;\n\
    \    import std.traits : isIntegral;\n    enum isPrime = n.isPrime;\n    // writeln(n,\
    \ \"is prime: \", isPrime);\n    // writeln(n, \"isIntegral: \", isIntegral!(typeof(n)));\n\
    \    static if (isIntegral!(typeof(n)))\n    {\n        static if (isPrime)\n\
    \        {\n            return [n];\n        }\n        else\n        {\n    \
    \        // long[] factors = [1, n];\n            auto primers = iota(2, n.sqrt.ceil).filter!(n.isPrime).array;\n\
    \            long[] factors = [];\n            foreach (x; primers)\n        \
    \    {\n                while (n % x == 0)\n                {\n              \
    \      factors ~= x;\n                    n /= x;\n                }\n       \
    \     }\n            if (n == 1)\n            {\n                return factors;\n\
    \            }\n            else\n            {\n                return factors\
    \ ~ [n];\n            }\n        }\n    }\n    else \n    {\n        return [];\n\
    \    }\n}", "{\n    long[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113,\
    \ 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\
    \ 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\
    \ 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\
    \ 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,\
    \ 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601,\
    \ 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\
    \ 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821,\
    \ 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929,\
    \ 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031,\
    \ 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109,\
    \ 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201,", "{\n   \
    \ assert(n>1);\n    long[] result;\n    long tmp = n;\n    foreach(i;2..sqrt(n))\n\
    \    {\n        if(tmp%i==0)\n        {\n            result~=i;\n            tmp/=i;\n\
    \        }\n    }\n    if(tmp!=1) result~=tmp;\n    return result;\n}", "{\n \
    \   long[] res;\n    long f;\n    while (n > 1L)\n    {\n        f = smallestPrimeFactor(n);\n\
    \        res ~= f;\n        n /= f;\n    }\n    return res;\n}", "{\n    import\
    \ std.math;\n    import std.typecons;\n    long[] factors;\n    foreach(p; PrimeGenerator.primesUpTo(cast(long)sqrt(n)))\
    \ \n    {\n        while(n % p == 0) \n        {\n            n /= p;\n      \
    \      factors ~= p;\n        }\n    }\n    if(n > 1) \n    {\n        factors\
    \ ~= n;\n    }\n    return factors;\n}\n/*\n Given n, return the alphabetized\
    \ list of n-letter words.", "{\n    auto factors = [];\n    long i = 2;\n    long\
    \ remainder = n;\n    while (i <= remainder) \n    {\n        if (remainder %\
    \ i == 0) \n        {\n            // odd number of factors\n            if ((remainder\
    \ / i) % i == 0) \n            {\n                factors ~= i*i;\n          \
    \      remainder /= i*i;\n            }\n            else \n            {\n  \
    \              factors ~= i;\n                remainder /= i;\n            }\n\
    \        }\n        else \n        {\n            ++i;\n        }\n    }\n   \
    \ return factors;\n}\nstruct Point(T) \n{\n    T x;\n    T y;\n}\n/*\n Computes\
    \ the distance from the origin to the point\n >>> getDistance(Point!int(1, 1))\n\
    \ 2.0\n */\nauto getDistance(Point!T)(Point!T p)\n{\n    return sqrt(p.x * p.x\
    \ + p.y * p.y);\n}", "{\n    assert(n > 0);\n    long[] result = null;\n    foreach(i;\
    \ 2 .. trunc(sqrt(n)))\n    {\n        if (n % i == 0)\n        {\n          \
    \  long[] cur = factorize(n / i);\n            if (cur.length > 0)\n         \
    \   {\n                result = cur;\n                break;\n            }\n\
    \        }\n    }\n    if (result == null)\n    {\n        result = [n];\n   \
    \ }\n    else\n    {\n        result ~= 2;\n    }\n    return result;\n}", "{\n\
    \    long[] res = [];\n    foreach(p; takeWhile!(a => a < ceil(sqrt(n)), primes))\
    \ \n    {\n        size_t count = 0;\n        while(n % p == 0) \n        {\n\
    \            count++;\n            n /= p;\n        }\n        if(count > 0) \n\
    \        {\n            long[] arr = replicate(count, p);\n            res ~=\
    \ arr;\n        }\n    }\n    if(n > 1) \n    {\n        long[] arr = replicate(1,\
    \ n);\n        res ~= arr;\n    }\n    return res;\n}\nassert(factorize(8L) ==\
    \ [2L, 2L, 2L]);\nassert(factorize(25L) == [5L, 5L]);\nassert(factorize(70L) ==\
    \ [2L, 5L, 7L]);", "{\n\tauto res = new long[];", "{\n    long sq = (long)sqrt(n);\n\
    \    ulong p = 2;\n    while (p <= sq)\n    {\n      while (n % p == 0)\n    \
    \  {\n        n /= p;\n        writeln(p);\n      }\n      p++;\n    }\n    if\
    \ (n != 1)\n    {\n      writeln(n);\n    }\n    return [1,1,1];\n}", "{\n   \
    \ if (n == 1) return [1];\n    auto primes = generatePrimes(n);\n    import std.algorithm;\n\
    \    auto result = [].init;\n    foreach (p; primes)\n    {\n        while (n\
    \ % p == 0)\n        {\n            result ~= p;\n            n /= p;\n      \
    \  }\n    }\n    return result;\n}\n \nlong[] generatePrimes(long n)\n{\n    auto\
    \ primes = [2].init;\n    foreach (i; 2..n + 1)\n    {\n        foreach (p; primes)\n\
    \        {\n            if (i % p == 0) break;\n            if (p * p > i)\n \
    \           {\n                primes ~= i;\n                break;\n        \
    \    }\n        }\n    }\n    return primes;\n}\n \n//test\nassert(factorize(8L)\
    \ == [2L, 2L, 2L]);\nassert(factorize(25L) == [5L, 5L]);\nassert(factorize(70L)\
    \ == [2L, 5L, 7L]);\n \nunittest\n{\n    import std.algorithm;\n    import std.stdio;\n\
    \    long[] results = [\n        [1],\n        [2],\n        [2, 2],\n       \
    \ [2, 3],\n        [2, 2, 2],\n        [3, 3],\n        [2, 5],\n        [2, 2,\
    \ 3],\n        [2, 7],\n        [2, 2, 2, 2],\n        [3, 5],\n        [2, 2,\
    \ 7],\n        [2, 3, 3],\n        [2, 2, 2, 3],\n        [2, 2, 5],\n       \
    \ [2, 11],\n        [2, 2, 2, 2, 2],\n        [3, 3, 3],\n        [2, 2, 13],\n\
    \        [2, 17],\n        [2, 2, 2, 2, 3],\n        [2, 19],\n        [2, 2,\
    \ 2, 5],\n        [2, 3, 7],\n        [2, 2, 2, 2,", "{\n    long[] result;\n\
    \    int i = 2;\n    while (n > 1) \n    {\n        if (n % i == 0) \n       \
    \ {\n            result ~= i;\n            n /= i;\n        }\n        else \n\
    \        {\n            i++;\n        }\n    }\n    return result;\n}", "{\n \
    \   if (n <= 1L)\n        return [n];\n    else if (n%2L == 0L)\n        return\
    \ [2L] ~ factorize(n/2L);\n    else if (n%3L == 0L)\n        return [3L] ~ factorize(n/3L);\n\
    \    else\n    {\n        long p = 5L;\n        while (p*p <= n)\n        {\n\
    \            if (n%p == 0L)\n                return [p] ~ factorize(n/p);\n  \
    \          p += 2L;\n            if (n%p == 0L)\n                return [p] ~\
    \ factorize(n/p);\n            p += 4L;\n        }\n        return [n];\n    }\n\
    }\n/*\n    Return array of prime numbers from 2 to n.\n    >>> sieve(10L)\n  \
    \  [2L, 3L, 5L, 7L]\n*/\nlong[] sieve(long n)\n{\n    import std.conv;\n    import\
    \ std.math;\n    import std.algorithm;\n    import std.array;\n    import std.typecons;\n\
    \    import std.range;\n    import std.bitmanip;\n    import std.meta;\n    import\
    \ std.bitmanip;\n    // Generate list of numbers: 2, 3, 4, ..., n\n    Tuple!(long[],\
    \ uint[]) t = tuple(iota(n - 1L).array, repeat(1u, n - 1L).array);\n    // Eliminate\
    \ all multiples of 2\n    t[1][2L] = 0u;\n    long i = 3L;\n    long mul = 2L;\n\
    \    long m = n/2L;\n    // Eliminate all odd multiples of all primes <= n\n \
    \   while (i <= m)\n    {\n        // Skip all even multiples\n        if (t[1][i]\
    \ == 1u)\n        {\n            mul = 2L;\n            // Eliminate all odd multiples\n\
    \            foreach (j; iota(i*mul, n, i*2L))\n                t[1][j] = 0u;\n\
    \        }\n        i", "{\n    int i = 0;\n    long[] result;\n    int j = 0;\n\
    \    foreach(d; iota(2, n).front.takeWhile!((i) => (i * i <= n))) \n    {\n  \
    \      while(n % d == 0) \n        {\n            n /= d;\n            result[j]\
    \ = d;\n            j++;\n        }\n    }\n    if(n > 1) \n    {\n        result[j]\
    \ = n;\n    }\n    return result;\n}\n/*\n Given a list of words and a string\
    \ S, find all starting indices in S which are anagrams of words in the given list.\n\
    \    >>> findAnagrams(\"abxaba\", [\"ab\", \"ba\", \"abx\", \"xab\", \"axb\"])\n\
    \    [0, 3, 4]\n*/", "{\n    if (n < 2) \n        return [n];\n    long[] factors\
    \ = [2], \n        total = [],\n        factorIdx = 0;\n    while (n > 1) \n \
    \   {\n        if (n % factors[factorIdx] == 0) \n        {\n            n /=\
    \ factors[factorIdx];\n            total ~= factors[factorIdx];\n        }\n \
    \       else \n        {\n            // Need to find the next factor, but only\
    \ search up to the square root of n.\n            // If we search any higher,\
    \ then it's either n or a factor that we've already accounted for.\n         \
    \   // If a factor is found, then it will be added to the factors array and factorIdx\
    \ will be incremented.\n            long upperBound = cast(long)sqrt(n);\n   \
    \         foreach (i; 2..upperBound) \n            {\n                if (n %\
    \ i == 0) \n                {\n                    factors ~= i;\n           \
    \         factorIdx++;\n                    break;\n                }\n      \
    \      }\n            // If no factor was found, then that means that n is prime\
    \ and doesn't have any more factors.\n            if (i == upperBound) \n    \
    \        {\n                factors ~= n;\n                total ~= n;\n     \
    \           break;\n            }\n        }\n    }\n    return total;\n}", "{\n\
    \    long[] result;\n    long i = 2;\n    while (i <= n)\n    {\n        if (n\
    \ % i == 0)\n        {\n            result ~= i;\n            n /= i;\n      \
    \  }\n        else\n        {\n            i++;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] primes = new long[0L];\n    long[] factors = new\
    \ long[0L];\n    for (long i = 2L; i < n; i++) \n    {\n        if (n % i == 0L)\
    \ \n        {\n            bool isPrime = true;\n            foreach (prime; primes)\
    \ \n            {\n                if (i % prime == 0L) \n                {\n\
    \                    isPrime = false;\n                    break;\n          \
    \      }\n            }\n            if (isPrime) \n            {\n          \
    \      factors ~= i;\n                n /= i;\n                i--;\n        \
    \    }\n        }\n    }\n    return factors;\n}", "{\n    assert(n >= 2L);\n\
    \    import std.algorithm : filter, sort, uniq;\n    import std.math : isPrime;\n\
    \    import std.range : iota;\n    import std.conv : to;\n    import std.typecons\
    \ : tuple;\n    import std.array : appender;\n    import std.array : empty;\n\
    \    import std.array : array;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.internal.math.fp_utils : pow;\n    import std.math\
    \ : pow;\n    import std.range : zip;\n    import std.typecons : tuple;\n    auto\
    \ a = appender!(long[])();\n    foreach(p; 2L..n+1L)\n    {\n        if(n % p\
    \ == 0L)\n        {\n            a.put(p);\n            n /= p;\n        }\n \
    \   }\n    a.put(n);\n    return a.data;\n}", "{ \n    \n    static import std.algorithm.searching\
    \ : all;\n    static import std.array : array;\n    static import std.math : floor;\n\
    \    static import std.algorithm.sorting : sort;\n    static import std.container\
    \ : appender;\n    static import std.conv : to;\n    static import std.range :\
    \ iterate;\n    static import std.bitmanip : setBit;\n    static import std.range\
    \ : retro;\n    static import std.algorithm.iteration : map;\n    static import\
    \ std.range : cycle;\n    static import std.algorithm.comparison : equal;\n  \
    \  static import std.algorithm.searching : find;\n    static import std.math :\
    \ log2;\n    static import std.array : repeat;\n    static import std.algorithm.mutation\
    \ : pushFront;\n    static import std.algorithm.mutation : popFront;\n    static\
    \ import std.algorithm.mutation : popBack;\n    static import std.algorithm.mutation\
    \ : popBack;\n    static import std.algorithm.mutation : pushBack;\n    static\
    \ import std.typecons : tuple;\n    static import std.typecons : Tuple;\n    static\
    \ import std.array : append;\n    static import std.algorithm.mutation : splice;\n\
    \    static import std.algorithm.mutation : insert;\n    static import std.algorithm.mutation\
    \ : remove;\n    static import std.algorithm.mutation : insert;\n    static import\
    \ std.range : take;\n    static import std.range : takeExactly;\n    static import\
    \ std.algorithm.mutation : remove;\n    static import std.algorithm.mutation :\
    \ remove;\n    static import std.range : retro;\n    static import std.algorithm.mutation\
    \ : swap;\n    static import std.internal.math.primitive : ilog2;\n    static\
    \ import std.range : cycle;\n    static import std.range : only;\n    static import\
    \ std.algorithm.mutation : popFront;\n    static import std.range : take;\n  \
    \  static import std.array : array;\n    static import std.algorithm.mutation\
    \ : splice;\n    static import std", "{\n\t\n\tlong[] factors = [];\n\twhile (n\
    \ % 2 == 0) \n\t{\n\t\tfactors ~= 2;\n\t\tn /= 2;\n\t}\n\tfor (int i = 3; i <=\
    \ n; i += 2) \n\t{\n\t\twhile (n % i == 0) \n\t\t{\n\t\t\tfactors ~= i;\n\t\t\t\
    n /= i;\n\t\t}\n\t}\n\treturn factors;\n}", "{\n    long[] r = new long[];\n \
    \   while (n % 2 == 0) \n    {\n        r ~= 2;\n        n /= 2;\n    }\n    long\
    \ i = 3;\n    while (i * i <= n) \n    {\n        while (n % i == 0) \n      \
    \  {\n            r ~= i;\n            n /= i;\n        }\n        i += 2;\n \
    \   }\n    if (n > 1)\n        r ~= n;\n    return r;\n}\n/*\n    Return greatest\
    \ common divisor\n    >>> gcd(12L, 18L)\n    6L\n    >>> gcd(6L, 18L)\n    6L\n\
    \    >>> gcd(6L, 12L)\n    6L\n    >>> gcd(3L, 5L)\n    1L\n*/\nlong gcd(long\
    \ a, long b) \n{\n    while (b != 0) \n    {\n        long tmp = a % b;\n    \
    \    a = b;\n        b = tmp;\n    }\n    return a;\n}\n/*\n    Return least common\
    \ multiple\n    >>> lcm(12L, 18L)\n    36L\n    >>> lcm(6L, 18L)\n    18L\n  \
    \  >>> lcm(6L, 12L)\n    12L\n    >>> lcm(3L, 5L)\n    15L\n*/\nlong lcm(long\
    \ a, long b) \n{\n    return a * b / gcd(a, b);\n}\n/*\n    Return a set of all\
    \ the divisors of the given number \n    >>> divisors(36L)\n    [1L, 2L, 3L, 4L,\
    \ 6L, 9L, 12L, 18L, 36L]\n    >>> divisors(9L)\n    [1L, 3L, 9L]\n    >>> divisors(1L)\n\
    \    [1L]\n*/\nlong[] divisors(long n) \n{\n    long[] r = new long[];\n    foreach\
    \ (i; 1L .. n + 1L) \n    {\n        if (n % i == 0", "{ \n    long i; \n    bool[]\
    \ is_prime = new bool[n + 1]; \n    for (i = 2; i <= n; i++) { \n        is_prime[i]\
    \ = true; \n    } \n    for (i = 2; i * i <= n; i++) { \n        if (is_prime[i])\
    \ { \n            for (long j = i * i; j <= n; j += i) { \n                is_prime[j]\
    \ = false; \n            } \n        } \n    } \n    long[] primes = new long[n\
    \ + 1]; \n    long len = 0; \n    for (i = 2; i <= n; i++) { \n        if (is_prime[i])\
    \ { \n            primes[len] = i; \n            len++; \n        } \n    } \n\
    \    long tmp = n; \n    long[] res = new long[len]; \n    long len_res = 0; \n\
    \    for (i = 0; i < len; i++) { \n        while (tmp % primes[i] == 0) { \n \
    \           res[len_res] = primes[i]; \n            len_res++; \n            tmp\
    \ /= primes[i]; \n        } \n    } \n    return res[0..len_res]; \n} \n/*\n \
    \   Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize_2(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize_2(25L)\n    [5L, 5L]\n    >>> factorize_2(70L)\n    [2L, 5L,\
    \ 7L]\n*/\nlong[] factorize_2(long n)\n{\n    auto primes = sieve_prime(n);\n\
    \    long tmp = n;\n    long[] res = new long[primes.length];\n    long len_res\
    \ = 0;\n    foreach(", "{\n\tlong[] ret;\n\tforeach(prime; PrimeSieve!(long)(sqrt(n)\
    \ + 1L))\n\t{\n\t\tif(n % prime == 0)\n\t\t{\n\t\t\tret ~= prime;\n\t\t\tn /=\
    \ prime;\n\t\t}\n\t}\n\treturn ret;\n}", "{\n    import std.math;\n    auto factors\
    \ = appender!(long[])();\n    auto chkFactor = appender!(long[])();\n    long\
    \ i = 2;\n    while (n > 1) \n    {\n        while (n % i == 0) \n        {\n\
    \            factors.put(i);\n            n /= i;\n        }\n        i++;\n \
    \   }\n    return chkFactor.data;\n}\n//def factorize(n):\n    //import math\n\
    \    //factors = []\n    //for i in range(2, int(math.sqrt(n) + 1)):\n       \
    \ //while n % i == 0:\n            //factors.append(i)\n            //n //= i\n\
    \    //if n > 1:\n        //factors.append(n)\n    //return factors", "{\n   \
    \  /*\n         * Take a number and divide it by two until the remainder is 0\n\
    \         * */\n    long[] primes = new long[100]; \n    int count = 0;\n    \n\
    \    while (n % 2 == 0) \n    { \n        primes[count] = 2; \n        count++;\n\
    \        n = n / 2; \n    } \n  \n    /* n must be odd at this point.  So we can\
    \ skip  \n       one element (Note i = i +2) */\n    for (long i = 3; i <= sqrt(n);\
    \ i = i + 2) \n    { \n        // While i divides n, print i and divide n \n \
    \       while (n % i == 0) \n        { \n            primes[count] = i; \n   \
    \         count++;\n            n = n / i; \n        } \n    } \n  \n    // This\
    \ condition is to handle the case when n  \n    // is a prime number greater than\
    \ 2 \n    if (n > 2) \n    {\n        primes[count] = n; \n        count++;\n\
    \    } \n    \n    primes = primes[0..count];\n    \n    return primes;\n}", "{\n\
    \    bool[] isPrime = new bool[n + 1];\n    for (size_t i = 0; i < isPrime.length;\
    \ i++)\n    {\n        isPrime[i] = true;\n    }\n    isPrime[0] = false;\n  \
    \  isPrime[1] = false;\n    for (size_t i = 2; i < isPrime.length; i++)\n    {\n\
    \        if (isPrime[i])\n        {\n            for (size_t j = i * i; j < isPrime.length;\
    \ j += i)\n            {\n                isPrime[j] = false;\n            }\n\
    \        }\n    }\n    bool[] isComp = new bool[n + 1];\n    for (size_t i = 0;\
    \ i < isComp.length; i++)\n    {\n        isComp[i] = false;\n    }\n    for (size_t\
    \ i = 2; i < isComp.length; i++)\n    {\n        if (isPrime[i])\n        {\n\
    \            for (size_t j = i * i; j < isComp.length; j += i)\n            {\n\
    \                isComp[j] = true;\n            }\n        }\n    }\n    bool[]\
    \ isSquare = new bool[n + 1];\n    for (size_t i = 0; i < isSquare.length; i++)\n\
    \    {\n        isSquare[i] = false;\n    }\n    for (size_t i = 2; i < isSquare.length;\
    \ i++)\n    {\n        if (isPrime[i])\n        {\n            for (size_t j =\
    \ i * i; j < isSquare.length; j += i * i)\n            {\n                isSquare[j]\
    \ = true;\n            }\n        }\n    }\n    long[] factors = [];\n    while\
    \ (isSquare[n])\n    {\n        factors ~= n;\n        n /= n;\n    }\n    while\
    \ (isComp[n])\n    {\n        for (size_t i = 2; i < isPrime.length; i++)\n  \
    \      {\n            if (isPrime[i] && n % i == 0)\n            {\n         \
    \       factors ~=", "{\n    assert(n > 0);\n    if (n == 1) return new long[0];\n\
    \    long[] result = new long[];\n    while (n % 2 == 0) {\n        result ~=\
    \ 2;\n        n /= 2;\n    }\n    while (n % 3 == 0) {\n        result ~= 3;\n\
    \        n /= 3;\n    }\n    while (n % 5 == 0) {\n        result ~= 5;\n    \
    \    n /= 5;\n    }\n    long i = 7;\n    // Any composite number should be able\
    \ to expressed as: n = p*k with p a prime, k < n\n    //      Therefore, each\
    \ composite number has at least one prime factor < sqrt(n)\n    //      Therefore,\
    \ for each factor which is >= sqrt(n), if we find there is no such prime, n must\
    \ be prime\n    //      Therefore, there is no need to check for potential prime\
    \ factors greater than sqrt(n)\n    //      But we still need to check for the\
    \ potential prime factors less than sqrt(n)\n    while (i*i <= n) {\n        while\
    \ (n % i == 0) {\n            result ~= i;\n            n /= i;\n        }\n \
    \       i += 4;\n        while (n % i == 0) {\n            result ~= i;\n    \
    \        n /= i;\n        }\n        i += 2;\n        while (n % i == 0) {\n \
    \           result ~= i;\n            n /= i;\n        }\n        i += 4;\n  \
    \      while (n % i == 0) {\n            result ~= i;\n            n /= i;\n \
    \       }\n        i += 2;\n        while (n % i == 0) {\n            result ~=\
    \ i;\n            n /= i;\n        }\n        i += 4;\n        while (n % i ==\
    \ 0) {\n            result ~= i;\n            n /= i;\n        }\n        i +=\
    \ 6;\n        while (n % i == 0) {\n            result ~= i;\n            n /=\
    \ i;\n        }\n        i += 2;\n        while (n % i == 0) {\n            result\
    \ ~=", "{\n    long[] result = new long[0];\n    long d = 2;\n    while (n > 1)\
    \ \n    {\n        int cnt = 0;\n        while (n % d == 0) \n        {\n    \
    \        cnt++;\n            n /= d;\n        }\n        if (cnt != 0)\n     \
    \       result ~= repeat(d, cnt);\n        d++;\n    }\n    return result;\n}",
  "{\n    if (n < 2) return new long[0];\n    import std.math;\n    auto divisors\
    \ = new long[100];\n    size_t size = 0;\n    foreach (prime; iota(2, sqrt(n)))\n\
    \    {\n        while (n % prime == 0)\n        {\n            divisors[size++]\
    \ = prime;\n            n /= prime;\n        }\n    }\n    divisors[size++] =\
    \ n;\n    return divisors[0 .. size];\n}\nsize_t[] factorize(size_t n) {\n   \
    \ if (n < 2) return new size_t[0];\n    import std.math;\n    auto divisors =\
    \ new size_t[100];\n    size_t size = 0;\n    foreach (prime; iota(2, sqrt(n)))\n\
    \    {\n        while (n % prime == 0)\n        {\n            divisors[size++]\
    \ = prime;\n            n /= prime;\n        }\n    }\n    divisors[size++] =\
    \ n;\n    return divisors[0 .. size];\n}", "{\n    n = n.abs;\n    long[] result\
    \ = null;\n    long[] prime;\n    ulong[] bitP;\n    if (n < 2)\n    {\n     \
    \   return [1L];\n    }\n    bitP = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\
    \ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\
    \ 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\
    \ 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,\
    \ 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,\
    \ 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,\
    \ 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,\
    \ 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,\
    \ 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170,\
    \ 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186,\
    \ 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202,\
    \ 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218,\
    \ 219, 220, 221, 222, 223, 224, 225, 226", "{\n    \n    auto factors = new long[];\n\
    \    int p = 2;\n    while (p <= sqrt(n)) \n    {\n        while (n % p == 0)\
    \ \n        {\n            factors ~= p;\n            n /= p;\n        }\n   \
    \     p += 1;\n    }\n    if (n > 1) \n    {\n        factors ~= n;\n    }\n \
    \   return factors;\n}\n/*\n    Return the largest prime factor of given integer\n\
    \    >>> primeFactor(4L)\n    2L\n    >>> primeFactor(9L)\n    3L\n    >>> primeFactor(31L)\n\
    \    31L\n*/\nlong primeFactor(long n) \n{\n    return factorize(n).back;\n}\n\
    /*\n    >>> triangular(1)\n    1\n    >>> triangular(3)\n    6\n    >>> triangular(6)\n\
    \    21\n    >>> triangular(10)\n    55\n    >>> triangular(15)\n    120\n*/\n\
    long triangular(long n) \n{\n    return n * (n + 1) / 2;\n}\n/*\n>>> nthTriangular(1)\n\
    1\n>>> nthTriangular(2)\n3\n>>> nthTriangular(5)\n15\n>>> nthTriangular(10)\n\
    55\n>>> nthTriangular(15)\n120\n*/\nlong nthTriangular(long n) \n{\n    return\
    \ triangular(n);\n}\n/*\n>>> numDivisors(1)\n1\n>>> numDivisors(3)\n2\n>>> numDivisors(6)\n\
    4\n>>> numDivisors(10)\n4\n>>> numDivisors(15)\n4\n>>> numDivisors(21)\n4\n>>>\
    \ numDivisors(28)\n6\n*/\nlong numDivisors(long n) \n{\n    auto factors = factorize(n);\n\
    \    auto ret = 1;\n    for (int i = 0; i < factors.length; i++) \n    {\n   \
    \     ret *= factors[i].count;\n    }\n    return ret;\n}\n/*\n>>> triangularNumberWithOverNDivisors(5)\n\
    28\n>>>", "{\n    long i=2;\n    auto f;\n    while(i*i<=n)\n    {\n        if(n%i==0)\n\
    \        {\n            f~=i;\n            n/=i;\n        }\n        else\n  \
    \          i++;\n    }\n    if(n>1)\n        f~=n;\n    return f;\n}\n/*\n   \
    \ Find number of divisors of given integer\n    >>> divisors(8L)\n    4\n    >>>\
    \ divisors(25L)\n    3\n    >>> divisors(70L)\n    8\n    I changed the original\
    \ to allow return of the list of divisors as well.\n*/\nTuple!(int,Tuple!(int[]))\
    \ divisors(ulong n)\n{\n    auto divs = [1];\n    ulong i=2;\n    while(i*i<=n)\n\
    \    {\n        if(n%i==0)\n        {\n            divs~=i;\n            divs~=n/i;\n\
    \        }\n        i++;\n    }\n    if(i*i==n)\n        divs~=i;\n    return\
    \ tuple(divs.length,divs);\n}\n/*\n    Given integer number n, return the greatest\
    \ odd divisor of n\n    >>> greatest_odd_divisor(8L)\n    1\n    >>> greatest_odd_divisor(25L)\n\
    \    25\n    >>> greatest_odd_divisor(70L)\n    35\n*/\nulong greatest_odd_divisor(ulong\
    \ n)\n{\n    ulong k=1;\n    ulong i=3;\n    while(i*i<=n)\n    {\n        if(n%i==0)\n\
    \            k=i;\n        i+=2;\n    }\n    if(k==1)\n        return n;\n   \
    \ return k;\n}\n/*\n    Given integer number n, return the smallest odd divisor\
    \ of n\n    >>> smallest_odd_divisor(8L)\n    1\n    >>> smallest_odd_divisor(25L)\n\
    \    5\n    >>> smallest_", "{\n\tlong[] result = new long[]; \n\tfor (long i\
    \ = 2; i <= n; ++i) \n\t{\n\t\twhile (n % i == 0) \n\t\t{\n\t\t\tresult ~= i;\n\
    \t\t\tn /= i;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Return a tuple (gcd,x,y)\
    \ where gcd is the greatest common divisor of a and b, and x,y are such that ax+by=gcd.\n\
    \    The number of iterations should be no more than a few dozen.\n    >>> gcd(48,18)\n\
    \    (6L, 2L, -1L)\n*/\nTuple!(long,long,long) gcd(long a, long b) \n{\n\tif (a\
    \ % b == 0)\n\t\treturn tuple(b, 0, 1);\n\telse \n\t{\n\t\tauto r = gcd(b, a %\
    \ b);\n\t\treturn tuple(r[0], r[2], r[1] - r[2] * (a / b));\n\t}\n}\n/*\n Return\
    \ a tuple (gcd,x,y) where gcd is the greatest common divisor of a and b, and x,y\
    \ are such that ax+by=gcd.\n    The number of iterations should be no more than\
    \ a few dozen.\n    >>> gcd(48,18)\n    (6L, 2L, -1L)\n*/\nTuple!(long,long,long)\
    \ gcd(long a, long b) \n{\n\t// http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \t// http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n\twhile (b !=\
    \ 0) \n\t{\n\t\tlong c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn tuple(a,\
    \ 0, 1);\n}\n/*\n Return a tuple (x,y) such that x*a+y*b=gcd(a,b)\n    >>> egcd(48,18)\n\
    \    (2L, -1", "{\n    long[] result = [];\n    import std.algorithm.comparison\
    \ : min;\n    import std.math;\n    if (n == 0)\n        return [0L];\n    while\
    \ (n != 1)\n    {\n        ulong p = primes(n, 2L);\n        result ~= p;\n  \
    \      n /= p;\n    }\n    return result;\n}\n/*\n Given a list of prime factors\
    \ of a positive integer. \n Return a list of lists of factors, where each list\
    \ corresponds to a prime factor.\n Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ >>> partition(0)\n    [[0]]\n    >>> partition(1)\n    [[1]]\n    >>> partition(2)\n\
    \    [[2]]\n    >>> partition(4)\n    [[2, 2]]\n    >>> partition(5)\n    [[5]]\n\
    \    >>> partition(8)\n    [[2, 2, 2]]\n    >>> partition(25)\n    [[5, 5]]\n\
    \    >>> partition(70)\n    [[2, 5, 7]]\n    >>> partition(1000)\n    [[2, 2,\
    \ 2, 5, 5, 5]]\n*/\nlong[][] partition(long n)\n{\n    long[] factors = factorize(n);\n\
    \    import std.algorithm.comparison : min;\n    import std.math;\n    import\
    \ std.algorithm.comparison : min;\n    import std.math;\n    if (n == 0)\n   \
    \     return [[0L]];\n    long[][] result = [];\n    long[] primes = factors[];\n\
    \    long prime = factors[0];\n    long[] p = [];\n    import std.algorithm.comparison\
    \ : min;\n    import std.math;\n    if (n == 0)\n        return [[0L]];\n    long[][]\
    \ result = [];\n    long[] primes = factors[];\n    long prime = factors[0];\n\
    \    long[] p = [];\n    foreach (x; factors)\n    {\n        if (x == prime)\n\
    \            p ~= x;\n        else\n        {\n            result ~= p;\n", "{\n\
    \    // 1 is not a prime number\n    if (n == 1) return new long[](0);\n    //\
    \ 2 is the only even prime number\n    if (n == 2) return new long[](1) ~= 2;\n\
    \    // else, iterate throught odd numbers\n    long[] primes = new long[](0);\n\
    \    for (long i = 3; i <= n / 2; i += 2)\n    {\n        if (n % i == 0)\n  \
    \      {\n            long[] temp = factorize(i);\n            foreach (a; temp)\n\
    \                primes ~= a;\n            n /= i;\n            temp = factorize(n);\n\
    \            foreach (a; temp)\n                primes ~= a;\n            break;\n\
    \        }\n    }\n    return primes;\n}", "{ \n    \n    long[] out = [];\n \
    \   while (n%2 == 0) \n    { \n        out ~= 2; \n        n = n/2; \n    } \n\
    \    for (long i = 3; i <= sqrt(n); i = i+2) \n    { \n        while (n%i == 0)\
    \ \n        { \n            out ~= i; \n            n = n/i; \n        } \n  \
    \  } \n    if (n > 2) \n        out ~= n; \n    return out;\n} \n    ", "{\n \
    \   static long[] factorizeR(long n, long i) \n    {\n        if (n <= 1)\n  \
    \          return [ ];\n        if (n % i == 0)\n            return [i] ~ factorizeR(n\
    \ / i, i);\n        return factorizeR(n, i + 1);\n    }\n    static assert(isPrime(3));\n\
    \    static assert(!isPrime(4));\n    static assert(isPrime(5));\n    static assert(!isPrime(6));\n\
    \    static assert(isPrime(7));\n    static assert(!isPrime(8));\n    static assert(!isPrime(9));\n\
    \    static assert(!isPrime(10));\n    static assert(isPrime(11));\n    static\
    \ assert(!isPrime(12));\n    static assert(isPrime(13));\n    static assert(!isPrime(14));\n\
    \    static assert(!isPrime(15));\n    static assert(!isPrime(16));\n    static\
    \ assert(isPrime(17));\n    static assert(!isPrime(18));\n    static assert(isPrime(19));\n\
    \    static assert(!isPrime(20));\n    static assert(isPrime(29));\n    static\
    \ assert(isPrime(31));\n    static assert(isPrime(37));\n    static assert(isPrime(41));\n\
    \    static assert(isPrime(43));\n    static assert(isPrime(47));\n    static\
    \ assert(isPrime(53));\n    static assert(isPrime(59));\n    static assert(isPrime(61));\n\
    \    static assert(isPrime(67));\n    static assert(isPrime(71));\n    static\
    \ assert(isPrime(73));\n    static assert(isPrime(79));\n    static assert(isPrime(83));\n\
    \    static assert(isPrime(89));\n    static assert(isPrime(97));\n    static\
    \ assert(isPrime(101));\n    static assert(isPrime(103));\n    static assert(isPrime(107));\n\
    \    static assert(isPrime(109));\n    static assert(isPrime(113));\n    static\
    \ assert(isPrime(127));\n    static assert(isPrime(131));\n    static assert(isPrime(137));\n\
    \    static assert", "{\n    long[] ret;\n    long i;\n    while(n % 2 == 0)\n\
    \    {\n        ret ~= 2;\n        n /= 2;\n    }\n    for(i = 3; i <= n; i +=\
    \ 2)\n    {\n        while(n % i == 0)\n        {\n            ret ~= i;\n   \
    \         n /= i;\n        }\n    }\n    return ret;\n}", "{\n    long[] factors\
    \ = new long[];\n    if (n == 1) \n    {\n        return factors;\n    }\n   \
    \ else \n    {\n        while (n % 2 == 0) \n        {\n            factors ~=\
    \ 2;\n            n /= 2;\n        }\n        long f = 3;\n        while (f *\
    \ f <= n) \n        {\n            if (n % f == 0) \n            {\n         \
    \       factors ~= f;\n                n /= f;\n            }\n            else\
    \ \n            {\n                f += 2;\n            }\n        }\n       \
    \ if (n != 1) \n        {\n            factors ~= n;\n        }\n        return\
    \ factors;\n    }\n}\n/*\n    Compute the sum of all positive integers up to and\
    \ including n, that are\n    divisible by either a or b.\n    >>> sumDivisibleBy(6,\
    \ 3)\n    9\n    >>> sumDivisibleBy(10, 3)\n    18\n    >>> sumDivisibleBy(10,\
    \ 5)\n    15\n    >>> sumDivisibleBy(10, 5)\n    15\n    >>> sumDivisibleBy(5,\
    \ 5)\n    5\n    >>> sumDivisibleBy(7, 11)\n    0\n    >>> sumDivisibleBy(11,\
    \ 7)\n    0\n*/\nlong sumDivisibleBy(long n, long a, long b) \n{\n    long sum\
    \ = 0;\n    for (long i = 0; i <= n; i++) \n    {\n        if (i % a == 0 || i\
    \ % b == 0) \n        {\n            sum += i;\n        }\n    }\n    return sum;\n\
    }\n/*\n    Given a string, return a string that is made of the first 2 chars (if\
    \ present), however include first char only if it is 'o' and include the second\
    \ only if it is 'z', so \"ozymandias\" yields \"oz\".\n    >>> startOz(\"ozymandias\"\
    )\n    \"oz\"\n    >>> startOz(\"bzoo\")\n    \"z\"\n    >>> startOz(\"oxx\")\n\
    \    \"o\"\n    >>> startOz(\"ounce\")\n    \"o\"", "{\n    long[] factors = [];",
  "{\n    long[] factors = {};\n    long[] primes = sieve(n);\n    long i = 0;\n \
    \   foreach(long prime; primes) \n    {\n        long factor = 0;\n        while\
    \ (n % prime == 0) \n        {\n            n /= prime;\n            factor++;\n\
    \        }\n        if (factor > 0) \n        {\n            factors = factors\
    \ ~ tuple(prime, factor);\n        }\n    }\n    long[] result = {};\n    foreach(tuple!(long,\
    \ long) factor; factors) \n    {\n        result = result ~ repeat(factor[0],\
    \ factor[1]);\n    }\n    return result;\n}", "{\n    long[] factors = [];\n \
    \   if (n <= 1) \n    {\n        return factors;\n    }\n    long x = 2;\n   \
    \ while (n >= x * x) \n    {\n        if (n % x == 0) \n        {\n          \
    \  factors ~= x;\n            n /= x;\n        } \n        else \n        {\n\
    \            x++;\n        }\n    }\n    factors ~= n;\n    return factors;\n\
    }\n/*\n Take array of numbers and return their product.\n    >>> product([1L,\
    \ 2L, 3L])\n    6L\n    >>> product([0L, 2L, 3L])\n    0L\n    >>> product([100L,\
    \ 200L, 300L])\n    6000000L\n    >>> product([1L, 2L, 0L, 3L])\n    0L\n*/\n\
    long product(long[] numbers) \n{\n    long result = 1;\n    foreach (num; numbers)\
    \ \n    {\n        result *= num;\n    }\n    return result;\n}\n \n/*\n Take\
    \ list of numbers and return sum of their squares.\n    >>> squareSum([1L, 2L,\
    \ 2L])\n    9L\n    >>> squareSum([0L, 3L, 4L, 5L])\n    50L\n*/\nlong squareSum(long[]\
    \ numbers) \n{\n    long result = 0;\n    foreach (num; numbers) \n    {\n   \
    \     result += num * num;\n    }\n    return result;\n}\n \n/*\n Take a list\
    \ of numbers and return true if first and last number are same.\n    >>> isSame([])\n\
    \    True\n    >>> isSame([1L])\n    True\n    >>> isSame([1L, 2L, 3L])\n    False\n\
    \    >>> isSame([1L, 2L, 1L])\n    True\n*/", "{\n\tlong i;\n\ti = 2;\n\tlong[]\
    \ res = new long[0];\n\twhile (n > 1) \n\t{\n\t\tif (n % i == 0) \n\t\t{\n\t\t\
    \tres ~= i;\n\t\t\tn /= i;\n\t\t} \n\t\telse \n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\
    \treturn res;\n}", "{\n    long[] result = [];\n    int i = 2;\n    while (n !=\
    \ 1) \n    {\n        while (n % i == 0) \n        {\n            result ~= i;\n\
    \            n /= i;\n        }\n        i++;\n    }\n    return result;\n}",
  "{ \n  long[] factors = [];\n  while (n % 2 == 0) \n  { \n    factors ~= 2; \n \
    \   n = n/2; \n  } \n  \n  for (long i = 3; i <= sqrt(n); i = i + 2) \n  { \n\
    \    while (n % i == 0) \n    { \n      factors ~= i; \n      n = n/i; \n    }\
    \ \n  } \n  \n  if (n > 2) \n    factors ~= n; \n  return factors;\n}", "{\n \
    \   long[] result = [];\n    foreach(i; 2..sqrt(n)+1) \n    {\n        if(n %\
    \ i == 0) \n        {\n            auto times = 0;\n            while(n % i ==\
    \ 0) \n            {\n                n /= i;\n                times++;\n    \
    \        }\n            result ~= repeat(i, times);\n        }\n    }\n    if(n\
    \ > 1) result ~= [n];\n    return result;\n}\n// test\nunittest \n{\n    assert(factorize(8L)\
    \ == [2L, 2L, 2L]);\n    assert(factorize(25L) == [5L, 5L]);\n    assert(factorize(70L)\
    \ == [2L, 5L, 7L]);\n}\n \n \n \n \n \n/*\n     1) count number of characters\
    \ in input string.\n        - exclude newline character\n        - get the number\
    \ by calling length method on string\n    2) count number of words in input string.\n\
    \        - words are separated by whitespace(newline, tab, space)\n        - use\
    \ split function (returns immutable(value) array)\n        - get the number by\
    \ calling length method on array\n    3) count number of lines in input string.\n\
    \        - lines are separated by newline\n        - use splitLines method (returns\
    \ immutable(value) array)\n        - get the number by calling length method on\
    \ array\n    4) replace consecutive whitespace with single space\n        - use\
    \ replace function with regex and replace by single space. \n        - start with\
    \ newline and tab then a space, to catch all whitespace (except newline)\n   \
    \ 5) create a list of words in input string\n        - use split function (returns\
    \ immutable(value) array)\n        - use foreach loop to output each word on a\
    \ new line (or use writeln)\n    6) create a list of lines in input string\n \
    \       - use splitLines method (returns immutable(value) array)\n        - use\
    \ foreach loop to output each line on a new line (or use writeln)\n    7) split\
    \ the input string into words and count each word.\n        - use split function\
    \ (returns immutable(value)", "{\n\treturn factorize(n, n);\n}", "{\n    if (n\
    \ <= 0L) \n        throw new Error(\"factorize: n should be positive\");\n   \
    \ if (n == 1L) \n        return typeof(this).init;\n    static long[] primes;\n\
    \    static long[] primeFactors;\n    static bool[] isComposite;\n    static if\
    \ (!primes) \n    {\n        enum \n        {\n            maxn = 1_000_000L\n\
    \        };\n        primes = new long[maxn / log(maxn) + 5];\n        primeFactors\
    \ = new long[maxn];\n        isComposite = new bool[maxn];\n        isComposite[0]\
    \ = true;\n        isComposite[1] = true;\n        foreach (immutable i; 2 ..\
    \ maxn) \n        {\n            if (!isComposite[i]) \n            {\n      \
    \          primes ~= i;\n                primeFactors[i] = i;\n            }\n\
    \            foreach (immutable j; 0 .. primes.length) \n            {\n     \
    \           immutable p = primes[j];\n                if (p * i >= maxn) \n  \
    \                  break;\n                isComposite[p * i] = true;\n      \
    \          primeFactors[p * i] = p;\n                if (i % p == 0) \n      \
    \              break;\n            }\n        }\n    }\n    long factor;\n   \
    \ long[] res;\n    while (n > 1L) \n    {\n        factor = primeFactors[n];\n\
    \        res ~= factor;\n        while (n % factor == 0L) \n            n /= factor;\n\
    \    }\n    return res;\n}", "{\n\t\tlong i,d, reslen=0;\n\t\tlong[] res = new\
    \ long[reslen];\n\t\td=2;\n\t\twhile(n>1)\n\t\t{\n\t\t\tif(n%d==0)\n\t\t\t{\n\t\
    \t\t\tres[reslen]=d;\n\t\t\t\treslen++;\n\t\t\t\tn=n/d;\n\t\t\t}\n\t\t\telse\n\
    \t\t\t{\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n}", "{ \n    long[] res\
    \ = new long[0];\n    long i = 2;\n    while (n > 1) \n    { \n        while (n\
    \ % i == 0) \n        { \n            n /= i; \n            res ~= i;\n      \
    \  } \n        i++; \n    } \n    return res;\n}", "{\n    auto result = [];\n\
    \    for (long i = 2; i <= n; i++) \n    {\n        long k = 0;\n        while\
    \ (n % i == 0) \n        {\n            n /= i;\n            k++;\n        }\n\
    \        result ~= replicate(i, k);\n    }\n    return result;\n}\n/*\n    Given\
    \ 3 array of integers.\n    Find 3 points(indexes of arrays) with min distance\
    \ between them.\n    We have to return the distance.\n    The test check that\
    \ the distance is as small as possible.\n    >>> min_distance([1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1])\n    0\n    >>> min_distance([1, 2, 3], [1, 2, 3], [1, 2, 3])\n\
    \    0\n    >>> min_distance([1, 3, 4], [2, 1, 5], [3, 2, 6])\n    1\n    >>>\
    \ min_distance([1, 4, 5], [2, 3, 3], [3, 3, 2])\n    2\n    >>> min_distance([3,\
    \ 3, 3], [3, 3, 3], [3, 3, 3])\n    0\n    >>> min_distance([5, 4, 3], [1, 1,\
    \ 4], [1, 1, 5])\n    1\n    >>> min_distance([1, 1, 5], [1, 1, 4], [5, 4, 3])\n\
    \    1\n*/", "{\n    long[] result = new long[];\n    while (n%2==0) \n    {\n\
    \        result ~= 2;\n        n /= 2;\n    }\n    long p = 3;\n    while (n !=\
    \ 1) \n    {\n        while (n%p == 0) \n        {\n            result ~= p;\n\
    \            n /= p;\n        }\n        p += 2;\n    }\n    return result;\n}",
  "{\n    long result[];\n    long cnt = n;\n    long k;\n    while (cnt % 2 == 0)\n\
    \    {\n        result ~= 2;\n        cnt /= 2;\n    }\n    for (long i = 3; i\
    \ * i <= cnt; i += 2)\n    {\n        while (cnt % i == 0)\n        {\n      \
    \      result ~= i;\n            cnt /= i;\n        }\n    }\n    if (cnt > 2)\n\
    \        result ~= cnt;\n    return result;\n}", "{\n    long[] ret = new long[];\n\
    \    long p = 2;\n    while (n > 1) \n    {\n        if (n % p == 0) \n      \
    \  {\n            ret ~= p;\n            n /= p;\n        } \n        else\n \
    \           p++;\n    }\n    return ret;\n}", "{\n    auto result = new long[];\n\
    \    ulong k = cast(ulong)n;\n    while ((k & 1) == 0) \n    {\n        result\
    \ ~= 2;\n        k >>= 1;\n    }\n    foreach (i; 3 .. (ulong)sqrt(n) + 1 by 2)\
    \ \n    {\n        while (k % i == 0) \n        {\n            result ~= i;\n\
    \            k /= i;\n        }\n    }\n    if (k > 1)\n        result ~= k;\n\
    \    return result;\n}", "{\n  if (n <= 1) return new long[0];\n  long[] ans =\
    \ [];\n  long i = 2;\n  while (n > 1) \n  {\n    if (n % i == 0) \n    {\n   \
    \   ans ~= i;\n      n /= i;\n    }\n    else \n    {\n      i += 1;\n    }\n\
    \  }\n  return ans;\n}\n/*\nCheck whether given tuple is a pair of amicable numbers\n\
    \    Input should be a tuple of two integers\n    >>> is_amicable(220L, 284L)\n\
    \    True\n    >>> is_amicable(1184L, 1210L)\n    True\n    >>> is_amicable(10L,\
    \ 20L)\n    False\n*/", "{\n    import std.algorithm.sorting : sort;\n    import\
    \ std.range : take;\n    import std.math : isOdd;\n    import std.typecons : tuple;\n\
    \    long[] res;\n    if(n <= 1) \n    {\n        res ~= n;\n        return res;\n\
    \    }\n    foreach(t; take(primeFactors(n), isOdd(n))) \n    {\n        if(t[0]\
    \ == 0) \n        {\n            break;\n        }\n        res ~= t[0];\n   \
    \ }\n    sort(res);\n    return res;\n}\n/*\n Returns a list of tuples containing\
    \ prime number and power of it in the factorization of input number\n    >>> primeFactors(8L)\n\
    \    [(2L, 3L)]\n    >>> primeFactors(25L)\n    [(5L, 2L)]\n    >>> primeFactors(70L)\n\
    \    [(2L, 1L), (5L, 1L), (7L, 1L)]\n*/\ntuple!(long, long)[] primeFactors(long\
    \ n) \n{\n    import std.range : take;\n    import std.math : sqrt;\n    import\
    \ std.typecons : tuple;\n    if(n <= 1) \n    {\n        return [];\n    }\n \
    \   tuple!(long, long)[] res;\n    foreach(t; take(primes(), sqrt(n).ceil + 1L))\
    \ \n    {\n        long power = 0L;\n        while(n % t == 0) \n        {\n \
    \           n /= t;\n            power++;\n        }\n        if(power != 0) \n\
    \        {\n            res ~= tuple(t, power);\n        }\n    }\n    if(n !=\
    \ 1) \n    {\n        res ~= tuple(n, 1L);\n    }\n    return res;\n}\n// Returns\
    \ a lazy evaluated list of prime numbers\nlazy long[] primes() \n{\n    import\
    \ std.range : take;\n    long[] primes;\n    primes ~= 2L;\n    while(true) \n\
    \    {\n        long next", "{\n    long[] res;\n    long f = n;\n    for (long\
    \ i = 2; i < f + 1; i++)\n    {\n        if (f % i == 0)\n        {\n        \
    \    res ~= i;\n            while (f % i == 0)\n            {\n              \
    \  f /= i;\n            }\n        }\n    }\n    return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
