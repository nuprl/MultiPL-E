name: HumanEval_49_modp
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \nin\n{\n  assert(p > 0);\n\
    \  assert(n >= 0);\n}\nbody\n{\n  alias P = tuple(long, long);\n  alias T = tuple(P,\
    \ long);\n  long N = n;\n  assert(N >= 0);\n  T t = tuple(tuple(1L, 0L), p);\n\
    \  if(N == 0)\n  {\n    return 1L;\n  }\n  while(N != 1)\n  {\n    if(N & 1)\n\
    \    {\n      t = tuple(tuple(get!1(t)[0] * get!0(t)[0] + get!1(t)[1] * get!0(t)[1],\
    \ \n                      get!1(t)[0] * get!0(t)[1] + get!1(t)[1] * get!0(t)[0]),\
    \ \n                get!1(t)[1] * get!1(t)[1] - 2L * get!1(t)[0] * get!1(t)[1]\
    \ + get!1(t)[0] * get!1(t)[0]);\n    }\n    else\n    {\n      t = tuple(tuple(get!0(t)[0]\
    \ * get!0(t)[0] + get!1(t)[1] * get!0(t)[1], \n                      get!0(t)[0]\
    \ * get!0(t)[1] + get!1(t)[1] * get!0(t)[0]), \n                get!1(t)[1] *\
    \ get!1(t)[1] - 2L * get!1(t)[0] * get!1(t)[1] + get!1(t)[0] * get!1(t)[0]);\n\
    \    }\n    N >>= 1;\n  }\n  long result = (get!0(t)[0] + get!1(t)[1]) % p;\n\
    \  assert(result > 0);\n  return result;\n}\n/*\nReturn a random integer from\
    \ [0, n).\n*/\nlong random(long n) \nin\n{\n  assert(n > 0);\n}\nbody\n{\n  import\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6a63ql9f.d(25): Error: function declaration without return type.\
    \ (Note that constructors are always named `this`)\\n/tmp/tmp6a63ql9f.d(26): Error:\
    \ function declaration without return type. (Note that constructors are always\
    \ named `this`)\\n/tmp/tmp6a63ql9f.d(65): Error: identifier expected following\
    \ `import`\\n/tmp/tmp6a63ql9f.d(65): Error: `;` expected\\n/tmp/tmp6a63ql9f.d(77):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6a63ql9f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  if(n == 0)\n    return\
    \ 1;\n  /*\n  return  (modp(n/2, p) ** 2) % p if n % 2 == 0 \n  else  (modp(n/2,\
    \ p) ** 2 * a) % p\n  */\n  if(n % 2 == 0)\n    return  pow(modp(n/2, p), 2) %\
    \ p;\n  else\n    return  (pow(modp(n/2, p), 2) * n) % p;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8xexr8bu.d(35): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f05]\\n??:? void tmp8xexr8bu.__unittest_L30_C1()\
    \ [0x427b1b]\\n??:? void tmp8xexr8bu.__modtest() [0x427c88]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc2b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aabe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc51]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430100]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fbdd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aa95]\\n??:? runModuleUnitTests [0x42ba01]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428354]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282db]\\n??:? _d_run_main [0x428246]\\n??:? main [0x427c9b]\\\
    n??:? __libc_start_main [0x99fad554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n    if (n<p)\n    {\n \
    \   return n;\n    }\n    else\n    {\n    long m;\n    long q;\n    q = n/p;\n\
    \    m = n-q*p;\n    return m;\n    }\n    \n    \n/* Return True iff n is prime.\n\
    \    >>> isprime(11L)\n    True\n    >>> isprime(111L)\n    False\n    >>> isprime(17L)\n\
    \    True\n    >>> isprime(2L)\n    True\n    >>> isprime(199L)\n    True\n  \
    \  >>> isprime(200L)\n    False\n*/\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9dnho5qm.d(18): Error: cannot use function constraints for non-template\
    \ functions. Use `static if` instead\\n/tmp/tmp9dnho5qm.d(18): Error: declaration\
    \ expected, not `if`\\n/tmp/tmp9dnho5qm.d(21): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9dnho5qm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    /*\n        p(a+b) == (pa+pb) mod m\n   \
    \     *2 == *2 mod m\n        *2 == (+0+*2) mod m\n        *2 == (+(p*1)+*2) mod\
    \ m\n    */\n    return ((p * modp(n / 2, p)) + modp(n % 2, p)) % p;\n}\n/*\n\
    \  Find a generator for the multiplicative group of integers modulo p, where p\
    \ is prime. \n  Such a generator is called a primitive root modulo p. Returns\
    \ None if no primitive root \n  exists (i.e., if p is a prime power).\n  >>> find_generator(11L)\n\
    \  10L\n  >>> find_generator(7L)\n  3L\n  >>> find_generator(9L)\n*/\nlong find_generator(long\
    \ p) \n{\n    long g;\n    long n = p - 1;\n    if (p == 2) \n    {\n        return\
    \ 1;\n    }\n    // find the maximum power of 2 dividing n\n    long q = 1;\n\
    \    while (n % 2 == 0) \n    {\n        n /= 2;\n        q += 1;\n    }\n   \
    \ // we're only interested in multiplicative orders that are 1 modulo 2\n    n\
    \ = n * (pow(2, q - 1) - 1);\n    for (g = 2; g < p; g += 1) \n    {\n       \
    \ // check if g is a generator\n        // if g^{2^i} != 1 mod p for 0 <= i <\
    \ q, then g is a generator\n        if (all!((x) => (modp(g, p) != modp(1, p)),\
    \ iota(q))) \n        {\n            return g;\n        }\n    }\n    return 0;\n\
    }\n// Compute a^b mod m.\n// Note: modp is faster, but is limited to 64-bit integers.\n\
    long modexp(long a, long b, long m) \n{\n    if (a == 0) \n    {\n\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnt_uis5i.d(76): Error: found `unittest` instead of statement\\\
    n/tmp/tmpnt_uis5i.d(88): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnt_uis5i.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    const long TWO =\
    \ 2L;\n    if (n == 0L) \n    {\n        return 1L;\n    }\n    Tuple!(long, long)\
    \ qr = divmod(n, TWO);\n    long a = modp(qr[0], p);\n    long m = a * a % p;\n\
    \    if (qr[1] == 1L) \n    {\n        m = (m * TWO) % p;\n    }\n    return m;\n\
    }\n/*\nGenerate the n-th prime.  Note that n=1 returns 2.\n    >>> primes(1)\n\
    \    2L\n    >>> primes(2)\n    3L\n    >>> primes(3)\n    5L\n    >>> primes(4)\n\
    \    7L\n    >>> primes(10)\n    29L\n    >>> primes(11)\n    31L\n    \n*/\n\
    long primes(long n) \n{\n    long p = 2L;\n    long i = 1L;\n    while (i < n)\
    \ \n    {\n        p += 1L;\n        if (isprime(p)) \n        {\n           \
    \ i += 1L;\n        }\n    }\n    return p;\n}\n/*\nReturn true if p is prime,\
    \ false otherwise.\n    >>> isprime(2L)\n    true\n    >>> isprime(3L)\n    true\n\
    \    >>> isprime(4L)\n    false\n    >>> isprime(5L)\n    true\n    >>> isprime(6L)\n\
    \    false\n    >>> isprime(7L)\n    true\n    >>> isprime(8L)\n    false\n  \
    \  >>> isprime(9L)\n    false\n    >>> isprime(10L)\n    false\n    >>> isprime(11L)\n\
    \    true\n    >>> isprime(12L)\n    false\n    >>> isprime(13L)\n    true\n \
    \   >>> isprime(15L)\n    false\n    >>> isprime(17L)\n    true\n    >>> isprime(2147483647L)\n\
    \    true\n    >>> isprime(18446744073709551557L)\n    true\n   \nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9_qkwar7.d(63): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9_qkwar7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    auto[exponent, base]\
    \ = split(n);\n    long result = 1L;\n    for (long i = 0L; i < exponent; i++)\
    \ \n    {\n        result = result * base % p;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfkmrslbp.d(19): Error: basic type expected, not `[`\\n/tmp/tmpfkmrslbp.d(19):\
    \ Error: found `,` when expecting `]`\\n/tmp/tmpfkmrslbp.d(19): Error: semicolon\
    \ expected, not `]`\\n/tmp/tmpfkmrslbp.d(19): Error: found `]` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfkmrslbp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if(n == 0L) \n \
    \   {\n        return 1L;\n    }\n    else if(n == 1L) \n    {\n        return\
    \ 2L % p;\n    }\n    else \n    {\n        long k = n / 2L;\n        return pow(modp(k,\
    \ p), 2L) % p;\n    }\n}\n/*\n    >>> powmodp(7L, 4L, 97L)\n    63L\n    >>> powmodp(17L,\
    \ 4L, 97L)\n    17L\n    >>> powmodp(8L, 1L, 97L)\n    8L\n    >>> powmodp(8L,\
    \ 0L, 97L)\n    1L\n    >>> powmodp(8L, -1L, 97L)\n    73L\n    >>> powmodp(8L,\
    \ -2L, 97L)\n    48L\n*/\nlong powmodp(long a, long n, long p) \n{\n    if(n ==\
    \ 0L) \n    {\n        return 1L;\n    }\n    else if(n > 0L) \n    {\n      \
    \  long k = n / 2L;\n        return pow(powmodp(a, k, p), 2L) % p;\n    }\n  \
    \  else \n    {\n        return powmodp(powmodp(a, -1L, p), -n, p);\n    }\n}\n\
    /*\n    >>> truediv(2L, 3L)\n    '2/3'\n    >>> truediv(21L, -21L)\n    '-1/1'\n\
    \    >>> truediv(11L, 7L)\n    '11/7'\n    >>> truediv(8L, 6L)\n    '4/3'\n  \
    \  >>> truediv(3L, 15L)\n    '1/5'\n    >>> truediv(6L, 15L)\n    '2/5'\n    >>>\
    \ truediv(6L, 30L)\n    '1/5'\n    >>> truediv(6L, 60L)\n    '1/10'\n    >>> truediv(\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsvgi7nfg.d(63): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsvgi7nfg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    auto r = 1L;\n \
    \   auto b = to!int(n) % p;\n    if(b < 0)\n        b += p;\n    foreach(i; 0\
    \ .. bits!long)\n    {\n        if(b & (1L << i))\n            r = (r * 2L) %\
    \ p;\n    }\n    return r;\n}\n/*\nReturn the n-th Fibonacci number modulo p.\n\
    \    >>> fibp(8L, 7L)\n    6L\n    >>> fibp(8L, 101L)\n    44L\n    >>> fibp(8L,\
    \ 100L)\n    44L\n    >>> fibp(8L, 11L)\n    9L\n    >>> fibp(8L, 29L)\n    20L\n\
    \    >>> fibp(8L, 31L)\n    4L\n*/\nlong fibp(long n, long p) \n{\n    return\
    \ (modp(n, p) * (1L + modp(n, p))) % p;\n}\n/*\nReturn k, such that (n ** k) %\
    \ p == 1.\n    >>> multiplicative_order(3L, 7L)\n    6L\n    >>> multiplicative_order(3L,\
    \ 101L)\n    100L\n    >>> multiplicative_order(3L, 11L)\n    10L\n    >>> multiplicative_order(3L,\
    \ 29L)\n    28L\n    >>> multiplicative_order(100L, 101L)\n    50L\n*/\nlong multiplicative_order(long\
    \ n, long p) \n{\n    auto k = 1L;\n    auto b = n % p;\n    if(b < 0)\n     \
    \   b += p;\n    foreach(i; 0 .. bits!long)\n    {\n        if(b & (1L << i))\n\
    \            k = k * 2L;\n    }\n    return k;\n}\n/*\nReturn the number of distinct\
    \ prime factors.\n    >>> distinct_prime_factors(1L)\n    0L\n    >>> distinct_prime_factors(2L)\n\
    \    1L\n    >>> distinct_prime_factors(3L)\n    1L\n\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkl2ddn8p.d(75): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkl2ddn8p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return 2;\n\
    \    }\n    else if (n % 2 == 0)\n    {\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    }\n    else\n    {\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) * 2 % p;\n    }\n}\n/*\nTest if n is probably prime.\n    >>> is_probable_prime(7L)\n\
    \    True\n    >>> is_probable_prime(10000000000000000039L)\n    True\n    >>>\
    \ is_probable_prime(9999999999999999991L)\n    False\n    >>> is_probable_prime(10000000000000000007L)\n\
    \    True\n    >>> is_probable_prime(85L)\n    False\n*/\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong a = 1L;\n\twhile\
    \ (n != 0L) {\n\t\twhile ((n % 2L) == 0L) {\n\t\t\tn /= 2L;\n\t\t\tlong b = p\
    \ % 8L;\n\t\t\tif (b == 3L || b == 5L)\n\t\t\t\tp = -p;\n\t\t}\n\t\tn -= 1L;\n\
    \t\tif (p < 0L)\n\t\t\ta = -a;\n\t\ta = (a * n) % p;\n\t}\n\tif (p == 1L)\n\t\t\
    return 0L;\n\tif (a < 0L)\n\t\ta += p;\n\treturn a;\n}\n// \nlong poly_horner(inout(long[])\
    \ A, long x) {\n\tlong n = A.length;\n\tlong s = A[n - 1];\n\tlong i = n - 2;\n\
    \twhile (i >= 0) {\n\t\ts = s * x + A[i];\n\t\ti -= 1;\n\t}\n\treturn s;\n}\n\
    // \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpivkkg4q7.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f5d]\\n??:? void tmpivkkg4q7.__unittest_L50_C1()\
    \ [0x427be1]\\n??:? void tmpivkkg4q7.__modtest() [0x427cdc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bcf7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab8a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd1d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301cc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fca9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab61]\\n??:? runModuleUnitTests [0x42bacd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428420]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283a7]\\n??:? _d_run_main [0x428312]\\n??:? main [0x427cef]\\\
    n??:? __libc_start_main [0x126c6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (p == 1) \n \
    \   {\n        return 0;\n    }\n    return powmod(2L, n, p);\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdanvlhgu.d(23): Error: template `std.math.powmod` cannot deduce\
    \ function from argument types `!()(long, long, long)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(7505):\
    \        `std.math.powmod(F, G, H)(F x, G n, H m) if (isUnsigned!F && isUnsigned!G\
    \ && isUnsigned!H)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdanvlhgu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n == 0) return\
    \ 1;\n\tlong c = 1L;\n\tlong e = p - 2L;\n\twhile (e > 0) \n\t{\n\t\tif (e & 1)\
    \ c = (c * n) % p;\n\t\tn = (n * n) % p;\n\t\te = e >> 1;\n\t}\n\treturn c;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmzr0h5uk.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e0d]\\n??:? void tmpmzr0h5uk.__unittest_L30_C1()\
    \ [0x427a95]\\n??:? void tmpmzr0h5uk.__modtest() [0x427b90]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb33]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9c6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb59]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430008]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fae5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a99d]\\n??:? runModuleUnitTests [0x42b909]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42825c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281e3]\\n??:? _d_run_main [0x42814e]\\n??:? main [0x427ba3]\\\
    n??:? __libc_start_main [0xd87d7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long ans = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     ans = (ans * a) % p;\n        }\n        a = (a * a) % p;\n        n /=\
    \ 2L;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    ulong r = 1;\n \
    \   for (int i = 0; i < n; i++)\n        r = r * 2 % p;\n    return r;\n}\n/*\n\
    Return the number of bits required to express n (be aware of numerics).\n    >>>\
    \ bits_required(0L)\n    0\n    >>> bits_required(1L)\n    1\n    >>> bits_required(2L)\n\
    \    2\n    >>> bits_required(3L)\n    2\n    >>> bits_required(4L)\n    3\n \
    \   >>> bits_required(5L)\n    3\n*/\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  if (n < 0) {\n   \
    \ return modp(-n, p);\n  }\n  else if (n == 0) {\n    return 1;\n  }\n  else if\
    \ (n == 1) {\n    return 0;\n  }\n  else if (n % 2 == 0) {\n    long m = modp(n\
    \ / 2, p);\n    return (m + m) % p;\n  }\n  else {\n    return (modp(n - 1, p)\
    \ + p - 1) % p;\n  }\n}\n/*\nA power of 2.\n    >>> ispow2(0)\n    True\n    >>>\
    \ ispow2(1)\n    True\n    >>> ispow2(2)\n    True\n    >>> ispow2(3)\n    False\n\
    \    >>> ispow2(4)\n    True\n    >>> ispow2(0x1000000000000000L)\n    True\n\
    \    >>> ispow2(0x1000000000000001L)\n    False\n*/\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpehdu6dpv.d(57): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e35]\\n??:? void tmpehdu6dpv.__unittest_L53_C1()\
    \ [0x427ab9]\\n??:? void tmpehdu6dpv.__modtest() [0x427bb4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb5b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb81]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430030]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb0d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9c5]\\n??:? runModuleUnitTests [0x42b931]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428284]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42820b]\\n??:? _d_run_main [0x428176]\\n??:? main [0x427bc7]\\\
    n??:? __libc_start_main [0x97f3b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n    @safe pure nothrow\n\
    {\n    /*\n        if p == 1 or n == 0, return 0\n        if p == 2, return (n\
    \ % 2 == 0) ? 0 : 1\n        if p == -1, return (n % 2 == 0) ? 1 : -1\n    */\n\
    \    import std.bitmanip;\n    if (p == 1 || n == 0)\n        return 0;\n    if\
    \ (p == 2)\n        return (n % 2 == 0) ? 0 : 1;\n    if (p == -1)\n        return\
    \ (n % 2 == 0) ? 1 : -1;\n    return powmod(2, n, p);\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk0esontp.d(32): Error: template `std.math.powmod` cannot deduce\
    \ function from argument types `!()(int, long, long)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(7505):\
    \        `std.math.powmod(F, G, H)(F x, G n, H m) if (isUnsigned!F && isUnsigned!G\
    \ && isUnsigned!H)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk0esontp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long c = modp(n >>\
    \ 1, p);\n        if (n & 1) \n        {\n            return (c * c * 2) % p;\n\
    \        }\n        else \n        {\n            return (c * c) % p;\n      \
    \  }\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    foreach (i; 0 .. n)\n    {\n        res = (res * 2L) % p;\n    }\n    return\
    \ res;\n}\n/*\nReturn n*2^-1 modulo p (be aware of numerics).\n*/\nlong modpinv(long\
    \ n, long p) \n{\n    long res = 1L;\n    foreach (i; 0 .. n)\n    {\n       \
    \ res = (res * 2L) % p;\n    }\n    return (res * n) % p;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n == 0) return\
    \ 1;\n\tlong pow = modp(n / 2, p);\n\tpow = pow * pow % p;\n\tif (n % 2) pow =\
    \ pow * 2 % p;\n\treturn pow;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 1) \n  \
    \  {\n        return 1;\n    }\n    if (n == 1) \n    {\n        return 2;\n \
    \   }\n    if (n % 2 == 0) \n    {\n        long x = modp(n / 2, p);\n       \
    \ return (x * x) % p;\n    }\n    else \n    {\n        return (2 * modp(n - 1,\
    \ p)) % p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
