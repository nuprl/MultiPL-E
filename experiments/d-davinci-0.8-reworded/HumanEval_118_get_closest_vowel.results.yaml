name: HumanEval_118_get_closest_vowel
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowels = \"aeiou\";\n\
    \    static string vowels_uc = \"AEIOU\";\n    static string all_vowels = \"aeiouAEIOU\"\
    ;\n    static string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    static string consonants_uc = \"BCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n\
    \    while (i < word.length)\n    {\n        if (word[i] in consonants)\n    \
    \    {\n            int j = i + 1;\n            while (j < word.length)\n    \
    \        {\n                if (word[j] in consonants)\n                {\n  \
    \                  break;\n                }\n                j++;\n         \
    \   }\n            if (j < word.length)\n            {\n                int k\
    \ = i + 1;\n                while (k < j)\n                {\n               \
    \     if (word[k] in all_vowels)\n                    {\n                    \
    \    return word[k];\n                    }\n                    k++;\n      \
    \          }\n            }\n            i = j;\n        }\n        else if (word[i]\
    \ in vowels_uc)\n        {\n            int j = i + 1;\n            while (j <\
    \ word.length)\n            {\n                if (word[j] in consonants_uc)\n\
    \                {\n                    break;\n                }\n          \
    \      j++;\n            }\n            if (j < word.length)\n            {\n\
    \                int k = i + 1;\n                while (k < j)\n             \
    \   {\n                    if (word[k] in all_vowels)\n                    {\n\
    \                        return word[k];\n                    }\n            \
    \        k++;\n                }\n            }\n            i = j;\n        }\n\
    \        else\n        {\n            i++;\n        }\n    }\n    return \"\"\
    ;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1dqxczth.d(33): Error: incompatible types for `(word[cast(ulong)i])\
    \ in (consonants)`: `immutable(char)` and `string`\\n/tmp/tmp1dqxczth.d(38): Error:\
    \ incompatible types for `(word[cast(ulong)j]) in (consonants)`: `immutable(char)`\
    \ and `string`\\n/tmp/tmp1dqxczth.d(49): Error: incompatible types for `(word[cast(ulong)k])\
    \ in (all_vowels)`: `immutable(char)` and `string`\\n/tmp/tmp1dqxczth.d(58): Error:\
    \ incompatible types for `(word[cast(ulong)i]) in (vowels_uc)`: `immutable(char)`\
    \ and `string`\\n/tmp/tmp1dqxczth.d(63): Error: incompatible types for `(word[cast(ulong)j])\
    \ in (consonants_uc)`: `immutable(char)` and `string`\\n/tmp/tmp1dqxczth.d(74):\
    \ Error: incompatible types for `(word[cast(ulong)k]) in (all_vowels)`: `immutable(char)`\
    \ and `string`\\n/tmp/tmp1dqxczth.d(51): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)k]` of type `immutable(char)` to `string`\\n/tmp/tmp1dqxczth.d(76):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)k]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1dqxczth.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowels = \"aeiouAEIOU\";\n    auto\
    \ word_list = word.split(\"\");\n    auto closest_vowel = \"\";\n    foreach(i,\
    \ letter; word_list)\n    {\n        if(i != 0 && i != word_list.length-1)\n \
    \       {\n            if(vowels.canFind(letter))\n            {\n           \
    \     if(vowels.canFind(word_list[i-1]) == false && vowels.canFind(word_list[i+1])\
    \ == false)\n                {\n                    return letter;\n         \
    \       }\n            }\n        }\n    }\n    return closest_vowel;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphk4_x8k7.d(26): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphk4_x8k7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // TODO: implement your method here\n\
    \    string result = \"\";\n    bool gotConsonant = false;\n    string consonants\
    \ = \"bBcCdDfFgGhHjJkKlLmMnNpPqQrRsStTvVwWxXyYzZ\";\n    // \"BCDFGHJKLMNPQRSTVWXYZ\"\
    \n    foreach (i, c; word)\n    {\n        if (consonants.canFind(c))\n      \
    \  {\n            if (gotConsonant)\n            {\n                return result;\n\
    \            }\n            else\n            {\n                gotConsonant\
    \ = true;\n            }\n        }\n        else\n        {\n            if (gotConsonant)\n\
    \            {\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfyzvx31q.d(32): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpfyzvx31q.d(47): Error: cannot implicitly convert expression `c` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfyzvx31q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto it = find(word.rbegin(), word.rend(),\
    \ 'a')();\n    if (it != word.rend())\n        return \"a\";\n    it = find(word.rbegin(),\
    \ word.rend(), 'e')();\n    if (it != word.rend())\n        return \"e\";\n  \
    \  it = find(word.rbegin(), word.rend(), 'i')();\n    if (it != word.rend())\n\
    \        return \"i\";\n    it = find(word.rbegin(), word.rend(), 'o')();\n  \
    \  if (it != word.rend())\n        return \"o\";\n    it = find(word.rbegin(),\
    \ word.rend(), 'u')();\n    if (it != word.rend())\n        return \"u\";\n  \
    \  it = find(word.rbegin(), word.rend(), 'A')();\n    if (it != word.rend())\n\
    \        return \"A\";\n    it = find(word.rbegin(), word.rend(), 'E')();\n  \
    \  if (it != word.rend())\n        return \"E\";\n    it = find(word.rbegin(),\
    \ word.rend(), 'I')();\n    if (it != word.rend())\n        return \"I\";\n  \
    \  it = find(word.rbegin(), word.rend(), 'O')();\n    if (it != word.rend())\n\
    \        return \"O\";\n    it = find(word.rbegin(), word.rend(), 'U')();\n  \
    \  if (it != word.rend())\n        return \"U\";\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4u84j_ds.d(25): Error: undefined identifier `find`, did you mean\
    \ template `Bind(alias Template, args1...)`?\\n/tmp/tmp4u84j_ds.d(26): Error:\
    \ no property `rend` for type `string`\\n/tmp/tmp4u84j_ds.d(29): Error: no property\
    \ `rend` for type `string`\\n/tmp/tmp4u84j_ds.d(32): Error: no property `rend`\
    \ for type `string`\\n/tmp/tmp4u84j_ds.d(35): Error: no property `rend` for type\
    \ `string`\\n/tmp/tmp4u84j_ds.d(38): Error: no property `rend` for type `string`\\\
    n/tmp/tmp4u84j_ds.d(41): Error: no property `rend` for type `string`\\n/tmp/tmp4u84j_ds.d(44):\
    \ Error: no property `rend` for type `string`\\n/tmp/tmp4u84j_ds.d(47): Error:\
    \ no property `rend` for type `string`\\n/tmp/tmp4u84j_ds.d(50): Error: no property\
    \ `rend` for type `string`\\n/tmp/tmp4u84j_ds.d(53): Error: no property `rend`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4u84j_ds.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n\tauto empty = string.init;\n\tauto vowels\
    \ = \"AEIOUaeiou\";\n\tauto consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    ;\n\tauto vowel_indexes = word.indexOfAny(vowels);\n\tauto consonant_indexes =\
    \ word.indexOfAny(consonants);\n\tauto dummies = vowel_indexes.zip(consonant_indexes);\n\
    \tauto dummies_to_number = dummies.map!((dummy) => dummy[0] - dummy[1]);\n\tauto\
    \ dummies_negative = dummies_to_number.takeWhile!((x) => x <= 0);\n\tauto dummies_positive\
    \ = dummies_to_number.dropWhile!((x) => x <= 0);\n\t\n\tif (dummies_negative.length\
    \ == 0 || dummies_positive.length == 0)\n\t{\n\t\treturn empty;\n\t}\n\t\n\tauto\
    \ dummy_negative = dummies_negative.back;\n\tauto dummy_positive = dummies_positive.front;\n\
    \tauto i = abs(dummy_negative) < abs(dummy_positive) ? dummies_negative.length\
    \ : dummies_positive.length;\n\treturn word[vowel_indexes[i]];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmz43ifrr.d(28): Error: no property `indexOfAny` for type `string`\\\
    n/tmp/tmpmz43ifrr.d(29): Error: no property `indexOfAny` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmz43ifrr.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowels = \"aeiouAEIOU\"\
    ;\n    if (word.length > 2)\n    {\n        auto left = word.length;\n       \
    \ auto right = word.length - 1;\n        while (left > 0)\n        {\n       \
    \     if (vowels.indexOf(word[left - 1]) != -1)\n            {\n             \
    \   left--;\n                if (vowels.indexOf(word[right]) == -1)\n        \
    \        {\n                    return word[left];\n                }\n      \
    \      }\n            else\n            {\n                left--;\n         \
    \   }\n            right--;\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqvfxll07.d(32): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpqvfxll07.d(35): Error: no property `indexOf` for type `string`\\n/tmp/tmpqvfxll07.d(37):\
    \ Error: cannot implicitly convert expression `word[left]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqvfxll07.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // for (int i = word.length - 1; i >=\
    \ 0; i--)\n    // {\n    //     char c = word[i];\n    //     if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u')\n    //     {\n    //        \
    \ if (i == word.length - 1)\n    //         {\n    //             return \"\"\
    ;\n    //         }\n    //         else if (i == 0)\n    //         {\n    //\
    \             return \"\";\n    //         }\n    //         else\n    //    \
    \     {\n    //             if (word[i + 1] == 'a' || word[i + 1] == 'e' || word[i\
    \ + 1] == 'i' || word[i + 1] == 'o' || word[i + 1] == 'u')\n    //           \
    \  {\n    //                 continue;\n    //             }\n    //         \
    \    else\n    //             {\n    //                 return word[i..i + 1];\n\
    \    //             }\n    //         }\n    //     }\n    // }\n    // return\
    \ \"\";\n    int first = word.find(\"a\");\n    int second = word.find(\"e\");\n\
    \    int third = word.find(\"i\");\n    int fourth = word.find(\"o\");\n    int\
    \ fifth = word.find(\"u\");\n    int sixth = word.find(\"A\");\n    int seventh\
    \ = word.find(\"E\");\n    int eigth = word.find(\"I\");\n    int ninth = word.find(\"\
    O\");\n    int tenth = word.find(\"U\");\n    if (first == -1)\n    {\n      \
    \  first = -2;\n    }\n    if (second == -1)\n    {\n        second = -2;\n  \
    \  }\n    if (third == -1)\n    {\n        third = -2;\n    }\n    if (fourth\
    \ == -1)\n    {\n        fourth = -2;\n    }\n    if (fifth == -1)\n    {\n  \
    \      fifth = -2;\n    }\n    if (sixth == -1)\n    {\n        sixth = -2\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjvho9err.d(85): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmpjvho9err.d(103): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmpjvho9err.d(103): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjvho9err.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static const string vowels = \"aeiouAEIOU\"\
    ;\n    size_t left = 0, right = 0;\n    for (; left < word.length(); ++left) {\n\
    \        if (vowels.find(word[left]) != -1) {\n            break;\n        }\n\
    \    }\n    if (left == word.length()) return \"\";\n    right = left;\n    for\
    \ (; right < word.length(); ++right) {\n        if (vowels.find(word[right]) ==\
    \ -1) {\n            break;\n        }\n    }\n    if (right == word.length())\
    \ return \"\";\n    return word[min(left, right)];\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpltgpydoh.d(27): Error: no property `length` for type `string`\\\
    n/tmp/tmpltgpydoh.d(28): Error: no property `find` for type `const(string)`\\\
    n/tmp/tmpltgpydoh.d(32): Error: no property `length` for type `string`\\n/tmp/tmpltgpydoh.d(34):\
    \ Error: no property `length` for type `string`\\n/tmp/tmpltgpydoh.d(35): Error:\
    \ no property `find` for type `const(string)`\\n/tmp/tmpltgpydoh.d(39): Error:\
    \ no property `length` for type `string`\\n/tmp/tmpltgpydoh.d(40): Error: undefined\
    \ identifier `min`, did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpltgpydoh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  int vowel_index = -1;\n    for (int i = word.length - 1; i >= 0; i--) {\n \
    \       if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i]\
    \ == 'O' || word[i] == 'U') {\n            vowel_index = i;\n            break;\n\
    \        }\n    }\n    if (vowel_index == -1) {\n        return \"\";\n    } else\
    \ {\n        if (vowel_index + 1 == word.length) {\n            return \"\";\n\
    \        } else {\n            if (word[vowel_index + 1] == 'a' || word[vowel_index\
    \ + 1] == 'e' || word[vowel_index + 1] == 'i' || word[vowel_index + 1] == 'o'\
    \ || word[vowel_index + 1] == 'u' || word[vowel_index + 1] == 'A' || word[vowel_index\
    \ + 1] == 'E' || word[vowel_index + 1] == 'I' || word[vowel_index + 1] == 'O'\
    \ || word[vowel_index + 1] == 'U') {\n                return \"\";\n         \
    \   } else {\n                return word[vowel_index .. $];\n            }\n\
    \        }\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpclbw8k7x.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpclbw8k7x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    auto\
    \ idx = word.length - 1;\n    while (idx-- > 0) {\n        if (vowels.count(word[idx]))\
    \ {\n            auto right = idx + 1;\n            if (right < word.length) {\n\
    \                if (vowels.count(word[right])) continue;\n                return\
    \ word[idx..$];\n            }\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmqihau9i.d(28): Error: no property `count` for type `string`\\\
    n/tmp/tmpmqihau9i.d(31): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqihau9i.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    assert(word.length);\n    size_t last_vowel_index\
    \ = -1;\n    string vowels = \"AEIOUaeiou\";\n    for (size_t i = 0; i < word.length;\
    \ i++)\n    {\n        for (size_t j = 0; j < vowels.length; j++)\n        {\n\
    \            if (word[i] == vowels[j])\n            {\n                last_vowel_index\
    \ = i;\n                break;\n            }\n        }\n    }\n    if (last_vowel_index\
    \ < 0)\n        return \"\";\n    string result;\n    for (size_t i = last_vowel_index;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) == string.npos)\n\
    \        {\n            if (last_vowel_index < i - 1)\n                result\
    \ = word[i - 1];\n            break;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj_t5ylhv.d(44): Error: no property `find` for type `string`\\\
    n/tmp/tmpj_t5ylhv.d(44): Error: no property `npos` for type `string`\\n/tmp/tmpj_t5ylhv.d(47):\
    \ Error: cannot implicitly convert expression `word[i - 1LU]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj_t5ylhv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string[] vowels = \"aeiouAEIOU\";\n\
    \    int[] consonants = [];\n    string closest_vowel = \"\";\n    int shortest_distance\
    \ = word.length;\n    int distance;\n    int start_distance;\n    bool isVowel;\n\
    \    bool isVowelBefore;\n    for (int i = 0; i < word.length; i++)\n    {\n \
    \       isVowel = false;\n        isVowelBefore = false;\n        foreach (vowel;\
    \ vowels)\n        {\n            if (word[i] == vowel)\n            {\n     \
    \           isVowel = true;\n                break;\n            }\n        }\n\
    \        if (isVowel)\n        {\n            continue;\n        }\n        else\n\
    \        {\n            consonants ~= i;\n        }\n    }\n    for (int i = consonants.length\
    \ - 1; i > 0; i--)\n    {\n        start_distance = shortest_distance;\n     \
    \   for (int j = consonants[i] + 1; j < word.length; j++)\n        {\n       \
    \     foreach (vowel; vowels)\n            {\n                if (word[j] == vowel)\n\
    \                {\n                    distance = j - consonants[i];\n      \
    \              if (distance < start_distance)\n                    {\n       \
    \                 start_distance = distance;\n                        closest_vowel\
    \ = vowel;\n                    }\n                    break;\n              \
    \  }\n            }\n        }\n        shortest_distance = start_distance;\n\
    \    }\n    return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_tyukrya.d(25): Error: cannot implicitly convert expression `\"\
    aeiouAEIOU\"` of type `string` to `string[]`\\n/tmp/tmp_tyukrya.d(28): Error:\
    \ cannot implicitly convert expression `word.length` of type `ulong` to `int`\\\
    n/tmp/tmp_tyukrya.d(39): Error: incompatible types for `(word[cast(ulong)i]) ==\
    \ (vowel)`: `immutable(char)` and `string`\\n/tmp/tmp_tyukrya.d(54): Error: cannot\
    \ implicitly convert expression `consonants.length - 1LU` of type `ulong` to `int`\\\
    n/tmp/tmp_tyukrya.d(61): Error: incompatible types for `(word[cast(ulong)j]) ==\
    \ (vowel)`: `immutable(char)` and `string`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp_tyukrya.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowel=\"aeiouAEIOU\";\n    string\
    \ lst=\"\";\n    foreach(immutable i, immutable c; word)\n    {\n        if(i<word.length-1)\n\
    \        {\n            if(vowel.indexOf(word[i])!=-1)\n            {\n      \
    \          if(vowel.indexOf(word[i+1])==-1)\n                {\n             \
    \       lst=word[i];\n                    break;\n                }\n        \
    \    }\n        }\n    }\n    return lst;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphjjp0w82.d(31): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmphjjp0w82.d(33): Error: no property `indexOf` for type `string`\\n/tmp/tmphjjp0w82.d(35):\
    \ Error: cannot implicitly convert expression `word[i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphjjp0w82.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string::size_type\
    \ pos = 0;\n    if (word.length() < 2)\n        return \"\";\n    if (vowels.find(word[word.length()-1])\
    \ != string::npos)\n        return \"\";\n    pos = word.rfind_first_of(vowels);\n\
    \    while (pos != string::npos)\n    {\n        if (pos + 1 < word.length() &&\
    \ vowels.find(word[pos+1]) == string::npos)\n            return word.substr(pos,\
    \ 1);\n        pos = word.rfind_first_of(vowels, pos-1);\n    }\n    return \"\
    \";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpybtg7p0u.d(26): Error: use `.` for member lookup, not `::`\\\
    n/tmp/tmpybtg7p0u.d(29): Error: found `:` when expecting `)`\\n/tmp/tmpybtg7p0u.d(29):\
    \ Error: found `:` instead of statement\\n/tmp/tmpybtg7p0u.d(32): Error: found\
    \ `:` when expecting `)`\\n/tmp/tmpybtg7p0u.d(32): Error: found `:` instead of\
    \ statement\\n/tmp/tmpybtg7p0u.d(38): Error: declaration expected, not `return`\\\
    n/tmp/tmpybtg7p0u.d(39): Error: unrecognized declaration\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpybtg7p0u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    if (word.length < 2) return \"\";\n\
    \    string vowels = \"aoeui\";\n    string result = \"\";\n    int right_index\
    \ = word.length-1;\n    int left_index = word.length-2;\n    while (right_index\
    \ > 0)\n    {\n        if (vowels.find(word[right_index]) == -1 && vowels.find(word[left_index])\
    \ == -1)\n        {\n            right_index--;\n            left_index--;\n \
    \       }\n        else if (vowels.find(word[right_index]) == -1 && vowels.find(word[left_index])\
    \ != -1)\n        {\n            result = word[left_index];\n            break;\n\
    \        }\n        else if (vowels.find(word[right_index]) != -1 && vowels.find(word[left_index])\
    \ == -1)\n        {\n            result = word[right_index];\n            break;\n\
    \        }\n        else\n        {\n            break;\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpscg8b73u.d(28): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpscg8b73u.d(29): Error: cannot implicitly\
    \ convert expression `word.length - 2LU` of type `ulong` to `int`\\n/tmp/tmpscg8b73u.d(32):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpscg8b73u.d(32): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpscg8b73u.d(37): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpscg8b73u.d(37): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpscg8b73u.d(39): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)left_index]` of type `immutable(char)` to `string`\\\
    n/tmp/tmpscg8b73u.d(42): Error: no property `find` for type `string`\\n/tmp/tmpscg8b73u.d(42):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpscg8b73u.d(44): Error:\
    \ cannot implicitly convert expression `word[cast(ulong)right_index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpscg8b73u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static assert((\"yogurt\")==(\"yogurt\"\
    ));\n    static assert((\"yogurt\")!=(\"Yogurt\"));\n    static assert((\"yogurt\"\
    )!=(\"y0gurt\"));\n    auto string vowel = \"aeiou\";\n    //int fvowel = -1;\n\
    \    int fvowel = indexOf(vowel, word);\n    int lvowel = fvowel;\n    if (fvowel==-1)\n\
    \        return \"\";\n    while(fvowel<word.length && lvowel>-1)\n    {\n   \
    \     auto first = word[fvowel];\n        auto second = word[lvowel];\n      \
    \  if (second ==first)\n        {\n            --lvowel;\n            continue;\n\
    \        }\n        auto first_pos = indexOf(vowel, first);\n        auto second_pos\
    \ = indexOf(vowel, second);\n        if (first_pos == -1 && second_pos == -1)\n\
    \        {\n            fvowel++;\n            lvowel--;\n            continue;\n\
    \        }\n        if (first_pos == -1)\n        {\n            return second;\n\
    \        }\n        if (second_pos == -1)\n        {\n            return first;\n\
    \        }\n        if (abs(fvowel-lvowel)>1)\n        {\n            fvowel++;\n\
    \            lvowel--;\n            continue;\n        }\n        if (first_pos\
    \ < second_pos)\n        {\n            return first;\n        }\n        else\n\
    \        {\n            return second;\n        }\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphnj0104h.d(28): Error: variable `tmphnj0104h.get_closest_vowel.vowel`\
    \ storage class `auto` has no effect if type is not inferred, did you mean `scope`?\\\
    n/tmp/tmphnj0104h.d(30): Error: undefined identifier `indexOf`\\n/tmp/tmphnj0104h.d(43):\
    \ Error: undefined identifier `indexOf`\\n/tmp/tmphnj0104h.d(44): Error: undefined\
    \ identifier `indexOf`\\n/tmp/tmphnj0104h.d(53): Error: cannot implicitly convert\
    \ expression `second` of type `immutable(char)` to `string`\\n/tmp/tmphnj0104h.d(57):\
    \ Error: cannot implicitly convert expression `first` of type `immutable(char)`\
    \ to `string`\\n/tmp/tmphnj0104h.d(67): Error: cannot implicitly convert expression\
    \ `first` of type `immutable(char)` to `string`\\n/tmp/tmphnj0104h.d(71): Error:\
    \ cannot implicitly convert expression `second` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphnj0104h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  return find_if(retro(word), (dchar x) {\n        return x == \"\";\n    });\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgd3tzy3l.d(26): Error: undefined identifier `find_if`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgd3tzy3l.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string ret = \"\";\n    foreach(i, ch; word)\n    {\n        if(vowels.canFind(ch))\n\
    \        {\n            if(i > 0 && i < word.length - 1)\n            {\n    \
    \            if(!vowels.canFind(word[i - 1]) && !vowels.canFind(word[i + 1]))\n\
    \                {\n                    ret = ch;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3e8b1usu.d(29): Error: no property `canFind` for type `string`\\\
    n/tmp/tmp3e8b1usu.d(33): Error: no property `canFind` for type `string`\\n/tmp/tmp3e8b1usu.d(33):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp3e8b1usu.d(35): Error:\
    \ cannot implicitly convert expression `ch` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3e8b1usu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string closest = \"\";\n    int word_length\
    \ = word.length;\n    string cons = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    int min_distance = -1;\n    if (word_length == 0 || word_length == 1)\n\
    \        return closest;\n    for (int i = 0; i < word_length; i++)\n    {\n \
    \       if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i]\
    \ == 'O' || word[i] == 'U')\n        {\n            if (i < word_length - 1)\n\
    \            {\n                if (word[i + 1] == 'a' || word[i + 1] == 'e' ||\
    \ word[i + 1] == 'i' || word[i + 1] == 'o' || word[i + 1] == 'u' || word[i + 1]\
    \ == 'A' || word[i + 1] == 'E' || word[i + 1] == 'I' || word[i + 1] == 'O' ||\
    \ word[i + 1] == 'U')\n                    continue;\n            }\n        \
    \    if (i > 0)\n            {\n                if (word[i - 1] == 'a' || word[i\
    \ - 1] == 'e' || word[i - 1] == 'i' || word[i - 1] == 'o' || word[i - 1] == 'u'\
    \ || word[i - 1] == 'A' || word[i - 1] == 'E' || word[i - 1] == 'I' || word[i\
    \ - 1] == 'O' || word[i - 1] == 'U')\n                    continue;\n        \
    \    }\n            int dist = 0;\n            for (int j = word_length - 1; j\
    \ > i; j--)\n            {\n                for (int k = 0; k < cons.length;\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpowjfc6ob.d(49): Error: expression expected, not `unittest`\\\
    n/tmp/tmpowjfc6ob.d(50): Error: found `{` when expecting `)`\\n/tmp/tmpowjfc6ob.d(67):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmpowjfc6ob.d(67): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpowjfc6ob.d(67): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpowjfc6ob.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n  string vowels = \"AEIOUaeiou\";\n  bool\
    \ isConsonant = true;\n  int index = 0;\n  for (int i = word.length - 1; i >=\
    \ 0; i--)\n  {\n    if (vowels.findFirstOf(word[i]) != -1) {\n      if (isConsonant)\
    \ {\n        index = i;\n        break;\n      }\n      isConsonant = true;\n\
    \    }\n    else {\n      isConsonant = false;\n    }\n  }\n  return (index !=\
    \ 0) ? word[index] : \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmputmsc8hd.d(28): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmputmsc8hd.d(30): Error: no property\
    \ `findFirstOf` for type `string`\\n/tmp/tmputmsc8hd.d(41): Error: incompatible\
    \ types for `(word[cast(ulong)index]) : (\"\")`: `immutable(char)` and `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmputmsc8hd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
