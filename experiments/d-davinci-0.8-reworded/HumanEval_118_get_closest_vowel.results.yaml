language: d
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowels = \"aeiou\";\n\
    \    static string vowels_uc = \"AEIOU\";\n    static string all_vowels = \"aeiouAEIOU\"\
    ;\n    static string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    static string consonants_uc = \"BCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n\
    \    while (i < word.length)\n    {\n        if (word[i] in consonants)\n    \
    \    {\n            int j = i + 1;\n            while (j < word.length)\n    \
    \        {\n                if (word[j] in consonants)\n                {\n  \
    \                  break;\n                }\n                j++;\n         \
    \   }\n            if (j < word.length)\n            {\n                int k\
    \ = i + 1;\n                while (k < j)\n                {\n               \
    \     if (word[k] in all_vowels)\n                    {\n                    \
    \    return word[k];\n                    }\n                    k++;\n      \
    \          }\n            }\n            i = j;\n        }\n        else if (word[i]\
    \ in vowels_uc)\n        {\n            int j = i + 1;\n            while (j <\
    \ word.length)\n            {\n                if (word[j] in consonants_uc)\n\
    \                {\n                    break;\n                }\n          \
    \      j++;\n            }\n            if (j < word.length)\n            {\n\
    \                int k = i + 1;\n                while (k < j)\n             \
    \   {\n                    if (word[k] in all_vowels)\n                    {\n\
    \                        return word[k];\n                    }\n            \
    \        k++;\n                }\n            }\n            i = j;\n        }\n\
    \        else\n        {\n            i++;\n        }\n    }\n    return \"\"\
    ;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvuo89c18.d(33): Error: incompatible types for `(word[cast(ulong)i])
    in (consonants)`: `immutable(char)` and `string`

    /tmp/tmpvuo89c18.d(38): Error: incompatible types for `(word[cast(ulong)j]) in
    (consonants)`: `immutable(char)` and `string`

    /tmp/tmpvuo89c18.d(49): Error: incompatible types for `(word[cast(ulong)k]) in
    (all_vowels)`: `immutable(char)` and `string`

    /tmp/tmpvuo89c18.d(58): Error: incompatible types for `(word[cast(ulong)i]) in
    (vowels_uc)`: `immutable(char)` and `string`

    /tmp/tmpvuo89c18.d(63): Error: incompatible types for `(word[cast(ulong)j]) in
    (consonants_uc)`: `immutable(char)` and `string`

    /tmp/tmpvuo89c18.d(74): Error: incompatible types for `(word[cast(ulong)k]) in
    (all_vowels)`: `immutable(char)` and `string`

    /tmp/tmpvuo89c18.d(51): Error: cannot implicitly convert expression `word[cast(ulong)k]`
    of type `immutable(char)` to `string`

    /tmp/tmpvuo89c18.d(76): Error: cannot implicitly convert expression `word[cast(ulong)k]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowels = \"aeiouAEIOU\";\n    auto\
    \ word_list = word.split(\"\");\n    auto closest_vowel = \"\";\n    foreach(i,\
    \ letter; word_list)\n    {\n        if(i != 0 && i != word_list.length-1)\n \
    \       {\n            if(vowels.canFind(letter))\n            {\n           \
    \     if(vowels.canFind(word_list[i-1]) == false && vowels.canFind(word_list[i+1])\
    \ == false)\n                {\n                    return letter;\n         \
    \       }\n            }\n        }\n    }\n    return closest_vowel;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkj1e0a4o.d(26): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkj1e0a4o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // TODO: implement your method here\n\
    \    string result = \"\";\n    bool gotConsonant = false;\n    string consonants\
    \ = \"bBcCdDfFgGhHjJkKlLmMnNpPqQrRsStTvVwWxXyYzZ\";\n    // \"BCDFGHJKLMNPQRSTVWXYZ\"\
    \n    foreach (i, c; word)\n    {\n        if (consonants.canFind(c))\n      \
    \  {\n            if (gotConsonant)\n            {\n                return result;\n\
    \            }\n            else\n            {\n                gotConsonant\
    \ = true;\n            }\n        }\n        else\n        {\n            if (gotConsonant)\n\
    \            {\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5w3y9y8u.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp5w3y9y8u.d(47): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5w3y9y8u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto it = find(word.rbegin(), word.rend(),\
    \ 'a')();\n    if (it != word.rend())\n        return \"a\";\n    it = find(word.rbegin(),\
    \ word.rend(), 'e')();\n    if (it != word.rend())\n        return \"e\";\n  \
    \  it = find(word.rbegin(), word.rend(), 'i')();\n    if (it != word.rend())\n\
    \        return \"i\";\n    it = find(word.rbegin(), word.rend(), 'o')();\n  \
    \  if (it != word.rend())\n        return \"o\";\n    it = find(word.rbegin(),\
    \ word.rend(), 'u')();\n    if (it != word.rend())\n        return \"u\";\n  \
    \  it = find(word.rbegin(), word.rend(), 'A')();\n    if (it != word.rend())\n\
    \        return \"A\";\n    it = find(word.rbegin(), word.rend(), 'E')();\n  \
    \  if (it != word.rend())\n        return \"E\";\n    it = find(word.rbegin(),\
    \ word.rend(), 'I')();\n    if (it != word.rend())\n        return \"I\";\n  \
    \  it = find(word.rbegin(), word.rend(), 'O')();\n    if (it != word.rend())\n\
    \        return \"O\";\n    it = find(word.rbegin(), word.rend(), 'U')();\n  \
    \  if (it != word.rend())\n        return \"U\";\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp18euk9bb.d(25): Error: undefined identifier `find`, did you mean
    template `Bind(alias Template, args1...)`?

    /tmp/tmp18euk9bb.d(26): Error: no property `rend` for type `string`

    /tmp/tmp18euk9bb.d(29): Error: no property `rend` for type `string`

    /tmp/tmp18euk9bb.d(32): Error: no property `rend` for type `string`

    /tmp/tmp18euk9bb.d(35): Error: no property `rend` for type `string`

    /tmp/tmp18euk9bb.d(38): Error: no property `rend` for type `string`

    /tmp/tmp18euk9bb.d(41): Error: no property `rend` for type `string`

    /tmp/tmp18euk9bb.d(44): Error: no property `rend` for type `string`

    /tmp/tmp18euk9bb.d(47): Error: no property `rend` for type `string`

    /tmp/tmp18euk9bb.d(50): Error: no property `rend` for type `string`

    /tmp/tmp18euk9bb.d(53): Error: no property `rend` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp18euk9bb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n\tauto empty = string.init;\n\tauto vowels\
    \ = \"AEIOUaeiou\";\n\tauto consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    ;\n\tauto vowel_indexes = word.indexOfAny(vowels);\n\tauto consonant_indexes =\
    \ word.indexOfAny(consonants);\n\tauto dummies = vowel_indexes.zip(consonant_indexes);\n\
    \tauto dummies_to_number = dummies.map!((dummy) => dummy[0] - dummy[1]);\n\tauto\
    \ dummies_negative = dummies_to_number.takeWhile!((x) => x <= 0);\n\tauto dummies_positive\
    \ = dummies_to_number.dropWhile!((x) => x <= 0);\n\t\n\tif (dummies_negative.length\
    \ == 0 || dummies_positive.length == 0)\n\t{\n\t\treturn empty;\n\t}\n\t\n\tauto\
    \ dummy_negative = dummies_negative.back;\n\tauto dummy_positive = dummies_positive.front;\n\
    \tauto i = abs(dummy_negative) < abs(dummy_positive) ? dummies_negative.length\
    \ : dummies_positive.length;\n\treturn word[vowel_indexes[i]];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphr7s5fe3.d(28): Error: no property `indexOfAny` for type `string`

    /tmp/tmphr7s5fe3.d(29): Error: no property `indexOfAny` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphr7s5fe3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowels = \"aeiouAEIOU\"\
    ;\n    if (word.length > 2)\n    {\n        auto left = word.length;\n       \
    \ auto right = word.length - 1;\n        while (left > 0)\n        {\n       \
    \     if (vowels.indexOf(word[left - 1]) != -1)\n            {\n             \
    \   left--;\n                if (vowels.indexOf(word[right]) == -1)\n        \
    \        {\n                    return word[left];\n                }\n      \
    \      }\n            else\n            {\n                left--;\n         \
    \   }\n            right--;\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_zyqjmw9.d(32): Error: no property `indexOf` for type `string`

    /tmp/tmp_zyqjmw9.d(35): Error: no property `indexOf` for type `string`

    /tmp/tmp_zyqjmw9.d(37): Error: cannot implicitly convert expression `word[left]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_zyqjmw9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // for (int i = word.length - 1; i >=\
    \ 0; i--)\n    // {\n    //     char c = word[i];\n    //     if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u')\n    //     {\n    //        \
    \ if (i == word.length - 1)\n    //         {\n    //             return \"\"\
    ;\n    //         }\n    //         else if (i == 0)\n    //         {\n    //\
    \             return \"\";\n    //         }\n    //         else\n    //    \
    \     {\n    //             if (word[i + 1] == 'a' || word[i + 1] == 'e' || word[i\
    \ + 1] == 'i' || word[i + 1] == 'o' || word[i + 1] == 'u')\n    //           \
    \  {\n    //                 continue;\n    //             }\n    //         \
    \    else\n    //             {\n    //                 return word[i..i + 1];\n\
    \    //             }\n    //         }\n    //     }\n    // }\n    // return\
    \ \"\";\n    int first = word.find(\"a\");\n    int second = word.find(\"e\");\n\
    \    int third = word.find(\"i\");\n    int fourth = word.find(\"o\");\n    int\
    \ fifth = word.find(\"u\");\n    int sixth = word.find(\"A\");\n    int seventh\
    \ = word.find(\"E\");\n    int eigth = word.find(\"I\");\n    int ninth = word.find(\"\
    O\");\n    int tenth = word.find(\"U\");\n    if (first == -1)\n    {\n      \
    \  first = -2;\n    }\n    if (second == -1)\n    {\n        second = -2;\n  \
    \  }\n    if (third == -1)\n    {\n        third = -2;\n    }\n    if (fourth\
    \ == -1)\n    {\n        fourth = -2;\n    }\n    if (fifth == -1)\n    {\n  \
    \      fifth = -2;\n    }\n    if (sixth == -1)\n    {\n        sixth = -2\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq4oxqvei.d(85): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpq4oxqvei.d(103): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpq4oxqvei.d(103): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4oxqvei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static const string vowels = \"aeiouAEIOU\"\
    ;\n    size_t left = 0, right = 0;\n    for (; left < word.length(); ++left) {\n\
    \        if (vowels.find(word[left]) != -1) {\n            break;\n        }\n\
    \    }\n    if (left == word.length()) return \"\";\n    right = left;\n    for\
    \ (; right < word.length(); ++right) {\n        if (vowels.find(word[right]) ==\
    \ -1) {\n            break;\n        }\n    }\n    if (right == word.length())\
    \ return \"\";\n    return word[min(left, right)];\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9e_3u8zn.d(27): Error: no property `length` for type `string`

    /tmp/tmp9e_3u8zn.d(28): Error: no property `find` for type `const(string)`

    /tmp/tmp9e_3u8zn.d(32): Error: no property `length` for type `string`

    /tmp/tmp9e_3u8zn.d(34): Error: no property `length` for type `string`

    /tmp/tmp9e_3u8zn.d(35): Error: no property `find` for type `const(string)`

    /tmp/tmp9e_3u8zn.d(39): Error: no property `length` for type `string`

    /tmp/tmp9e_3u8zn.d(40): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9e_3u8zn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  int vowel_index = -1;\n    for (int i = word.length - 1; i >= 0; i--) {\n \
    \       if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i]\
    \ == 'O' || word[i] == 'U') {\n            vowel_index = i;\n            break;\n\
    \        }\n    }\n    if (vowel_index == -1) {\n        return \"\";\n    } else\
    \ {\n        if (vowel_index + 1 == word.length) {\n            return \"\";\n\
    \        } else {\n            if (word[vowel_index + 1] == 'a' || word[vowel_index\
    \ + 1] == 'e' || word[vowel_index + 1] == 'i' || word[vowel_index + 1] == 'o'\
    \ || word[vowel_index + 1] == 'u' || word[vowel_index + 1] == 'A' || word[vowel_index\
    \ + 1] == 'E' || word[vowel_index + 1] == 'I' || word[vowel_index + 1] == 'O'\
    \ || word[vowel_index + 1] == 'U') {\n                return \"\";\n         \
    \   } else {\n                return word[vowel_index .. $];\n            }\n\
    \        }\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0lb_pz1u.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0lb_pz1u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    auto\
    \ idx = word.length - 1;\n    while (idx-- > 0) {\n        if (vowels.count(word[idx]))\
    \ {\n            auto right = idx + 1;\n            if (right < word.length) {\n\
    \                if (vowels.count(word[right])) continue;\n                return\
    \ word[idx..$];\n            }\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6npjmi23.d(28): Error: no property `count` for type `string`

    /tmp/tmp6npjmi23.d(31): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6npjmi23.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    assert(word.length);\n    size_t last_vowel_index\
    \ = -1;\n    string vowels = \"AEIOUaeiou\";\n    for (size_t i = 0; i < word.length;\
    \ i++)\n    {\n        for (size_t j = 0; j < vowels.length; j++)\n        {\n\
    \            if (word[i] == vowels[j])\n            {\n                last_vowel_index\
    \ = i;\n                break;\n            }\n        }\n    }\n    if (last_vowel_index\
    \ < 0)\n        return \"\";\n    string result;\n    for (size_t i = last_vowel_index;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) == string.npos)\n\
    \        {\n            if (last_vowel_index < i - 1)\n                result\
    \ = word[i - 1];\n            break;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp44d_dk6r.d(44): Error: no property `find` for type `string`

    /tmp/tmp44d_dk6r.d(44): Error: no property `npos` for type `string`

    /tmp/tmp44d_dk6r.d(47): Error: cannot implicitly convert expression `word[i -
    1LU]` of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp44d_dk6r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string[] vowels = \"aeiouAEIOU\";\n\
    \    int[] consonants = [];\n    string closest_vowel = \"\";\n    int shortest_distance\
    \ = word.length;\n    int distance;\n    int start_distance;\n    bool isVowel;\n\
    \    bool isVowelBefore;\n    for (int i = 0; i < word.length; i++)\n    {\n \
    \       isVowel = false;\n        isVowelBefore = false;\n        foreach (vowel;\
    \ vowels)\n        {\n            if (word[i] == vowel)\n            {\n     \
    \           isVowel = true;\n                break;\n            }\n        }\n\
    \        if (isVowel)\n        {\n            continue;\n        }\n        else\n\
    \        {\n            consonants ~= i;\n        }\n    }\n    for (int i = consonants.length\
    \ - 1; i > 0; i--)\n    {\n        start_distance = shortest_distance;\n     \
    \   for (int j = consonants[i] + 1; j < word.length; j++)\n        {\n       \
    \     foreach (vowel; vowels)\n            {\n                if (word[j] == vowel)\n\
    \                {\n                    distance = j - consonants[i];\n      \
    \              if (distance < start_distance)\n                    {\n       \
    \                 start_distance = distance;\n                        closest_vowel\
    \ = vowel;\n                    }\n                    break;\n              \
    \  }\n            }\n        }\n        shortest_distance = start_distance;\n\
    \    }\n    return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmapv3o6l.d(25): Error: cannot implicitly convert expression `"aeiouAEIOU"`
    of type `string` to `string[]`

    /tmp/tmpmapv3o6l.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpmapv3o6l.d(39): Error: incompatible types for `(word[cast(ulong)i]) ==
    (vowel)`: `immutable(char)` and `string`

    /tmp/tmpmapv3o6l.d(54): Error: cannot implicitly convert expression `consonants.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpmapv3o6l.d(61): Error: incompatible types for `(word[cast(ulong)j]) ==
    (vowel)`: `immutable(char)` and `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmapv3o6l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowel=\"aeiouAEIOU\";\n    string\
    \ lst=\"\";\n    foreach(immutable i, immutable c; word)\n    {\n        if(i<word.length-1)\n\
    \        {\n            if(vowel.indexOf(word[i])!=-1)\n            {\n      \
    \          if(vowel.indexOf(word[i+1])==-1)\n                {\n             \
    \       lst=word[i];\n                    break;\n                }\n        \
    \    }\n        }\n    }\n    return lst;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0l0p9fuy.d(31): Error: no property `indexOf` for type `string`

    /tmp/tmp0l0p9fuy.d(33): Error: no property `indexOf` for type `string`

    /tmp/tmp0l0p9fuy.d(35): Error: cannot implicitly convert expression `word[i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0l0p9fuy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string::size_type\
    \ pos = 0;\n    if (word.length() < 2)\n        return \"\";\n    if (vowels.find(word[word.length()-1])\
    \ != string::npos)\n        return \"\";\n    pos = word.rfind_first_of(vowels);\n\
    \    while (pos != string::npos)\n    {\n        if (pos + 1 < word.length() &&\
    \ vowels.find(word[pos+1]) == string::npos)\n            return word.substr(pos,\
    \ 1);\n        pos = word.rfind_first_of(vowels, pos-1);\n    }\n    return \"\
    \";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv5a_djf8.d(26): Error: use `.` for member lookup, not `::`

    /tmp/tmpv5a_djf8.d(29): Error: found `:` when expecting `)`

    /tmp/tmpv5a_djf8.d(29): Error: found `:` instead of statement

    /tmp/tmpv5a_djf8.d(32): Error: found `:` when expecting `)`

    /tmp/tmpv5a_djf8.d(32): Error: found `:` instead of statement

    /tmp/tmpv5a_djf8.d(38): Error: declaration expected, not `return`

    /tmp/tmpv5a_djf8.d(39): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv5a_djf8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    if (word.length < 2) return \"\";\n\
    \    string vowels = \"aoeui\";\n    string result = \"\";\n    int right_index\
    \ = word.length-1;\n    int left_index = word.length-2;\n    while (right_index\
    \ > 0)\n    {\n        if (vowels.find(word[right_index]) == -1 && vowels.find(word[left_index])\
    \ == -1)\n        {\n            right_index--;\n            left_index--;\n \
    \       }\n        else if (vowels.find(word[right_index]) == -1 && vowels.find(word[left_index])\
    \ != -1)\n        {\n            result = word[left_index];\n            break;\n\
    \        }\n        else if (vowels.find(word[right_index]) != -1 && vowels.find(word[left_index])\
    \ == -1)\n        {\n            result = word[right_index];\n            break;\n\
    \        }\n        else\n        {\n            break;\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg5gs470o.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpg5gs470o.d(29): Error: cannot implicitly convert expression `word.length
    - 2LU` of type `ulong` to `int`

    /tmp/tmpg5gs470o.d(32): Error: no property `find` for type `string`

    /tmp/tmpg5gs470o.d(32): Error: no property `find` for type `string`

    /tmp/tmpg5gs470o.d(37): Error: no property `find` for type `string`

    /tmp/tmpg5gs470o.d(37): Error: no property `find` for type `string`

    /tmp/tmpg5gs470o.d(39): Error: cannot implicitly convert expression `word[cast(ulong)left_index]`
    of type `immutable(char)` to `string`

    /tmp/tmpg5gs470o.d(42): Error: no property `find` for type `string`

    /tmp/tmpg5gs470o.d(42): Error: no property `find` for type `string`

    /tmp/tmpg5gs470o.d(44): Error: cannot implicitly convert expression `word[cast(ulong)right_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg5gs470o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static assert((\"yogurt\")==(\"yogurt\"\
    ));\n    static assert((\"yogurt\")!=(\"Yogurt\"));\n    static assert((\"yogurt\"\
    )!=(\"y0gurt\"));\n    auto string vowel = \"aeiou\";\n    //int fvowel = -1;\n\
    \    int fvowel = indexOf(vowel, word);\n    int lvowel = fvowel;\n    if (fvowel==-1)\n\
    \        return \"\";\n    while(fvowel<word.length && lvowel>-1)\n    {\n   \
    \     auto first = word[fvowel];\n        auto second = word[lvowel];\n      \
    \  if (second ==first)\n        {\n            --lvowel;\n            continue;\n\
    \        }\n        auto first_pos = indexOf(vowel, first);\n        auto second_pos\
    \ = indexOf(vowel, second);\n        if (first_pos == -1 && second_pos == -1)\n\
    \        {\n            fvowel++;\n            lvowel--;\n            continue;\n\
    \        }\n        if (first_pos == -1)\n        {\n            return second;\n\
    \        }\n        if (second_pos == -1)\n        {\n            return first;\n\
    \        }\n        if (abs(fvowel-lvowel)>1)\n        {\n            fvowel++;\n\
    \            lvowel--;\n            continue;\n        }\n        if (first_pos\
    \ < second_pos)\n        {\n            return first;\n        }\n        else\n\
    \        {\n            return second;\n        }\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3i2qan03.d(28): Error: variable `tmp3i2qan03.get_closest_vowel.vowel`
    storage class `auto` has no effect if type is not inferred, did you mean `scope`?

    /tmp/tmp3i2qan03.d(30): Error: undefined identifier `indexOf`

    /tmp/tmp3i2qan03.d(43): Error: undefined identifier `indexOf`

    /tmp/tmp3i2qan03.d(44): Error: undefined identifier `indexOf`

    /tmp/tmp3i2qan03.d(53): Error: cannot implicitly convert expression `second` of
    type `immutable(char)` to `string`

    /tmp/tmp3i2qan03.d(57): Error: cannot implicitly convert expression `first` of
    type `immutable(char)` to `string`

    /tmp/tmp3i2qan03.d(67): Error: cannot implicitly convert expression `first` of
    type `immutable(char)` to `string`

    /tmp/tmp3i2qan03.d(71): Error: cannot implicitly convert expression `second` of
    type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3i2qan03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  return find_if(retro(word), (dchar x) {\n        return x == \"\";\n    });\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfuh6s3h6.d(26): Error: undefined identifier `find_if`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfuh6s3h6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string ret = \"\";\n    foreach(i, ch; word)\n    {\n        if(vowels.canFind(ch))\n\
    \        {\n            if(i > 0 && i < word.length - 1)\n            {\n    \
    \            if(!vowels.canFind(word[i - 1]) && !vowels.canFind(word[i + 1]))\n\
    \                {\n                    ret = ch;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmped7sl_zh.d(29): Error: no property `canFind` for type `string`

    /tmp/tmped7sl_zh.d(33): Error: no property `canFind` for type `string`

    /tmp/tmped7sl_zh.d(33): Error: no property `canFind` for type `string`

    /tmp/tmped7sl_zh.d(35): Error: cannot implicitly convert expression `ch` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmped7sl_zh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string closest = \"\";\n    int word_length\
    \ = word.length;\n    string cons = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    int min_distance = -1;\n    if (word_length == 0 || word_length == 1)\n\
    \        return closest;\n    for (int i = 0; i < word_length; i++)\n    {\n \
    \       if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i]\
    \ == 'O' || word[i] == 'U')\n        {\n            if (i < word_length - 1)\n\
    \            {\n                if (word[i + 1] == 'a' || word[i + 1] == 'e' ||\
    \ word[i + 1] == 'i' || word[i + 1] == 'o' || word[i + 1] == 'u' || word[i + 1]\
    \ == 'A' || word[i + 1] == 'E' || word[i + 1] == 'I' || word[i + 1] == 'O' ||\
    \ word[i + 1] == 'U')\n                    continue;\n            }\n        \
    \    if (i > 0)\n            {\n                if (word[i - 1] == 'a' || word[i\
    \ - 1] == 'e' || word[i - 1] == 'i' || word[i - 1] == 'o' || word[i - 1] == 'u'\
    \ || word[i - 1] == 'A' || word[i - 1] == 'E' || word[i - 1] == 'I' || word[i\
    \ - 1] == 'O' || word[i - 1] == 'U')\n                    continue;\n        \
    \    }\n            int dist = 0;\n            for (int j = word_length - 1; j\
    \ > i; j--)\n            {\n                for (int k = 0; k < cons.length;\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxlkc9bwt.d(49): Error: expression expected, not `unittest`

    /tmp/tmpxlkc9bwt.d(50): Error: found `{` when expecting `)`

    /tmp/tmpxlkc9bwt.d(67): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxlkc9bwt.d(67): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxlkc9bwt.d(67): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxlkc9bwt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n  string vowels = \"AEIOUaeiou\";\n  bool\
    \ isConsonant = true;\n  int index = 0;\n  for (int i = word.length - 1; i >=\
    \ 0; i--)\n  {\n    if (vowels.findFirstOf(word[i]) != -1) {\n      if (isConsonant)\
    \ {\n        index = i;\n        break;\n      }\n      isConsonant = true;\n\
    \    }\n    else {\n      isConsonant = false;\n    }\n  }\n  return (index !=\
    \ 0) ? word[index] : \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_w9rw_ld.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp_w9rw_ld.d(30): Error: no property `findFirstOf` for type `string`

    /tmp/tmp_w9rw_ld.d(41): Error: incompatible types for `(word[cast(ulong)index])
    : ("")`: `immutable(char)` and `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_w9rw_ld.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ rightConsonants = \"\";\n    string leftConsonants = \"\";\n    string result\
    \ = \"\";\n    auto is_consonant = [] (char c) { return !(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u'); };\n    auto find_consonants = [&] (string&\
    \ start, string&end) {\n        for (int i = start.length-1; i >= 0; i--) {\n\
    \            if (is_consonant(start[i])) {\n                start = start[i..$];\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    for (int i = 0; i < end.length; i++) {\n            if (is_consonant(end[i]))\
    \ {\n                end = end[0..i];\n            } else {\n                break;\n\
    \            }\n        }\n    };\n    find_consonants(rightConsonants, leftConsonants);\n\
    \    word = rightConsonants ~ leftConsonants;\n    if (word.length == 0) {\n \
    \       return \"\";\n    }\n    int dist = 0;\n    foreach (int i, char c; word)\
    \ {\n        if (vowels.canFind(c)) {\n            if (dist == 0) {\n        \
    \        dist = i;\n                result = c;\n            } else if (i < dist)\
    \ {\n                dist = i;\n                result = c;\n            }\n \
    \       }\n    }\n    return result;\n}\n/*\n    Note:\n    - https://www.geeksforgeeks.org/g-fact-44/\n\
    */\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfmifqbnl.d(29): Error: found `c` when expecting `.` following char

    /tmp/tmpfmifqbnl.d(29): Error: found `)` when expecting identifier following `char`.

    /tmp/tmpfmifqbnl.d(29): Error: found `{` when expecting `,`

    /tmp/tmpfmifqbnl.d(29): Error: expression expected, not `return`

    /tmp/tmpfmifqbnl.d(29): Error: found `!` when expecting `,`

    /tmp/tmpfmifqbnl.d(29): Error: found `;` when expecting `,`

    /tmp/tmpfmifqbnl.d(29): Error: expression expected, not `}`

    /tmp/tmpfmifqbnl.d(29): Error: found `;` when expecting `,`

    /tmp/tmpfmifqbnl.d(30): Error: expression expected, not `auto`

    /tmp/tmpfmifqbnl.d(30): Error: found `find_consonants` when expecting `,`

    /tmp/tmpfmifqbnl.d(30): Error: expression expected, not `=`

    /tmp/tmpfmifqbnl.d(30): Error: expression expected, not `]`

    /tmp/tmpfmifqbnl.d(30): Error: found `{` when expecting `,`

    /tmp/tmpfmifqbnl.d(31): Error: expression expected, not `for`

    /tmp/tmpfmifqbnl.d(31): Error: found `i` when expecting `.` following int

    /tmp/tmpfmifqbnl.d(31): Error: found `=` when '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // Added char[string] for constant time\
    \ lookup.\n    enum char[string] vowels = ['a':true, 'e':true, 'i':true, 'o':true,\
    \ 'u':true, 'A':true, 'E':true, 'I':true, 'O':true, 'U':true];\n    string result\
    \ = \"\";\n    bool found_vowel = false;\n    int i = word.length - 1;\n    int\
    \ j = i - 1;\n    while (i > -1 && j > -1)\n    {\n        if (vowels[word[i]]\
    \ && !vowels[word[j]])\n        {\n            found_vowel = true;\n         \
    \   result = word[i];\n            break;\n        }\n        i--;\n        j--;\n\
    \    }\n    if (!found_vowel)\n    {\n        result = \"\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4c_dokop.d(26): Error: cannot implicitly convert expression `[''a'':true,
    ''e'':true, ''i'':true, ''o'':true, ''u'':true, ''A'':true, ''E'':true, ''I'':true,
    ''O'':true, ''U'':true]` of type `bool[char]` to `char[string]`

    /tmp/tmp4c_dokop.d(29): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp4c_dokop.d(36): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4c_dokop.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowels = \"aeiouAEIOU\"\
    ;\n    static immutable vowels_length = vowels.length;\n    static immutable word_length\
    \ = word.length;\n    static immutable word_length_1 = word_length - 1;\n    static\
    \ immutable word_length_2 = word_length - 2;\n    static size_t j = word_length_1;\n\
    \    static auto find_vowel = [&](size_t i)\n    {\n        while(j >= 1)\n  \
    \      {\n            for(size_t z = 0; z < vowels_length; ++z)\n            {\n\
    \                if(word[j] == vowels[z])\n                {\n               \
    \     return j;\n                }\n            }\n            --j;\n        }\n\
    \        return size_t.max;\n    };\n    static size_t k = word_length_2;\n  \
    \  static auto find_consonant = [&](size_t i)\n    {\n        while(k >= 1)\n\
    \        {\n            for(size_t z = 0; z < vowels_length; ++z)\n          \
    \  {\n                if(word[k] != vowels[z])\n                {\n          \
    \          return k;\n                }\n            }\n            --k;\n   \
    \     }\n        return size_t.max;\n    };\n    static bool start = true;\n \
    \   static bool consonant_found = false;\n    static string result = \"\";\n \
    \   static size_t vowel_index = 0;\n    static size_t consonant_index = 0;\n \
    \   static size_t shortest_distance = size_t.max;\n    static size_t temp_distance\
    \ = 0;\n    static size_t i = 0;\n    while(i < word_length)\n    {\n        if(start)\n\
    \        {\n            consonant_index = find_consonant(i);\n            if(consonant_index\
    \ == size_t.max)\n            {\n                return \"\";\n            }\n\
    \            vowel_index = find_vowel(i);\n            if(vowel_index == size_t.max)\n\
    \            {\n                return \"\";\n            }\n            start\
    \ = false;\n           \nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0fwsvw3k.d(31): Error: expression expected, not `]`

    /tmp/tmp0fwsvw3k.d(31): Error: found `i` when expecting `,`

    /tmp/tmp0fwsvw3k.d(32): Error: found `{` when expecting `,`

    /tmp/tmp0fwsvw3k.d(33): Error: expression expected, not `while`

    /tmp/tmp0fwsvw3k.d(34): Error: found `{` when expecting `,`

    /tmp/tmp0fwsvw3k.d(35): Error: expression expected, not `for`

    /tmp/tmp0fwsvw3k.d(35): Error: found `z` when expecting `,`

    /tmp/tmp0fwsvw3k.d(35): Error: expression expected, not `=`

    /tmp/tmp0fwsvw3k.d(35): Error: found `0` when expecting `,`

    /tmp/tmp0fwsvw3k.d(35): Error: expression expected, not `;`

    /tmp/tmp0fwsvw3k.d(35): Error: found `z` when expecting `,`

    /tmp/tmp0fwsvw3k.d(35): Error: expression expected, not `<`

    /tmp/tmp0fwsvw3k.d(35): Error: found `vowels_length` when expecting `,`

    /tmp/tmp0fwsvw3k.d(35): Error: expression expected, not `;`

    /tmp/tmp0fwsvw3k.d(35): Error: found `z` when expecting `,`

    /tmp/tmp0fwsvw3k.d(36): Error: found `{` when expecting `,`

    /tmp/tmp0fwsvw3k.d(37): Error: expression expe'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowel = \"aeiouAEIOU\";\n   \
    \ if(word.length < 2)\n        return \"\";\n    int index = word.length;\n  \
    \  if(vowel.findFirstOf(word[index - 1]) != string.npos)\n        index = word.length\
    \ - 1;\n    for(int i = index - 2; i >= 0; i--)\n    {\n        if(vowel.findFirstOf(word[i])\
    \ != string.npos)\n        {\n            if(vowel.findFirstOf(word[i + 1]) ==\
    \ string.npos)\n                return word[i..$];\n        }\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6_rdqk0p.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp6_rdqk0p.d(29): Error: no property `findFirstOf` for type `string`

    /tmp/tmp6_rdqk0p.d(29): Error: no property `npos` for type `string`

    /tmp/tmp6_rdqk0p.d(30): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp6_rdqk0p.d(33): Error: no property `findFirstOf` for type `string`

    /tmp/tmp6_rdqk0p.d(33): Error: no property `npos` for type `string`

    /tmp/tmp6_rdqk0p.d(35): Error: no property `findFirstOf` for type `string`

    /tmp/tmp6_rdqk0p.d(35): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6_rdqk0p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  char[] newWord = word.dup;\n    newWord.reverse;\n    foreach(i,char; newWord)\n\
    \    {\n        if(vowels.find(char) != -1)\n        {\n            return to!string(char);\n\
    \        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp238n4ve7.d(28): Error: no identifier for declarator `char`

    /tmp/tmp238n4ve7.d(30): Error: found `)` when expecting `.` following char

    /tmp/tmp238n4ve7.d(30): Error: found `!=` when expecting identifier following
    `char`.

    /tmp/tmp238n4ve7.d(31): Error: found `{` when expecting `)`

    /tmp/tmp238n4ve7.d(32): Error: found `)` when expecting `.` following char

    /tmp/tmp238n4ve7.d(32): Error: found `;` when expecting identifier following `char`.

    /tmp/tmp238n4ve7.d(33): Error: found `}` when expecting `,`

    /tmp/tmp238n4ve7.d(34): Error: expression expected, not `}`

    /tmp/tmp238n4ve7.d(35): Error: found `return` when expecting `,`

    /tmp/tmp238n4ve7.d(35): Error: found `;` when expecting `,`

    /tmp/tmp238n4ve7.d(36): Error: expression expected, not `}`

    /tmp/tmp238n4ve7.d(37): Error: found `unittest` when expecting `,`

    /tmp/tmp238n4ve7.d(55): Error: found `void` when expecting `,`

    /tmp/tmp238n4ve7.d(55): Error: found `{` when expecting `,`

    /tmp/tmp238n4ve7.d(55): Error: expression expected, not `}`

    /tmp/tmp238n4ve7.d(55'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    size_t closest = 0;\n    int distance\
    \ = 0;\n    foreach(size_t index, char letter; word)\n    {\n        if(\"aeiouAEIOU\"\
    .find(letter) != -1)\n        {\n            if(distance == 0)\n            {\n\
    \                distance = (word.length - index);\n                closest =\
    \ index;\n            }\n            else if((word.length - index) < distance)\n\
    \            {\n                distance = (word.length - index);\n          \
    \      closest = index;\n            }\n        }\n    }\n    if(distance == 0)\n\
    \    {\n        return \"\";\n    }\n    return word[closest..closest];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7dk1fdlc.d(29): Error: no property `find` for type `string`

    /tmp/tmp7dk1fdlc.d(33): Error: cannot implicitly convert expression `word.length
    - index` of type `ulong` to `int`

    /tmp/tmp7dk1fdlc.d(38): Error: cannot implicitly convert expression `word.length
    - index` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7dk1fdlc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ consonants = \"bcdfghjklmnpqrstvwxyz\";\n    string c;\n    c.length = word.length;\n\
    \    int i = word.length;\n    while(i-- > 0)\n    {\n        if(consonants.indexOf(word[i])\
    \ != -1)\n        {\n            c[i] = 1;\n        }\n        else\n        {\n\
    \            c[i] = 0;\n        }\n    }\n    //writeln(c);\n    //writeln(word);\n\
    \    int start = word.length - 1;\n    while(start > 0)\n    {\n        if(c[start]\
    \ == 1 && c[start - 1] == 0)\n        {\n            break;\n        }\n     \
    \   start--;\n    }\n    if(start == 0)\n    {\n        return \"\";\n    }\n\
    \    string vowel = \"\";\n    int min_index = 0;\n    foreach(i, ch; word[start..$])\n\
    \    {\n        if(vowels.indexOf(ch) != -1)\n        {\n            vowel ~=\
    \ ch;\n            min_index = i;\n            break;\n        }\n    }\n    foreach(i,\
    \ ch; word[start..$])\n    {\n        if(vowels.indexOf(ch) != -1)\n        {\n\
    \            if(i < min_index)\n            {\n                min_index = i;\n\
    \                vowel = ch;\n            }\n        }\n    }\n    return vowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuk94vf6h.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpuk94vf6h.d(32): Error: no property `indexOf` for type `string`

    /tmp/tmpuk94vf6h.d(34): Error: cannot modify `immutable` expression `c[cast(ulong)i]`

    /tmp/tmpuk94vf6h.d(38): Error: cannot modify `immutable` expression `c[cast(ulong)i]`

    /tmp/tmpuk94vf6h.d(43): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpuk94vf6h.d(58): Error: variable `i` is shadowing variable `tmpuk94vf6h.get_closest_vowel.i`

    /tmp/tmpuk94vf6h.d(60): Error: no property `indexOf` for type `string`

    /tmp/tmpuk94vf6h.d(63): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpuk94vf6h.d(67): Error: variable `i` is shadowing variable `tmpuk94vf6h.get_closest_vowel.i`

    /tmp/tmpuk94vf6h.d(69): Error: no property `indexOf` for type `string`

    /tmp/tmpuk94vf6h.d(73): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpuk94vf6h.d(74): E'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4keu6id4.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x42818d]

    ??:? void tmp4keu6id4.__unittest_L27_C1() [0x427ad3]

    ??:? void tmp4keu6id4.__modtest() [0x427f10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42be37]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ad46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fe5d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43030c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fde9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ad1d]

    ??:? runModuleUnitTests [0x42bc0d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4285dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowel = \"aeiouAEIOU\";\n   \
    \ string cons = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int closest_vowel_distance\
    \ = 999;\n    int closest_vowel_index = -1;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowel.indexOf(word[i]) != -1)\n        {\n        \
    \    for (int j = i; j >= 0; j--)\n            {\n                if (cons.indexOf(word[j])\
    \ != -1)\n                {\n                    int vowel_distance = i - j;\n\
    \                    if (vowel_distance < closest_vowel_distance)\n          \
    \          {\n                        closest_vowel_distance = vowel_distance;\n\
    \                        closest_vowel_index = i;\n                    }\n   \
    \                 break;\n                }\n            }\n        }\n    }\n\
    \    if (closest_vowel_index != -1)\n    {\n        return word[closest_vowel_index..$];\n\
    \    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0yziyi93.d(31): Error: no property `indexOf` for type `string`

    /tmp/tmp0yziyi93.d(35): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0yziyi93.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    const string vowels = \"AEIOUYaeiouy\"\
    ;\n    const string consonants = \"BCDFGHJKLMNPQRSTVWXZbcdfghjklmnpqrstvwxz\"\
    ;\n    bool hasFoundVowel = false;\n    bool hasFoundConsonant = false;\n    for\
    \ (int i = word.length - 1; i >= 0; i--) {\n        if (consonants.canFind(word[i]))\
    \ {\n            hasFoundConsonant = true;\n        }\n        if (vowels.canFind(word[i]))\
    \ {\n            if (hasFoundConsonant && hasFoundVowel) {\n                return\
    \ word[i .. i + 1];\n            }\n            hasFoundVowel = true;\n      \
    \  }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpod9nbe1t.d(29): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpod9nbe1t.d(30): Error: no property `canFind` for type `const(string)`

    /tmp/tmpod9nbe1t.d(33): Error: no property `canFind` for type `const(string)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpod9nbe1t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string closest_vowel = \"\";\n    int result_index = 0;\n    int first_consonant_index\
    \ = 0;\n    int last_consonant_index = 0;\n    int abs_diff = 0;\n    int min_abs_diff\
    \ = 0;\n    for (int i = 0; i < word.length; i++)\n    {\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i]\
    \ == 'U')\n        {\n            closest_vowel = word[i];\n            first_consonant_index\
    \ = i;\n            for (int j = word.length - 1; j > i; j--)\n            {\n\
    \                if (word[j] != 'a' && word[j] != 'e' && word[j] != 'i' && word[j]\
    \ != 'o' && word[j] != 'u' && word[j] != 'A' && word[j] != 'E' && word[j] != 'I'\
    \ && word[j] != 'O' && word[j] != 'U')\n                {\n                  \
    \  last_consonant_index = j;\n                    break;\n                }\n\
    \            }\n            abs_diff = abs(last_consonant_index - first_consonant_index);\n\
    \            if (min_abs_diff == 0)\n            {\n                min_abs_diff\
    \ = abs_diff;\n                result_index = i;\n            }\n            else\
    \ if (abs_diff < min_abs_diff)\n            {\n                min_abs_diff =\
    \ abs_diff;\n                result_index = i;\n            }\n        }\n   \
    \ }\n    if (min_abs_diff == 0)\n    {\n        return \"\";\n    }\n    else\n\
    \    {\n        return word[result_index];\n   \nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5yu47lta.d(67): Error: found `unittest` instead of statement

    /tmp/tmp5yu47lta.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5yu47lta.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  size_t start_index = word.indexOf(\" \");\n    if (start_index == string.npos)\n\
    \        start_index = 0;\n    size_t end_index = word.lastIndexOf(\" \");\n \
    \   if (end_index == string.npos)\n        end_index = word.length;\n    size_t\
    \ vowel_index = string.npos;\n    size_t vowel_distance = string.npos;\n    foreach\
    \ (v; vowels) {\n        size_t current_index = word.indexOf(v, start_index);\n\
    \        while (current_index != string.npos) {\n            if (current_index\
    \ > end_index)\n                break;\n            if (current_index > start_index\
    \ && \n                !isalpha(word[current_index - 1])) {\n                if\
    \ (vowel_index == string.npos || \n                    current_index - start_index\
    \ < vowel_distance) {\n                    vowel_index = current_index;\n    \
    \                vowel_distance = current_index - start_index;\n             \
    \   }\n            }\n            if (current_index < end_index && \n        \
    \        !isalpha(word[current_index + 1])) {\n                if (vowel_index\
    \ == string.npos || \n                    current_index - start_index < vowel_distance)\
    \ {\n                    vowel_index = current_index;\n                    vowel_distance\
    \ = current_index - start_index;\n                }\n            }\n         \
    \   current_index = word.indexOf(v, current_index + 1);\n        }\n    }\n  \
    \  if (vowel_index == string.npos)\n        return \"\";\n    return word[vowel_index\
    \ .. $];\n}\nstring[][] test_cases = [\n    [\"yogurt\", \"u\"],\n    [\"FULL\"\
    , \"U\"],\n    [\"quick\", \"\"],\n    [\"ab\", \"\"],\n    [\" \", \"\"],\n \
    \   [\"\", \"\"],\n    [\"dog\", \"o\"],\n    [\"dgo\", \"o\"],\n    [\"gdi\"\
    , \"i\"],\n    [\"gdi\", \"i\"],\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprqn2yuyp.d(73): Error: expression expected, not `unittest`

    /tmp/tmprqn2yuyp.d(74): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmprqn2yuyp.d(91): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmprqn2yuyp.d(91): Error: semicolon expected, not `main`

    /tmp/tmprqn2yuyp.d(91): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmprqn2yuyp.d(91): Error: no identifier for declarator `main()`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqn2yuyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int n = word.length;\n    if (n < 3)\
    \ return \"\";\n    int vowels[5] = {'a', 'e', 'i', 'o', 'u'};\n    int idx;\n\
    \    int min_distance = n;\n    string closest_vowel = \"\";\n    foreach (i;\
    \ 0 .. n) {\n        foreach (v; vowels) {\n            if (word[i] == v) {\n\
    \                idx = i;\n                break;\n            }\n        }\n\
    \        if (idx == 0) continue;\n        if (word[idx + 1] == 'a' || word[idx\
    \ + 1] == 'e' || word[idx + 1] == 'i' || word[idx + 1] == 'o' || word[idx + 1]\
    \ == 'u') continue;\n        if (word[idx - 1] == 'a' || word[idx - 1] == 'e'\
    \ || word[idx - 1] == 'i' || word[idx - 1] == 'o' || word[idx - 1] == 'u') continue;\n\
    \        if (n - idx - 1 < min_distance) {\n            min_distance = n - idx\
    \ - 1;\n            closest_vowel = word[idx .. idx];\n        }\n    }\n    return\
    \ closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjte_gjms.d(27): Deprecation: instead of C-style syntax, use D-style
    syntax `int[5] vowels`

    /tmp/tmpjte_gjms.d(25): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjte_gjms.d(27): Error: a struct is not a valid initializer for a `int[5]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjte_gjms.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int word_size = word.length;\n    //return\
    \ word.slice(word_size-2, word_size-1);\n    //return word[word_size-2];\n   \
    \ // return word[word_size-1];\n    //return word[word_size-2];\n    int current_word_position\
    \ = word_size-1;\n    //return \"a\";\n    //return word[1];\n    while(current_word_position\
    \ > 0){\n        if(word[current_word_position] != 'a' && word[current_word_position]\
    \ != 'e' &&\n                word[current_word_position] != 'i' && word[current_word_position]\
    \ != 'o' &&\n                word[current_word_position] != 'u' && word[current_word_position]\
    \ != 'A' &&\n                word[current_word_position] != 'E' && word[current_word_position]\
    \ != 'I' &&\n                word[current_word_position] != 'O' && word[current_word_position]\
    \ != 'U'){\n            break;\n        }\n        else {\n            current_word_position\
    \ -= 1;\n        }\n    }\n    //return to!string(current_word_position);\n  \
    \  if(current_word_position == 0) {\n        return \"\";\n    }\n    return word[current_word_position-1];\n\
    }\n//==========================\n/*\nYou are given a word. Your task is to find\
    \ the closest vowel that stands between \n    two consonants from the right side\
    \ of the word (case sensitive).\n    \n    Vowels in the beginning and ending\
    \ doesn't count. Return empty string if you didn't\n    find any vowel met the\
    \ above condition. \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2xrr_28v.d(52): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2xrr_28v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto iter = word.rfind('a');\n    if\
    \ (iter == string.npos) {\n        iter = word.rfind('e');\n        if (iter ==\
    \ string.npos) {\n            iter = word.rfind('i');\n            if (iter ==\
    \ string.npos) {\n                iter = word.rfind('o');\n                if\
    \ (iter == string.npos) {\n                    iter = word.rfind('u');\n     \
    \               if (iter == string.npos) {\n                        iter = word.rfind('y');\n\
    \                        if (iter == string.npos) {\n                        \
    \    return \"\";\n                        }\n                    }\n        \
    \        }\n            }\n        }\n    }\n    return word[iter..$];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1acb2mno.d(25): Error: no property `rfind` for type `string`

    /tmp/tmp1acb2mno.d(26): Error: no property `npos` for type `string`

    /tmp/tmp1acb2mno.d(28): Error: no property `npos` for type `string`

    /tmp/tmp1acb2mno.d(30): Error: no property `npos` for type `string`

    /tmp/tmp1acb2mno.d(32): Error: no property `npos` for type `string`

    /tmp/tmp1acb2mno.d(34): Error: no property `npos` for type `string`

    /tmp/tmp1acb2mno.d(36): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1acb2mno.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string r_char;\n    auto cnt = 0;\n\
    \    auto has_left = false;\n    auto has_right = false;\n    bool [] vowels =\
    \ [true, false, false, false, true, false, false, false, true, false, false, false,\
    \ false, false, true, false, false, false, false, false, true, false, false, false,\
    \ false, false];\n    foreach(const i, w; word)\n    {\n        if(vowels[i])\n\
    \        {\n            cnt++;\n            if(cnt == 2)\n            {\n    \
    \            has_left = true;\n            }\n            if(cnt == 3)\n     \
    \       {\n                has_right = true;\n            }\n        }\n     \
    \   else\n        {\n            cnt = 0;\n        }\n        if(has_left && has_right)\n\
    \        {\n            r_char = w;\n            break;\n        }\n    }\n  \
    \  return r_char;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprc052h8a.d(50): Error: cannot implicitly convert expression `w`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprc052h8a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowel = \"aeiouAEIOU\";\n   \
    \ string consonant = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ ret;\n    string check;\n    size_t pos;\n    int distance;\n    size_t p2;\n\
    \    int min_distance = -1;\n    int temp_distance;\n    check = word[0];\n  \
    \  foreach(i,v)\n    {\n        //cout << \"check \" << check << \" vs \" << word[word.length\
    \ - 1] << endl;\n        //cout << \"i \" << i << \" v \" << v << endl;\n    \
    \    if(check == word[word.length - 1])\n        {\n            return \"\";\n\
    \        }\n        else if(vowel.find(check) != -1)\n        {\n            pos\
    \ = v;\n            p2 = pos;\n            check = word[pos + 1];\n          \
    \  if(check == word[word.length - 1])\n            {\n                //cout <<\
    \ \"first \" << endl;\n                return \"\";\n            }\n         \
    \   //cout << \"pos \" << pos << endl;\n            //cout << \"word[pos] \" <<\
    \ word[pos] << endl;\n            while(vowel.find(check) != -1)\n           \
    \ {\n                //cout << \"pos \" << pos << endl;\n                p2 =\
    \ p2 + 1;\n                check = word[p2 + 1];\n                if(check ==\
    \ word[word.length - 1])\n                {\n                    //cout << \"\
    second \" << endl;\n                    return \"\";\n                }\n    \
    \        }\n            if(p2 != word.length - 1)\n            {\n           \
    \     distance = p2 - pos;\n                if(distance <= min_distance || min_distance\
    \ == -1)\n                {\n                    min_distance = distance;\n  \
    \                  ret = word[pos];\n                }\n            }\n      \
    \      check = word[p2 + 1];\n            if(check == word[word.length - 1])\n\
    \            {\n                //cout << \"third \" << endl;\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyhllx57b.d(35): Error: no identifier for declarator `v`

    /tmp/tmpyhllx57b.d(35): Error: found `)` when expecting `;`

    /tmp/tmpyhllx57b.d(79): Error: found `unittest` instead of statement

    /tmp/tmpyhllx57b.d(97): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpyhllx57b.d(97): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpyhllx57b.d(97): Error: found `End of File` when expecting `)`

    /tmp/tmpyhllx57b.d(97): Error: found `End of File` instead of statement

    /tmp/tmpyhllx57b.d(97): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyhllx57b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string vowels = \"aeiouAEIOU\";\n    int word_size = word.length;\n   \
    \ int pos = -1;\n    for (int i = word_size - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != -1 && i != word_size - 1) {\n            if (consonants.find(word[i + 1])\
    \ == -1) {\n                pos = i + 1;\n                break;\n           \
    \ }\n        }\n    }\n    if (pos == -1) {\n        return \"\";\n    }\n   \
    \ int vowel_pos = pos;\n    int min_distance = 999;\n    for (int i = 0; i < vowels.length;\
    \ i++) {\n        int distance = abs(pos - word.find(vowels[i]));\n        if\
    \ (word.find(vowels[i]) != -1 && distance < min_distance) {\n            min_distance\
    \ = distance;\n            vowel_pos = word.find(vowels[i]);\n        }\n    }\n\
    \    if (min_distance == 999) {\n        return \"\";\n    }\n    return word[vowel_pos\
    \ .. vowel_pos];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplnufm8zp.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplnufm8zp.d(30): Error: no property `find` for type `string`

    /tmp/tmplnufm8zp.d(31): Error: no property `find` for type `string`

    /tmp/tmplnufm8zp.d(43): Error: no property `find` for type `string`

    /tmp/tmplnufm8zp.d(44): Error: no property `find` for type `string`

    /tmp/tmplnufm8zp.d(46): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnufm8zp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ vowels2 = \"AEIOU\";\n    bool state = false;\n    size_t num = 0;\n    if (word\
    \ == \"\")\n        return \"\";\n    while (word.size() > 0)\n    {\n       \
    \ if (word[word.size() - 1] == 'a' || word[word.size() - 1] == 'e' || word[word.size()\
    \ - 1] == 'i' || word[word.size() - 1] == 'o' || word[word.size() - 1] == 'u')\n\
    \        {\n            if (state == true)\n                return word[word.size()\
    \ - 1];\n            num = word.size() - 1;\n            state = true;\n     \
    \   }\n        else\n            state = false;\n        word.pop_back();\n  \
    \  }\n    if (state == true)\n        return word[num];\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd0xz850k.d(31): Error: no property `size` for type `string`

    /tmp/tmpd0xz850k.d(33): Error: no property `size` for type `string`

    /tmp/tmpd0xz850k.d(33): Error: no property `size` for type `string`

    /tmp/tmpd0xz850k.d(33): Error: no property `size` for type `string`

    /tmp/tmpd0xz850k.d(33): Error: no property `size` for type `string`

    /tmp/tmpd0xz850k.d(33): Error: no property `size` for type `string`

    /tmp/tmpd0xz850k.d(36): Error: no property `size` for type `string`

    /tmp/tmpd0xz850k.d(37): Error: no property `size` for type `string`

    /tmp/tmpd0xz850k.d(42): Error: no property `pop_back` for type `string`

    /tmp/tmpd0xz850k.d(45): Error: cannot implicitly convert expression `word[num]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd0xz850k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowel = \"aeiou\";\n    string\
    \ result = \"\";\n    for (int i = 0; i < word.length; i++)\n    {\n        //\
    \ Check if vowel\n        if (vowel.count(word[i]) > 0)\n        {\n         \
    \   // Check if vowel is not at the end\n            if (i+1 < word.length)\n\
    \            {\n                // Check if next letter is a consonant\n     \
    \           if (vowel.count(word[i+1]) == 0)\n                {\n            \
    \        // Check if vowel is not at the beginning\n                    if (i-1\
    \ >= 0)\n                    {\n                        // Check if previous letter\
    \ is a consonant\n                        if (vowel.count(word[i-1]) == 0)\n \
    \                       {\n                            // Returns the vowel if\
    \ met all of the conditions\n                            result = word[i];\n \
    \                           break;\n                        }\n              \
    \      }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3d5utkwm.d(30): Error: no property `count` for type `string`

    /tmp/tmp3d5utkwm.d(36): Error: no property `count` for type `string`

    /tmp/tmp3d5utkwm.d(42): Error: no property `count` for type `string`

    /tmp/tmp3d5utkwm.d(45): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3d5utkwm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static auto vowels = tuple(\"A\", \"\
    E\", \"I\", \"O\", \"U\", \"Y\", \"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n\
    \    string result = \"\";\n    bool found_vowel = false;\n    foreach (i, c;\
    \ word)\n    {\n        if (c in vowels)\n        {\n            if (found_vowel)\n\
    \            {\n                break;\n            }\n            else\n    \
    \        {\n                result = c;\n                found_vowel = true;\n\
    \            }\n        }\n        else\n        {\n            found_vowel =\
    \ false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcna1tpjy.d(30): Error: incompatible types for `(c) in (vowels)`:
    `immutable(char)` and `Tuple!(string, string, string, string, string, string,
    string, string, string, string, string, string)`

    /tmp/tmpcna1tpjy.d(38): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcna1tpjy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  enum result_type{\n        no_vowel_found,\n        left_most_vowel_found,\n\
    \        right_most_vowel_found,\n        vowels_found\n    } result = no_vowel_found;\n\
    \    int vowel_index, left_index, right_index;\n    int prev_vowel_index = -1;\n\
    \    for(int i = 0; i < word.length; i++)\n    {\n        for(int j = 0; j < vowels.length;\
    \ j++)\n        {\n            if(word[i] == vowels[j])\n            {\n     \
    \           if(result == no_vowel_found)\n                {\n                \
    \    result = left_most_vowel_found;\n                    left_index = prev_vowel_index;\n\
    \                    right_index = i;\n                    vowel_index = i;\n\
    \                }\n                else if(result == left_most_vowel_found)\n\
    \                {\n                    result = vowels_found;\n             \
    \       right_index = i;\n                }\n                else if(result ==\
    \ right_most_vowel_found)\n                {\n                    result = vowels_found;\n\
    \                    left_index = prev_vowel_index;\n                }\n     \
    \           else if(result == vowels_found)\n                {\n             \
    \       left_index = prev_vowel_index;\n                    right_index = i;\n\
    \                }\n                prev_vowel_index = i;\n            }\n   \
    \     }\n    }\n    if(result == no_vowel_found)\n    {\n        return \"\";\n\
    \    }\n    else if(result == left_most_vowel_found)\n    {\n        if(left_index\
    \ == -1)\n        {\n            return \"\";\n        }\n        else\n     \
    \   {\n            return word[left_index..left_index+1];\n        }\n    }\n\
    \    else if(result == right_most_vowel_found)\n    {\n        if(right_index\
    \ == word.length-1)\n        {\n            return \"\";\n       \nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppt7y5gu9.d(87): Error: found `unittest` instead of statement

    /tmp/tmppt7y5gu9.d(105): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppt7y5gu9.d(105): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppt7y5gu9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    immutable const string vowels = \"aeiouAEIOU\"\
    ;\n    immutable const string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    for (int i = word.length - 1; i >= 0; i--)\n    {\n        foreach (v;\
    \ word[i .. $])\n        {\n            if (vowels.canFind(v))\n            {\n\
    \                foreach (c; word[0 .. i])\n                {\n              \
    \      if (consonants.canFind(c))\n                    {\n                   \
    \     return v;\n                    }\n                }\n            }\n   \
    \     }\n    }\n    return \"\";\n}\n/*\nWrite a function that takes two numbers\
    \ and returns true if their sum is less than 100. Otherwise, the function should\
    \ return false.\n*/\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpksq8sr1m.d(25): Error: conflicting attribute `const`

    /tmp/tmpksq8sr1m.d(26): Error: conflicting attribute `const`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpksq8sr1m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    word = word.stripLeft().stripRight();\n\
    \    // typeof(word[0]) is dchar, immutable(char)[], char*\n    // typeof(word[0])\
    \ == char\n    auto vowels = \"aeiouAEIOU\";\n    if (word.length == 0)\n    \
    \    return \"\";\n    if (word.length == 1)\n        return \"\";\n    if (word.length\
    \ == 2)\n        return \"\";\n    immutable(char)[] arr = word.dup;\n    size_t\
    \ len = arr.length;\n    // if all is upper, call toLower()\n    for (int i =\
    \ 0; i < arr.length; i++)\n    {\n        if (arr[i] == arr[i].toUpper)\n    \
    \    {\n            word = word.toLower;\n            break;\n        }\n    }\n\
    \    // check if string is longer than 2\n    if (word.length > 2)\n    {\n  \
    \      for (int i = 1; i < len - 1; i++)\n        {\n            if (vowels.find(word[i\
    \ - 1]) != -1)\n                continue;\n            if (vowels.find(word[i\
    \ + 1]) != -1)\n                continue;\n            if (vowels.find(word[i])\
    \ != -1)\n                return word[i..i];\n        }\n    }\n    return \"\"\
    ;\n}\n/*\ndef get_closest_vowel(word):\n    if len(word) < 3:\n        return\
    \ ''\n    word = word.lower()\n    idx = -1\n    for i in xrange(1, len(word)\
    \ - 1):\n        if word[i] in 'aeiou' and word[i - 1] not in 'aeiou' and word[i\
    \ + 1] not in 'aeiou':\n            idx = i\n            break\n    return word[idx]\
    \ if idx > -1 else ''\n*/\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbw2hg95r.d(25): Error: no property `stripLeft` for type `string`

    /tmp/tmpbw2hg95r.d(40): Error: no property `toUpper` for type `immutable(char)`

    /tmp/tmpbw2hg95r.d(42): Error: no property `toLower` for type `string`

    /tmp/tmpbw2hg95r.d(51): Error: no property `find` for type `string`

    /tmp/tmpbw2hg95r.d(53): Error: no property `find` for type `string`

    /tmp/tmpbw2hg95r.d(55): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbw2hg95r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowels = Tuple!(\"a\", \"e\", \"\
    i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\");\n    // In case there are\
    \ no vowels\n    if(word.count!(a => vowels.contains(a)) == 0)\n        return\
    \ \"\";\n    // Find the rightmost vowel\n    string rightmost_vowel = word.retro.takeWhile!(a\
    \ => vowels.contains(a)).array[0];\n    // Find the index of the rightmost vowel\n\
    \    size_t index_rightmost_vowel = word.length - word.retro.takeWhile!(a => vowels.contains(a)).array.length;\n\
    \    // If there are no consonants to the right of the vowel, return the vowel\n\
    \    if(index_rightmost_vowel + 1 == word.length)\n        return rightmost_vowel;\n\
    \    // If there are consonants to the right of the vowel\n    else\n    {\n \
    \       string closest_vowel = \"\";\n        string temp_vowel = \"\";\n    \
    \    // Go from the rightmost vowel to the end of the word\n        foreach(i;\
    \ index_rightmost_vowel .. word.length)\n        {\n            // If the first\
    \ item to the right of the vowel is a consonant and there are vowels\n       \
    \     // to the right of it, continue\n            if(!vowels.contains(word[i])\
    \ && word.count!(a => vowels.contains(a)) != 0)\n            {\n             \
    \   // Find the closest vowel to the right of the consonant\n                temp_vowel\
    \ = word.retro.takeWhile!(a => vowels.contains(a)).array[0];\n               \
    \ // Replace the vowel if it is closer to the consonant\n                if(abs(i\
    \ - (word.length - word.retro.takeWhile!(a => vowels.contains(a)).array.length))\
    \ < abs(i - (word.length - word.retro.takeWhile!(a => vowels.contains(a)).array.length)))\n\
    \                    closest_vowel = temp_vowel;\n\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpit_6juco.d(54): Error: found `unittest` instead of statement

    /tmp/tmpit_6juco.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpit_6juco.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpit_6juco.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpit_6juco.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    char[] vowels = ['a', 'e', 'i', 'o',\
    \ 'u', 'A', 'E', 'I', 'O', 'U'];\n    int r = 0;\n    int count = 0;\n    char\
    \ result = ' ';\n    for (int i = word.length - 1; i >= 0; i--)\n    {\n     \
    \   if (vowels.indexOf(word[i]) != -1)\n        {\n            result = word[i];\n\
    \            r = i;\n            break;\n        }\n    }\n    for (int i = r\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.indexOf(word[i]) == -1)\n     \
    \   {\n            count++;\n        }\n        else\n        {\n            return\
    \ \"\";\n        }\n    }\n    if (count == 0)\n    {\n        return \"\";\n\
    \    }\n    return result.toString();\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsubatd6o.d(29): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpsubatd6o.d(31): Error: no property `indexOf` for type `char[]`

    /tmp/tmpsubatd6o.d(40): Error: no property `indexOf` for type `char[]`

    /tmp/tmpsubatd6o.d(53): Error: no property `toString` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsubatd6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    size_t word_size = word.length;\n  \
    \  size_t vowel_pos;\n    size_t last_cons_pos;\n    size_t first_cons_pos;\n\
    \    size_t diff_last;\n    size_t diff_first;\n    string[] vowels = [\"a\",\
    \ \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"];\n    foreach(vowel;\
    \ vowels)\n    {\n        vowel_pos = word.find(vowel);\n        // printf(\"\
    vowel: %s vowel_pos: %s\\n\", vowel, vowel_pos);\n        if(vowel_pos != -1)\n\
    \        {\n            last_cons_pos = word.rfind(\"a\") + word.rfind(\"e\")\
    \ + word.rfind(\"i\") + word.rfind(\"o\") + word.rfind(\"u\") + word.rfind(\"\
    A\") + word.rfind(\"E\") + word.rfind(\"I\") + word.rfind(\"O\") + word.rfind(\"\
    U\") + word_size;\n            // printf(\"last_cons_pos: %s\\n\", last_cons_pos);\n\
    \            diff_last = vowel_pos - last_cons_pos;\n            if(diff_last\
    \ > 1)\n            {\n                first_cons_pos = word.find(\"a\") + word.find(\"\
    e\") + word.find(\"i\") + word.find(\"o\") + word.find(\"u\") + word.find(\"A\"\
    ) + word.find(\"E\") + word.find(\"I\") + word.find(\"O\") + word.find(\"U\")\
    \ + word_size;\n                // printf(\"first_cons_pos: %s\\n\", first_cons_pos);\n\
    \                diff_first = vowel_pos - first_cons_pos;\n                if(diff_first\
    \ > 1)\n                {\n                    return vowel;\n               \
    \ }\n            }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjdn0fv10.d(34): Error: no property `find` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(38): Error: no property `rfind` for type `string`

    /tmp/tmpjdn0fv10.d(43): Error: no property `find` for type `string`

    /tmp/tmpjdn0fv10.d(43): Error: no property `find` for type `string`

    /tmp/tmpjdn0fv10.d(43): Error: no property `find` for type `string`

    /tmp/tmpjdn0fv10.d(43): Error: no property `find` for type `st'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    import std.algorithm : find;\n    import\
    \ std.range : zip;\n    import std.array : array;\n    import std.ascii : toLower;\n\
    \    auto vowels = \"aeiou\";\n    auto vowels_zip = zip(vowels, [1..]);\n   \
    \ auto closest = map!(t => t[0])(\n        filter!(t => t[1] == min(map!(t =>\
    \ t[1])(\n            filter!(t => is(t[0] == vowels_zip[0][0]))(zip(word, [1..])))))(\n\
    \                zip(word, [1..]))).array;\n    return closest.length != 0 ? closest[0]\
    \ : \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv35bo114.d(30): Error: found `..` when expecting `,`

    /tmp/tmpv35bo114.d(33): Error: found `..` when expecting `,`

    /tmp/tmpv35bo114.d(34): Error: found `..` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv35bo114.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    /*\n    int[] vowel_index;\n    for(int\
    \ i = 0; i < word.length; i++)\n    {\n        char ch = word[i];\n        if(ch\
    \ == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')\n        {\n   \
    \         vowel_index ~= i;\n        }\n    }\n    if(vowel_index.length == 0)\n\
    \    {\n        return \"\";\n    }\n    else if(vowel_index.length == 1)\n  \
    \  {\n        return word[vowel_index[0]..vowel_index[0]];\n    }\n    else\n\
    \    {\n        int last_cons_index = 0;\n        int closest_vowel_index = -1;\n\
    \        for(int i = 0; i < vowel_index.length; i++)\n        {\n            int\
    \ cur_cons_index = vowel_index[i] - 1;\n            if(cur_cons_index > last_cons_index)\n\
    \            {\n                last_cons_index = cur_cons_index;\n          \
    \      closest_vowel_index = vowel_index[i];\n            }\n        }\n     \
    \   return word[closest_vowel_index..closest_vowel_index];\n    }\n    */\n  \
    \  int last_cons_index = -1;\n    int closest_vowel_index = -1;\n    for(int i\
    \ = 0; i < word.length; i++)\n    {\n        char ch = word[i];\n        if(ch\
    \ == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')\n        {\n   \
    \         int cur_cons_index = i - 1;\n            if(cur_cons_index > last_cons_index)\n\
    \            {\n                last_cons_index = cur_cons_index;\n          \
    \      closest_vowel_index = i;\n            }\n        }\n    }\n    if(closest_vowel_index\
    \ == -1)\n    {\n        return \"\";\n    }\n    else\n    {\n\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbhtwmb21.d(81): Error: found `unittest` instead of statement

    /tmp/tmpbhtwmb21.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbhtwmb21.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string res = \"\";\n    foreach(ch; word)\n    {\n        if(ch == ' ') break;\n\
    \        else if(vowels.canFind(ch))\n        {\n            res = ch;\n     \
    \       break;\n        }\n    }\n    if(res.length == 0)\n        return \"\"\
    ;\n    else\n        return res;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2okxjmcn.d(30): Error: no property `canFind` for type `string`

    /tmp/tmp2okxjmcn.d(32): Error: cannot implicitly convert expression `ch` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2okxjmcn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string result = \"\";\n    bool passed_vowel = false;\n    for (int i = word.length\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != string::npos) {\n \
    \           if (passed_vowel) {\n                result = word[i];\n         \
    \       break;\n            }\n        } else {\n            passed_vowel = true;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo65rwcwa.d(29): Error: found `:` when expecting `)`

    /tmp/tmpo65rwcwa.d(29): Error: found `:` instead of statement

    /tmp/tmpo65rwcwa.d(34): Error: declaration expected, not `else`

    /tmp/tmpo65rwcwa.d(36): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo65rwcwa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowels = tuple( \"a\", \"e\", \"\
    i\", \"o\", \"u\" );\n    auto found = tuple();\n    foreach(i, index; word)\n\
    \    {\n        if( i in vowels )\n        {\n            found ~= tuple( i, index\
    \ );\n        }\n    }\n    if(found.length == 0)\n    {\n        return \"\"\
    ;\n    }\n    if(found.length == 1)\n    {\n        return found[0][0];\n    }\n\
    \    int lastIndex = word.length - 1;\n    foreach(sub; found)\n    {\n      \
    \  if(sub[1] == lastIndex)\n        {\n            continue;\n        }\n    \
    \    if(sub[1] > 0)\n        {\n            if(sub[1] + 1 < lastIndex)\n     \
    \       {\n                if(sub[0] notin vowels)\n                {\n      \
    \              return sub[0];\n                }\n            }\n        }\n \
    \   }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp19kg5z2i.d(53): Error: found `notin` when expecting `)`

    /tmp/tmp19kg5z2i.d(53): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp19kg5z2i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowels = tuple(['a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n    string[] consonants = word.split();\n\
    \    string[] vowels = word.split();\n    string[] letters = word.split();\n \
    \   string[] result = \"\";\n    int l = word.length();\n    int m = l - 1;\n\
    \    for (int i = 0; i < l; i++) {\n        if (letters[i] in vowels) {\n    \
    \        vowels ~= letters[i];\n        } else {\n            consonants ~= letters[i];\n\
    \        }\n    }\n    if (vowels.length() == 0) {\n        return \"\";\n   \
    \ }\n    if (consonants.length() == 0) {\n        return \"\";\n    }\n    for\
    \ (int i = 0; i < vowels.length(); i++) {\n        int j = word.find(vowels[i]);\n\
    \        if (j > 0) {\n            string s = word[j - 1 .. j + 1];\n        \
    \    if (s[1] in vowels) {\n                if (s[0] in consonants && s[2] in\
    \ consonants) {\n                    result ~= s[1];\n                }\n    \
    \        }\n        }\n    }\n    if (result.length() == 0) {\n        return\
    \ \"\";\n    }\n    return result[result.length() - 1];\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxchb_vwn.d(26): Error: no property `split` for type `string`

    /tmp/tmpxchb_vwn.d(27): Error: no property `split` for type `string`

    /tmp/tmpxchb_vwn.d(27): Error: declaration `tmpxchb_vwn.get_closest_vowel.vowels`
    is already defined

    /tmp/tmpxchb_vwn.d(28): Error: no property `split` for type `string`

    /tmp/tmpxchb_vwn.d(29): Error: cannot implicitly convert expression `""` of type
    `string` to `string[]`

    /tmp/tmpxchb_vwn.d(30): Error: no property `length` for type `string`

    /tmp/tmpxchb_vwn.d(33): Error: incompatible types for `(letters[cast(ulong)i])
    in (vowels)`: `string` and `Tuple!(char[])`

    /tmp/tmpxchb_vwn.d(34): Error: cannot append type `string` to type `Tuple!(char[])`

    /tmp/tmpxchb_vwn.d(39): Error: function expected before `()`, not `1LU` of type
    `ulong`

    /tmp/tmpxchb_vwn.d(42): Error: no property `length` for type `string[]`

    /tmp/tmpxchb_vwn.d(45): Error: function expected before `()`, not `1LU` of type
    `ulong`

    /tmp/tmpxchb_vwn.d(46): Error: no property `find` for type `string`

    /tmp/tmpxchb_vwn.d('
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // TODO\n    // check if there are more\
    \ than one consonants before a vowel \n    // check if there are more than one\
    \ consonants after a vowel\n    // if there are more than one consonants before\
    \ a vowel\n    //      return the vowel closest to the last consonant\n    //\
    \ if there are more than one consonants after a vowel\n    //      return the\
    \ vowel closest to the first consonant\n    return \"\";\n}\nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkdofvs3h.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x42818d]

    ??:? void tmpkdofvs3h.__unittest_L34_C1() [0x427ad3]

    ??:? void tmpkdofvs3h.__modtest() [0x427f10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42be37]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ad46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fe5d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43030c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fde9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ad1d]

    ??:? runModuleUnitTests [0x42bc0d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4285dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string VOWELS = \"aeiouAEIOU\";\n  \
    \  immutable bool isVowel(dchar c) { return VOWELS.canFind(c); }\n    enum len\
    \ = word.length;\n    for (int i = len - 1; i >= 0; i--)\n    {\n        if (isVowel(word[i]))\n\
    \        {\n            if (i == len - 1 || i == 0) continue;\n            if\
    \ (!isVowel(word[i+1]) && !isVowel(word[i-1]))\n                return word[i];\n\
    \        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj2t91rz7.d(26): Error: `immutable` function `tmpj2t91rz7.get_closest_vowel.isVowel`
    cannot access mutable data `VOWELS`

    /tmp/tmpj2t91rz7.d(27): Error: variable `word` cannot be read at compile time

    /tmp/tmpj2t91rz7.d(34): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj2t91rz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    int\
    \ idx = word.length - 1;\n    bool found = false;\n    while(idx > 0)\n    {\n\
    \        auto ch = word[idx];\n        if(vowels.canFind(ch))\n        {\n   \
    \         if(!vowels.canFind(word[idx + 1]) && \n               !vowels.canFind(word[idx\
    \ - 1]))\n            {\n                found = true;\n                break;\n\
    \            }\n        }\n        idx--;\n    }\n    if(found)\n        return\
    \ ch;\n    else\n        return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz0mfpvbf.d(26): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpz0mfpvbf.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpz0mfpvbf.d(33): Error: no property `canFind` for type `string`

    /tmp/tmpz0mfpvbf.d(34): Error: no property `canFind` for type `string`

    /tmp/tmpz0mfpvbf.d(43): Error: undefined identifier `ch`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz0mfpvbf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowels = \"aeiouAEIOU\";\n    enum\
    \ consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int closest_vowel_idx\
    \ = -1;\n    int distance = -1;\n    int first_vowel_idx = -1;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (consonants.count(word[i]))\n\
    \        {\n            first_vowel_idx = word.findFirstOf(vowels, i);\n     \
    \       if (first_vowel_idx != -1)\n            {\n                auto tmp_distance\
    \ = first_vowel_idx - i;\n                if (distance == -1 || distance > tmp_distance)\n\
    \                {\n                    distance = tmp_distance;\n           \
    \         closest_vowel_idx = first_vowel_idx;\n                }\n          \
    \  }\n        }\n    }\n    if (closest_vowel_idx != -1)\n    {\n        return\
    \ word[closest_vowel_idx..closest_vowel_idx];\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80nuflbf.d(32): Error: no property `count` for type `string`

    /tmp/tmp80nuflbf.d(34): Error: no property `findFirstOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80nuflbf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowels = \"aeiouAEIOU\";\n    int\
    \ vowelDist = -1;\n    char vowel = '\\0';\n    for (int i = 0; i < word.length;\
    \ i++) {\n        if (word[i] in vowels) {\n            if (i == 0 || (i == word.length\
    \ - 1)) {\n                continue;\n            }\n            if (word[i-1]\
    \ in vowels || word[i+1] in vowels) {\n                continue;\n           \
    \ }\n            if (vowelDist == -1 || vowelDist > abs(i - word.length)) {\n\
    \                vowelDist = abs(i - word.length);\n                vowel = word[i];\n\
    \            }\n        }\n    }\n    return vowel ? vowel.toString() : \"\";\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3od1m2qb.d(29): Error: incompatible types for `(word[cast(ulong)i])
    in ("aeiouAEIOU")`: `immutable(char)` and `string`

    /tmp/tmp3od1m2qb.d(33): Error: incompatible types for `(word[cast(ulong)(i - 1)])
    in ("aeiouAEIOU")`: `immutable(char)` and `string`

    /tmp/tmp3od1m2qb.d(33): Error: incompatible types for `(word[cast(ulong)(i + 1)])
    in ("aeiouAEIOU")`: `immutable(char)` and `string`

    /tmp/tmp3od1m2qb.d(37): Error: cannot implicitly convert expression `abs(cast(ulong)i
    - word.length)` of type `ulong` to `int`

    /tmp/tmp3od1m2qb.d(42): Error: no property `toString` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3od1m2qb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int\
    \ index_of_vowel = -1;\n    int index_of_consonant = -1;\n    int index_of_first_consonant\
    \ = -1;\n    int index_of_second_consonant = -1;\n    bool vowels_found = false;\n\
    \    bool consonants_found = false;\n    bool found_vowel_between_consonants =\
    \ false;\n    bool found_two_consonants = false;\n    string result = \"\";\n\
    \    foreach(c; word)\n    {\n        if (vowels.canFind(c))\n        {\n    \
    \        index_of_vowel = indexOf(word, c);\n            if (consonants_found)\n\
    \            {\n                if (index_of_vowel < index_of_second_consonant)\n\
    \                {\n                    found_vowel_between_consonants = true;\n\
    \                    result = c;\n                }\n            }\n         \
    \   vowels_found = true;\n        }\n        else if (consonants.canFind(c))\n\
    \        {\n            index_of_consonant = indexOf(word, c);\n            if\
    \ (vowels_found)\n            {\n                if (index_of_first_consonant\
    \ == -1)\n                {\n                    index_of_first_consonant = index_of_consonant;\n\
    \                }\n                else if (index_of_second_consonant == -1)\n\
    \                {\n                    index_of_second_consonant = index_of_consonant;\n\
    \                    found_two_consonants = true;\n                }\n       \
    \     }\n            consonants_found = true;\n        }\n    }\n    if (found_vowel_between_consonants)\n\
    \    {\n        return result;\n    }\n    else\n    {\n        return \"\";\n\
    \    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8s91mq5i.d(38): Error: no property `canFind` for type `string`

    /tmp/tmp8s91mq5i.d(40): Error: undefined identifier `indexOf`

    /tmp/tmp8s91mq5i.d(46): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp8s91mq5i.d(51): Error: no property `canFind` for type `string`

    /tmp/tmp8s91mq5i.d(53): Error: undefined identifier `indexOf`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8s91mq5i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowels = \"aeiouAEIOU\"\
    ;\n    auto result = \"\";\n    foreach(i, index; word)\n    {\n        if (word[index]\
    \ in vowels)\n        {\n            if (index == 0)\n            {\n        \
    \        result = \"\";\n                break;\n            }\n            if\
    \ (index < word.length - 1)\n            {\n                if (word[index + 1]\
    \ in vowels)\n                {\n                    result = \"\";\n        \
    \            break;\n                }\n                else\n               \
    \ {\n                    result = word[index..$];\n                    break;\n\
    \                }\n            }\n            if (index == word.length - 1)\n\
    \            {\n                result = \"\";\n                break;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk5zwgfem.d(29): Error: incompatible types for `(word[cast(ulong)index])
    in (vowels)`: `immutable(char)` and `string`

    /tmp/tmpk5zwgfem.d(38): Error: incompatible types for `(word[cast(ulong)(cast(int)index
    + 1)]) in (vowels)`: `immutable(char)` and `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk5zwgfem.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string empty = \"\";\n    int vowel_pos = 0;\n    int count = 0;\n    bool\
    \ found_vowel = false;\n    bool non_empty = false;\n    while (count < word.length)\n\
    \    {\n        int pos = word.length - count - 1;\n        if (vowels.find(word[pos])\
    \ == -1)\n        {\n            if (found_vowel)\n            {\n           \
    \     non_empty = true;\n                break;\n            }\n        }\n  \
    \      else\n        {\n            found_vowel = true;\n            vowel_pos\
    \ = pos;\n        }\n        count++;\n    }\n    if (non_empty)\n    {\n    \
    \    return word[vowel_pos..vowel_pos];\n    }\n    else\n    {\n        return\
    \ empty;\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpub0rklmm.d(33): Error: cannot implicitly convert expression `word.length
    - cast(ulong)count - 1LU` of type `ulong` to `int`

    /tmp/tmpub0rklmm.d(34): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpub0rklmm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // loop to check vowel\n    string closest\
    \ = \"\";\n    enum vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    int next_vowel_index\
    \ = -1;\n    foreach(index, letter; word)\n    {\n        // if letter is a vowel\n\
    \        if(vowels.canFind(letter))\n        {\n            // if there is a next\
    \ vowel\n            if(next_vowel_index > -1)\n            {\n              \
    \  // get distance\n                int next_vowel_distance = index - next_vowel_index;\n\
    \                int current_vowel_distance = next_vowel_index - index;\n    \
    \            if(current_vowel_distance < next_vowel_distance)\n              \
    \  {\n                    closest = letter;\n                }\n            }\n\
    \            else\n            {\n                // set next vowel index\n  \
    \              next_vowel_index = index;\n            }\n        }\n    }\n  \
    \  return closest;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphxhlvtcn.d(32): Error: no property `canFind` for type `string[]`

    /tmp/tmphxhlvtcn.d(38): Error: cannot implicitly convert expression `index - cast(ulong)next_vowel_index`
    of type `ulong` to `int`

    /tmp/tmphxhlvtcn.d(39): Error: cannot implicitly convert expression `cast(ulong)next_vowel_index
    - index` of type `ulong` to `int`

    /tmp/tmphxhlvtcn.d(42): Error: cannot implicitly convert expression `letter` of
    type `immutable(char)` to `string`

    /tmp/tmphxhlvtcn.d(48): Error: cannot implicitly convert expression `index` of
    type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphxhlvtcn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    immutable string vowels = \"aeiou\"\
    ;\n    immutable string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    string result\
    \ = \"\";\n    bool lastIsConsonant = false;\n    foreach(i, letter; word.invert)\n\
    \    {\n        if(consonants.find(letter))\n        {\n            if(!lastIsConsonant)\n\
    \            {\n                break;\n            }\n            lastIsConsonant\
    \ = true;\n        }\n        else if(vowels.find(letter))\n        {\n      \
    \      if(lastIsConsonant)\n            {\n                result = letter;\n\
    \                break;\n            }\n            lastIsConsonant = false;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2hbsuu48.d(29): Error: no property `invert` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2hbsuu48.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum {\n        A,\n        E,\n   \
    \     I,\n        O,\n        U,\n        Y,\n        COUNT\n    }\n    int consonant\
    \ = COUNT;\n    int vowel = COUNT;\n    const(char) [] lookup = [\"A\", \"E\"\
    , \"I\", \"O\", \"U\", \"Y\"];\n    for (int i = word.length - 1; i > 0; i--)\
    \ {\n        consonant = vowel;\n        foreach (v; 0 .. COUNT) {\n         \
    \   if (word[i] == lookup[v]) {\n                vowel = v;\n                break;\n\
    \            }\n        }\n        if (consonant != COUNT && vowel != COUNT) {\n\
    \            return lookup[vowel];\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyaasjf04.d(36): Error: cannot implicitly convert expression `["A",
    "E", "I", "O", "U", "Y"]` of type `string[]` to `const(char)[]`

    /tmp/tmpyaasjf04.d(37): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpyaasjf04.d(46): Error: cannot implicitly convert expression `lookup[cast(ulong)vowel]`
    of type `const(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyaasjf04.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowelPos = word.find_last_of(\"\
    aeiouAEIOU\");\n    if (vowelPos != -1) {\n        // we have some vowels at all\n\
    \        if (vowelPos < word.length() - 1) {\n            if (word[vowelPos+1]\
    \ != 'a' &&\n                word[vowelPos+1] != 'e' &&\n                word[vowelPos+1]\
    \ != 'i' &&\n                word[vowelPos+1] != 'o' &&\n                word[vowelPos+1]\
    \ != 'u' &&\n                word[vowelPos+1] != 'A' &&\n                word[vowelPos+1]\
    \ != 'E' &&\n                word[vowelPos+1] != 'I' &&\n                word[vowelPos+1]\
    \ != 'O' &&\n                word[vowelPos+1] != 'U') {\n                // we\
    \ have vowel and consonant after it\n                if (vowelPos > 0) {\n   \
    \                 if (word[vowelPos-1] != 'a' &&\n                        word[vowelPos-1]\
    \ != 'e' &&\n                        word[vowelPos-1] != 'i' &&\n            \
    \            word[vowelPos-1] != 'o' &&\n                        word[vowelPos-1]\
    \ != 'u' &&\n                        word[vowelPos-1] != 'A' &&\n            \
    \            word[vowelPos-1] != 'E' &&\n                        word[vowelPos-1]\
    \ != 'I' &&\n                        word[vowelPos-1] != 'O' &&\n            \
    \            word[vowelPos-1] != 'U') {\n                        // we have vowel\
    \ between two consonants\n                        return word[vowelPos..vowelPos+1];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj5098wgg.d(25): Error: no property `find_last_of` for type `string`

    /tmp/tmpj5098wgg.d(28): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj5098wgg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    uint\
    \ minIndex = uint.max;\n    string minVowel = \"\";\n    // iterate through the\
    \ word and check if it's a consonant\n    foreach(immutable letter; word.length)\n\
    \    {\n        if(!vowels.canFind(letter)) // it's a consonant\n        {\n \
    \           // let's check the previous character (letter - 1)\n            immutable\
    \ previousLetter = word[letter - 1];\n            if(vowels.canFind(previousLetter))\
    \ // we found a vowel, let's check if it's the closest one\n            {\n  \
    \              if(letter - 1 < minIndex)\n                {\n                \
    \    minIndex = letter - 1;\n                    minVowel = previousLetter;\n\
    \                }\n            }\n        }\n    }\n    return minVowel;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int min_index = word.length;\n    string vowel_result = \"\";\n    for (size_t\
    \ i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != string.npos)\n\
    \        {\n            size_t consonant_index = word.rfind(\"qwrtypsdfghjklzxcvbnmQWRTYPSDFGHJKLZXCVBNM\"\
    , i);\n            if (consonant_index == string.npos)\n                continue;\n\
    \            size_t consonant_index2 = word.rfind(\"qwrtypsdfghjklzxcvbnmQWRTYPSDFGHJKLZXCVBNM\"\
    , consonant_index - 1);\n            if (consonant_index2 == string.npos)\n  \
    \              continue;\n            if (min_index > (i - consonant_index2))\n\
    \            {\n                min_index = i - consonant_index2;\n          \
    \      vowel_result = word[i..i+1];\n            }\n        }\n    }\n    return\
    \ vowel_result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6rbjs6cy.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp6rbjs6cy.d(30): Error: no property `find` for type `string`

    /tmp/tmp6rbjs6cy.d(30): Error: no property `npos` for type `string`

    /tmp/tmp6rbjs6cy.d(32): Error: no property `rfind` for type `string`

    /tmp/tmp6rbjs6cy.d(33): Error: no property `npos` for type `string`

    /tmp/tmp6rbjs6cy.d(35): Error: no property `rfind` for type `string`

    /tmp/tmp6rbjs6cy.d(36): Error: no property `npos` for type `string`

    /tmp/tmp6rbjs6cy.d(40): Error: cannot implicitly convert expression `i - consonant_index2`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6rbjs6cy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string cons = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int pos1\
    \ = -1;\n    int pos2 = -1;\n    foreach(immutable int i, immutable char c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            pos1 = i;\n    \
    \        break;\n        }\n    }\n    foreach_reverse(immutable int i, immutable\
    \ char c; word)\n    {\n        if(vowels.canFind(c))\n        {\n           \
    \ pos2 = i;\n            break;\n        }\n    }\n    int pos3 = -1;\n    int\
    \ pos4 = -1;\n    foreach(immutable int i, immutable char c; word)\n    {\n  \
    \      if(cons.canFind(c))\n        {\n            pos3 = i;\n            break;\n\
    \        }\n    }\n    foreach_reverse(immutable int i, immutable char c; word)\n\
    \    {\n        if(cons.canFind(c))\n        {\n            pos4 = i;\n      \
    \      break;\n        }\n    }\n    //writeln(pos1, pos2, pos3, pos4);\n    if(pos3\
    \ == -1 || pos4 == -1) return \"\";\n    if(pos2 == -1) return word[pos1..$];\n\
    \    if(pos1 == -1) return word[pos2..$];\n    if(pos4 - pos3 > pos2 - pos1) return\
    \ word[pos1..$];\n    else return word[pos2..$];\n}\n/*\nFind the largest number\
    \ from a list that is divisible by three.\nIf the list is empty, the largest number\
    \ will be zero (0).\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdfenke9u.d(70): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdfenke9u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    // doesn't count vowels in the beginning or ending\n    if (!consonants.canFind(word[0])\
    \ || !consonants.canFind(word[$-1]))\n        return \"\";\n    \n    string vowels\
    \ = \"aeiouAEIOU\";\n    foreach (i, ch; word[$-1..0])\n    {\n        if (consonants.canFind(ch))\n\
    \        {\n            if (vowels.canFind(word[$-i-1]))\n                return\
    \ word[$-i-1..$-i];\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_f3wfr38.d(27): Error: no property `canFind` for type `string`

    /tmp/tmp_f3wfr38.d(27): Error: no property `canFind` for type `string`

    /tmp/tmp_f3wfr38.d(33): Error: no property `canFind` for type `string`

    /tmp/tmp_f3wfr38.d(35): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_f3wfr38.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    size_t\
    \ index = word.length - 1;\n    int j = 0;\n    while (index > 0)\n    {\n   \
    \     j = 0;\n        while (j < vowels.length)\n        {\n            if (word[index]\
    \ == vowels[j])\n            {\n                if (word[index - 1] != vowels[j]\
    \ && word[index + 1] != vowels[j])\n                {\n                    return\
    \ word[index..$];\n                }\n            }\n            j++;\n      \
    \  }\n        index--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpauoyjvrd.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428325]

    ??:? void tmpauoyjvrd.__unittest_L46_C1() [0x427c6b]

    ??:? void tmpauoyjvrd.__modtest() [0x4280a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c043]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42af52]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430069]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430518]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fff5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42af29]

    ??:? runModuleUnitTests [0x42be19]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int count = 0;\n    bool flag = false;\n    if (word.length == 1) {\n     \
    \   return \"\";\n    } else {\n        for (int i = word.length-1; i >= 0; i--)\
    \ {\n            if (vowels.find(word[i]) != -1) {\n                if (flag)\
    \ {\n                    return word[i..$];\n                }\n             \
    \   count = 0;\n            } else {\n                count++;\n             \
    \   if (count == 2) {\n                    flag = true;\n                }\n \
    \           }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgdn39if5.d(31): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpgdn39if5.d(32): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgdn39if5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    //1.find the first consonant from the\
    \ right side of the word\n    //2.find the first vowel from the right side of\
    \ the word\n    //3.calculate the distance between them\n    //4.return the vowel\n\
    \    string vowel_list = \"aeiou\";\n    string consonant_list = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    int word_length = word.length;\n    string temp_result;\n    string result;\n\
    \    //1.find the first consonant from the right side of the word\n    for (int\
    \ i = word_length - 1; i >= 0; i--)\n    {\n        if (consonant_list.findFirstOf(word[i])\
    \ != -1)\n        {\n            //2.find the first vowel from the right side\
    \ of the word\n            for (int j = i - 1; j >= 0; j--)\n            {\n \
    \               if (vowel_list.findFirstOf(word[j]) != -1)\n                {\n\
    \                    temp_result = word[j];\n                    //3.calculate\
    \ the distance between them\n                    if (result.length == 0)\n   \
    \                 {\n                        result = temp_result;\n         \
    \           }\n                    else if (i - j < word_length - vowel_list.findFirstOf(result))\n\
    \                    {\n                        result = temp_result;\n      \
    \              }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvux1mo_f.d(31): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpvux1mo_f.d(37): Error: no property `findFirstOf` for type `string`

    /tmp/tmpvux1mo_f.d(42): Error: no property `findFirstOf` for type `string`

    /tmp/tmpvux1mo_f.d(44): Error: cannot implicitly convert expression `word[cast(ulong)j]`
    of type `immutable(char)` to `string`

    /tmp/tmpvux1mo_f.d(50): Error: no property `findFirstOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvux1mo_f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowels = ['a', 'e', 'i', 'o', 'u'];\n\
    \    string s = word.dup;\n    char[] res = \"\";\n    while(s.length > 0)\n \
    \   {\n        if(vowels.count(s[$-1]) == 0)\n        {\n            if(vowels.count(s[$-2])\
    \ == 1)\n            {\n                res ~= s[$-2];\n                return\
    \ res.dup;\n            }\n        }\n        s = s[0..$-1];\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7gq13xs6.d(27): Error: cannot implicitly convert expression `""`
    of type `string` to `char[]`

    /tmp/tmp7gq13xs6.d(30): Error: no property `count` for type `char[]`

    /tmp/tmp7gq13xs6.d(32): Error: no property `count` for type `char[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gq13xs6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n\tstring vowels = \"aeiou\";\n\tint min_val\
    \ = int.max;\n\tstring res = \"\";\n\t\n\t// Iterate through the string in reverse\
    \ order\n\tfor (int i = word.length - 1; i >= 0; i--)\n\t{\n\t\t// If the character\
    \ is a vowel, check the previous char\n\t\tif (word[i] in vowels)\n\t\t{\n\t\t\
    \tif (i - 1 >= 0) // Check that i - 1 is inside the string\n\t\t\t{\n\t\t\t\t\
    // If the previous char is not a vowel, then return the vowel\n\t\t\t\tif (word[i\
    \ - 1] !in vowels) return word[i .. $];\n\t\t\t}\n\t\t\t// Otherwise, if the string\
    \ is 1 character long, return the vowel\n\t\t\telse if (word.length == 1) return\
    \ word[i .. $];\n\t\t}\n\t}\n\treturn \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpku3o5gj_.d(30): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpku3o5gj_.d(33): Error: incompatible types for `(word[cast(ulong)i]) in
    (vowels)`: `immutable(char)` and `string`

    /tmp/tmpku3o5gj_.d(38): Error: incompatible types for `(word[cast(ulong)(i - 1)])
    in (vowels)`: `immutable(char)` and `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpku3o5gj_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n  if (word.empty)\n    return \"\";\n  string\
    \ vowels = \"AEIOUaeiou\";\n  size_t word_size = word.length;\n  size_t vowel_index\
    \ = word_size;\n  for (size_t i = word_size - 1; i > 0; i--)\n  {\n    if (vowels.find(word[i])\
    \ != string.npos)\n    {\n      vowel_index = i;\n      break;\n    }\n  }\n \
    \ if (vowel_index == word_size)\n    return \"\";\n  return word[vowel_index];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaet29puy.d(25): Error: no property `empty` for type `string`

    /tmp/tmpaet29puy.d(32): Error: no property `find` for type `string`

    /tmp/tmpaet29puy.d(32): Error: no property `npos` for type `string`

    /tmp/tmpaet29puy.d(40): Error: cannot implicitly convert expression `word[vowel_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaet29puy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n\tauto vowel = \"\";\n\tauto idx = word.length;\n\
    \tauto char_arr = word.dup;\n\t\n\twhile(idx>0)\n\t{\n\t\tauto curr = char_arr[idx-1];\n\
    \t\tidx--;\n\t\tif(!vowel.length)\n\t\t{\n\t\t\tvowel = curr;\n\t\t}\n\t\telse\
    \ if(vowel != curr)\n\t\t{\n\t\t\tauto vowel_idx = vowel.indexOf(\"aeiouAEIOU\"\
    );\n\t\t\tauto curr_idx = vowel.indexOf(\"aeiouAEIOU\");\n\t\t\t\n\t\t\tif(curr_idx\
    \ == -1 && vowel_idx != -1)\n\t\t\t{\n\t\t\t\treturn vowel;\n\t\t\t}\n\t\t\telse\
    \ if(curr_idx != -1 && vowel_idx == -1)\n\t\t\t{\n\t\t\t\treturn curr;\n\t\t\t\
    }\n\t\t\telse if(curr_idx != -1 && vowel_idx != -1)\n\t\t\t{\n\t\t\t\tif(abs(vowel_idx\
    \ - idx) > abs(curr_idx - idx))\n\t\t\t\t{\n\t\t\t\t\treturn curr;\n\t\t\t\t}\n\
    \t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn vowel;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvowel\
    \ = \"\";\n\t\t}\n\t}\n\treturn \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4xubuymi.d(35): Error: cannot implicitly convert expression `curr`
    of type `char` to `string`

    /tmp/tmp4xubuymi.d(37): Error: incompatible types for `(vowel) != (curr)`: `string`
    and `char`

    /tmp/tmp4xubuymi.d(39): Error: no property `indexOf` for type `string`

    /tmp/tmp4xubuymi.d(40): Error: no property `indexOf` for type `string`

    /tmp/tmp4xubuymi.d(48): Error: cannot implicitly convert expression `curr` of
    type `char` to `string`

    /tmp/tmp4xubuymi.d(54): Error: cannot implicitly convert expression `curr` of
    type `char` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xubuymi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  enum bool is_vowel = false;\n    enum bool is_con_previous = false;\n    enum\
    \ bool is_con_current = false;\n    int length = word.length;\n    string closest_vowel\
    \ = \"\";\n    int distance = 100;\n    for (int i = length - 1; i >= 0; i--)\n\
    \    {\n        for (int j = 0; j < vowels.length; j++)\n        {\n         \
    \   if (word[i] == vowels[j])\n            {\n                is_vowel = true;\n\
    \                break;\n            }\n        }\n        if (is_vowel)\n   \
    \     {\n            if (is_con_previous && is_con_current)\n            {\n \
    \               if (distance > (length - i - 1))\n                {\n        \
    \            distance = length - i - 1;\n                    closest_vowel = word[i];\n\
    \                }\n            }\n            is_con_previous = false;\n    \
    \        is_vowel = false;\n        }\n        else\n        {\n            is_con_previous\
    \ = is_con_current;\n            is_con_current = true;\n        }\n    }\n  \
    \  return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj_3g9nhl.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpj_3g9nhl.d(38): Error: cannot modify constant `is_vowel`

    /tmp/tmpj_3g9nhl.d(49): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmpj_3g9nhl.d(52): Error: cannot modify constant `is_con_previous`

    /tmp/tmpj_3g9nhl.d(53): Error: cannot modify constant `is_vowel`

    /tmp/tmpj_3g9nhl.d(57): Error: cannot modify constant `is_con_previous`

    /tmp/tmpj_3g9nhl.d(58): Error: cannot modify constant `is_con_current`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj_3g9nhl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  bool found = false;\n    int location = 0;\n    int closest = 0;\n    int size\
    \ = word.length;\n    for (int i = 0; i < size; i++)\n    {\n        foreach(char\
    \ vowel; vowels)\n        {\n            if (word[i] == vowel)\n            {\n\
    \                if (found == false)\n                {\n                    location\
    \ = i;\n                    found = true;\n                }\n               \
    \ else\n                {\n                    closest = location;\n         \
    \           if (i < closest)\n                    {\n                        return\
    \ word[i..i+1];\n                    }\n                }\n            }\n   \
    \     }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqgg0apkw.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqgg0apkw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto found = word.rfind(\"a\");\n  \
    \  if (found == string.npos)\n        found = word.rfind(\"e\");\n    if (found\
    \ == string.npos)\n        found = word.rfind(\"i\");\n    if (found == string.npos)\n\
    \        found = word.rfind(\"o\");\n    if (found == string.npos)\n        found\
    \ = word.rfind(\"u\");\n    if (found == string.npos)\n        found = word.rfind(\"\
    A\");\n    if (found == string.npos)\n        found = word.rfind(\"E\");\n   \
    \ if (found == string.npos)\n        found = word.rfind(\"I\");\n    if (found\
    \ == string.npos)\n        found = word.rfind(\"O\");\n    if (found == string.npos)\n\
    \        found = word.rfind(\"U\");\n    if (found == string.npos)\n        return\
    \ \"\";\n    if (found == 0)\n        return \"\";\n    else\n    {\n        auto\
    \ found2 = word.rfind(\"a\",found-1);\n        if (found2 == string.npos)\n  \
    \          found2 = word.rfind(\"e\",found-1);\n        if (found2 == string.npos)\n\
    \            found2 = word.rfind(\"i\",found-1);\n        if (found2 == string.npos)\n\
    \            found2 = word.rfind(\"o\",found-1);\n        if (found2 == string.npos)\n\
    \            found2 = word.rfind(\"u\",found-1);\n        if (found2 == string.npos)\n\
    \            found2 = word.rfind(\"A\",found-1);\n        if (found2 == string.npos)\n\
    \            found2 = word.rfind(\"E\",found-1);\n        if (found2 == string.npos)\n\
    \            found2 = word.rfind(\"I\",found-1);\n        if (found2 == string.npos)\n\
    \            found2 = word.rfind(\"O\",found-1);\n        if (found2 == string.npos)\n\
    \            found2 = word.rfind(\"U\",\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_jt1xrwb.d(69): Error: expression expected, not `unittest`

    /tmp/tmp_jt1xrwb.d(70): Error: found `{` when expecting `,`

    /tmp/tmp_jt1xrwb.d(71): Error: expression expected, not `alias`

    /tmp/tmp_jt1xrwb.d(71): Error: found `candidate` when expecting `,`

    /tmp/tmp_jt1xrwb.d(71): Error: expression expected, not `=`

    /tmp/tmp_jt1xrwb.d(71): Error: found `get_closest_vowel` when expecting `,`

    /tmp/tmp_jt1xrwb.d(71): Error: expression expected, not `;`

    /tmp/tmp_jt1xrwb.d(73): Error: found `assert` when expecting `,`

    /tmp/tmp_jt1xrwb.d(73): Error: found `;` when expecting `,`

    /tmp/tmp_jt1xrwb.d(74): Error: found `;` when expecting `,`

    /tmp/tmp_jt1xrwb.d(75): Error: found `;` when expecting `,`

    /tmp/tmp_jt1xrwb.d(76): Error: found `;` when expecting `,`

    /tmp/tmp_jt1xrwb.d(77): Error: found `;` when expecting `,`

    /tmp/tmp_jt1xrwb.d(78): Error: found `;` when expecting `,`

    /tmp/tmp_jt1xrwb.d(79): Error: found `;` when expecting `,`

    /tmp/tmp_jt1xrwb.d(80): Error: found `;` when expecting `,`

    /tmp/tmp_jt1xrwb.d(81): '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string ret;\n    // regex patt = regex(\"\
    ([bcdfghjklmnpqrstvwxyz]+)([aeiou]+)([bcdfghjklmnpqrstvwxyz]+)\", regex.icase);\n\
    \    static auto patt = regex(\"([bcdfghjklmnpqrstvwxyz]+)([aeiou]+)([bcdfghjklmnpqrstvwxyz]+)\"\
    , regex.icase);\n    static auto m = match(\"\");\n    m = patt.match(word);\n\
    \    writeln(m.suffix().length);\n    if (m.suffix().length == word.length)\n\
    \        return \"\";\n    ret = m.suffix().front;\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi1z4ri0z.d(27): Error: undefined identifier `regex`

    /tmp/tmpi1z4ri0z.d(28): Error: undefined identifier `match`

    /tmp/tmpi1z4ri0z.d(30): Error: `writeln` is not defined, perhaps `import std.stdio;`
    is needed?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi1z4ri0z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    size_t vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"].indexOf(word[0].toLowerCase());\n    string vow = vowels == -1\
    \ ? \"\" : word[0].toLowerCase();\n    uint len = word.length;\n    size_t i =\
    \ 1;\n    for (; i < len; i++)\n    {\n        if (word[i].toLowerCase() in [\"\
    a\", \"e\", \"i\", \"o\", \"u\"])\n        {\n            vow = word[i].toLowerCase();\n\
    \            break;\n        }\n    }\n    // ['b', 'c', 'd', 'f', 'g', 'h', 'j',\
    \ 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    for\
    \ (; i < len; i++)\n    {\n        if (word[i].toLowerCase() in [\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"])\n        {\n      \
    \      for (size_t j = i + 1; j < len; j++)\n            {\n                if\
    \ (word[j].toLowerCase() in [\"a\", \"e\", \"i\", \"o\", \"u\"])\n           \
    \     {\n                    if (abs(i - j) < abs(i - word.indexOf(vow)))\n  \
    \                  {\n                        vow = word[j].toLowerCase();\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  return vow;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n \
    \   assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn0j7jw6v.d(25): Error: no property `indexOf` for type `string[]`

    /tmp/tmpn0j7jw6v.d(26): Error: no property `toLowerCase` for type `immutable(char)`

    /tmp/tmpn0j7jw6v.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `uint`

    /tmp/tmpn0j7jw6v.d(31): Error: no property `toLowerCase` for type `immutable(char)`

    /tmp/tmpn0j7jw6v.d(33): Error: no property `toLowerCase` for type `immutable(char)`

    /tmp/tmpn0j7jw6v.d(40): Error: no property `toLowerCase` for type `immutable(char)`

    /tmp/tmpn0j7jw6v.d(44): Error: no property `toLowerCase` for type `immutable(char)`

    /tmp/tmpn0j7jw6v.d(46): Error: no property `indexOf` for type `string`

    /tmp/tmpn0j7jw6v.d(48): Error: no property `toLowerCase` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn0j7jw6v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum aeiou = ['a', 'e', 'i', 'o', 'u'];\n\
    \    int[] vowel_position;\n    foreach(idx, c; word)\n    {\n        if(c in\
    \ aeiou)\n        {\n            vowel_position ~= idx;\n        }\n    }\n  \
    \  if(vowel_position.length > 1)\n    {\n        if(word[vowel_position[$-1]]\
    \ != 'u')\n        {\n            return to!string(word[vowel_position[$-1]]);\n\
    \        }\n        else if(word[vowel_position[$-2]] != 'i')\n        {\n   \
    \         return to!string(word[vowel_position[$-2]]);\n        }\n        else\
    \ if(word[vowel_position[$-3]] != 'o')\n        {\n            return to!string(word[vowel_position[$-3]]);\n\
    \        }\n        else if(word[vowel_position[$-4]] != 'e')\n        {\n   \
    \         return to!string(word[vowel_position[$-4]]);\n        }\n        else\n\
    \        {\n            return to!string(word[vowel_position[$-5]]);\n       \
    \ }\n    }\n    else\n    {\n        return \"\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqmxi556c.d(29): Error: incompatible types for `(c) in ([''a'',
    ''e'', ''i'', ''o'', ''u''])`: `immutable(char)` and `char[]`

    /tmp/tmpqmxi556c.d(31): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpqmxi556c.d(38): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpqmxi556c.d(42): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpqmxi556c.d(46): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpqmxi556c.d(50): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpqmxi556c.d(54): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqmxi556c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    bool c = false;\n    bool v = false;\n\
    \    string v_s = \"\";\n    string v_r = \"\";\n    uint c_p = 0;\n    uint v_p\
    \ = 0;\n    for (uint i = 0; i < word.length; i++)\n    {\n        if (word[i]\
    \ in \"aeiouAEIOU\")\n        {\n            if (c)\n            {\n         \
    \       v = true;\n                if (v_s.length == 0)\n                {\n \
    \                   v_s = word[i..$];\n                    v_p = i;\n        \
    \        }\n                else\n                {\n                    v_r =\
    \ word[i..$];\n                    if (v_r.length < v_s.length)\n            \
    \        {\n                        v_s = v_r;\n                        v_p =\
    \ i;\n                    }\n                }\n            }\n        }\n   \
    \     else\n        {\n            c = true;\n            c_p = i;\n        }\n\
    \    }\n    if (v)\n    {\n        if (c_p - v_p == 1)\n        {\n          \
    \  return v_s[0..1];\n        }\n        else\n        {\n            return v_s[0..0];\n\
    \        }\n    }\n    else\n    {\n        return \"\";\n    }\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpexf4bifn.d(33): Error: incompatible types for `(word[cast(ulong)i])
    in ("aeiouAEIOU")`: `immutable(char)` and `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpexf4bifn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    import std.array : empty;\n    import\
    \ std.regex : regex;\n    import std.algorithm : find;\n    import std.string\
    \ : toStringz;\n    import std.stdio : writeln;\n    import std.math : abs;\n\
    \    import std.range : retro;\n    import std.typecons : tuple;\n    //if (word.empty)\
    \ { return \"\"; }\n    auto vowels = tuple(\"a\", \"e\", \"i\", \"o\", \"u\"\
    , \"A\", \"E\", \"I\", \"O\", \"U\");\n    auto consonants = tuple(\"B\", \"C\"\
    , \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\"\
    , \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"b\", \"c\", \"d\"\
    , \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\");\n    //foreach (char c; word)\n\
    \    //{\n        //if (c in consonants)\n        //{\n            //if (c.next\
    \ in vowels) { return c.next; }\n            //if (c.next in consonants)\n   \
    \         //{\n                //if (c.next.next in vowels) { return c.next.next;\
    \ }\n            //}\n        //}\n    //}\n    //return \"\";\n    auto r = word.retro;\n\
    \    auto c = r.find(x => x in consonants);\n    if (c == word.retro.end) { return\
    \ \"\"; }\n    auto pos = c.save;\n    auto v = word.retro.find(x => x in vowels);\n\
    \    if (v == word.retro.end) { return \"\"; }\n    auto pos_v = v.save;\n   \
    \ if (pos_v > pos) { return word[pos_v].toStringz; }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx2fegqra.d(49): Error: template `std.algorithm.searching.find`
    cannot deduce function from argument types `!()(Result!(), void)`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(1550):        `std.algorithm.searching.find(alias
    pred = "a == b", InputRange, Element)(InputRange haystack, scope Element needle)
    if (isInputRange!InputRange && is(typeof(binaryFun!pred(haystack.front, needle))
    : bool))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(1816):        `std.algorithm.searching.find(alias
    pred, InputRange)(InputRange haystack) if (isInputRange!InputRange)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(1870):        `std.algorithm.searching.find(alias
    pred = "a == b", R1, R2)(R1 haystack, scope R2 needle) if (isForwardRange!R1 &&
    isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front, needle.front)) :
    bool))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(2322):        `std.algorithm.searching.find(alias
    pred = "a == b", Range, Ranges...)(Range haystack, Ranges needles) if (Ranges.length
    > 1 && is(typeof(startsWith!pred(haystack, needles))))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(2437):        `std.algorithm.searching.find(RandomAccessRange,
    alias pred, InputRange)(RandomAccessRange haystack, scope BoyerMooreFinder!(pred,
    InputRange) needle)`

    /tmp/tmpx2fegqra.d(50): Error: no property `end` for type `Result!()`

    /tmp/tmpx2fegqra.d(52): Error: template `std.algorithm.searching.find` can'
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static immutable vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"];\n    static immutable\
    \ vowels_size = vowels.length;\n    static immutable consonants = [\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\", \"B\", \"C\", \"D\"\
    , \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\"\
    , \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    static immutable consonants_size\
    \ = consonants.length;\n    static immutable default_result = \"\";\n    static\
    \ immutable _size = word.length;\n    static immutable result_size = _size * 2\
    \ + 1;\n    static immutable result = new Tuple!(char, result_size)();\n    static\
    \ immutable result_max_index = result_size - 1;\n    static immutable result_min_index\
    \ = 0;\n    static immutable word_max_index = _size - 1;\n    static immutable\
    \ word_min_index = 0;\n    static immutable consonants_max_index = consonants_size\
    \ - 1;\n    static immutable consonants_min_index = 0;\n    static immutable vowels_max_index\
    \ = vowels_size - 1;\n    static immutable vowels_min_index = 0;\n    static immutable\
    \ word_mod_vowels_size = word_max_index % vowels_size;\n    static immutable word_mod_consonants_size\
    \ = word_max_index % consonants_size;\n    static immutable max_index = max(word_mod_vowels_size,\
    \ word_mod_consonants_size);\n    static immutable min_index = min(word_mod_vowels_size,\
    \ word_mod_consonants_size);\n    static immutable result_range = iota(result_min_index,\
    \ result_max_index);\n    static immutable word_\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpirv6t22j.d(47): Error: no identifier for declarator `word_`

    /tmp/tmpirv6t22j.d(47): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpirv6t22j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n  string result;\n  // I would need a better\
    \ way to get the list of vowels\n  string vowels = \"AEIOUaeiou\";\n  for (int\
    \ i = word.length - 1; i >= 0; i--)\n  {\n    if (vowels.find(word[i]) != string.npos)\n\
    \    {\n      if (i > 0 && vowels.find(word[i - 1]) == string.npos)\n      {\n\
    \        result = word[i];\n        break;\n      }\n      else if (i < word.length\
    \ - 1 && vowels.find(word[i + 1]) == string.npos)\n      {\n        result = word[i];\n\
    \        break;\n      }\n    }\n  }\n  return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvnes39w2.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpvnes39w2.d(30): Error: no property `find` for type `string`

    /tmp/tmpvnes39w2.d(30): Error: no property `npos` for type `string`

    /tmp/tmpvnes39w2.d(32): Error: no property `find` for type `string`

    /tmp/tmpvnes39w2.d(32): Error: no property `npos` for type `string`

    /tmp/tmpvnes39w2.d(34): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmpvnes39w2.d(37): Error: no property `find` for type `string`

    /tmp/tmpvnes39w2.d(37): Error: no property `npos` for type `string`

    /tmp/tmpvnes39w2.d(39): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvnes39w2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string result = \"\";\n    string consonants\
    \ = \"bcdfghjklmnpqrstvwxyz\";\n    string::iterator it;\n    bool first_consonant\
    \ = false;\n    bool last_consonant = false;\n    foreach(i, word) {\n       \
    \ if (consonants.find(i) != -1) {\n            first_consonant = true;\n     \
    \       break;\n        }\n    }\n    foreach_reverse(i, word) {\n        if (consonants.find(i)\
    \ != -1) {\n            last_consonant = true;\n            break;\n        }\n\
    \    }\n    if (!first_consonant || !last_consonant) {\n        return result;\n\
    \    }\n    auto vowel_indices = [](string word) {\n        string vowels = \"\
    aeiouAEIOU\";\n        string::iterator it;\n        ulong vowel_index;\n    \
    \    ulong max_word_len = word.length;\n        auto result = new Tuple!(string,\
    \ ulong)(word, max_word_len);\n        foreach(i, word) {\n            if (vowels.find(i)\
    \ != -1) {\n                vowel_index = word.index(i);\n                if (vowel_index\
    \ < result[1]) {\n                    result[0] = i;\n                    result[1]\
    \ = vowel_index;\n                }\n            }\n        }\n        return\
    \ result;\n    };\n    return vowel_indices(word)[0];\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_a5le6nt.d(27): Error: use `.` for member lookup, not `::`

    /tmp/tmp_a5le6nt.d(30): Error: no identifier for declarator `word`

    /tmp/tmp_a5le6nt.d(30): Error: found `)` when expecting `;`

    /tmp/tmp_a5le6nt.d(36): Error: found `foreach_reverse` when expecting `)`

    /tmp/tmp_a5le6nt.d(42): Error: found `if` when expecting `;` following statement

    /tmp/tmp_a5le6nt.d(42): Error: basic type expected, not `!`

    /tmp/tmp_a5le6nt.d(42): Error: found `!` when expecting `)`

    /tmp/tmp_a5le6nt.d(42): Error: missing `{ ... }` for function literal

    /tmp/tmp_a5le6nt.d(42): Error: found `first_consonant` when expecting `;` following
    statement

    /tmp/tmp_a5le6nt.d(42): Error: found `||` instead of statement

    /tmp/tmp_a5le6nt.d(45): Error: found `word` when expecting `,`

    /tmp/tmp_a5le6nt.d(45): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmp_a5le6nt.d(45): Error: declaration expected, not `{`

    /tmp/tmp_a5le6nt.d(47): Error: no identifier for declarator `string`

    /tmp/tmp_a5le6nt.d(47): Error: declaration expect'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    for (int i = word.length-1; i > 0; i--)\n    {\n       \
    \ if (word[i] in vowels)\n        {\n            auto firstcons = true;\n    \
    \        auto secondcons = true;\n            auto index = i;\n            while(firstcons\
    \ && index > 0)\n            {\n                if (word[index-1] in vowels)\n\
    \                {\n                    firstcons = false;\n                }\n\
    \                index--;\n            }\n            auto index2 = i;\n     \
    \       while(secondcons && index2 < word.length-1)\n            {\n         \
    \       if (word[index2+1] in vowels)\n                {\n                   \
    \ secondcons = false;\n                }\n                index2++;\n        \
    \    }\n            if (firstcons && secondcons)\n            {\n            \
    \    result = word[i];\n                break;\n            }\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkt2gmn63.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpkt2gmn63.d(29): Error: incompatible types for `(word[cast(ulong)i]) in
    (vowels)`: `immutable(char)` and `string`

    /tmp/tmpkt2gmn63.d(36): Error: incompatible types for `(word[cast(ulong)(index
    - 1)]) in (vowels)`: `immutable(char)` and `string`

    /tmp/tmpkt2gmn63.d(45): Error: incompatible types for `(word[cast(ulong)(index2
    + 1)]) in (vowels)`: `immutable(char)` and `string`

    /tmp/tmpkt2gmn63.d(53): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkt2gmn63.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowel = \"AEIOU\";\n    string\
    \ consonant = \"BCDFGHJKLMNPQRSTVWXYZ\";\n    string ret = \"\";\n    int distance\
    \ = 0;\n    int dis = 0;\n    foreach(i, ch; word.length)\n    {\n        if(word[word.length\
    \ - i - 1] == 'A' || word[word.length - i - 1] == 'E' \n        || word[word.length\
    \ - i - 1] == 'I' || word[word.length - i - 1] == 'O'\n        || word[word.length\
    \ - i - 1] == 'U')\n        {\n            //std.stdio.writeln(word[word.length\
    \ - i - 1]);\n            distance = i;\n            ret = word[word.length -\
    \ i - 1];\n            break;\n        }\n    }\n    if(ret == \"\")\n       \
    \ return ret;\n    else\n    {\n        dis = distance;\n        foreach(i, ch;\
    \ word.length)\n        {\n            if(word[word.length - i - 1] == 'A' ||\
    \ word[word.length - i - 1] == 'E' \n            || word[word.length - i - 1]\
    \ == 'I' || word[word.length - i - 1] == 'O'\n            || word[word.length\
    \ - i - 1] == 'U')\n            {\n                //std.stdio.writeln(word[word.length\
    \ - i - 1]);\n                distance = i;\n                if(abs(dis - distance)\
    \ == 1)\n                {\n                    //std.stdio.writeln(ret);\n  \
    \                  return ret;\n                }\n                dis = distance;\n\
    \                ret = word[word.length - i - 1];\n            }\n        }\n\
    \    }\n    return ret;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprjf97qwj.d(30): Error: invalid `foreach` aggregate `word.length`

    /tmp/tmprjf97qwj.d(47): Error: invalid `foreach` aggregate `word.length`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjf97qwj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int c_index = -1;\n    int v_index =\
    \ -1;\n    foreach(index, c; word)\n    {\n        c_index = c_index == -1 &&\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ? v_index : c_index;\n\
    \        v_index = c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ?\
    \ index : v_index;\n    }\n    return abs(c_index - v_index) < 2 ? \"\" : word[v_index];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7pgrp1at.d(30): Error: cannot implicitly convert expression `cast(int)c
    == 97 || cast(int)c == 101 || cast(int)c == 105 || cast(int)c == 111 || cast(int)c
    == 117 ? index : cast(ulong)v_index` of type `ulong` to `int`

    /tmp/tmp7pgrp1at.d(32): Error: incompatible types for `("") : (word[cast(ulong)v_index])`:
    `string` and `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7pgrp1at.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n  string vowels = \"aeiouAEIOU\";\n  auto\
    \ indices = indexes(word);\n  reverse(indices);\n  auto vowels_iter = find_if(indices,\n\
    \                             [&word, &vowels](int idx) {\n                  \
    \             return vowels.find(word[idx]) != string.npos;\n                \
    \             });\n  bool vowel_found = vowels_iter != indices.rend;\n  bool is_between_consonants\
    \ = false;\n  if (vowel_found) {\n    is_between_consonants = \n      vowels.find(word[*vowels_iter\
    \ - 1]) == string.npos &&\n      vowels.find(word[*vowels_iter + 1]) == string.npos;\n\
    \  }\n  return vowel_found && is_between_consonants ?\n    word[*vowels_iter..*vowels_iter\
    \ + 1] : \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n \
    \   assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8gicgd56.d(29): Error: found `idx` when expecting `.` following
    int

    /tmp/tmp8gicgd56.d(29): Error: found `)` when expecting identifier following `int`.

    /tmp/tmp8gicgd56.d(29): Error: found `{` when expecting `,`

    /tmp/tmp8gicgd56.d(30): Error: expression expected, not `return`

    /tmp/tmp8gicgd56.d(30): Error: found `vowels` when expecting `,`

    /tmp/tmp8gicgd56.d(30): Error: found `;` when expecting `,`

    /tmp/tmp8gicgd56.d(31): Error: expression expected, not `}`

    /tmp/tmp8gicgd56.d(31): Error: found `;` when expecting `,`

    /tmp/tmp8gicgd56.d(32): Error: found `vowel_found` when expecting `.` following
    bool

    /tmp/tmp8gicgd56.d(32): Error: found `=` when expecting identifier following `bool`.

    /tmp/tmp8gicgd56.d(32): Error: found `vowels_iter` when expecting `,`

    /tmp/tmp8gicgd56.d(32): Error: expression expected, not `!=`

    /tmp/tmp8gicgd56.d(32): Error: found `indices` when expecting `,`

    /tmp/tmp8gicgd56.d(32): Error: found `;` when expecting `,`

    /tmp/tmp8gicgd56.d(33): Error: found `is_between_consonants` when e'
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string[] vowels = { \"a\", \"e\", \"\
    i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\" };\n    string[] consonants\
    \ = { \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\", \"\
    B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"\
    P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\" };\n    int\
    \ c1 = -1;\n    int c2 = -1;\n    foreach(int i, char d; word)\n    {\n      \
    \  c1 = c2;\n        c2 = -1;\n        foreach(string c; consonants)\n       \
    \ {\n            if(c[0] == d)\n            {\n                c2 = i;\n     \
    \           break;\n            }\n        }\n        if(c1 != -1 && c2 != -1)\n\
    \        {\n            foreach(string c; vowels)\n            {\n           \
    \     if(c[0] == d)\n                {\n                    return c;\n      \
    \          }\n            }\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpae18ts36.d(25): Error: a struct is not a valid initializer for
    a `string[]`

    /tmp/tmpae18ts36.d(26): Error: a struct is not a valid initializer for a `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpae18ts36.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowels = \"aeiouAEIOU\";\n    auto\
    \ a = map!(ch => ch in vowels && word[$-1] !in vowels && word[$+1] !in vowels)\n\
    \             (iota(word.length));\n    return a.empty ? \"\" : word[a.front];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ps0ydxp.d(26): Error: template instance `map!((ch) => ch in vowels
    && !(word[__dollar - 1] in vowels) && !(word[__dollar + 1] in vowels))` template
    `map` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ps0ydxp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowel = \"aeiouAEIOU\";\n   \
    \ int cons = 0;\n    for (int i = word.length() - 1; i >= 0; i--)\n    {\n   \
    \     if (vowel.find(word[i]) == -1)\n        {\n            cons++;\n       \
    \ }\n        else if (cons > 1)\n        {\n            return word[i..$];\n \
    \       }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphmijdwkz.d(27): Error: no property `length` for type `string`

    /tmp/tmphmijdwkz.d(29): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphmijdwkz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    auto l = word.length;\n    for (auto i = 1; i <\
    \ l; i++)\n    {\n        //printf(\"%c %c\\n\", word[i-1], word[i]);\n      \
    \  if (vowels.canFind(word[i]))\n        {\n            if (!vowels.canFind(word[i-1]))\n\
    \            {\n                if (i == l-1)\n                {\n           \
    \         result = word[i];\n                    break;\n                }\n \
    \               else if (!vowels.canFind(word[i+1]))\n                {\n    \
    \                result = word[i];\n                    break;\n             \
    \   }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptxjfnwfs.d(31): Error: no property `canFind` for type `string`

    /tmp/tmptxjfnwfs.d(33): Error: no property `canFind` for type `string`

    /tmp/tmptxjfnwfs.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmptxjfnwfs.d(40): Error: no property `canFind` for type `string`

    /tmp/tmptxjfnwfs.d(42): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxjfnwfs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int ai = 0;\n    int bi = 0;\n    int\
    \ a = 0;\n    int b = 0;\n    int i = 0;\n    int distance = 0;\n    int min_distance\
    \ = 0;\n    int min_ai = 0;\n    int min_bi = 0;\n    foreach(c; word) {\n   \
    \     if (c.isVowel)\n        {\n            ai = i;\n            a = 1;\n   \
    \     }\n        else\n        {\n            if (a == 1)\n            {\n   \
    \             bi = i;\n                b = 1;\n            }\n        }\n    \
    \    if (a == 1 && b == 1)\n        {\n            distance = bi - ai;\n     \
    \       if (min_distance == 0 || distance < min_distance)\n            {\n   \
    \             min_distance = distance;\n                min_ai = ai;\n       \
    \         min_bi = bi;\n            }\n            a = 0;\n            b = 0;\n\
    \        }\n        i++;\n    }\n    if (min_distance != 0)\n    {\n        return\
    \ word[min_ai];\n    }\n    else\n    {\n        return \"\";\n    }\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmdcx84r_.d(35): Error: no property `isVowel` for type `immutable(char)`

    /tmp/tmpmdcx84r_.d(64): Error: cannot implicitly convert expression `word[cast(ulong)min_ai]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmdcx84r_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string empty = \"\";\n    int r = word.length\
    \ - 1;\n    int l = 0;\n    string result = \"\";\n    string consts = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string vowels = \"aeiouAEIOU\";\n    for (; l < r; l++) {\n        if (consts.findFirstOf(word[l])\
    \ != string.npos) {\n            break;\n        }\n    }\n    for (; r > l; r--)\
    \ {\n        if (consts.findFirstOf(word[r]) != string.npos) {\n            break;\n\
    \        }\n    }\n    if (l >= r) {\n        return empty;\n    }\n    int best\
    \ = 0;\n    foreach (idx, val; word[l..r]) {\n        if (vowels.findFirstOf(val)\
    \ != string.npos) {\n            if (r - idx < idx - l) {\n                if\
    \ (r - idx > best) {\n                    best = r - idx;\n                  \
    \  result = val;\n                }\n            } else {\n                if\
    \ (idx - l > best) {\n                    best = idx - l;\n                  \
    \  result = val;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg4y2izj7.d(26): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpg4y2izj7.d(32): Error: no property `findFirstOf` for type `string`

    /tmp/tmpg4y2izj7.d(32): Error: no property `npos` for type `string`

    /tmp/tmpg4y2izj7.d(37): Error: no property `findFirstOf` for type `string`

    /tmp/tmpg4y2izj7.d(37): Error: no property `npos` for type `string`

    /tmp/tmpg4y2izj7.d(46): Error: no property `findFirstOf` for type `string`

    /tmp/tmpg4y2izj7.d(46): Error: no property `npos` for type `string`

    /tmp/tmpg4y2izj7.d(49): Error: cannot implicitly convert expression `cast(ulong)r
    - idx` of type `ulong` to `int`

    /tmp/tmpg4y2izj7.d(50): Error: cannot implicitly convert expression `val` of type
    `immutable(char)` to `string`

    /tmp/tmpg4y2izj7.d(54): Error: cannot implicitly convert expression `idx - cast(ulong)l`
    of type `ulong` to `int`

    /tmp/tmpg4y2izj7.d(55): Error: cannot implicitly convert expression `val` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "'
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int start = 0;\n    int stop = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  start = i;\n            break;\n        }\n    }\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            stop = i;\n            break;\n        }\n    }\n    for (int i =\
    \ start; i < stop; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            string left = \"\";\n            string right = \"\";\n  \
    \          if (i == 0)\n            {\n                left = \"\";\n        \
    \    }\n            else\n            {\n                left = word[i - 1];\n\
    \            }\n            if (i == word.length - 1)\n            {\n       \
    \         right = \"\";\n            }\n            else\n            {\n    \
    \            right = word[i + 1];\n            }\n            if (vowels.find(left)\
    \ == -1 && vowels.find(right) == -1)\n            {\n                return word[i];\n\
    \            }\n        }\n    }\n    return \"\";\n}\n/*\n    You are given a\
    \ string.\n    You need to print the lexicographically sorted power-set of the\
    \ string.\n    Note: The string s contains lowercase letter of alphabet.\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm77mbrvc.d(74): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm77mbrvc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // Case sensitive\n    auto v = \"AEIOUaeiou\"\
    ;\n    auto c = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\";\n    int i = word.length-1;\n\
    \    for (; i >= 1; --i) {\n        if (word[i] in v) {\n            if (word[i-1]\
    \ in c) return word[i..$];\n        }\n        else if (word[i] in c) {\n    \
    \        if (word[i-1] in v) return \"\";\n        }\n    }\n    return \"\";\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    int\
    \ len = word.length;\n    int start = 0;\n    int end = len - 1;\n    int start_found\
    \ = 0;\n    int end_found = 0;\n    string result = \"\";\n    for (int i = 0;\
    \ i < len; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n     \
    \       if (word[i] == vowels[j])\n            {\n                start = i;\n\
    \                start_found = 1;\n                break;\n            }\n   \
    \     }\n        if (start_found == 1)\n        {\n            break;\n      \
    \  }\n    }\n    for (int i = len - 1; i >= 0; i--)\n    {\n        for (int j\
    \ = 0; j < 5; j++)\n        {\n            if (word[i] == vowels[j])\n       \
    \     {\n                end = i;\n                end_found = 1;\n          \
    \      break;\n            }\n        }\n        if (end_found == 1)\n       \
    \ {\n            break;\n        }\n    }\n    if (start_found == 0 && end_found\
    \ == 0)\n    {\n        return result;\n    }\n    else if (start_found == 0 &&\
    \ end_found == 1)\n    {\n        for (int i = len - 1; i >= 0; i--)\n       \
    \ {\n            for (int j = 0; j < 5; j++)\n            {\n                if\
    \ (word[i] == vowels[j])\n                {\n                    result = word[i];\n\
    \                    break;\n                }\n            }\n            if\
    \ (result != \"\")\n            {\n                break;\n            }\n   \
    \     }\n    }\n    else if (start_found == 1 && end_found == 0)\n    {\n    \
    \    for (int i = 0; i < len; i++)\n        {\n            for (int j = 0; j <\
    \ 5; j++)\n            {\n                if (word[i] == vowels[j])\n        \
    \        {\n                    result = word[i];\n                    break;\n\
    \                }\n            }\n            if (result != \"\")\n         \
    \  \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0iywsnxg.d(100): Error: found `unittest` instead of statement

    /tmp/tmp0iywsnxg.d(118): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp0iywsnxg.d(118): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0iywsnxg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    auto\
    \ p = find(rbegin(word), rend(word), 'a');\n    if (p != rend(word)) return \"\
    a\";\n    p = find(rbegin(word), rend(word), 'e');\n    if (p != rend(word)) return\
    \ \"e\";\n    p = find(rbegin(word), rend(word), 'i');\n    if (p != rend(word))\
    \ return \"i\";\n    p = find(rbegin(word), rend(word), 'o');\n    if (p != rend(word))\
    \ return \"o\";\n    p = find(rbegin(word), rend(word), 'u');\n    if (p != rend(word))\
    \ return \"u\";\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp389tkbvn.d(26): Error: undefined identifier `find`, did you mean
    template `Bind(alias Template, args1...)`?

    /tmp/tmp389tkbvn.d(27): Error: undefined identifier `rend`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmp389tkbvn.d(29): Error: undefined identifier `rend`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmp389tkbvn.d(31): Error: undefined identifier `rend`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmp389tkbvn.d(33): Error: undefined identifier `rend`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmp389tkbvn.d(35): Error: undefined identifier `rend`, did you mean template
    `Bind(alias Template, args1...)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp389tkbvn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    auto it = find(word.rbegin(), word.rend(), 'a');\n\
    \    if (it != word.rend()) {\n        result = vowels[0];\n    }\n    for (int\
    \ i = 1; i < 10; i++) {\n        auto it = find(word.rbegin(), word.rend(), vowels[i]);\n\
    \        if (it != word.rend()) {\n            result = vowels[i];\n         \
    \   break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpannc0g53.d(27): Error: undefined identifier `find`, did you mean
    template `Bind(alias Template, args1...)`?

    /tmp/tmpannc0g53.d(28): Error: no property `rend` for type `string`

    /tmp/tmpannc0g53.d(29): Error: cannot implicitly convert expression `vowels[0]`
    of type `immutable(char)` to `string`

    /tmp/tmpannc0g53.d(32): Error: undefined identifier `find`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmpannc0g53.d(32): Error: variable `it` is shadowing variable `tmpannc0g53.get_closest_vowel.it`

    /tmp/tmpannc0g53.d(33): Error: no property `rend` for type `string`

    /tmp/tmpannc0g53.d(34): Error: cannot implicitly convert expression `vowels[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpannc0g53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowels = immutable([\"a\", \"e\"\
    , \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]);\n    string result\
    \ = \"\";\n    int distance = 9999;\n    foreach(size_t i, dchar c; word.byChunk)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            if(result.empty\
    \ || (word.length - i) < distance)\n            {\n                result = c;\n\
    \                distance = word.length - i;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwfaihcto.d(25): Error: basic type expected, not `[`

    /tmp/tmpwfaihcto.d(25): Error: found `,` when expecting `]`

    /tmp/tmpwfaihcto.d(25): Error: found `"e"` when expecting `)`

    /tmp/tmpwfaihcto.d(25): Error: `(arguments)` expected following `immutable(_error_["a"])`

    /tmp/tmpwfaihcto.d(25): Error: identifier expected following comma

    /tmp/tmpwfaihcto.d(25): Error: found `]` when expecting `;` following statement

    /tmp/tmpwfaihcto.d(25): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfaihcto.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    enum\
    \ result = \"\";\n    enum n = word.length;\n    enum a = n-1;\n    foreach(inout\
    \ char ch;word)\n    {\n        if(n > 1){\n            if(vowels.find(ch) > -1){\n\
    \                if(word[a-1] != ch){\n                    result = ch;\n    \
    \                a = n-1;\n                }else{\n                    a -= 1;\n\
    \                }\n            }else{\n                a -= 1;\n            }\n\
    \        }\n        n -= 1;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqnfl11ny.d(27): Error: variable `word` cannot be read at compile
    time

    /tmp/tmpqnfl11ny.d(29): Error: variable `tmpqnfl11ny.get_closest_vowel.ch` `inout`
    variables can only be declared inside `inout` functions

    /tmp/tmpqnfl11ny.d(32): Error: no property `find` for type `string`

    /tmp/tmpqnfl11ny.d(34): Error: cannot modify string literal `""`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqnfl11ny.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowel_idx = -1;\n    int i = 0;\n\
    \    for (; i < word.length; i++) {\n        if(!is_vowel(word[i])) {\n      \
    \      break;\n        }\n    }\n    for (; i < word.length; i++) {\n        if(is_vowel(word[i]))\
    \ {\n            vowel_idx = i;\n        } else {\n            break;\n      \
    \  }\n    }\n    if(vowel_idx >= 0) {\n        return word[vowel_idx .. $];\n\
    \    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfu95ut8m.d(28): Error: undefined identifier `is_vowel`

    /tmp/tmpfu95ut8m.d(33): Error: undefined identifier `is_vowel`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfu95ut8m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string closest_vowel;\n    foreach(i,\
    \ char x; word) \n    {\n        if(i == 0 || i == word.length - 1) \n       \
    \ {\n            continue;\n        }\n        if(x.toupper == 'A' || x.toupper\
    \ == 'E' || x.toupper == 'I' || x.toupper == 'O' || x.toupper == 'U') \n     \
    \   {\n            if(x.toupper != word[i-1].toupper && x.toupper != word[i+1].toupper)\
    \ \n            {\n                closest_vowel = x;\n                break;\n\
    \            }\n        }\n    }\n    return closest_vowel;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1_pfw2xv.d(32): Error: no property `toupper` for type `char`

    /tmp/tmp1_pfw2xv.d(32): Error: no property `toupper` for type `char`

    /tmp/tmp1_pfw2xv.d(32): Error: no property `toupper` for type `char`

    /tmp/tmp1_pfw2xv.d(32): Error: no property `toupper` for type `char`

    /tmp/tmp1_pfw2xv.d(32): Error: no property `toupper` for type `char`

    /tmp/tmp1_pfw2xv.d(34): Error: no property `toupper` for type `char`

    /tmp/tmp1_pfw2xv.d(34): Error: no property `toupper` for type `immutable(char)`

    /tmp/tmp1_pfw2xv.d(34): Error: no property `toupper` for type `char`

    /tmp/tmp1_pfw2xv.d(34): Error: no property `toupper` for type `immutable(char)`

    /tmp/tmp1_pfw2xv.d(36): Error: cannot implicitly convert expression `x` of type
    `char` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_pfw2xv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string closest_vowel = \"\";\n    int distance_to_closest_vowel = word.length;\n\
    \    int distance_to_current_vowel = 0;\n    char previous_letter = ' ';\n   \
    \ int previous_letter_index = 0;\n    for (size_t i = 0; i < word.length; i++)\n\
    \    {\n        char current_letter = word[i];\n        if (vowels.findFirstOf(current_letter)\
    \ != -1)\n        {\n            // This is a vowel, is it the closest?\n    \
    \        distance_to_current_vowel = i - previous_letter_index;\n            if\
    \ (distance_to_current_vowel < distance_to_closest_vowel)\n            {\n   \
    \             // This is the closest vowel we have seen so far.\n            \
    \    distance_to_closest_vowel = distance_to_current_vowel;\n                closest_vowel\
    \ = current_letter;\n            }\n        }\n        else\n        {\n     \
    \       // This is a consonant, is it between two other consonants?\n        \
    \    if (previous_letter != ' ')\n            {\n                if (vowels.findFirstOf(previous_letter)\
    \ == -1)\n                {\n                    // We're between two consonants,\
    \ so record the previous letter's index\n                    previous_letter_index\
    \ = i - 1;\n                }\n            }\n        }\n        previous_letter\
    \ = current_letter;\n    }\n    return closest_vowel;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp37d6t8ic.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp37d6t8ic.d(34): Error: no property `findFirstOf` for type `string`

    /tmp/tmp37d6t8ic.d(37): Error: cannot implicitly convert expression `i - cast(ulong)previous_letter_index`
    of type `ulong` to `int`

    /tmp/tmp37d6t8ic.d(42): Error: cannot implicitly convert expression `current_letter`
    of type `char` to `string`

    /tmp/tmp37d6t8ic.d(50): Error: no property `findFirstOf` for type `string`

    /tmp/tmp37d6t8ic.d(53): Error: cannot implicitly convert expression `i - 1LU`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp37d6t8ic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string vowels = \"aeiouAEIOU\";\n    int distance = int.max;\n    int temp_distance\
    \ = 0;\n    string result = \"\";\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (consonants.canFind(word[i]))\n        {\n            temp_distance\
    \ = 0;\n            for (int j = i+1; j < word.length; j++)\n            {\n \
    \               if (vowels.canFind(word[j]))\n                {\n            \
    \        temp_distance = j - i;\n                    if (temp_distance < distance)\n\
    \                    {\n                        distance = temp_distance;\n  \
    \                      result = word[j];\n                    }\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk2uv4ex_.d(32): Error: no property `canFind` for type `string`

    /tmp/tmpk2uv4ex_.d(37): Error: no property `canFind` for type `string`

    /tmp/tmpk2uv4ex_.d(43): Error: cannot implicitly convert expression `word[cast(ulong)j]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk2uv4ex_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowels = \"aeiouAEIOU\"\
    ;\n    bool prev_cons = false;\n    int min_pos = int.max;\n    int min_dist =\
    \ int.max;\n    foreach(i, char c; word)\n    {\n        if(vowels.find(c) !=\
    \ -1)\n        {\n            if(prev_cons)\n            {\n                int\
    \ dist = word.length - i;\n                if(dist < min_dist)\n             \
    \   {\n                    min_dist = dist;\n                    min_pos = i;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      prev_cons = true;\n        }\n    }\n    if(min_pos == int.max)\n     \
    \   return \"\";\n    return word[min_pos..$];\n}\n/*\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpos1fslo8.d(52): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpos1fslo8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164269
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    immutable vowels = \"aeiouAEIOU\";\n\
    \    immutable consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n\
    \    string ans = \"\";\n    bool flag = false;\n    size_t last_consonant = -1;\n\
    \    for (immutable size_t i = 0; i < word.length; i++)\n    {\n        if (consonants.find(word[i])\
    \ != std.string.npos)\n        {\n            if (last_consonant != -1)\n    \
    \        {\n                for (size_t j = last_consonant; j < i; j++)\n    \
    \            {\n                    if (vowels.find(word[j]) != std.string.npos)\n\
    \                    {\n                        if (!flag)\n                 \
    \       {\n                            ans = word[j];\n                      \
    \      flag = true;\n                        }\n                        else\n\
    \                        {\n                            auto tmp = abs(last_consonant\
    \ - j);\n                            if (tmp < abs(last_consonant - j))\n    \
    \                        {\n                                ans = word[j];\n \
    \                           }\n                        }\n                   \
    \ }\n                }\n            }\n            last_consonant = i;\n     \
    \   }\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuues9cmn.d(30): Error: cannot modify `immutable` expression `0LU`

    /tmp/tmpuues9cmn.d(32): Error: no property `find` for type `immutable(string)`

    /tmp/tmpuues9cmn.d(32): Error: undefined identifier `string` in package `std`

    /tmp/tmpuues9cmn.d(38): Error: no property `find` for type `immutable(string)`

    /tmp/tmpuues9cmn.d(38): Error: undefined identifier `string` in package `std`

    /tmp/tmpuues9cmn.d(42): Error: cannot implicitly convert expression `word[j]`
    of type `immutable(char)` to `string`

    /tmp/tmpuues9cmn.d(50): Error: cannot implicitly convert expression `word[j]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuues9cmn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  bool first_vowel = false;\n    int first_vowel_pos = 0;\n    foreach(c; word)\
    \ {\n        if(!first_vowel && vowels.canFind(c)) {\n            first_vowel\
    \ = true;\n            first_vowel_pos = word.length - word.countUntil(c);\n \
    \       } else if(first_vowel && vowels.canFind(c)) {\n            return word[word.length\
    \ - word.countUntil(c)];\n        }\n    }\n    return \"\";\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp27acq5l9.d(29): Error: no property `canFind` for type `string`

    /tmp/tmp27acq5l9.d(31): Error: no property `countUntil` for type `string`

    /tmp/tmp27acq5l9.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp27acq5l9.d(33): Error: no property `countUntil` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27acq5l9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto it = rfind!(a => (a == 'a' || a\
    \ == 'e' || a == 'i' || a == 'o' || a == 'u') && (a - 1 != 'a' || a - 1 != 'e'\
    \ || a - 1 != 'i' || a - 1 != 'o' || a - 1 != 'u'))(word);\n    return it == -1\
    \ ? \"\" : word[it..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpplg9m2a8.d(25): Error: template instance `rfind!((a) => (a == ''a''
    || a == ''e'' || a == ''i'' || a == ''o'' || a == ''u'') && (a - 1 != ''a'' ||
    a - 1 != ''e'' || a - 1 != ''i'' || a - 1 != ''o'' || a - 1 != ''u''))` template
    `rfind` is not defined, did you mean Bind(alias Template, args1...)?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpplg9m2a8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    immutable vowel = \"aeiouAEIOU\";\n\
    \    string res = \"\";\n    auto consonant = true;\n    auto vowel_found = false;\n\
    \    foreach(i, w; word.retro)\n    {\n        if(vowel.canFind(w))\n        {\n\
    \            if(consonant && vowel_found)\n            {\n                res\
    \ = w;\n                break;\n            }\n            vowel_found = true;\n\
    \            consonant = false;\n        }\n        else\n        {\n        \
    \    consonant = true;\n        }\n    }\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwo_jbpeo.d(29): Error: no property `retro` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwo_jbpeo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // write your code here\n    return\
    \ word;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1rba78jc.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x42819d]

    ??:? void tmp1rba78jc.__unittest_L28_C1() [0x427adf]

    ??:? void tmp1rba78jc.__modtest() [0x427f1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42be47]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ad56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fe6d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43031c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fdf9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ad2d]

    ??:? runModuleUnitTests [0x42bc1d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4285ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    auto\
    \ result = Filter!(c => c == ' ')(word);\n    if(result.length < 2) return \"\"\
    ;\n    int idx1 = word.length-1;\n    bool vw_flag = false;\n    foreach(i;idx1..-1)\n\
    \    {\n        if(vowels.canFind(word[i]))\n        {\n            if(!vw_flag)\n\
    \            {\n                vw_flag = true;\n                continue;\n \
    \           }\n            else\n            {\n                idx1 = i;\n  \
    \              break;\n            }\n        }\n        else vw_flag = false;\n\
    \    }\n    if(idx1 == word.length-1) return \"\";\n    int idx2 = idx1-1;\n \
    \   vw_flag = false;\n    foreach(i;idx2..-1)\n    {\n        if(vowels.canFind(word[i]))\n\
    \        {\n            if(!vw_flag)\n            {\n                vw_flag =\
    \ true;\n                continue;\n            }\n            else\n        \
    \    {\n                idx2 = i;\n                break;\n            }\n   \
    \     }\n        else vw_flag = false;\n    }\n    if(idx2 == idx1-1) return \"\
    \";\n    return word[idx1..idx1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnbc72tn_.d(26): Error: template instance `Filter!((c) => c == ''
    '')` template `Filter` is not defined

    /tmp/tmpnbc72tn_.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpnbc72tn_.d(32): Error: no property `canFind` for type `string`

    /tmp/tmpnbc72tn_.d(52): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnbc72tn_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    enum vowels = \"aeiouAEIOU\";\n    string Result;\n    bool IsConsonant\
    \ = false;\n    bool IsVowel = false;\n    bool LastConsonant = false;\n    int\
    \  Distance = int.max;\n    int index = word.length - 1;\n    foreach(int i;0..word.length)\n\
    \    {\n        if(consonants.canFind(word[i]))\n        {\n            IsConsonant\
    \ = true;\n            LastConsonant = true;\n        }\n        else if(vowels.canFind(word[i]))\n\
    \        {\n            IsVowel = true;\n            if(IsConsonant && LastConsonant)\n\
    \            {\n                if(Distance > abs(i - index))\n              \
    \  {\n                    Distance = abs(i - index);\n                    Result\
    \ = word[i];\n                }\n            }\n            LastConsonant = false;\n\
    \        }\n        index--;\n    }\n    return Result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprn_2woir.d(32): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmprn_2woir.d(33): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprn_2woir.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowel = \"aeiou\";\n    tuple!(char,int)[]\
    \ position;\n    foreach(idx,ch;word){\n        if(vowel.canFind(ch)){\n     \
    \       position ~= tuple(ch,idx);\n        }\n    }\n    if(position.length <\
    \ 2) return \"\";\n    int dist = 1e6;\n    int left = 0;\n    int right = position.length\
    \ - 1;\n    while(left < right){\n        int curDist = position[right].$1 - position[left].$1;\n\
    \        if(curDist < dist){\n            dist = curDist;\n        }\n       \
    \ left++;\n        right--;\n    }\n    if(dist == 1e6) return \"\";\n    return\
    \ position[right].$0.toString;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkrons5da.d(37): Error: identifier expected following `.`, not `$`

    /tmp/tmpkrons5da.d(37): Error: semicolon expected, not `1`

    /tmp/tmpkrons5da.d(37): Error: identifier expected following `.`, not `$`

    /tmp/tmpkrons5da.d(37): Error: found `1` when expecting `;` following statement

    /tmp/tmpkrons5da.d(37): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpkrons5da.d(45): Error: identifier expected following `.`, not `$`

    /tmp/tmpkrons5da.d(45): Error: found `0` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkrons5da.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    bool found = false;\n    int index_closest\
    \ = 0;\n    int distance_closest = 0;\n    int index_recent = 0;\n    int distance_recent\
    \ = 0;\n    foreach(i, c; word) {\n        if(c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c\
    \ == 'O' || c == 'U') {\n            if(found) {\n                index_closest\
    \ = index_recent;\n                distance_closest = distance_recent;\n     \
    \           break;\n            }\n            else {\n                index_recent\
    \ = i;\n                distance_recent = 0;\n            }\n        }\n     \
    \   else {\n            found = true;\n            distance_recent++;\n      \
    \  }\n    }\n    if(distance_closest == 0) {\n        return \"\";\n    }\n  \
    \  return std.typecons.Tuple!(string, size_t)(word, index_closest).takeOne().takeOne();\n\
    }\n \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc7a3_44t.d(39): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpc7a3_44t.d(51): Error: no property `takeOne` for type `Tuple!(string,
    ulong)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc7a3_44t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = int.max;\n    int index_of_previous_vowel\
    \ = -1;\n    int index_of_next_vowel = -1;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.indexOf(word[i]) != -1) \n        {\n      \
    \      if (i != 0 && index_of_previous_vowel == -1) \n            {\n        \
    \        if (vowels.indexOf(word[i - 1]) == -1) \n                {\n        \
    \            index_of_previous_vowel = i;\n                }\n            }\n\
    \            if (i != word.length - 1 && index_of_next_vowel == -1) \n       \
    \     {\n                if (vowels.indexOf(word[i + 1]) == -1) \n           \
    \     {\n                    index_of_next_vowel = i;\n                }\n   \
    \         }\n        }\n    }\n    if (index_of_previous_vowel == -1 && index_of_next_vowel\
    \ == -1)\n    {\n        return result;\n    }\n    if (index_of_previous_vowel\
    \ == -1)\n    {\n        return word[index_of_next_vowel..index_of_next_vowel];\n\
    \    }\n    if (index_of_next_vowel == -1)\n    {\n        return word[index_of_previous_vowel..index_of_previous_vowel];\n\
    \    }\n    int distance_of_previous_vowel = abs(word.length - index_of_previous_vowel);\n\
    \    int distance_of_next_vowel = abs(word.length - index_of_next_vowel);\n  \
    \  if (distance_of_previous_vowel < distance_of_next_vowel)\n    {\n        return\
    \ word[index_of_previous_vowel..index_of_pre\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpanlrq8jk.d(67): Error: found `unittest` when expecting `,`

    /tmp/tmpanlrq8jk.d(85): Error: found `void` when expecting `,`

    /tmp/tmpanlrq8jk.d(85): Error: found `{` when expecting `,`

    /tmp/tmpanlrq8jk.d(85): Error: expression expected, not `}`

    /tmp/tmpanlrq8jk.d(85): Error: found `End of File` when expecting `,`

    /tmp/tmpanlrq8jk.d(85): Error: found `End of File` when expecting `]`

    /tmp/tmpanlrq8jk.d(85): Error: found `End of File` when expecting `;` following
    `return` statement

    /tmp/tmpanlrq8jk.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpanlrq8jk.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpanlrq8jk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    //step1: Find the index of the closest\
    \ vowels. \n    int index = 0;\n    int right_con = -1;\n    int right_vowel =\
    \ -1;\n    string vowels = \"aeiou\";\n    foreach(int i, char ch; word) {\n \
    \       if(vowels.find(ch) != -1) {\n            if(right_con != -1) {\n     \
    \           index = i;\n                break;\n            }\n        } else\
    \ {\n            right_con = i;\n        }\n    }\n    //step2: find the character\
    \ from the index.\n    return word[index..$];\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpza03cc0t.d(31): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpza03cc0t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string closestVowel = \"\";\n    int closestIndex = 0;\n    int wordLength\
    \ = word.length;\n    int wordEnd = wordLength - 1;\n    int vowelCount = 0;\n\
    \    int currentCharIndex = 0;\n    int lastVowelIndex = 0;\n    string currentChar\
    \ = \"\";\n    int currentIndex = 0;\n    int vowelIndex = 0;\n    int lastConsonantIndex\
    \ = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int i = 0;\n    //\
    \ Assumes that the input string will only contain a-z and A-Z.\n    for (i = 0;\
    \ i < wordLength; i++)\n    {\n        if (vowels.find(word[i]) >= 0)\n      \
    \  {\n            vowelCount++;\n            lastVowelIndex = i;\n        }\n\
    \    }\n    // If no vowels, return an empty string.\n    if (vowelCount == 0)\n\
    \    {\n        return \"\";\n    }\n    // If only vowels, return the last vowel\
    \ in the string.\n    if (vowelCount == wordLength)\n    {\n        return word[lastVowelIndex];\n\
    \    }\n    // If only one vowel, return the first character.\n    if (vowelCount\
    \ == 1)\n    {\n        return word[0];\n    }\n    // If the last character is\
    \ a vowel, return it.\n    if (vowels.find(word[wordEnd]) >= 0)\n    {\n     \
    \   return word[wordEnd];\n    }\n    // If the first character is a vowel, return\
    \ it.\n    if (vowels.find(word[0]) >= 0)\n    {\n        return word[0];\n  \
    \  }\n    // There are at least two vowels and neither the first nor last character\
    \ is a vowel.\n    // Determine the index of the last consonant.\n    for (j =\
    \ wordEnd; j >= 0; j--)\n    {\n        if (vowels.find(word[j]) < 0)\n      \
    \  {\n            lastConsonantIndex\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe08mi6u1.d(82): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpe08mi6u1.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpe08mi6u1.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpe08mi6u1.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe08mi6u1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto word2 = word.dup;\n    word2.popFront;\n\
    \    if (word2.empty) return \"\";\n    auto word3 = word2.dup;\n    if (word3.empty)\
    \ return \"\";\n    while (!word3.empty)\n    {\n        if (word3.front in 'aeiouAEIOU')\n\
    \        {\n            break;\n        }\n        word3.popFront;\n    }\n  \
    \  if (word3.empty) return \"\";\n    auto word4 = word3.dup;\n    if (word4.empty)\
    \ return \"\";\n    while (!word4.empty)\n    {\n        if (word4.front !in 'aeiouAEIOU')\n\
    \        {\n            break;\n        }\n        word4.popFront;\n    }\n  \
    \  if (word4.empty) return \"\";\n    word4.popFront;\n    if (word4.empty) return\
    \ \"\";\n    word3.popFront;\n    if (word3.empty) return \"\";\n    while (!word3.empty)\n\
    \    {\n        if (word3.front !in 'aeiouAEIOU')\n        {\n            break;\n\
    \        }\n        word3.popFront;\n    }\n    if (word3.empty) return \"\";\n\
    \    auto word5 = word3.dup;\n    word5.popFront;\n    word3.popFront;\n    if\
    \ (word3.empty) return \"\";\n    auto dist1 = distance(word4.front, word3.front);\n\
    \    auto dist2 = distance(word5.front, word3.front);\n    return dist1 < dist2\
    \ ? word4.front : word5.front;\n}\n//struct MyWord {\n//    string word;\n// \
    \   size_t index;\n//    string get_closest_vowel() {\n//        auto word2 =\
    \ word.dup;\n//        word2.popFront;\n//        if (word2.empty) return \"\"\
    ;\n//        auto word3 = word2.dup;\n//        if (word3.empty) return \"\";\n\
    //        while (!word3.empty)\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp75qqix9q.d(32): Error: unterminated character constant

    /tmp/tmp75qqix9q.d(32): Error: found `eiouAEIOU` when expecting `)`

    /tmp/tmp75qqix9q.d(32): Error: unterminated character constant

    /tmp/tmp75qqix9q.d(33): Error: found `{` when expecting `;` following statement

    /tmp/tmp75qqix9q.d(38): Error: declaration expected, not `if`

    /tmp/tmp75qqix9q.d(40): Error: declaration expected, not `if`

    /tmp/tmp75qqix9q.d(41): Error: declaration expected, not `while`

    /tmp/tmp75qqix9q.d(43): Error: unterminated character constant

    /tmp/tmp75qqix9q.d(43): Error: unterminated character constant

    /tmp/tmp75qqix9q.d(46): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp75qqix9q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    int\
    \ n = word.length;\n    if (n <= 1) return \"\";\n    for (int i = n - 1; i >\
    \ 0; i--)\n    {\n        if (vowels.findFirstOf(word[i]) != string.npos &&\n\
    \            vowels.findFirstOf(word[i - 1]) == string.npos)\n        {\n    \
    \        return word[i..$];\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7gjzhogh.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7gjzhogh.d(30): Error: no property `findFirstOf` for type `string`

    /tmp/tmp7gjzhogh.d(30): Error: no property `npos` for type `string`

    /tmp/tmp7gjzhogh.d(31): Error: no property `findFirstOf` for type `string`

    /tmp/tmp7gjzhogh.d(31): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gjzhogh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string vowels = \"aeiouAEIOU\";\n    string ret = \"\";\n    int index\
    \ = -1;\n    if (word.length >= 3) {\n        foreach (i, elem; word) {\n    \
    \        if (elem in consonants) {\n                if (index == -1) {\n     \
    \               index = i;\n                }\n                else {\n      \
    \              if (word[i - 1] in vowels) {\n                        index = i;\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ (index > 0) {\n            ret = word[index - 1];\n        }\n    }\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpooycevqd.d(31): Error: incompatible types for `(elem) in (consonants)`:
    `immutable(char)` and `string`

    /tmp/tmpooycevqd.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpooycevqd.d(36): Error: incompatible types for `(word[i - 1LU]) in (vowels)`:
    `immutable(char)` and `string`

    /tmp/tmpooycevqd.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpooycevqd.d(43): Error: cannot implicitly convert expression `word[cast(ulong)(index
    - 1)]` of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpooycevqd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    if (word.length == 0) return \"\";\n\
    \    string vowels = \"AEIOUaeiou\";\n    string res = \"\";\n    long min_idx\
    \ = word.length;\n    long temp_idx = word.length;\n    long first_idx = word.length;\n\
    \    long second_idx = word.length;\n    for (auto i = 0; i < word.length; i++)\n\
    \    {\n        auto c = word[i];\n        temp_idx = vowels.find(c);\n      \
    \  if (temp_idx != -1)\n        {\n            if (first_idx == word.length)\n\
    \            {\n                first_idx = i;\n            }\n            else\n\
    \            {\n                second_idx = i;\n                min_idx = min(min_idx,\
    \ second_idx - first_idx);\n                first_idx = second_idx;\n        \
    \    }\n        }\n    }\n    if (min_idx == word.length)\n    {\n        return\
    \ \"\";\n    }\n    else\n    {\n        first_idx = word.length;\n        second_idx\
    \ = word.length;\n        for (auto i = 0; i < word.length; i++)\n        {\n\
    \            auto c = word[i];\n            temp_idx = vowels.find(c);\n     \
    \       if (temp_idx != -1)\n            {\n                if (first_idx == word.length)\n\
    \                {\n                    first_idx = i;\n                }\n  \
    \              else\n                {\n                    second_idx = i;\n\
    \                    if (second_idx - first_idx == min_idx)\n                \
    \    {\n                        res = word[second_idx];\n                    \
    \    break;\n                    }\n                    first_idx = second_idx;\n\
    \                }\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9i8emj1g.d(35): Error: no property `find` for type `string`

    /tmp/tmp9i8emj1g.d(45): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp9i8emj1g.d(61): Error: no property `find` for type `string`

    /tmp/tmp9i8emj1g.d(73): Error: cannot implicitly convert expression `word[cast(ulong)second_idx]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9i8emj1g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    for (int i = word.length - 1; i > 0; i--)\n    {\n\
    \        if (word[i] is vowel and word[i - 1] is not vowel)\n        {\n     \
    \       result = word[i];\n            break;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9yrwp2ap.d(29): Error: found `and` when expecting `)`

    /tmp/tmp9yrwp2ap.d(29): Error: found `vowel` when expecting `;` following statement

    /tmp/tmp9yrwp2ap.d(29): Error: found `)` instead of statement

    /tmp/tmp9yrwp2ap.d(35): Error: declaration expected, not `return`

    /tmp/tmp9yrwp2ap.d(36): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9yrwp2ap.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowel = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    auto vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    int\
    \ vowel_index;\n    bool flag = false;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (member(vowels, word[i]))\n        {\n            vowel_index\
    \ = i;\n            flag = true;\n            break;\n        }\n    }\n    if\
    \ (flag)\n    {\n        for (int i = word.length-1; i > vowel_index; i--)\n \
    \       {\n            if (!member(vowels, word[i]))\n            {\n        \
    \        return word[vowel_index..i-1];\n            }\n        }\n    }\n   \
    \ return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n \
    \   assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppt7o_4ux.d(31): Error: undefined identifier `member`

    /tmp/tmppt7o_4ux.d(40): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmppt7o_4ux.d(42): Error: undefined identifier `member`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppt7o_4ux.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowels = [ \"a\", \"e\", \"i\"\
    , \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\" ];\n    auto reversed = word.reversed;\n\
    \    string closest_vowel = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ char vowel; vowels)\n    {\n        if(reversed.canFind(vowel))\n        {\n\
    \            auto dist = word.length - reversed.indexOf(vowel);\n            if(dist\
    \ < min_distance)\n            {\n                min_distance = dist;\n     \
    \           closest_vowel = vowel;\n            }\n        }\n    }\n    return\
    \ closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz5lhed_b.d(26): Error: no property `reversed` for type `string`

    /tmp/tmpz5lhed_b.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpz5lhed_b.d(29): Error: cannot implicitly convert expression `["a", "e",
    "i", "o", "u", "A", "E", "I", "O", "U"]` of type `string[]` to `char[10]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz5lhed_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\";\n    size_t\
    \ i = word.size();\n    size_t j = i;\n    for (; i > 0; --i)\n    {\n       \
    \ if (consonants.find(word[i]) != string.npos)\n        {\n            for (;\
    \ j > i; --j)\n            {\n                if (vowels.find(word[j]) != string.npos)\n\
    \                {\n                    return word[j];\n                }\n \
    \           }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpep7qa3h5.d(27): Error: no property `size` for type `string`

    /tmp/tmpep7qa3h5.d(31): Error: no property `find` for type `string`

    /tmp/tmpep7qa3h5.d(31): Error: no property `npos` for type `string`

    /tmp/tmpep7qa3h5.d(35): Error: no property `find` for type `string`

    /tmp/tmpep7qa3h5.d(35): Error: no property `npos` for type `string`

    /tmp/tmpep7qa3h5.d(37): Error: cannot implicitly convert expression `word[j]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpep7qa3h5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowel = \"aeiou\";\n    string\
    \ result;\n    foreach(element; enumBy(word))\n    {\n        if(element in vowel)\n\
    \        {\n            if(std.algorithm.binarySearch(word, element) != 0)\n \
    \           {\n                if(element != \"a\" || element != \"A\")\n    \
    \            {\n                    if(!(std.algorithm.binarySearch(vowel, word[std.algorithm.binarySearch(word,\
    \ element) - 1]) != -1))\n                    {\n                        result\
    \ = element;\n                        break;\n                    }\n        \
    \        }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2mi1ar1c.d(27): Error: undefined identifier `enumBy`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2mi1ar1c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ right_part = word.split(\"\")[$-1];\n    string left_part = word.split(\"\"\
    )[0];\n    int last_index = word.length - 1;\n    int i = 0;\n    while (i < right_part.length)\
    \ {\n        if (right_part[i] in vowels) {\n            if (right_part[i + 1]\
    \ in \"bcdfghjklmnpqrstvwxyz\" && \n                right_part[i - 1] in \"bcdfghjklmnpqrstvwxyz\"\
    )\n                return right_part[i];\n        }\n        i++;\n    }\n   \
    \ i = 0;\n    while (i < left_part.length) {\n        if (left_part[i] in vowels)\
    \ {\n            if (left_part[i + 1] in \"bcdfghjklmnpqrstvwxyz\" && \n     \
    \           left_part[i - 1] in \"bcdfghjklmnpqrstvwxyz\")\n                return\
    \ left_part[i];\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfeccilw5.d(26): Error: no property `split` for type `string`

    /tmp/tmpfeccilw5.d(27): Error: no property `split` for type `string`

    /tmp/tmpfeccilw5.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpfeccilw5.d(31): Error: incompatible types for `(right_part[cast(ulong)i])
    in (vowels)`: `immutable(char)` and `string`

    /tmp/tmpfeccilw5.d(32): Error: incompatible types for `(right_part[cast(ulong)(i
    + 1)]) in ("bcdfghjklmnpqrstvwxyz")`: `immutable(char)` and `string`

    /tmp/tmpfeccilw5.d(33): Error: incompatible types for `(right_part[cast(ulong)(i
    - 1)]) in ("bcdfghjklmnpqrstvwxyz")`: `immutable(char)` and `string`

    /tmp/tmpfeccilw5.d(40): Error: incompatible types for `(left_part[cast(ulong)i])
    in (vowels)`: `immutable(char)` and `string`

    /tmp/tmpfeccilw5.d(41): Error: incompatible types for `(left_part[cast(ulong)(i
    + 1)]) in ("bcdfghjklmnpqrstvwxyz")`: `immutable(char)` and `string`

    /tmp/tmpfeccilw5.d(42): Error: incompatible types for `(left_part[cast('
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static import std.regex;\n    static\
    \ struct Regexer\n    {\n        Regex rx_a;\n        Regex rx_e;\n        Regex\
    \ rx_i;\n        Regex rx_o;\n        Regex rx_u;\n        Regexer()\n       \
    \ {\n            rx_a = regex(r\"([^aeiou]+)(a)([^aeiou]+)\");\n            rx_e\
    \ = regex(r\"([^aeiou]+)(e)([^aeiou]+)\");\n            rx_i = regex(r\"([^aeiou]+)(i)([^aeiou]+)\"\
    );\n            rx_o = regex(r\"([^aeiou]+)(o)([^aeiou]+)\");\n            rx_u\
    \ = regex(r\"([^aeiou]+)(u)([^aeiou]+)\");\n        }\n    } regexer;\n    auto\
    \ tmp = regexer.rx_a.replace(word, \"\");\n    if (tmp != word)\n        return\
    \ \"a\";\n    tmp = regexer.rx_e.replace(word, \"\");\n    if (tmp != word)\n\
    \        return \"e\";\n    tmp = regexer.rx_i.replace(word, \"\");\n    if (tmp\
    \ != word)\n        return \"i\";\n    tmp = regexer.rx_o.replace(word, \"\");\n\
    \    if (tmp != word)\n        return \"o\";\n    tmp = regexer.rx_u.replace(word,\
    \ \"\");\n    if (tmp != word)\n        return \"u\";\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi8rz0lw4.d(33): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpi8rz0lw4.d(34): Error: no identifier for declarator `Regexer()`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi8rz0lw4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // your code here\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjsgxpyf8.d(23): Error: function `tmpjsgxpyf8.get_closest_vowel`
    has no `return` statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjsgxpyf8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ ans = \"\";\n    int min = 100;\n    // Loop over word\n    foreach(char ch;\
    \ word)\n    {\n        // Check if char is vowel\n        if(vowels.find(ch)\
    \ != -1)\n        {\n            //Loop backwards and check for consonants\n \
    \           for(int i = word.length-1; i >= 0; i--)\n            {\n         \
    \       if(vowels.find(word[i]) == -1)\n                {\n                  \
    \  //If char is consonant and distance is less than min set min to distance\n\
    \                    if(i-word.length+1 < min)\n                    {\n      \
    \                  min = i-word.length+1;\n                        ans = ch;\n\
    \                    }\n                    break;\n                }\n      \
    \      }\n        }\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfhxj4lgn.d(32): Error: no property `find` for type `string`

    /tmp/tmpfhxj4lgn.d(35): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpfhxj4lgn.d(37): Error: no property `find` for type `string`

    /tmp/tmpfhxj4lgn.d(42): Error: cannot implicitly convert expression `cast(ulong)i
    - word.length + 1LU` of type `ulong` to `int`

    /tmp/tmpfhxj4lgn.d(43): Error: cannot implicitly convert expression `ch` of type
    `char` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfhxj4lgn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n  string vowels = \"aeiouAEIOU\";\n  string\
    \ consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n  string right\
    \ = \"\";\n  string left = \"\";\n  int right_idx = word.length;\n  int left_idx\
    \ = word.length;\n  int idx = word.length - 1;\n  while (idx >= 0) {\n    if (right_idx\
    \ == word.length && (vowels.find(word[idx]) != -1)) {\n      right_idx = idx;\n\
    \      right = word[idx];\n    } else if (left_idx == word.length && (consonants.find(word[idx])\
    \ != -1)) {\n      left_idx = idx;\n      left = word[idx];\n    } else if (left_idx\
    \ != word.length && (vowels.find(word[idx]) != -1)) {\n      right_idx = idx;\n\
    \      right = word[idx];\n      break;\n    }\n    idx--;\n  }\n  if (left_idx\
    \ == word.length || right_idx == word.length) {\n    return \"\";\n  }\n  return\
    \ right;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_fzoa0kn.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_fzoa0kn.d(30): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_fzoa0kn.d(31): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp_fzoa0kn.d(33): Error: no property `find` for type `string`

    /tmp/tmp_fzoa0kn.d(35): Error: cannot implicitly convert expression `word[cast(ulong)idx]`
    of type `immutable(char)` to `string`

    /tmp/tmp_fzoa0kn.d(36): Error: no property `find` for type `string`

    /tmp/tmp_fzoa0kn.d(38): Error: cannot implicitly convert expression `word[cast(ulong)idx]`
    of type `immutable(char)` to `string`

    /tmp/tmp_fzoa0kn.d(39): Error: no property `find` for type `string`

    /tmp/tmp_fzoa0kn.d(41): Error: cannot implicitly convert expression `word[cast(ulong)idx]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fzoa0kn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string conso = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    size_t\
    \ i = word.length;\n    size_t j = word.length;\n    string result = \"\";\n \
    \   while(i > 0)\n    {\n        if(conso.find(word[i-1]) != -1)\n        {\n\
    \            if(vowels.find(word[i]) != -1)\n            {\n                result\
    \ = word[i];\n                i--;\n                break;\n            }\n  \
    \          else\n            {\n                i--;\n            }\n        }\n\
    \        else\n        {\n            i--;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9m9vjhey.d(32): Error: no property `find` for type `string`

    /tmp/tmp9m9vjhey.d(34): Error: no property `find` for type `string`

    /tmp/tmp9m9vjhey.d(36): Error: cannot implicitly convert expression `word[i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9m9vjhey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static bool[] is_vowel = new bool[256];\n\
    \    static bool[] is_consonant = new bool[256];\n    is_vowel['a'] = is_vowel['e']\
    \ = is_vowel['i'] = is_vowel['o'] = is_vowel['u'] = is_vowel['A'] = is_vowel['E']\
    \ = is_vowel['I'] = is_vowel['O'] = is_vowel['U'] = true;\n    is_consonant['b']\
    \ = is_consonant['c'] = is_consonant['d'] = is_consonant['f'] = is_consonant['g']\
    \ = is_consonant['h'] = is_consonant['j'] = is_consonant['k'] = is_consonant['l']\
    \ = is_consonant['m'] = is_consonant['n'] = is_consonant['p'] = is_consonant['q']\
    \ = is_consonant['r'] = is_consonant['s'] = is_consonant['t'] = is_consonant['v']\
    \ = is_consonant['w'] = is_consonant['x'] = is_consonant['y'] = is_consonant['z']\
    \ = is_consonant['B'] = is_consonant['C'] = is_consonant['D'] = is_consonant['F']\
    \ = is_consonant['G'] = is_consonant['H'] = is_consonant['J'] = is_consonant['K']\
    \ = is_consonant['L'] = is_consonant['M'] = is_consonant['N'] = is_consonant['P']\
    \ = is_consonant['Q'] = is_consonant['R'] = is_consonant['S'] = is_consonant['T']\
    \ = is_consonant['V'] = is_consonant['W'] = is_consonant['X'] = is_consonant['Y']\
    \ = is_consonant['Z'] = true;\n   \nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd6w3hfhd.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd6w3hfhd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length;\n    if (len < 3)\n        return \"\";\n    string\
    \ ret = \"\";\n    int index = len - 2;\n    while (index > 0)\n    {\n      \
    \  char c = word[index];\n        if (vowels.find(c) != -1)\n        {\n     \
    \       char c1 = word[index-1];\n            char c2 = word[index+1];\n     \
    \       if (vowels.find(c1) == -1 && vowels.find(c2) == -1)\n            {\n \
    \               ret = c;\n                break;\n            }\n        }\n \
    \       index--;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg65bulc7.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpg65bulc7.d(34): Error: no property `find` for type `string`

    /tmp/tmpg65bulc7.d(38): Error: no property `find` for type `string`

    /tmp/tmpg65bulc7.d(38): Error: no property `find` for type `string`

    /tmp/tmpg65bulc7.d(40): Error: cannot implicitly convert expression `c` of type
    `char` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg65bulc7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    int\
    \ n = word.length;\n    if (n < 3) return \"\";\n    int right = n-1;\n    while\
    \ (right > 1 && !vowels.contains(word[right])) {\n        right--;\n    }\n  \
    \  int left = right-1;\n    while (left > 0 && vowels.contains(word[left])) {\n\
    \        left--;\n    }\n    if (vowels.contains(word[left])) return \"\";\n \
    \   return word[right..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa3y3ft5f.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpa3y3ft5f.d(29): Error: no property `contains` for type `string`

    /tmp/tmpa3y3ft5f.d(33): Error: no property `contains` for type `string`

    /tmp/tmpa3y3ft5f.d(36): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa3y3ft5f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string result;\n    foreach(char ch;\
    \ word)\n    {\n        if (ch != ' ')\n        {\n            if (ch != 'a' &&\
    \ ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u' && ch != 'A' && ch != 'E' &&\
    \ ch != 'I' && ch != 'O' && ch != 'U')\n            {\n                result\
    \ ~= ch;\n            }\n        }\n    }\n    if (result.length <= 1)\n    {\n\
    \        return \"\";\n    }\n    else\n    {\n        int length = word.length;\n\
    \        for (int i = 0; i < length; i++)\n        {\n            if (word[length\
    \ - 1 - i] == 'a' || word[length - 1 - i] == 'e' || word[length - 1 - i] == 'i'\
    \ || word[length - 1 - i] == 'o' || word[length - 1 - i] == 'u' || word[length\
    \ - 1 - i] == 'A' || word[length - 1 - i] == 'E' || word[length - 1 - i] == 'I'\
    \ || word[length - 1 - i] == 'O' || word[length - 1 - i] == 'U')\n           \
    \ {\n                return word[length - 1 - i .. length - 1 - i];\n        \
    \    }\n        }\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ahcktb8.d(42): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7ahcktb8.d(23): Error: function `tmp7ahcktb8.get_closest_vowel` no `return
    exp;` or `assert(0);` at end of function

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ahcktb8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum Vowels : string\n    {\n      \
    \  A = \"A\", E = \"E\", I = \"I\", O = \"O\", U = \"U\", Y = \"Y\"\n    }\n \
    \   string[] vowels = [\n        cast(string)Vowels.A,\n        cast(string)Vowels.E,\n\
    \        cast(string)Vowels.I,\n        cast(string)Vowels.O,\n        cast(string)Vowels.U,\n\
    \        cast(string)Vowels.Y\n    ];\n    string vowels_lower = toLowerCase(vowels.join());\n\
    \    // it seems that the default case of switch is needed here\n    foreach(inout\
    \ rch; word[word.length - 1 .. 0])\n    {\n        switch(vowels_lower.canFind(toLowerCase(rch)))\n\
    \        {\n            case true:\n                return rch;\n            case\
    \ false:\n                break;\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsqbjktti.d(37): Error: undefined identifier `toLowerCase`

    /tmp/tmpsqbjktti.d(41): Error: no property `canFind` for type `string`

    /tmp/tmpsqbjktti.d(44): Error: cannot implicitly convert expression `rch` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsqbjktti.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    if (word.length < 2)\n        return result;\n    \n   \
    \ for (int i = word.length - 1; i > 0; i--)\n    {\n        if (vowels.indexOf(word[i])\
    \ != -1)\n        {\n            if (vowels.indexOf(word[i - 1]) == -1)\n    \
    \            return word[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp29qqfss2.d(30): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp29qqfss2.d(32): Error: no property `indexOf` for type `string`

    /tmp/tmp29qqfss2.d(34): Error: no property `indexOf` for type `string`

    /tmp/tmp29qqfss2.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp29qqfss2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    string\
    \ vowels = \"aeiouAEIOU\";\n    string result = \"\";\n    for (int i = len -\
    \ 1; i > 0; i--) {\n        int pos = vowels.find(word[i]);\n        if (pos !=\
    \ -1) {\n            result = word[i];\n            break;\n        }\n    }\n\
    \    if (result == \"\") {\n        return result;\n    }\n    int pos = word.find(result);\n\
    \    while (pos != -1) {\n        int end = pos + 1;\n        int start = pos\
    \ - 1;\n        if (start >= 0 && end < len) {\n            int left = vowels.find(word[start]);\n\
    \            int right = vowels.find(word[end]);\n            if (left == -1 &&\
    \ right == -1) {\n                return result;\n            }\n        }\n \
    \       pos = word.find(result, pos + 1);\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcupb_hdi.d(25): Error: no property `length` for type `string`

    /tmp/tmpcupb_hdi.d(29): Error: no property `find` for type `string`

    /tmp/tmpcupb_hdi.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmpcupb_hdi.d(38): Error: no property `find` for type `string`

    /tmp/tmpcupb_hdi.d(43): Error: no property `find` for type `string`

    /tmp/tmpcupb_hdi.d(44): Error: no property `find` for type `string`

    /tmp/tmpcupb_hdi.d(49): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcupb_hdi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    import std.string;\n    import std.algorithm;\n\
    \    import std.functional;\n    import std.range;\n    import std.array;\n  \
    \  import std.conv;\n    import std.math;\n    import std.typecons;\n    auto\
    \ vowels = \"aouie\".dup;\n    uint ndx = 0;\n    bool found = false;\n    foreach(int\
    \ i; 1..word.length)\n    {\n        if (word[word.length - i] in vowels)\n  \
    \      {\n            ndx = word.length - i;\n            found = true;\n    \
    \        break;\n        }\n    }\n    if (found)\n    {\n        if (ndx == 0)\n\
    \        {\n            return \"\";\n        }\n        else if (ndx == word.length\
    \ - 1)\n        {\n            return \"\";\n        }\n        else if (word[ndx\
    \ - 1] in vowels)\n        {\n            return \"\";\n        }\n        else\
    \ if (word[ndx + 1] in vowels)\n        {\n            return \"\";\n        }\n\
    \        else\n        {\n            return word[ndx..$];\n        }\n    }\n\
    \    else\n    {\n        return \"\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyvoyjh_4.d(36): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpyvoyjh_4.d(55): Error: incompatible types for `(word[cast(ulong)(ndx -
    1u)]) in (vowels)`: `immutable(char)` and `char[]`

    /tmp/tmpyvoyjh_4.d(59): Error: incompatible types for `(word[cast(ulong)(ndx +
    1u)]) in (vowels)`: `immutable(char)` and `char[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyvoyjh_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164271
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n  //  enum vowels = \"AEIOU\";\n \
    \   \n    string vowels = \"AEIOU\";\n    //ssert( word[0] != '');\n    string\
    \ result;\n    for(size_t i = 0; i < word.length; i++)\n    {\n        size_t\
    \ check = vowels.find(word[i]);\n        if(check != string.npos)\n        {\n\
    \            result += word[i];\n        }\n        \n    }\n    \n    \n    \n\
    \    \n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpil4ajyyj.d(33): Error: no property `find` for type `string`

    /tmp/tmpil4ajyyj.d(34): Error: no property `npos` for type `string`

    /tmp/tmpil4ajyyj.d(36): Error: slice `result` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpil4ajyyj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string ret = \"\";\n    int min_distance = 99;\n    int last_index = word.length\
    \ - 1;\n    int rindex = last_index;\n    for (int i = 0; i < last_index; i++)\n\
    \    {\n        if (word[i] in vowels) \n        {\n            for (; rindex\
    \ > i; rindex--)\n            {\n                if (word[rindex] in vowels)\n\
    \                {\n                    break;\n                }\n          \
    \  }\n            if (rindex > i)\n            {\n                if (min_distance\
    \ > rindex - i)\n                {\n                    min_distance = rindex\
    \ - i;\n                    ret = word[i];\n                }\n            }\n\
    \        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjvy4ztcs.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpjvy4ztcs.d(32): Error: incompatible types for `(word[cast(ulong)i]) in
    (vowels)`: `immutable(char)` and `string`

    /tmp/tmpjvy4ztcs.d(36): Error: incompatible types for `(word[cast(ulong)rindex])
    in (vowels)`: `immutable(char)` and `string`

    /tmp/tmpjvy4ztcs.d(46): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjvy4ztcs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ cons = \"bcdfghjklmnpqrstvwxyz\";\n    int ri = word.length - 1;\n    string\
    \ rv = \"\";\n    int length = word.length;\n    if (length < 2)\n    {\n    \
    \    return \"\";\n    }\n    for (int i = length - 1; i >= 0; i--)\n    {\n \
    \       if (vowels.find(word[i]) != -1)\n        {\n            rv = word[i];\n\
    \            ri = i;\n            break;\n        }\n    }\n    if (rv == \"\"\
    )\n    {\n        return \"\";\n    }\n    int p = -1;\n    int n = -1;\n    for\
    \ (int i = ri - 1; i >= 0; i--)\n    {\n        if (cons.find(word[i]) != -1)\n\
    \        {\n            p = i;\n            break;\n        }\n    }\n    for\
    \ (int i = ri + 1; i < length; i++)\n    {\n        if (cons.find(word[i]) !=\
    \ -1)\n        {\n            n = i;\n            break;\n        }\n    }\n \
    \   if (p == -1 && n == -1)\n    {\n        return \"\";\n    }\n    else if (p\
    \ == -1 && n != -1)\n    {\n        return rv;\n    }\n    else if (p != -1 &&\
    \ n == -1)\n    {\n        return rv;\n    }\n    if (n - ri > ri - p)\n    {\n\
    \        return rv;\n    }\n    else\n    {\n        return \"\";\n    }\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg9mnbllg.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpg9mnbllg.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpg9mnbllg.d(36): Error: no property `find` for type `string`

    /tmp/tmpg9mnbllg.d(38): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmpg9mnbllg.d(51): Error: no property `find` for type `string`

    /tmp/tmpg9mnbllg.d(59): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg9mnbllg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    string vowels = \"AEIOUaeiou\"\
    ;\n    int vowel_pos = -1;\n    int max_dist = -1;\n    foreach(i, c; word)\n\
    \    {\n        int v_pos = vowels.find(c);\n        if(v_pos != -1)\n       \
    \ {\n            int dist = i - vowel_pos;\n            if(dist > 1 && (max_dist\
    \ == -1 || dist < max_dist))\n            {\n                max_dist = dist;\n\
    \                vowel_pos = i;\n            }\n        }\n    }\n    return vowel_pos\
    \ == -1 ? \"\" : word[vowel_pos..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpylfrpa4a.d(31): Error: no property `find` for type `string`

    /tmp/tmpylfrpa4a.d(34): Error: cannot implicitly convert expression `i - cast(ulong)vowel_pos`
    of type `ulong` to `int`

    /tmp/tmpylfrpa4a.d(38): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpylfrpa4a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\";\n    string\
    \ output = \"\";\n    immutable int i = 0;\n    immutable int j = 0;\n    immutable\
    \ int index = 0;\n    immutable int ind = 0;\n    immutable int k = 0;\n    immutable\
    \ int diff = 0;\n    immutable int mini = 0;\n    immutable int min = 0;\n   \
    \ immutable int minj = 0;\n    immutable int wlen = word.length;\n    int a[5]\
    \ = void;\n    int b[5] = void;\n    int count = 0;\n    foreach(immutable char\
    \ ch; word)\n    {\n        if(consonants.find(ch) != -1)\n        {\n       \
    \     a[i] = j;\n            i++;\n        }\n        j++;\n    }\n    foreach(immutable\
    \ char ch; word)\n    {\n        if(vowels.find(ch) != -1)\n        {\n      \
    \      b[index] = ind;\n            index++;\n        }\n        ind++;\n    }\n\
    \    if(i < 2) return \"\";\n    else\n    {\n        k = 0;\n        while(k\
    \ < i - 1)\n        {\n            mini = a[k + 1] - a[k];\n            diff =\
    \ mini;\n            count = 0;\n            while(count < index)\n          \
    \  {\n                if(b[count] > a[k] && b[count] < a[k + 1])\n           \
    \     {\n                    mini = a[k + 1] - b[count];\n                   \
    \ if(mini < diff)\n                    {\n                        diff = mini;\n\
    \                        min = b[count];\n                        minj = k;\n\
    \                    }\n                }\n                count++;\n        \
    \    }\n            k++;\n        }\n        count = 0;\n        diff = wlen -\
    \ a[i - 1];\n        mini = wlen - a[i - 1];\n        while(count < index)\n \
    \       {\n            if(b[count] > a[i - 1])\n           \nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxcfejgrx.d(38): Deprecation: instead of C-style syntax, use D-style
    syntax `int[5] a`

    /tmp/tmpxcfejgrx.d(39): Deprecation: instead of C-style syntax, use D-style syntax
    `int[5] b`

    /tmp/tmpxcfejgrx.d(91): Error: found `unittest` instead of statement

    /tmp/tmpxcfejgrx.d(109): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxcfejgrx.d(109): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxcfejgrx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto const vowels = tuple!(\"a\", \"\
    e\", \"i\", \"o\", \"u\")();\n    int cp = word.length - 1;\n    while (cp >=\
    \ 0) {\n        if (vowels.canFind(word[cp])) {\n            return word[cp..cp+1];\n\
    \        }\n        cp--;\n    }\n    return \"\";\n}\n/*\n    #### Problems?\n\
    \    If you have any problems with the above exercise or any other problems with\
    \ your programming \n    comprehension, please post them here: https://goo.gl/forms/Gx6UEL2QNQHTB9XJ3\n\
    */\n//===----------------------------------------------------------------------===//\n\
    /*\n    #### What's Next?\n    - [The prime factor sieve](http://rosettacode.org/wiki/Sieve_of_Eratosthenes#D)\n\
    \    - [Functional tower of Hanoi](http://rosettacode.org/wiki/Towers_of_Hanoi#D)\n\
    \    - [Fizzbuzz](http://rosettacode.org/wiki/FizzBuzz#D)\n    - [Arithmetic expressions](http://rosettacode.org/wiki/Arithmetic_evaluation#D)\n\
    */\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(2003):
    Error: static assert:  "Insufficient number of names given."

    /tmp/tmphkl01ly9.d(25):        instantiated from here: `tuple!()`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkl01ly9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static char[] vowels = {'a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    if (word.length < 3) return \"\";\n\
    \    string result = \"\";\n    int index = 0;\n    int count = 0;\n    int sub\
    \ = int.max;\n    for (int i = word.length - 1; i > 0; i--)\n    {\n        if\
    \ (word[i] in vowels)\n        {\n            if (word[i-1] in vowels) continue;\n\
    \            else\n            {\n                for (int j = i + 1; j < word.length;\
    \ j++)\n                {\n                    if (word[j] in vowels)\n      \
    \              {\n                        count = j - i;\n                   \
    \     if (count < sub)\n                        {\n                          \
    \  sub = count;\n                            index = i;\n                    \
    \    }\n                        break;\n                    }\n              \
    \  }\n            }\n        }\n    }\n    if (sub == int.max) return \"\";\n\
    \    else return word[index..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdf0bmeow.d(25): Error: a struct is not a valid initializer for
    a `char[]`

    /tmp/tmpdf0bmeow.d(31): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpdf0bmeow.d(33): Error: incompatible types for `(word[cast(ulong)i]) in
    (vowels)`: `immutable(char)` and `char[]`

    /tmp/tmpdf0bmeow.d(35): Error: incompatible types for `(word[cast(ulong)(i - 1)])
    in (vowels)`: `immutable(char)` and `char[]`

    /tmp/tmpdf0bmeow.d(40): Error: incompatible types for `(word[cast(ulong)j]) in
    (vowels)`: `immutable(char)` and `char[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdf0bmeow.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    int\
    \ pos = 0;\n    string result = \"\";\n    word = word.chomp(\"a\",\"e\",\"i\"\
    ,\"o\",\"u\");\n    bool isConsonant = true;\n    foreach(c; word.text) {\n  \
    \      if(vowels.find(c) == -1) {\n            if(!isConsonant) {\n          \
    \      int distance = word.length - pos;\n                if(result.length ==\
    \ 0 || distance < distance(result))\n                    result = c;\n       \
    \     }\n            isConsonant = true;\n        } else {\n            isConsonant\
    \ = false;\n        }\n        pos++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9bszu0e4.d(28): Error: no property `chomp` for type `string`

    /tmp/tmp9bszu0e4.d(30): Error: no property `text` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9bszu0e4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // your code here\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjsgxpyf8.d(23): Error: function `tmpjsgxpyf8.get_closest_vowel`
    has no `return` statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjsgxpyf8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int n = word.length;\n    for (int i = n - 1; i > 0; i--)\n    {\n        if\
    \ (vowels.find(word[i]) == -1)\n        {\n            if (vowels.find(word[i\
    \ - 1]) != -1)\n            {\n                return word[i - 1];\n         \
    \   }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdkozdaiy.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpdkozdaiy.d(29): Error: no property `find` for type `string`

    /tmp/tmpdkozdaiy.d(31): Error: no property `find` for type `string`

    /tmp/tmpdkozdaiy.d(33): Error: cannot implicitly convert expression `word[cast(ulong)(i
    - 1)]` of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdkozdaiy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto is_vowel = {'a', 'e', 'i', 'o',\
    \ 'u', 'A', 'E', 'I', 'O', 'U'};\n    immutable vowels = filter!(is_vowel)(word);\n\
    \    immutable previous_vowel = \n        map!(a => a[0])(\n            sort!((a,\
    \ b) => a[1] < b[1])(\n                zip(vowels, map!(i => i + 1)(iota(vowels.length)))));\n\
    \    immutable consonants = \n        filter!(c => !(c in is_vowel))(word);\n\
    \    immutable next_consonant = \n        map!(a => a[0])(\n            sort!((a,\
    \ b) => a[1] < b[1])(\n                zip(consonants, map!(i => i + 1)(iota(consonants.length)))));\n\
    \    if (consonants.length == 0 || vowels.length == 0)\n        return \"\";\n\
    \    for (size_t i = 1; i < consonants.length; i++)\n    {\n        if (consonants[i]\
    \ < previous_vowel[i - 1])\n            return to!string(previous_vowel[i - 1]);\n\
    \    }\n    if (previous_vowel[$ - 1] < next_consonant[0])\n        return to!string(previous_vowel[$\
    \ - 1]);\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph8_5m8ll.d(25): Error: cannot infer type from struct initializer

    /tmp/tmph8_5m8ll.d(26): Error: template instance `filter!is_vowel` template `filter`
    is not defined

    /tmp/tmph8_5m8ll.d(28): Error: template instance `map!((a) => a[0])` template
    `map` is not defined

    /tmp/tmph8_5m8ll.d(32): Error: template instance `filter!((c) => !(c in is_vowel))`
    template `filter` is not defined

    /tmp/tmph8_5m8ll.d(34): Error: template instance `map!((a) => a[0])` template
    `map` is not defined

    /tmp/tmph8_5m8ll.d(42): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmph8_5m8ll.d(45): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph8_5m8ll.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    if (word.length == 0)\n        return result;\n    foreach\
    \ (i, c; (int)word.length - 1 - i) \n    {\n        if (vowels.find(word[i]) !=\
    \ -1) \n        {\n            if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i\
    \ + 1]) == -1) \n            {\n                result = word[i];\n          \
    \      break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_nu_qxjh.d(29): Error: C style cast illegal, use `cast(int)word.length`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_nu_qxjh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string result = \"\";\n    bool is_consonant\
    \ = true;\n    int i = word.length;\n    int closest_pos = 0;\n    int pos = 0;\n\
    \    int j = 0;\n    int k = 0;\n    foreach(ch; word) {\n        switch(ch) {\n\
    \            case 'a':\n            case 'e':\n            case 'i':\n       \
    \     case 'o':\n            case 'u':\n            case 'A':\n            case\
    \ 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n\
    \                if(is_consonant) {\n                    is_consonant = false;\n\
    \                    closest_pos = i;\n                    result = ch;\n    \
    \            }\n                break;\n            default:\n               \
    \ is_consonant = true;\n                break;\n        }\n        i--;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3n5n7g4p.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp3n5n7g4p.d(47): Error: cannot implicitly convert expression `ch` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3n5n7g4p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int position = 0;\n    for (int i =\
    \ 0; i < word.length; i++)\n    {\n        if (word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\n                || word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\n\
    \        {\n            position = i;\n            if (word[position - 1] != 'a'\
    \ && word[position - 1] != 'e' && word[position - 1] != 'i' && word[position -\
    \ 1] != 'o' && word[position - 1] != 'u'\n                    && word[position\
    \ - 1] != 'A' && word[position - 1] != 'E' && word[position - 1] != 'I' && word[position\
    \ - 1] != 'O' && word[position - 1] != 'U'\n                    && word[position\
    \ + 1] != 'a' && word[position + 1] != 'e' && word[position + 1] != 'i' && word[position\
    \ + 1] != 'o' && word[position + 1] != 'u'\n                    && word[position\
    \ + 1] != 'A' && word[position + 1] != 'E' && word[position + 1] != 'I' && word[position\
    \ + 1] != 'O' && word[position + 1] != 'U')\n            {\n                return\
    \ word[position .. position + 1];\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjrew0mp0.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428655]

    ??:? void tmpjrew0mp0.__unittest_L43_C1() [0x427f9b]

    ??:? void tmpjrew0mp0.__modtest() [0x4283d8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c373]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b282]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430399]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430848]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430325]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b259]

    ??:? runModuleUnitTests [0x42c149]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b18]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static immutable string vowels = \"\
    aeiouAEIOU\";\n    static immutable string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    static immutable string special = \".,;:!? -\";\n    int word_length =\
    \ word.length;\n    string result = \"\";\n    int char_index;\n    while (word_length\
    \ > 0) {\n        char_index = word_length - 1;\n        result = word[char_index];\n\
    \        if (consonants.find(result) != -1) {\n            // TARGET CONSONANT\
    \ FOUND\n            break;\n        }\n        if (special.find(result) != -1)\
    \ {\n            // SPECIAL CHARACTER FOUND\n            word_length = char_index;\n\
    \            continue;\n        }\n        // VOWEL FOUND\n        return \"\"\
    ;\n    }\n    // VOWEL CHECK FROM STARTING\n    word_length = char_index;\n  \
    \  char_index = word_length - 1;\n    int vowel_index = 0;\n    int last_vowel_index\
    \ = 0;\n    while (char_index > 0) {\n        result = word[char_index];\n   \
    \     if (vowels.find(result) != -1) {\n            // VOWEL FOUND\n         \
    \   vowel_index = char_index;\n            if (last_vowel_index == 0) {\n    \
    \            last_vowel_index = vowel_index;\n            }\n        }\n     \
    \   if (consonants.find(result) != -1) {\n            // TARGET CONSONANT FOUND\n\
    \            break;\n        }\n        if (special.find(result) != -1) {\n  \
    \          // SPECIAL CHARACTER FOUND\n            vowel_index = 0;\n        }\n\
    \        // MOVING INDEX\n        char_index = char_index - 1;\n    }\n    if\
    \ (vowel_index == 0) {\n        return \"\";\n    }\n    return word[min(vowel_index,\
    \ last_vowel_index)];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvh2lv2jj.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpvh2lv2jj.d(33): Error: cannot implicitly convert expression `word[cast(ulong)char_index]`
    of type `immutable(char)` to `string`

    /tmp/tmpvh2lv2jj.d(34): Error: no property `find` for type `immutable(string)`

    /tmp/tmpvh2lv2jj.d(38): Error: no property `find` for type `immutable(string)`

    /tmp/tmpvh2lv2jj.d(52): Error: cannot implicitly convert expression `word[cast(ulong)char_index]`
    of type `immutable(char)` to `string`

    /tmp/tmpvh2lv2jj.d(53): Error: no property `find` for type `immutable(string)`

    /tmp/tmpvh2lv2jj.d(60): Error: no property `find` for type `immutable(string)`

    /tmp/tmpvh2lv2jj.d(64): Error: no property `find` for type `immutable(string)`

    /tmp/tmpvh2lv2jj.d(74): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvh2lv2jj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  auto i = word.length;\n    int j = 0;\n    foreach(c; word)\n    {\n      \
    \  if(vowels.canFind(c))\n        {\n            j = i;\n        }\n        i--;\n\
    \    }\n    return j < word.length/2 ? \"\" : word[j..j];\n}\n/*\n    ### Tests\n\
    \    auto tests = [[\"yogurt\", \"u\"], [\"FULL\", \"U\"], [\"quick\", \"\"],\
    \ [\"ab\", \"\"]];\n    foreach(test; tests)\n    {\n        assert(get_closest_vowel(test[0])\
    \ == test[1]);\n    }\n*/\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzki4yo09.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpzki4yo09.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzki4yo09.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowel = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    string result;\n    foreach(index, i; reverse(word))\n    {\n\
    \        if(vowel.contains(word[i]))\n        {\n            result = word[i..$];\n\
    \            break;\n        }\n    }\n    if(result.length < 3)\n    {\n    \
    \    return \"\";\n    }\n    return result[0..1];\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa86e_0o8.d(27): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa86e_0o8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    //static string vowels = \"aeiou\";\n\
    \    static string vowels = \"AEIOUaeiou\";\n    //static array vowels = [ 'a',\
    \ 'e', 'i', 'o', 'u' ];\n    string res = \"\";\n    enum is_vowel = false;\n\
    \    int counter = 0;\n    /*\n    string str = \"GoSpotGo\";\n    for (int i\
    \ = 0; i < str.length; i++)\n    {\n        printf(\"%c\\n\", str[i]);\n    }\n\
    \    */\n    /*\n    import std.math;\n    int a = max(1, 2);\n    int b = max(2,\
    \ 3);\n    */\n    //bool a = 1 == 1;\n    //bool b = \"ab\" in \"abcd\";\n  \
    \  //int i = -1;\n    /*\n    int i = 5;\n    --i;\n    ++i;\n    */\n    //string\
    \ u = word[word.length - 1];\n    //int j = word.length - 1;\n    for (int i =\
    \ word.length - 1; i >= 0; --i)\n    {\n        /*\n        printf(\"%c\\n\",\
    \ word[i]);\n        */\n        if (word[i] in vowels)\n        {\n         \
    \   //printf(\"%c\\n\", word[i]);\n            if (is_vowel)\n            {\n\
    \                //\n                break;\n            }\n            else\n\
    \            {\n                res = word[i];\n                is_vowel = true;\n\
    \            }\n        }\n        else\n        {\n            if (is_vowel)\n\
    \            {\n                break;\n            }\n        }\n    }\n    //string\
    \ res = \"\";\n    return res;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_njmb_as.d(53): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp_njmb_as.d(58): Error: incompatible types for `(word[cast(ulong)i]) in
    (vowels)`: `immutable(char)` and `string`

    /tmp/tmp_njmb_as.d(68): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmp_njmb_as.d(69): Error: cannot modify constant `is_vowel`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_njmb_as.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ closest_vowel = \"\";\n    size_t dist = INFINITY;\n    for (size_t i = 1; i\
    \ < word.length(); i++) {\n        if (vowels.indexOf(word[i]) == -1) {\n    \
    \        continue;\n        }\n        if (vowels.indexOf(word[i-1]) == -1) {\n\
    \            if (dist > i) {\n                dist = i;\n                closest_vowel\
    \ = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\
    /*\nThe town judge trusts nobody. Nobody trusts the town judge. There is exactly\
    \ one \nperson that satisfies properties 1 and 2.\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1z9wgsee.d(41): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1z9wgsee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    uint min_distance = uint.max;\n    string\
    \ result = \"\";\n    foreach(i, c; word)\n    {\n        if(c in ['a', 'e', 'i',\
    \ 'o', 'u'])\n        {\n            auto const distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c.to!string;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*\n    You are given an array of integers. The\
    \ array is sorted, but contains gaps of numbers.\n    Find the largest number\
    \ in the array. For example, if you have the array\n    [2, 3, 6, 14, 15, 27,\
    \ 99], the largest number is 99.\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmput4ekosv.d(41): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmput4ekosv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string[]\
    \ consonants_list = split(consonants, \"\");\n    string[] vowels_list = split(vowels,\
    \ \"\");\n    string[] word_list = split(word, \"\");\n    string reversed_word\
    \ = \"\";\n    string temp = \"\";\n    foreach(char item; reverse(word_list))\n\
    \    {\n        reversed_word ~= item;\n    }\n    foreach(string item; consonants_list)\n\
    \    {\n        reversed_word = reversed_word.replace(item, \"\");\n    }\n  \
    \  if(len(reversed_word) == 0)\n    {\n        return \"\";\n    }\n    foreach(string\
    \ item; vowels_list)\n    {\n        reversed_word = reversed_word.replace(item,\
    \ \"\");\n    }\n    if(len(reversed_word) == 0)\n    {\n        return \"\";\n\
    \    }\n    foreach(string item; vowels_list)\n    {\n        temp = reversed_word.replace(item,\
    \ \"\");\n        if(len(temp) < len(reversed_word))\n        {\n            reversed_word\
    \ = temp;\n        }\n    }\n    foreach(char item; reverse(split(reversed_word,\
    \ \"\")))\n    {\n        return item;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6eww1w0t.d(27): Error: undefined identifier `split`

    /tmp/tmp6eww1w0t.d(28): Error: undefined identifier `split`

    /tmp/tmp6eww1w0t.d(29): Error: undefined identifier `split`

    /tmp/tmp6eww1w0t.d(32): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmp6eww1w0t.d(38): Error: no property `replace` for type `string`

    /tmp/tmp6eww1w0t.d(40): Error: undefined identifier `len`

    /tmp/tmp6eww1w0t.d(46): Error: no property `replace` for type `string`

    /tmp/tmp6eww1w0t.d(48): Error: undefined identifier `len`

    /tmp/tmp6eww1w0t.d(54): Error: no property `replace` for type `string`

    /tmp/tmp6eww1w0t.d(55): Error: undefined identifier `len`

    /tmp/tmp6eww1w0t.d(55): Error: undefined identifier `len`

    /tmp/tmp6eww1w0t.d(60): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/'
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    immutable list vowels = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"];\n    string vowel = \"\";\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i..i+1]) && \n      \
    \      vowels.find(word[i-1..i]) &&\n            vowels.find(word[i-2..i-1]))\n\
    \        {\n            vowel = word[i-2..i-1];\n            break;\n        }\n\
    \    }\n    return vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc5jconbc.d(25): Error: undefined identifier `list`

    /tmp/tmpc5jconbc.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc5jconbc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string vowels_str = \"\";\n    bool prevIsVowel = false;\n    auto word_reverse\
    \ = word.dup.reversed;\n    foreach(c; word_reverse)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            vowels_str ~= c;\n            prevIsVowel = true;\n  \
    \      }\n        else\n        {\n            if(prevIsVowel)\n             \
    \   break;\n        }\n    }\n    if(vowels_str.length == 0)\n        return \"\
    \";\n    else\n        return vowels_str.dup.reversed;\n}\n/*\n    You are given\
    \ a word. Your task is to find the closest vowel \n    that stands in the middle\
    \ of two consonants from the right side \n    of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty \n \
    \   string if you didn't find any vowel met the above condition. \nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphbhnys1x.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphbhnys1x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string ret = \"\";\n    uint min_index = 0;\n    uint min_dist = uint.max;\n\
    \    for (uint i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (word.length - i < min_dist)\n           \
    \ {\n                min_dist = word.length - i;\n                min_index =\
    \ i;\n            }\n        }\n    }\n    if (min_dist > 1)\n    {\n        return\
    \ ret;\n    }\n    else\n    {\n        return word[min_index .. min_index];\n\
    \    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkqedphjx.d(31): Error: no property `find` for type `string`

    /tmp/tmpkqedphjx.d(35): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `uint`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkqedphjx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string VOWELS = \"aeiouAEIOU\";\n  \
    \  string CONSONANTS = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ CONSONANTS_WITH_VOWELS = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZaeiouAEIOU\"\
    ;\n    string result = \"\";\n    int con_index = word.length - 1;\n    int closest_index\
    \ = 0;\n    int closest_diff = word.length;\n    int i = 0;\n    while (i < word.length)\n\
    \    {\n        if (CONSONANTS.indexOf(word[i]) != -1)\n        {\n          \
    \  con_index = i;\n            break;\n        }\n        i++;\n    }\n    i =\
    \ con_index;\n    while (i < word.length)\n    {\n        if (VOWELS.indexOf(word[i])\
    \ != -1)\n        {\n            if (closest_diff > i - con_index)\n         \
    \   {\n                closest_diff = i - con_index;\n                closest_index\
    \ = i;\n            }\n        }\n        i++;\n    }\n    if (closest_diff <\
    \ word.length)\n    {\n        result = word[closest_index..closest_index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_pjaf_g.d(29): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpo_pjaf_g.d(31): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpo_pjaf_g.d(35): Error: no property `indexOf` for type `string`

    /tmp/tmpo_pjaf_g.d(45): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_pjaf_g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  size_t length = word.length;\n    size_t j = 0;\n    size_t found = word.length;\n\
    \    size_t i = word.length - 1;\n    for (; i > 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (vowels.find(word[i-1]) == -1)\n         \
    \   {\n                found = i;\n                break;\n            }\n   \
    \     }\n    }\n    return word.length == found ? \"\" : word[found..found];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_544d9zw.d(32): Error: no property `find` for type `string`

    /tmp/tmp_544d9zw.d(34): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_544d9zw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length;\n    string closest = \"\";\n    int index = -1;\n \
    \   for (int i = len - 2; i >= 0; i--)\n    {\n        if (vowels.findFirstOf(word[i])\
    \ != string.npos)\n        {\n            if (vowels.findFirstOf(word[i+1]) ==\
    \ string.npos)\n            {\n                closest = word[i..$];\n       \
    \         index = i;\n                break;\n            }\n        }\n    }\n\
    \    if (index == -1)\n        return \"\";\n    foreach (i;0..index)\n    {\n\
    \        if (vowels.findFirstOf(word[i]) != string.npos)\n        {\n        \
    \    if (vowels.findFirstOf(word[i+1]) == string.npos)\n            {\n      \
    \          if (len - i - 1 < index - i)\n                {\n                 \
    \   index = i;\n                    closest = word[i..$];\n                }\n\
    \            }\n        }\n    }\n    return closest;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1pz0rh9c.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp1pz0rh9c.d(31): Error: no property `findFirstOf` for type `string`

    /tmp/tmp1pz0rh9c.d(31): Error: no property `npos` for type `string`

    /tmp/tmp1pz0rh9c.d(33): Error: no property `findFirstOf` for type `string`

    /tmp/tmp1pz0rh9c.d(33): Error: no property `npos` for type `string`

    /tmp/tmp1pz0rh9c.d(45): Error: no property `findFirstOf` for type `string`

    /tmp/tmp1pz0rh9c.d(45): Error: no property `npos` for type `string`

    /tmp/tmp1pz0rh9c.d(47): Error: no property `findFirstOf` for type `string`

    /tmp/tmp1pz0rh9c.d(47): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1pz0rh9c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOU\";\n    string\
    \ result = \"\";\n    uint minDistance = 0;\n    int idx = 0;\n    foreach(i,\
    \ char ch; word)\n    {\n        idx = vowels.find(ch);\n        if(idx != -1)\n\
    \        {\n            uint d = i;\n            if(minDistance == 0 || d < minDistance)\n\
    \            {\n                result = ch;\n                minDistance = d;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhzu5goc.d(31): Error: no property `find` for type `string`

    /tmp/tmpxhzu5goc.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `uint`

    /tmp/tmpxhzu5goc.d(37): Error: cannot implicitly convert expression `ch` of type
    `char` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhzu5goc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOU\";\n    string\
    \ consonants = \"BCDFGHJKLMNPQRSTVWXYZ\";\n    string retStr = \"\";\n    int\
    \ iVowel = -1;\n    int i = 0;\n    auto letter = word[i];\n    auto it = 0;\n\
    \    auto secondConsonant = 0;\n    while (it != '\\0')\n    {\n        if (consonants.find(word[i])\
    \ != -1)\n        {\n            secondConsonant = i;\n            break;\n  \
    \      }\n        it++;\n    }\n    for (int i = secondConsonant - 1; i > 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            iVowel\
    \ = i;\n            break;\n        }\n    }\n    if (iVowel != -1)\n    {\n \
    \       retStr = word[iVowel];\n    }\n    return retStr;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjj007m34.d(35): Error: no property `find` for type `string`

    /tmp/tmpjj007m34.d(42): Error: variable `i` is shadowing variable `tmpjj007m34.get_closest_vowel.i`

    /tmp/tmpjj007m34.d(44): Error: no property `find` for type `string`

    /tmp/tmpjj007m34.d(52): Error: cannot implicitly convert expression `word[cast(ulong)iVowel]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjj007m34.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string result = \"\";\n    string temp\
    \ = word.dup.uppercase;\n    size_t wordLen = word.length;\n    size_t i = wordLen\
    \ - 1;\n    bool findFirstConsonant = false;\n    bool findSecondConsonant = false;\n\
    \    while (i != size_t.max)\n    {\n        if (temp[i] == 'A' || temp[i] ==\
    \ 'E' || temp[i] == 'I' || temp[i] == 'O' || temp[i] == 'U')\n        {\n    \
    \        if (findFirstConsonant && !findSecondConsonant)\n            {\n    \
    \            result = word[i..$];\n                break;\n            }\n   \
    \         findFirstConsonant = false;\n            findSecondConsonant = false;\n\
    \        }\n        else\n        {\n            if (!findFirstConsonant)\n  \
    \          {\n                findFirstConsonant = true;\n            }\n    \
    \        else if (findFirstConsonant && !findSecondConsonant)\n            {\n\
    \                findSecondConsonant = true;\n            }\n        }\n     \
    \   i--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm21p37zy.d(26): Error: no property `uppercase` for type `char[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm21p37zy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum vowel = \"aeiouAEIOU\";\n    int\
    \ i = word.length;\n    while(--i >= 0)\n    {\n        if(word[i] in vowel)\n\
    \        {\n            if(i > 0 && word[i-1] not in vowel)\n                return\
    \ word[i..$];\n            else if(i < word.length-1 && word[i+1] not in vowel)\n\
    \                return word[i..$];\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvocpevys.d(31): Error: found `not` when expecting `)`

    /tmp/tmpvocpevys.d(31): Error: found `in` instead of statement

    /tmp/tmpvocpevys.d(33): Error: found `not` when expecting `)`

    /tmp/tmpvocpevys.d(33): Error: found `in` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvocpevys.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    import std.algorithm : map, filter,\
    \ find;\n    import std.range : each;\n    import std.conv : to;\n    import std.string\
    \ : join;\n    import std.array : array;\n    import std.typecons : tuple;\n \
    \   import std.math : min;\n    import std.range : take, takeUntil;\n    import\
    \ std.algorithm : cartesianProduct;\n    import std.datetime : Clock;\n    import\
    \ std.typecons : tuple;\n    import std.range : zip;\n    import std.typecons\
    \ : Flag;\n    import std.typecons : Tuple;\n    import std.range : cycle;\n \
    \   import std.algorithm : find, findSplit;\n    import std.range : iota;\n  \
    \  import std.string : toUpper, toLower;\n    import std.regex : split;\n    import\
    \ std.conv : to;\n    import std.array : array;\n    import std.range : only;\n\
    \    import std.algorithm : count;\n    import std.algorithm : each;\n    import\
    \ std.math : min;\n    import std.array : sort;\n    import std.algorithm : map;\n\
    \    import std.algorithm : max;\n    import std.range : zip;\n    import std.algorithm\
    \ : find, findSplit;\n    import std.range : iota;\n    import std.string : toUpper,\
    \ toLower;\n    import std.regex : split;\n    import std.typecons : tuple;\n\
    \    import std.range : take, takeUntil;\n    import std.algorithm : cartesianProduct;\n\
    \    import std.datetime : Clock;\n    import std.typecons : tuple;\n    import\
    \ std.range : zip;\n    import std.typecons : Flag;\n    import std.typecons :\
    \ Tuple;\n    import std.range : cycle;\n    import std.algorithm : count;\n \
    \   import std.array : only;\n    import std.math : min;\n    import std.array\
    \ : sort;\n    import std.algorithm : map;\n    import std.algorithm : max;\n\
    \    import std.range : zip;\n    import std.algorithm : find, find\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnuzdwrhg.d(75): Error: `;` expected

    /tmp/tmpnuzdwrhg.d(93): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnuzdwrhg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels=\"aeiouAEIOU\";\n    string\
    \ consonants=\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    size_t pos=-1;\n\
    \    for(size_t i=0;i<word.length();i++)\n    {\n        if(consonants.find(word[i])!=string::npos)\n\
    \        {\n            pos=i;\n            break;\n        }\n    }\n    size_t\
    \ w_pos=word.length()-1;\n    while(pos!=word.length()-1)\n    {\n        if(vowels.find(word[w_pos])!=string::npos)\n\
    \        {\n            for(size_t i=w_pos;i>=pos;i--)\n            {\n      \
    \          if(consonants.find(word[i])!=string::npos)\n                {\n   \
    \                 return word[w_pos];\n                }\n            }\n    \
    \    }\n        w_pos--;\n    }\n    return \"\";\n}\n/*\nImplement function that\
    \ returns the reverse of the given string.\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyz44ypvl.d(30): Error: found `:` when expecting `)`

    /tmp/tmpyz44ypvl.d(30): Error: found `:` instead of statement

    /tmp/tmpyz44ypvl.d(37): Error: declaration expected, not `while`

    /tmp/tmpyz44ypvl.d(41): Error: no identifier for declarator `i`

    /tmp/tmpyz44ypvl.d(41): Error: declaration expected, not `>=`

    /tmp/tmpyz44ypvl.d(41): Error: no identifier for declarator `i`

    /tmp/tmpyz44ypvl.d(41): Error: declaration expected, not `--`

    /tmp/tmpyz44ypvl.d(46): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyz44ypvl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    \n    string ret;\n    int len_chk=word.length;\n\
    \    int len_vowel=0;\n    string closest_vowel;\n    int len=0;\n    int idx=0;\n\
    \    int[] vowel_idx =[];\n    int[] con_idx =[];\n    bool vowel_idx_chk=false;\n\
    \    bool vowel_idx_chk2=false;\n    bool vowel_idx_chk3=false;\n    bool con_idx_chk=false;\n\
    \    bool con_idx_chk2=false;\n    bool con_idx_chk3=false;\n    if(len_chk>=2)\n\
    \    {\n        while(idx<len_chk)\n        {\n            if(word[idx]=='a'||word[idx]=='e'||word[idx]=='i'||word[idx]=='o'||word[idx]=='u'||word[idx]=='A'||word[idx]=='E'||word[idx]=='I'||word[idx]=='O'||word[idx]=='U')\n\
    \            {\n                vowel_idx_chk3=true;\n                vowel_idx~=idx;\n\
    \                vowel_idx_chk=true;\n            }\n            else\n      \
    \      {\n                vowel_idx_chk=false;\n            }\n            if(vowel_idx_chk==false&&vowel_idx_chk3==true)\n\
    \            {\n                con_idx~=idx;\n                con_idx_chk=true;\n\
    \            }\n            else\n            {\n                con_idx_chk=false;\n\
    \            }\n            idx++;\n        }\n        idx=0;\n        while(idx<vowel_idx.length)\n\
    \        {\n            if(vowel_idx[idx]==0||vowel_idx[idx]==len_chk-1)\n   \
    \         {\n                vowel\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa4kkrig6.d(72): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpa4kkrig6.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpa4kkrig6.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpa4kkrig6.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpa4kkrig6.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa4kkrig6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int count = 0;\n    int diff\
    \ = 0;\n    int diff_value = 0;\n    int diff_value_min = 5000;\n    while (count\
    \ < word.length-1)\n    {\n        index = 0;\n        while (index < vowels.length)\n\
    \        {\n            if (word[count] == vowels[index])\n            {\n   \
    \             index = vowels.length;\n                count++;\n            }\n\
    \            else\n            {\n                index++;\n            }\n  \
    \      }\n        if (index == vowels.length)\n        {\n            index =\
    \ 0;\n            while (index < vowels.length)\n            {\n             \
    \   if (word[count+1] == vowels[index])\n                {\n                 \
    \   diff = abs(count - count+1);\n                    if (diff <= diff_value_min)\n\
    \                    {\n                        diff_value_min = diff;\n     \
    \                   diff_value = count+1;\n                    }\n           \
    \         index = vowels.length;\n                }\n                else\n  \
    \              {\n                    index++;\n                }\n          \
    \  }\n            count++;\n        }\n    }\n    if (diff_value_min != 5000)\n\
    \    {\n        result = word[diff_value];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwfpdl58u.d(39): Error: cannot implicitly convert expression `vowels.length`
    of type `ulong` to `int`

    /tmp/tmpwfpdl58u.d(60): Error: cannot implicitly convert expression `vowels.length`
    of type `ulong` to `int`

    /tmp/tmpwfpdl58u.d(72): Error: cannot implicitly convert expression `word[cast(ulong)diff_value]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfpdl58u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    bool found_consonant = false;\n    int\
    \ pos = word.length;\n    while (pos--) {\n        if (!isVowel(word[pos])) {\n\
    \            found_consonant = true;\n        } else if (found_consonant) {\n\
    \            return string(word[pos]);\n        }\n    }\n    return \"\";\n}\n\
    /*\ntuple(string, int, bool) get_closest_vowel2(string word) \n{\n    bool found_consonant\
    \ = false;\n    int pos = word.length;\n    while (pos--) {\n        if (!isVowel(word[pos]))\
    \ {\n            found_consonant = true;\n        } else if (found_consonant)\
    \ {\n            //return tuple(string(word[pos]), pos, true);\n            return\
    \ tuple(string(word[pos]), pos, false);\n        }\n    }\n    return tuple(\"\
    \", 0, false);\n}\n*/\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeg58qzqt.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpeg58qzqt.d(28): Error: undefined identifier `isVowel`

    /tmp/tmpeg58qzqt.d(31): Error: function expected before `()`, not `string` of
    type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeg58qzqt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string result;\n    immutable vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"];\n\
    \    immutable consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\",\
    \ \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\", \"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\"\
    , \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\"\
    , \"Y\", \"Z\"];\n    immutable word_len = word.length;\n    if (word_len > 1)\n\
    \    {\n        immutable consonant_positions = [];\n        immutable vowel_positions\
    \ = [];\n        foreach (immutable i, immutable letter; word)\n        {\n  \
    \          if (consonants.find(letter) != -1)\n            {\n               \
    \ consonant_positions ~= i;\n            }\n            else if (vowels.find(letter)\
    \ != -1)\n            {\n                vowel_positions ~= i;\n            }\n\
    \        }\n        immutable current_pos = 0;\n        immutable current_possibility\
    \ = [];\n        for (immutable consonant_index = 0; consonant_index < consonant_positions.length;\
    \ consonant_index++)\n        {\n            current_pos = consonant_positions[consonant_index];\n\
    \            foreach (immutable vowel_position; vowel_positions)\n           \
    \ {\n                if (vowel_position > current_pos)\n                {\n  \
    \                  current_possibility ~= abs(current_pos - vowel_position);\n\
    \                }\n            }\n        }\n        if (current_possibility.length\
    \ > 0)\n        {\n            immutable min_distance = min(current_possibility);\n\
    \            immutable min_position = min_distance + current_pos;\n          \
    \  result = word[min_position..min_position];\n        }\n    }\n    return result;\n\
    }\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi7d2_ygc.d(35): Error: no property `find` for type `immutable(string[])`

    /tmp/tmpi7d2_ygc.d(37): Error: cannot modify `immutable` expression `consonant_positions`

    /tmp/tmpi7d2_ygc.d(39): Error: no property `find` for type `immutable(string[])`

    /tmp/tmpi7d2_ygc.d(41): Error: cannot modify `immutable` expression `vowel_positions`

    /tmp/tmpi7d2_ygc.d(46): Error: cannot modify `immutable` expression `0`

    /tmp/tmpi7d2_ygc.d(48): Error: expression `consonant_positions[0]` is `void` and
    has no value

    /tmp/tmpi7d2_ygc.d(49): Error: variable `tmpi7d2_ygc.get_closest_vowel.vowel_position`
    variables cannot be of type `void`

    /tmp/tmpi7d2_ygc.d(49): Error: expression `__r75[__key76]` is `void` and has no
    value

    /tmp/tmpi7d2_ygc.d(59): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi7d2_ygc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  if(word.length() < 2) \n        return \"\";\n    int i;\n    for(i = word.length()\
    \ - 1; i >= 0; i--)\n    {\n        if(vowels.canFind(word[i])) \n        {\n\
    \            for(int j = i - 1; j >= 0; j--)\n            {\n                if(!vowels.canFind(word[j]))\n\
    \                    return word[i..$];\n            }\n        }\n    }\n   \
    \ return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n \
    \   assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp47v9mt49.d(26): Error: no property `length` for type `string`

    /tmp/tmp47v9mt49.d(29): Error: no property `length` for type `string`

    /tmp/tmp47v9mt49.d(31): Error: no property `canFind` for type `string`

    /tmp/tmp47v9mt49.d(35): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp47v9mt49.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    word\
    \ = word.dup;\n    int a = word.find(\"\");\n    int b = word.find(\"\");\n  \
    \  for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            a = i;\n            break;\n        }\n    }\n\
    \    if (a == word.length - 1)\n    {\n        return \"\";\n    }\n    for (int\
    \ i = word.length - 1; i >= 0; i--)\n    {\n        if (consonants.find(word[i])\
    \ != -1)\n        {\n            b = i;\n            break;\n        }\n    }\n\
    \    if (b == 0)\n    {\n        return \"\";\n    }\n    string c = \"\";\n \
    \   for (int i = a; i < b; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            c = word[i..i];\n        }\n    }\n    return c;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp54oep86.d(28): Error: no property `find` for type `string`

    /tmp/tmpp54oep86.d(29): Error: no property `find` for type `string`

    /tmp/tmpp54oep86.d(32): Error: no property `find` for type `string`

    /tmp/tmpp54oep86.d(42): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpp54oep86.d(44): Error: no property `find` for type `string`

    /tmp/tmpp54oep86.d(57): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp54oep86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n  auto vowels = \"AEIOUaeiou\";\n  bool\
    \ left_is_consonant = false;\n  int left = 0;\n  int right = 0;\n  int diff =\
    \ 1 << 30;\n  for (int i = 0; i < word.length; i++)\n  {\n    if (word[i] == '_')\
    \ continue;\n    if (vowels.find(word[i]) == -1) \n    {\n      if (left_is_consonant)\
    \ \n      {\n        int new_diff = abs(i - left);\n        if (new_diff < diff)\
    \ \n        {\n          diff = new_diff;\n          right = i;\n        }\n \
    \     }\n      left_is_consonant = true;\n      left = i;\n    } \n    else \n\
    \    {\n      left_is_consonant = false;\n    }\n  }\n  if (right == 0) return\
    \ \"\";\n  return word[right];\n}\n \n \n \n \n \n //#############################################################\n\
    \ //#                        MY SOLUTION 4\n //#############################################################\n\
    \ \n \n import std.stdio;\nimport std.math;\n \nstring get_closest_vowel(string\
    \ word) \n{\n    enum vowel = \"aeiouAEIOU\";\n    int maxDist = INT_MAX;\n  \
    \  int pos = 0;\n    \n    for (int i = 0; i < word.length; i++)\n    {\n    \
    \    if (vowel.find(word[i]) != -1)\n        {\n            auto dist = i;\n \
    \           for (int j = i + 1; j < word.length; j++)\n            {\n       \
    \         if (vowel.find(word[j]) == -1)\n                {\n                \
    \    dist = j - i;\n                    break;\n                }\n          \
    \  }\n            \n            if (dist < maxDist)\n            {\n         \
    \       maxDist = dist;\n                pos = i;\n            }\n        }\n\
    \    }\n    \n    return maxDist == INT_MAX ? \"\" : word[pos..$];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv7ohg3l6.d(33): Error: no property `find` for type `string`

    /tmp/tmpv7ohg3l6.d(53): Error: cannot implicitly convert expression `word[cast(ulong)right]`
    of type `immutable(char)` to `string`

    /tmp/tmpv7ohg3l6.d(71): Error: undefined identifier `INT_MAX`

    /tmp/tmpv7ohg3l6.d(76): Error: no property `find` for type `string`

    /tmp/tmpv7ohg3l6.d(81): Error: no property `find` for type `string`

    /tmp/tmpv7ohg3l6.d(96): Error: undefined identifier `INT_MAX`

    /tmp/tmpv7ohg3l6.d(102): Error: `tmpv7ohg3l6.get_closest_vowel` called with argument
    types `(string)` matches both:

    /tmp/tmpv7ohg3l6.d(23):     `tmpv7ohg3l6.get_closest_vowel(string word)`

    and:

    /tmp/tmpv7ohg3l6.d(68):     `tmpv7ohg3l6.get_closest_vowel(string word)`

    /tmp/tmpv7ohg3l6.d(103): Error: `tmpv7ohg3l6.get_closest_vowel` called with argument
    types `(string)` matches both:

    /tmp/tmpv7ohg3l6.d(23):     `tmpv7ohg3l6.get_closest_vowel(string word)`

    and:

    /tmp/tmpv7ohg3l6.d(68):     `tmpv7ohg3l6.get_closest_vowel(string word)`

    /tmp/tmpv7ohg3l6.d(104): Error:'
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int index = 0;\n    bool found = false;\n    string prev\
    \ = \"\";\n    foreach(c; word)\n    {\n        if(prev != \"\" && prev != \"\
    a\" && prev != \"e\" && prev != \"i\" && prev != \"o\" && prev != \"u\")\n   \
    \     {\n            if(c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" ||\
    \ c == \"u\")\n            {\n                result = c;\n                found\
    \ = true;\n                break;\n            }\n        }\n        prev = c;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg5tyv6kg.d(34): Error: incompatible types for `(c) == ("a")`: `immutable(char)`
    and `string`

    /tmp/tmpg5tyv6kg.d(34): Error: incompatible types for `(c) == ("e")`: `immutable(char)`
    and `string`

    /tmp/tmpg5tyv6kg.d(34): Error: incompatible types for `(c) == ("i")`: `immutable(char)`
    and `string`

    /tmp/tmpg5tyv6kg.d(34): Error: incompatible types for `(c) == ("o")`: `immutable(char)`
    and `string`

    /tmp/tmpg5tyv6kg.d(34): Error: incompatible types for `(c) == ("u")`: `immutable(char)`
    and `string`

    /tmp/tmpg5tyv6kg.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmpg5tyv6kg.d(41): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg5tyv6kg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    enum char_type\n    {\n        vowel,\n\
    \        consonant,\n        other\n    };\n    auto word_chars = word.dup;\n\
    \    auto char_types = zip(word_chars, map!(t => char_type.other)(word_chars));\n\
    \    foreach(ref character; word_chars)\n    {\n        if(character.toLower ==\
    \ 'a' || character.toLower == 'e' || character.toLower == 'i' || character.toLower\
    \ == 'o' || character.toLower == 'u')\n        {\n            char_types[character]\
    \ = char_type.vowel;\n        }\n        else if(character.isLetter)\n       \
    \ {\n            char_types[character] = char_type.consonant;\n        }\n   \
    \ }\n    auto first_vowel = find(char_types, char_type.vowel);\n    if(first_vowel\
    \ == char_types.length)\n    {\n        return \"\";\n    }\n    auto right_consonant\
    \ = 0;\n    auto left_consonant = 0;\n    auto i = first_vowel;\n    while(i <\
    \ char_types.length)\n    {\n        if(char_types[i] == char_type.consonant)\n\
    \        {\n            right_consonant = i;\n            break;\n        }\n\
    \        i++;\n    }\n    if(right_consonant == 0)\n    {\n        return \"\"\
    ;\n    }\n    auto j = first_vowel;\n    while(j >= 0)\n    {\n        if(char_types[j]\
    \ == char_type.consonant)\n        {\n            left_consonant = j;\n      \
    \      break;\n        }\n        j--;\n    }\n    if(left_consonant == 0)\n \
    \   {\n        return \"\";\n    }\n    if(right_consonant - first_vowel < first_vowel\
    \ - left_consonant)\n    {\n        return word_chars[first_vowel..first_vowel\
    \ + 1];\n    }\n    else\n   \nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0o2u8km.d(30): Deprecation: use `{ }` for an empty statement,
    not `;`

    /tmp/tmpf0o2u8km.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0o2u8km.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    char[] Vowels = ['a', 'e', 'i', 'o',\
    \ 'u', 'A', 'E', 'I', 'O', 'U'];\n    char[] consonants = ['b', 'c', 'd', 'f',\
    \ 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y',\
    \ 'z', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S',\
    \ 'T', 'V', 'W', 'X', 'Y', 'Z'];\n    int length = word.length;\n    int index\
    \ = 0;\n    int lastindex = 0;\n    foreach(var c; word)\n    {\n        foreach(var\
    \ v; Vowels)\n        {\n            if(c == v)\n            {\n             \
    \   lastindex = index;\n            }\n        }\n        index++;\n    }\n  \
    \  int firstIndex = lastindex;\n    int secondIndex = lastindex;\n    foreach(var\
    \ c; word[0..firstIndex])\n    {\n        foreach(var v; consonants)\n       \
    \ {\n            if(c == v)\n            {\n                firstIndex = index;\n\
    \            }\n        }\n        index++;\n    }\n    index = 0;\n    foreach(var\
    \ c; word[lastindex..$])\n    {\n        foreach(var v; consonants)\n        {\n\
    \            if(c == v)\n            {\n                secondIndex = index;\n\
    \            }\n        }\n        index++;\n    }\n    return word[secondIndex\
    \ + lastindex];\n}\n/*\n    Problem: https://www.codewars.com/kata/5ae3bfaa20aab5b87700002c\n\
    \    The beginning of the word will be given to you. You must find the missing\
    \ \n    ending and return it. If there is no beginning given, or if the word is\n\
    \    complete, return the word.\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8mp4fdsk.d(68): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8mp4fdsk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowel_map = \"aeiouAEIOU\";\n\
    \    int vowel_index = 0;\n    int distance = 0;\n    int i = word.length-1;\n\
    \    int min_distance = word.length+1;\n    while(i>=0)\n    {\n        if(vowel_map.findFirstOf(word[i])==string::npos)\n\
    \        {\n            i--;\n            continue;\n        }\n        distance\
    \ = word.length-i;\n        if(distance<min_distance)\n        {\n           \
    \ min_distance = distance;\n            vowel_index = i;\n        }\n        i--;\n\
    \    }\n    if(min_distance>word.length)\n        return \"\";\n    return word[vowel_index..$];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp768d9wg8.d(32): Error: found `:` when expecting `)`

    /tmp/tmp768d9wg8.d(32): Error: found `:` instead of statement

    /tmp/tmp768d9wg8.d(45): Error: declaration expected, not `if`

    /tmp/tmp768d9wg8.d(47): Error: declaration expected, not `return`

    /tmp/tmp768d9wg8.d(48): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp768d9wg8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static immutable string vowels = \"\
    aeiou\";\n    static immutable string consonants = \"bcdfghjklmnpqrstvwxyz\";\n\
    \    static immutable string other_consonants = \"BCDFGHJKLMNPQRSTVWXYZ\";\n \
    \   bool found_consonant = false;\n    int vowel_position = -1;\n    int consonant_position\
    \ = -1;\n    int i;\n    for (i = word.length-1; i >= 0; i--)\n    {\n       \
    \ if (consonants.indexOf(word[i]) >= 0 || other_consonants.indexOf(word[i]) >=\
    \ 0)\n        {\n            if (found_consonant)\n            {\n           \
    \     consonant_position = i;\n                break;\n            }\n       \
    \     else\n            {\n                found_consonant = true;\n         \
    \   }\n        }\n        else if (vowels.indexOf(word[i]) >= 0)\n        {\n\
    \            vowel_position = i;\n        }\n    }\n    if (vowel_position < 0\
    \ || consonant_position < 0)\n    {\n        return \"\";\n    }\n    return word[vowel_position..vowel_position+1];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_5ipe7ac.d(32): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp_5ipe7ac.d(34): Error: no property `indexOf` for type `immutable(string)`

    /tmp/tmp_5ipe7ac.d(34): Error: no property `indexOf` for type `immutable(string)`

    /tmp/tmp_5ipe7ac.d(46): Error: no property `indexOf` for type `immutable(string)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_5ipe7ac.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    // Split the word into two parts. \n\
    \    auto const (left, right) = word.split;\n    // Reverse the right part.\n\
    \    right.reverse;\n    // Create a buffer to store the adjacent vowels.\n  \
    \  auto buf = appender!(string[])();\n    // This counter is used to indicate\
    \ how many adjacent vowels we found in the right part.\n    auto counter = 0;\n\
    \    // The index where we start to search vowels.\n    auto first_consonant_found\
    \ = 0;\n    // Each loop will find one consonant and the adjacent vowels.\n  \
    \  for (size_t i = 0; i < right.length; ++i)\n    {\n        // Is it a consonant?\n\
    \        if (!isVowel(right[i]))\n        {\n            // Yes, it is a consonant.\
    \ We add the current character to the buffer \n            // which is used to\
    \ store the characters from the first consonant to \n            // the last found\
    \ vowel. The first consonant will be added when we find\n            // two consecutive\
    \ consonants in the right part.\n            if (counter > 0)\n            {\n\
    \                // We found the first consonant.\n                first_consonant_found\
    \ = i;\n                buf.put(right[i]);\n            }\n            else\n\
    \            {\n                // We found two consecutive consonants. We reset\
    \ the counter and \n                // add the consonant to the buffer.\n    \
    \            counter = 0;\n                buf.put(right[i]);\n            }\n\
    \        }\n        else\n        {\n            // It is a vowel. We will continue\
    \ the search until we find two consecutive\n            // consonants. The counter\
    \ is used to indicate how many adjacent vowels\n            // we found. \n  \
    \          ++counter;\n            buf.put(right[i]);\n        }\n    }\n    //\
    \ If no adjacent vowels or we didn't find any consonant in the right part, \n\
    \    // then we return the empty string.\n    if (counter == 0 || first_consonant_found\
    \ == 0)\n    {\n        return \"\";\n    }\n    // After we find the first consonant,\
    \ we reverse the buffer and return \n    // the first character from the buffer.\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprxu_136s.d(26): Error: found `,` when expecting `)`

    /tmp/tmprxu_136s.d(26): Error: semicolon expected, not `)`

    /tmp/tmprxu_136s.d(26): Error: found `)` instead of statement

    /tmp/tmprxu_136s.d(76): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprxu_136s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    import std.algorithm;\n    import std.range;\n\
    \    import std.array;\n    import std.typecons;\n    import std.string;\n   \
    \ import std.math;\n    import std.conv;\n    import std.traits;\n    import std.range;\n\
    \    import std.functional;\n    import std.format;\n    import std.conv;\n  \
    \  import std.ascii;\n    import std.conv;\n    import std.algorithm;\n    import\
    \ std.regex;\n    import std.range;\n    import std.array;\n    import std.bigint;\n\
    \    import std.bigint;\n    import std.datetime;\n    import std.algorithm;\n\
    \    import std.algorithm;\n    import std.range;\n    import std.regex;\n   \
    \ import std.format;\n    import std.array;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.range;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.algorithm;\n    import std.range;\n    import std.range;\n   \
    \ import std.range;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.range;\n    import std.array;\n    import std.range;\n    import std.datetime;\n\
    \    import std.datetime;\n    import std.algorithm;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.regex;\n    import std.range;\n    import std.regex;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.string;\n    import std.string;\n  \
    \  import std.range;\n    import std.algorithm;\n    import std.range;\n    import\
    \ std.format;\n    import std.regex;\n    import std.array;\n    import std.algorithm;\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbtode_py.d(93): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbtode_py.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    size_t len = word.length;\n    size_t\
    \ i = len;\n    size_t index_left = len;\n    size_t index_right = len;\n    while(i--)\n\
    \    {\n        switch(word[i])\n        {\n            case 'a':\n          \
    \  case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n\
    \            case 'A':\n            case 'E':\n            case 'I':\n       \
    \     case 'O':\n            case 'U':\n                index_left = i;\n    \
    \            break;\n            default:\n                if(index_left < index_right)\n\
    \                {\n                    index_right = i;\n                }\n\
    \                break;\n        }\n    }\n    if(index_left < index_right)\n\
    \    {\n        return word[index_left..index_left+1];\n    }\n    return \"\"\
    ;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7f_t7x4r.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x428285]

    ??:? void tmp7f_t7x4r.__unittest_L59_C1() [0x427bcb]

    ??:? void tmp7f_t7x4r.__modtest() [0x428008]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bfa3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aeb2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ffc9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430478]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ff55]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ae89]

    ??:? runModuleUnitTests [0x42bd79]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428748]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164271
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowelStr = \"aeiouAEIOU\";\n\
    \    // vowelStr.length == 5;\n    string consonantStr = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    // consonantStr.length == 21;\n    int sz = word.length;\n    // sz >=\
    \ 2\n    bool isAllVowel(true);\n    foreach(ch; word)\n    {\n        if(consonantStr.indexOf(ch)\
    \ != -1)\n        {\n            isAllVowel = false;\n            break;\n   \
    \     }\n    }\n    if(isAllVowel) return \"\";\n    if(consonantStr.indexOf(word[0])\
    \ != -1 || consonantStr.indexOf(word[sz-1]) != -1) return \"\";\n    int idx =\
    \ sz-1;\n    int cnt = 0;\n    for(; idx > 0; idx--)\n    {\n        if(vowelStr.indexOf(word[idx])\
    \ != -1)\n        {\n            cnt++;\n            if(cnt == 2) break;\n   \
    \     }\n    }\n    if(cnt < 2) return \"\";\n    return word[idx].toString();\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqgcy8gtw.d(31): Error: basic type expected, not `true`

    /tmp/tmpqgcy8gtw.d(31): Error: found `true` when expecting `)`

    /tmp/tmpqgcy8gtw.d(31): Error: semicolon expected following function declaration

    /tmp/tmpqgcy8gtw.d(31): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqgcy8gtw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowel = \"AEIOUaeiou\"\
    ;\n    static string consonant = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    ;\n    string result;\n    size_t left = 0;\n    size_t right = word.length()\
    \ - 1;\n    bool flagLeft = true;\n    bool flagRight = true;\n    while(left\
    \ < right)\n    {\n        while(vowel.find(word[left]) == string::npos && left\
    \ < right)\n        {\n            left++;\n        }\n        while(vowel.find(word[right])\
    \ == string::npos && left < right)\n        {\n            right--;\n        }\n\
    \        if(vowel.find(word[left]) != string::npos && vowel.find(word[right])\
    \ != string::npos)\n        {\n            result = word[left];\n            break;\n\
    \        }\n        else\n        {\n            left++;\n            right--;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6uckk0gy.d(34): Error: found `:` when expecting `)`

    /tmp/tmp6uckk0gy.d(34): Error: found `:` instead of statement

    /tmp/tmp6uckk0gy.d(38): Error: found `:` when expecting `)`

    /tmp/tmp6uckk0gy.d(38): Error: found `:` instead of statement

    /tmp/tmp6uckk0gy.d(42): Error: declaration expected, not `if`

    /tmp/tmp6uckk0gy.d(45): Error: declaration expected, not `break`

    /tmp/tmp6uckk0gy.d(46): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6uckk0gy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int word_len = word.length();\n    int closest_vowel_index = -1;\n    int closest_vowel_index_distance\
    \ = 0;\n    for (int i = word_len - 1; i >= 0; i--)\n    {\n        foreach (vowel;\
    \ vowels)\n        {\n            if (word[i] == vowel)\n            {\n     \
    \           if (closest_vowel_index == -1)\n                {\n              \
    \      closest_vowel_index = i;\n                    closest_vowel_index_distance\
    \ = word_len - i;\n                }\n                else\n                {\n\
    \                    int new_vowel_index_distance = word_len - i;\n          \
    \          if (new_vowel_index_distance > closest_vowel_index_distance)\n    \
    \                {\n                        closest_vowel_index = i;\n       \
    \                 closest_vowel_index_distance = new_vowel_index_distance;\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  return closest_vowel_index > 0 ? word[closest_vowel_index..closest_vowel_index]\
    \ : \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpksmr_r8v.d(26): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpksmr_r8v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowels = tuple(\"aeiouAEIOU\");\n\
    \    int min_dist = int.max;\n    string res = \"\";\n    for (int i = 0; i <\
    \ word.length; i++) \n    {\n        for (int j = i + 1; j < word.length; j++)\
    \ \n        {\n            if (word[i] in vowels && word[j] in vowels) \n    \
    \        {\n                if (j - i < min_dist) \n                {\n      \
    \              min_dist = j - i;\n                    res = word[i .. j];\n  \
    \              }\n            }\n        }\n    }\n    return res;\n}\nstring\
    \ get_closest_vowel(string word)\n{\n    auto vowels = tuple(\"aeiouAEIOU\");\n\
    \    int min_dist = int.max;\n    string res = \"\";\n    for (int i = 0; i <\
    \ word.length; i++) \n    {\n        for (int j = i + 1; j < word.length; j++)\
    \ \n        {\n            if (word[i] in vowels && word[j] in vowels) \n    \
    \        {\n                if (j - i < min_dist) \n                {\n      \
    \              min_dist = j - i;\n                    res = word[i .. j];\n  \
    \              }\n            }\n        }\n    }\n    return res;\n}\nstring\
    \ get_closest_vowel(string word) \n{\n    import std.algorithm : min;\n    import\
    \ std.string : count;\n    word = word.filter!(a => \"aeiouAEIOU\".count(a));\n\
    \    return word.length ? word.min!(x => \"aeiouAEIOU\".count(x)) : \"\";\n}\n\
    string get_closest_vowel(string word) \n{\n    import std.algorithm : min;\n \
    \   import std.string : count;\n    word = word.filter!(a => \"aeiouAEIOU\".count(a));\n\
    \    return word.length ? word.min!(x => \"aeiouAEIOU\".count(x)) : \"\";\n\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplvg38bpm.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplvg38bpm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    const string vowels = \"aeiou\";\n \
    \   foreach(int i, char c; word)\n    {\n        if(vowels.canFind(c))\n     \
    \   {\n            int pre_index = word[i - 1];\n            int post_index =\
    \ word[i + 1];\n            if((pre_index < 97 || pre_index > 122) && (post_index\
    \ < 97 || post_index > 122))\n            {\n                return c.toString();\n\
    \            }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdegji8hl.d(28): Error: no property `canFind` for type `const(string)`

    /tmp/tmpdegji8hl.d(34): Error: no property `toString` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdegji8hl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowels = \"aeiouAEIOU\"\
    ;\n    static string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    int cons_count = 0;\n    foreach(c; word)\n    {\n        if(consonants.canFind(c))\n\
    \            cons_count++;\n    }\n    if(cons_count < 2)\n        return \"\"\
    ;\n    for(size_t i = word.length; i > 0; i--)\n    {\n        if(consonants.canFind(word[i]))\n\
    \        {\n            for(size_t j = i; j > 0; j--)\n            {\n       \
    \         if(vowels.canFind(word[j]))\n                    return word[j..j];\n\
    \            }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprcugvkqq.d(30): Error: no property `canFind` for type `string`

    /tmp/tmprcugvkqq.d(37): Error: no property `canFind` for type `string`

    /tmp/tmprcugvkqq.d(41): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprcugvkqq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    static string vowels = \"aeiouAEIOU\"\
    ;\n    bool found_vowel = false;\n    for (size_t i = word.length() - 1; i > 0;\
    \ i--) {\n        if (vowels.find(word[i]) != string::npos) {\n            found_vowel\
    \ = true;\n            if (vowels.find(word[i - 1]) == string::npos) {\n     \
    \           return word.substr(i, 1);\n            }\n        }\n    }\n    return\
    \ found_vowel ? \"\" : \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6m18t6cs.d(28): Error: found `:` when expecting `)`

    /tmp/tmp6m18t6cs.d(28): Error: found `:` instead of statement

    /tmp/tmp6m18t6cs.d(30): Error: found `:` when expecting `)`

    /tmp/tmp6m18t6cs.d(30): Error: found `:` instead of statement

    /tmp/tmp6m18t6cs.d(34): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6m18t6cs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"AEIOUaeiou\";\n  \
    \  auto last_c = rfind(word, r\"\\w+\");\n    if (last_c == word.length)\n   \
    \     return \"\";\n    auto current_c = last_c;\n    while (current_c > 0) {\n\
    \        auto current_v = find(word, vowels, current_c);\n        if (current_v\
    \ < last_c && current_v != word.length)\n            return word[current_v ..\
    \ $];\n        current_c = find(word, r\"\\w+\", current_c);\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8lc8iwmn.d(26): Error: undefined identifier `rfind`, did you mean
    template `Bind(alias Template, args1...)`?

    /tmp/tmp8lc8iwmn.d(31): Error: undefined identifier `find`, did you mean template
    `Bind(alias Template, args1...)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8lc8iwmn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164270
