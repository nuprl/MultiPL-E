name: HumanEval_12_longest
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Out of array of strings, return\
  \ the longest one. Return the first one in case of multiple\n    strings of the\
  \ same length. Return null in case the input array is empty.\n    >>> longest([])\n\
  \    None\n    >>> longest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"\
  a\", \"bb\", \"ccc\"])\n    \"ccc\"\n    \n*/\nNullable!(string) longest(string[]\
  \ strings) \n"
tests: "unittest\n{\n    alias candidate = longest;\n\n{\n        auto result = candidate([]);\n\
  \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([\"x\"\
  , \"y\", \"z\"]);\n        assert(!result.isNull && result.get == \"x\");\n}\n\n\
  {\n        auto result = candidate([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\"\
  , \"abc\"]);\n        assert(!result.isNull && result.get == \"zzzz\");\n}\n\n}\n\
  void main(){}"
completions: ["{\n    if (strings.length == 0)\n        return null;\n    alias longest\
    \ = strings[0];\n    foreach (string s; strings)\n    {\n        if (s.length\
    \ > longest.length)\n            longest = s;\n    }\n    return longest;\n}",
  "{\n    Nullable!(string) longest = Nullable!(string).init;\n    foreach(str; strings)\n\
    \    {\n        if(!longest.isNull && str.length > longest.get.length)\n     \
    \   {\n            longest = Nullable!(string).init;\n            longest.get\
    \ = str;\n        }\n        else if(longest.isNull)\n        {\n            longest.get\
    \ = str;\n        }\n    }\n    return longest;\n}", "{\n    return !strings.empty\
    \ ? strings.maxElement!(a => a.length) : null;\n}", "{\n    import std.algorithm.sorting\
    \ : sort;\n    if (strings.length == 0)\n        return null;\n    sort(strings);\n\
    \    return strings[$-1];\n}\nstring s = longest([]);\nassert(s is null);\ns =\
    \ longest([\"a\", \"b\", \"c\"]);\nassert(s == \"c\");\ns = longest([\"a\", \"\
    bb\", \"ccc\"]);\nassert(s == \"ccc\");\n \n// Sort in descending order\ns = longest([\"\
    c\", \"b\", \"a\"]);\nassert(s == \"c\");\n \n// First in case of multiple maxs\n\
    s = longest([\"aa\", \"b\", \"c\"]);\nassert(s == \"aa\");\n \n// All equal length\n\
    s = longest([\"a\", \"b\", \"c\"]);\nassert(s == \"a\");", "{\n    size_t max_length\
    \ = 0;\n    Nullable!(string) result = null;\n    foreach (string s; strings)\n\
    \    {\n        if (s.length > max_length)\n        {\n            max_length\
    \ = s.length;\n            result = s;\n        }\n    }\n    return result;\n\
    }\n/*\n    Out of two strings, return the longer one. Return the first one in\
    \ case of a tie.\n    >>> longest_two(\"a\", \"b\")\n    \"a\"\n    >>> longest_two(\"\
    abc\", \"ab\")\n    \"abc\"\n*/\nstring longest_two(string a, string b)\n{\n \
    \   return (a.length > b.length) ? a : b;\n}\n/*\n    Out of an array of strings,\
    \ return the shortest one. Return the first one in case of\n    multiple strings\
    \ of the same length. Return null in case the input array is empty.\n    >>> shortest([])\n\
    \    None\n    >>> shortest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"\
    a\", \"bb\", \"ccc\"])\n    \"a\"\n*/\nNullable!(string) shortest(string[] strings)\n\
    {\n    size_t min_length = size_t.max;\n    Nullable!(string) result = null;\n\
    \    foreach (string s; strings)\n    {\n        if (s.length < min_length)\n\
    \        {\n            min_length = s.length;\n            result = s;\n    \
    \    }\n    }\n    return result;\n}\n/*\n    Out of two strings, return the shorter\
    \ one. Return the first one in case of a tie.\n    >>> shortest_two(\"a\", \"\
    b\")\n    \"a\"\n    >>> shortest_two(\"abc\", \"ab\")\n    \"ab\"\n*/\nstring\
    \ shortest_two(string a, string b)\n{\n    return (a.length < b.length) ? a :\
    \ b;\n}\n/*\n    Split the string s around the given character and return the\
    \ resulting array of strings.\n    >>> split(\"abcd\", 'c')\n    [\"ab\", \"d\"\
    ]\n    >>> split(\"abcd\", 'b')\n", "{\n    int longestLength = 0;\n    Nullable!(string)\
    \ longestString = null;\n    foreach(string testString; strings)\n    {\n    \
    \    if(testString.length > longestLength)\n        {\n            longestLength\
    \ = testString.length;\n            longestString = testString;\n        }\n \
    \   }\n    return longestString;\n}", "{\n    Nullable!(string) longString = Nullable!(string).init;\n\
    \    foreach(str; strings)\n    {\n        if(longString.isNull || str.length\
    \ > longString.get.length)\n        {\n            longString = Nullable!(string).from(str);\n\
    \        }\n    }\n    return longString;\n}", "{\n    if (strings.length == 0)\n\
    \        return null;\n    size_t longestLen = 0;\n    Nullable!(string) longestStr\
    \ = null;\n    foreach (str; strings) \n    {\n        size_t len = str.length;\n\
    \        if (len > longestLen) \n        {\n            longestLen = len;\n  \
    \          longestStr = str;\n        }\n    }\n    return longestStr;\n}", "{\n\
    \tint maxLength = 0;\n\tNullable!(string) result = null;\n\tforeach(str; strings)\n\
    \t{\n\t\tif(str.length > maxLength)\n\t\t{\n\t\t\tmaxLength = str.length;\n\t\t\
    \tresult = str;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    Nullable!(string) ret;\n\
    \    foreach(i, ref elem; strings)\n    {\n        if(!elem.length) continue;\n\
    \        if(!ret.isNull && ret.value.length > elem.length) continue;\n       \
    \ ret = elem;\n    }\n    return ret;\n}", "{\n    Nullable!(string) result =\
    \ null;\n    foreach(string item; strings)\n    {\n        if(item.length > result.ptr.length)\
    \ \n        {\n            result = item;\n        }\n    }\n    return result;\n\
    }", "{\n    Nullable!(string) longest = null;\n    foreach(str; strings)\n   \
    \ {\n        if (str.length > longest.length) \n        {\n            longest\
    \ = new Nullable!(string)(str);\n        }\n    }\n    return longest;\n}", "{\n\
    \    if (strings.length == 0) \n    {\n        return null;\n    }\n    else\n\
    \    {\n        auto longest = max(strings.map!(a => a.length));\n        foreach\
    \ (str; strings) \n        {\n            if (str.length == longest) \n      \
    \      {\n                return str;\n            }\n        }\n    }\n}\n/*\n\
    \ This function takes an array of strings and returns the result of concatenating\
    \ each element of the array with itself.\n    >>> double_all([\"a\", \"b\", \"\
    c\"])\n    [\"aa\", \"bb\", \"cc\"]\n    >>> double_all([])\n    []\n*/\nstring[]\
    \ double_all(string[] strings) \n{\n    auto result = new string[];\n    foreach\
    \ (s; strings) \n    {\n        result ~= s ~ s;\n    }\n    return result;\n\
    }\n/*\n    This function takes two arrays of strings and returns a new array that\
    \ contains the elements in the first array\n    whose lengths are longer than\
    \ the lengths of the elements in the second array.\n    >>> longer_than_all([\"\
    a\", \"ab\", \"abc\"], [\"b\", \"bb\", \"bbb\"])\n    [\"abc\"]\n    >>> longer_than_all([\"\
    ab\", \"bb\", \"bbb\"], [\"a\", \"ab\", \"abc\"])\n    [\"bbb\"]\n    >>> longer_than_all([\"\
    a\", \"ab\", \"abc\"], [\"b\", \"bb\", \"bbb\"])\n    [\"abc\"]\n    >>> longer_than_all([],\
    \ [\"b\", \"bb\", \"bbb\"])\n    []\n    >>> longer_than_all([\"a\", \"ab\", \"\
    abc\"], [])\n    [\"a\", \"ab\", \"abc\"]\n*/\nstring[] longer_than_all(string[]\
    \ strings, string[] strings2) \n{\n    auto result = new string[];\n    foreach\
    \ (s; strings) \n    {\n        bool longer = true;\n        foreach (s2; strings2)\
    \ \n        {\n            if (s.length <= s2.length) \n            {\n      \
    \          longer = false;\n            }\n        }\n        if (", "{\n    if\
    \ (strings.length == 0)\n        return null;\n    import std.algorithm : max;\n\
    \    import std.typecons : Nullable;\n    Nullable!(string) max = Nullable!(string)(strings[0]);\n\
    \    foreach (string s; strings) \n    {\n        Nullable!(string) null_s = Nullable!(string)(s);\n\
    \        if (null_s > max)\n            max = null_s;\n    }\n    return max;\n\
    }", "{\n    if (strings.length == 0)\n        return null;\n    auto maxSize =\
    \ strings[0].length;\n    int posMax = 0;\n    foreach (i, s; strings) \n    {\n\
    \        if (s.length > maxSize) \n        {\n            maxSize = s.length;\n\
    \            posMax = i;\n        }\n    }\n    return strings[posMax];\n}\n/*\n\
    \    Given array of integers, return its square.\n    >>> square([])\n    []\n\
    \    >>> square([0, 1, 2, 3, 4])\n    [0, 1, 4, 9, 16]\n*/", "{\n    if (strings.length\
    \ == 0) return null;\n    auto longest = strings[0];\n    foreach (string s; strings)\n\
    \    {\n        if (s.length > longest.length)\n            longest = s;\n   \
    \ }\n    return longest;\n}\n/*\n Convert a string to a double. Returns null if\
    \ the string is not a valid double.\n    >>> toDouble(\"1.0\")\n    1.0\n    >>>\
    \ toDouble(\"invalid\")\n    None\n*/\nNullable!(double) toDouble(string text)\
    \ \n{\n    import std.conv;\n    try\n    {\n        return to!double(text);\n\
    \    }\n    catch(Exception)\n    {\n        return null;\n    }\n}\n/*\n Write\
    \ a function which takes an array of double and returns the sum.\n Return null\
    \ if the array is empty.\n    >>> sumOfDouble([])\n    None\n    >>> sumOfDouble([1.0,\
    \ 2.0, 3.0])\n    6.0\n*/\nNullable!(double) sumOfDouble(double[] doubles) \n\
    {\n    if (doubles.length == 0) return null;\n    auto sum = 0.0;\n    foreach\
    \ (double d; doubles)\n    {\n        sum += d;\n    }\n    return sum;\n}\n/*\n\
    \ Find the first string in an array which starts with a given string.\n Return\
    \ null if no such string is found.\n    >>> findStartsWith([\"a\", \"b\", \"ab\"\
    ], \"a\")\n    \"a\"\n    >>> findStartsWith([\"a\", \"b\", \"ab\"], \"b\")\n\
    \    \"b\"\n    >>> findStartsWith([\"a\", \"b\", \"ab\"], \"abc\")\n    None\n\
    */\nNullable!(string) findStartsWith(string[] strings, string search) \n{\n  \
    \  foreach (string s; strings)\n    {\n        if (s.startsWith(search))\n   \
    \         return s;\n    }\n    return null;\n}\n/*\n Write a function that takes\
    \ a string, and returns a new string with all the vowels removed.\n    >>> removeVowels(\"\
    hello\")\n    \"hll\"", "{\n    Nullable!(string) result = null;\n    size_t maxLength\
    \ = 0;\n    foreach (string str; strings)\n    {\n        if (str.length > maxLength)\n\
    \        {\n            maxLength = str.length;\n            result = str;\n \
    \       }\n    }\n    return result;\n}\n/*\n     In the given array, find the\
    \ element with the minimal value. \n     Return null in case the input array is\
    \ empty.\n    >>> min([])\n    None\n    >>> min([1,2,3])\n    1\n    >>> min([9,2,3])\n\
    \    2\n*/\nNullable!(int) min(int[] arr)\n{\n    Nullable!(int) result = null;\n\
    \    int minValue = max!int;\n    foreach (int a; arr)\n    {\n        if (a <\
    \ minValue)\n        {\n            minValue = a;\n            result = a;\n \
    \       }\n    }\n    return result;\n}\n/*\n Out of array of strings, return\
    \ the shortest one. Return the first one in case of multiple\n    strings of the\
    \ same length. Return null in case the input array is empty.\n    >>> shortest([])\n\
    \    None\n    >>> shortest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"\
    a\", \"bb\", \"ccc\"])\n    \"a\"\n*/\nNullable!(string) shortest(string[] strings)\n\
    {\n    Nullable!(string) result = null;\n    size_t minLength = max!size_t;\n\
    \    foreach (string str; strings)\n    {\n        if (str.length < minLength)\n\
    \        {\n            minLength = str.length;\n            result = str;\n \
    \       }\n    }\n    return result;\n}\n/*\n    Given a list of strings, return\
    \ a list of all strings that\n    are palindromes (case insensitive).\n    >>>\
    \ palindromes([\"a\", \"b\", \"c\"])\n    []\n    >>> palindromes([\"a\", \"b\"\
    , \"CdC\"])\n    [\"CdC\"]\n    >>> palindromes([\"a\", \"", "{\n    Nullable!(string)\
    \ result = null;\n    if (strings.length == 0)\n        return result;\n    result\
    \ = strings[0];\n    foreach (i, s; strings)\n    {\n        if (s.length > result.idup.length)\n\
    \            result = s;\n    }\n    return result;\n}", "{\n\tif (strings.length\
    \ == 0)\n\t\treturn null;\n\treturn strings.reduce!((x, y) => x.length > y.length\
    \ ? x : y);\n}", "{\n    Nullable!(string) result = null;\n    foreach(string\
    \ str; strings) \n    {\n        if(result.isNull || str.length > result.get.length)\
    \ \n        {\n            result = str;\n        }\n    }\n    return result;\n\
    }\n/*\n    Out of array of strings, return the shortest one. Return the first\
    \ one in case of multiple\n    strings of the same length. Return null in case\
    \ the input array is empty.\n    >>> shortest([])\n    None\n    >>> shortest([\"\
    a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"a\", \"bb\", \"ccc\"])\n \
    \   \"a\"\n*/\nNullable!(string) shortest(string[] strings) \n{\n    Nullable!(string)\
    \ result = null;\n    foreach(string str; strings) \n    {\n        if(result.isNull\
    \ || str.length < result.get.length) \n        {\n            result = str;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Out of array of strings, return\
    \ the average length of strings. Ignore nulls.\n    >>> averageLength([\"a\",\
    \ \"bb\", \"ccc\"])\n    2.0\n    >>> averageLength([\"a\", \"\", \"ccc\"])\n\
    \    2.0\n    >>> averageLength([\"a\", null, \"ccc\"])\n    2.0\n*/\ndouble averageLength(string[]\
    \ strings) \n{\n    int sum = 0;\n    int count = 0;\n    foreach(string str;\
    \ strings) \n    {\n        if(str) \n        {\n            sum += str.length;\n\
    \            count++;\n        }\n    }\n    return cast(double)sum / count;\n\
    }\n/*\n    Out of array of strings, return the word that has the highest sum of\
    \ letters' positions\n    in the alphabet. Return the first one in case of multiple\
    \ words with the same sum.\n    Return null in case the input array is empty.\n\
    \    >>> alphabeticalSum([\"a\", \"bb\", \"ccc\"])\n    \"a\"\n    >>> alphabeticalSum([\"\
    a\", \"b\", \"c\"])\n    \"", "{\n    if (strings.length == 0) return null;\n\
    \    Nullable!(string) foundString = null;\n    foreach (str; strings)\n    {\n\
    \        if (foundString is null || str.length > foundString.length)\n       \
    \ {\n            foundString = str;\n        }\n    }\n    return foundString;\n\
    }", "{\n    if (strings.length == 0)\n        return null;\n    else if (strings.length\
    \ == 1)\n        return strings[0];\n    else\n    {\n        size_t longestIdx\
    \ = 0;\n        foreach (idx, string s; strings)\n        {\n            if (s.length\
    \ > strings[longestIdx].length)\n                longestIdx = idx;\n        }\n\
    \        return strings[longestIdx];\n    }\n}", "{\n    if (strings.length ==\
    \ 0)\n        return null;\n    else if (strings.length == 1)\n        return\
    \ strings[0];\n    else\n    {\n        Nullable!(string) longest = strings[0];\n\
    \        foreach (i, str; strings)\n        {\n            if (str.length > longest.get().length)\n\
    \                longest = str;\n        }\n        return longest;\n    }\n}\n\
    /*\n    An empty array of integers is defined as a sorted array in which all elements\
    \ are equal.\n    Write a function to determine whether the array is empty or\
    \ not.\n    >>> isEmpty([])\n    True\n    >>> isEmpty([1,1,1])\n    True\n  \
    \  >>> isEmpty([1,2,3])\n    False\n*/", "{\n\tsize_t longest = 0;\n\tNullable!(string)\
    \ result = null;\n\tforeach(string s; strings)\n\t{\n\t\tif(s.length > longest)\n\
    \t\t{\n\t\t\tlongest = s.length;\n\t\t\tresult = s;\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\n Given a positive number n, return the largest prime number that is less\
    \ than n.\n    >>> largest_prime(2)\n    2\n    >>> largest_prime(10)\n    7\n\
    \    >>> largest_prime(11)\n    7\n    >>> largest_prime(12)\n    11\n*/", "{\n\
    \tif (strings.length == 0) return null;\n\t\n\tNullable!(string) result = null;\n\
    \tforeach (s; strings) \n\t{\n\t\tif (result is null || s.length > result.get.length)\n\
    \t\t\tresult = s;\n\t}\n\treturn result;\n}", "{\n    // assume first is the longest\n\
    \    Nullable!(string) result = to!Nullable(strings[0]);\n    foreach(str; strings)\n\
    \    {\n        auto current = to!Nullable(str);\n        if(!result.isNull &&\
    \ !current.isNull)\n        {\n            result = max(result, current, (a, b)\
    \ => a.length > b.length);\n        }\n    }\n    return result;\n}", "{\n   \
    \ Nullable!(string) ret = null;\n    int i = 0;\n    foreach(str; strings)\n \
    \   {\n        if(str.length > i)\n        {\n            ret = str;\n       \
    \     i = str.length;\n        }\n    }\n    return ret;\n}", "{\n    if (strings.length\
    \ == 0)\n        return null;\n    auto result = strings[0];\n    foreach (i,\
    \ string s; strings) \n    {\n        if (s.length > result.length)\n        \
    \    result = s;\n    }\n    return result;\n}", "{\n\tif (strings.length == 0)\n\
    \t\treturn null;\n\telse\n\t{\n\t\tstring result = strings[0];\n\t\tforeach (string\
    \ s; strings)\n\t\t{\n\t\t\tif (s.length > result.length)\n\t\t\t\tresult = s;\n\
    \t\t}\n\t\treturn result;\n\t}\n}", "{\n    if (strings.length == 0) return null;\n\
    \    return strings.reduce!((a, b) => if (a.length > b.length) a else b);\n}",
  "{\n    if (strings.length == 0)\n        return null;\n    Nullable!(string) ret\
    \ = null;\n    int maxLen = 0;\n    foreach (str; strings)\n    {\n        if\
    \ (str.length > maxLen)\n        {\n            maxLen = str.length;\n       \
    \     ret = str;\n        }\n    }\n    return ret;\n}", "{\n    Nullable!(string)\
    \ longestString = null;\n    foreach(string str; strings) \n    {\n        if(!longestString.isNull\
    \ && str.length < longestString.get.length) \n        {\n            continue;\n\
    \        }\n        longestString = str;\n    }\n    return longestString;\n}",
  "{\n\tif (strings.length == 0)\n\t\treturn null;\n\t\t\n\tint longestIndex = 0;\n\
    \tforeach (i, s; strings)\n\t{\n\t\tif (s.length > strings[longestIndex].length)\n\
    \t\t\tlongestIndex = i;\n\t}\n\treturn strings[longestIndex];\n}\n/*\n  From an\
    \ array of strings, return the shortest one. Return the first one in case of multiple\n\
    \    strings of the same length. Return null in case the input array is empty.\n\
    \    >>> shortest([])\n    None\n    >>> shortest([\"a\", \"b\", \"c\"])\n   \
    \ \"a\"\n    >>> shortest([\"a\", \"bb\", \"ccc\"])\n    \"a\"\n*/\nNullable!(string)\
    \ shortest(string[] strings) \n{\n\tif (strings.length == 0)\n\t\treturn null;\n\
    \t\t\n\tint shortestIndex = 0;\n\tforeach (i, s; strings)\n\t{\n\t\tif (s.length\
    \ < strings[shortestIndex].length)\n\t\t\tshortestIndex = i;\n\t}\n\treturn strings[shortestIndex];\n\
    }\n/*\n  From an array of strings, return the sum of their lengths. \n    >>>\
    \ string_lengths_sum([])\n    0\n    >>> string_lengths_sum([\"a\", \"b\", \"\
    c\"])\n    3\n    >>> string_lengths_sum([\"a\", \"bb\", \"ccc\"])\n    6\n*/\n\
    size_t string_lengths_sum(string[] strings) \n{\n\tsize_t sum = 0;\n\tforeach\
    \ (i, s; strings)\n\t{\n\t\tsum += s.length;\n\t}\n\treturn sum;\n}\n/*\n  From\
    \ an array of strings, return the sum of their lengths. \n    >>> string_lengths_product([])\n\
    \    1\n    >>> string_lengths_product([\"a\", \"b\", \"c\"])\n    3\n    >>>\
    \ string_lengths_product([\"a\", \"bb\", \"ccc\"])\n    6\n*/\nsize_t string_lengths_product(string[]\
    \ strings)", "{\n    /*\n    string[] strings = [\"a\", \"bb\", \"ccc\"];\n  \
    \  size_t idx = 0;\n    foreach(i, el; strings)\n    {\n        if(el.length >\
    \ strings[idx].length)\n            idx = i;\n    }\n    return strings[idx];\n\
    \    */\n    if(strings.length == 0)\n        return null;\n    auto res = max(strings.map!(s\
    \ => s.length));\n    return strings[res.index];\n}\n ", "{\n    if (strings.length\
    \ == 0) \n    {\n        return null;\n    }\n    alias longest = strings[0];\n\
    \    foreach (str; strings) \n    {\n        if (str.length > longest.length)\
    \ \n        {\n            longest = str;\n        }\n    }\n    return longest;\n\
    }", "{\n    if (strings.length == 0)\n        return null;\n    else\n    {\n\
    \        size_t max_length = 0;\n        string result = \"\";\n        foreach\
    \ (string str; strings)\n        {\n            if (str.length > max_length)\n\
    \            {\n                max_length = str.length;\n                result\
    \ = str;\n            }\n        }\n        return result;\n    }\n}", "{\n  \
    \  size_t longestLength = 0;\n    foreach (index, string str; strings) \n    {\n\
    \        if (str.length > longestLength) \n        {\n            longestLength\
    \ = str.length;\n        }\n    }\n    return longestLength == 0 ? Nullable!(string)()\
    \ : Nullable!(string)(strings[0]);\n}", "{\n\tif (strings.length == 0)\n\t\treturn\
    \ null;\n\t//\n\tauto max_len = 0;\n\tauto max_len_idx = 0;\n\tforeach (i, s;\
    \ strings)\n\t{\n\t\tif (s.length > max_len)\n\t\t{\n\t\t\tmax_len = s.length;\n\
    \t\t\tmax_len_idx = i;\n\t\t}\n\t}\n\t//\n\treturn strings[max_len_idx];\n}\n\
    /*\n Out of array of integers, return the largest one.\n    >>> max_int([])\n\
    \    0\n    >>> max_int([1, 2, 3])\n    3\n    >>> max_int([-1, -2, -3])\n   \
    \ -1\n*/", "{\n    if (strings.length == 0)\n        return null;\n    else\n\
    \    {\n        auto result = std.algorithm.max(strings, (a, b) => a.length -\
    \ b.length);\n        return result.front;\n    }\n}", "{\n    if (strings.length\
    \ == 0) return Nullable!(string)();\n    Nullable!(string) result = Nullable!(string)(strings[0]);\n\
    \    for (string s; s=strings[]) \n    {\n        if (s.length > result.get.length)\
    \ \n        {\n            result = Nullable!(string)(s);\n        }\n    }\n\
    \    return result;\n}\n/*\n Return square for a number. Return null for negative\
    \ numbers.\n    >>> square(3)\n    9\n    >>> square(-3)\n    None\n    >>> square(2.5)\n\
    \    6.25\n*/\nNullable!(real) square(real x) \n{\n    if (x < 0) return Nullable!(real)();\n\
    \    return Nullable!(real)(x * x);\n}\n/*\n Return the string representing a\
    \ char value. Return null if the input is not a char.\n    >>> charValue(\"c\"\
    )\n    'c'\n    >>> charValue(\"\")\n    None\n    >>> charValue(\"ab\")\n   \
    \ None\n*/\nNullable!(char) charValue(string s) \n{\n    if (s.length != 1) return\
    \ Nullable!(char)();\n    return Nullable!(char)(s[0]);\n}\n/*\n Return the square\
    \ root of a number. Return null for negative numbers.\n    >>> squareRoot(4)\n\
    \    2\n    >>> squareRoot(-4)\n    None\n    >>> squareRoot(2.5)\n    1.581138\n\
    */\nNullable!(real) squareRoot(real x) \n{\n    if (x < 0) return Nullable!(real)();\n\
    \    return Nullable!(real)(sqrt(x));\n}\n/*\n Return the largest of the input\
    \ values. Return null if the input array is empty.\n    >>> largest([])\n    None\n\
    \    >>> largest([1, 2, 3])\n    3\n    >>> largest([1, 2, 3, -1])\n    3\n  \
    \  >>> largest([1.1, 1.2, 1.05])\n    1.2\n*/\nNullable!(real) largest(real[]\
    \ values) \n{\n    if (", "{\n    Nullable!(string) longest = null;\n    int maxLength\
    \ = 0;\n    foreach(string str; strings) \n    {\n        const int length = str.length;\n\
    \        if (length > maxLength) \n        {\n            maxLength = length;\n\
    \            longest = str;\n        }\n    }\n    return longest;\n}\n/*\n Given\
    \ a set of numbers, return a set where each number is replaced by its absolute\
    \ value.\n    >>> abs({-1, -2, 0, 1, 2})\n    {0, 1, 2}\n    >>> abs({-1, -2,\
    \ 0, 1, 2})\n    {0, 1, 2}\n*/", "{\n    Nullable!(string) result = null;\n  \
    \  foreach(string s; strings)\n    {\n        if(result.isNull || s.length > result.get.length)\n\
    \        {\n            result = s;\n        }\n    }\n    return result;\n}",
  "{\n    if (strings.length == 0) \n    {\n        return null;\n    }\n    auto\
    \ w = strings[0];\n    foreach (i, curr; strings) \n    {\n        if (curr.length\
    \ > w.length) \n        {\n            w = curr;\n        }\n    }\n    return\
    \ w;\n}\n/*\n    >>> count_occurences([\"hello\", \"bob\", \"hello\", \"bob\"\
    , \"bob\", \"bob\", \"hello\"])\n    [\"hello\": 3, \"bob\": 4]\n*/\nMap!(string,\
    \ int) count_occurences(string[] strings) \n{\n    auto acc = std.map.Map!(string,\
    \ int)();\n    foreach (s; strings) \n    {\n        acc[s]++;\n    }\n    return\
    \ acc;\n}\n/*\n    >>> filter_by_length([\"hello\", \"bob\", \"hello\", \"bob\"\
    , \"bob\", \"bob\", \"hello\"], 4)\n    [\"hello\", \"bob\", \"bob\", \"bob\"\
    ]\n*/\nstring[] filter_by_length(string[] strings, size_t len) \n{\n    return\
    \ strings.filter!(s => s.length == len);\n}\n/*\n    >>> filter_by_length_safe([\"\
    hello\", \"bob\", \"hello\", \"bob\", \"bob\", \"bob\", \"hello\"], 4)\n    [\"\
    hello\", \"bob\", \"bob\", \"bob\"]\n    >>> filter_by_length_safe([\"hello\"\
    , \"bob\", \"hello\", \"bob\", \"bob\", \"bob\", \"hello\"], 100)\n    []\n*/\n\
    string[] filter_by_length_safe(string[] strings, size_t len) \n{\n    return strings.filter!(s\
    \ => s.length == len).retro;\n}\n/*\n    >>> filter_by_is_palindrome([\"hello\"\
    , \"bob\", \"aa\", \"bob\", \"bob\", \"bob\", \"hello\"])\n    [\"aa\", \"bob\"\
    , \"bob\", \"bob\", \"bob\"]\n*/\nstring", "{\n    Nullable!(string) longest =\
    \ null;\n    foreach(string str; strings)\n    {\n        if(longest.isNull ||\
    \ str.length > longest.get!.length)\n        {\n            longest = str;\n \
    \       }\n    }\n    return longest;\n}", "{\n    import std.algorithm;\n   \
    \ import std.range;\n    import std.stdio;\n    auto range = strings.maxElement!(a\
    \ => a.length);", "{\n    auto longest = strings.front;\n    foreach(string s;\
    \ strings)\n    {\n        if(s.length > longest.length)\n            longest\
    \ = s;\n    }\n    return longest;\n}", "{\n    Nullable!(string) result = Nullable!(string).init;\n\
    \    foreach(string s; strings) \n    {\n        if(result.isNull || (s.length\
    \ > result.get.length))\n        {\n            result = Nullable!(string).init(s);\n\
    \        }\n    }\n    return result;\n}", "{\n    if (strings.length == 0)\n\
    \        return null;\n    else\n    {\n        string longest = strings[0];\n\
    \        foreach (string s; strings)\n        {\n            if (s.length > longest.length)\n\
    \                longest = s;\n        }\n        return longest;\n    }\n}\n\
    /*\n Solve the quadratic equation in form of ax^2 + bx + c = 0\n    >>> quadratic(1,\
    \ -3, 2)\n    [2, 1]\n    >>> quadratic(1, 2, 1)\n    [-1]\n    >>> quadratic(1,\
    \ -6, 9)\n    [3]\n    >>> quadratic(1, -4, 4)\n    [2]\n    >>> quadratic(1,\
    \ 4, 4)\n    []\n    >>> quadratic(1, 0, -4)\n    [2, -2]\n*/\nreal[] quadratic(real\
    \ a, real b, real c)\n{\n    auto d = b * b - 4 * a * c;\n    if (d < 0)\n   \
    \     return [];\n    else if (d == 0)\n        return [ -b / (2 * a) ];\n   \
    \ else\n    {\n        real x1 = (-b + sqrt(d)) / (2 * a);\n        real x2 =\
    \ (-b - sqrt(d)) / (2 * a);\n        return [ x1, x2 ];\n    }\n}", "{\n    import\
    \ std.conv : to;\n    import std.algorithm : max, map;\n    import std.range :\
    \ take, takeExactly;\n    import std.typecons : Nullable;\n    import std.array\
    \ : array;\n    auto lengths = strings.map!(a => a.length).array;\n    auto max_length\
    \ = max(lengths);\n    Nullable!(string) max_string = Nullable!(string)();\n \
    \   foreach(i, string s; strings)\n    {\n        if(s.length == max_length)\n\
    \        {\n            max_string = Nullable!(string)(s);\n            break;\n\
    \        }\n    }\n    return max_string;\n}", "{\n\tNullable!(string) result;",
  "{\n    Nullable!(string) longest;\n    foreach(str; strings)\n    {\n        if(longest.isNull\
    \ || longest.get.length < str.length)\n        {\n            longest = str;\n\
    \        }\n    }\n    return longest;\n}\n/*\n Reimplement max so that it works\
    \ both on a range and on an array.\n    >>> max([1,2,3])\n    3\n    >>> max(1,2,3)\n\
    \    3\n    >>> max(\"a\", \"b\", \"c\")\n    \"c\"\n*/\nT max(T)(T[] xs)\n{\n\
    \    return max(xs);\n}", "{\n    if (strings.length == 0) \n    {\n        return\
    \ null;\n    }", "{\n    Nullable!(string) result = null;\n    foreach(string\
    \ str; strings)\n    {\n        if (result is null || str.length > result.length)\n\
    \        {\n            result = str;\n        }\n    }\n    return result;\n\
    }\n/*\n    Given an array of string representing numbers, return the sum of all\
    \ of them.\n    >>> sumNumberArray([\"1\", \"3\", \"8\"])\n    12\n    >>> sumNumberArray([\"\
    1\", \"3\", \"8.1\"])\n    12.1\n    >>> sumNumberArray([\"1\", \"3\", \"8.1\"\
    , \"1e3\"])\n    1012.1\n    >>> sumNumberArray([\"1\", \"3\", \"8.1\", \"1e3\"\
    , \"4.2e2\"])\n    1412.1\n*/\ndouble sumNumberArray(string[] strings) \n{\n \
    \   double result = 0;\n    foreach(string str; strings)\n    {\n        result\
    \ += to!double(str);\n    }\n    return result;\n}", "{\n    string maxLengthString\
    \ = null;\n    foreach(string str; strings) \n    {\n        if(maxLengthString\
    \ is null || str.length > maxLengthString.length)\n        {\n            maxLengthString\
    \ = str;\n        }\n    }\n    return maxLengthString;\n}", "{\n    if (strings.length\
    \ > 0)\n    {\n        size_t longestIndex = 0;\n        foreach (index, string\
    \ s; strings)\n        {\n            if (s.length > strings[longestIndex].length)\n\
    \            {\n                longestIndex = index;\n            }\n       \
    \ }\n        return strings[longestIndex];\n    }\n    return null;\n}", "{\n\
    \    if (strings.length == 0)\n        return null;\n    string longest = strings[0];\n\
    \    foreach (s; strings)\n    {\n        if (s.length > longest.length)\n   \
    \         longest = s;\n    }\n    return longest;\n}", "{\n    Nullable!(string)\
    \ candidate = null;\n    foreach (string s; strings)\n    {\n        if (!candidate.isNull)\n\
    \        {\n            if (s.length > candidate.get.length) \n            {\n\
    \                candidate = s;\n            }\n        }\n        else\n    \
    \    {\n            candidate = s;\n        }\n    }\n    return candidate;\n}",
  "{\n    if (strings.length == 0)\n        return null;\n    else\n    {\n      \
    \  size_t maxLen = 0;\n        string maxStr = null;\n        foreach (idx, s;\
    \ strings)\n        {\n            size_t len = s.length;\n            if (len\
    \ > maxLen)\n            {\n                maxLen = len;\n                maxStr\
    \ = s;\n            }\n        }\n        return maxStr;\n    }\n}", "{\n    Nullable!(string)\
    \ result = typeof(result).init;\n    size_t resultLen = 0;\n    foreach (string\
    \ s; strings)\n    {\n        size_t len = s.length;\n        if (len > resultLen)\n\
    \        {\n            resultLen = len;\n            result = s;\n        }\n\
    \    }\n    return result;\n}", "{\n\tsize_t length = strings.length;\n\tif (length==0)\n\
    \t\treturn Nullable!(string)();\n\tsize_t max_length = 0;\n\tsize_t max_idx =\
    \ 0;\n\tforeach (i, s; strings)\n\t{\n\t\tif (s.length > max_length)\n\t\t{\n\t\
    \t\tmax_length = s.length;\n\t\t\tmax_idx = i;\n\t\t}\n\t}\n\treturn to!Nullable!(string)(strings[max_idx]);\n\
    }", "{\n    return strings.length == 0 ? Nullable!(string).init : \n         \
    \  strings.reduce!((a, b) => a.length > b.length ? a : b).idup;\n}\n \n \n \n\
    \ \n ", "{\n    if (strings.length == 0) return null;\n    auto max = tuple(0,\
    \ null);\n    foreach (i, s; strings) {\n        if (s.length > max[0])\n    \
    \        max = tuple(s.length, s);\n    }\n    return max[1];\n}", "{\n    string\
    \ longest = null;\n    foreach(string s; strings)\n    {\n        if(s.length\
    \ > longest.length)\n        {\n            longest = s;\n        }\n    }\n \
    \   return longest;\n}", "{\n    import std.algorithm : reduce;\n    import std.algorithm\
    \ : max;\n    import std.typecons : Nullable;\n    import std.conv : to;\n   \
    \ int maxLength = strings.reduce!((a,b) => max(a.length, b.length));\n    string\
    \ result = strings.filter!(v => v.length == maxLength)[0];\n    return to!Nullable!(string)(result);\n\
    }", "{\n    string result = null;\n    foreach(str; strings)\n    {\n        if(str.length\
    \ > result.length)\n        {\n            result = str;\n        }\n    }\n \
    \   return result;\n}\n/*\nSum the given integers. Ignore any non-integer values\
    \ in the argument list.\n>>> add(1, 2, 3)\n6\n>>> add(1, 2, 3, \"foo\")\n6\n>>>\
    \ add(1, \"bar\", 4)\n5\n*/", "{\n\tsize_t pos = 0;\n\tforeach(size_t i, string\
    \ s; strings)\n\t{\n\t\tif(s.length > strings[pos].length) pos = i;\n\t}\n\treturn\
    \ pos == 0 ? null : strings[pos];\n}", "{\n    import std.array : map;\n    size_t\
    \ len = 0;\n    foreach (str; strings)\n    {\n        if (str.length > len)\n\
    \            len = str.length;\n    }\n    Nullable!(string) res = Nullable!(string).init;\n\
    \    foreach (str; strings)\n    {\n        if (str.length == len)\n        {\n\
    \            res = str;\n            break;\n        }\n    }\n    return res;\n\
    }", "{\n    Nullable!(string) current;\n    foreach(str; strings) \n    {\n  \
    \      if(current.isNull || str.length > current.get.length)\n            current\
    \ = str;\n    }\n    return current;\n}\nassert(longest([\"a\", \"bb\", \"ccc\"\
    ]) == \"ccc\");\n \n/*\n Out of array of integers, return the lowest one. Return\
    \ the first one in case of multiple\n    integers of the same value. Return null\
    \ in case the input array is empty.\n    >>> min([])\n    None\n    >>> min([1,\
    \ 2, 3])\n    1\n    >>> min([4, 3, 2, 1])\n    1\n    \n*/\nNullable!(int) min(int[]\
    \ integers) \n{\n    Nullable!(int) current;\n    foreach(i; integers) \n    {\n\
    \        if(current.isNull || i < current.get)\n            current = i;\n   \
    \ }\n    return current;\n}\nassert(min([1, 2, 3]) == 1);\n \n/*\n Out of array\
    \ of strings, return the shortest one. Return the first one in case of multiple\n\
    \    strings of the same length. Return null in case the input array is empty.\n\
    \    >>> shortest([])\n    None\n    >>> shortest([\"a\", \"b\", \"c\"])\n   \
    \ \"a\"\n    >>> shortest([\"a\", \"bb\", \"ccc\"])\n    \"a\"\n    \n*/\nNullable!(string)\
    \ shortest(string[] strings) \n{\n    Nullable!(string) current;\n    foreach(str;\
    \ strings) \n    {\n        if(current.isNull || str.length < current.get.length)\n\
    \            current = str;\n    }\n    return current;\n}\nassert(shortest([\"\
    a\", \"bb\", \"ccc\"]) == \"a\");\n \n/*\n Out of array of integers, return the\
    \ highest one. Return the first one in case of multiple\n    integers of the same\
    \ value. Return null in case the input array is empty.\n    >>> max([])\n    None\n\
    \    >>> max([1, 2, 3])\n    3\n    >>> max([", "{\n    return reduce!\"a.length\
    \ > b.length ? a : b\"(strings.init, strings.back);\n}", "{\n    Nullable!(string)\
    \ longest = null;\n    foreach(string s; strings)\n    {\n        longest = (s.length\
    \ > (longest is null ? 0 : longest.get.length) ? s : longest);\n    }\n    return\
    \ longest;\n}", "{\n    // TODO: implement this function\n    return null;\n}\n\
    unittest \n{\n    assert(longest([\"a\", \"b\", \"c\"]) == \"a\");\n    assert(longest([\"\
    a\", \"bb\", \"ccc\"]) == \"ccc\");\n}", "{\n    return std.algorithm.maxElement!(\"\
    a.length < b.length\")(strings).map!((s) => Nullable!(string)(s));\n}", "{\n \
    \   if (strings.length == 0) \n    {\n        return null;\n    }\n    int maxIndex\
    \ = 0;\n    foreach (idx, s; strings) \n    {\n        if (s.length > strings[maxIndex].length)\
    \ \n        {\n            maxIndex = idx;\n        }\n    }\n    return strings[maxIndex];\n\
    }\n/*\n Given an array of strings, return a new array containing the results of\
    \ applying the\n    provided function to each element of the array.\n    >>> mapStringToLength([\"\
    a\", \"bb\", \"ccc\"])\n    [1, 2, 3]\n*/", "{\n    if (strings.length == 0)\n\
    \        return null;\n    string best = strings[0];\n    for (string s ; strings)\n\
    \    {\n        if (s.length > best.length)\n            best = s;\n    }\n  \
    \  return best;\n}\n/*\n As above, but return an array of strings.\n    >>> longest([\"\
    a\", \"b\", \"c\"])\n    [\"a\"]\n    >>> longest([\"a\", \"bb\", \"ccc\"])\n\
    \    [\"ccc\"]\n    >>> longest([\"eee\", \"bb\", \"ccc\"])\n    [\"eee\", \"\
    ccc\"]\n */\nstring[] longest2(string[] strings) \n{\n    string[] bests;\n  \
    \  if (strings.length == 0)\n        return bests;\n    bests ~= strings[0];\n\
    \    int bestLength = strings[0].length;\n    for (string s ; strings)\n    {\n\
    \        if (s.length > bestLength)\n        {\n            bests = [s];\n   \
    \         bestLength = s.length;\n        }\n        else if (s.length == bestLength)\n\
    \        {\n            bests ~= s;\n        }\n    }\n    return bests;\n}\n\
    /*\n As above, but return a tuple of the strings and their lengths.\n    >>> longest2([\"\
    a\", \"b\", \"c\"])\n    [\"a\", 1]\n    >>> longest2([\"a\", \"bb\", \"ccc\"\
    ])\n    [\"ccc\", 3]\n    >>> longest2([\"eee\", \"bb\", \"ccc\"])\n    [\"eee\"\
    , 3]\n */\nTuple!(string[], size_t) longest3(string[] strings) \n{\n    string[]\
    \ bests;\n    size_t bestLength = 0;\n    if (strings.length != 0)\n    {\n  \
    \      bests ~= strings[0];\n        bestLength = strings[0].length;\n    }\n\
    \    for (string s ; strings)\n    {\n        if (s.length > bestLength)\n   \
    \     {\n            bests = [s];\n            bestLength = s.length;\n      \
    \  }\n        else if (s", "{\n    if (strings.length == 0)\n        return null;\n\
    \    string[int] lenghts;\n    foreach (i, s; strings) \n    {\n        lenghts[s.length]\
    \ ~= s;\n    }\n    auto l = lenghts.keys.array;\n    l.sort;\n    auto v = lenghts[l[$\
    \ - 1]];\n    return v[0];\n}\n/*\n    >>> fizzbuzz(0)\n    'FizzBuzz'\n    >>>\
    \ fizzbuzz(3)\n    'Fizz'\n    >>> fizzbuzz(5)\n    'Buzz'\n    >>> fizzbuzz(15)\n\
    \    'FizzBuzz'\n    >>> fizzbuzz(2)\n    '2'\n    \n*/\nstring fizzbuzz(size_t\
    \ n) \n{\n    string str;\n    if (n % 3 == 0) \n    {\n        str ~= \"Fizz\"\
    ;\n    }\n    if (n % 5 == 0) \n    {\n        str ~= \"Buzz\";\n    }\n    if\
    \ (str.length == 0) \n    {\n        str = n.to!string;\n    }\n    return str;\n\
    }\n/*\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>>\
    \ is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(4)\n\
    \    False\n    >>> is_prime(5)\n    True\n    >>> is_prime(6)\n    False\n  \
    \  >>> is_prime(7)\n    True\n    >>> is_prime(8)\n    False\n    >>> is_prime(9)\n\
    \    False\n    >>> is_prime(10)\n    False\n    >>> is_prime(11)\n    True\n\
    \    >>> is_prime(12)\n    False\n    >>> is_prime(13)\n    True\n    >>> is_prime(14)\n\
    \    False\n    >>> is_prime(15)\n    False\n    >>> is_prime(16)\n    False\n\
    \    >>> is_prime(17)\n    True", "{\n    Nullable!(string) winner = Nullable!(string).init;\n\
    \    foreach( string str; strings )\n    {\n        if( !winner.isNull )\n   \
    \     {\n            if( winner.get.length < str.length )\n                winner\
    \ = str;\n        }\n        else\n            winner = str;\n    }\n    return\
    \ winner;\n}", "{\n    Nullable!(string) longest;\n    foreach(str; strings) \n\
    \    {\n        if (longest.isNull || longest.get.length < str.length) \n    \
    \    {\n            longest = str;\n        }\n    }\n    return longest;\n}\n\
    //Sum of the squares of digits of a number", "{\n    if (strings.length == 0)\
    \ return null;", "    if (isInputRange!(typeof(strings), string))\n{\n    if (strings.length\
    \ == 0)\n        return null;\n    if (strings.length == 1)\n        return strings[0];\n\
    \    size_t iMaxLength = 0;\n    size_t iIndexOfLongest = 0;\n    foreach (i,\
    \ s; strings) \n    {\n        if (s.length > iMaxLength) \n        {\n      \
    \      iMaxLength = s.length;\n            iIndexOfLongest = i;\n        }\n \
    \   }\n    return strings[iIndexOfLongest];\n}", "{\n    Nullable!(string) longest\
    \ = null;\n    if (strings.length != 0)\n    {\n        longest = strings[0];\n\
    \        for (int i = 1; i < strings.length; i++)\n        {\n            if (strings[i].length\
    \ > longest.length)\n            {\n                longest = strings[i];\n  \
    \          }\n        }\n    }\n    return longest;\n}", "{\n    // start with\
    \ the first string, or null\n    Nullable!(string) longest = strings.length ?\
    \ strings[0] : null;", "{\n\tNullable!(string) output;\n\tint biggest = 0;\n\t\
    foreach(i, string str; strings) \n\t{\n\t\tint temp = str.length;\n\t\tif(temp\
    \ > biggest) \n\t\t{\n\t\t\tbiggest = temp;\n\t\t\toutput = str;\n\t\t}\n\t}\n\
    \treturn output;\n}\n/*\n\tArray of strings, remove all the strings that have\
    \ a length divisible by 2.\n\t\t>>> filterEven([\"a\", \"bb\", \"ccc\"])\n\t\t\
    [\"bb\", \"ccc\"]\n\t\t>>> filterEven([\"aa\", \"bb\", \"ccc\"])\n\t\t[\"bb\"\
    , \"ccc\"]\n\t\t>>> filterEven([\"aa\", \"bb\", \"cc\"])\n\t\t[\"bb\"]\n\t\t>>>\
    \ filterEven([\"aa\", \"bb\", \"c\"])\n\t\t[\"bb\"]\n\t\t>>> filterEven([\"aa\"\
    , \"bb\"])\n\t\t[\"bb\"]\n\t\t>>> filterEven([\"aa\", \"b\"])\n\t\t[]\n\t\t>>>\
    \ filterEven([\"a\", \"b\"])\n\t\t[\"b\"]\n\t\t>>> filterEven([\"a\"])\n\t\t[]\n\
    \t\t>>> filterEven([])\n\t\t[]\n*/\nstring[] filterEven(string[] arrayOfStrings)\
    \ \n{\n\tstring[] output;\n\tforeach(i, string s; arrayOfStrings) \n\t{\n\t\t\
    if(s.length % 2 != 0) \n\t\t{\n\t\t\toutput ~= s;\n\t\t}\n\t}\n\treturn output;\n\
    }\n/*\n\tArray of strings, return the amount of strings that have a length divisible\
    \ by 2.\n\t\t>>> countEven([\"a\", \"bb\", \"ccc\"])\n\t\t2\n\t\t>>> countEven([\"\
    aa\", \"bb\", \"ccc\"])\n\t\t2\n\t\t>>> countEven([\"aa\", \"bb\", \"cc\"])\n\t\
    \t1\n\t\t>>> countEven([\"aa\", \"bb\", \"c\"])\n\t\t1\n\t\t>>> countEven([\"\
    aa\", \"bb\"])\n\t\t1\n\t\t>>>", "{\n    if (strings.length == 0) return null;\n\
    \    else \n    {\n        size_t n = 0;\n        foreach (i, s; strings) \n \
    \       {\n            if (s.length > strings[n].length) \n            {\n   \
    \             n = i;\n            }\n        }\n        return strings[n];\n \
    \   }\n}", "{\n    Nullable!(string) result = Nullable!(string).init;\n    foreach(string\
    \ str; strings) \n    {\n        if(result.isNull || str.length > result.get.length)\n\
    \        {\n            result = str;\n        }\n    }\n    return result;\n}",
  "{\n    // auto length = lambda(const string x) { return x.length; };\n    auto\
    \ length = (const string x) { return x.length; };\n    Nullable!(string) longest\
    \ = null;\n    foreach (i, x; strings)\n    {\n        if (longest.isNull || length(x)\
    \ > length(longest.get!string))\n        {\n            longest = x;\n       \
    \ }\n    }\n    return longest;\n}\n// const max = lambda(int[] xs) { return reduce!max(xs,\
    \ 0); };\nconst max = (int[] xs) { return reduce!max(xs, 0); };", "{\n    static\
    \ struct \n    {\n        string val;\n        size_t length;\n    } longest;\n\
    \    longest.val = null;\n    longest.length = 0;\n    foreach(s; strings) \n\
    \    {\n        if(s.length > longest.length) \n        {\n            longest.val\
    \ = s;\n            longest.length = s.length;\n        }\n    }\n    return longest.val;\n\
    }\n/*\n    Take a list of integers (positive, negative, or 0), and return a sorted\n\
    \    list of the three largest integers in the input list. If the input list is\n\
    \    too small, return a list of all its elements.\n    >>> threeLargest([])\n\
    \    []\n    >>> threeLargest([42])\n    [42]\n    >>> threeLargest([7, 8, -1,\
    \ 42, 12, 0])\n    [8, 12, 42]\n*/", "{\n    if (strings.length == 0)\n      \
    \  return null;\n    \n    auto r = reduce!\"a.length > b.length\"(strings);\n\
    \    return r.reduced;\n}", "{\n    Nullable!(string) result = null;\n    foreach(string\
    \ s; strings) \n    {\n        if(result is null || s.length > result.get.length)\n\
    \            result = s;\n    }\n    return result;\n}", "{\n    return strings.length\
    \ > 0 ? strings[strings.length - 1] : typeof(return).init;\n}\n/*\n Write a function\
    \ that takes an array of numbers and returns the sum of all\n    the numbers.\n\
    \    >>> sum([2, 3, 5])\n    10\n    >>> sum([1.0, 1.0, 1.0])\n    3.0\n    >>>\
    \ sum([])\n    0\n*/\nreal sum(real[] nums)\n{\n    real res = 0;\n    foreach(num;\
    \ nums)\n    {\n        res += num;\n    }\n    return res;\n}\n/*\n Write a function\
    \ that takes an array of numbers and returns the first one\n    that is different\
    \ from the rest.\n    >>> first_different([1, 2, 3, 2, 1])\n    3\n    >>> first_different([1,\
    \ 2, 2, 2, 1])\n    1\n    >>> first_different([1, 1, 1, 1, 1])\n    1\n    >>>\
    \ first_different([])\n    None\n*/\nNullable!(real) first_different(real[] nums)\n\
    {\n    bool equal = true;\n    foreach(num; nums)\n    {\n        if(num != nums[0])\n\
    \        {\n            equal = false;\n            break;\n        }\n    }\n\
    \    return equal ? typeof(return).init : nums[0];\n}\n/*\n Write a function that\
    \ generates a random array of integers between 0 and\n    20, inclusive. The length\
    \ of the array should be 10.\n    >>> random_array()\n    [3, 16, 0, 14, 15, 18,\
    \ 10, 7, 16, 14]\n*/", "    if (allSatisfy!(isString, strings)) {\n    Nullable!(string)\
    \ res = null;\n    foreach (s; strings) {\n        if (res is null || s.length\
    \ > res.length) {\n            res = s;\n        }\n    }\n    return res;\n}",
  "{\n    //Nullable!(string) result;\n    string result;\n    result = \"\";\n  \
    \  foreach(index, str; strings)\n    {\n        if(str.length > result.length)\n\
    \        {\n            result = str;\n        }\n    }\n    return result;\n}",
  "{\n\tsize_t longestLength = 0;\n\tsize_t longestIndex = 0;\n\tforeach(index, s;\
    \ strings)\n\t{\n\t\tif(s.length > longestLength)\n\t\t{\n\t\t\tlongestLength\
    \ = s.length;\n\t\t\tlongestIndex = index;\n\t\t}\n\t}\n\treturn longestLength\
    \ > 0 ? strings[longestIndex] : Nullable!(string).init;\n}\n/*\n\tOut of array\
    \ of strings, return the shortest one. Return the first one in case of multiple\n\
    \    strings of the same length. Return null in case the input array is empty.\n\
    \    >>> shortest([])\n    None\n    >>> shortest([\"a\", \"b\", \"c\"])\n   \
    \ \"a\"\n    >>> shortest([\"a\", \"bb\", \"ccc\"])\n    \"a\"\n*/\nNullable!(string)\
    \ shortest(string[] strings) \n{\n\tsize_t shortestLength = 9999999;\n\tsize_t\
    \ shortestIndex = 0;\n\tforeach(index, s; strings)\n\t{\n\t\tif(s.length < shortestLength)\n\
    \t\t{\n\t\t\tshortestLength = s.length;\n\t\t\tshortestIndex = index;\n\t\t}\n\
    \t}\n\treturn shortestLength < 9999999 ? strings[shortestIndex] : Nullable!(string).init;\n\
    }\n/*\n\tInput is a list of integers, which could be positive, negative or zero.\n\
    \    Return the last number in the list, which is the greatest of all the numbers.\n\
    \    >>> max([])\n    None\n    >>> max([1, 2, 3])\n    3\n    >>> max([-1, -2,\
    \ -3])\n    -1\n    >>> max([0, -1, -2, -3])\n    0\n*/\nNullable!(int) max(int[]\
    \ numbers) \n{\n\tint max = 0;\n\tforeach(n; numbers)\n\t{\n\t\tif(n > max)\n\t\
    \t{\n\t\t\tmax = n;\n\t\t}\n\t}\n\treturn max > 0 ? max : Nullable!(int).init;\n\
    }\n/*\nInput is a", "{\n  return strings.reduce!\"a > b ? a : b\";\n}", "{\n \
    \   return strings.front;\n}", "{\n    if (strings.length == 0)\n        return\
    \ null;\n    \n    auto currMax = strings[0];\n    foreach (idx,s; strings) \n\
    \    {\n        if (s.length > currMax.length)\n            currMax = s;\n   \
    \ }\n    return currMax;\n}\n/*\n Given a string, return a string of the same\
    \ length with each char that's a\n    vowel in uppercase and all other chars in\
    \ lowercase.\n    >>> capitalizeVowels(\"Aabcd eEfgh iIjklm\")\n    \"AaBcd eEfgh\
    \ iIjklm\"\n*/\nstring capitalizeVowels(string s) \n{\n    auto vowels = [\"a\"\
    ,\"e\",\"i\",\"o\",\"u\"];\n    auto result = \"\";\n    foreach (c; s) \n   \
    \ {\n        if (vowels.canFind(lower(c)))\n            result ~= upper(c);\n\
    \        else\n            result ~= lower(c);\n    }\n    return result;\n}\n\
    /*\n Given a string, return a string of the same length with each char that's\
    \ a\n    vowel in uppercase and all other chars in lowercase.\n    >>> capitalizeVowels(\"\
    Aabcd eEfgh iIjklm\")\n    \"AaBcd eEfgh iIjklm\"\n*/\nstring capitalizeVowels2(string\
    \ s) \n{\n    auto vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"];\n    auto result\
    \ = \"\";\n    foreach (c; s) \n    {\n        if (c.isLetter && vowels.canFind(lower(c)))\n\
    \            result ~= upper(c);\n        else\n            result ~= lower(c);\n\
    \    }\n    return result;\n}\n/*\n Given an array of strings and a string, replace\
    \ all occurrences of the string in the array\n    with empty string.\n    >>>\
    \ replaceAll([\"abc\", \"bbc\", \"abc\"], \"abc\")\n    [\"\", \"bbc\", \"\"]\n\
    */\nstring[] replaceAll(string[] strings, string oldS) \n{\n    auto result =\
    \ strings.du", "{\n    if (strings.length == 0) return null;\n    int longest_length\
    \ = 0;\n    string longest = null;\n    foreach (string s; strings)\n    {\n \
    \       if (s.length > longest_length)\n        {\n            longest_length\
    \ = s.length;\n            longest = s;\n        }\n    }\n    return longest;\n\
    }", "{\n    if (strings.length == 0) \n    {\n        return Nullable!(string).init;\n\
    \    }\n    auto result = strings[0];\n    foreach (cur; strings) \n    {\n  \
    \      if (cur.length > result.length) \n        {\n            result = cur;\n\
    \        }\n    }\n    return result;\n}", "{\n    import std.algorithm : max;\n\
    \    return strings.empty ? null : strings.max!((a, b) => a.length < b.length).front;\n\
    }\n ", "{\n    Nullable!(string) result = null;\n    foreach(string str; strings)\
    \ \n    {\n        if(str.length > result.isNull? result.get!(string.init).length\
    \ : 0) \n        {\n            result = Nullable!(string)(str);\n        }\n\
    \    }\n    return result;\n}", "{\n    import std.algorithm;\n    return strings.empty\
    \ ? null : strings.max;\n}", "{\n    import std.conv;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.functional;\n    // FIXME: error: cannot\
    \ implicitly convert expression ((__lambda1)()) of type Nullable!(string) to Nullable!(string)\n\
    \    // return strings.empty ? null : strings.sort!((a, b) => a.length < b.length)[0];\n\
    \    return strings.empty ? null : strings.sort!((a, b) => a.length < b.length).front;\n\
    \    // return strings.empty ? null : strings.sort!((a, b) => a.length < b.length).front;\n\
    }", "{\n\tNullable!(string) longest = null;\n\tforeach(str; strings)\n\t{\n\t\t\
    if(str.length > longest.length)\n\t\t{\n\t\t\tlongest = str;\n\t\t}\n\t}\n\treturn\
    \ longest;\n}", "{\n    Nullable!(string) longest = null;\n    foreach(s; strings)\n\
    \    {\n        if(longest.isNull || longest.get.length < s.length)\n        {\n\
    \            longest = s;\n        }\n    }\n    return longest;\n}", "{\n   \
    \ if (strings.length == 0) \n    {\n        return null;\n    }\n    else \n \
    \   {\n        import std.algorithm.comparison : max;\n        return strings.max!((a,\
    \ b) => a.length < b.length)[0];\n    }\n}", "{\n    Nullable!(string) nullable\
    \ = Nullable!(string)();\n    if (strings.length == 0)\n        return nullable;\n\
    \    string result = strings[0];\n    foreach (index, element; strings)\n    {\n\
    \        if (element.length > result.length)\n            result = element;\n\
    \    }\n    return result;\n}\n//\n/*\n    Given a string and a set of characters,\
    \ return the shortest substring that contains all the\n    characters in the set.\
    \ Return null in case the input array is empty.\n    >>> shortestSubstring([\"\
    a\", \"b\", \"c\"], \"ab\")\n    \"ab\"\n    >>> shortestSubstring([\"a\", \"\
    bb\", \"ccc\"], \"abc\")\n    \"bb\"\n    >>> shortestSubstring([\"a\", \"bb\"\
    , \"ccc\"], \"ba\")\n    null\n*/\nNullable!(string) shortestSubstring(string[]\
    \ strings, string characters) \n{\n    Nullable!(string) nullable = Nullable!(string)();\n\
    \    if (strings.length == 0)\n        return nullable;\n    string[] result =\
    \ strings[0..$];\n    foreach (index, element; strings)\n    {\n        if (element.length\
    \ > characters.length)\n            continue;\n        if (element.find(characters)\
    \ != -1)\n            if (element.length < result.length)\n                result\
    \ = element;\n    }\n    if (result.length == strings.length)\n        return\
    \ nullable;\n    return result;\n}\n//\n/*\n    Out of a list of integers, return\
    \ the largest perfect square that is less than the given\n    integer n. Return\
    \ null in case there is no perfect square that is less than n.\n    >>> largestSquare(5)\n\
    \    4\n    >>> largestSquare(16)\n    9\n    >>> largestSquare(17)\n    null\n\
    */\nNullable!(size_t) largestSquare(size_t n) \n{\n    Nullable!(size_t) nullable\
    \ = Nullable!(size_t)();\n    for (size_t i = n - 1; i > 0; i--)\n    {\n    \
    \    size_t root = sq", "{\n    int maxLen = 0;\n    size_t maxIdx = 0;\n    for\
    \ (size_t i = 0; i < strings.length; i++) \n    {\n        int len = strings[i].length;\n\
    \        if (len > maxLen) \n        {\n            maxLen = len;\n          \
    \  maxIdx = i;\n        }\n    }\n    return maxLen > 0 ? Nullable!(string)(strings[maxIdx])\
    \ : Nullable!(string).init;\n}", "{\n\tif (strings.length == 0) \n    {\n\t\t\
    return null;\n\t}\n\t\n\tstring result = strings[0];\n\tforeach (s; strings) \n\
    \    {\n\t\tif (s.length > result.length) \n        {\n\t\t\tresult = s;\n\t\t\
    }\n\t}\n\treturn result;\n}", "{\n    if (strings.length == 0)\n        return\
    \ null;\n    size_t maxLen = 0;\n    string result = null;\n    foreach (string\
    \ str; strings)\n    {\n        auto length = str.length;\n        if (length\
    \ > maxLen)\n        {\n            maxLen = length;\n            result = str;\n\
    \        }\n    }\n    return result;\n}", "{\n    if (strings.length == 0) \n\
    \    {\n        return null;\n    }\n    auto longest = strings[0];\n    foreach\
    \ (string s; strings) \n    {\n        if (s.length > longest.length) \n     \
    \   {\n            longest = s;\n        }\n    }\n    return longest;\n}\n/*\n\
    \    Check if a number is a power of two.\n    >>> isPowerOfTwo(1024)\n    true\n\
    \    >>> isPowerOfTwo(1025)\n    false\n*/", "{\n    int maxLen = -1;\n    string\
    \ ret = null;\n    foreach(const string a; strings)\n    {\n        if(a.length\
    \ > maxLen) \n        {\n            maxLen = a.length;\n            ret = a;\n\
    \        }\n    }\n    return ret;\n}\n/*\nGiven a number array, return True if\
    \ there is a pair of numbers that adds up to 0.\nReturn False otherwise.", "{\n\
    \    Nullable!(string) longest;\n    if (strings.length > 0) {\n        longest\
    \ = strings[0];\n        foreach (string s; strings) {\n            if (s.length\
    \ > longest.length) {\n                longest = s;\n            }\n        }\n\
    \    }\n    return longest;\n}", "{\n    Nullable!(string) longest = null;\n \
    \   foreach(string str; strings) \n    {\n        if (longest is null || str.length\
    \ > longest.get.length) \n        {\n            longest = str;\n        }\n \
    \   }\n    return longest;\n}\n/*\n Write a function that returns a given number\
    \ as an array of digits.\n    >>> toDigits(123)\n    [1, 2, 3]\n    >>> toDigits(99999)\n\
    \    [9, 9, 9, 9, 9]\n    >>> toDigits(123023)\n    [1, 2, 3, 0, 2, 3]\n*/\nsize_t[]\
    \ toDigits(size_t n) \n{\n    size_t[] result;\n    while (n != 0) \n    {\n \
    \       size_t digit = n % 10;\n        result ~= digit;\n        n /= 10;\n \
    \   }\n    return result.reverse;\n}\n/*\n Use toDigits to implement a function\
    \ that counts how many digits a number has.\n    >>> numberLength(0)\n    1\n\
    \    >>> numberLength(123)\n    3\n    >>> numberLength(999999999999)\n    12\n\
    */\nsize_t numberLength(size_t n)\n{\n    return toDigits(n).length;\n}\n/*\n\
    \ Write a function that calculates a number raised to a given power.\n    >>>\
    \ numberPower(2, 3)\n    8\n    >>> numberPower(10, 0)\n    1\n    >>> numberPower(5,\
    \ 5)\n    3125\n*/\nsize_t numberPower(size_t number, size_t power)\n{\n    size_t\
    \ result = 1;\n    for (size_t i = 0; i < power; i++) \n    {\n        result\
    \ *= number;\n    }\n    return result;\n}\n/*\n Use toDigits and numberPower\
    \ to implement a function that calculates the n-th digit of a number.\n    >>>\
    \ nthDigit(12345, 0)\n    5\n    >>> nthDigit(12345, 3)\n    2\n    >>> nthDigit(12345,\
    \ 5)\n    0\n", "{\n\tint high = 0;\n\tint pos = 0;\n\tint count = 0;\n\tint len\
    \ = strings.length;\n\twhile(count < len)\n\t{\n\t\tif(high < strings[count].length)\n\
    \t\t{\n\t\t\thigh = strings[count].length;\n\t\t\tpos = count;\n\t\t}\n\t\tcount++;\n\
    \t}\n\tif(pos == 0 && high == 0)\n\t{\n\t\treturn null;\n\t}\n\telse\n\t{\n\t\t\
    return strings[pos];\n\t}\n}", "{\n    Nullable!(string) longest = null;\n   \
    \ foreach(string s; strings) \n    {\n        if (longest.isNull || s.length >\
    \ longest.get.length) \n        {\n            longest = s;\n        }\n    }\n\
    \    return longest;\n}", "{\n    string result = \"\";\n    foreach(string s;\
    \ strings)\n    {\n        if(s.length > result.length)\n        {\n         \
    \   result = s;\n        }\n    }\n    if(result == \"\")\n    {\n        return\
    \ null;\n    }\n    return result;\n}", "{\n    auto maybe_longest = map!(a =>\
    \ (a.length, a))(strings).max();\n    return maybe_longest.empty ? null : maybe_longest.get.second;\n\
    }\n/*\n    >>> longest([\"ab\", \"b\", \"c\"])\n    \"ab\"\n    >>> longest([\"\
    a\", \"bb\", \"ccc\"])\n    \"ccc\"\n*/", "{\n    import std.stdio;\n    Nullable!(string)\
    \ longest = null;\n    foreach(str; strings)\n    {\n        if(longest.isNull\
    \ || longest.get.length < str.length) \n        {\n            longest = str;\n\
    \        }\n    }\n    return longest;\n}", "{\n    import std.algorithm;\n  \
    \  import std.range;\n    import std.typecons;\n    import std.conv;\n    if (strings.length\
    \ == 0) \n    {\n        return null;\n    }\n    auto byLength = sort!((a, b)\
    \ => a.length > b.length);\n    auto ordered = byLength(strings);\n    auto first\
    \ = ordered.front;\n    Nullable!(string) theLongest = to!Nullable!(string)(first);\n\
    \    return theLongest;\n}", "{\n    if (strings.length == 0) \n    {\n      \
    \  return null;\n    }\n    else \n    {\n        return strings.reduce!((result,\
    \ element) => result.length > element.length ? result : element);\n    }\n}\n\
    /*\n    Return a string representing the number in words, for example, 42 -> \u201C\
    fourty two\u201D.\n    Numbers between 0 and 20 are spelled out, others are returned\
    \ as is.\n    >>> spell_number(0)\n    \"zero\"\n    >>> spell_number(2)\n   \
    \ \"two\"\n    >>> spell_number(42)\n    \"42\"\n    >>> spell_number(30)\n  \
    \  \"30\"\n*/\nstring spell_number(int n) \n{\n    switch (n) \n    {\n      \
    \  case 0: return \"zero\";\n        case 1: return \"one\";\n        case 2:\
    \ return \"two\";\n        case 3: return \"three\";\n        case 4: return \"\
    four\";\n        case 5: return \"five\";\n        case 6: return \"six\";\n \
    \       case 7: return \"seven\";\n        case 8: return \"eight\";\n       \
    \ case 9: return \"nine\";\n        case 10: return \"ten\";\n        case 11:\
    \ return \"eleven\";\n        case 12: return \"twelve\";\n        case 13: return\
    \ \"thirteen\";\n        case 14: return \"fourteen\";\n        case 15: return\
    \ \"fifteen\";\n        case 16: return \"sixteen\";\n        case 17: return\
    \ \"seventeen\";\n        case 18: return \"eighteen\";\n        case 19: return\
    \ \"nineteen\";\n        case 20: return \"twenty\";\n        default: return\
    \ n.to!string;\n    }\n}\n/*\nImplement the classic game of battleships.", "{\n\
    \    return strings.filter!(s => s.length == strings.map!(s => s.length).max).front;\n\
    }\n/*\n    for (string s; strings) \n    {\n        if (s.length == strings.map!(s\
    \ => s.length).max)\n            return s;\n    }\n    return null;\n}\n*/\n/*\n\
    \    >>> string(None)\n    \"\"\n    >>> string(Some(\"foo\"))\n    \"foo\"\n\
    */\nstring string(Nullable!(string) maybe)\n{\n    return maybe.isNull ? \"\"\
    \ : maybe.get;\n}\n/*\n >>> mostFrequent(null)\n 0\n >>> mostFrequent([])\n 0\n\
    \ >>> mostFrequent([1, 1, 1, 2, 2, 3])\n 1\n >>> mostFrequent([1, 2, 3, 3, 3,\
    \ 3])\n 3\n >>> mostFrequent([1, 2, 3, 1, 2, 3])\n 0\n*/\n// Return most frequent\
    \ number in a range. Return 0 if no such number exists.", "{\n    string result\
    \ = null;\n    foreach(s; strings)\n    {\n        if (result is null || s.length\
    \ > result.length) \n        {\n            result = s;\n        }\n    }\n  \
    \  return result;\n}\n/*\n Out of an array of floating point numbers, return the\
    \ most close one to the provided number.\n    >>> nearestTo(2.4, [1.5, 2.1, 2.5,\
    \ 2.9])\n    2.5\n    >>> nearestTo(2.4, [2.2, 2.3, 2.1])\n    2.3\n    >>> nearestTo(3.14,\
    \ [1.5, 2.1, 2.5, 2.9])\n    2.9\n    \n*/", "{\n    if (strings.length == 0)\
    \ return null;\n    int max = strings[0].length;\n    string maxString = strings[0];\n\
    \    foreach (string str; strings) \n    {\n        if (str.length > max) \n \
    \       {\n            max = str.length;\n            maxString = str;\n     \
    \   }\n    }\n    return maxString;\n}", "{\n    size_t maxLen = 0;\n    size_t\
    \ maxIndex = 0;\n    foreach(i, s; strings) \n    {\n        if (s.length > maxLen)\
    \ \n        {\n            maxLen = s.length;\n            maxIndex = i;\n   \
    \     }\n    }\n    return maxLen ? make!Nullable(strings[maxIndex]) : null;\n\
    }", "{\n    immutable ulong longestLength = 0;\n    immutable string longestString\
    \ = null;\n    foreach (string s; strings) \n    {\n        if (s.length > longestLength)\
    \ \n        {\n            longestLength = s.length;\n            longestString\
    \ = s;\n        }\n    }\n    return longestString;\n}\n/*\n Given an array of\
    \ integers, return the sum of all its elements\n    >>> sum([])\n    0\n    >>>\
    \ sum([1, 2, 3])\n    6\n    >>> sum([-10, 10, 10])\n    10\n*/", "{\n    Nullable!(string)\
    \ longest = null;\n    foreach(str; strings)\n    {\n        if (longest.isNull)\n\
    \        {\n            longest = str;\n        }\n        else if (str.length\
    \ > longest.get.length)\n        {\n            longest = str;\n        }\n  \
    \  }\n    return longest;\n}", "{\n    if (strings.length == 0)\n        return\
    \ null;\n    auto longest = strings[0];\n    foreach (string s; strings)\n   \
    \ {\n        if (s.length > longest.length)\n            longest = s;\n    }\n\
    \    return longest;\n}\n/*\n Out of array of strings, return the shortest one.\
    \ Return the first one in case of multiple\n    strings of the same length. Return\
    \ null in case the input array is empty.\n    >>> shortest([])\n    None\n   \
    \ >>> shortest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"a\", \"\
    bb\", \"ccc\"])\n    \"a\"\n*/\nNullable!(string) shortest(string[] strings) \n\
    {\n    if (strings.length == 0)\n        return null;\n    auto shortest = strings[0];\n\
    \    foreach (string s; strings)\n    {\n        if (s.length < shortest.length)\n\
    \            shortest = s;\n    }\n    return shortest;\n}\n/*\n Out of array\
    \ of strings, return the shortest one that is longer than a given length.\n  \
    \  Return the first one in case of multiple strings of the same length.\n    Return\
    \ null in case the input array is empty.\n    >>> shortestLongerThan([], 1)\n\
    \    None\n    >>> shortestLongerThan([\"a\", \"b\", \"c\"], 1)\n    \"b\"\n \
    \   >>> shortestLongerThan([\"a\", \"bb\", \"ccc\"], 1)\n    \"bb\"\n*/\nNullable!(string)\
    \ shortestLongerThan(string[] strings, size_t length) \n{\n    auto shorterThanLength\
    \ = filter!(a => a.length > length)(strings);\n    return shortest(shorterThanLength);\n\
    }\n/*\n Out of array of strings, return the longest one that is shorter than a\
    \ given length.\n    Return the first one in case of multiple strings of the same\
    \ length.\n    Return null in case the input array is empty.\n    >>> longestShorterThan([],\
    \ 1)\n    None\n    >>> longestShorterThan([\"a\", \"b\", \"c\"], 1)\n    \"a\"\
    \n    >>> longestShorterTh", "{\n    static if (strings.length == 0) \n    {\n\
    \        return null;\n    } \n    else \n    {\n        return strings.min!((a,\
    \ b) => a.length > b.length)[0];\n    }\n}", "{\n    Nullable!(string) result\
    \ = null;\n    if (strings.length)\n    {\n        import std.algorithm;\n   \
    \     result = reduce!((a, b) => (a.length > b.length) ? a : b)(strings);\n  \
    \  }\n    return result;\n}\n/*\n    The bmi function compute the BMI (Body Mass\
    \ Index) for a person with the specified height and weight.\n    >>> bmi(1.7,\
    \ 80)\n    27.681660899653975\n*/\ndouble bmi(double height, double weight) \n\
    {\n    return weight / (height * height);\n}\n/*\n    The quadratic function computes\
    \ the solution of a quadratic equation\n    with the specified coefficients.\n\
    \    >>> quadratic(1, 4, 1)\n    (-0.26794919243112270+1.7320508075688772i, -0.26794919243112270-1.7320508075688772i)\n\
    \    >>> quadratic(1, -5, 6)\n    (3, 2)\n*/\nTuple!(complex, complex) quadratic(double\
    \ a, double b, double c) \n{\n    import std.math : pow, sqrt;\n    if (a == 0)\
    \ \n    {\n        return tuple(c / b, c / b);\n    } \n    else \n    {\n   \
    \     auto D = pow(b, 2) - 4 * a * c;\n        auto sol1 = (-b + sqrt(D)) / (2\
    \ * a);\n        auto sol2 = (-b - sqrt(D)) / (2 * a);\n        return tuple(sol1,\
    \ sol2);\n    }\n}\n/*\n    The wind_chill function computes the wind chill for\
    \ a given temperature in degrees\n    Celcius and wind speed in kilometres per\
    \ hour.\n    >>> wind_chill(5, 25)\n    -3.3486805654705385\n*/\ndouble wind_chill(double\
    \ celsius, double wind_speed) \n{\n    import std.math : pow;\n    // Approximate\
    \ formula for the wind chill factor\n    // Valid for temperatures in the", "{\n\
    \tNullable!(string) ret;\n\tforeach(value; strings) \n\t{\n\t\tif(!ret.isValid)\
    \ \n\t\t{\n\t\t\tret = value;\n\t\t}\n\t\telse if(value.length > ret.get.length)\
    \ \n\t\t{\n\t\t\tret = value;\n\t\t}\n\t}\n\treturn ret;\n}", "{\n    Nullable!(string)\
    \ longest = Nullable!(string).init;\n    foreach(str; strings)\n    {\n      \
    \  static if(longest.isNull)\n        {\n            longest = str;\n        }\n\
    \        else\n        {\n            if(str.length > longest.value.length)\n\
    \            {\n                longest = str;\n            }\n        }\n   \
    \ }\n    return longest;\n}\n/*\n    Is this array of strings a pangram, that\
    \ is, does it contain all the letters of the English alphabet?\n    >>> isPangram([\"\
    the\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\",\
    \ \"dog\"])\n    True\n    >>> isPangram([\"a\", \"bb\", \"ccc\"])\n    False\n\
    */", "{\n    size_t len = strings.length;\n    if (len == 0) \n    {\n       \
    \ return null;\n    }\n    else \n    {\n        string result = strings[0];\n\
    \        foreach (size_t i, ref string s; strings) \n        {\n            if\
    \ (s.length > result.length) \n            {\n                result = s;\n  \
    \          }\n        }\n        return result;\n    }\n}", "{\n  string longest;\n\
    \  foreach(string str; strings)\n  {\n    if(!longest.length || str.length > longest.length)\n\
    \      longest = str;\n  }\n  return longest;\n}\n/*\n Get a list of unique elements\
    \ from the input.\n    >>> distinct([\"a\", \"b\", \"a\", \"c\"])\n    [\"a\"\
    , \"b\", \"c\"]\n    >>> distinct([])\n    []\n*/\nstring[] distinct(string[]\
    \ list)\n{\n  auto result = new string[];\n  foreach(string str; list)\n  {\n\
    \    if(!result.length || result.indexOf(str) == -1)\n      result ~= str;\n \
    \ }\n  return result;\n}\n/*\n Group the input strings by their length.\n    >>>\
    \ groupByLength([\"a\", \"bb\", \"c\", \"ddd\"])\n    [[\"a\", \"c\"], [\"bb\"\
    ], [\"ddd\"]]\n    >>> groupByLength([])\n    []\n*/\nstring[][] groupByLength(string[]\
    \ strings)\n{\n  auto result = new string[][];\n  foreach(string str; strings)\n\
    \  {\n    bool found = false;\n    foreach(string[] array; result)\n    {\n  \
    \    if(array.length && array[0].length == str.length)\n      {\n        array\
    \ ~= str;\n        found = true;\n        break;\n      }\n    }\n    if(!found)\n\
    \    {\n      result ~= new string[str];\n    }\n  }\n  return result;\n}\n/*\n\
    \ Given a list of strings, find the longest common prefix.\n    >>> longestCommonPrefix([\"\
    ab\", \"abc\", \"a\"])\n    \"a\"\n    >>> longestCommonPrefix([\"ab\", \"c\"\
    , \"ddd\"])\n    \"\"\n    >>> longestCommonPrefix([])\n    \"\"\n*/\nstring longestCommonPrefix(string[]\
    \ strings)\n{\n  string result;\n  if(!strings.length)\n    return result;\n \
    \ uint min_length = strings[0].length;\n  foreach(string str; strings)\n  {\n\
    \    min_length", "{\n    Nullable!(string) result = Nullable!(string).init;\n\
    \    foreach(idx, str; strings) \n    {\n        if(result.isNull || str.length\
    \ > result.get!.length)\n        {\n            result = Nullable!(string)(str);\n\
    \        }\n    }\n    return result;\n}", "{\n    if (strings.length == 0) \n\
    \    {\n        return null;\n    }\n    else \n    {\n        string longest;\n\
    \        foreach (string s; strings) \n        {\n            if (s.length > longest.length)\
    \ \n            {\n                longest = s;\n            }\n        }\n  \
    \      return longest;\n    }\n}", "{\n    if (strings.length == 0) return null;\n\
    \    Nullable!(string) result = strings[0];\n    int maxLen = strings[0].length;\n\
    \    foreach (string s; strings) \n    {\n        int len = s.length;\n      \
    \  if (len > maxLen)\n        {\n            maxLen = len;\n            result\
    \ = s;\n        }\n    }\n    return result;\n}", "{\n    Nullable!(string) result\
    \ = Nullable!(string).init;\n    foreach(str; strings)\n    {\n        if (str.length\
    \ > result.get.length) result = str;\n    }\n    return result;\n}\n/*\n    Take\
    \ an array of strings and return a list of tuples, each containing the length\
    \ of the string,\n    and the string itself.\n    >>> lengths([\"a\", \"bb\",\
    \ \"ccc\"])\n    [(1, \"a\"), (2, \"bb\"), (3, \"ccc\")]\n*/", "{\n    Nullable!(string)\
    \ longest = Nullable!(string).init;\n    for (string s; s = strings.popFront())\
    \ \n    {\n        if (!longest.isNull && s.length < longest.get.length) \n  \
    \      {\n            continue;\n        }\n        longest = s;\n    }\n    return\
    \ longest;\n}", "{\n    auto result = filter!(a => a.length == max(map!(a => a.length)(strings)))(strings);\n\
    \    return result.length ? result[0] : null;\n}", "{\n    if (strings.length\
    \ == 0)\n        return null;\n    else\n    {\n        auto best = strings[0];\n\
    \        foreach (str; strings)\n            if (str.length > best.length)\n \
    \               best = str;\n        return best;\n    }\n}", "{\n    Nullable!(string)\
    \ result = null;\n    foreach(string s; strings)\n    {\n        if(s.length >\
    \ result.length)\n        {\n            result = s;\n        }\n    }\n    return\
    \ result;\n}\n/*\n Count the number of times a substring appears in a string.\n\
    \    >>> substrCount(\"abba\", \"bb\")\n    1\n    >>> substrCount(\"abbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb",
  "{\n    if (strings.length == 0)\n        return null;\n    auto longestString =\
    \ strings[0];\n    foreach (index, string; strings) \n    {\n        if (string.length\
    \ > longestString.length)\n            longestString = string;\n    }\n    return\
    \ longestString;\n}", "{\n    auto result = null;\n    foreach(str; strings) \n\
    \    {\n        if (str.length > result.length) \n        {\n            result\
    \ = str;\n        }\n    }\n    return result;\n}", "{\n    if (strings.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        auto s\
    \ = strings[0];\n        for (auto e : strings)\n        {\n            if (e.length\
    \ > s.length) \n            {\n                s = e;\n            }\n       \
    \ }\n        return to!(Nullable!(string))(s);\n    }\n}\n/*\n   Write a function\
    \ that takes two numbers and returns a list of their prime factors.\n    >>> prime_factors(1,\
    \ 2)\n    [[], [2]]\n    >>> prime_factors(2, 3)\n    [[2], [3]]\n    >>> prime_factors(8,\
    \ 9)\n    [[2, 2, 2], [3, 3]]\n    \n*/\nsize_t[][] prime_factors(size_t x, size_t\
    \ y) \n{\n    size_t[][] res = new size_t[2][];\n    res[0] = prime_factors(x);\n\
    \    res[1] = prime_factors(y);\n    return res;\n}\nsize_t[] prime_factors(size_t\
    \ x) \n{\n    size_t[] res = new size_t[];\n    size_t d = 2;\n    while (x >\
    \ 1) \n    {\n        while (x % d == 0) \n        {\n            res ~= d;\n\
    \            x /= d;\n        }\n        d += 1;\n    }\n    return res;\n}\n\
    /*\n    A permutation of numbers 1, 2, ..., n is called beautiful if there are\
    \ no adjacent elements whose difference is 1.", "{\n    Nullable!(string) result\
    \ = Nullable!(string).init;\n    foreach(elem; strings)\n    {\n        if(result.isNull()\
    \ || result.get.length < elem.length)\n        {\n            result = elem;\n\
    \        }\n    }\n    return result;\n}", "{\n    Nullable!(string) result =\
    \ null;\n    foreach(string s; strings)\n    {\n        if(result.isNull)\n  \
    \      {\n            result = s;\n        }\n        else if(s.length > result.get!(string).length)\n\
    \        {\n            result = s;\n        }\n    }\n    return result;\n}",
  "{\n    if (strings.length == 0) \n    {\n        return null;\n    }\n    size_t\
    \ max = 0;\n    Nullable!(string) longest = null;\n    for (size_t i = 0; i <\
    \ strings.length; i++) \n    {\n        if (strings[i].length > max) \n      \
    \  {\n            max = strings[i].length;\n            longest = to!string(strings[i]);\n\
    \        }\n    }\n    return longest;\n}\n/*\n    Write a function that returns\
    \ a tuple of a string and an integer. The string should be the concatenation of\
    \ an even number of strings that take turns being \"Hello\" and \"world\".\n \
    \   The integer should be the sum of the lengths of all strings passed as parameters.\n\
    \    >>> helloWorldTuple(\"a\", \"bb\", \"ccc\")\n    (\"Hello world Hello world\
    \ Hello \", 12)\n    \n*/\ntuple!(string, size_t) helloWorldTuple(string[] strings)\
    \ \n{\n    size_t sum = 0;\n    string world = \"world\";\n    string hello =\
    \ \"Hello\";\n    string result = \"\";\n    size_t i = 0;\n    while (i < strings.length)\
    \ \n    {\n        sum += strings[i].length;\n        result ~= world;\n     \
    \   i++;\n        if (i < strings.length) \n        {\n            sum += strings[i].length;\n\
    \            result ~= hello;\n            i++;\n        }\n    }\n    return\
    \ tuple(result, sum);\n}\n/*\n    Write a function that takes an array of strings\
    \ as argument and returns a tuple of the same size where each element is a tuple\
    \ of a bool and a string.\n    The bool in the first tuple should be true if the\
    \ string has length greater than 2 and false otherwise.\n    The bool in the second\
    \ tuple should be true if the string is \"b\" and false otherwise.\n    The bool\
    \ in the third tuple should be true if the string has length greater than 1 and\
    \ false otherwise.\n    >>> boolsAndStrings([\"a\", \"b\", \"c\"])\n    ((false,\
    \ \"a\"), (true, \"b\"), (true, \"c\"))\n    \n*/\nt", "{\n    if (strings.length\
    \ == 0) return null;\n    Nullable!(string) max = strings[0];\n    size_t maxLen\
    \ = max.length;\n    foreach (str; strings) \n    {\n        size_t len = str.length;\n\
    \        if (len > maxLen)\n        {\n            max = str;\n            maxLen\
    \ = len;\n        }\n    }\n    return max;\n}", "{\n  Nullable!(string) result\
    \ = Nullable!(string).init;\n  foreach(string s; strings)\n  {\n    if (result.isNull\
    \ || s.length > result.get.length)\n    {\n      result = to!Nullable(s);\n  \
    \  }\n  }\n  return result;\n}", "{\n    if (strings.length == 0) \n    {\n  \
    \      return null;\n    }\n    else \n    {\n        int max_length = strings[0].length;\n\
    \        int max_idx = 0;\n        foreach (i, s; strings) \n        {\n     \
    \       if (s.length > max_length) \n            {\n                max_length\
    \ = s.length;\n                max_idx = i;\n            }\n        }\n      \
    \  return strings[max_idx];\n    }\n}", "{\n    Nullable!(string) result = null;\n\
    \    foreach(string s; strings)\n    {\n        if (result.isNull || s.length\
    \ > result.get.length)\n        {\n            result = s;\n        }\n    }\n\
    \    return result;\n}", "{\n    import std.algorithm;\n    import std.functional;\n\
    \    import std.range;\n    import std.typecons;\n    /*\n    auto a = strings.filter!(s\
    \ => s.length > 0).map!(s => s.length).max();\n    return a.isSome ? strings[a.get]\
    \ : null;\n    */\n    //better way\n    return strings.filter!(s => s.length\
    \ > 0).sort!((a, b) => a.length > b.length).front;\n}\n/*\n >>> longest([\"a\"\
    , \"bb\", \"ccc\"])\n \"ccc\"\n */\nunittest\n{\n    auto a = longest([\"a\",\
    \ \"bb\", \"ccc\"]);\n    assert(a == \"ccc\");\n}", "{\n    Nullable!(string)\
    \ longest = Nullable!(string).init;\n    foreach(string str; strings) \n    {\n\
    \        if (longest.isNull || str.length > longest.get.length) \n        {\n\
    \            longest = Nullable!(string).init(str);\n        }\n    }\n    return\
    \ longest;\n}", "{\n    import std.algorithm;\n    import std.range;\n    return\
    \ strings.length ? max(strings, (a, b) => a.length > b.length).front : Nullable!(string).init;\n\
    }", "{\n    Nullable!(string) result = null;\n    foreach(string s; strings) \n\
    \    {\n        if (result is null || s.length > result.idup.length) \n      \
    \  {\n            result = s;\n        }\n    }\n    return result;\n}", "{\n\
    \    if (strings.length == 0)\n        return null;\n    \n    size_t maxLen =\
    \ 0;\n    string maxLenStr = null;\n    foreach (str; strings) \n    {\n     \
    \   if (str.length > maxLen) \n        {\n            maxLen = str.length;\n \
    \           maxLenStr = str;\n        }\n    }\n    return maxLenStr;\n}\n \n\
    /*\n    Return the longest string that is the prefix of a and b.\n    >>> commonPrefix(\"\
    flow\", \"flower\")\n    \"fl\"\n    >>> commonPrefix(\"dog\", \"cat\")\n    \"\
    \"\n*/\nstring commonPrefix(string a, string b) \n{\n    size_t len = min(a.length,\
    \ b.length);\n    size_t i = 0;\n    for (; i < len; i++) \n    {\n        if\
    \ (a[i] != b[i])\n            break;\n    }\n    return a[0 .. i];\n}\n \n/*\n\
    \    Out of array of strings, return the one that has the most common prefix with\
    \ the first string.\n    Return the first one in case of multiple strings of the\
    \ same length.\n    Return null in case the input array is empty.\n    >>> closest([])\n\
    \    None\n    >>> closest([\"flow\", \"flower\", \"flight\"])\n    \"flower\"\
    \n    >>> closest([\"dog\", \"cat\", \"dove\"])\n    \"dog\"\n*/\nNullable!(string)\
    \ closest(string[] strings) \n{\n    if (strings.length == 0)\n        return\
    \ null;\n    \n    string closestStr = null;\n    size_t maxLen = 0;\n    foreach\
    \ (str; strings) \n    {\n        string prefix = commonPrefix(strings[0], str);\n\
    \        if (prefix.length > maxLen) \n        {\n            maxLen = prefix.length;\n\
    \            closestStr = str;\n        }\n    }\n    return closestStr;\n}\n ",
  "{\n    Nullable!(string) result = null;\n    foreach(str; strings)\n    {\n   \
    \     if(str.length > result.getOrElse(str).length)\n        {\n            result\
    \ = new Nullable!(string)(str);\n        }\n    }\n    return result;\n}\nunittest\
    \ \n{\n    assert(longest([\"abc\", \"xyz\"]) == \"xyz\");\n    assert(longest([\"\
    abc\", \"xyz\"]) == \"xyz\");\n    assert(longest([\"abc\", \"xyz\", \"hg\"])\
    \ == \"xyz\");\n    assert(longest([\"abc\", \"xyz\", \"hg\", \"b\"]) == \"xyz\"\
    );\n    assert(longest([\"abc\", \"xyz\", \"hg\", \"b\", \"zzzz\"]) == \"zzzz\"\
    );\n    assert(longest([\"abc\", \"xyz\", \"hg\", \"b\", \"zzzz\", \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
  "{\n    Nullable!(string) result = Nullable!(string).init;\n    foreach(str; strings)\n\
    \    {\n        result = str.length > result.value.length ? str : result;\n  \
    \  }\n    return result;\n}", "{\n    if (strings.length == 0)\n        return\
    \ null;\n    auto longestString = strings[0];\n    foreach (index, string; strings)\
    \ \n    {\n        if (longestString.length < string.length)\n            longestString\
    \ = string;\n    }\n    return longestString;\n}", "{\n\tauto ret = Nullable!(string)(null);\n\
    \tint max_length = 0;\n\tforeach(i, s; strings)\n\t{\n\t\tif(s.length > max_length)\n\
    \t\t{\n\t\t\tmax_length = s.length;\n\t\t\tret = s;\n\t\t}\n\t}\n\treturn ret;\n\
    }", "{\n\tNullable!(string) result;\n\tif (strings.length > 0)\n\t{\n\t\tresult\
    \ = strings[0];\n\t\tforeach (index, s; strings)\n\t\t{\n\t\t\tif (s.length >\
    \ result.get.length)\n\t\t\t{\n\t\t\t\tresult = s;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "{\n    Nullable!(string) longest;\n    // looping through array\
    \ to find the longest string\n    foreach(s; strings)\n    {\n        if(!longest.isNull\
    \ && longest.get.length < s.length)\n        {\n            longest = s;\n   \
    \     }\n        else if(longest.isNull)\n        {\n            longest = s;\n\
    \        }\n    }\n    return longest;\n}", "{\n    if (strings.length == 0) \n\
    \    {\n        return null;\n    }\n    auto longestString = strings[0];\n  \
    \  foreach (string str; strings) \n    {\n        if (str.length > longestString.length)\
    \ \n        {\n            longestString = str;\n        }\n    }\n    return\
    \ longestString;\n}", "{\n    // find biggest string\n    Nullable!(size_t) iMax\
    \ = null;\n    foreach (i, string; strings) \n    {\n        // if current string\
    \ length bigger than max length\n        if (iMax is null || string.length > strings[iMax].length)\
    \ \n        {\n            // update max length\n            iMax = i;\n     \
    \   }\n    }\n    // return longest string if exists\n    return iMax is null\
    \ ? null : strings[iMax];\n}", "{\n    if (strings.length == 0) return null;\n\
    \    return strings.reduce!((x,y) => x.length > y.length ? x : y);\n}", "{\n \
    \   Nullable!(string) result = null;\n    int longest = 0;\n    foreach(string\
    \ s; strings)\n    {\n        if(s.length > longest)\n        {\n            longest\
    \ = s.length;\n            result = s;\n        }\n    }\n    return result;\n\
    }\n/*\n    Reverse a string.\n    >>> reverse(\"abc\")\n    \"cba\"\n    >>> reverse(\"\
    \")\n    \"\"\n*/\nstring reverse(string s)\n{\n    int end = s.length - 1;\n\
    \    string result = s[0..$];\n    foreach(i; 0..end/2)\n    {\n        string\
    \ tmp = result[i];\n        result[i] = result[end - i];\n        result[end -\
    \ i] = tmp;\n    }\n    return result;\n}", "{\n    enum longestSoFar = 0; //\
    \ the longest string so far\n    Nullable!(string) longest = Nullable!(string).init;\n\
    \    foreach (i, s; strings) {\n        if (s.length > longestSoFar) {\n     \
    \       longestSoFar = s.length;\n            longest = s;\n        }\n    }\n\
    \    return longest;\n}\n/*\n    Given an array of strings, sort it by length.\n\
    \    >>> sortByLength([\"a\", \"bb\", \"ccc\"])\n    [\"a\", \"bb\", \"ccc\"]\n\
    \    >>> sortByLength([\"ccc\", \"bb\", \"a\"])\n    [\"a\", \"bb\", \"ccc\"]\n\
    */\nstring[] sortByLength(string[] strings) \n{\n    sort!((a, b) => a.length\
    \ > b.length)(strings);\n    return strings;\n}", "{\n    if (strings.length ==\
    \ 0) return null;\n    int max = strings[0].length;\n    int maxI = 0;\n    foreach\
    \ (i, s; strings)\n    {\n        if (s.length > max)\n        {\n           \
    \ max = s.length;\n            maxI = i;\n        }\n    }\n    return strings[maxI];\n\
    }", "{\n    if (strings.length == 0)\n        return null;\n    \n    // this\
    \ function has a side effect: it modifies the array by sorting it\n    sort(strings);\n\
    \    \n    return strings[$-1];\n}", "    {\n    Nullable!(string) result;\n \
    \   if (strings.length == 0)\n        {\n        result = Nullable!(string).init;\n\
    \        }\n    else\n        {\n        string current = strings[0];\n      \
    \  foreach (string stringItem; strings)\n            {\n            if (stringItem.length\
    \ > current.length)\n                {\n                current = stringItem;\n\
    \                }\n            }\n        result = Nullable!(string).of(current);\n\
    \        }\n    return result;\n    }", "{\n    if (strings.length == 0)\n   \
    \     return Nullable!(string)();\n    size_t maxIndex = 0;\n    size_t maxLength\
    \ = strings[0].length;\n    foreach (index, str; strings) \n    {\n        if\
    \ (str.length > maxLength) \n        {\n            maxIndex = index;\n      \
    \      maxLength = str.length;\n        }\n    }\n    return Nullable!(string)(strings[maxIndex]);\n\
    }", "{\n    if (strings.length == 0)\n        return null;\n    return  max(strings,\
    \ (a, b) => a.length < b.length).front;\n}\n \n // Write a function that, given\
    \ a character and a non-empty string, \n // returns the index of the last occurrence\
    \ of that character in the string.\n // Return -1 if the character does not occur.\n\
    \ // findLastIndex('d', \"addam\") # 4\n // findLastIndex('a', \"addam\") # 3\n\
    \ // findLastIndex('z', \"addam\") # -1\n \n int findLastIndex(string s, in char\
    \ c) \n {\n     return s.length - 1 - s.retro.indexOf(c);\n }\n \n /*\n    Given\
    \ a string, return an array of all non-empty substrings of the string\n    >>>\
    \ substrings(\"abc\")\n    [\"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\"]\n */\n\
    string[] substrings(string s) \n{\n    auto result = new string[];\n    foreach\
    \ (i; 0 .. s.length)\n        foreach (j; i .. s.length)\n            result ~=\
    \ s[i .. j];\n    return result;\n}\n \n /*\n    Given a string, return an array\
    \ of all possible anagrams of the string.\n    >>> anagrams(\"abc\")\n    [\"\
    abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\nstring[] anagrams(string\
    \ s) \n{\n    static void helper(string[] result, string prefix, string suffix)\
    \ \n    {\n        if (suffix.length == 0)\n            result ~= prefix;\n  \
    \      else \n        {\n            foreach (i, char c; suffix)\n           \
    \     helper(result, prefix ~ c, suffix[0 .. i] ~ suffix[i + 1 .. $]);\n     \
    \   }\n    }\n    \n    auto result = new string[];\n    helper(result, \"\",\
    \ s);\n    return result;\n}\n \n /*\n    Given a string, return an array of all\
    \ possible characters\n    that can be inserted in the middle of the string to\
    \ make two new", "{\n    import std.algorithm : max, map;\n    return strings.max!((s1,\
    \ s2) => s1.length < s2.length).map!(s => s);\n}\n/*\n Out of array of positive\
    \ integers, return the one closest to zero. Return null in case the\n    input\
    \ array is empty.\n    >>> closest([])\n    None\n    >>> closest([5, 4, -9, 6,\
    \ -10, -1, 8])\n    -1\n*/\nNullable!(int) closest(int[] numbers) \n{\n    import\
    \ std.algorithm : min, map;\n    return numbers.min!((s1, s2) => abs(s1) < abs(s2)).map!(n\
    \ => n);\n}\n/*\n Out of array of integers, return the one closest to zero. Return\
    \ null in case the input\n    array is empty.\n    >>> closest([])\n    None\n\
    \    >>> closest([5, 4, -9, 6, -10, -1, 8])\n    -1\n    >>> closest([5, 4, -9,\
    \ 6, 10, 1, 8])\n    1\n*/\nNullable!(int) closest(int[] numbers) \n{\n    import\
    \ std.algorithm : min, map;\n    return numbers.min!((s1, s2) => abs(s1) < abs(s2)).map!(n\
    \ => n);\n}\n/*\n Out of array of integers, return one closest to zero. If there\
    \ are two equally distant\n    integers, return the smallest one. Return null\
    \ in case the input array is empty.\n    >>> closest([])\n    None\n    >>> closest([5,\
    \ 4, -9, 6, -10, -1, 8])\n    -1\n    >>> closest([5, 4, -9, 6, 10, 1, 8])\n \
    \   1\n*/\nNullable!(int) closest(int[] numbers) \n{\n    import std.algorithm\
    \ : min, map;\n    return numbers.min!((s1, s2) => abs(s1) == abs(s2) ? s1 < s2\
    \ : abs(s1) < abs(s2)).map!(n => n);\n}\n/*\n", "    if( isInputRange!(typeof(strings),string)\
    \ && !isSomeString!(typeof(strings)) ) {\n        if( strings.length == 0 ) {\n\
    \            return Nullable!(string)();\n        }\n        else {\n        \
    \    int biggestLen = strings[0].length;\n            string biggestStr = strings[0];\n\
    \            for( auto x : strings ) {\n                if( x.length > biggestLen\
    \ ) {\n                    biggestLen = x.length;\n                    biggestStr\
    \ = x;\n                }\n            }\n            return Nullable!(string)(biggestStr);\n\
    \        }\n    }", "{\n    if (strings.length == 0)\n        return null;\n \
    \   if (strings.length == 1)\n        return strings[0];\n    else\n    {\n  \
    \      auto len = strings[0].length;\n        size_t i = 0;\n        size_t index\
    \ = 0;\n        foreach (j, s; strings)\n        {\n            if (s.length >\
    \ len)\n            {\n                len = s.length;\n                index\
    \ = j;\n            }\n        }\n        return strings[index];\n    }\n}\n/*\n\
    \ Given the number of Bases n, the number of Runs b and the number of Out n, return\
    \ the\n    average number of Batting Average. In case no hits have been made,\
    \ the Batting Average\n    should be 0. Round the result to three decimal places.\n\
    \    >>> battingAvg(0, 0, 0)\n    0.000\n    >>> battingAvg(5, 10, 2)\n    0.400\n\
    \    >>> battingAvg(3, 0, 2)\n    0.667\n    >>> battingAvg(2, 3, 0)\n    0.000\n\
    \    >>> battingAvg(2, 3, 1)\n    0.333\n*/\ndouble battingAvg(int bases, int\
    \ runs, int outs) \n{\n    if (bases == 0 && runs == 0)\n        return 0.0;\n\
    \    return (double)bases / (double)(runs + outs);\n}\n/*\n Given a string s,\
    \ return true if it is a valid email address, and false otherwise.\n    >>> validEmail(\"\
    a@b.c\")\n    true\n    >>> validEmail(\"a.b@c\")\n    true\n    >>> validEmail(\"\
    a@b.c.d\")\n    true\n    >>> validEmail(\"a@b.c.\")\n    false\n    >>> validEmail(\"\
    @b.c\")\n    false\n    >>> validEmail(\"a@\")\n    false\n    >>> validEmail(\"\
    a.b@c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.a.b.c.d.e.f.g.", "{\n    string\
    \ result = null;\n    foreach(i, str; strings) \n    {\n        if(result.length\
    \ < str.length)\n            result = str;\n    }\n    return to!Nullable(result);\n\
    }", "{\n  if (strings.length == 0)\n  {\n    return null;\n  }\n  else\n  {\n\
    \    string longest = strings[0];\n    for (string i; i = strings.front; strings.popFront())\n\
    \    {\n      if (i.length > longest.length)\n      {\n        longest = i;\n\
    \      }\n    }\n    return longest;\n  }\n}", "{\n\tNullable!(string) longest\
    \ = null;\n\tforeach(string str; strings)\n\t{\n\t\tif(longest is null || str.length\
    \ > longest.length)\n\t\t{\n\t\t\tlongest = str;\n\t\t}\n\t}\n\treturn longest;\n\
    }", "{\n    Nullable!(string) result = null;\n    foreach(s; strings)\n    {\n\
    \        if (result.isNull || s.length > result.get.length)\n        {\n     \
    \       result = s;\n        }\n    }\n    return result;\n}", "{\n    Nullable!(string)\
    \ result = null;\n    foreach(string str; strings) \n    {\n        if(result.isNull\
    \ || result.get.length < str.length) \n        {\n            result = str;\n\
    \        }\n    }\n    return result;\n}", "{\n    if (strings.length == 0)\n\
    \        return null;\n    \n    size_t maxLength = 0;\n    size_t maxIndex =\
    \ 0;\n    foreach (i, s; strings)\n    {\n        if (s.length > maxLength)\n\
    \        {\n            maxLength = s.length;\n            maxIndex = i;\n   \
    \     }\n    }\n    return strings[maxIndex];\n}", "{\n    if (strings.length\
    \ == 0) return null;\n    auto max = strings[0];\n    foreach (i, str; strings)\n\
    \    {\n        if (str.length > max.length) max = str;\n    }\n    return max;\n\
    }\n// Write a function that returns the n first elements of a Fibonacci sequence.\n\
    string[] fibonacci(in size_t n)\n{\n    if (n == 0) return [];\n    if (n == 1)\
    \ return [\"0\"];\n    if (n == 2) return [\"0\", \"1\"];\n    string[] fib =\
    \ new string[](n);\n    fib[0] = \"0\";\n    fib[1] = \"1\";\n    for (size_t\
    \ i = 2; i < n; i++)\n    {\n        fib[i] = (to!int(fib[i - 1]) + to!int(fib[i\
    \ - 2])).to!string;\n    }\n    return fib;\n}\nstruct Employee\n{\n    string\
    \ name;\n    int salary;\n    string division;\n}\n/*\n Given a database file,\n\
    \ - Return the names of all employees with a salary > X.\n - Return the name of\
    \ the division with the most employees.\n - Return the name of the division with\
    \ the highest salary.\n - Return the division with the largest salary gap (highest\
    \ salary - lowest salary)\n*/\nEmployee[] loadEmployees(string filename)\n{\n\
    \    import std.stdio : writefln;\n    File file = File(filename, \"r\");\n  \
    \  Employee[] employees;\n    bool firstLine = true;\n    foreach (line; file.byLine())\n\
    \    {\n        if (firstLine)\n        {\n            firstLine = false;\n  \
    \          continue;\n        }\n        string[] tokens = line.split(\",\");\n\
    \        Employee e;\n        e.name = tokens[0];\n        e.salary = to!int(tokens[1]);\n\
    \        e.division = tokens[2];\n        employees ~= e;\n    }\n    file.close();\n\
    \    return employees;\n}\n// Return the names of all employees with a salary\
    \ > X.\nstring[] salGreaterThan", "{\n    if (strings.length == 0) \n    {\n \
    \       return null;\n    }\n    string longest = strings[0];\n    foreach (string\
    \ str; strings) \n    {\n        if (str.length > longest.length) \n        {\n\
    \            longest = str;\n        }\n    }\n    return longest;\n}", "{\n\t\
    if (strings.length == 0)\n\t\treturn Nullable!(string)();\n\t\n\tstring result\
    \ = strings[0];\n\tforeach (string s; strings)\n\t{\n\t\tif (s.length > result.length)\n\
    \t\t\tresult = s;\n\t}\n\treturn Nullable!(string)(result);\n}", "{\n    size_t\
    \ longest = 0;\n    auto index = 0;\n    foreach(str; strings)\n    {\n      \
    \  if(str.length > longest)\n        {\n            longest = str.length;\n  \
    \          index = strings.indexOf(str);\n        }\n    }\n    return strings.length\
    \ != 0 ? typeof(return).init : null;\n}\n/*\n Out of array of strings, return\
    \ the shortest one. Return the first one in case of multiple\n    strings of the\
    \ same length. Return null in case the input array is empty.\n    >>> shortest([])\n\
    \    None\n    >>> shortest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"\
    a\", \"bb\", \"ccc\"])\n    \"a\"\n    >>> shortest([\"a\", \"bbb\", \"ccc\"])\n\
    \    \"a\"\n*/\nNullable!(string) shortest(string[] strings) \n{\n    size_t shortest\
    \ = max;\n    auto index = 0;\n    foreach(str; strings)\n    {\n        if(str.length\
    \ < shortest)\n        {\n            shortest = str.length;\n            index\
    \ = strings.indexOf(str);\n        }\n    }\n    return strings.length != 0 ?\
    \ typeof(return).init : null;\n}\n/*\n Out of array of strings, return the string\
    \ of smallest alphabetical order.\n    Return the first one in case of multiple\
    \ strings of the same order.\n    Return null in case the input array is empty.\n\
    \    >>> earliest([])\n    None\n    >>> earliest([\"a\", \"b\", \"c\"])\n   \
    \ \"a\"\n    >>> earliest([\"c\", \"b\", \"a\"])\n    \"a\"\n    >>> earliest([\"\
    ccc\", \"aaa\", \"bbb\"])\n    \"aaa\"\n*/\nNullable!(string) earliest(string[]\
    \ strings) \n{\n    immutable string temp;\n    immutable size_t length = strings.length;\n\
    \    if(length == 0)\n        return null;\n    foreach(str; strings)\n    {\n\
    \        if(temp > str)\n            temp = str;\n    }\n    return temp;\n}\n\
    /*\n Out of array", "{\n    Nullable!(string) longest;\n    foreach(string s;\
    \ strings)\n    {\n        if(!longest.isNull)\n        {\n            if(s.length\
    \ > longest.get.length)\n            {\n                longest = s;\n       \
    \     }\n        }\n        else\n        {\n            longest = s;\n      \
    \  }\n    }\n    return longest;\n}\n// Case 2", "{\n\tif (strings.length == 0)\
    \ \n\t{\n\t\treturn null;\n\t}\n\t\n\tstring result = strings[0];\n\tforeach (string\
    \ str; strings) \n\t{\n\t\tif (str.length > result.length) \n\t\t{\n\t\t\tresult\
    \ = str;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    string result = \"\";\n  \
    \  Nullable!(string) resultNullable = Nullable!(string)(result);\n    foreach(string\
    \ s; strings)\n    {\n        if(s.length > result.length)\n        {\n      \
    \      result = s;\n            resultNullable = Nullable!(string)(result);\n\
    \        }\n    }\n    return resultNullable;\n}", "{\n    if (strings.length\
    \ == 0)\n        return null;\n    auto result = strings[0];\n    foreach (str;\
    \ strings)\n    {\n        if (str.length > result.length)\n            result\
    \ = str;\n    }\n    return result;\n}", "{\n    // Single line solution using\
    \ std.algorithm.maxElement\n    // return strings.empty ? null : strings[maxElement(strings,\
    \ (a, b) => a.length > b.length).idup];\n    \n    // More elaborated solution\n\
    \    Nullable!(string) result = null;\n    foreach (string s; strings)\n    {\n\
    \        if (result is null || s.length > result.get!.length)\n        {\n   \
    \         result = s;\n        }\n    }\n    return result;\n}", "{\n    Nullable!(string)\
    \ result = Nullable!(string).init;\n    if(strings.length > 0)\n    {\n      \
    \  import std.algorithm : max;\n        import std.range : iota;\n        result\
    \ = max(strings, (a, b) => a.length > b.length).front;\n    }\n    return result;\n\
    }", "{\n  import std.algorithm.iteration : map, max;\n  if (strings.empty)\n \
    \   return null;\n  else\n    return strings[strings.map!(a => a.length).max!((a,\
    \ b) => a > b)];\n}", "{\n    Nullable!(string) result = Nullable!(string).init;\n\
    \    foreach(str; strings)\n    {\n        if(str.length > result.value.length)\n\
    \        {\n            result.value = str;\n        }\n    }\n    return result;\n\
    }\n/*\n Group items of the given string array by the length of the string, sorted\
    \ ascending by the string length, then alphabetically by the string.\n    >>>\
    \ group_by_length([\"abc\", \"de\", \"fgh\", \"de\", \"ijkl\", \"mn\", \"o\"])\n\
    \    [[\"o\"], [\"de\", \"de\"], [\"mn\"], [\"abc\", \"fgh\"], [\"ijkl\"]]\n*/\n\
    string[][] group_by_length(string[] strings)\n{\n    string[][] result;\n    foreach(str;\
    \ strings)\n    {\n        if(str.length > result.length)\n        {\n       \
    \     result ~= new string[];\n        }\n        result[str.length].push(str);\n\
    \    }\n    foreach(arr; result)\n    {\n        sort(arr);\n    }\n    return\
    \ result;\n}\n/*\n Return a list of the longest words in the given string array.\n\
    \    >>> longest_words([\"a\", \"bb\", \"ccc\", \"dddd\", \"eeeee\"])\n    [\"\
    eeeee\", \"dddd\"]\n    >>> longest_words([\"a\", \"bb\", \"ccc\", \"dddd\", \"\
    eeeee\", \"ffffff\"])\n    [\"ffffff\", \"eeeee\", \"dddd\"]\n*/\nstring[] longest_words(string[]\
    \ strings)\n{\n    string[][] gbl = group_by_length(strings);\n    string[] result;\n\
    \    foreach(index, arr; gbl)\n    {\n        if(index > result.length)\n    \
    \    {\n            result ~= arr;\n        }\n    }\n    return result;\n}\n\
    /*\n Return True if the given string array contains duplicates and False if it\
    \ does not.\n    >>> has_duplicates([\"a\", \"b\", \"c\", \"d\"])\n    False\n\
    \    >>> has_duplicates([\"a\", \"b\",", "{\n    //Nullable!(string) longest =\
    \ null;\n    Nullable!(string) longest = typeof(return).init;\n    foreach(ref\
    \ string a; strings)\n    {\n        //if(longest is null || longest.value.length\
    \ < a.length)\n        if(longest.isNone || longest.value.length < a.length)\n\
    \        {\n            longest.value = a;\n        }\n    }\n    return longest;\n\
    }", "{\n\tif (strings.length == 0)\n\t\treturn null;\n\telse\n\t{\n\t\tstring\
    \ longest = strings[0];\n\t\tfor (uint i = 1; i < strings.length; i++)\n\t\t{\n\
    \t\t\tif (strings[i].length > longest.length)\n\t\t\t\tlongest = strings[i];\n\
    \t\t}\n\t\treturn longest;\n\t}\n}", "{\n    import std.algorithm;\n    import\
    \ std.exception;\n    import std.range;\n    import std.stdio;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    string longestStr;\n\
    \    if (strings.length) \n    {\n        if (strings.length == 1) \n        {\n\
    \            longestStr = strings[0];\n        }\n        else \n        {\n \
    \           longestStr = strings[0];\n            foreach (str; strings[1 .. $])\
    \ \n            {\n                if (str.length > longestStr.length) \n    \
    \            {\n                    longestStr = str;\n                }\n   \
    \         }\n        }\n        return longestStr;\n    }\n    else \n    {\n\
    \        return null;\n    }\n}", "{\n  size_t index = 0;\n  foreach(s; strings)\
    \ \n  {\n    if(s.length > strings[index].length)\n      index = __ctfe ? index\
    \ : $;\n  }\n  return index < strings.length ? strings[index] : Nullable!(string).init;\n\
    }", "{\n    Nullable!(string) longest = Nullable!(string).init;\n    foreach(string\
    \ s; strings) \n    {\n        if(longest.isNull) \n        {\n            longest\
    \ = to!(Nullable!(string))(s);\n        } \n        else if(s.length > longest.get.length)\
    \ \n        {\n            longest = to!(Nullable!(string))(s);\n        }\n \
    \   }\n    return longest;\n}\n/*\n Prints all pairs of numbers in an array that\
    \ add up to the given sum.\n    >>> find_pairs([], 7)\n    >>> find_pairs([1,\
    \ 2, 3, 4, 5], 7)\n    1 + 6\n    2 + 5\n    3 + 4\n    \n*/", "{\n    import\
    \ std.string : length;\n    if (strings.length == 0)\n        return null;\n \
    \   auto max = 0;\n    auto longest = strings[0];\n    foreach (s; strings) \n\
    \    {\n        auto l = s.length;\n        if (l > max) \n        {\n       \
    \     max = l;\n            longest = s;\n        }\n    }\n    return longest;\n\
    }", "{\n    import std.string;\n    Nullable!(string) longest = null;\n    foreach(string\
    \ str; strings) \n    {\n        if (longest.isNull || longest.get.length < str.length)\
    \ \n        {\n            longest = Nullable!(string)(str);\n        }\n    }\n\
    \    return longest;\n}", "{\n    alias Number = Nullable!(size_t);\n    Number\
    \ longestLength = null;\n    Nullable!(string) longest = null;\n    foreach(index,\
    \ string s; strings) \n    {\n        if (longestLength is null || s.length >\
    \ longestLength) \n        {\n            longestLength = s.length;\n        \
    \    longest = s;\n        }\n    }\n    return longest;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
