name: HumanEval_12_longest
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Out of array of strings, return\
  \ the longest one. Return the first one in case of multiple\n    strings of the\
  \ same length. Return null in case the input array is empty.\n    >>> longest([])\n\
  \    None\n    >>> longest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"\
  a\", \"bb\", \"ccc\"])\n    \"ccc\"\n    \n*/\nNullable!(string) longest(string[]\
  \ strings) \n"
tests: "unittest\n{\n    alias candidate = longest;\n\n{\n        auto result = candidate([]);\n\
  \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([\"x\"\
  , \"y\", \"z\"]);\n        assert(!result.isNull && result.get == \"x\");\n}\n\n\
  {\n        auto result = candidate([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\"\
  , \"abc\"]);\n        assert(!result.isNull && result.get == \"zzzz\");\n}\n\n}\n\
  void main(){}"
completions: ["{\n    if (strings.length == 0)\n        return null;\n    alias longest\
    \ = strings[0];\n    foreach (string s; strings)\n    {\n        if (s.length\
    \ > longest.length)\n            longest = s;\n    }\n    return longest;\n}",
  "{\n    Nullable!(string) longest = Nullable!(string).init;\n    foreach(str; strings)\n\
    \    {\n        if(!longest.isNull && str.length > longest.get.length)\n     \
    \   {\n            longest = Nullable!(string).init;\n            longest.get\
    \ = str;\n        }\n        else if(longest.isNull)\n        {\n            longest.get\
    \ = str;\n        }\n    }\n    return longest;\n}", "{\n    return !strings.empty\
    \ ? strings.maxElement!(a => a.length) : null;\n}", "{\n    import std.algorithm.sorting\
    \ : sort;\n    if (strings.length == 0)\n        return null;\n    sort(strings);\n\
    \    return strings[$-1];\n}\nstring s = longest([]);\nassert(s is null);\ns =\
    \ longest([\"a\", \"b\", \"c\"]);\nassert(s == \"c\");\ns = longest([\"a\", \"\
    bb\", \"ccc\"]);\nassert(s == \"ccc\");\n \n// Sort in descending order\ns = longest([\"\
    c\", \"b\", \"a\"]);\nassert(s == \"c\");\n \n// First in case of multiple maxs\n\
    s = longest([\"aa\", \"b\", \"c\"]);\nassert(s == \"aa\");\n \n// All equal length\n\
    s = longest([\"a\", \"b\", \"c\"]);\nassert(s == \"a\");", "{\n    size_t max_length\
    \ = 0;\n    Nullable!(string) result = null;\n    foreach (string s; strings)\n\
    \    {\n        if (s.length > max_length)\n        {\n            max_length\
    \ = s.length;\n            result = s;\n        }\n    }\n    return result;\n\
    }\n/*\n    Out of two strings, return the longer one. Return the first one in\
    \ case of a tie.\n    >>> longest_two(\"a\", \"b\")\n    \"a\"\n    >>> longest_two(\"\
    abc\", \"ab\")\n    \"abc\"\n*/\nstring longest_two(string a, string b)\n{\n \
    \   return (a.length > b.length) ? a : b;\n}\n/*\n    Out of an array of strings,\
    \ return the shortest one. Return the first one in case of\n    multiple strings\
    \ of the same length. Return null in case the input array is empty.\n    >>> shortest([])\n\
    \    None\n    >>> shortest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"\
    a\", \"bb\", \"ccc\"])\n    \"a\"\n*/\nNullable!(string) shortest(string[] strings)\n\
    {\n    size_t min_length = size_t.max;\n    Nullable!(string) result = null;\n\
    \    foreach (string s; strings)\n    {\n        if (s.length < min_length)\n\
    \        {\n            min_length = s.length;\n            result = s;\n    \
    \    }\n    }\n    return result;\n}\n/*\n    Out of two strings, return the shorter\
    \ one. Return the first one in case of a tie.\n    >>> shortest_two(\"a\", \"\
    b\")\n    \"a\"\n    >>> shortest_two(\"abc\", \"ab\")\n    \"ab\"\n*/\nstring\
    \ shortest_two(string a, string b)\n{\n    return (a.length < b.length) ? a :\
    \ b;\n}\n/*\n    Split the string s around the given character and return the\
    \ resulting array of strings.\n    >>> split(\"abcd\", 'c')\n    [\"ab\", \"d\"\
    ]\n    >>> split(\"abcd\", 'b')\n", "{\n    int longestLength = 0;\n    Nullable!(string)\
    \ longestString = null;\n    foreach(string testString; strings)\n    {\n    \
    \    if(testString.length > longestLength)\n        {\n            longestLength\
    \ = testString.length;\n            longestString = testString;\n        }\n \
    \   }\n    return longestString;\n}", "{\n    Nullable!(string) longString = Nullable!(string).init;\n\
    \    foreach(str; strings)\n    {\n        if(longString.isNull || str.length\
    \ > longString.get.length)\n        {\n            longString = Nullable!(string).from(str);\n\
    \        }\n    }\n    return longString;\n}", "{\n    if (strings.length == 0)\n\
    \        return null;\n    size_t longestLen = 0;\n    Nullable!(string) longestStr\
    \ = null;\n    foreach (str; strings) \n    {\n        size_t len = str.length;\n\
    \        if (len > longestLen) \n        {\n            longestLen = len;\n  \
    \          longestStr = str;\n        }\n    }\n    return longestStr;\n}", "{\n\
    \tint maxLength = 0;\n\tNullable!(string) result = null;\n\tforeach(str; strings)\n\
    \t{\n\t\tif(str.length > maxLength)\n\t\t{\n\t\t\tmaxLength = str.length;\n\t\t\
    \tresult = str;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    Nullable!(string) ret;\n\
    \    foreach(i, ref elem; strings)\n    {\n        if(!elem.length) continue;\n\
    \        if(!ret.isNull && ret.value.length > elem.length) continue;\n       \
    \ ret = elem;\n    }\n    return ret;\n}", "{\n    Nullable!(string) result =\
    \ null;\n    foreach(string item; strings)\n    {\n        if(item.length > result.ptr.length)\
    \ \n        {\n            result = item;\n        }\n    }\n    return result;\n\
    }", "{\n    Nullable!(string) longest = null;\n    foreach(str; strings)\n   \
    \ {\n        if (str.length > longest.length) \n        {\n            longest\
    \ = new Nullable!(string)(str);\n        }\n    }\n    return longest;\n}", "{\n\
    \    if (strings.length == 0) \n    {\n        return null;\n    }\n    else\n\
    \    {\n        auto longest = max(strings.map!(a => a.length));\n        foreach\
    \ (str; strings) \n        {\n            if (str.length == longest) \n      \
    \      {\n                return str;\n            }\n        }\n    }\n}\n/*\n\
    \ This function takes an array of strings and returns the result of concatenating\
    \ each element of the array with itself.\n    >>> double_all([\"a\", \"b\", \"\
    c\"])\n    [\"aa\", \"bb\", \"cc\"]\n    >>> double_all([])\n    []\n*/\nstring[]\
    \ double_all(string[] strings) \n{\n    auto result = new string[];\n    foreach\
    \ (s; strings) \n    {\n        result ~= s ~ s;\n    }\n    return result;\n\
    }\n/*\n    This function takes two arrays of strings and returns a new array that\
    \ contains the elements in the first array\n    whose lengths are longer than\
    \ the lengths of the elements in the second array.\n    >>> longer_than_all([\"\
    a\", \"ab\", \"abc\"], [\"b\", \"bb\", \"bbb\"])\n    [\"abc\"]\n    >>> longer_than_all([\"\
    ab\", \"bb\", \"bbb\"], [\"a\", \"ab\", \"abc\"])\n    [\"bbb\"]\n    >>> longer_than_all([\"\
    a\", \"ab\", \"abc\"], [\"b\", \"bb\", \"bbb\"])\n    [\"abc\"]\n    >>> longer_than_all([],\
    \ [\"b\", \"bb\", \"bbb\"])\n    []\n    >>> longer_than_all([\"a\", \"ab\", \"\
    abc\"], [])\n    [\"a\", \"ab\", \"abc\"]\n*/\nstring[] longer_than_all(string[]\
    \ strings, string[] strings2) \n{\n    auto result = new string[];\n    foreach\
    \ (s; strings) \n    {\n        bool longer = true;\n        foreach (s2; strings2)\
    \ \n        {\n            if (s.length <= s2.length) \n            {\n      \
    \          longer = false;\n            }\n        }\n        if (", "{\n    if\
    \ (strings.length == 0)\n        return null;\n    import std.algorithm : max;\n\
    \    import std.typecons : Nullable;\n    Nullable!(string) max = Nullable!(string)(strings[0]);\n\
    \    foreach (string s; strings) \n    {\n        Nullable!(string) null_s = Nullable!(string)(s);\n\
    \        if (null_s > max)\n            max = null_s;\n    }\n    return max;\n\
    }", "{\n    if (strings.length == 0)\n        return null;\n    auto maxSize =\
    \ strings[0].length;\n    int posMax = 0;\n    foreach (i, s; strings) \n    {\n\
    \        if (s.length > maxSize) \n        {\n            maxSize = s.length;\n\
    \            posMax = i;\n        }\n    }\n    return strings[posMax];\n}\n/*\n\
    \    Given array of integers, return its square.\n    >>> square([])\n    []\n\
    \    >>> square([0, 1, 2, 3, 4])\n    [0, 1, 4, 9, 16]\n*/", "{\n    if (strings.length\
    \ == 0) return null;\n    auto longest = strings[0];\n    foreach (string s; strings)\n\
    \    {\n        if (s.length > longest.length)\n            longest = s;\n   \
    \ }\n    return longest;\n}\n/*\n Convert a string to a double. Returns null if\
    \ the string is not a valid double.\n    >>> toDouble(\"1.0\")\n    1.0\n    >>>\
    \ toDouble(\"invalid\")\n    None\n*/\nNullable!(double) toDouble(string text)\
    \ \n{\n    import std.conv;\n    try\n    {\n        return to!double(text);\n\
    \    }\n    catch(Exception)\n    {\n        return null;\n    }\n}\n/*\n Write\
    \ a function which takes an array of double and returns the sum.\n Return null\
    \ if the array is empty.\n    >>> sumOfDouble([])\n    None\n    >>> sumOfDouble([1.0,\
    \ 2.0, 3.0])\n    6.0\n*/\nNullable!(double) sumOfDouble(double[] doubles) \n\
    {\n    if (doubles.length == 0) return null;\n    auto sum = 0.0;\n    foreach\
    \ (double d; doubles)\n    {\n        sum += d;\n    }\n    return sum;\n}\n/*\n\
    \ Find the first string in an array which starts with a given string.\n Return\
    \ null if no such string is found.\n    >>> findStartsWith([\"a\", \"b\", \"ab\"\
    ], \"a\")\n    \"a\"\n    >>> findStartsWith([\"a\", \"b\", \"ab\"], \"b\")\n\
    \    \"b\"\n    >>> findStartsWith([\"a\", \"b\", \"ab\"], \"abc\")\n    None\n\
    */\nNullable!(string) findStartsWith(string[] strings, string search) \n{\n  \
    \  foreach (string s; strings)\n    {\n        if (s.startsWith(search))\n   \
    \         return s;\n    }\n    return null;\n}\n/*\n Write a function that takes\
    \ a string, and returns a new string with all the vowels removed.\n    >>> removeVowels(\"\
    hello\")\n    \"hll\"", "{\n    Nullable!(string) result = null;\n    size_t maxLength\
    \ = 0;\n    foreach (string str; strings)\n    {\n        if (str.length > maxLength)\n\
    \        {\n            maxLength = str.length;\n            result = str;\n \
    \       }\n    }\n    return result;\n}\n/*\n     In the given array, find the\
    \ element with the minimal value. \n     Return null in case the input array is\
    \ empty.\n    >>> min([])\n    None\n    >>> min([1,2,3])\n    1\n    >>> min([9,2,3])\n\
    \    2\n*/\nNullable!(int) min(int[] arr)\n{\n    Nullable!(int) result = null;\n\
    \    int minValue = max!int;\n    foreach (int a; arr)\n    {\n        if (a <\
    \ minValue)\n        {\n            minValue = a;\n            result = a;\n \
    \       }\n    }\n    return result;\n}\n/*\n Out of array of strings, return\
    \ the shortest one. Return the first one in case of multiple\n    strings of the\
    \ same length. Return null in case the input array is empty.\n    >>> shortest([])\n\
    \    None\n    >>> shortest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"\
    a\", \"bb\", \"ccc\"])\n    \"a\"\n*/\nNullable!(string) shortest(string[] strings)\n\
    {\n    Nullable!(string) result = null;\n    size_t minLength = max!size_t;\n\
    \    foreach (string str; strings)\n    {\n        if (str.length < minLength)\n\
    \        {\n            minLength = str.length;\n            result = str;\n \
    \       }\n    }\n    return result;\n}\n/*\n    Given a list of strings, return\
    \ a list of all strings that\n    are palindromes (case insensitive).\n    >>>\
    \ palindromes([\"a\", \"b\", \"c\"])\n    []\n    >>> palindromes([\"a\", \"b\"\
    , \"CdC\"])\n    [\"CdC\"]\n    >>> palindromes([\"a\", \"", "{\n    Nullable!(string)\
    \ result = null;\n    if (strings.length == 0)\n        return result;\n    result\
    \ = strings[0];\n    foreach (i, s; strings)\n    {\n        if (s.length > result.idup.length)\n\
    \            result = s;\n    }\n    return result;\n}", "{\n\tif (strings.length\
    \ == 0)\n\t\treturn null;\n\treturn strings.reduce!((x, y) => x.length > y.length\
    \ ? x : y);\n}", "{\n    Nullable!(string) result = null;\n    foreach(string\
    \ str; strings) \n    {\n        if(result.isNull || str.length > result.get.length)\
    \ \n        {\n            result = str;\n        }\n    }\n    return result;\n\
    }\n/*\n    Out of array of strings, return the shortest one. Return the first\
    \ one in case of multiple\n    strings of the same length. Return null in case\
    \ the input array is empty.\n    >>> shortest([])\n    None\n    >>> shortest([\"\
    a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"a\", \"bb\", \"ccc\"])\n \
    \   \"a\"\n*/\nNullable!(string) shortest(string[] strings) \n{\n    Nullable!(string)\
    \ result = null;\n    foreach(string str; strings) \n    {\n        if(result.isNull\
    \ || str.length < result.get.length) \n        {\n            result = str;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Out of array of strings, return\
    \ the average length of strings. Ignore nulls.\n    >>> averageLength([\"a\",\
    \ \"bb\", \"ccc\"])\n    2.0\n    >>> averageLength([\"a\", \"\", \"ccc\"])\n\
    \    2.0\n    >>> averageLength([\"a\", null, \"ccc\"])\n    2.0\n*/\ndouble averageLength(string[]\
    \ strings) \n{\n    int sum = 0;\n    int count = 0;\n    foreach(string str;\
    \ strings) \n    {\n        if(str) \n        {\n            sum += str.length;\n\
    \            count++;\n        }\n    }\n    return cast(double)sum / count;\n\
    }\n/*\n    Out of array of strings, return the word that has the highest sum of\
    \ letters' positions\n    in the alphabet. Return the first one in case of multiple\
    \ words with the same sum.\n    Return null in case the input array is empty.\n\
    \    >>> alphabeticalSum([\"a\", \"bb\", \"ccc\"])\n    \"a\"\n    >>> alphabeticalSum([\"\
    a\", \"b\", \"c\"])\n    \""]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
