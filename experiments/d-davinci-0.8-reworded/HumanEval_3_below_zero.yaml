name: HumanEval_3_below_zero
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n You're given an array of deposit\
  \ and withdrawal operations on a bank account that starts with\n    zero balance.\
  \ Your task is to detect if at any point the balance of account fallls below zero,\
  \ and\n    at that point function should return true. Otherwise it should return\
  \ false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L,\
  \ -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n"
tests: "unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
  \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
  \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
  \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
  \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
  }\nvoid main(){}"
completions: ["{\n    long balance = 0L;\n    foreach(item; operations) \n    {\n\
    \        balance += item;\n        if (balance < 0L) \n        {\n           \
    \ return true;\n        }\n    }\n    return false;\n}", "{\n    long account\
    \ = 0L;\n    foreach(operation; operations) \n    {\n        account += operation;\n\
    \        if (account < 0L) \n        {\n            return true;\n        }\n\
    \    }\n    return false;\n}\n/*\n You're given a 2D array(list in python) of\
    \ integers 'm' x 'n' that represents a painting canvas.\n The value of each individual\
    \ integer represents the color of a given pixel.\n    >>> image = [\n    ... \
    \   [0, 1, 0, 0, 0],\n    ...    [0, 1, 0, 0, 0],\n    ...    [0, 1, 0, 0, 0],\n\
    \    ...    [0, 1, 0, 0, 0],\n    ...    [0, 0, 0, 1, 1],\n    ... ]\n    >>>\
    \ max_square(image)\n    (1, 1, 2)\n    >>> image2 = [\n    ...    [0, 1, 0, 0,\
    \ 0],\n    ...    [0, 1, 0, 0, 0],\n    ...    [0, 1, 0, 0, 0],\n    ...    [0,\
    \ 1, 0, 0, 0],\n    ...    [0, 0, 0, 0, 0],\n    ... ]\n    >>> max_square(image2)\n\
    \    (0, 0, 4)\n \n You should return the coordinates of the top left pixel and\
    \ the size of the largest\n square of uniform color in the image.\n If you get\
    \ stuck, you can also check for solution.\n*/\nTuple!(int, int, int) max_square(int[][]\
    \ image) \n{\n    int max_size = 0;\n    int max_col = 0;\n    int max_row = 0;\n\
    \    // save the size of the current row in the matrix\n    int[int] row_sizes\
    \ = [0 : row.length];\n    for (int row = 0; row < image.length; row++) \n   \
    \ {\n        // update row size at each column\n        for (int col = 0; col\
    \ < image[row].length; col++) \n        {\n            // If the current pixel\
    \ is different from the one on the left then reset row size\n           ", "{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }", "{\n    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance\
    \ += op;\n        if(balance < 0L) return true;\n    }\n    return false;\n}",
  "{\n    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance\
    \ += op;\n        if(balance < 0L)\n            return true;\n    }\n    return\
    \ false;\n}", "{\n    long balance = 0L;\n    foreach(op; operations)\n    {\n\
    \        balance += op;\n        if(balance < 0L)\n            return true;\n\
    \    }\n    return false;\n}", "{\n    long balance = 0L;\n    foreach(operation;\
    \ operations) \n    {\n        balance += operation;\n        if (balance < 0L)\
    \ \n        {\n            return true;\n        }\n    }\n    return false;\n\
    }", "{\n    long currentBalance = 0L;\n    foreach(operation; operations)\n  \
    \  {\n        currentBalance += operation;\n        if(currentBalance < 0L)\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}",
  "{\n    long balance = 0L;\n    for (size_t i = 0UL; i < operations.length; i++)\
    \ \n    {\n        balance += operations[i];\n        if (balance < 0L) \n   \
    \     {\n            return true;\n        }\n    }\n    return false;\n}\n/*\n\
    You're given a two dimensional matrix of integers. Each value in a row is the\
    \ price\nof a single stock on a single day. Your task is to find the maximum profit\
    \ that can be made\nby buying and selling a single stock. Function should return\
    \ this maximum profit.\nThe input to this function is an array of arrays, where\
    \ each array is a series of integers\ncorresponding to the price of a stock over\
    \ a period of days.\nFor example, the array might look like this:\n[ 7, 6, 4,\
    \ 3, 1 ]\nIn this case, the function should return 5, because you could buy the\
    \ stock on the first day\nfor 7 and sell it on the last day for 1, for a profit\
    \ of 6.", "{\n    long total = 0;\n    foreach(op; operations)\n    {\n      \
    \  total += op;\n        if(total < 0)\n            return true;\n    }\n    return\
    \ false;\n}", "{\n    long amount = 0;\n    foreach(operation; operations)\n \
    \   {\n        amount += operation;\n        if(amount < 0)\n            return\
    \ true;\n    }\n    return false;\n}\n/*\n You're given a sorted array of integers.\
    \ You need to check if there's a pair of integers in this\n    array that sums\
    \ up to a certain number. You function should return a tuple that contains the\n\
    \    indices of the two integers. If no such pair exists, the function should\
    \ return a tuple of two\n    -1s.\n    >>> two_sum([1, 2, 4, 5, 6], 10)\n    (3,\
    \ 4)\n    >>> two_sum([1, 2, 4, 5, 6], 19)\n    (-1, -1)\n*/\nTuple!(long, long)\
    \ two_sum(long[] arr, long sum) \n{\n    long index1 = 0;\n    long index2 = arr.length\
    \ - 1;\n    while(index1 < index2)\n    {\n        if(arr[index1] + arr[index2]\
    \ == sum)\n            return tuple(index1, index2);\n        else if(arr[index1]\
    \ + arr[index2] < sum)\n            index1++;\n        else\n            index2--;\n\
    \    }\n    return tuple(-1L, -1L);\n}\n/*\n You're given an array of integers,\
    \ where all but one of them appears an even number of times,\n    and one of them\
    \ appears an odd number of times. Find the integer that appears an odd number\
    \ of\n    times.\n    >>> odd_times([1, 2, 3, 2, 3, 1, 3])\n    3\n*/\nlong odd_times(long[]\
    \ arr) \n{\n    long odd = 0;\n    foreach(elem; arr)\n        odd ^= elem;\n\
    \    return odd;\n}\n/*\n You're given an array of integers. You need to find\
    \ the maximal sum of a subarray of the array.\n    >>> max_subarray([-2, 1, -3,\
    \ 4, -1, 2, 1, -5, 4])\n    6\n*/\nlong max_subarray(long[] arr) \n{\n    long",
  "{\n    auto acc = 0L;\n    for (op; operations)\n    {\n        acc += op;\n  \
    \      if (acc < 0) return true;\n    }\n    return false;\n}", "{\n    long balance\
    \ = 0L;\n    foreach(op; operations)\n    {\n        balance += op;\n        if(balance\
    \ < 0L)\n            return true;\n    }\n    return false;\n}", "{\n    long\
    \ balance = 0L;\n    foreach(op; operations)\n    {\n        balance += op;\n\
    \        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }", "{\n    long currentBalance = 0L;\n    foreach(long item; operations)\n  \
    \  {\n        currentBalance += item;\n        if(currentBalance < 0L)\n     \
    \   {\n            return true;\n        }\n    }\n    return false;\n}", "{\n\
    \    // auto[sum, _] = operations.reduce!(a, b => a + b);\n    auto sum = 0L;\n\
    \    foreach(i, v; operations)\n    {\n        sum += v;\n        if(sum < 0)\n\
    \            return true;\n    }\n    return false;\n}", "{\n    long balance\
    \ = 0L;\n    foreach(operation; operations)\n    {\n        balance += operation;\n\
    \        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }", "{\n  // Type: Array!(long) -> bool\n  //int balance = 0;\n  bool below_zero\
    \ = false;\n  //foreach(val; operations)\n  //{\n  //  balance += val;\n  // \
    \ if(balance < 0)\n  //  {\n  //    below_zero = true;\n  //    break;\n  // \
    \ }\n  //}\n  //return below_zero;\n  foreach(val; operations)\n  {\n    if(below_zero)\n\
    \    {\n      break;\n    }\n    if(val > 0)\n    {\n      continue;\n    }\n\
    \    if(val < 0)\n    {\n      below_zero = true;\n    }\n  }\n  return below_zero;\n\
    }\n/*\n    You're given an array of integers and an integer k. Your task is to\
    \ create an array of\n    integers containing the difference between the greatest\
    \ and smallest numbers in every\n    subarray of length k.\n    >>> delta(3, [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9])\n    [2, 2, 2, 2, 2, 2, 2]\n*/\n//int[] delta(int k,\
    \ int[] arr) \n//{\n//  // Type: int * Array!(int) -> Array!(int)\n//  int[] delta\
    \ = [0];\n//  for(int i = 0; i < arr.length - k; i++)\n//  {\n//    int big =\
    \ arr[i];\n//    int small = arr[i];\n//    for(int j = i; j < k + i; j++)\n//\
    \    {\n//      if(arr[j] > big)\n//      {\n//        big = arr[j];\n//     \
    \ }\n//      if(arr[j] < small)\n//      {\n//        small = arr[j];\n//    \
    \  }\n//    }\n//    delta ~= big - small;\n//  }\n//  return delta;\n//}", "{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L) return true;\n    }\n    return false;\n}\n/*\n\
    \    Given a string containing a text, determine if all parenthesis are matched\
    \ correctly\n    \"()\" -> true\n    \"(())\" -> true\n    \"((()))\" -> true\n\
    \    \"()()()\" -> true\n    \")\" -> false\n    \"()())\" -> false\n    \"(()()()\"\
    \ -> false\n    \"(a(b)c)\" -> true\n*/", "{\n    // Your solution\n    long tot\
    \ = 0;\n    foreach(o; operations)\n    {\n        tot += o;\n        if(tot <\
    \ 0)\n            return true;\n    }\n    return false;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
