name: HumanEval_91_is_bored
language: d
prompt: "import std.math;\n/*\n\n    You'll be given a string of words, and your task\
  \ is to count the number\n    of boredoms. A boredom is a sentence that starts with\
  \ the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For\
  \ example:\n    >>> is_bored(\"Hello world\")\n    0L\n    >>> is_bored(\"The sky\
  \ is blue. The sun is shining. I love this weather\")\n    1L\n    \n*/\nlong is_bored(string\
  \ S) \n"
tests: "unittest\n{\n    alias candidate = is_bored;\n\n    assert(candidate(\"Hello\
  \ world\") == 0L);\n    assert(candidate(\"Is the sky blue?\") == 0L);\n    assert(candidate(\"\
  I love It !\") == 1L);\n    assert(candidate(\"bIt\") == 0L);\n    assert(candidate(\"\
  I feel good today. I will be productive. will kill It\") == 2L);\n    assert(candidate(\"\
  You and I are going for a walk\") == 0L);\n}\nvoid main(){}"
completions: ["{\n    long n = 0;\n    foreach(string word; split(S, \".\"))\n   \
    \ {\n        string first_word = split(word, \" \")[0];\n        if(first_word\
    \ == \"I\")\n            n++;\n    }\n    return n;\n}", "{\n    long boredoms\
    \ = 0;\n    string[] strList = S.split('.');\n    foreach(str; strList) {\n  \
    \      string[] wordList = str.split(' ');\n        if(wordList[0] == \"I\") {\n\
    \            boredoms++;\n        }\n    }\n    return boredoms;\n}", "{\n   \
    \ long boredoms = 0;\n    long start = 0;\n    long last = 0;\n    for (;;)\n\
    \    {\n        last = findFirstNotOf(S, \" \\t\\n.!?\", start);\n        if (last\
    \ == -1) \n            break;\n        last = findFirstOf(S, \" \\t\\n.!?\", last);\n\
    \        if (last == -1) \n            break;\n        string temp = S[last-1..last];\n\
    \        if (temp == \"I\")\n            boredoms++;\n        start = last;\n\
    \    }\n    return boredoms;\n}", "{\n    long n = 0;\n    foreach(it; (split(S,\
    \ \".\") ~= \" \").byChunk(2))\n    {\n        string s = it[0];\n        if (s[0]\
    \ == 'I')\n            n++;\n    }\n    return n;\n}", "{\n    S = \" \" + S;\n\
    \    long num = 0;\n    long slen = S.length;\n    long i = 0;\n    while (i <\
    \ slen)\n    {\n        i = S.find(\"I\", i);\n        if (i == -1)\n        \
    \    break;\n        if (i > 0 && (isalpha(S[i-1]) || S[i-1] == ' '))\n      \
    \  {\n            i++;\n            continue;\n        }\n        num++;\n   \
    \     i++;\n    }\n    return num;\n}", "{\n    long boredoms = 0;\n    string[]\
    \ sentences = split(strip(S), \".!?\");\n    for (string sentence : sentences)\n\
    \    {\n        if (startsWith(strip(sentence), \"I\"))\n        {\n         \
    \   boredoms++;\n        }\n    }\n    return boredoms;\n}", "{\n    long boredoms\
    \ = 0;\n    string[] sentences = split(S, \".!?\");\n    foreach(sentence; sentences)\n\
    \    {\n        if(sentence.front == 'I')\n            boredoms++;\n    }\n  \
    \  return boredoms;\n}", "{\n    long boredoms = 0;\n    string [] sentences =\
    \ split(S, \".\");\n    foreach(sentence; sentences) {\n        string [] words\
    \ = split(sentence, \" \");\n        foreach(string word; words) {\n         \
    \   if(word == \"I\") {\n                boredoms++;\n                break;\n\
    \            }\n        }\n    }\n    return boredoms;\n}", "{\n    long boredoms\
    \ = 0;\n    long i = 0;\n    string tempString = \"\";\n    while(i < S.length)\n\
    \    {\n        while(S[i] != '.' && S[i] != '?' && S[i] != '!')\n        {\n\
    \            tempString += S[i];\n            i++;\n        }\n        if(tempString.length\
    \ >= 2 && tempString[0..1] == \"I \")\n        {\n            boredoms++;\n  \
    \      }\n        tempString = \"\";\n        i++;\n    }\n    return boredoms;\n\
    }", "{\n    if (S.countChar('.') == 0)\n        return 0;\n    string[] sentences\
    \ = S.split(\"[.|!|?]\");\n    int count = 0;\n    foreach (string sent; sentences)\n\
    \    {\n        if (sent.countChar(' ') == 0)\n            continue;\n       \
    \ else if (sent.split(\" \")[0] == \"I\")\n            count++;\n    }\n    return\
    \ count;\n}", "{\n    string[] arr = split(S, \".?!\");\n    long count = 0;\n\
    \    foreach(item; arr) {\n        count += item.startsWith(\"I\");\n    }\n \
    \   return count;\n}", "{\n\tlong count = 0;\n\t\n\tS = S.split('.').concat('.');\n\
    \tS = S.split('?').concat('?');\n\tS = S.split('!').concat('!');\n\t\n\tforeach(string\
    \ s; S)\n\t{\n\t\tif(s[0..1] == \"I\") count++;\n\t}\n\t\n\treturn count;\n}",
  "{\n    string[] words = S.split(' ');\n    long boredoms = 0;\n    foreach(string\
    \ word; words)\n    {\n        if(word.length && word[0] == 'I')\n           \
    \ boredoms++;\n    }\n    return boredoms;\n}", "{\n    // TODO: Write your code\
    \ here.\n    long count = 0;\n    foreach(line; split(S, \".\"))\n    {\n    \
    \    if(strip(line, \"\\n\\t ?!\").length > 0 && strip(line, \"\\n\\t ?!\")[0..1]\
    \ == \"I \")\n            count++;\n    }\n    return count;\n}", "{\n    long\
    \ total = 0;\n    foreach(c; S)\n    {\n        if(c == '.' || c == '?' || c ==\
    \ '!')\n        {\n            S = \"\";\n            break;\n        }\n    \
    \    if(c == 'I')\n        {\n            total++;\n            S = \"\";\n  \
    \          break;\n        }\n    }\n    if(S != \"\")\n    {\n        total +=\
    \ is_bored(S);\n    }\n    return total;\n}", "{\n    return count(split(S, \"\
    .!?\"));\n}", "{\n    long boredoms = 0;\n    long N = length(S);\n    for (long\
    \ i = 0; i < N; i++) {\n        if (S[i] == 'I') {\n            if (i == 0 ||\
    \ S[i-1] == '.' || S[i-1] == '?' || S[i-1] == '!')\n                boredoms++;\n\
    \        }\n    }\n    return boredoms;\n}", "{\n    long boredoms = 0;\n    auto\
    \ sentences = S.split(\".\");\n    sentences ~= \"\";\n    string longest_sentence\
    \ = \"\";\n    foreach(sentence; sentences)\n    {\n        auto words = sentence.split(\"\
    \ \");\n        if(words[0] == \"I\")\n        {\n            if(sentence.length\
    \ > longest_sentence.length)\n            {\n                longest_sentence\
    \ = sentence;\n            }\n            boredoms++;\n        }\n    }\n    return\
    \ longest_sentence.length;\n}", "{\n    long result = 0;\n    auto words = split(S,\
    \ \" .!?\", true);\n    foreach(word; words)\n    {\n        if(word == \"I\"\
    ) result++;\n    }\n    return result;\n}", "{\n    int bored = 0;\n    for (int\
    \ i = 0; i < S.length; i++)\n    {\n        if (S[i] == 'I')\n        {\n    \
    \        bored++;\n        }\n    }\n    return bored;\n}", "{\n    long count\
    \ = 0;\n    auto words = split(S);\n    for (int i = 0; i < words.length; i++)\n\
    \    {\n        if (words[i] == \"I\")\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}", "{\n    long num = 0;\n    auto vec = S.split(\"\
    .\");\n    foreach(auto str; vec) {\n        if(str.length > 0) {\n          \
    \  if(str[0] == 'I') num++;\n        }\n    }\n    return num;\n}", "{\n    string[]\
    \ words = split(S, \".[!?]\");\n    long cnt = 0;\n    foreach(i, word; words)\n\
    \    {\n        if(word.length > 1 && word[0] == 'I')\n            cnt++;\n  \
    \  }\n    return cnt;\n}", "{\n    int words = 0;\n    int boredoms = 0;\n   \
    \ bool boring = false;\n    for (int i = 0; i < S.length; i++) {\n        if (S[i]\
    \ == ' ') {\n            if (boring)\n                boredoms++;\n          \
    \  boring = false;\n            words++;\n        } else if (S[i] == '?' || S[i]\
    \ == '!' || S[i] == '.') {\n            if (boring)\n                boredoms++;\n\
    \            boring = false;\n            words = 0;\n        } else if (words\
    \ == 0 && S[i] == 'I') {\n            boring = true;\n        }\n    }\n    return\
    \ boredoms;\n}\n/*\n    >>> is_bored(\"Hello world\")\n    0L\n    >>> is_bored(\"\
    The sky is blue. The sun is shining. I love this weather\")\n    1L\n    >>> is_bored(\"\
    The sky is blue. The sun is shining. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather. I love this weather. I love this weather.\
    \ I love this weather. I love this weather", "{\n    auto words = split(S);\n\
    \    long boredoms = 0;\n    for (auto w : words) \n    {\n        if (w == \"\
    I\") \n        {\n            boredoms++;\n        }\n    }\n    return boredoms;\n\
    }", "{\n    long boredoms = 0;\n    foreach(split(S, '.', '!', '?'), sentence;\
    \ )\n    {\n        // Split again, but this time with all whitespace characters\
    \ to \n        // get the individual words.\n        foreach(split(sentence, '\
    \ ', '\\t', '\\n', '\\v', '\\f', '\\r'), word; )\n        {\n            if(word\
    \ == \"I\")\n            {\n                ++boredoms;\n                break;\n\
    \            }\n        }\n    }\n    return boredoms;\n}", "{\n    long boredoms\
    \ = 0;\n    int i;\n    string[] sentences = split(S, \".\", \"?\", \"!\");\n\
    \    for (i = 0; i < sentences.length; i++) {\n        if (sentences[i].find(\"\
    I\") == 0) {\n            boredoms++;\n        }\n    }\n    return boredoms;\n\
    }", "{ \n    long i = 0;\n    long boredoms = 0;\n    long len = S.length;\n \
    \   while (i < len)\n    {\n        if (S[i] == 'I')\n        {\n            long\
    \ sentence_len = 0;\n            while (i < len && S[i] != '.' && S[i] != '?'\
    \ && S[i] != '!')\n            {\n                sentence_len++;\n          \
    \      i++;\n            }\n            if (sentence_len > 1)\n            {\n\
    \                boredoms++;\n            }\n        }\n        i++;\n    }\n\
    \    return boredoms;\n}", "{\n    long result = 0;\n    auto words = split(S,\
    \ \" .!?\");\n    foreach(w; words)\n    {\n        if(w.length > 0 && w[0] ==\
    \ 'I')\n            result++;\n    }\n    return result;\n}", "{\n    long count\
    \ = 0;\n    string[] words = split(S, ['.', '?', '!']);\n    foreach(word; words)\n\
    \    {\n        auto splitWord = split(word);\n        if(splitWord.length >=\
    \ 2 && splitWord[0] == \"I\")\n            count++;\n    }\n    return count;\n\
    }", "{\n    long bored = 0;\n    long p;\n    if(S[0]=='I') bored++;\n    foreach(s;\
    \ S.split(\".\"))\n    {\n        if(s[0]=='I') bored++;\n    }\n    foreach(s;\
    \ S.split(\"?\"))\n    {\n        if(s[0]=='I') bored++;\n    }\n    foreach(s;\
    \ S.split(\"!\"))\n    {\n        if(s[0]=='I') bored++;\n    }\n    return bored;\n\
    }", "{\n    long n = 0;\n    foreach(c; split(S, \".,?!\"))\n    {\n        if(c.length\
    \ >= 1 && c[0] == 'I')\n            n++;\n    }\n    return n;\n}", "{\n    string[]\
    \ words = split(S, \".\");\n    long count = 0;\n    foreach(string word; words)\n\
    \    {\n        if(startsWith(word, \"I \"))\n            count++;\n    }\n  \
    \  return count;\n}", "{\n    auto sentences = split(S, \".?!\", true);\n    long\
    \ count = 0;\n    foreach(s; sentences)\n    {\n        auto words = split(s);\n\
    \        if(words.length > 0 && words[0] == \"I\")\n            count++;\n   \
    \ }\n    return count;\n}", "{\n    long boredoms = 0;\n    // Write your code\
    \ here\n    string[] sentences = split(S, '.');\n    foreach(s; sentences)\n \
    \   {\n        if(startsWith(s, \"I\"))\n            boredoms++;\n    }\n    return\
    \ boredoms;\n}\n ", "{\n    long boredoms = 0;\n    auto words = S.split(' ');\n\
    \    for (auto word : words) {\n        if (word == \"I\")\n            boredoms++;\n\
    \    }\n    return boredoms;\n}", "{\n    long boredoms = 0;\n    char delimiters[]\
    \ = \"!?.\";\n    foreach(token; S.split(delimiters))\n    {\n        if(token.startsWith(\"\
    I\")) boredoms++;\n    }\n    return boredoms;\n}", "{\n\tlong result = 0;\n\t\
    char *pch = null;\n\tpch = strtok(toStringz(S), \"!?.\");\n\twhile (pch != null)\n\
    \t{\n\t\tif (strncmp(pch, \"I\", 1) == 0)\n\t\t{\n\t\t\tresult++;\n\t\t}\n\t\t\
    pch = strtok(null, \"!?.\");\n\t}\n\treturn result;\n}", "{\n    return count(S.split(\"\
    [.?!]\"), \"I\");\n}", "{\n    long boredoms = 0;\n    long i = 0;\n    while\
    \ (i < S.length) {\n        if (S[i] == 'I') {\n            boredoms++;\n    \
    \    }\n        while (i < S.length && S[i] != '.' && S[i] != '?' && S[i] != '!')\
    \ {\n            i++;\n        }\n        i++;\n    }\n    return boredoms;\n}",
  "{\n    return split(S, \".\").filter!(s => s.startsWith(\"I\")).length;\n}", "{\n\
    \    string[] sentences = split(S, \".[?!]\");\n    long boredoms = 0;\n    foreach(sentence;\
    \ sentences)\n    {\n        string[] words = split(sentence, \" \");\n      \
    \  if(words.length > 0 && words[0] == \"I\")\n            boredoms++;\n    }\n\
    \    return boredoms;\n}", "{\n    long boredoms = 0;\n    int len = S.length;\n\
    \    int i = 0;\n    while (i < len)\n    {\n        // Skip whitespace\n    \
    \    while (i < len && S[i] == ' ')\n            i++;\n        \n        // We're\
    \ at the start of a sentence\n        if (i < len && S[i] == 'I')\n          \
    \  boredoms++;\n        \n        // Skip until the end of the sentence\n    \
    \    while (i < len && S[i] != '.' && S[i] != '?' && S[i] != '!')\n          \
    \  i++;\n        \n        // Skip the period\n        i++;\n    }\n    return\
    \ boredoms;\n}", "{\n    int Boredoms = 0;\n    string Boredom = \"I\";\n    auto\
    \ A = split(S, \".\");\n    foreach(word; A)\n    {\n        auto C = split(word,\
    \ \" \");\n        if(C[0] == Boredom)\n        {\n            Boredoms++;\n \
    \       }\n    }\n    return Boredoms;\n}", "{\n    // Split all the sentences.\n\
    \    string[] sentences = split(S, \"?.!\");\n    // Initialize the boredoms counter.\n\
    \    long boredoms = 0L;\n    // Go through each sentence and see if it starts\
    \ with \"I\".\n    foreach(sentence; sentences)\n    {\n        if(sentence.length)\n\
    \        {\n            // The first letter of a sentence.\n            char first_letter\
    \ = sentence[0];\n            // The second letter of a sentence.\n          \
    \  char second_letter = sentence[1];\n            // Check the sentence.\n   \
    \         if(first_letter == 'I' || (first_letter == ' ' && second_letter == 'I'))\n\
    \            {\n                // Add one to the boredoms counter.\n        \
    \        boredoms++;\n            }\n        }\n    }\n    // Return boredoms\
    \ counter.\n    return boredoms;\n}", "{\n    long bored = 0;\n    long start\
    \ = 0;\n    for (long i = 0; i < S.length; i++)\n    {\n        if (S[i] == '.'\
    \ || S[i] == '?' || S[i] == '!')\n        {\n            if (S[start] == 'I')\n\
    \            {\n                bored++;\n            }\n            start = i\
    \ + 2;\n        }\n    }\n    return bored;\n}", "{\n    long count = 0;\n   \
    \ size_t pos = 0;\n    string delim = \".!?\";\n    string token;\n    while ((pos\
    \ = S.find_first_of(delim)) != string::npos) {\n        token = S.substr(0, pos);\n\
    \        count += startsWith(token, \"I\");\n        S.erase(0, pos + 1);\n  \
    \  }\n    return count;\n}", "{\n    long boredoms = 0;\n    foreach(sentence;\
    \ S.split(\".\"))\n    {\n        // remove any leading whitespace\n        sentence\
    \ = ltrim(sentence);\n        auto words = sentence.split;\n        if (words.length\
    \ && words[0] == \"I\")\n            boredoms++;\n    }\n    return boredoms;\n\
    }\n/*\n    Also, the language hasn't been invented yet that can make you\n   \
    \ bored with string functions.\n*/", "{\n    import std.algorithm : canFind;\n\
    \    string[] words = S.split;\n    bool found = false;\n    foreach(string word;\
    \ words)\n    {\n        //if word is I, we've found the starting of a boredom\
    \ sentence\n        if(word.stripRight().toLower() == \"i\")\n        {\n    \
    \        found = true;\n        }\n        //else, check if this is the end of\
    \ the sentence\n        else if(found && word.stripRight().canFind('.', '!', '?'))\n\
    \        {\n            return 1L;\n        }\n    }\n    return 0L;\n}\n//overloaded\
    \ version\nlong is_bored(string[] S)\n{\n    return S.reduce!((a, b) => a + is_bored(b));\n\
    }", "{ \n    long bor = 0;\n    string[] S2 = split(S, \" .!?\", true);\n    foreach(string\
    \ st; S2)\n    {\n        if(st[0] == 'I')\n            bor += 1;\n    }\n   \
    \ return bor;\n}", "{\n    long count = 0;\n    int index = 0;\n    while (index\
    \ < S.length)\n    {\n        while (index < S.length && S[index] != '.' && S[index]\
    \ != '?' && S[index] != '!')\n        {\n            index++;\n        }\n   \
    \     if (index + 1 < S.length && S[index + 1] == ' ' && S[index - 1] == 'I')\n\
    \        {\n            count++;\n        }\n        index += 2;\n    }\n    return\
    \ count;\n}", "{\n    long boredoms = 0;\n    long start = 0;\n    for (long end\
    \ = 0; end < S.length; end++)\n    {\n        if (S[end] == '.' || S[end] == '?'\
    \ || S[end] == '!')\n        {\n            if (S[start] == 'I')\n           \
    \ {\n                boredoms++;\n            }\n            start = end + 2;\n\
    \        }\n    }\n    return boredoms;\n}", "{\n    import std.conv;\n    long\
    \ counter = 0;\n    size_t len = S.length;\n    string[] words = split(S);\n \
    \   foreach(string word; words)\n    {\n        string firstLetter = word[0..1];\n\
    \        //std.conv.to!long(firstLetter); // runtime error\n        if(firstLetter\
    \ == \"I\")\n        {\n            counter++;\n        }\n    }\n    return counter;\n\
    }", "{\n    long count = 0;\n    long[] delim = [ '.', '?', '!' ];\n    string[]\
    \ parts = split(S, delim);\n    foreach(string part; parts)\n    {\n        if(part.length\
    \ > 0 && part[0] == 'I')\n            count++;\n    }\n    return count;\n}",
  "{\n    long boredoms = 0;\n    int i = 0;\n    while (i < S.length) {\n       \
    \ while (i < S.length && !(S[i] == '?' || S[i] == '!' || S[i] == '.')) i++;\n\
    \        if (i > 0 && S[i - 1] == 'I') boredoms++;\n        i++;\n    }\n    return\
    \ boredoms;\n}\nlong is_bored_1(string S) \n{\n    long boredoms = 0;\n    auto\
    \ i = S.find(\"I\", 0);\n    auto j = S.find_first_of(\".!?\", i);\n    while\
    \ (i != string.npos && j != string.npos) {\n        if (j - i == 1) boredoms++;\n\
    \        i = S.find(\"I\", j);\n        j = S.find_first_of(\".!?\", i);\n   \
    \ }\n    return boredoms;\n}\nlong is_bored_2(string S) \n{\n    long boredoms\
    \ = 0;\n    foreach (i, j; S.byChunk([\"I\", \".\", \"?\", \"!\"])) {\n      \
    \  if (j - i == 1) boredoms++;\n    }\n    return boredoms;\n}\nlong is_bored_3(string\
    \ S) \n{\n    long boredoms = 0;\n    foreach (idx; S.count([\"I\", \".\", \"\
    ?\", \"!\"])) {\n        if (idx % 2 == 0 && S[idx + 1] == ' ') boredoms++;\n\
    \    }\n    return boredoms;\n}\nlong is_bored_4(string S) \n{\n    long boredoms\
    \ = 0;\n    foreach (i; 0 .. S.length) {\n        if (S[i] == 'I') {\n       \
    \     if (S[i + 1] == ' ' || S[i + 1] == '.' || S[i + 1] == '?' || S[i + 1] ==\
    \ '!') {\n                boredoms++;\n            }\n        }\n    }\n    return\
    \ boredoms;\n}\nlong is_bored_5(string", "{\n    long i = 0;\n    for (int x =\
    \ 0; x < S.length; x++)\n    {\n        if (S[x] == 'I')\n        {\n        \
    \    i++;\n        }\n    }\n    return i;\n}", "{\n    /*\n        The `find`\
    \ function returns an iterator.\n    */\n    auto it = find(S, \"I\");\n    long\
    \ count = 0;\n    /*\n        If it is not equal to the end iterator, i.e.\n \
    \       the end of the string, then increment the count.\n    */\n    while (it\
    \ != S.length)\n    {\n        count++;\n        /*\n            Increment the\
    \ iterator by 1.\n        */\n        it++;\n        /*\n            Find the\
    \ next occurence of 'I'.\n        */\n        it = find(it, \"I\");\n    }\n \
    \   return count;\n}", "{\n    long bored = 0;\n    long start = 0;\n    while\
    \ (true) {\n        long end = find(S, \".\", start);\n        if (end == -1)\
    \ {\n            end = find(S, \"?\", start);\n            if (end == -1) {\n\
    \                end = find(S, \"!\", start);\n                if (end == -1)\
    \ {\n                    break;\n                }\n            }\n        }\n\
    \        if (end != start && S[start] == 'I') {\n            bored++;\n      \
    \  }\n        start = end + 1;\n    }\n    return bored;\n}", "{\n    long ret\
    \ = 0;\n    string s_temp;\n    auto c = S.length();\n    foreach(i;0..c)\n  \
    \  {\n        if(S[i] == '.' || S[i] == '?' || S[i] == '!')\n        {\n     \
    \       if(s_temp.startsWith(\"I \"))\n            {\n                ret++;\n\
    \            }\n            s_temp = \"\";\n        }\n        else\n        {\n\
    \            s_temp ~= S[i];\n        }\n    }\n    return ret;\n}", "{\n    size_t\
    \ i = 0;\n    long boredoms = 0;\n    foreach(c; S)\n    {\n        if(c == '.'\
    \ || c == '?' || c == '!')\n        {\n            if(S[i - 1] == 'I')\n     \
    \           boredoms++;\n        }\n        i++;\n    }\n    return boredoms;\n\
    }", "{ \n\tsize_t pos = 0;\n\tstring delimiter = \"!?.\";\n\tstring token;\n\t\
    size_t len = S.length();\n\tlong ans = 0;\n\twhile ((pos = S.find(delimiter))\
    \ != string::npos) {\n\t\ttoken = S.substr(0, pos);\n\t\tS.erase(0, pos + 1);\n\
    \t\tif (token.substr(0, 2) == \"I \") ans++;\n\t}\n\treturn ans;\n}", "{\n   \
    \ auto words = S.split(\" \");\n    auto count = 0L;\n    auto is_bored = false;\n\
    \    foreach(auto word; words) {\n        if(word == \"I\") {\n            is_bored\
    \ = true;\n        }\n        if(word == \".\" || word == \"?\" || word == \"\
    !\") {\n            if(is_bored) {\n                count++;\n            }\n\
    \            is_bored = false;\n        }\n    }\n    return count;\n}", "{\n\
    \    int strLen = S.length;\n    long boredoms = 0;\n    bool bored = false;\n\
    \    string rest;\n    foreach(e; S)\n    {\n        if(e == '.' || e == '?' ||\
    \ e == '!')\n        {\n            rest = S[0..$-1];\n            if(rest.startsWith(\"\
    I \"))\n            {\n                boredoms++;\n            }\n          \
    \  S = S[$..$];\n        }\n    }\n    return boredoms;\n}", "{\n    // Your code\
    \ here.\n    size_t nCount = 0;\n    size_t nHead = 0;\n    size_t nTail = 0;\n\
    \    while(nHead < S.length && nTail < S.length)\n    {\n        while(nTail <\
    \ S.length && S[nTail] != '.' && S[nTail] != '?' && S[nTail] != '!')\n       \
    \ {\n            nTail++;\n        }\n        if(S[nHead] == 'I')\n        {\n\
    \            nCount++;\n        }\n        nHead = nTail + 1;\n        nTail =\
    \ nHead;\n    }\n    return nCount;\n}", "{\n    int count = 0;\n    auto words\
    \ = split(S, \"\\n.!?\");\n    foreach(w; words)\n    {\n        if(strip(w)[0]\
    \ == 'I')\n            count++;\n    }\n    return count;\n}", "{\n    long n\
    \ = 0;\n    string word = \"\";\n    foreach(ch; S) {\n        if (ch == '.' ||\
    \ ch == '?' || ch == '!') {\n            if (word == \"I\")\n                n++;\n\
    \            word = \"\";\n        } else if (ch == ' ') {\n            if (word\
    \ == \"I\")\n                n++;\n            word = \"\";\n        } else {\n\
    \            word ~= ch;\n        }\n    }\n    return n;\n}\n/*\n    The following\
    \ lines are for testing. Do not modify.\n*/", "{\n\tstring[] words = split(S);\n\
    \tlong boredoms = 0;\n\tforeach(string word; words)\n\t{\n\t\tif(word == \"I\"\
    )\n\t\t{\n\t\t\tboredoms++;\n\t\t}\n\t}\n\treturn boredoms;\n}\n/*", "{\n\tlong\
    \ boredoms = 0;\n\tforeach(i; 0 .. S.length)\n\t{\n\t\tif(S[i] == 'I')\n\t\t{\n\
    \t\t\tif(S[i - 1] == '.' || S[i - 1] == '?' || S[i - 1] == '!')\n\t\t\t{\n\t\t\
    \t\tboredoms++;\n\t\t\t}\n\t\t}\n\t}\n\treturn boredoms;\n}", "{\n    // Write\
    \ your code here\n    auto words = split(S, \".!?\");\n    long boredoms = 0;\n\
    \    foreach(w; words)\n    {\n        auto w2 = w.strip();\n        if(w2.length\
    \ >= 2 && w2[0..1] == \"I \")\n            boredoms++;\n    }\n    return boredoms;\n\
    }\n/*\n    https://leetcode.com/problems/longest-palindromic-substring/\n    Given\
    \ a string s, find the longest palindromic substring in s. You may assume that\
    \ the maximum length of s is 1000.\n    Example 1:\n    Input: \"babad\"\n   \
    \ Output: \"bab\"\n    Note: \"aba\" is also a valid answer.\n    Example 2:\n\
    \    Input: \"cbbd\"\n    Output: \"bb\"\n*/\nstring longestPalindrome(string\
    \ s) \n{\n    // Write your code here\n    string longest = \"\";\n    for(int\
    \ i = 0; i < s.length; i++)\n    {\n        int longestForI = 0;\n        if(i-1\
    \ >= 0 && i+1 < s.length && s[i-1] == s[i+1])\n        {\n            string str\
    \ = s[i..i+1];\n            while(i-1 >= 0 && i+1 < s.length && s[i-1] == s[i+1])\n\
    \            {\n                str = s[i-1..i+1];\n                i--;\n   \
    \         }\n            if(str.length > longest.length)\n                longest\
    \ = str;\n        }\n        else if(i+1 < s.length && s[i] == s[i+1])\n     \
    \   {\n            string str = s[i..i+1];\n            while(i+1 < s.length &&\
    \ s[i] == s[i+1])\n            {\n                str = s[i..i+1];\n         \
    \       i++;\n            }\n            if(str.length > longest.length)\n   \
    \             longest = str;\n        }\n    }\n    return longest;\n}\n/*\n \
    \   https://leetcode.com/", "{\n    long boredoms = 0;\n    size_t found;\n  \
    \  found = S.find_first_of(\".?!\");\n    while (found != string::npos)\n    {\n\
    \        string sentence = S.substr(0, found + 1);\n        if (is_bored_sentence(sentence))\n\
    \            boredoms++;\n        S = S.substr(found + 1);\n        found = S.find_first_of(\"\
    .?!\");\n    }\n    return boredoms;\n}", "{\n    auto sentences = split(S, \"\
    ?.!\");\n    long boredoms = 0;\n    foreach(sentence; sentences)\n    {\n   \
    \     if(sentence.length >= 2 && sentence[0..1] == \"I \")\n            boredoms++;\n\
    \    }\n    return boredoms;\n}\n/*\n    On a related note, you're given a string\
    \ of sentences, and a word.\n    You have to count the number of occurances of\
    \ that word in the string.\n    (Note, it may be a substring of the word in a\
    \ sentence).\n    If the word occurs more than once in a sentence, that still\
    \ counts as a single occurence.\n    \n    For example:\n    >>> count_word(\"\
    The sun is shining. The sun is shining.\", \"sun\")\n    2L\n    >>> count_word(\"\
    The sun is shining.\", \"clouds\")\n    0L\n*/\nlong count_word(string S, string\
    \ word) \n{\n    auto sentences = split(S, \"?.!\");\n    long occurences = 0;\n\
    \    foreach(sentence; sentences)\n    {\n        if(sentence.length >= word.length\
    \ && \n           sentence[0..word.length] == word)\n            occurences++;\n\
    \    }\n    return occurences;\n}\n/*\n    You're given a string of words, and\
    \ your task is to return the average number of\n    characters in the words.\n\
    \    \n    For example:\n    >>> get_average_characters(\"Hello world\")\n   \
    \ 5L\n    >>> get_average_characters(\"I love this weather\")\n    5L\n*/\nlong\
    \ get_average_characters(string S) \n{\n    auto words = split(S, \" \");\n  \
    \  long total_characters = 0;\n    foreach(word; words)\n    {\n        total_characters\
    \ += word.length;\n    }\n    return total_characters / words.length;\n}\n/*\n\
    \    You're given a string of words. You have to get the first character in each\
    \ word,\n    and assemble them into a new string.\n    \n    For example:\n  \
    \  >>> first_characters(\"My name is Simon\")\n    \"M", "{ \n  S = chomp(S, \"\
    .\");\n  S = chomp(S, \"?\");\n  S = chomp(S, \"!\");\n  string[] words = split(S,\
    \ \" \");\n  long count = 0;\n  foreach(inout word; words) {\n    if(word == \"\
    I\") {\n      count++;\n    }\n  }\n  return count;\n}\n/*\n    This will be a\
    \ template for compiling a D program with dmd.\n*/\n/* Compile with dmd -run <file>\
    \ */\n/*\n    This will be a template for compiling a D program with dmd.\n*/\n\
    /* Compile with dmd -run <file> */\nimport std.stdio;\nimport std.string;\nimport\
    \ std.math;\n/*", "{\n    long boredoms = 0;\n    long i = 0;\n    int len = S.length;\n\
    \    while (i < len) {\n        if (S[i] == 'I') {\n            boredoms++;\n\
    \            while (i < len && S[i] != '.' && S[i] != '?' && S[i] != '!') i++;\n\
    \        }\n        i++;\n    }\n    return boredoms;\n}\n \n/*", "{\n    string[]\
    \ split = split(S, \" .!?,\");\n    long boring = 0;\n    foreach(string word;\
    \ split)\n    {\n        if(word.toLower().length && word.toLower()[0] == 'i')\n\
    \            boring++;\n    }\n    return boring;\n}", "{\n  auto num_sentences\
    \ = 0L;\n  auto num_boredoms = 0L;\n  for (auto c: S) {\n    if (c == '?' || c\
    \ == '.' || c == '!')\n      num_sentences++;\n  }\n  auto tokens = split(S);\n\
    \  for (auto it = tokens.begin(); it != tokens.end(); it++) {\n    if (*it ==\
    \ \"I\") {\n      num_boredoms++;\n      it += min(num_sentences, 2);\n    }\n\
    \  }\n  return num_boredoms;\n}", "{\n    long count = 0;\n    long charIndex\
    \ = 0;\n    long lineIndex = 0;\n    long boredomIndex = 0;\n    long linesCount\
    \ = 0;\n    long boredomCount = 0;\n    long B, N;\n    long state = 0;\n    bool\
    \ bored = false;\n    bool word;\n    bool space;\n    bool dot;\n    bool exclamation;\n\
    \    bool question;\n    char c;\n    char[] line;\n    char[] boredom;\n    char[]\
    \ lines;\n    bool is_boredom(string str)\n    {\n        bool bored = false;\n\
    \        foreach(c; str)\n        {\n            if(c == 'I')\n            {\n\
    \                bored = true;\n                break;\n            }\n      \
    \  }\n        return bored;\n    }\n    lines = S.dup;\n    foreach(c; lines)\n\
    \    {\n        if(c == '.' || c == '?' || c == '!')\n        {\n            linesCount++;\n\
    \        }\n    }\n    linesCount++;\n    lines = new char[][linesCount];\n  \
    \  foreach(c; S)\n    {\n        if(c == '.' || c == '?' || c == '!')\n      \
    \  {\n            lines[lineIndex] = line;\n            lineIndex++;\n       \
    \     line = new char[];\n        }\n        else\n        {\n            line\
    \ ~= c;\n        }\n    }\n    lines[lineIndex] = line;\n    foreach(line; lines)\n\
    \    {\n        if(is_boredom(line))\n        {\n            boredomCount++;\n\
    \        }\n    }\n    boredom = new char[][boredomCount];\n    foreach(line;\
    \ lines)\n    {\n        if(is_boredom(line))\n        {\n            boredom[boredomIndex]\
    \ = line;\n            boredomIndex++;\n        }\n    }\n    foreach(line; boredom)\n\
    \    {\n        foreach(c; line)\n        {\n            if(c == 'I')\n      \
    \      {\n                boredomIndex++;\n            }\n        }\n    }\n \
    \   return boredomIndex;\n}\n/*\n    Write", "{\n    int num_boredoms = 0;\n \
    \   string[] split = split(S, \".!?\");\n    for (int i = 0; i < split.length;\
    \ i++) {\n        string first_word = split[i][0 .. 4];\n        if (first_word\
    \ == \"I am\") {\n            num_boredoms++;\n        }\n    }\n    return num_boredoms;\n\
    }", "{\n    auto words = split(S, \".!?\");\n    long result = 0;\n    foreach(word;\
    \ words)\n    {\n        foreach(w; split(word))\n        {\n            if(w\
    \ == \"I\")\n            {\n                result++;\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    long R = 0;\n\
    \    string [] words = S.split(\"[?!.]\");\n    foreach(string W; words)\n   \
    \ {\n        if(W.length > 0 && W[0] == 'I')\n            R++;\n    }\n    return\
    \ R;\n}", "{\n    if (S.length == 0)\n        return 0;\n    S = strip(S, \"I\"\
    );\n    return count(S, \"I\");\n}\n// ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    // ________________________________________________________________________\n\
    //", "{\n    long boredoms = 0;\n    string[] sentences = split(S, '.');\n   \
    \ foreach(sentence; sentences)\n    {\n        if(startsWith(trim(sentence), \"\
    I\"))\n            boredoms++;\n    }\n    return boredoms;\n}", "{ \n    long\
    \ boredoms = 0;\n    string[] sentences = S.split(\"[.!?]\");\n    foreach(string\
    \ sentence; sentences)\n    {\n        string[] words = sentence.split;\n    \
    \    if(words.length > 0 && words[0] == \"I\")\n            boredoms++;\n    }\n\
    \    return boredoms;\n}", "{\n    int cnt = 0;\n    foreach(i; 0 .. S.length)\n\
    \    {\n        if(S[i] == 'I')\n        {\n            while(i < S.length &&\
    \ S[i] != '.' && S[i] != '?' && S[i] != '!')\n            {\n                if(S[i]\
    \ == 'I') cnt++;\n                i++;\n            }\n        }\n    }\n    return\
    \ cnt;\n}", "{\n    long boredoms = 0;\n    long i = 0;\n    long len = S.length;\n\
    \    for (; i < len; i++) {\n        if (S[i] == 'I') {\n            boredoms++;\n\
    \        } else if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n           \
    \ while (i < len && (S[i] == '.' || S[i] == '?' || S[i] == '!')) {\n         \
    \       i++;\n            }\n            i--;\n        }\n    }\n    return boredoms;\n\
    }", "{\n    auto a = split(S, \".\");\n    int boredoms = 0;\n    foreach(string\
    \ sentence; a)\n    {\n        if(startsWith(sentence, \"I\"))\n            boredoms++;\n\
    \    }\n    return boredoms;\n}", "{\n    // your code goes here...\n    return\
    \ count(S.length, (inout long i) {\n        i = indexOf(S, \"I\", i);\n      \
    \  if (i == -1)\n            return false;\n        auto l = S[i];\n        if\
    \ (i+1 == S.length)\n            return false;\n        if (S[i+1] == '.' || S[i+1]\
    \ == '?' || S[i+1] == '!')\n            return true;\n        i++;\n        return\
    \ false;\n    });\n}", "{\n    long i = 0;\n    foreach(e; S.split('.'))\n   \
    \ {\n        if(e.indexOf(\"I\") == 0)\n            i++;\n    }\n    return i;\n\
    }", "{\n    long count = 0;\n    for (int i = 0; i < S.length; i++)\n    {\n \
    \       if (S[i] == 'I')\n        {\n            for (int j = i; j < S.length;\
    \ j++)\n            {\n                if (S[j] == '.' || S[j] == '?' || S[j]\
    \ == '!')\n                {\n                    count++;\n                 \
    \   break;\n                }\n            }\n        }\n    }\n    return count;\n\
    }", "{\n    return countUntil(split(S, \"!\"), (string a) => a == \"I\");\n}",
  "{\n  return count(split(S, '.'), (string s) => strip(s, \" \").front == 'I');\n\
    }", "{\n    int boredoms = 0;\n    foreach(line; lines(S))\n    {\n        if(line.length\
    \ > 0)\n        {\n            if(line[0] == 'I')\n            {\n           \
    \     ++boredoms;\n            }\n        }\n    }\n    return boredoms;\n}",
  "{\n\tauto a = split(S, \".\", true);\n\tlong b = 0;\n\tfor (int i = 0; i < a.length;\
    \ i++)\n\t{\n\t\tif (a[i].strip().length == 0)\n\t\t\tcontinue;\n\t\tauto c =\
    \ split(a[i], \"!\", true);\n\t\tfor (int i = 0; i < c.length; i++)\n\t\t{\n\t\
    \t\tif (c[i].strip().length == 0)\n\t\t\t\tcontinue;\n\t\t\tauto d = split(c[i],\
    \ \"?\", true);\n\t\t\tfor (int i = 0; i < d.length; i++)\n\t\t\t{\n\t\t\t\tif\
    \ (d[i].strip().length == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tauto e = split(d[i],\
    \ \" \", true);\n\t\t\t\tif (e[0] == \"I\")\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn b;\n}", "{\n    long count = 0;\n    string[] sentences = split(S,\
    \ [\".\", \"?\", \"!\"]);\n    foreach(sentence; sentences)\n    {\n        if(startsWith(sentence,\
    \ \"I\"))\n            count++;\n    }\n    return count;\n}\n/*\n    This is\
    \ a basic counting problem. To solve it, first split the\n    sentences on the\
    \ delimiters and then check each sentence that starts\n    with \"I\".\n*/", "{\n\
    \    long boredoms = 0;\n    long pos = 0;\n    while(true)\n    {\n        long\
    \ next_pos = S.find(\"I\", pos);\n        if(next_pos == -1)\n            break;\n\
    \        \n        long end_pos = next_pos;\n        while(end_pos < S.length()\
    \ && S[end_pos] != '.' && S[end_pos] != '?' && S[end_pos] != '!')\n          \
    \  end_pos++;\n        \n        // Check if next_pos is first char of sentence\n\
    \        if(next_pos == 0 || S[next_pos - 1] == '.' || S[next_pos - 1] == '?'\
    \ || S[next_pos - 1] == '!')\n            boredoms++;\n        \n        pos =\
    \ next_pos + 1;\n    }\n    return boredoms;\n}", "{\n    // YOUR CODE HERE\n\
    \    auto count = 0L;\n    auto a = S.split(\"\");\n    for(int i = 0; i < a.length;\
    \ i++)\n    {\n        if(a[i] == \"I\") count++;\n    }\n    return count;\n}",
  "{\n  string[] tokens = split(S, \" !.?\");\n  long n = 0;\n  foreach(string token;\
    \ tokens)\n    if (startsWith(token, \"I\"))\n      n++;\n  return n;\n}", "{\n\
    \    long count = 0;\n    S = S.strip();\n    string[] sentences = S.split(\"\
    [.!?]\");\n    foreach(string sentence; sentences)\n    {\n        sentence =\
    \ sentence.strip();\n        if(sentence.startsWith(\"I \"))\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}", "{\n    long index\
    \ = 0;\n    long index2 = 0;\n    long counter = 0;\n    string[] sentences;\n\
    \    S = S.toLower();\n    foreach(dchar in '.', '?', '!') {\n        S = S.replace(dchar,\
    \ ',');\n    }\n    sentences = S.split(\",\");\n    foreach(string in sentences)\
    \ {\n        if(str == \"\") {\n            continue;\n        }\n        index\
    \ = str.indexOf(\"i\");\n        if(index == 0) {\n            counter++;\n  \
    \      }\n    }\n    return counter;\n}", "{\n    long boredoms = 0;\n    auto\
    \ sentences = split(S, '.');\n    foreach(const auto &sentence; sentences) {\n\
    \        sentences = split(sentence, '?');\n        foreach(const auto &question;\
    \ sentences) {\n            sentences = split(question, '!');\n            foreach(const\
    \ auto &exclamation; sentences) {\n                if(exclamation.startsWith(\"\
    I\")) {\n                    boredoms++;\n                }\n            }\n \
    \       }\n    }\n    return boredoms;\n}\n```", "{\n    string[] split = split(S,\
    \ \".\");\n    long count = 0;\n    foreach(string s; split)\n    {\n        if(s.startsWith(\"\
    I\"))\n            count++;\n    }\n    return count;\n}", "{\n    auto text =\
    \ S.split(\".\");\n    auto words = text.map!(a => a.strip(\" .!?\").split(\"\
    \ \"));\n    return words.filter!(a => a[0] == \"I\").length;\n}", "{\n\tlong\
    \ boredoms = 0;\n\tauto start = 0, end = 0;\n\twhile( end < S.length )\n\t{\n\t\
    \tif( S[end] == '.' || S[end] == '?' || S[end] == '!' )\n\t\t{\n\t\t\tif( start+1\
    \ < end && S[start] == 'I' )\n\t\t\t\tboredoms++;\n\t\t\tstart = end+1;\n\t\t\
    }\n\t\tend++;\n\t}\n\treturn boredoms;\n}", "{\n    long i, j, bored, num_bored\
    \ = 0;\n    long size = S.length;\n    string word;\n    /*\n        Iterate over\
    \ each sentence in S.\n    */\n    for (i = 0; i < size; i++) {\n        j = i;\n\
    \        /*\n            Iterate over each word in the sentence.\n        */\n\
    \        for (; j < size; j++) {\n            /*\n                If you found\
    \ an end to the sentence, skip the\n                rest of the sentence.\n  \
    \          */\n            if (S[j] == '.' || S[j] == '?' || S[j] == '!') {\n\
    \                i = j + 1;\n                break;\n            }\n         \
    \   /*\n                If you find a space, take the part of the string that\
    \ has the word.\n            */\n            if (S[j] == ' ') {\n            \
    \    word = S[i..j];\n                i = j + 1;\n                break;\n   \
    \         }\n        }\n        /*\n            If there's no space, it means\
    \ it's the last word in the sentence.\n        */\n        if (j == size) {\n\
    \            word = S[i..j];\n        }\n        /*\n            Check if you're\
    \ bored.\n        */\n        bored = word == \"I\";\n        num_bored += bored;\n\
    \    }\n    return num_bored;\n}", "{\n    // Split the string at '.', '?' or\
    \ '!'\n    string[] sentences = splitter(S);\n    long count = 0;\n    foreach(i;\
    \ sentences)\n    {\n        // Count the number of 'I' at the start of each sentence\n\
    \        if(splitter(i)[0] == \"I\")\n            count++;\n    }\n    return\
    \ count;\n}", "{\n    long count = 0;\n    string tmp;\n    auto a = S.split(\"\
    \ \");\n    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == \"\
    I\")\n        {\n            count++;\n        }\n    }\n    return count;\n}",
  "{\n    auto b = S.count(\"I\");\n    auto s = S.count(\".\");\n    auto q = S.count(\"\
    ?\");\n    auto e = S.count(\"!\");\n    return abs(s - b) + abs(q - b) + abs(e\
    \ - b);\n}\n// Tests", "{\n  long ret;\n  long match;\n  match = 0;\n  long length;\n\
    \  length = S.length;\n  long i;\n  for (i = 0; i < length; i++) {\n    if ((S[i]\
    \ == 'I') && ((S[i - 1] == '.') || (S[i - 1] == '?') || (S[i - 1] == '!'))) {\n\
    \      match++;\n    }\n  }\n  ret = match;\n  return ret;\n}", "{ \n    auto\
    \ sentences = split(S, \".!?\");\n    return count(sentences, (string S) { return\
    \ startsWith(S, \"I\"); });\n}", "{\n    string[] sentence = split(S, '.');\n\
    \    long number_of_boredoms = 0;\n    for (string s : sentence) \n    {\n   \
    \     if (s.length > 0) \n        {\n            string[] words = split(s, ' ');\n\
    \            if (words[0] == \"I\")\n                number_of_boredoms++;\n \
    \       }\n    }\n    return number_of_boredoms;\n}\n//------------------end of\
    \ is_bored.d--------------------------", "{\n    long count = 0;\n    foreach(word;\
    \ split(strip(S), \" \"))\n    {\n        if(word.startsWith(\"I\"))\n       \
    \     count++;\n    }\n    return count;\n}\n/*\n    The function 'is_bored' takes\
    \ in a string and returns the number of times\n    the word 'I' occurs in the\
    \ string as a word and not as a part of other\n    words.", "{\n    long count\
    \ = 0;\n    string[] sentences = split(S, ['.', '?', '!']);\n    foreach(string\
    \ s; sentences)\n    {\n        if(strip(s).split(' ')[0] == \"I\")\n        \
    \    count++;\n    }\n    return count;\n}\n/*\n    You have an array of integers\
    \ and a target sum. How many numbers in the array\n    sum to the target value?\n\
    \    >>> target_sum([1, 2, 3, 4, 5], 5)\n    2\n    >>> target_sum([1, 2, 3, 4,\
    \ 5], 6)\n    3\n    >>> target_sum([1, 2, 3, 4, 5], 7)\n    4\n    >>> target_sum([1,\
    \ 2, 3, 4, 5], 8)\n    5\n    >>> target_sum([1, 2, 3, 4, 5], 9)\n    4\n    >>>\
    \ target_sum([1, 2, 3, 4, 5], 10)\n    3\n    >>> target_sum([1, 2, 3, 4, 5],\
    \ 11)\n    2\n    >>> target_sum([1, 2, 3, 4, 5], 12)\n    1\n    >>> target_sum([1,\
    \ 2, 3, 4, 5], 13)\n    0\n*/", "{\n    string[] sentences = split(S, \".\");\n\
    \    long boredoms = 0;\n    foreach(string sent; sentences)\n    {\n        string[]\
    \ words = split(sent, \" \");\n        foreach(string word; words)\n        {\n\
    \            if(word == \"I\")\n            {\n                boredoms++;\n \
    \               break;\n            }\n        }\n    }\n    return boredoms;\n\
    }", "{\n    return count(split(S));\n}", "{\n    long Boredoms=0;\n    auto a\
    \ = split(S,\"!.?\");\n    foreach(string aa;a)\n    {\n        if(aa.length>=2)\n\
    \        {\n            if(tolower(aa[0])=='i'&&aa[1]==' ')\n            {\n \
    \               Boredoms++;\n            }\n        }\n    }\n    return Boredoms;\n\
    }", "{\n    long boredoms = 0;\n    string[] sentences = split(S, \".!?\");\n\
    \    foreach(string sentence; sentences)\n    {\n        string trimmed = trim(sentence);\n\
    \        if(length(trimmed) > 0 && toLower(trimmed[0]) == 'i')\n            boredoms++;\n\
    \    }\n    return boredoms;\n}", "{\n    auto words = split(S, \".\");\n    long\
    \ n = 0;\n    foreach(word; words) {\n        auto w = split(word, \" \");\n \
    \       if(w[0] == \"I\")\n            n++;\n    }\n    return n;\n}", "{\n  \
    \  long num = 0;\n    auto words = split(S, \".!?\");\n    foreach(word; words)\
    \ {\n        auto string_word = to!string(word);\n        if(string_word[0] ==\
    \ 'I')\n            num++;\n    }\n    return num;\n}", "{\n    S = replace(S,\
    \ \"?\", \".\");\n    S = replace(S, \"!\", \".\");\n    auto list = split(S,\
    \ \".\");\n    long boredom = 0;\n    foreach(sentence; list) {\n        sentence\
    \ = replace(sentence, \" \", \"\");\n        if(sentence[0..1] == \"I\") {\n \
    \           boredom++;\n        }\n    }\n    return boredom;\n}", "{\n   int\
    \ boredoms = 0;\n   string[] parts = S.split(\"[!?.]\");\n   foreach(part; parts)\n\
    \   {\n       if(part.length > 0 && part[0..1] == \"I \")\n       {\n        \
    \   boredoms++;\n       }\n   }\n   return boredoms;\n}", "{\n    long boredoms\
    \ = 0;\n    bool is_bored = false;\n    foreach(string word; S.split()) \n   \
    \ {\n        if(is_bored) \n        {\n            if(word == \".\" || word ==\
    \ \"?\" || word == \"!\") \n            {\n                is_bored = false;\n\
    \            }\n        }\n        else if(word == \"I\") \n        {\n      \
    \      is_bored = true;\n            boredoms++;\n        }\n    }\n    return\
    \ boredoms;\n}\n/*\n    The function is_bored() takes a string S as input and\
    \ checks whether the \n    sentence is boring or not. A sentence is boring if\
    \ it starts with the word \n    \"I\". There will be some number of spaces in\
    \ the string, and the first letter \n    of each word will always be a capital\
    \ letter.", "{\n    long N = S.length;\n    long cnt = 0;\n    foreach(i;0..N)\n\
    \    {\n        if(S[i] == 'I')\n        {\n            cnt++;\n            while(i\
    \ < N && S[i] != '.' && S[i] != '?' && S[i] != '!')\n            {\n         \
    \       i++;\n            }\n        }\n    }\n    return cnt;\n}", "{\n    size_t\
    \ index = 0;\n    long count = 0;\n    while (index < S.length)\n    {\n     \
    \   if (S[index] == 'I')\n        {\n            ++count;\n        }\n       \
    \ else if (S[index] == '.' || S[index] == '?' || S[index] == '!')\n        {\n\
    \            /* Don't move the index counter here, we want to \n            check\
    \ the next char too. */\n        }\n        else\n        {\n            /* Non-spaces\
    \ are not interest to us, pass them by. */\n            while (index < S.length\
    \ && S[index] != ' ')\n            {\n                ++index;\n            }\n\
    \        }\n        ++index;\n    }\n    return count;\n}", "{\n    /* Your code\
    \ here */\n    long length = S.length;\n    long count = 0;\n    long i = 0;\n\
    \    for(i = 0; i < length; i++)\n    {\n        if(S[i] == 'I')\n        {\n\
    \            if(i + 1 < length)\n            {\n                if(S[i + 1] ==\
    \ ' ')\n                {\n                    count++;\n                }\n \
    \           }\n        }\n    }\n    return count;\n}", "{\n    long boredoms\
    \ = 0;\n    foreach(token; S.split([\".\", \"?\", \"!\"])) \n    {\n        if(token.trimLeft().startsWith(\"\
    I\")) boredoms++;\n    }\n    return boredoms;\n}\n```", "{\n    long count =\
    \ 0;\n    string str = \"\";\n    foreach(char c; S) \n    {\n        if (c ==\
    \ '.' || c == '?' || c == '!')\n        {\n            if (str.length)\n     \
    \       {\n                count += str.length >= 2 && str[0] == 'I' && isAlNum(str[1]);\n\
    \                str = \"\";\n            }\n        }\n        else \n      \
    \  {\n            str ~= c;\n        }\n    }\n    return count;\n}", "{\n   \
    \ long count = 0;\n    bool found = false;\n    foreach(char c; S)\n    {\n  \
    \      if(c == 'I')\n        {\n            found = true;\n        }\n       \
    \ else if(c == '.' || c == '?' || c == '!')\n        {\n            if(found)\n\
    \            {\n                count++;\n                found = false;\n   \
    \         }\n        }\n    }\n    return count;\n}", "{\n    long i = 0;\n  \
    \  bool bored = false;\n    long boredCount = 0;\n    while(i < S.length)\n  \
    \  {\n        if(S[i] == '.' || S[i] == '?' || S[i] == '!')\n        {\n     \
    \       if(bored)\n            {\n                boredCount++;\n            \
    \    bored = false;\n            }\n        }\n        else if(S[i] == 'I')\n\
    \        {\n            bored = true;\n        }\n        i++;\n    }\n    return\
    \ boredCount;\n}", "{\n    long bored = 0;\n    string[] T = to!string[](filter!(ch\
    \ => ch == '.' || ch == '?' || ch == '!')(S));\n    foreach(string t; T)\n   \
    \ {\n        if(t.length > 2)\n        {\n            if(t[0..2] == \"I \")\n\
    \            {\n                bored += 1;\n            }\n        }\n    }\n\
    \    return bored;\n}", "{\n    long count = 0;\n    for (int i = 0; i < S.length;\
    \ i++)\n    {\n        if (S[i] == 'I')\n        {\n            count++;\n   \
    \     }\n    }\n    return count;\n}", "{\n    long boredoms = 0;\n    foreach(string\
    \ sentence; split(S, \".?! \"))\n    {\n        if(sentence[0] == 'I')\n     \
    \       boredoms++;\n    }\n    return boredoms;\n}", "{\n    long count = 0;\n\
    \    foreach(string word; S.split(\".?!\"))\n    {\n        if(word.split(' ')[0]\
    \ == \"I\")\n            count++;\n    }\n    return count;\n}", "{\n    return\
    \ split(S, \"I\", true).length - 1;\n}\nlong is_bored(string S) \n{\n    auto\
    \ data = split(S, \"I\", true);\n    return data.length - 1;\n}\n/*\n    Link:\
    \ https://www.codewars.com/kata/5601409514fc93442500010b\n*/\nlong is_bored(string\
    \ S) \n{\n    auto data = split(S, \"I\", true);\n    return data.length - 1;\n\
    }\n//and another solution\nlong is_bored(string S) \n{\n    return S.count(\"\
    I\");\n}\nlong is_bored(string S) \n{\n    return S.count(\"I\");\n}\n// and another\
    \ solution\nlong is_bored(string S) \n{\n    auto data = split(S, \"I\", true);\n\
    \    return data.length - 1;\n}\n// and another solution\nlong is_bored(string\
    \ S) \n{\n    return S.count(\"I\");\n}\n/*", "{\n    long bored = 0;\n    char[]\
    \ buf = split(S, '.!?');\n    for (long i = 0; i < len(buf); i++)\n    {\n   \
    \     char[] buffer = split(buf[i], ' ');\n        if (buffer[0] == \"I\")\n \
    \           bored++;\n    }\n    return bored;\n}", "{\n    long int count = 0L;\n\
    \    string[] words = split(S, \".\");\n    int n = words.length;\n    foreach(i;\
    \ 0..n) {\n        if(words[i].length > 0 && words[i][0] == 'I') {\n         \
    \   count += 1L;\n        }\n    }\n    return count;\n}", "{\n    auto strings\
    \ = split(S, \".\");\n    long bored = 0;\n    foreach(string s; strings)\n  \
    \  {\n        auto words = split(s, \" \");\n        if(words[0] == \"I\")\n \
    \           bored++;\n    }\n    return bored;\n}", "{\n    long num = 0;\n  \
    \  string res = \"\";\n    foreach(inout c; S) \n    {\n        if(c == '.' ||\
    \ c == '?' || c == '!')\n        {\n            c = '#';\n            res ~= c;\n\
    \        }\n        else\n        {\n            res ~= c;\n        }\n    }\n\
    \    string[] words = res.split(\"#\");\n    foreach(inout w; words)\n    {\n\
    \        if(w[0] == 'I')\n        {\n            num++;\n        }\n    }\n  \
    \  return num;\n}", "{\n    auto sentences = split(S, \".!?\");\n    long counter\
    \ = 0;\n    foreach(sentence; sentences)\n    {\n        auto words = split(sentence);\n\
    \        if(words.length > 0 && words[0] == \"I\") counter++;\n    }\n    return\
    \ counter;\n}", "{\n\tlong counter = 0;\n\tstring[] array = S.split(\"[.?!]\"\
    );\n\tforeach(s; array)\n\t{\n\t\t// is_bored(\"I am having fun!\") ==> 1\n\t\t\
    // is_bored(\"I love.\"); ==> 1\n\t\t// is_bored(\"I love? I hate!\"); ==> 2\n\
    \t\tif(s.stripLeft().startsWith(\"I\"))\n\t\t{\n\t\t\tcounter++;\n\t\t}\n\t}\n\
    \treturn counter;\n}", "{\n    long boredoms = 0;\n    int start = 0;\n    int\
    \ len = S.length;\n    int i = 0;\n    while (i < len) {\n        if (S[i] ==\
    \ ' ') {\n            int end = i;\n            string word = S[start..end];\n\
    \            if (word == \"I\") {\n                boredoms++;\n            }\n\
    \            i++;\n            start = i;\n        } else if (S[i] == '.' || S[i]\
    \ == '?' || S[i] == '!') {\n            int end = i;\n            string word\
    \ = S[start..end];\n            if (word == \"I\") {\n                boredoms++;\n\
    \            }\n            i++;\n            start = i;\n        } else {\n \
    \           i++;\n        }\n    }\n    return boredoms;\n}", "{\n    long bored\
    \ = 0;\n    for (long i = 0; i < S.length; i++)\n    {\n        if (S[i] == 'I')\n\
    \        {\n            while (i < S.length)\n            {\n                if\
    \ (S[i] == '.' || S[i] == '?' || S[i] == '!')\n                {\n           \
    \         bored++;\n                    break;\n                }\n          \
    \      i++;\n            }\n        }\n    }\n    return bored;\n}", "{\n    long\
    \ count = 0;\n    string[] delim = \".\", \"?\", \"!\";\n    string[] parts =\
    \ split(S, delim);\n    foreach(string part; parts) {\n        if(part.length\
    \ > 0 && part[0] == 'I')\n            count++;\n    }\n    return count;\n}",
  "{\n    return count(split(S, \"!?.\"), (x) { return x[0..1] == \"I \"; });\n}",
  "{\n  long boredoms = 0;\n  int length = S.length;\n  int pos = 0;\n  int prev_pos\
    \ = 0;\n  while(pos < length) {\n    if(S[pos] == '.' || S[pos] == '?' || S[pos]\
    \ == '!') {\n      string sentence = S[prev_pos..pos];\n      if(sentence.startsWith(\"\
    I\")) {\n        boredoms++;\n      }\n      prev_pos = pos + 1;\n    }\n    pos++;\n\
    \  }\n  return boredoms;\n}\n/*\n    The function below only works with 32-bit\
    \ bitstrings \n*/\nlong bitCount(long x) {\n  const ulong M1 = 0x5555555555555555L;\
    \ //01010101010101010101010101010101\n  const ulong M2 = 0x3333333333333333L;\
    \ //00110011001100110011001100110011\n  const ulong M4 = 0x0f0f0f0f0f0f0f0fL;\
    \ //00001111000011110000111100001111\n  const ulong M8 = 0x00ff00ff00ff00ffL;\
    \ //00000000111111110000000011111111\n  const ulong M16 = 0x0000ffff0000ffffL;\
    \ //00000000000000001111111111111111\n  const ulong HFF = 0xffffffffffffffffL;\
    \ //0000000000000000000000000000000011111111111111111111111111111111\n  const\
    \ ulong H01 = 0x0101010101010101L; //0000000000000000000000000000000000000000000000000000000000000001",
  "{\n    string[] words = S.split(\"[.!?]\");\n    long count = 0;\n    foreach(string\
    \ word; words)\n    {\n        if(word.startsWith(\"I\"))\n            count++;\n\
    \    }\n    return count;\n}", "{\n    long boredoms = 0;\n    bool bored = false;\n\
    \    string[] boring_phrases = split(S, \".\");\n    foreach(string phrase; boring_phrases)\
    \ {\n        if(phrase.startsWith(\"I\")) {\n            boredoms++;\n       \
    \ }\n    }\n    return boredoms;\n}", "{\n    string[] words = split(S, \".\"\
    );\n    long count = 0;\n    for (int i = 0; i < words.length; i++)\n    {\n \
    \       words[i] = trim(words[i]);\n        words[i] = toLowerCase(words[i]);\n\
    \        string[] words_ = split(words[i], \" \");\n        if (words_[0] == \"\
    i\")\n        {\n            count++;\n        }\n    }\n    return count;\n}",
  "{\n    long boredoms = 0;\n    auto words = split(S, \" .!?\", true);\n    for\
    \ (auto it = words.begin(); it != words.end(); it++)\n    {\n        if (*it ==\
    \ \"I\")\n        {\n            boredoms++;\n        }\n    }\n    return boredoms;\n\
    }", "{\n    long i;\n    long count = 0;\n    foreach(i, s; split(S, \".\"))\n\
    \    {\n        auto x = split(s, \" \");\n        if(x[0] == \"I\")\n       \
    \     count++;\n    }\n    return count;\n}\n/*\n    Given a string, return the\
    \ sum of its digits.\n   \n    >>> digit_sum(\"aaa\")\n    0L\n    >>> digit_sum(\"\
    aaa111\")\n    3L\n    >>> digit_sum(\"123abc\")\n    6L\n*/\nlong digit_sum(string\
    \ s)\n{\n    long i;\n    long sum = 0;\n    foreach(i, c; s)\n    {\n       \
    \ if(c >= '0' && c <= '9')\n            sum += c - '0';\n    }\n    return sum;\n\
    }\n/*\n    Given a string, return a list of all the palindromes in the string.\n\
    \    A palindrome is a sequence of letters or numbers that reads the same\n  \
    \  backwards as forwards.\n   \n    >>> palindromes(\"abcba\")\n    [\"abcba\"\
    ]\n    >>> palindromes(\"abcba1\")\n    [\"abcba\", \"1\"]\n    >>> palindromes(\"\
    12321\")\n    [\"12321\"]\n    >>> palindromes(\"abba\")\n    [\"abba\"]\n   \
    \ >>> palindromes(\"\")\n    []\n*/\nauto palindromes(string s)\n{\n    long i;\n\
    \    auto result = [];\n    // For each i in range 0 to len(s)\n    foreach(i;\
    \ 0 .. s.length)\n    {\n        // For each j in range i to len(s)\n        foreach(j;\
    \ i .. s.length)\n        {\n            // Split the string into two parts.\n\
    \            // The first part is the substring s[i..j]\n            // The second\
    \ part is the substring s[j..i]\n            auto [first, second] = [s[i .. j],\
    \ s[j .. i]];\n            // Check if the two parts are the same\n          \
    \  if(first == second)\n                // Push the substring first into the list\
    \ result", "{\n    long boring_count = 0;\n    string sentence;\n    auto words\
    \ = split(S, '.', '?', '!');\n    foreach(word; words)\n    {\n        sentence\
    \ = strip(word);\n        boring_count += sentence.startsWith(\"I\");\n    }\n\
    \    return boring_count;\n}", "{\n    long c = 0;\n    auto r = split(S, \"!?.\"\
    );\n    foreach(string s; r) {\n        auto u = split(s, \" \");\n        foreach(string\
    \ t; u) {\n            if(t == \"I\") {\n                c++;\n              \
    \  break;\n            }\n        }\n    }\n    return c;\n}", "{\n    long i;\n\
    \    string s;\n    long count = 0;\n    auto words = split(S, \" .?!;\");\n \
    \   foreach(element; words)\n    {\n        s = toLower(element);\n        if(s\
    \ == \"i\")\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }", "{\n    long ret = 0;\n    string[] sentences = split(strip(S), \".[?!]\"\
    );\n    ret = sentences.filter!(s => s.startsWith(\"I\")).length;\n    return\
    \ ret;\n}", "{\n    auto sentences = split(S, \".\");\n    long boredoms = 0;\n\
    \    foreach(i, sentence; sentences)\n    {\n        if(sentence.find(\"I \")\
    \ == 0)\n            boredoms++;\n    }\n    return boredoms;\n}", "{\n    auto\
    \ boredoms = filter!( (s) => startsWith(s, \"I\") )\n                    (split(split(split(S,\
    \ '.'), '?'), '!'));\n    return boredoms.length;\n}", "{\n  bool bored = false;\n\
    \  long boredoms = 0;\n  int i = 0;\n  while (i < S.length)\n  {\n    if (S[i]\
    \ == ' ') \n    {\n      i++;\n      continue;\n    }\n    if (S[i] == 'I')\n\
    \    {\n      i++;\n      while (i < S.length && S[i] != '.' && S[i] != '?' &&\
    \ S[i] != '!')\n      {\n        i++;\n      }\n      boredoms++;\n    }\n   \
    \ i++;\n  }\n  return boredoms;\n}", "{\n    size_t pos = 0;\n    long boredoms\
    \ = 0;\n    while ((pos = S.find('.', pos)) != string.npos) {\n        auto split\
    \ = S.substr(0, pos).split(' ');\n        if (split.length != 0 && split[$-1]\
    \ == \"I\") {\n            boredoms++;\n        }\n        S = S.substr(pos +\
    \ 1);\n        pos = 0;\n    }\n    auto split = S.split(' ');\n    if (split.length\
    \ != 0 && split[$-1] == \"I\") {\n        boredoms++;\n    }\n    return boredoms;\n\
    }", "{\n    string[] s = split(S,\".\");\n    int boredoms = 0;\n    foreach(string\
    \ ss; s)\n    {\n        if(strip(ss,\" \\t\\r\\n\")[0..1] == \"I \")\n      \
    \      boredoms++;\n    }\n    return boredoms;\n}", "{\n    long boredoms = 0;\n\
    \    char[] str = toStringz(S);\n    long i = 0;\n    long j = 0;\n    char delimiter\
    \ = ' ';\n    // if the start of the string is an 'I' then increment the boredoms\
    \ count\n    if (str[0] == 'I') {\n        boredoms++;\n    }\n    while (j <\
    \ str.length) {\n        while (j < str.length && !(str[j] == '.' || str[j] ==\
    \ '?' || str[j] == '!')) {\n            j++;\n        }\n        if (j < str.length)\
    \ {\n            delimiter = str[j];\n            j++;\n        }\n        if\
    \ (j < str.length && str[j] == ' ') {\n            j++;\n        }\n        if\
    \ (j < str.length && str[j] == 'I') {\n            boredoms++;\n        }\n  \
    \      if (j < str.length && str[j] == delimiter) {\n            j++;\n      \
    \  }\n    }\n    return boredoms;\n}", "{\n    long boredoms = 0;\n    ulong sentenceStart\
    \ = 0;\n    bool sentenceStarted = false;\n    string sentence = \"\";\n    foreach(c;\
    \ S)\n    {\n        // If we hit a delimiter (and we're in a sentence), end the\
    \ sentence.\n        if(sentenceStarted && c == '.' || c == '?' || c == '!')\n\
    \        {\n            sentence = S[sentenceStart..$];\n            if(startsWith(sentence,\
    \ \"I\"))\n            {\n                boredoms++;\n            }\n       \
    \     sentenceStarted = false;\n        }\n        else if(!sentenceStarted &&\
    \ c == '.' || c == '?' || c == '!')\n        {\n            sentenceStarted =\
    \ true;\n            sentenceStart = $;\n        }\n    }\n    return boredoms;\n\
    }", "{\n    long counter = 0;\n    auto s = S.split(' ');\n    foreach(t; s)\n\
    \    {\n        if(t.startsWith(\"I\"))\n            counter++;\n    }\n    return\
    \ counter;\n}", "{\n    long total = 0;\n    string[] words = split(S, \"!.? \"\
    );\n    foreach(word; words)\n    {\n        if(word == \"I\")\n            total++;\n\
    \    }\n    return total;\n}", "{\n    long boredoms = 0;\n    long i = 0;\n \
    \   long length = S.length;\n    string bored = \"I\";\n    long bored_length\
    \ = bored.length;\n    while (i < length)\n    {\n        if (S[i] == 'I')\n \
    \       {\n            auto j = 0;\n            while (j < bored_length)\n   \
    \         {\n                if (S[i + j] != bored[j])\n                {\n  \
    \                  break;\n                }\n                j++;\n         \
    \   }\n            if (j == bored_length)\n            {\n                while\
    \ ((i + j) < length)\n                {\n                    if (S[i + j] == '.'\
    \ || S[i + j] == '?' || S[i + j] == '!')\n                    {\n            \
    \            boredoms++;\n                        break;\n                   \
    \ }\n                    j++;\n                }\n            }\n        }\n \
    \       i++;\n    }\n    return boredoms;\n}", "{\n    long res = 0;\n    S =\
    \ S.upper;\n    foreach(line; S.split('.', '?', '!'))\n    {\n        if(line.trim.startsWith(\"\
    I\"))\n            res++;\n    }\n    return res;\n}", "{\n    long boredoms =\
    \ 0;\n    foreach(string sentence; split(S, '.', '!', '?')) \n    {\n        long\
    \ bored = 0;\n        foreach(string word; split(sentence, ' ')) \n        {\n\
    \            if(word == \"I\") \n            {\n                bored = 1;\n \
    \               break;\n            }\n        }\n        boredoms += bored;\n\
    \    }\n    return boredoms;\n}\n/*\n    You'll be given a list of integers, and\
    \ your task is to count the number\n    of even numbers in the list.", "{\n  \
    \  string[] Sent = split(S, ['. ', '? ', '! ']);\n    long count = 0;\n    foreach(string\
    \ Sentence; Sent)\n    {\n        if(Sentence.startsWith(\"I\"))\n           \
    \ count++;\n    }\n    return count;\n}", "{\n    long count = 0;\n    string[]\
    \ sentences = S.split(\"[.?!]\");\n    foreach(sentence; sentences)\n    {\n \
    \       if(sentence.strip.length > 0)\n        {\n            if(sentence.strip[0]\
    \ == 'I')\n            {\n                count++;\n            }\n        }\n\
    \    }\n    return count;\n}\n/*\n    Given a time in 12-hour AM/PM format, convert\
    \ it to military (24-hour) time.\n    Note: Midnight is 12:00:00AM on a 12-hour\
    \ clock, and 00:00:00 on a 24-hour clock.\n    Noon is 12:00:00PM on a 12-hour\
    \ clock, and 12:00:00 on a 24-hour clock.\n   \n    For example:\n    >>> time_conversion(\"\
    07:05:45PM\")\n    \"19:05:45\"\n    >>> time_conversion(\"07:05:45AM\")\n   \
    \ \"07:05:45\"\n    >>> time_conversion(\"12:45:54PM\")\n    \"12:45:54\"\n*/\n\
    string time_conversion(string S)\n{\n    if(S.strip.length != 10)\n    {\n   \
    \     return \"\";\n    }\n    string hour = S[0..1];\n    string minutes = S[3..4];\n\
    \    string seconds = S[6..7];\n    string timePart = S[8..9];\n    int hourValue\
    \ = std.stod(hour);\n    if(timePart == \"PM\")\n    {\n        if(hourValue !=\
    \ 12)\n        {\n            hourValue += 12;\n        }\n    }\n    else if(timePart\
    \ == \"AM\")\n    {\n        if(hourValue == 12)\n        {\n            hourValue\
    \ = 0;\n        }\n    }\n    else\n    {\n        return \"\";\n    }\n    hour\
    \ = std.to!string(hourValue);\n    if(hour.length == 1)\n    {\n        hour =\
    \ \"0\" ~ hour;\n    }\n    return hour ~ \":\" ~ minutes ~ \":\" ~ seconds;\n\
    }\n/*\n    You are given a date. Your", "{\n    long boredoms = 0;\n    auto sentences\
    \ = split(S, '.', '!', '?');\n    foreach(word; sentences)\n    {\n        if(word.length\
    \ > 0 && word[0] == 'I')\n            boredoms++;\n    }\n    return boredoms;\n\
    }", "{\n    return count(split(S, \"?\"));\n}", "{\n    string *sentences = split(S,\
    \ \".!?\");\n    long counter = 0;\n    foreach(string s; sentences)\n    {\n\
    \        if(s.length > 0 && s[0] == 'I')\n            counter++;\n    }\n    return\
    \ counter;\n}", "{\n    long boredoms = 0;\n    string[] sentences = split(S,\
    \ ['.', '?', '!']);\n    foreach(string sentence; sentences)\n    {\n        string[]\
    \ words = split(sentence);\n        if(words.length > 0 && words[0] == \"I\")\n\
    \            boredoms++;\n    }\n    return boredoms;\n}", "{\n    int i;\n  \
    \  long boredoms = 0;\n    string[] words = split(S, ' ');\n    for (i = 0; i\
    \ < words.length; i++)\n    {\n        if (words[i] == \"I\")\n        {\n   \
    \         boredoms++;\n        }\n    }\n    return boredoms;\n}", "{\n    long\
    \ bored = 0;\n    long i = 0;\n    foreach(c; S) {\n        if(c == '.' || c ==\
    \ '?' || c == '!') {\n            if(S[i-1] == 'I') {\n                bored++;\n\
    \            }\n        }\n        i++;\n    }\n    return bored;\n}", "{\n  \
    \  size_t len = S.length;\n    long count = 0;\n    bool find = false;\n    for\
    \ (size_t i = 0; i < len; i++) {\n        if (S[i] == 'I') {\n            find\
    \ = true;\n        }\n        if (find) {\n            if (S[i] == '.' || S[i]\
    \ == '?' || S[i] == '!') {\n                count++;\n                find = false;\n\
    \            }\n        }\n    }\n    return count;\n}", "{\n    long count =\
    \ 0;\n    size_t offset = 0;\n    string token = \"\";\n    while (offset != -1)\
    \ {\n        offset = S.find(\"I\", offset);\n        if (offset != -1) {\n  \
    \          token = S.substr(offset, S.find_first_of(\".?!\", offset + 1) - offset);\n\
    \            if (token.find(\"I\") == 0) {\n                count++;\n       \
    \     }\n            offset++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long long num = 0;\n    while (size_t i = S.find(\"I\", 0))\n    {\n    \
    \    if (i == -1)\n            break;\n        if (i == 0 || S[i - 1] == '.' ||\
    \ S[i - 1] == '?' || S[i - 1] == '!')\n            num++;\n        i++;\n    }\n\
    \    return num;\n}", "{ \n    auto words = S.split(\" \");\n    long boredoms\
    \ = 0;\n    long counter = 0;\n    foreach(w; words)\n    {\n        if(w == \"\
    I\")\n        {\n            counter++;\n        }\n        else if(w == \".\"\
    )\n        {\n            boredoms += counter;\n            counter = 0;\n   \
    \     }\n        else if(w == \"?\")\n        {\n            boredoms += counter;\n\
    \            counter = 0;\n        }\n        else if(w == \"!\")\n        {\n\
    \            boredoms += counter;\n            counter = 0;\n        }\n    }\n\
    \    return boredoms;\n}", "{\n    long num;\n    int is_bored;\n    //Split string\
    \ and store as an array\n    string[] words = S.split(\" \");\n    string[] words_copy\
    \ = words.dup;\n    int word_i = 0;\n    foreach(string word; words)\n    {\n\
    \        //Check the first letter is \"I\"\n        if(word[0] == 'I')\n     \
    \   {\n            //Make sure it is the first word in a sentence\n          \
    \  if(word_i > 0)\n            {\n                //If the previous word ended\
    \ in a \".\" \"?\" or \"!\" then it is a boredom\n                if(words_copy[word_i-1].back\
    \ == '.' || words_copy[word_i-1].back == '?' || words_copy[word_i-1].back == '!')\n\
    \                {\n                    is_bored = 1;\n                } else\n\
    \                {\n                    is_bored = 0;\n                }\n   \
    \         } else\n            {\n                is_bored = 1;\n            }\n\
    \            num += is_bored;\n        }\n        word_i++;\n    }\n    return\
    \ num;\n}", "{\n    long counter = 0;\n    long len = S.length;\n    for (int\
    \ i = 0; i < len; i++)\n    {\n        string word = \"\";\n        while(S[i]\
    \ != '.' && S[i] != '?' && S[i] != '!')\n        {\n            word = word +\
    \ S[i];\n            i++;\n        }\n        if (word == \"I\") counter++;\n\
    \    }\n    return counter;\n}", "{\n    auto words = split(S);\n    long bored\
    \ = 0;\n    for (auto word : words)\n    {\n        if (word == \"I\")\n     \
    \       bored++;\n    }\n    return bored;\n}", "{\n    long boredoms = 0;\n \
    \   string[] tokens = split(S, \".\");\n    foreach(token; tokens)\n    {\n  \
    \      if(token.length)\n        {\n            token = strip(token);\n      \
    \      if(token[0] == 'I')\n                boredoms++;\n        }\n    }\n  \
    \  return boredoms;\n}", "{\n    string[] words = std.regex.split(S, std.regex.pattern(\"\
    [.?!]\"));\n    long boredoms = 0;\n    foreach(string word; words)\n    {\n \
    \       if(word.length > 0 && word[0] == 'I')\n            boredoms++;\n    }\n\
    \    return boredoms;\n}\n/*\n    Given a temperature in fahrenheit, return the\
    \ temperature in celsius.\n    For example:\n    >>> to_celsius(84)\n    29L\n\
    \    >>> to_celsius(80)\n    27L\n*/\nlong to_celsius(long fahrenheit) \n{\n \
    \   return long((fahrenheit - 32.0) * (5.0 / 9.0));\n}\n/*\n    Given a temperature\
    \ in celsius, return the temperature in fahrenheit.\n    For example:\n    >>>\
    \ to_fahrenheit(29)\n    84L\n    >>> to_fahrenheit(27)\n    80L\n*/\nlong to_fahrenheit(long\
    \ celsius) \n{\n    return long((celsius * (9.0 / 5.0)) + 32.0);\n}\n/*\n    Given\
    \ a string of words, return the string with the longest word.\n    If more than\
    \ one word is the longest, return the first.\n    For example:\n    >>> longest_word(\"\
    The rain in Spain falls mainly on the plain\")\n    \"mainly\"\n    >>> longest_word(\"\
    It is not the strongest of the species that survives, nor the most intelligent\
    \ that survives. It is the one that is the most adaptable to change.\")\n    \"\
    adaptable\"\n*/\nstring longest_word(string sentence) \n{\n    string[] words\
    \ = std.regex.split(sentence, std.regex.pattern(\" \"));\n    long longest_length\
    \ = 0;\n    foreach(string word; words)\n    {\n        if(word.length > longest_length)\n\
    \            longest_length = word.length;\n    }\n    foreach(string word; words)\n\
    \    {\n        if(word.length == longest_length)\n            return word;\n\
    \    }\n    return \"\";\n}\n/*\n", "{\n    auto sentences = S.split(\".\");\n\
    \    sentences ~= \".\";\n    long boredoms = 0;\n    string sentence = \"\";\n\
    \    foreach(sentence; sentences)\n    {\n        if(sentence.split(\" \")[0]\
    \ == \"I\")\n            boredoms++;\n    }\n    return boredoms;\n}", "{\n  \
    \  /*\n    string[] s;\n    s = split(S, \".\");\n    int t = 0;\n    foreach(string\
    \ in; s)\n    {\n        string s2 = replace(in, \",\", \"\");\n        string[]\
    \ s3;\n        s3 = split(s2, \" \");\n        if(s3[0] == \"I\")\n          \
    \  t++;\n    }\n    return t;\n    */\n    long res;\n    string[] s;\n    s =\
    \ split(S, \".\");\n    //string[] s2;\n    string s2;\n    foreach(string s1;\
    \ s)\n    {\n        s2 = replace(s1, \",\", \"\");\n        res += s2.count(\"\
    I\") == 1 ? 1 : 0;\n    }\n    return res;\n}", "{\n    long i;\n    long count\
    \ = 0;\n    long temp = 0;\n    foreach(c; S)\n    {\n        if (c == '.' ||\
    \ c == '?' || c == '!')\n        {\n            count += temp;\n            temp\
    \ = 0;\n        }\n        else if (c == 'I')\n        {\n            temp = 1;\n\
    \        }\n    }\n    return count;\n}", "{\n    long total = 0;\n    if(S.length\
    \ > 0)\n    {\n        auto words = split(S, [](char c) {return c == '.' || c\
    \ == '?' || c == '!';});\n        foreach(auto word; words)\n        {\n     \
    \       if(word.length > 0)\n            {\n                if(word[0] == 'I')\n\
    \                {\n                    total++;\n                }\n        \
    \    }\n        }\n    }\n    return total;\n}", "{\n    long count = 0;\n   \
    \ long len = S.length;\n    string temp = \"\";\n    long i = 0;\n    while(i\
    \ < len)\n    {\n        if(S[i] != '.' && S[i] != '?' && S[i] != '!')\n     \
    \   {\n            temp += S[i];\n        }\n        else if(S[i] == '.' || S[i]\
    \ == '?' || S[i] == '!')\n        {\n            if(temp.compare(\"I\") == 0)\n\
    \            {\n                count++;\n            }\n            temp = \"\
    \";\n        }\n        i++;\n    }\n    return count;\n}", "{\n    auto words\
    \ = split(S, \" .!?\");\n    long boredoms = 0;\n    foreach(word; words) {\n\
    \        if(word == \"I\") boredoms++;\n    }\n    return boredoms;\n}", "{\n\
    \    long boredoms = 0;\n    long start = 0;\n    long end = 0;\n    long is_bored\
    \ = 0;\n    long len = S.length;\n    for (long i = 0; i < len; i++)\n    {\n\
    \        if (S[i] == '.' || S[i] == '?' || S[i] == '!')\n        {\n         \
    \   start = i + 1;\n            if (is_bored == 1)\n            {\n          \
    \      boredoms++;\n            }\n            is_bored = 0;\n        }\n    \
    \    else if (S[i] == ' ' && S[i + 1] == 'I')\n        {\n            is_bored\
    \ = 1;\n        }\n    }\n    return boredoms;\n}\n/*\n    You are given an array\
    \ of strings, return all groups of strings that are\n    anagrams.\n    \n   \
    \ >>> anagrams([\"\",\"b\",\"\"])\n    [[]]\n    >>> anagrams([\"ab\",\"ba\",\"\
    cd\",\"dc\",\"e\"])\n    [[ab, ba], [cd, dc]]\n    >>> anagrams([\"ab\",\"ba\"\
    ,\"cd\",\"dc\",\"e\",\"a\",\"d\"])\n    [[ab, ba], [cd, dc], [e], [a], [d]]\n\
    */\nstring[] anagrams(string[] words) \n{\n    sort(words);\n    dstring[string]\
    \ groups;\n    foreach (i, string s; words)\n    {\n        string sorted_s =\
    \ sort_string(s);\n        if (sorted_s.length > 0)\n        {\n            groups[sorted_s]\
    \ ~= s;\n        }\n    }\n    string[][] result;\n    foreach (group; groups)\n\
    \    {\n        result ~= group;\n    }\n    return result;\n}\n/*\n    Given\
    \ a string, determine if it is a palindrome, considering only alphanumeric\n \
    \   characters and ignoring cases.\n    \n    >>> is_palindrome(\"A man, a plan,\
    \ a canal: Panama\")\n    true\n    >>> is_palindrome(\"race a car\")\n    false\n\
    */", "{\n    long n = 0;\n    for (size_t i = 0; i < S.length; i++)\n    {\n \
    \       if (S[i] == 'I')\n        {\n            if (i + 1 < S.length)\n     \
    \       {\n                if (S[i + 1] == ' ')\n                {\n         \
    \           if (i + 2 < S.length)\n                    {\n                   \
    \     if (i + 3 < S.length)\n                        {\n                     \
    \       if (S[i + 3] == '.' || S[i + 3] == '?' || S[i + 3] == '!')\n         \
    \                   {\n                                n++;\n                \
    \            }\n                        }\n                        else\n    \
    \                    {\n                            if (S[i + 2] == '.' || S[i\
    \ + 2] == '?' || S[i + 2] == '!')\n                            {\n           \
    \                     n++;\n                            }\n                  \
    \      }\n                    }\n                }\n            }\n        }\n\
    \    }\n    return n;\n}\n//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
  "{\n    long boredoms = 0;\n    if (S.empty)\n        return boredoms;\n    auto\
    \ strs = split(S, \"! \");\n    foreach (str; strs)\n    {\n        auto subStrs\
    \ = split(str, \". \");\n        foreach (subStr; subStrs)\n        {\n      \
    \      auto words = split(subStr, \" \");\n            if (words[0] == \"I\")\n\
    \                boredoms++;\n        }\n    }\n    return boredoms;\n}", "{\n\
    \    long boredom = 0;\n    string[] sentences = S.split(\"[\\\\.\\\\?\\\\!]\"\
    );\n    foreach(string sentence; sentences) {\n        if(sentence.length > 0\
    \ && sentence[0..1] == \"I \")\n            boredom++;\n    }\n    return boredom;\n\
    }", "{\n    long r = 0;\n    auto words = split(S, \" \");\n    foreach(auto w;\
    \ words)\n    {\n        if (w == \"I\")\n            r++;\n    }\n    return\
    \ r;\n}", "{\n    long bor = 0;\n    long dot = 0;\n    long q = 0;\n    long\
    \ ex = 0;\n    long i = 0;\n    long si = S.length;\n    while (i < si)\n    {\n\
    \        dot = S.find(\".\", i);\n        q = S.find(\"?\", i);\n        ex =\
    \ S.find(\"!\", i);\n        if (dot < 0 && q < 0 && ex < 0)\n            break;\n\
    \        if (dot < 0)\n            dot = si + 2;\n        if (q < 0)\n       \
    \     q = si + 2;\n        if (ex < 0)\n            ex = si + 2;\n        if (dot\
    \ < q && dot < ex)\n        {\n            if (S.substr(i, 3) == \"I am\")\n \
    \               bor++;\n            i = dot + 1;\n        }\n        else if (q\
    \ < dot && q < ex)\n        {\n            if (S.substr(i, 3) == \"I am\")\n \
    \               bor++;\n            i = q + 1;\n        }\n        else if (ex\
    \ < dot && ex < q)\n        {\n            if (S.substr(i, 3) == \"I am\")\n \
    \               bor++;\n            i = ex + 1;\n        }\n    }\n    return\
    \ bor;\n}", "{\n    auto a = split(S, \".\");\n    long count = 0;\n    foreach(sentence;\
    \ a)\n    {\n        auto b = split(sentence, \" \");\n        if(b[0] == \"I\"\
    )\n            count++;\n    }\n    return count;\n}", "{\n    long boredoms =\
    \ 0;\n    long pos = 0;\n    long length = S.length;\n    long last_pos = length;\n\
    \    while(pos < length)\n    {\n        long sentence_start = S.findFirst('.',\
    \ pos);\n        long sentence_end = S.findFirst('!', pos);\n        long sentence_excl\
    \ = S.findFirst('?', pos);\n        sentence_start = sentence_start == -1 ? last_pos\
    \ : sentence_start;\n        sentence_end = sentence_end == -1 ? last_pos : sentence_end;\n\
    \        sentence_excl = sentence_excl == -1 ? last_pos : sentence_excl;\n   \
    \     long sentence_end_pos = min(sentence_start, sentence_end, sentence_excl);\n\
    \        if(sentence_end_pos == last_pos)\n        {\n            break;\n   \
    \     }\n        pos = sentence_end_pos;\n        ++pos;\n        string sentence\
    \ = S[sentence_end_pos - 1 .. pos];\n        if(sentence.findFirst(\"I\") == 0)\n\
    \        {\n            ++boredoms;\n        }\n    }\n    return boredoms;\n}",
  "{\n    long r = 0;\n    foreach(word; split(S, \" \"))\n    {\n        if(word\
    \ == \"I\")\n            r++;\n    }\n    return r;\n}", "{\n    string[] words\
    \ = S.split(\"[!.? ]\");\n    long boredoms = 0;\n    for (size_t i = 0; i < words.length;\
    \ i++) {\n        if (words[i] == \"I\") {\n            boredoms++;\n        }\n\
    \    }\n    return boredoms;\n}", "{ \n    long result = 0;\n    string[] sentences\
    \ = split(S, \"!?.\");\n    foreach(string sentence; sentences)\n    {\n     \
    \   if(sentence.length > 0 && sentence[0..1] == \"I \")\n            result++;\n\
    \    }\n    return result;\n}", "{\n    int n = S.length;\n    long res = 0;\n\
    \    int i = 0;\n    while (i < n) {\n        if (S[i] == 'I') {\n           \
    \ res++;\n            while (i < n && (S[i] != '.' && S[i] != '?' && S[i] != '!'))\n\
    \                i++;\n        }\n        i++;\n    }\n    return res;\n}", "{\n\
    \    auto bored = 0L;\n    auto first = true;\n    foreach(w; S.split(\" \"))\
    \ {\n        if (first) {\n            first = false;\n            if (w == \"\
    I\") {\n                bored++;\n            }\n        } else {\n          \
    \  switch (w[0]) {\n                case '.':\n                case '!':\n   \
    \             case '?':\n                    first = true;\n                 \
    \   break;\n            }\n        }\n    }\n    return bored;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
