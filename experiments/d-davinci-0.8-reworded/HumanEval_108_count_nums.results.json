{
  "language": "d",
  "name": "HumanEval_108_count_nums",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(i; arr)\n    {\n        if(abs(i) > 9)\n        {\n            auto result_sum = tuple(i);\n            while(result_sum[0] > 9)\n            {\n                result_sum = tuple(i);\n                foreach(j; 0..result_sum.length)\n                {\n                    result_sum[0] += result_sum[j];\n                }\n                i = result_sum[0];\n            }\n        }\n        if(i > 0)\n        {\n            result++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptkepef04.d(30): Error: variable `j` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptkepef04.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(i; arr)\n    {\n        if(i < 0) i = -i;\n        long sum = 0L;\n        while(i != 0)\n        {\n            sum += i % 10;\n            i /= 10;\n        }\n        if(sum > 0)\n            result++;\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz8iimprs.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz8iimprs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.map!((long l) => Math.abs(l)).map!((long l) => l.toString.sum!\"(a, b) => a.to!int + b.to!int\").count!((long l) => l > 0);\n}\n// void test()\n// {\n//     auto arr = [1L, 1L, 2L];\n//     auto arr1 = arr.map!((long l) => Math.abs(l));\n//     long num = arr1.map!((long l) => l.toString.sum!\"(a, b) => a.to!int + b.to!int\").count!((long l) => l > 0);\n//     assert(num == 3L);\n// }\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd1zpjqps.d(28): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd1zpjqps.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n  long count = 0;\n  foreach(long i; arr)\n  {\n    if (i < 0)\n      i = -i;\n    long sum = 0;\n    while (i != 0)\n    {\n      sum += i % 10;\n      i /= 10;\n    }\n    if (sum > 0)\n      count++;\n  }\n  return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsmw86i74.d(35): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsmw86i74.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong ret = 0;\n\tforeach(elem; arr) \n\t{\n\t\tif(elem<0) \n\t\t{\n\t\t\telem *= -1;\n\t\t}\n\t\tlong sum = 0;\n\t\twhile(elem>0) \n\t\t{\n\t\t\tsum += elem%10;\n\t\t\telem /= 10;\n\t\t}\n\t\tif(sum > 0)\n\t\t{\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplm4vfsmo.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmplm4vfsmo.__unittest_L39_C1() [0x427e36]\n??:? void tmplm4vfsmo.__modtest() [0x428098]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428764]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long counter = 0;\n    foreach(i; arr)\n    {\n        long number = i;\n        long total = 0;\n        if(number == 0) \n        {\n            counter += 1;\n        }\n        while(number != 0)\n        {\n            number = abs(number);\n            total += number % 10;\n            number /= 10;\n        }\n        if(total > 0)\n        {\n            counter += 1;\n        }\n    }\n    return counter;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcg5jgb6h.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpcg5jgb6h.__unittest_L41_C1() [0x427e8e]\n??:? void tmpcg5jgb6h.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(num; arr) \n    {\n        if(sum_digits(num) > 0) \n        {\n            count++;\n        }\n    }\n    return count;\n}\nlong sum_digits(long num) \n{\n    long sum = 0;\n    long num_abs = abs(num);\n    while(num_abs > 0) \n    {\n        sum += num_abs % 10;\n        num_abs /= 10;\n    }\n    return sum;\n}\nlong abs(long num) \n{\n    return (num < 0) ? -num : num;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp__5r212d.d(44): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp__5r212d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ans = 0L;\n    long k = 0L;\n    long sum = 0L;\n    long temp = 0L;\n    long newnum = 0L;\n    long power = 0L;\n    long temp2 = 0L;\n    tuple(long, long)[] newarr = new tuple(long, long)[0];\n    for (; k < size_t(arr); k++)\n    {\n        newarr ~= tuple(long, long)(abs(arr[k]), arr[k]);\n    }\n    sort(newarr);\n    foreach (ref x; newarr)\n    {\n        temp = x[0];\n        while (temp >= 10L)\n        {\n            sum = 0L;\n            power = 0L;\n            while (temp != 0L)\n            {\n                newnum = temp % 10L;\n                temp /= 10L;\n                sum += newnum * pow(10L, power);\n                power++;\n            }\n            temp = sum;\n        }\n        x[0] = temp;\n    }\n    sort(newarr);\n    for (k = 0L; k < size_t(newarr); k++)\n    {\n        if (x[0] != temp2)\n        {\n            temp2 = x[0];\n            ans++;\n        }\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzcb5e579.d(26): Error: found `,` when expecting `.` following long\n/tmp/tmpzcb5e579.d(26): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpzcb5e579.d(26): Error: found `newarr` when expecting `;` following statement\n/tmp/tmpzcb5e579.d(26): Error: found `=` instead of statement\n/tmp/tmpzcb5e579.d(29): Error: found `,` when expecting `.` following long\n/tmp/tmpzcb5e579.d(29): Error: found `long` when expecting identifier following `long`.\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzcb5e579.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong sum = 0;\n\tforeach(num; arr) \n\t{\n\t\tif(num < 0) \n\t\t{\n\t\t\tnum = -num;\n\t\t}\n\t\t\n\t\tint el = 0;\n\t\twhile(num > 0) \n\t\t{\n\t\t\tel += num % 10;\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\tif(el > 0) \n\t\t{\n\t\t\tsum++;\n\t\t}\n\t}\n\treturn sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpaatq8hgg.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428325]\n??:? void tmpaatq8hgg.__unittest_L41_C1() [0x427e42]\n??:? void tmpaatq8hgg.__modtest() [0x4280a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c333]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1c6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430359]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430808]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b19d]\n??:? runModuleUnitTests [0x42c109]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428774]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.filter!(a => a.abs.digits.sum > 0).length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2bgt27dy.d(19): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bgt27dy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    long[] signed_digits = new long[arr.length];\n    for (long i = 0L; i < arr.length; i++) \n    {\n        long x = arr[i];\n        signed_digits[i] = x < 0L ? -x : x;\n    }\n    for (long x in signed_digits) \n    {\n        long digits_sum = 0L;\n        while (x != 0L) \n        {\n            digits_sum += x % 10L;\n            x /= 10L;\n        }\n        if (digits_sum > 0L) \n        {\n            result++;\n        }\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb7vmivwt.d(26): Error: semicolon expected, not `in`\n/tmp/tmpb7vmivwt.d(26): Error: expression expected, not `in`\n/tmp/tmpb7vmivwt.d(26): Error: found `signed_digits` when expecting `;` following `for` condition\n/tmp/tmpb7vmivwt.d(41): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb7vmivwt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n  long counter = 0;\n  int i = 0;\n  foreach(l; arr) \n  {\n    if(l > 0)\n    {\n      l = l;\n    }\n    else\n    {\n      l = -l;\n    }\n    long sum = 0;\n    while(l > 0)\n    {\n      sum += l % 10;\n      l /= 10;\n    }\n    if(sum > 0)\n    {\n      counter++;\n    }\n  }\n  return counter;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp811zzvnx.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42832d]\n??:? void tmp811zzvnx.__unittest_L44_C1() [0x427e4e]\n??:? void tmp811zzvnx.__modtest() [0x4280b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c33b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430361]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430810]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a5]\n??:? runModuleUnitTests [0x42c111]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42877c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long[] sums = new long[arr.length];\n    foreach(i, e; arr)\n    {\n        sums[i] = abs(e).to!string.map!(a => a.to!long - '0'.to!long).sum;\n    }\n    return sums.filter!(a => a > 0).length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2piju8vw.d(22): Error: no property `to` for type `long`\n/tmp/tmp2piju8vw.d(24): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2piju8vw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(i;arr) \n    {\n        long sum = 0L;\n        long j = i;\n        while(j != 0L)\n        {\n            sum += j % 10L;\n            j /= 10L;\n        }\n        if(sum > 0L)\n            result++;\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpztgwyz3w.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpztgwyz3w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(idx, v; arr)\n    {\n        long digit_sum = 0;\n        foreach(i, d; v.digits())\n        {\n            digit_sum += (abs(d)).abs;\n        }\n        if(digit_sum > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmqrhqhyt.d(23): Error: no property `digits` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqrhqhyt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.count!(x => x.abs().digits.sum > 0);\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph156zhgt.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph156zhgt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long res = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        long temp = arr[(int)i];\n        if (temp < 0)\n        {\n            temp = -temp;\n        }\n        long sum = 0;\n        while (temp != 0)\n        {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (sum > 0)\n        {\n            res++;\n        }\n    }\n    return res;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwrrfl4lm.d(22): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpwrrfl4lm.d(40): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwrrfl4lm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return 0;\n    } \n    else if (arr.length == 1) \n    {\n        return arr[0] != 0 ? 1 : 0;\n    }\n    auto is_positive = arr[0] > 0;\n    long sum = 0;\n    long[] abs_arr = new long[arr.length];\n    for (long i = 0; i < arr.length; i++) \n    {\n        if (arr[i] != 0) \n        {\n            sum += abs(arr[i]);\n            abs_arr[i] = abs(arr[i]);\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3shmukrv.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428475]\n??:? void tmp3shmukrv.__unittest_L40_C1() [0x427f7e]\n??:? void tmp3shmukrv.__modtest() [0x4281f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c553]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430671]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b20]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305fd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3bd]\n??:? runModuleUnitTests [0x42c329]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428938]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long d = 0;\n    foreach(i ; arr)\n    {\n        if (abs(i) < 10)\n        {\n            d += 1;\n        }\n        else if (abs(i) >= 10)\n        {\n            d += getDigits(abs(i));\n        }\n    }\n    return d;\n}\nlong getDigits(long num)\n{\n    long sum = 0;\n    while (num > 0)\n    {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n// bool isPositive(long i)\n// {\n//     return i >= 0;\n// }\n// bool isNegative(long i)\n// {\n//     return i < 0;\n// }\n// bool areEqual(long i, long j)\n// {\n//     return i == j;\n// }\n// bool areNotEqual(long i, long j)\n// {\n//     return i != j;\n// }\n// bool isGreaterThan(long i, long j)\n// {\n//     return i > j;\n// }\n// bool isGreaterThanOrEqual(long i, long j)\n// {\n//     return i >= j;\n// }\n// bool isLessThan(long i, long j)\n// {\n//     return i < j;\n// }\n// bool isLessThanOrEqual(long i, long j)\n// {\n//     return i <= j;\n// }\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpl98qbjfu.d(75): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl98qbjfu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    int len = arr.length;\n    foreach(i; 0..len)\n    {\n        long val = arr[i];\n        int sum = 0;\n        while(val != 0)\n        {\n            sum += val % 10;\n            val /= 10;\n        }\n        if(sum > 0)\n            count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxzf7xy6y.d(20): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxzf7xy6y.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(long i; arr) \n    {\n        long n = i;\n        if(n < 0) \n        {\n            n = -n;\n        }\n        long sum = 0;\n        while(n != 0) \n        {\n            long r = n % 10;\n            sum += r;\n            n /= 10;\n        }\n        if(sum > 0) \n        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvaevd0cs.d(41): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvaevd0cs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    foreach(long i; arr)\n    {\n        if(abs(i).sumDigits > 0L) ret++;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb1oo6g9s.d(22): Error: no property `sumDigits` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb1oo6g9s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0L;\n    foreach(i; arr) \n    {\n        auto num = i.abs;\n        long sum = 0L;\n        while(num != 0L) \n        {\n            sum += num % 10L;\n            num /= 10L;\n        }\n        if(sum > 0L) \n        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4jug255f.d(36): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4jug255f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long r = 0L;\n    for (in i = 0; i < arr.length; i++) \n    {\n        if (abs(arr[i]).to!string.count.filter!((n) => n > '0').length > 0) \n        {\n            r += 1L;\n        }\n    }\n    return r;\n}\n \n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuuxmkbqz.d(20): Error: found `in` instead of statement\n/tmp/tmpuuxmkbqz.d(30): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuxmkbqz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n  long index = 0;\n  foreach(num; arr)\n  {\n    if(abs(num) >= 10)\n    {\n      long sum = 0;\n      while(num != 0)\n      {\n        sum += abs(num) % 10;\n        num /= 10;\n      }\n      if(sum != 0)\n      {\n        index++;\n      }\n    }\n    else\n    {\n      if(num != 0)\n      {\n        index++;\n      }\n    }\n  }\n  return index;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpve8zfvyb.d(45): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpve8zfvyb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long answer = 0L;\n    for (auto elem: arr) \n    {\n        if (abs(elem).sumDigits > 0) \n        {\n            answer++;\n        }\n    }\n    return answer;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0er2l2nr.d(20): Error: no identifier for declarator `elem`\n/tmp/tmp0er2l2nr.d(20): Error: expression expected, not `:`\n/tmp/tmp0er2l2nr.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0er2l2nr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    /* \n        Solution adapted from:\n        https://stackoverflow.com/questions/36086459/d-sum-digits-of-an-int\n    */\n    return arr.filter!(x => { \n        auto neg = false; \n        if (x < 0) \n        { \n            neg = true; \n            x = -x; \n        } \n        auto sum = 0; \n        while (x != 0) \n        { \n            sum += x % 10; \n            x /= 10; \n        } \n        return neg ? -sum : sum; \n    }).length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnif9v1gk.d(23): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnif9v1gk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int res = 0;\n    foreach(e; arr)\n    {\n        int su = 0;\n        bool negative = false;\n        if(e < 0) \n        {\n            e = -e;\n            negative = true;\n        }\n        while(e != 0)\n        {\n            su += e % 10;\n            e /= 10;\n        }\n        if(negative) su = -su;\n        if(su > 0) res++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpatq4ar9n.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x42833d]\n??:? void tmpatq4ar9n.__unittest_L39_C1() [0x428025]\n??:? void tmpatq4ar9n.__modtest() [0x4280c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c34b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1de]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430371]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430820]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302fd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1b5]\n??:? runModuleUnitTests [0x42c121]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42878c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong result = 0;\n\tforeach(el; arr)\n\t{\n\t\tauto abs = el.abs;\n\t\tlong sum = 0;\n\t\twhile(abs > 0)\n\t\t{\n\t\t\tsum += abs % 10;\n\t\t\tabs /= 10;\n\t\t}\n\t\tif(sum > 0)\n\t\t\tresult++;\n\t}\n\treturn result;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpagzzycax.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpagzzycax.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    foreach(e; arr)\n    {\n        auto[num, sign] = typeof(e).init.init;\n        if(sign == -1)\n        {\n            num *= -1;\n        }\n        sum += num;\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdrx1z66g.d(22): Error: basic type expected, not `[`\n/tmp/tmpdrx1z66g.d(22): Error: found `,` when expecting `]`\n/tmp/tmpdrx1z66g.d(22): Error: semicolon expected, not `]`\n/tmp/tmpdrx1z66g.d(22): Error: found `]` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdrx1z66g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr)\n    {\n        int sum = 0;\n        foreach(j; i.digits)\n        {\n            sum += j;\n        }\n        if(sum > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp870vi05a.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp870vi05a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long acc = 0;\n    foreach(long x; arr)\n    {\n        int sig = x < 0 ? -1 : 1;\n        if (sig * sum(digits(sig * x)) > 0)\n            acc++;\n    }\n    return acc;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdy67auwu.d(23): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdy67auwu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return 0L;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpctkoyee8.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x428275]\n??:? void tmpctkoyee8.__unittest_L21_C1() [0x427e19]\n??:? void tmpctkoyee8.__modtest() [0x427ff8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c283]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b116]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430758]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430235]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0ed]\n??:? runModuleUnitTests [0x42c059]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum_of_signed_digits;\n    long sum_of_digits = 0L;\n    long count = 0L;\n    auto signed_digits = std.algorithm.map!(long x => abs(x) % 10L * sign(x))(arr);\n    foreach(i; signed_digits)\n    {\n        sum_of_signed_digits = i;\n        foreach(j; signed_digits)\n        {\n            if(i != j)\n            {\n                sum_of_signed_digits += j;\n            }\n        }\n        if(sum_of_signed_digits > 0L)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnhpm6jr_.d(22): Error: found `x` when expecting `.` following long\n/tmp/tmpnhpm6jr_.d(22): Error: found `=>` when expecting identifier following `long`.\n/tmp/tmpnhpm6jr_.d(22): Error: found `abs` when expecting `)` following template argument list\n/tmp/tmpnhpm6jr_.d(22): Error: semicolon expected following auto declaration, not `)`\n/tmp/tmpnhpm6jr_.d(22): Error: found `)` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnhpm6jr_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(i; arr)\n    {\n        static if(!__traits(compiles, i))\n        {\n            continue;\n        }\n        result += abs(i) > 0 ? 1L : 0L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkuu206v3.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428355]\n??:? void tmpkuu206v3.__unittest_L30_C1() [0x427e5a]\n??:? void tmpkuu206v3.__modtest() [0x4280d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c363]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1f6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430389]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430838]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430315]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1cd]\n??:? runModuleUnitTests [0x42c139]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(int i, long num; arr) \n    {\n        int sum = 0;\n        if(num < 0) \n        {\n            sum += num % 10;\n            num = num / 10;\n        }\n        while(num > 0) \n        {\n            sum += num % 10;\n            num = num / 10;\n        }\n        if(sum > 0) \n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpldj68rqh.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmpldj68rqh.__unittest_L40_C1() [0x428029]\n??:? void tmpldj68rqh.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428794]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    foreach(i; arr)\n    {\n        long j = abs(i);\n        long sum = 0L;\n        while(j > 0L)\n        {\n            sum += j % 10L;\n            j /= 10L;\n        }\n        if(sum > 0L) ret++;\n    }\n    return ret;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnlq4iqo9.d(33): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnlq4iqo9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int count = 0;\n    foreach( a; arr )\n    {\n        if( a < 0 )\n            a = -a;\n        long s = 0;\n        for( int t = a; t > 0; t = t / 10 )\n            s += t % 10;\n        if( s > 0 )\n            count++;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4dylhztx.d(32): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4dylhztx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    int size = arr.length;\n    for (int i = 0; i < size; i++)\n    {\n        long elem = arr[i];\n        long sum = 0;\n        while (elem != 0)\n        {\n            sum += abs(elem % 10);\n            elem /= 10;\n        }\n        if (sum > 0)\n            count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkq2czyrg.d(20): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkq2czyrg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr)\n    {\n        if(abs(i) % 10 > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmb368nwr.d(29): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmb368nwr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong[] arrL = arr;\n\tlong sum = 0;\n\tlong count = 0;\n\tforeach(i; 0..arrL.length)\n\t{\n\t\tsum = 0;\n\t\tlong a = arrL[i];\n\t\tlong b = abs(a);\n\t\tdo \n\t\t{\n\t\t\tsum += b % 10;\n\t\t\tb /= 10;\n\t\t} while (b > 0);\n\t\tif (sum > 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpti1fv6du.d(39): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpti1fv6du.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    foreach(elem; arr)\n    {\n        long tmp = elem;\n        long sum = 0L;\n        while(tmp != 0L)\n        {\n            long lastDigit = tmp % 10L;\n            tmp = tmp / 10L;\n            sum += abs(lastDigit);\n        }\n        if(sum > 0L)\n        {\n            ret++;\n        }\n    }\n    return ret;\n}\n// Structs\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp00bdv_gd.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmp00bdv_gd.__unittest_L38_C1() [0x427e8a]\n??:? void tmp00bdv_gd.__modtest() [0x428104]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0L;\n    foreach(num; arr)\n    {\n        if(sum(num.abs.digits) > 0L)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpr_60dei9.d(29): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr_60dei9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int result = 0;\n    foreach(x; arr)\n    {\n        long sum = 0;\n        long t = x;\n        if(t < 0)\n            t = -t;\n        while(t != 0)\n        {\n            sum += t % 10;\n            t /= 10;\n        }\n        if(sum > 0)\n            result++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpi69bxbrn.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x42831d]\n??:? void tmpi69bxbrn.__unittest_L36_C1() [0x427e3a]\n??:? void tmpi69bxbrn.__modtest() [0x42809c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c32b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1be]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430351]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430800]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b195]\n??:? runModuleUnitTests [0x42c101]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42876c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(el; arr)\n    {\n        if(el!=0)\n        {\n            long sum = 0;\n            long el1 = abs(el);\n            while(el1 != 0)\n            {\n                sum += el1 % 10;\n                el1 /= 10;\n            }\n            if(sum > 0)\n                count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwr5jsw8l.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpwr5jsw8l.__unittest_L37_C1() [0x427e8e]\n??:? void tmpwr5jsw8l.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr) {\n        count += sum(i.digits);\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5yn1kvgr.d(21): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5yn1kvgr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return 0;\n    }\n    long posCount = 0;\n    for (long i = 0; i < arr.length; i++) \n    {\n        long val = arr[i];\n        if (val < 0) \n        {\n            val = val * -1;\n        }\n        if (val == 0) \n        {\n            continue;\n        }\n        long digitSum = 0;\n        while (val > 0) \n        {\n            digitSum += val % 10;\n            val = val / 10;\n        }\n        if (digitSum > 0) \n        {\n            posCount++;\n        }\n    }\n    return posCount;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5q8k8ei1.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x42833d]\n??:? void tmp5q8k8ei1.__unittest_L48_C1() [0x427e5a]\n??:? void tmp5q8k8ei1.__modtest() [0x4280bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b252]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430894]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430371]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b229]\n??:? runModuleUnitTests [0x42c195]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428800]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long num = 0;\n    foreach(i; arr)\n    {\n        if (i < 0)\n        {\n            if (digitSum(-i) > 0)\n            {\n                num += 1;\n            }\n        }\n        else\n        {\n            if (digitSum(i) > 0)\n            {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkjesrr3n.d(39): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkjesrr3n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    const long sz = arr.length;\n    if (sz == 0) \n    {\n        return 0;\n    }\n    long count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        long x = arr[i];\n        if (x < 0) \n        {\n            x = -x;\n        }\n        long s = 0;\n        while (x > 0) \n        {\n            s += x % 10;\n            x /= 10;\n        }\n        if (s > 0) \n        {\n            count++;\n        }\n    }\n    return count;\n}\nstatic assert(count_nums([]) == 0);\nstatic assert(count_nums([-1L, 11L, -11L]) == 1);\nstatic assert(count_nums([1L, 1L, 2L]) == 3);\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdi54bznv.d(48): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdi54bznv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.filter!(a => a.abs.sum_digits != 0)().length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnj8ao8vc.d(19): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnj8ao8vc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long counter = 0;\n    foreach(a; arr) \n    {\n        if(a != 0) \n        {\n            long sum = 0;\n            long abs = a.abs;\n            while(abs != 0) \n            {\n                sum += abs % 10;\n                abs /= 10;\n            }\n            if(sum > 0)\n                counter++;\n        }\n    }\n    return counter;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpisr2p6gt.d(37): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpisr2p6gt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(val; arr) \n    {\n        if(val < 0L) \n        {\n            val = -val;\n        }\n        result += (sum(std.array.split(to!string(val))) > 0L) ? 1L : 0L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplt9ub4do.d(26): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplt9ub4do.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    import std.math : abs;\n    long cnt = 0;\n    foreach(const n; arr) \n    {\n        const digits = n.stringof.split.filter!((n) => n!=\"-\").map!((n) => n.to!long).array;\n        if(digits.sum > 0)\n            cnt++;\n    }\n    return cnt;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb24dmz3t.d(23): Error: no property `split` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb24dmz3t.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    foreach(e; arr) \n    {\n        ret += 1L;\n    }\n    return ret;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqq33uwmx.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqq33uwmx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long num = 0;\n    long[] sign = new long[1];\n    long digit = 0;\n    foreach(x; arr) \n    {\n        num = sign[0] = x;\n        if(num < 0) num = -num;\n        while(num > 0) \n        {\n            digit += num % 10;\n            num /= 10;\n        }\n        if(digit > 0 && sign[0] < 0) \n        {\n            digit = -digit;\n        }\n        if(digit > 0) \n        {\n            return digit;\n        }\n    }\n    return digit;\n}\nstatic assert(count_nums([]) == 0L);\nstatic assert(count_nums([-1L, 11L, -11L]) == 1L);\nstatic assert(count_nums([1L, 1L, 2L]) == 3L);\n// unittest \n{\n    bool[] b = new bool[];\n    foreach(n; 0..1_000_000) \n    {\n        long[] arr = new long[n];\n        foreach(i; 0..n) \n        {\n            arr[i] = i % 2 == 0 ? i : -i;\n        }\n        b ~= count_nums(arr) == n;\n    }\n    assert(b.all);\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpywf1nftr.d(46): Error: declaration expected, not `{`\n/tmp/tmpywf1nftr.d(48): Error: declaration expected, not `foreach`\n/tmp/tmpywf1nftr.d(48): Error: declaration expected, not `0`\n/tmp/tmpywf1nftr.d(51): Error: declaration expected, not `foreach`\n/tmp/tmpywf1nftr.d(51): Error: declaration expected, not `0`\n/tmp/tmpywf1nftr.d(54): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpywf1nftr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long[long] map = new long[long];\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoml9ffyn.d(19): Error: need size of rightmost array, not type `long`\n/tmp/tmpoml9ffyn.d(20): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoml9ffyn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    for (i in arr)\n    {\n        if (abs(i) != i)\n        {\n            i = -i;\n        }\n        long sum = 0L;\n        while (i != 0L)\n        {\n            sum += i % 10L;\n            i /= 10L;\n        }\n        if (sum > 0L)\n        {\n            result++;\n        }\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfd80754_.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmpfd80754_.d(37): Error: found `return` when expecting `;` following `for` condition\n/tmp/tmpfd80754_.d(37): Error: found `;` when expecting `)`\n/tmp/tmpfd80754_.d(38): Error: found `}` instead of statement\n/tmp/tmpfd80754_.d(39): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfd80754_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long c = 0;\n    foreach(n; arr)\n    {\n        if(sum_digits(n) > 0)\n            c++;\n    }\n    return c;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdftgv0ug.d(27): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdftgv0ug.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int count = 0;\n    foreach(int i; arr)\n    {\n        int num = std.math.abs(i);\n        int sum = 0;\n        while(num > 0)\n        {\n            sum += num % 10;\n            num /= 10;\n        }\n        if(sum > 0)\n            count++;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmshcrmrw.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmshcrmrw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    /*\n        std.algorithm.map with std.math.abs and std.math.digits\n        std.math.digits(long[], long)\n    */\n    auto result = arr.map!(x => x < 0 ? x * -1 : x).map!(x => digits(x, 10)).filter!(x => x.length > 0).map!(x => x.sum()).filter!(x => x > 0).map!(x => 1L).sum();\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw7xbyo42.d(23): Error: no property `map` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw7xbyo42.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(i; arr) \n    {\n        long digit_sum = 0L;\n        i = abs(i);\n        while(i > 0L) \n        {\n            digit_sum += i % 10L;\n            i /= 10L;\n        }\n        if(digit_sum > 0L) \n        {\n            result++;\n        }\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9itllcs7.d(36): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9itllcs7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long _count_nums = 0L;\n    foreach (l; arr)\n    {\n        if (l.abs.to!string.fold!((a, b) => a + b.to!long)(0L) > 0L)\n        {\n            _count_nums += 1L;\n        }\n    }\n    return _count_nums;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw1c6gw5u.d(29): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw1c6gw5u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(e; arr)\n    {\n        count += (e < 0) ? -e : e;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwrhszqqa.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwrhszqqa.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164245
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    long curr = 0L;\n    long size = arr.length;\n    foreach(i; 0..size) \n    {\n        curr = sign(arr[i]) * sum(arr[i].abs.digits);\n        if (curr > 0L) \n        {\n            result++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkiuhe_pn.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpkiuhe_pn.d(24): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkiuhe_pn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": -1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    long sign = 0;\n    long reminder = 0;\n    long total = 0;\n    foreach(long num; arr)\n    {\n        if(num > 0)\n        {\n            total = num;\n        }\n        else if(num < 0)\n        {\n            total = -num;\n            sign = -1;\n        }\n        else\n        {\n            count++;\n            continue;\n        }\n        while(total != 0)\n        {\n            reminder = total % 10;\n            total = total / 10;\n            total += reminder;\n        }\n        if(total != 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Timeout",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164261
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int count = 0;\n    foreach(i; arr)\n    {\n        if(!i.digits.empty)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n// public alias\npublic alias count_nums = count_nums;\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5ax0mwi4.d(30): Error: `alias count_nums = count_nums;` cannot alias itself, use a qualified name to create an overload set\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ax0mwi4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long unsigned_sum = sum(map!(abs)(arr));\n    long signed_sum = sum(arr);\n    return unsigned_sum - signed_sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmdzgwg53.d(19): Error: undefined identifier `sum`\n/tmp/tmpmdzgwg53.d(20): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmdzgwg53.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    foreach(i;arr)\n    {\n        ret += (abs(i)%9)%9 == 0 ? 1L : 0L;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbc43eh0l.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x42835d]\n??:? void tmpbc43eh0l.__unittest_L26_C1() [0x427e66]\n??:? void tmpbc43eh0l.__modtest() [0x4280e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c36b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430391]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430840]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43031d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d5]\n??:? runModuleUnitTests [0x42c141]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.count!(x => x.abs.reduce!((a,b) => a+b) > 0);\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt66hgxr9.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt66hgxr9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(n; arr) \n    {\n        if (sum_digits(n) > 0L)\n            result++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppyhhehye.d(22): Error: undefined identifier `sum_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppyhhehye.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong count = 0;\n\tforeach(immutable e; arr) \n\t{\n\t\timmutable digits = e.digits;\n\t\tlong sum = 0;\n\t\tforeach(immutable d; digits) \n\t\t{\n\t\t\tsum += d;\n\t\t}\n\t\tif(sum > 0) \n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxx771w4l.d(22): Error: no property `digits` for type `immutable(long)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxx771w4l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long n = 0L;\n    foreach(long x; arr) \n    {\n        if (x < 0L) \n        {\n            x = -x;\n        }\n        long s = 0L;\n        long x0 = x;\n        while (x0 > 0L) \n        {\n            s += x0 % 10L;\n            x0 /= 10L;\n        }\n        if (s > 0L) \n        {\n            n += 1L;\n        }\n    }\n    return n;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp6cbuvlht.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428325]\n??:? void tmp6cbuvlht.__unittest_L40_C1() [0x427e46]\n??:? void tmp6cbuvlht.__modtest() [0x4280a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c333]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1c6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430359]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430808]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b19d]\n??:? runModuleUnitTests [0x42c109]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428774]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    long[] signeddigits;\n    long i;\n    i = 0L;\n    while ((i < arr.length)) {\n        signeddigits = signeddigits(arr[i]);\n        if ((sum(signeddigits) > 0L)) {\n            ret += 1L;\n        }\n        i += 1L;\n    }\n    return ret;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm3hhxtah.d(32): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3hhxtah.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.length;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9g4fp9y1.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9g4fp9y1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long[] arr1 = arr.map!(x => abs(x)).map!(x => x.to!string).map!(x => x.sumOf!long(\"0..9\".count)).filter!(x => x>0);\n    return arr1.length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6vgmt4ru.d(19): Error: no property `map` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vgmt4ru.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    if(arr.length == 0)\n    {\n        return count;\n    }\n    foreach(i; arr)\n    {\n        if(sum_signed_digits(i) > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzvd7rjl2.d(26): Error: undefined identifier `sum_signed_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzvd7rjl2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long b = 0;\n    foreach(x; arr)\n    {\n        long a = x;\n        if(a < 0)\n        {\n            a = -a;\n        }\n        long c = 0;\n        for(long i = 0; i < 9 && a > 0; i++)\n        {\n            long j = a % 10;\n            a = a / 10;\n            c = c + j;\n        }\n        if(c > 0)\n        {\n            b = b + 1;\n        }\n    }\n    return b;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp75n8_hq8.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmp75n8_hq8.__unittest_L41_C1() [0x427e62]\n??:? void tmp75n8_hq8.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428794]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    auto r = reduce!((a, b) => a + abs(b))(arr);\n    return r;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp0h80b_1.d(22): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp0h80b_1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(num; arr)\n    {\n        long temp = 0L;\n        if(num < 0L)\n        {\n            temp += abs(num);\n        }\n        else\n        {\n            temp = num;\n        }\n        do \n        {\n            long last_digit = temp % 10L;\n            temp /= 10L;\n            if(temp == 0L)\n            {\n                break;\n            }\n            result += last_digit;\n        }\n        while(true);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpy_f1hw86.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmpy_f1hw86.__unittest_L45_C1() [0x427f15]\n??:? void tmpy_f1hw86.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c39b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b22e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430870]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43034d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b205]\n??:? runModuleUnitTests [0x42c171]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287dc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for ( int i = 0; i < arr.length; i++ )\n    {\n        if ( arr[i] > 0 )\n        {\n            int v = arr[i];\n            while ( v > 0 )\n            {\n                sum += v % 10;\n                v /= 10;\n            }\n        }\n        else\n        {\n            int v = -arr[i];\n            while ( v > 0 )\n            {\n                sum -= v % 10;\n                v /= 10;\n            }\n        }\n    }\n    return (long) ceil(sum / 10.0);\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa33fv66g.d(41): Error: C style cast illegal, use `cast(long)ceil(sum / 10.0000)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa33fv66g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    /*\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc1tltkcd.d(19): Error: unterminated /* */ comment\n/tmp/tmpc1tltkcd.d(287): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc1tltkcd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.count!((long i) => \n    {\n        long l = 0;\n        long c = i;\n        if (c < 0) c = -c;\n        for (; c > 0; c /= 10)\n        {\n            l += c % 10;\n        }\n        return l > 0;\n    });\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpolbxmvxx.d(31): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolbxmvxx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    //return sum(map!((i)=>(abs(i)).sumDigits().reduce!((a,b)=>a+b))(arr));\n    return sum(map!((i)=>((i<0)?-i:i).sumDigits().reduce!((a,b)=>a+b))(arr));\n}\nlong sum(Range)(long[] arr) \n{\n    if(arr.length==0) return 0;\n    else return arr[0]+sum(arr[1..$]);\n}\nlong abs(long v) \n{\n    return (v<0)?-v:v;\n}\nlong[] range(long start, long count) \n{\n    long[] ret = new long[count];\n    long i = 0;\n    while(i<count) \n    {\n        ret[i] = start+i;\n        i++;\n    }\n    return ret;\n}\nRange sumDigits(long v) \n{\n    return v.digits;\n}\nRange digits(long v) \n{\n    import std.algorithm : map;\n    import std.conv : to;\n    if(v<0) return map!((i)=>-i.to!long)(to!string(-v).to!long[]);\n    else return to!string(v).to!long[];\n}\nlong[] map(alias fun, Range)(Range r) \n{\n    import std.algorithm : map;\n    return map!fun(r);\n}\nlong reduce(alias fun, Range)(Range r) \n{\n    import std.algorithm : reduce;\n    return reduce!fun(r);\n}\nlong[] to(long start, long end) \n{\n    return range(start, end-start);\n}\nlong[] to(long start, long end, long step) \n{\n    long[] ret = new long[(end-start)/step];\n    long j = 0;\n    long i = start;\n    while(i<end) \n    {\n        ret[j] = i;\n        i+=step;\n        j++;\n    }\n    return ret;\n}\nlong[]\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpayb7z938.d(81): Error: no identifier for declarator `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpayb7z938.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return 0L;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpctkoyee8.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x428275]\n??:? void tmpctkoyee8.__unittest_L21_C1() [0x427e19]\n??:? void tmpctkoyee8.__modtest() [0x427ff8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c283]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b116]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430758]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430235]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0ed]\n??:? runModuleUnitTests [0x42c059]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long size_t = arr.length;\n    long n = 0;\n    long temp = 0;\n    long temp_sum = 0;\n    long[] temp_arr = new long[arr.length];\n    bool[] swap_arr = new bool[arr.length];\n    for (long i = 0; i < size_t; i++)\n    {\n        temp = arr[i];\n        temp_sum = 0;\n        for (long j = 0; j < size_t; j++)\n        {\n            swap_arr[j] = false;\n        }\n        for (long j = 0; j < size_t; j++)\n        {\n            if (temp == arr[j] && swap_arr[j] == false)\n            {\n                temp_sum += temp;\n                swap_arr[j] = true;\n            }\n        }\n        temp_arr[i] = temp_sum;\n    }\n    for (long i = 0; i < size_t; i++)\n    {\n        if (temp_arr[i] > 0)\n        {\n            n++;\n        }\n    }\n    return n;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpi31wqyoe.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x4285dd]\n??:? void tmpi31wqyoe.__unittest_L52_C1() [0x4282c1]\n??:? void tmpi31wqyoe.__modtest() [0x42835c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430819]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b565]\n??:? runModuleUnitTests [0x42c4d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428aa0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    foreach(i; arr)\n    {\n        if(i < 0)\n        {\n            i = -i;\n        }\n        while(i > 0)\n        {\n            sum += i % 10;\n            i /= 10;\n        }\n    }\n    return arr.length - count(arr, (_dummy) => {return sum > 0;});\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3if3m8r2.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3if3m8r2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.filter!(x => abs(x).sumofdigits() > 0).length;\n}\nlong sumofdigits(int n) \n{\n    if (n < 0)\n        n = -n;\n    long res = 0;\n    while (n > 0)\n    {\n        res += n % 10;\n        n /= 10;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjb_eti_8.d(19): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjb_eti_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(int i; 0 .. arr.length) \n    {\n        if(sum(int[](string(abs(arr[i])))) > 0) \n        {\n            result++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgqjz65n9.d(22): Error: found `[` when expecting `.` following int\n/tmp/tmpgqjz65n9.d(22): Error: found `]` when expecting identifier following `int`.\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgqjz65n9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(i; arr) \n    {\n        if (sum(to!string(i).map!(a => i.to!long)) > 0L) \n        {\n            result++;\n        }\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6l1yynm5.d(29): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6l1yynm5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long n = 0L;\n    foreach(i; arr)\n    {\n        if (abs(i) == 0L)\n            continue;\n        if (((abs(i) % 10L) + (abs(i) / 10L)) > 0L)\n            n++;\n    }\n    return n;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpjhx9x9hg.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x42837d]\n??:? void tmpjhx9x9hg.__unittest_L29_C1() [0x427e86]\n??:? void tmpjhx9x9hg.__modtest() [0x428100]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i = 0; i < arr.length; i++) \n    {\n        int n = abs(arr[i]);\n        while (n > 0) \n        {\n            sum += n % 10;\n            n /= 10;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjhrjuugo.d(22): Error: cannot implicitly convert expression `abs(arr[cast(ulong)i])` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjhrjuugo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    import std.algorithm : count;\n    import std.math : abs;\n    import std.conv : to;\n    import std.range : chunks;\n    //int c = 0;\n    auto s = arr.map!(a => a.to!string).map!(a => a.chunks(1).map!(to!long).reduce!(a,b => a+b));\n    auto r = s.count!(a => a > 0);\n    return r;\n    /*\n    for(int i = 0; i < arr.length; i++) {\n        \n        auto a = arr[i].to!string;\n        int res = 0;\n        for(int j = 0; j < a.length; j++) {\n            res += to!int(a[j..j+1]);\n        }\n        if(res > 0) {\n            c++;\n        }\n    }\n    return c;\n    */\n}\n/*\n    Write a function count_vowels which takes a string and returns the number\n    of vowels in it.\n    >>> count_vowels(\"\")\n    0L\n    >>> count_vowels(\"abc\")\n    1L\n    >>> count_vowels(\"abcdf\")\n    2L\n*/\nlong count_vowels(string s) \n{\n    import std.algorithm : count;\n    auto res = s.count!(a => a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u');\n    return res;\n}\n/*\n    Write a function count_pattern which takes a pattern and a string and returns\n    the number of times the pattern appears in the string.\n    If the pattern is empty, it should be counted once per empty string between\n    characters, e.g. \"abc\" has 3 empty strings.\n    >>> count_pattern(\"\", \"\")\n    1L\n    >>> count_pattern(\"\", \"a\")\n    2L\n    >>> count_pattern(\"\", \"ab\")\n    3L\n    >>> count_pattern(\"a\", \"\")\n    0L\n    >>> count_pattern(\"a\", \"a\")\n    1\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqk4r0fqv.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqk4r0fqv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(int i, long elem; arr)\n    {\n        if(abs(elem) >= 0L)\n        {\n            if(abs(elem) / 10L > 0L)\n            {\n                int sum = 0;\n                long n = abs(elem);\n                while(n > 0L)\n                {\n                    sum += cast(int)(n % 10L);\n                    n /= 10L;\n                }\n                if(sum > 0)\n                {\n                    count++;\n                }\n            }\n            else\n            {\n                count++;\n            }\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp6w01ichc.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4283b5]\n??:? void tmp6w01ichc.__unittest_L46_C1() [0x427eba]\n??:? void tmp6w01ichc.__modtest() [0x428134]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b256]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430898]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430375]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b22d]\n??:? runModuleUnitTests [0x42c199]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428804]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(n; arr) \n    {\n        long sum = 0L;\n        n = n < 0L ? -n : n;\n        while(n > 0L)\n        {\n            sum += n % 10L;\n            n /= 10L;\n        }\n        if(sum > 0L)\n            result++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp60vnmbrs.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmp60vnmbrs.__unittest_L34_C1() [0x427e36]\n??:? void tmp60vnmbrs.__modtest() [0x428098]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428764]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(e; arr)\n    {\n        if(digitsum(e) > 0)\n            count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkn7lz6kt.d(22): Error: undefined identifier `digitsum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkn7lz6kt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr) {\n        auto tmp = i;\n        auto sum = 0;\n        while(tmp != 0) {\n            auto r = tmp % 10;\n            tmp = tmp / 10;\n            sum += r;\n        }\n        if(sum > 0)\n            count++;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxz3nylwm.d(33): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxz3nylwm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    auto ret = 0L;\n    auto it = arr.array;\n    for (auto i = 0; i < arr.length; i++)\n    {\n        auto x = it[i];\n        ret += ((x < 0) ? -1 : 1) * (abs(x) % 10);\n        x /= 10;\n        while (x != 0)\n        {\n            ret += (x % 10);\n            x /= 10;\n        }\n    }\n    return ret;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt8a_1i9e.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt8a_1i9e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long x, cnt = 0L;\n    foreach(x; arr)\n    {\n        if(x != 0L)\n        {\n            if(x > 0L && x % 10 == 0L)\n            {\n                ++cnt;\n            }\n            else\n            {\n                int y = abs(x);\n                while(y > 0)\n                {\n                    y /= 10;\n                    if(y > 0)\n                    {\n                        ++cnt;\n                    }\n                }\n            }\n        }\n    }\n    return cnt;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp54ro5kz9.d(44): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp54ro5kz9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    long idx = 0;\n    long val = 0;\n    while(idx < arr.length)\n    {\n        val = arr[idx];\n        if(val >= 0)\n        {\n            if(val != 0)\n            {\n                count++;\n            }\n        }\n        else\n        {\n            count++;\n        }\n        idx++;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgj8xznqs.d(40): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgj8xznqs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong[] signed_digits;\n\tlong result = 0L;\n\tlong sum = 0L;\n\tforeach(elem; arr) \n\t{\n\t\tif(elem < 0L) \n\t\t{\n\t\t\tsigned_digits = [-elem % 10L, -(elem / 10L) % 10L, -(elem / 100L) % 10L, -(elem / 1000L) % 10L, -(elem / 10000L) % 10L, -(elem / 100000L) % 10L, -(elem / 1000000L) % 10L, -(elem / 10000000L) % 10L, -(elem / 100000000L) % 10L, -(elem / 1000000000L) % 10L, -(elem / 10000000000L) % 10L, -(elem / 100000000000L) % 10L, -(elem / 1000000000000L) % 10L, -(elem / 10000000000000L) % 10L, -(elem / 100000000000000L) % 10L, -(elem / 1000000000000000L) % 10L, -(elem / 10000000000000000L) % 10L, -(elem / 100000000000000000L) % 10L, -(elem / 1000000000000000000L) % 10L];\n\t\t}\n\t\telse \n\t\t{\n\t\t\tsigned_digits = [elem % 10L, (elem / 10L) % 10L, (elem / 100L) % 10L, (elem / 1000L) % 10L, (elem / 10000L) % 10L, (elem / 100000L) % 10L, (elem / 1000000L) % 10L, (elem / 10000000L) % 10L, (elem / 100000000L) % 10L, (elem / 1000000000L) % 10L, (elem / 10000000000L) % 10L, (elem / 100000000000L) % 10L, (elem / 1000000000000L) % 10L, (elem / 10000000000000L) % 10L, (elem / 100000000000000L) % 10L, (elem / 100\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd1cm782n.d(30): Error: found `unittest` when expecting `)`\n/tmp/tmpd1cm782n.d(32): Error: found `{` when expecting `,`\n/tmp/tmpd1cm782n.d(33): Error: expression expected, not `alias`\n/tmp/tmpd1cm782n.d(33): Error: found `candidate` when expecting `,`\n/tmp/tmpd1cm782n.d(33): Error: expression expected, not `=`\n/tmp/tmpd1cm782n.d(33): Error: found `count_nums` when expecting `,`\n/tmp/tmpd1cm782n.d(33): Error: expression expected, not `;`\n/tmp/tmpd1cm782n.d(35): Error: found `assert` when expecting `,`\n/tmp/tmpd1cm782n.d(35): Error: found `;` when expecting `,`\n/tmp/tmpd1cm782n.d(36): Error: found `;` when expecting `,`\n/tmp/tmpd1cm782n.d(37): Error: found `;` when expecting `,`\n/tmp/tmpd1cm782n.d(38): Error: found `;` when expecting `,`\n/tmp/tmpd1cm782n.d(39): Error: found `;` when expecting `,`\n/tmp/tmpd1cm782n.d(40): Error: found `;` when expecting `,`\n/tmp/tmpd1cm782n.d(41): Error: found `;` when expecting `,`\n/tmp/tmpd1cm782n.d(42): Error: found `;` when expecting `,`\n/tmp/tmpd1cm782n.d(43): Error: ",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long[] temparr = arr.map!(element => abs(element)).map!(element => element.sumdigits()).filter!(element => element > 0);\n    return temparr.length;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy5vkvz3n.d(22): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy5vkvz3n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong res = 0;\n\tforeach(idx, val; arr) \n\t{\n\t\tif(val == 0) \n\t\t{\n\t\t\tres++;\n\t\t\tcontinue;\n\t\t}\n\t\tint sign = val < 0 ? -1 : 1;\n\t\tval = val < 0 ? -val : val;\n\t\tlong digit_sum = 0;\n\t\twhile(val > 0) \n\t\t{\n\t\t\tdigit_sum += val % 10;\n\t\t\tval /= 10;\n\t\t}\n\t\tif(sign * digit_sum > 0) \n\t\t{\n\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfn4v3y8x.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmpfn4v3y8x.__unittest_L42_C1() [0x427e66]\n??:? void tmpfn4v3y8x.__modtest() [0x4280c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428794]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(int a; arr)\n    {\n        long current = a;\n        long sum = 0;\n        while(current != 0)\n        {\n            sum += abs(current % 10);\n            current /= 10;\n        }\n        if(sum > 0)\n            count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_a_frvpm.d(20): Error: cannot implicitly convert expression `__r73[__key74]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_a_frvpm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr) {\n        long sum = 0;\n        long tmp = i < 0 ? -i : i;\n        while(tmp != 0) {\n            sum += tmp % 10;\n            tmp /= 10;\n        }\n        if(sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpigm7afur.d(33): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpigm7afur.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n  long counter = 0;\n  foreach(n; arr)\n  {\n    int[] digits = to!(int[])(n.text.to!(char[])).map!(a => a.to!int - '0'.to!int);\n    counter += (digits.sum > 0) ? 1 : 0;\n  }\n  return counter;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmn_vhimt.d(27): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmn_vhimt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    foreach(index, val; arr)\n    {\n        auto digits = new int[](2);\n        auto len = 0;\n        bool isNegative = false;\n        if(val < 0)\n        {\n            val = abs(val);\n            isNegative = true;\n        }\n        while(val > 0)\n        {\n            digits[len] = val % 10;\n            val /= 10;\n            len++;\n        }\n        if(len == 0)\n        {\n            digits[0] = 0;\n            len = 1;\n        }\n        auto sum = 0;\n        for(auto i = 0; i < len; i++)\n        {\n            sum += digits[i];\n        }\n        if(isNegative)\n        {\n            sum *= -1;\n        }\n        if(sum > 0)\n        {\n            ret++;\n        }\n    }\n    return ret;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkq1ka_ha.d(57): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkq1ka_ha.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr)\n    {\n        if(abs(i) < 10)\n        {\n            count++;\n        }\n        else\n        {\n            auto tmp = abs(i);\n            long sum = 0;\n            while(tmp != 0)\n            {\n                sum += tmp % 10;\n                tmp /= 10;\n            }\n            if(sum > 0)\n            {\n                count++;\n            }\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp35wys_yp.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp35wys_yp.__unittest_L43_C1() [0x427ea6]\n??:? void tmp35wys_yp.__modtest() [0x428120]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b23e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430880]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43035d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b215]\n??:? runModuleUnitTests [0x42c181]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287ec]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long res = 0;\n    foreach(n; arr) {\n        if(n > 0) {\n            long sum = 0;\n            foreach(digit; n.digits) {\n                sum += digit;\n            }\n            if(sum > 0) {\n                res++;\n            }\n        } else {\n            long sum = 0;\n            foreach(digit; n.digits) {\n                sum += digit;\n            }\n            if(sum < 0) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdrj9tejf.d(23): Error: no property `digits` for type `long`\n/tmp/tmpdrj9tejf.d(31): Error: no property `digits` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdrj9tejf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong total = 0;\n\tforeach(e; arr) \n\t{\n\t\tif(e == 0)\n\t\t\tcontinue;\n\t\tif(e < 0)\n\t\t\te = -e;\n\t\tlong curr_digit_sum = 0;\n\t\twhile(e != 0) \n\t\t{\n\t\t\tcurr_digit_sum += e % 10;\n\t\t\te /= 10;\n\t\t}\n\t\tif(curr_digit_sum > 0)\n\t\t\ttotal++;\n\t}\n\treturn total;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt9j59qfk.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428325]\n??:? void tmpt9j59qfk.__unittest_L37_C1() [0x427e46]\n??:? void tmpt9j59qfk.__modtest() [0x4280a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c333]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1c6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430359]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430808]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b19d]\n??:? runModuleUnitTests [0x42c109]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428774]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr) {\n        i = i < 0 ? -i : i;\n        long sum = 0;\n        while(i > 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if(sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpd7wr6pq3.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmpd7wr6pq3.__unittest_L33_C1() [0x427e36]\n??:? void tmpd7wr6pq3.__modtest() [0x428098]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428764]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\treturn 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpw5pi_stq.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x428275]\n??:? void tmpw5pi_stq.__unittest_L21_C1() [0x427e19]\n??:? void tmpw5pi_stq.__modtest() [0x427ff8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c283]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b116]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430758]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430235]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0ed]\n??:? runModuleUnitTests [0x42c059]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    long absNum = 0;\n    long num = 0;\n    foreach(num; arr)\n    {\n        absNum = abs(num);\n        do\n        {\n            sum += absNum % 10;\n            absNum /= 10;\n        } while(absNum > 0);\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvspt503h.d(22): Error: variable `num` is shadowing variable `tmpvspt503h.count_nums.num`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvspt503h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int sum = 0;\n    foreach(i; arr)\n    {\n        sum += sumOfDigits(i);\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzy8dk_ta.d(22): Error: undefined identifier `sumOfDigits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzy8dk_ta.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long counter = 0;\n    auto temp_signed_digits = new TypeTuple!(int[]);\n    for (auto n = arr.front; n !is null; n = n.next)\n    {\n        int temp_sum = 0;\n        auto signed_digits = signedDigits(n.value);\n        for (auto x = signed_digits.front; x !is null; x = x.next)\n        {\n            temp_sum += x.value;\n        }\n        if (temp_sum > 0)\n        {\n            counter++;\n        }\n    }\n    return counter;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps9g4xy03.d(20): Error: template instance `TypeTuple!(int[])` template `TypeTuple` is not defined\n/tmp/tmps9g4xy03.d(21): Error: no property `front` for type `long[]`\n/tmp/tmps9g4xy03.d(24): Error: undefined identifier `signedDigits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps9g4xy03.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    long sum = 0;\n    foreach(val; arr) \n    {\n        sum = val < 0 ? -val : val;\n        while(sum > 0) \n        {\n            count += sum % 10;\n            sum /= 10;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp83zojeea.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmp83zojeea.__unittest_L32_C1() [0x427e22]\n??:? void tmp83zojeea.__modtest() [0x428084]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c313]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1a6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430339]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307e8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b17d]\n??:? runModuleUnitTests [0x42c0e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428754]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr) {\n        long sum = 0;\n        long num = i < 0 ? i : -i;\n        while(num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if(sum > 0)\n            count++;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5gxzftby.d(32): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5gxzftby.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.count!(x => x.abs.sumDigits > 0);\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvygifpzh.d(19): Error: no property `count` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvygifpzh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long j = 0;\n    foreach(e; arr)\n    {\n        if (abs(e) >= 10) \n        {\n            long sum = 0;\n            while (e != 0) \n            {\n                sum += abs(e % 10);\n                e /= 10;\n            }\n            if (sum > 0)\n                j++;\n        }\n        else if (abs(e) > 0)\n            j++;\n    }\n    return j;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpf2rep0be.d(38): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf2rep0be.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong count = 0;\n\tforeach(i; arr)\n\t{\n\t\tint temp = abs(i);\n\t\twhile(temp > 0)\n\t\t{\n\t\t\tcount += temp % 10;\n\t\t\ttemp /= 10;\n\t\t}\n\t\tif(count > 0)\n\t\t\tcount = 1;\n\t}\n\treturn count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphvwlqq11.d(33): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphvwlqq11.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long c = 0;\n    foreach(i; arr) {\n        if(abs(i) != i) {\n            c += sum(i.digits);\n        } else {\n            c += sum(abs(i).digits);\n        }\n    }\n    return c;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2x_y6qiw.d(29): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2x_y6qiw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i;arr)\n    {\n        if(i < 0)\n        {\n            i *= -1;\n        }\n        long sum = 0;\n        while(i > 0)\n        {\n            sum += i % 10;\n            i /= 10;\n        }\n        if(sum > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpl6eig8_v.d(39): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl6eig8_v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    //auto res = arr.map!(a =>a).filter!(a => a > 0).sum;\n    auto res = 0L;\n    foreach(a; arr)\n    {\n        auto sum = 0L;\n        for(auto i = 0L; i < a.length; ++i)\n        {\n            sum += a[i];\n        }\n        if(sum > 0)\n        {\n            res += 1;\n        }\n    }\n    return res;\n}\n//long count_nums(long[] arr) { return 0L; }\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6_gx8k4t.d(24): Error: no property `length` for type `long`\n/tmp/tmp6_gx8k4t.d(26): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6_gx8k4t.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong count_nums = 0L;\n\tforeach(int num; arr)\n\t{\n\t\tint num_digits = num;\n\t\tlong digits_sum = 0L;\n\t\twhile(num_digits != 0)\n\t\t{\n\t\t\tdigits_sum += abs(num_digits % 10);\n\t\t\tnum_digits /= 10;\n\t\t}\n\t\tif(digits_sum > 0)\n\t\t\tcount_nums++;\n\t}\n\treturn count_nums;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnkhs3c36.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnkhs3c36.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    auto len = arr.length;\n    long count = 0;\n    for (inout(long) num : arr) \n    {\n        inout(long) sum = 0;\n        if (num < 0) \n        {\n            sum += abs(num % 10);\n            num /= 10;\n        }\n        while (num > 0) \n        {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) \n        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyyufkpzy.d(21): Error: semicolon expected, not `:`\n/tmp/tmpyyufkpzy.d(21): Error: expression expected, not `:`\n/tmp/tmpyyufkpzy.d(21): Error: found `arr` when expecting `;` following `for` condition\n/tmp/tmpyyufkpzy.d(41): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyyufkpzy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long elem; elem : arr)\n    {\n        long sum = 0;\n        if (elem < 0)\n        {\n            sum += -elem % 10;\n            elem = -elem / 10;\n        }\n        while (elem > 0)\n        {\n            sum += elem % 10;\n            elem /= 10;\n        }\n        if (sum > 0)\n            count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt59y7n4a.d(20): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt59y7n4a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        long a = arr[i];\n        long sum = 0;\n        while (a != 0)\n        {\n            sum += a % 10;\n            a /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8x1idmdt.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmp8x1idmdt.__unittest_L33_C1() [0x427ff5]\n??:? void tmp8x1idmdt.__modtest() [0x428090]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b222]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430864]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430341]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]\n??:? runModuleUnitTests [0x42c165]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    auto new_arr = arr.filter!(n =>\n    {\n        int sum = 0;\n        foreach(var digit; n.abs.digits)\n        {\n            sum += digit;\n        }\n        return sum > 0;\n    });\n    return new_arr.length;\n}\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_s39sd2p.d(30): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_s39sd2p.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    // Write your implementation here\n    long result = 0;\n    foreach(elt; arr)\n    {\n        if(abs(elt) > 0)\n        {\n            int sum = 0;\n            foreach(signed_digit; tuple(abs(elt).signedDigits))\n            {\n                sum += signed_digit;\n            }\n            if(sum > 0)\n            {\n                result++;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc_d4hbyb.d(26): Error: no property `signedDigits` for type `long`\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return 0L;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpctkoyee8.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x428275]\n??:? void tmpctkoyee8.__unittest_L21_C1() [0x427e19]\n??:? void tmpctkoyee8.__modtest() [0x427ff8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c283]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b116]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430758]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430235]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0ed]\n??:? runModuleUnitTests [0x42c059]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    /*\n        \uc7ac\uadc0\ud568\uc218\ub97c \uc774\uc6a9\ud574 \uad6c\ud604\ud558\ub294\uac8c \uc26c\uc6b4\uac70 \uac19\ub2e4.\n        \uc74c\uc218\uc778 \uacbd\uc6b0 \ub530\ub85c \ucd94\uac00\ud574\uc900\ub2e4.\n    */\n    long addDigit(long n) \n    {\n        if (n < 0) \n        {\n            n = -n;\n        }\n        if (n < 10) \n        {\n            return n;\n        }\n        return n % 10 + addDigit(n / 10);\n    }\n    return arr.filter!(n => addDigit(n) > 0).length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz8f79ict.d(35): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz8f79ict.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr) {\n        if (abs(i) < 10)\n            continue;\n        long s = 0;\n        while (i != 0) {\n            s += abs(i % 10);\n            i /= 10;\n        }\n        if (s != 0)\n            count++;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqtlpug60.d(33): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqtlpug60.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long counter = 0;\n    foreach(item; arr)\n    {\n        long[] digits = item.toString.split(`-`);\n        long sum = 0;\n        foreach(dig; digits)\n        {\n            sum += dig.sumDigits;\n        }\n        if(sum > 0)\n        {\n            counter++;\n        }\n    }\n    return counter;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpr4_gatu6.d(22): Error: no property `toString` for type `long`\n/tmp/tmpr4_gatu6.d(26): Error: no property `sumDigits` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr4_gatu6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int res = 0;\n    foreach(el; arr) \n    {\n        if(el < 0) el = -el;\n        if(el / 10 == 0) res++;\n        else \n        {\n            while(el > 0) \n            {\n                res += el % 10;\n                el /= 10;\n            }\n            if(res > 0) res++;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpme8zax5f.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpme8zax5f.__unittest_L36_C1() [0x427e56]\n??:? void tmpme8zax5f.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428784]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long n = 0L;\n    foreach(i; arr) \n    {\n        long x = i < 0L ? -i : i;\n        while(x) \n        {\n            n += x % 10L;\n            x /= 10L;\n        }\n    }\n    return n;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpu9wpiyhl.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmpu9wpiyhl.__unittest_L31_C1() [0x427e22]\n??:? void tmpu9wpiyhl.__modtest() [0x428084]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c313]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1a6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430339]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307e8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b17d]\n??:? runModuleUnitTests [0x42c0e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428754]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long res = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] == 0)\n        {\n            continue;\n        }\n        else if (arr[i] < 0)\n        {\n            res += abs(arr[i] / 10) + 1;\n        }\n        else\n        {\n            res += abs(arr[i] / 10);\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0zrstqe5.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4283ed]\n??:? void tmp0zrstqe5.__unittest_L37_C1() [0x427ef2]\n??:? void tmp0zrstqe5.__modtest() [0x42816c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c46f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b302]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430495]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430944]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430421]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2d9]\n??:? runModuleUnitTests [0x42c245]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    foreach(idx, n; arr) \n    {\n        if(sum(abs(n).digits()) > 0L) \n        {\n            ret += 1L;\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps7q_qlq5.d(22): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps7q_qlq5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong f_element;\n\tlong b_element;\n\tlong result;\n\t\n\tresult = 0;\n\t\n\tforeach(f_element; arr)\n\t{\n\t\tif (f_element < 0)\n\t\t{\n\t\t\tb_element = f_element * -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb_element = f_element;\n\t\t}\n\t\t\n\t\tforeach(char[] c; strip(to!string(b_element)))\n\t\t{\n\t\t\tresult += b_element;\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp53xjjhdb.d(25): Error: variable `f_element` is shadowing variable `tmp53xjjhdb.count_nums.f_element`\n/tmp/tmp53xjjhdb.d(36): Error: undefined identifier `strip`, did you mean alias `string`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp53xjjhdb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong result = 0;\n\tforeach(elem; arr) \n\t{\n\t\tif(abs(elem) != 0) \n\t\t{\n\t\t\tlong n = abs(elem);\n\t\t\tlong sum = 0;\n\t\t\twhile(n) \n\t\t\t{\n\t\t\t\tsum += n % 10;\n\t\t\t\tn /= 10;\n\t\t\t}\n\t\t\tif(sum > 0)\n\t\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppli17fsi.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmppli17fsi.__unittest_L37_C1() [0x427e9e]\n??:? void tmppli17fsi.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b236]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430878]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430355]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b20d]\n??:? runModuleUnitTests [0x42c179]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287e4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(x; arr)\n    {\n        int sum = 0;\n        long temp = abs(x);\n        while(temp > 0)\n        {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if(sum > 0)\n            count++;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3p4fv3kj.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3p4fv3kj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (auto elem : arr) \n    {\n        long sum = 0;\n        if (elem < 0) elem = -elem;\n        while (elem != 0) \n        {\n            sum += elem % 10;\n            elem /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5hpbmh3i.d(20): Error: no identifier for declarator `elem`\n/tmp/tmp5hpbmh3i.d(20): Error: expression expected, not `:`\n/tmp/tmp5hpbmh3i.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5hpbmh3i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long counter = 0;\n    foreach(elem; arr)\n    {\n        int sum = 0;\n        if(elem < 0)\n        {\n            elem = -elem;\n        }\n        while(elem > 0)\n        {\n            sum += elem % 10;\n            elem /= 10;\n        }\n        if(sum > 0)\n        {\n            counter++;\n        }\n    }\n    return counter;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpk8mxp_bl.d(39): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk8mxp_bl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    import std.math;\n    long[] signed_digits;\n    long count;\n    foreach(int i; 0..arr.length)\n    {\n        if(arr[i] < 0)\n        {\n            signed_digits ~= -arr[i];\n        }\n        else\n        {\n            signed_digits ~= arr[i];\n        }\n    }\n    long sum_digits(long n)\n    {\n        long sum;\n        while(n > 0)\n        {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n    foreach(long j; signed_digits)\n    {\n        if(sum_digits(j) > 0)\n        {\n            count += 1;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgbntf_nd.d(22): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgbntf_nd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long res = 0;\n    foreach(long x; arr) \n    {\n        int i = cast(int) x;\n        if (i < 0)\n            i = -i;\n        res += cast(long) i;\n    }\n    return res;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp44_wnc5s.d(29): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp44_wnc5s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long cnt = 0L;\n    for (int i = 0; i < arr.length; i++) {\n        if (abs(arr[i]).countDigits() > 0) {\n            cnt++;\n        }\n    }\n    return cnt;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz1p8bp1d.d(21): Error: no property `countDigits` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz1p8bp1d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr) \n    {\n        if (abs(i) != i) \n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpsflmnj50.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x42834d]\n??:? void tmpsflmnj50.__unittest_L29_C1() [0x427e52]\n??:? void tmpsflmnj50.__modtest() [0x4280cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c35b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430381]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430830]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43030d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c5]\n??:? runModuleUnitTests [0x42c131]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42879c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return reduce!q{a+b}(arr.map!q{a.sumdigits()}(filter!q{a!=0}(arr)));\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqgzrgroi.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqgzrgroi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong result = 0;\n\tforeach(elem; arr) \n\t{\n\t\tauto str = elem.to!string;\n\t\tbool isNegative = false;\n\t\tif(str[0] == '-') \n\t\t{\n\t\t\tisNegative = true;\n\t\t\tstr = str[1..$];\n\t\t}\n\t\tint sum = 0;\n\t\tforeach(s; str) \n\t\t{\n\t\t\tsum += s.to!int;\n\t\t}\n\t\tif(isNegative) \n\t\t{\n\t\t\tsum += 1;\n\t\t}\n\t\tif(sum > 0) \n\t\t{\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcyb4uzrj.d(22): Error: no property `to` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcyb4uzrj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.sum!(n => Math.abs(n)).count!(s => s > 0);\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_9_2mmrq.d(19): Error: no property `sum` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_9_2mmrq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.length;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9g4fp9y1.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9g4fp9y1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tif (arr.length == 0)\n\t\treturn 0;\n\t\n\tlong count = 0;\n\tforeach (x; arr)\n\t{\n\t\tint num = 0;\n\t\tif (x < 0)\n\t\t\tnum = x * -1;\n\t\telse\n\t\t\tnum = x;\n\t\t\n\t\tint sum = 0;\n\t\twhile (num > 0)\n\t\t{\n\t\t\tsum += num % 10;\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\tif (sum > 0)\n\t\t\tcount++;\n\t}\n\t\n\treturn count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdrjd2oe.d(44): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdrjd2oe.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long res = 0L;\n    foreach(n; arr) \n    {\n        long sum = 0L;\n        long num = abs(n);\n        while(num > 0L) \n        {\n            sum += num % 10L;\n            num /= 10L;\n        }\n        if(sum > 0L) \n        {\n            res++;\n        }\n    }\n    return res;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp849b9_hn.d(36): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp849b9_hn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    foreach(x; arr)\n    {\n        if(x < 0)\n        {\n            x = x * -1;\n        }\n        while(x > 0)\n        {\n            sum += x % 10;\n            x /= 10;\n        }\n    }\n    return sum;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp54zdjty2.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp54zdjty2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n  long count = 0;\n  for (int i = 0; i < arr.length; i++){\n    long a = 0;\n    long b = arr[i];\n    while (b != 0){\n      a += b % 10;\n      b /= 10;\n    }\n    if (a > 0){\n      count++;\n    }\n  }\n  return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpytr83os4.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmpytr83os4.__unittest_L33_C1() [0x427ff9]\n??:? void tmpytr83os4.__modtest() [0x428094]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c397]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b22a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43086c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430349]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b201]\n??:? runModuleUnitTests [0x42c16d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.filter!(a => a.abs().digits.sum > 0).length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp803j28ss.d(19): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp803j28ss.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.length;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9g4fp9y1.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9g4fp9y1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    \n    return 0L;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn7i7dvrw.d(22): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn7i7dvrw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    long n = 0L;\n    long i = 0L;\n    long[] tmp = new long[10L];\n    long j = 0L;\n    long sum = 0L;\n    long x = 0L;\n    long y = 0L;\n    long k = 0L;\n    long v = 0L;\n    long z = 0L;\n    long l = 0L;\n    long m = 0L;\n    long s = 0L;\n    long t = 0L;\n    long q = 0L;\n    long r = 0L;\n    long sign = 0L;\n    long digit = 0L;\n    long sum2 = 0L;\n    long num = 0L;\n    long sign2 = 0L;\n    n = arr.length;\n    i = 0L;\n    while (i < n)\n    {\n        x = arr[i];\n        sum = 0L;\n        if (x >= 0L)\n        {\n            sign = 1L;\n        }\n        else\n        {\n            sign = -1L;\n        }\n        y = x * sign;\n        tmp = new long[10L];\n        j = 0L;\n        while (y > 0L)\n        {\n            digit = y % 10L;\n            sum = sum + digit;\n            tmp[j] = digit;\n            y = y / 10L;\n            j = j + 1L;\n        }\n        if (sum != 0L)\n        {\n            result = result + 1L;\n        }\n        i = i + 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5zuwzz97.d(79): unittest failure\n----------------\n??:? _d_unittestp [0x42840d]\n??:? void tmp5zuwzz97.__unittest_L74_C1() [0x427f2e]\n??:? void tmp5zuwzz97.__modtest() [0x428190]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c4eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b37e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430609]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ab8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430595]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b355]\n??:? runModuleUnitTests [0x42c2c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288d0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] != 0L) {\n            ret++;\n        }\n    }\n    return ret;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9xtrm600.d(27): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9xtrm600.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr)\n    {\n        if(std.math.abs(i) > 9)\n        {\n            long t = i;\n            long sum = 0;\n            while(t != 0)\n            {\n                sum += abs(t % 10);\n                t /= 10;\n            }\n            if(sum > 0)\n                count++;\n        }\n        else\n        {\n            if(i != 0)\n                count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy4gbao3j.d(42): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy4gbao3j.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret = 0L;\n    foreach(idx, val; arr)\n    {\n        int sum = 0;\n        string s = val.to!string;\n        foreach(c; s)\n        {\n            sum += c.to!int - '0'.to!int;\n        }\n        if(sum > 0)\n            ret++;\n    }\n    return ret;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuo9h2ylh.d(33): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuo9h2ylh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcgge5sm9.d(26): unittest failure\n----------------\n??:? _d_unittestp [0x42827d]\n??:? void tmpcgge5sm9.__unittest_L21_C1() [0x427d9a]\n??:? void tmpcgge5sm9.__modtest() [0x427ffc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c28b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b11e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430760]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43023d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0f5]\n??:? runModuleUnitTests [0x42c061]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    if (arr.length == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        long res = 0;\n        foreach (long i; arr)\n        {\n            if(i<0)\n            {\n                res = res + (abs(i) % 10);\n            }\n            else\n            {\n                res = res + (i % 10);\n            }\n            \n        }\n        return res;\n    }\n    \n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyuu6up0z.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpyuu6up0z.__unittest_L42_C1() [0x427e8a]\n??:? void tmpyuu6up0z.__modtest() [0x428104]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n  long result = 0;\n  foreach(elem; arr)\n  {\n    long b = abs(elem);\n    long sum = 0;\n    while(b != 0)\n    {\n      sum += b % 10;\n      b /= 10;\n    }\n    if(sum > 0)\n      result++;\n  }\n  return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpab256ikv.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42837d]\n??:? void tmpab256ikv.__unittest_L34_C1() [0x427e86]\n??:? void tmpab256ikv.__modtest() [0x428100]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long res = 0;\n    foreach(i; arr)\n    {\n        res += (i != 0 && sum((i < 0 ? -i : i).digits) > 0);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbd26e9zw.d(22): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbd26e9zw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    bool isNegative = false;\n    long sum = 0;\n    foreach(n; arr)\n    {\n        sum = 0;\n        isNegative = false;\n        if(n < 0)\n        {\n            isNegative = true;\n            n = -n;\n        }\n        while(n > 0)\n        {\n            sum += n % 10;\n            n /= 10;\n        }\n        if(isNegative)\n        {\n            sum -= 1;\n        }\n        if(sum > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0izqkuxj.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x42833d]\n??:? void tmp0izqkuxj.__unittest_L47_C1() [0x427e5a]\n??:? void tmp0izqkuxj.__modtest() [0x4280bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c34b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1de]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430371]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430820]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302fd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1b5]\n??:? runModuleUnitTests [0x42c121]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42878c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n  long count = 0;\n  foreach(index, int n; arr)\n  {\n    auto tmp = n;\n    if(tmp < 0) tmp = -tmp;\n    long sum = 0;\n    while(tmp)\n    {\n      sum += tmp % 10;\n      tmp /= 10;\n    }\n    if(sum > 0) count++;\n  }\n  return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7sh3vprl.d(20): Error: cannot implicitly convert expression `__r74[__key73]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7sh3vprl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.length;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9g4fp9y1.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9g4fp9y1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164246
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long counter = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (abs(arr[i]) / 10 > 0)\n        {\n            long temp = abs(arr[i]);\n            long sum = 0;\n            while (temp / 10 > 0)\n            {\n                long lastDigit = temp % 10;\n                sum += lastDigit;\n                temp /= 10;\n            }\n            sum += temp;\n            if (sum > 0)\n            {\n                counter++;\n            }\n        }\n        else if (abs(arr[i]) == 0)\n        {\n            continue;\n        }\n        else\n        {\n            counter++;\n        }\n    }\n    return counter;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4z4afu2o.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428405]\n??:? void tmp4z4afu2o.__unittest_L49_C1() [0x427f0e]\n??:? void tmp4z4afu2o.__modtest() [0x428188]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c487]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b31a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43095c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430439]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2f1]\n??:? runModuleUnitTests [0x42c25d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong n = 0;\n\tfor (int i = 0; i < arr.length; i++) \n\t{\n\t\tif (sum_digits(arr[i]) > 0) \n\t\t{\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbxd4qdqr.d(29): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbxd4qdqr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    foreach(i; arr)\n    {\n        long v = i;\n        if(v < 0L)\n        {\n            v = abs(v);\n        }\n        while(v != 0L)\n        {\n            result += v % 10L;\n            v /= 10L;\n        }\n    }\n    return result;\n}\n//long count_nums(long[] arr) {\n//    long[] input = arr.dup;\n//    long result = 0L;\n//    foreach(v; input)\n//    {\n//        if(v < 0L)\n//        {\n//            v = abs(v);\n//        }\n//        while(v != 0L)\n//        {\n//            result += v % 10L;\n//            v /= 10L;\n//        }\n//    }\n//    return result;\n//}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptzhezzko.d(52): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptzhezzko.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n\tlong result = 0;\n\tlong limit = arr.length;\n\tfor (long i = 0; i < limit; i++)\n\t{\n\t\tlong a = arr[i];\n\t\tlong sum = 0;\n\t\twhile (a != 0)\n\t\t{\n\t\t\tsum += abs(a % 10);\n\t\t\ta /= 10;\n\t\t}\n\t\tif (sum > 0)\n\t\t{\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8xk9mks_.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmp8xk9mks_.__unittest_L37_C1() [0x427e96]\n??:? void tmp8xk9mks_.__modtest() [0x428110]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long n = 0L;\n    foreach(i; arr)\n    {\n        long k = 0L;\n        int sign = 1;\n        if(i < 0)\n        {\n            sign = -1;\n            i = -i;\n        }\n        int digits = cast(int)log10(i) + 1;\n        while(digits-- > 0)\n        {\n            long digit = i % 10;\n            k += digit;\n            i /= 10;\n        }\n        if(k * sign > 0)\n            n++;\n    }\n    return n;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkmpbaj_p.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpkmpbaj_p.__unittest_L41_C1() [0x428085]\n??:? void tmpkmpbaj_p.__modtest() [0x428120]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b252]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430894]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430371]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b229]\n??:? runModuleUnitTests [0x42c195]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287ec]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    /*\n    \n    \n    */\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4ljvs17o.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ljvs17o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++){\n        if (arr[i] > 0)\n            count++;\n        else if (arr[i] < 0)\n            count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm2auhw96.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmpm2auhw96.__unittest_L28_C1() [0x427e2a]\n??:? void tmpm2auhw96.__modtest() [0x42808c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b222]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430864]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430341]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]\n??:? runModuleUnitTests [0x42c165]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.filter!(x => x.sumSignedDigits() > 0L).length;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdrkjr9s4.d(21): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdrkjr9s4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    foreach(i; arr) \n    {\n        if(i == 0) \n        {\n            continue;\n        }\n        int sign = signbit(i);\n        i = abs(i);\n        sum = i % 10;\n        while(i /= 10) \n        {\n            sum += i % 10;\n        }\n        if(sum != 0) \n        {\n            if(sign != 0) \n            {\n                sum = -sum;\n            }\n            sum = 1;\n        }\n    }\n    return sum;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp47qjbf2q.d(44): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47qjbf2q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long counter = 0;\n    foreach(int e; arr) \n    {\n        int absE = abs(e);\n        long sumOfDigits = 0;\n        while(absE > 0) \n        {\n            sumOfDigits += absE % 10;\n            absE /= 10;\n        }\n        if(sumOfDigits > 0) \n        {\n            counter++;\n        }\n    }\n    return counter;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8nleakb9.d(36): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8nleakb9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.filter!(a => a.to!string.map!(a => a.to!long).sum > 0).length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5cv0vf3_.d(19): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5cv0vf3_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr)\n    {\n        int sum = 0;\n        foreach(j; i.tupleof)\n        {\n            sum += j;\n        }\n        if(sum > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2ashkc0w.d(23): Error: no property `tupleof` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ashkc0w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(i; arr)\n    {\n        if(abs(i) < 10)\n        {\n            count += 1;\n        }\n        else\n        {\n            long sum = 0;\n            int length = std.to!string(abs(i)).length;\n            for(int j = 0; j < length; j++)\n            {\n                int digit = i % 10;\n                sum += digit;\n                i /= 10;\n            }\n            if(sum > 0)\n            {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpravyhe25.d(29): Error: undefined identifier `to` in package `std`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpravyhe25.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(num; arr) \n    {\n        long sum = 0;\n        if(num < 0)\n        {\n            sum = -num;\n        }\n        else\n        {\n            sum = num;\n        }\n        while(sum > 0)\n        {\n            sum -= sum % 10;\n            sum /= 10;\n        }\n        if(sum != 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdd5vkvsm.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42832d]\n??:? void tmpdd5vkvsm.__unittest_L43_C1() [0x427ecd]\n??:? void tmpdd5vkvsm.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c33b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430361]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430810]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a5]\n??:? runModuleUnitTests [0x42c111]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42877c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (size_t i = 0; i < arr.length; i++) \n    {\n        long num = arr[i];\n        long sum = 0;\n        if (num < 0) \n        {\n            num = -num;\n        }\n        for (; num != 0; num /= 10) \n        {\n            sum += num % 10;\n        }\n        if (sum > 0) \n        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbplqb29z.d(39): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbplqb29z.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return std.algorithm.count!((long x) => x > 0)(arr);\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz50ysgc4.d(19): Error: undefined identifier `algorithm` in package `std`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz50ysgc4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(e; arr)\n    {\n        count += (abs(e) / 10 == 0) ? (abs(e) % 10 != 0) : 1;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkr256o7l.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x42837d]\n??:? void tmpkr256o7l.__unittest_L26_C1() [0x427e86]\n??:? void tmpkr256o7l.__modtest() [0x428100]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long c = 0;\n    int i;\n    for (i = 0; i < arr.length; i++) \n    {\n        c += (sum(cast(int[])arr[i])) > 0 ? 1 : 0;\n    }\n    return c;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp23x1trc5.d(27): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp23x1trc5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(long i; arr)\n    {\n        if(sum(digits(i)) > 0)\n            count++;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv5bxe5it.d(27): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv5bxe5it.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    static struct T (size_t num, size_t sgn) \n    {\n        size_t num;\n        size_t sgn;\n    }\n    pure nothrow @safe T abs(T x) { \n        if (x.sgn) \n            return T(x.num, 0);\n        else \n            return x;\n    }\n    pure nothrow @safe T add(T x, T y) { \n        return T(x.num + y.num, x.sgn + y.sgn);\n    }\n    pure nothrow @safe T addUnsigned(T x, T y) { \n        return T(x.num + y.num, x.sgn);\n    }\n    pure nothrow @safe T digits(long num) \n    {\n        return T(num % 10, num < 0 ? 1 : 0);\n    }\n    pure nothrow @safe long count_nums_rec(T[] arr) \n    {\n        return (arr.length ? (abs(arr[0]).num > 0 || count_nums_rec(arr[1 .. $])) : 0);\n    }\n    return count_nums_rec(arr.map!digits.cumulate!addUnsigned);\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8zxe50nt.d(24): Error: template struct `tmp8zxe50nt.count_nums.T(ulong num, ulong sgn)` is used as a type without instantiation; to instantiate it use `T!(arguments)`\n/tmp/tmp8zxe50nt.d(24): Error: template struct `tmp8zxe50nt.count_nums.T(ulong num, ulong sgn)` is used as a type without instantiation; to instantiate it use `T!(arguments)`\n/tmp/tmp8zxe50nt.d(30): Error: template struct `tmp8zxe50nt.count_nums.T(ulong num, ulong sgn)` is used as a type without instantiation; to instantiate it use `T!(arguments)`\n/tmp/tmp8zxe50nt.d(30): Error: template struct `tmp8zxe50nt.count_nums.T(ulong num, ulong sgn)` is used as a type without instantiation; to instantiate it use `T!(arguments)`\n/tmp/tmp8zxe50nt.d(30): Error: template struct `tmp8zxe50nt.count_nums.T(ulong num, ulong sgn)` is used as a type without instantiation; to instantiate it use `T!(arguments)`\n/tmp/tmp8zxe50nt.d(33): Error: template struct `tmp8zxe50nt.count_nums.T(ulong num, ulong sgn)` is used as a type without instantiation; to instantia",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    long arr_len = arr.length;\n    long tmp = 0;\n    while(count < arr_len)\n    {\n        tmp = arr[count];\n        if(tmp > 0)\n        {\n            if(tmp % 10 > 0)\n            {\n                count += 1;\n            }\n            else\n            {\n                tmp = tmp / 10;\n                if(tmp % 10 > 0)\n                {\n                    count += 1;\n                }\n                else\n                {\n                    tmp = tmp / 10;\n                    if(tmp % 10 > 0)\n                    {\n                        count += 1;\n                    }\n                    else\n                    {\n                        count += 1;\n                    }\n                }\n            }\n        }\n        else\n        {\n            tmp = tmp * -1;\n            if(tmp % 10 > 0)\n            {\n                count += 1;\n            }\n            else\n            {\n                tmp = tmp / 10;\n                if(tmp % 10 > 0)\n                {\n                    count += 1;\n                }\n                else\n                {\n                    tmp = tmp / 10;\n                    if(tmp % 10 > 0)\n                    {\n                        count += 1;\n                    }\n                    else\n                    {\n                        count += 1;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1vvjff5o.d(88): unittest failure\n----------------\n??:? _d_unittestp [0x4283ad]\n??:? void tmp1vvjff5o.__unittest_L83_C1() [0x427eca]\n??:? void tmp1vvjff5o.__modtest() [0x42812c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c42f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430455]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430904]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b299]\n??:? runModuleUnitTests [0x42c205]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428870]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int[] tmp_arr = new int[arr.length];\n    for (int i = 0; i < arr.length; i++)\n    {\n        int a = arr[i];\n        while (a != 0)\n        {\n            int b = a % 10;\n            tmp_arr[i] += b;\n            a /= 10;\n        }\n    }\n    return tmp_arr.filter!(n => n > 0).length;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1lxtkyz4.d(22): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmp1lxtkyz4.d(30): Error: no property `filter` for type `int[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1lxtkyz4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long n= 0L;\n    foreach(i; arr)\n    {\n        if(std.math.abs(i)>9L)\n        {\n            long a=0L;\n            long x= i;\n            do{\n                a+= x%10L;\n                x/=10L;\n            }while(x!=0L);\n            if(a>0L)\n                n++;\n        }\n        else\n            if(i>0L)\n                n++;\n    }\n    return n;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn7m6s233.d(39): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn7m6s233.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int t = arr.length;\n    int i = 0;\n    int d = 0;\n    long result = 0;\n    while (i < t) {\n        if (arr[i] < 0) {\n            d = abs(arr[i]);\n        } else {\n            d = arr[i];\n        }\n        while (d > 0) {\n            result += d % 10;\n            d /= 10;\n        }\n        if (result > 0) {\n            result = 1;\n        } else {\n            result = 0;\n        }\n        i += 1;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkbjnzpv3.d(19): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\n/tmp/tmpkbjnzpv3.d(25): Error: cannot implicitly convert expression `abs(arr[cast(ulong)i])` of type `long` to `int`\n/tmp/tmpkbjnzpv3.d(27): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkbjnzpv3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    \n    long[] a = arr.dup;\n    long cnt = 0;\n    long len = a.length;\n    long tmp;\n    long sum;\n    for (long i = 0; i < len; i++) {\n        tmp = a[i];\n        sum = 0;\n        while (tmp != 0) {\n            sum += abs(tmp % 10);\n            tmp /= 10;\n        }\n        if (sum > 0) {\n            cnt++;\n        }\n    }\n    return cnt;\n}\n//*/\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5bihfsnn.d(39): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5bihfsnn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n  long ret = 0;\n  foreach(inout e; arr)\n  {\n    if(sum_signed_digits(e) > 0)\n      ret++;\n  }\n  return ret;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2uo_rql_.d(20): Error: variable `tmp2uo_rql_.count_nums.e` `inout` variables can only be declared inside `inout` functions\n/tmp/tmp2uo_rql_.d(22): Error: undefined identifier `sum_signed_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2uo_rql_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.filter!(e => e < 0 ? sumSignedDigits(-e) > 0 : sumDigits(e) > 0).length;\n}\nlong sumDigits(long n)\n{\n    long result = 0;\n    while (n != 0) {\n        result += n % 10;\n        n /= 10;\n    }\n    return result;\n}\nlong sumSignedDigits(long n)\n{\n    long result = 0;\n    while (n != 0) {\n        result += n % 10;\n        n /= 10;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpui7ck3a4.d(19): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpui7ck3a4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long res = 0L;\n    foreach(index, item; arr) \n    {\n        long val = 0L;\n        while(item != 0L) \n        {\n            val += item % 10L;\n            item /= 10L;\n        }\n        if(val > 0L)\n            res++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpsku1eh4j.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmpsku1eh4j.__unittest_L33_C1() [0x427ff5]\n??:? void tmpsku1eh4j.__modtest() [0x428090]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c31b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430341]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b185]\n??:? runModuleUnitTests [0x42c0f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42875c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    int[] arr2 = new int[arr.length];\n    foreach(int i,ref long v; arr)\n    {\n        if(v<0)\n            arr2[i] = -v;\n        else\n            arr2[i] = v;\n    }\n    return arr2.count!(x=>x/10!=0);\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5h07y1br.d(23): Error: cannot implicitly convert expression `-v` of type `long` to `int`\n/tmp/tmp5h07y1br.d(25): Error: cannot implicitly convert expression `v` of type `long` to `int`\n/tmp/tmp5h07y1br.d(27): Error: no property `count` for type `int[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5h07y1br.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0L;\n    for (long x = 0L; x < arr.length; x++)\n    {\n        if (sumDigits(arr[x]) > 0L)\n        {\n            result++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp592gwlq3.d(22): Error: undefined identifier `sumDigits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp592gwlq3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        auto n = arr[i];\n        if (n < 0) n = -n;\n        if (n == 0)\n        {\n            return sum;\n        }\n        else\n        {\n            long digits_sum = 0;\n            for (; n != 0; n /= 10) digits_sum += n % 10;\n            if (digits_sum > 0) sum++;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp6q72bue_.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42833d]\n??:? void tmp6q72bue_.__unittest_L37_C1() [0x427e5a]\n??:? void tmp6q72bue_.__modtest() [0x4280bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b252]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430894]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430371]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b229]\n??:? runModuleUnitTests [0x42c195]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428800]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    foreach(a; arr)\n    {\n        long sum = 0;\n        while(a != 0)\n        {\n            auto m = a % 10;\n            sum += abs(m);\n            a /= 10;\n        }\n        if(sum > 0)\n            count++;\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt9m0xw_1.d(34): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9m0xw_1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long cnt = 0L;\n    foreach(e; arr)\n    {\n        auto d = e.abs.digits.sum;\n        if(d)\n            cnt++;\n    }\n    return cnt;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmuo6icio.d(22): Error: no property `digits` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmuo6icio.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164247
    }
  ]
}