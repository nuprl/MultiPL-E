name: HumanEval_10_make_palindrome
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Find the shortest palindrome that begins with a supplied\
  \ string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of\
  \ supplied string that is a palindrome.\n    // - Append to the end of the string\
  \ reverse of a string prefix that comes before the palindromic suffix.\n    // >>>\
  \ makePalindrome((\"\"))\n    // (\"\")\n    // >>> makePalindrome((\"cat\"))\n\
  \    // (\"catac\")\n    // >>> makePalindrome((\"cata\"))\n    // (\"catac\")\n\
  \    public static String makePalindrome(String string) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        if (string.length() == 0) {\n            return string;\n \
    \       }\n        int maxPalindromeLength = 0;\n        int maxPalindromeIndex\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            int palindromeLength\
    \ = 0;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindromeLength += 2;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            if (palindromeLength > maxPalindromeLength) {\n     \
    \           maxPalindromeLength = palindromeLength;\n                maxPalindromeIndex\
    \ = i;\n            }\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int i = 0; i < string.length() - maxPalindromeLength; i++) {\n \
    \           builder.append(string.charAt(string.length() - i - 1));\n        }\n\
    \        return builder.toString();", "        // Find the longest palindromic\
    \ suffix.\n        int suffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   suffixLength = string.length() - i;\n                break;\n            }\n\
    \        }\n        // Append the reverse of the prefix to the end of the string.\n\
    \        return string + new StringBuilder(string.substring(0, string.length()\
    \ - suffixLength)).reverse().toString();", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ longestPalindrome = 0;\n        for (int i = 0; i < length; i++) {\n       \
    \     int palindromeLength = length - i;\n            if (palindromeLength <=\
    \ longestPalindrome) {\n                break;\n            }\n            String\
    \ postfix = string.substring(i);\n            if (isPalindrome(postfix)) {\n \
    \               longestPalindrome = palindromeLength;\n            }\n       \
    \ }\n        String prefix = string.substring(0, length - longestPalindrome);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();", "        // Find the longest postfix of\
    \ supplied string that is a palindrome.\n        int maxLength = 0;\n        for\
    \ (int i = 0; i < string.length(); i++) {\n            int length = 0;\n     \
    \       for (int j = 0; j <= i; j++) {\n                if (string.charAt(i -\
    \ j) == string.charAt(i + j)) {\n                    length += 1;\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            maxLength = Math.max(maxLength, length);\n        }\n        // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n        StringBuilder builder = new StringBuilder(string);\n      \
    \  for (int i = 0; i < string.length() - maxLength; i++) {\n            builder.append(string.charAt(string.length()\
    \ - 1 - i));\n        }\n        return builder.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = string.length() - 1;\n    \
    \    while (i >= 0) {\n            if (isPalindrome(string.substring(i))) {\n\
    \                break;\n            }\n            i--;\n        }\n        sb.append(new\
    \ StringBuilder(string.substring(0, i)).reverse());\n        return sb.toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        for (int\
    \ i = 1, l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n              \
    \  z[i] = Math.min(r - i + 1, z[i - l]);\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i]))\n                ++z[i];\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; ++i)\
    \ {\n            if (z[i] == n - i && i > max)\n                max = i;\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        for (int i =\
    \ n - max - 1; i >= 0; --i)\n            sb.append(string.charAt(i));\n      \
    \  sb.append(string);\n        return sb.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        String reversed = sb.reverse().toString();\n\
    \        int length = string.length();\n        for (int i = 0; i < length; i++)\
    \ {\n            if (string.substring(0, length - i).equals(reversed.substring(i)))\
    \ {\n                return string + reversed.substring(0, i);\n            }\n\
    \        }\n        return string + reversed.substring(0, length);", "       \
    \ int n = string.length();\n        int[] z = new int[n];\n        int l = 0,\
    \ r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n \
    \               z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n       \
    \     while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n\
    \                z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n\
    \                l = i;\n                r = i + z[i] - 1;\n            }\n  \
    \      }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n      \
    \      if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n    \
    \        }\n        }\n        StringBuilder sb = new StringBuilder();\n     \
    \   for (int i = max; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    int n = string.length();\n        int[] z = new int[n];\n        for (int\
    \ i = 1, l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n              \
    \  z[i] = Math.min(r - i + 1, z[i - l]);\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i]))\n                ++z[i];\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; ++i)\
    \ {\n            if (z[i] == n - i && i > max)\n                max = i;\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        for (int i =\
    \ n - max - 1; i >= 0; --i)\n            sb.append(string.charAt(i));\n      \
    \  sb.append(string);\n        return sb.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        StringBuilder sb2 = new StringBuilder(string);\n\
    \        StringBuilder sb3 = new StringBuilder(string);\n        StringBuilder\
    \ sb4 = new StringBuilder(string);\n        StringBuilder sb5 = new StringBuilder(string);\n\
    \        StringBuilder sb6 = new StringBuilder(string);\n        StringBuilder\
    \ sb7 = new StringBuilder(string);\n        StringBuilder sb8 = new StringBuilder(string);\n\
    \        StringBuilder sb9 = new StringBuilder(string);\n        StringBuilder\
    \ sb10 = new StringBuilder(string);\n        StringBuilder sb11 = new StringBuilder(string);\n\
    \        StringBuilder sb12 = new StringBuilder(string);\n        StringBuilder\
    \ sb13 = new StringBuilder(string);\n        StringBuilder sb14 = new StringBuilder(string);\n\
    \        StringBuilder sb15 = new StringBuilder(string);\n        StringBuilder\
    \ sb16 = new StringBuilder(string);\n        StringBuilder sb17 = new StringBuilder(string);\n\
    \        StringBuilder sb18 = new StringBuilder(string);\n        StringBuilder\
    \ sb19 = new StringBuilder(string);\n        StringBuilder sb20 = new StringBuilder(string);\n\
    \        StringBuilder sb21 = new StringBuilder(string);\n        StringBuilder\
    \ sb22 = new StringBuilder(string);\n        StringBuilder sb23 = new StringBuilder(string);\n\
    \        StringBuilder sb24 = new StringBuilder(string);\n        StringBuilder\
    \ sb25 = new StringBuilder(string);\n        StringBuilder sb26 = new StringBuilder(string);\n\
    \        StringBuilder sb27 = new StringBuilder(string);\n        StringBuilder\
    \ sb28 = new StringBuilder(string);\n        StringBuilder sb29 = new StringBuilder(string);\n\
    \        StringBuilder sb30 = new StringBuilder(string);\n        StringBuilder\
    \ sb31 = new StringBuilder(string);\n        StringBuilder sb32 = new StringBuilder(string);\n\
    \        StringBuilder sb33 = new StringBuilder(string);\n        StringBuilder\
    \ sb34 = new StringBuilder(string);\n        StringBuilder sb35 = new StringBuilder(string);\n\
    \        StringBuilder sb36 = new StringBuilder(string);\n        StringBuilder\
    \ sb37 = new", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int maxPalindromeSuffixLength = 0;\n        for (int i = 0;\
    \ i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                maxPalindromeSuffixLength = string.length() - i;\n      \
    \          break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - maxPalindromeSuffixLength);\n        StringBuilder sb = new\
    \ StringBuilder(prefix);\n        sb.reverse();\n        return string + sb.toString();",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int maxPalindromeLength = 0;\n        int maxPalindromeIndex = 0;\n   \
    \     for (int i = 0; i < string.length(); i++) {\n            int palindromeLength\
    \ = 0;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindromeLength = 2 *\
    \ j + 1;\n                } else {\n                    break;\n             \
    \   }\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n               \
    \ maxPalindromeIndex = i;\n            }\n        }\n        for (int i = 0; i\
    \ < string.length() - 1; i++) {\n            int palindromeLength = 0;\n     \
    \       for (int j = 0; j <= i; j++) {\n                if (string.charAt(i -\
    \ j) == string.charAt(i + 1 + j)) {\n                    palindromeLength = 2\
    \ * j + 2;\n                } else {\n                    break;\n           \
    \     }\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n               \
    \ maxPalindromeIndex = i;\n            }\n        }\n        StringBuilder builder\
    \ = new StringBuilder(string);\n        for (int i = 0; i < string.length() -\
    \ maxPalindromeLength; i++) {\n            builder.append(string.charAt(string.length()\
    \ - i - 1));\n        }\n        return builder.toString();", "        int n =\
    \ string.length();\n        int i = 0;\n        while (i < n / 2 && string.charAt(i)\
    \ == string.charAt(n - i - 1)) {\n            i++;\n        }\n        if (i ==\
    \ n / 2) {\n            return string;\n        }\n        StringBuilder sb =\
    \ new StringBuilder(string.substring(i));\n        return sb.reverse().append(string).toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int longestPalindromeSuffix = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n                longestPalindromeSuffix\
    \ = i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < n - longestPalindromeSuffix; i++) {\n           \
    \ sb.append(string.charAt(n - 1 - i));\n        }\n        sb.append(string);\n\
    \        return sb.toString();", "        int n = string.length();\n        int[]\
    \ z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        for (int i = n - max - 1; i >= 0; i--) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        return string + sb.toString();",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int length = string.length();\n        int maxPalindromeLength = 0;\n\
    \        for (int i = 0; i < length; i++) {\n            int palindromeLength\
    \ = 0;\n            for (int j = 0; j < length - i; j++) {\n                if\
    \ (string.charAt(i + j) == string.charAt(length - 1 - j)) {\n                \
    \    palindromeLength++;\n                } else {\n                    break;\n\
    \                }\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n            }\n\
    \        }\n        // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n        StringBuilder builder = new\
    \ StringBuilder(string);\n        for (int i = 0; i < length - maxPalindromeLength;\
    \ i++) {\n            builder.append(string.charAt(length - 1 - i));\n       \
    \ }\n        return builder.toString();", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        return string + reverse(prefix);",
  "        int longestPalindrome = longestPalindrome(string);\n        String prefix\
    \ = string.substring(0, string.length() - longestPalindrome);\n        String\
    \ reverse = new StringBuilder(prefix).reverse().toString();\n        return string\
    \ + reverse;", "        StringBuilder sb = new StringBuilder(string);\n      \
    \  StringBuilder reverse = new StringBuilder(string).reverse();\n        int n\
    \ = string.length();\n        int i = 0;\n        while (i < n) {\n          \
    \  if (sb.substring(i).equals(reverse.substring(0, n - i))) {\n              \
    \  break;\n            }\n            i += 1;\n        }\n        return sb.append(reverse.substring(n\
    \ - i)).toString();", "        int n = string.length();\n        int[] p = new\
    \ int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n    \
    \    }\n        int c = 0;\n        int r = 0;\n        for (int i = 1; i < n;\
    \ i++) {\n            int i_mirror = 2 * c - i;\n            if (r > i) {\n  \
    \              p[i] = Math.min(r - i, p[i_mirror]);\n            }\n         \
    \   while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && string.charAt(i + 1 + p[i])\
    \ == string.charAt(i - 1 - p[i])) {\n                p[i]++;\n            }\n\
    \            if (i + p[i] > r) {\n                c = i;\n                r =\
    \ i + p[i];\n            }\n        }\n        int max_len = 0;\n        int center_index\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i + p[i] == n)\
    \ {\n                if (max_len < p[i]) {\n                    max_len = p[i];\n\
    \                    center_index = i;\n                }\n            }\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        for (int i =\
    \ center_index - max_len - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    // Find the longest palindromic suffix.\n        int palindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                palindromeSuffixLength = string.length() - i;\n         \
    \       break;\n            }\n        }\n        // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return string + new StringBuilder(string.substring(0, string.length()\
    \ - palindromeSuffixLength)).reverse().toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int i = string.length()\
    \ - 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(0,\
    \ i + 1))) {\n                break;\n            }\n            i--;\n      \
    \  }\n        String prefix = string.substring(0, i + 1);\n        String suffix\
    \ = string.substring(i + 1);\n        return prefix + reverse(suffix) + suffix;",
  "        StringBuilder sb = new StringBuilder(string);\n        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) == string.charAt(j)) {\n                i++;\n    \
    \            j--;\n            } else {\n                i = 0;\n            \
    \    j--;\n            }\n        }\n        return sb.append(sb.reverse().substring(n\
    \ - i)).toString();", "        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (z[i] == n - i) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        for (int i = max; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return string + sb.reverse().toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        String reverse = sb.reverse().toString();\n\
    \        String palindrome = string + reverse;\n        return palindrome;", " \
    \       int length = string.length();\n        if (length == 0) {\n          \
    \  return string;\n        }\n        int i = 0;\n        int j = length - 1;\n\
    \        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i++;\n            j--;\n\
    \        }\n        if (i >= j) {\n            return string;\n        }\n   \
    \     StringBuilder sb = new StringBuilder(string);\n        for (int k = j -\
    \ 1; k >= i; k--) {\n            sb.append(string.charAt(k));\n        }\n   \
    \     return sb.toString();", "        if (string.length() == 0) {\n         \
    \   return string;\n        }\n        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;", "        StringBuilder builder = new\
    \ StringBuilder(string);\n        StringBuilder reversed = new StringBuilder(string).reverse();\n\
    \        int length = string.length();\n        for (int i = 0; i < length; i++)\
    \ {\n            if (builder.toString().equals(reversed.toString())) {\n     \
    \           return builder.toString();\n            }\n            builder.append(reversed.charAt(i));\n\
    \        }\n        return builder.toString();", "        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        int palindromeLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                palindromeLength = string.length() - i;\n               \
    \ break;\n            }\n        }\n        // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n     \
    \   return string + new StringBuilder(string.substring(0, string.length() - palindromeLength)).reverse().toString();",
  "        int n = string.length();\n        for (int i = n - 1; i >= 0; i--) {\n\
    \            if (isPalindrome(string.substring(i))) {\n                return\
    \ string + reverse(string.substring(0, i));\n            }\n        }\n      \
    \  return string;", "        int n = string.length();\n        int[] z = new int[n];\n\
    \        z[0] = 0;\n        int l = 0;\n        int r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        int maxIndex\
    \ = 0;\n        for (int i = 0; i < n; i++) {\n            if (z[i] > max) {\n\
    \                max = z[i];\n                maxIndex = i;\n            }\n \
    \       }\n        StringBuilder sb = new StringBuilder();\n        for (int i\
    \ = maxIndex + max; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    if (string.length() == 0) {\n            return string;\n        }\n    \
    \    StringBuilder sb = new StringBuilder(string);\n        StringBuilder reversed\
    \ = new StringBuilder(string);\n        reversed.reverse();\n        int i = 0;\n\
    \        while (i < string.length()) {\n            if (string.substring(i).equals(reversed.substring(0,\
    \ string.length() - i))) {\n                break;\n            }\n          \
    \  i++;\n        }\n        sb.append(reversed.substring(string.length() - i));\n\
    \        return sb.toString();", "        // Find the longest palindromic suffix.\n\
    \        int suffixLength = 0;\n        for (int i = 0; i < string.length(); i++)\
    \ {\n            if (isPalindrome(string.substring(i))) {\n                suffixLength\
    \ = string.length() - i;\n                break;\n            }\n        }\n \
    \       // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        String prefix = string.substring(0,\
    \ string.length() - suffixLength);\n        StringBuilder builder = new StringBuilder(string);\n\
    \        builder.append(reverse(prefix));\n        return builder.toString();",
  "        int length = string.length();\n        if (length == 0) {\n           \
    \ return string;\n        }\n        int[] z = new int[length];\n        int left\
    \ = 0;\n        int right = 0;\n        for (int i = 1; i < length; i++) {\n \
    \           if (i > right) {\n                left = right = i;\n            \
    \    while (right < length && string.charAt(right) == string.charAt(right - left))\
    \ {\n                    right++;\n                }\n                z[i] = right\
    \ - left;\n                right--;\n            } else {\n                int\
    \ k = i - left;\n                if (z[k] < right - i + 1) {\n               \
    \     z[i] = z[k];\n                } else {\n                    left = i;\n\
    \                    while (right < length && string.charAt(right) == string.charAt(right\
    \ - left)) {\n                        right++;\n                    }\n      \
    \              z[i] = right - left;\n                    right--;\n          \
    \      }\n            }\n        }\n        int maxZ = 0;\n        int maxZIndex\
    \ = 0;\n        for (int i = 1; i < length; i++) {\n            if (z[i] > maxZ)\
    \ {\n                maxZ = z[i];\n                maxZIndex = i;\n          \
    \  }\n        }\n        StringBuilder builder = new StringBuilder();\n      \
    \  builder.append(string);\n        for (int i = maxZIndex - maxZ + 1; i < maxZIndex;\
    \ i++) {\n            builder.append(string.charAt(i));\n        }\n        return\
    \ builder.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        for (int i = 0; i < n; i++) {\n            if\
    \ (sb.substring(i).equals(rev.substring(0, n - i))) {\n                return\
    \ sb.append(rev.substring(n - i)).toString();\n            }\n        }\n    \
    \    return sb.append(rev.substring(1)).toString();", "        StringBuilder sb\
    \ = new StringBuilder(string);\n        StringBuilder rev = new StringBuilder(string).reverse();\n\
    \        int i = 0;\n        while (i < sb.length() && !sb.substring(i).equals(rev.substring(0,\
    \ sb.length() - i))) {\n            i++;\n        }\n        return sb.append(rev.substring(sb.length()\
    \ - i)).toString();", "        int length = string.length();\n        if (length\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < length; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = length - i;\n           \
    \     break;\n            }\n        }\n        return string + reverse(string.substring(0,\
    \ length - longestPalindromeSuffixLength));", "        StringBuilder sb = new\
    \ StringBuilder(string);\n        StringBuilder rev = new StringBuilder(string).reverse();\n\
    \        int n = string.length();\n        int i = 0;\n        while (i < n) {\n\
    \            if (sb.substring(i).equals(rev.substring(0, n - i))) {\n        \
    \        break;\n            }\n            i++;\n        }\n        return sb.append(rev.substring(n\
    \ - i)).toString();", "        int n = string.length();\n        int[] p = new\
    \ int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n    \
    \    }\n        int c = 0;\n        int r = 0;\n        for (int i = 1; i < n;\
    \ i++) {\n            int i_mirror = 2 * c - i;\n            if (r > i) {\n  \
    \              p[i] = Math.min(r - i, p[i_mirror]);\n            }\n         \
    \   while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && string.charAt(i + 1 + p[i])\
    \ == string.charAt(i - 1 - p[i])) {\n                p[i]++;\n            }\n\
    \            if (i + p[i] > r) {\n                c = i;\n                r =\
    \ i + p[i];\n            }\n        }\n        int max_len = 0;\n        int center_index\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i + p[i] == n)\
    \ {\n                if (max_len < p[i]) {\n                    max_len = p[i];\n\
    \                    center_index = i;\n                }\n            }\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        sb.append(string.substring(0,\
    \ center_index - max_len));\n        sb.reverse();\n        sb.append(string);\n\
    \        return sb.toString();", "        // >>> findLongestPalindromicSuffix(\"\
    \")\n        // (\"\")\n        // >>> findLongestPalindromicSuffix(\"cat\")\n\
    \        // (\"\")\n        // >>> findLongestPalindromicSuffix(\"cata\")\n  \
    \      // (\"a\")\n        // >>> findLongestPalindromicSuffix(\"catac\")\n  \
    \      // (\"ac\")\n        // >>> findLongestPalindromicSuffix(\"cataca\")\n\
    \        // (\"aca\")\n        // >>> findLongestPalindromicSuffix(\"catacat\"\
    )\n        // (\"cat\")\n        // >>> findLongestPalindromicSuffix(\"catacata\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatac\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacataca\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacat\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacata\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatac\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacataca\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacat\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacata\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacatac\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacataca\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicSuffix(\"catacatacatacatacat\"\
    )\n        // (\"atacat\")\n        // >>> findLongestPalindromicS", "       \
    \ if (string.length() == 0) {\n            return string;\n        }\n       \
    \ int longestPalindromeSuffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   longestPalindromeSuffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        return string + new StringBuilder(string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength)).reverse().toString();", " \
    \       int n = string.length();\n        int i = 0;\n        int j = n - 1;\n\
    \        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i++;\n            j--;\n\
    \        }\n        if (i >= j) {\n            return string;\n        }\n   \
    \     String prefix = string.substring(0, i);\n        String suffix = string.substring(i);\n\
    \        String reversed = new StringBuilder(suffix).reverse().toString();\n \
    \       return prefix + reversed + suffix;", "        StringBuilder builder =\
    \ new StringBuilder(string);\n        int length = string.length();\n        int\
    \ i = 0;\n        int j = length - 1;\n        while (i < j) {\n            if\
    \ (string.charAt(i) == string.charAt(j)) {\n                i++;\n           \
    \     j--;\n            } else {\n                i = 0;\n                j--;\n\
    \            }\n        }\n        if (i == j) {\n            builder.append(builder.reverse().substring(1));\n\
    \        } else {\n            builder.append(builder.reverse().substring(0, length\
    \ - j - 1));\n        }\n        return builder.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        return string + reverse(string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength));", "        // Find the longest\
    \ palindromic suffix.\n        String suffix = \"\";\n        for (int i = string.length()\
    \ - 1; i >= 0; i--) {\n            if (isPalindrome(string.substring(i))) {\n\
    \                suffix = string.substring(i);\n                break;\n     \
    \       }\n        }\n        // Append reverse of a prefix that comes before\
    \ the palindromic suffix.\n        String prefix = new StringBuilder(string.substring(0,\
    \ string.length() - suffix.length())).reverse().toString();\n        return string\
    \ + prefix;", "        // Find the longest postfix of supplied string that is\
    \ a palindrome.\n        int length = string.length();\n        int i = 0;\n \
    \       while (i < length) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        String prefix = string.substring(0,\
    \ i);\n        String reverse = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reverse;", "        int n = string.length();\n      \
    \  int[] z = new int[n];\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\n\
    \            if (i <= r)\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\n\
    \                ++z[i];\n            if (i + z[i] - 1 > r) {\n              \
    \  l = i;\n                r = i + z[i] - 1;\n            }\n        }\n     \
    \   int max = 0;\n        for (int i = 1; i < n; ++i) {\n            if (z[i]\
    \ == n - i && i > max)\n                max = i;\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int i = n - max - 1; i >= 0; --i)\n\
    \            sb.append(string.charAt(i));\n        return string + sb.toString();",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int length = string.length();\n        int palindromeLength = 0;\n    \
    \    for (int i = 0; i < length; i++) {\n            if (string.charAt(i) == string.charAt(length\
    \ - 1)) {\n                palindromeLength++;\n                length--;\n  \
    \          } else {\n                break;\n            }\n        }\n      \
    \  StringBuilder builder = new StringBuilder(string);\n        for (int i = palindromeLength;\
    \ i < string.length(); i++) {\n            builder.append(string.charAt(string.length()\
    \ - 1 - i));\n        }\n        return builder.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                j--;\n            }\n        }\n        return\
    \ sb.append(sb.reverse().substring(0, string.length() - i)).toString();", "  \
    \      if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        int i = 0;\n        while (i < n) {\n        \
    \    if (string.charAt(i) == rev.charAt(n - i - 1)) {\n                i++;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    sb.append(rev.substring(0, n - i));\n        return sb.toString();", "  \
    \      StringBuilder sb = new StringBuilder(string);\n        String rev = sb.reverse().toString();\n\
    \        String revPrefix = rev.substring(0, rev.length() - string.length());\n\
    \        return string + revPrefix;", "        if (string.length() == 0) {\n \
    \           return string;\n        }\n        int palindromeSuffixLength = getLongestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - palindromeSuffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        for (int i = 1, l = 0, r = 0; i < n; ++i)\
    \ {\n            if (i <= r)\n                z[i] = Math.min(r - i + 1, z[i -\
    \ l]);\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i]))\n                ++z[i];\n            if (i + z[i] - 1 > r) {\n   \
    \             l = i;\n                r = i + z[i] - 1;\n            }\n     \
    \   }\n        int longestPalindromeSuffix = 0;\n        for (int i = 1; i < n;\
    \ ++i) {\n            if (i + z[i] == n) {\n                longestPalindromeSuffix\
    \ = i;\n                break;\n            }\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int i = longestPalindromeSuffix; i <\
    \ n; ++i) {\n            sb.append(string.charAt(i));\n        }\n        sb.reverse();\n\
    \        sb.append(string);\n        return sb.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int length = string.length();\n   \
    \     for (int i = length - 1; i >= 0; i--) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                sb.append(reverse(string.substring(0, i)));\n           \
    \     break;\n            }\n        }\n        return sb.toString();", "    \
    \    StringBuilder sb = new StringBuilder(string);\n        String reverse = sb.reverse().toString();\n\
    \        String result = string + reverse.substring(reverse.indexOf(string) +\
    \ string.length());\n        return result;", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        String suffix = string.substring(i);\n\
    \        String prefix = string.substring(0, i);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return prefix + makePalindrome(suffix)\
    \ + reversedPrefix;", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;", "        if (string.length() == 0)\
    \ {\n            return string;\n        }\n        int suffixLength = longestPalindromicSuffix(string);\n\
    \        String prefix = string.substring(0, string.length() - suffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int longestPalindromeSuffix =\
    \ 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffix = i;\n            }\n        }\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffix);\n\
    \        return string + new StringBuilder(prefix).reverse().toString();", " \
    \       // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int length = string.length();\n        int longestPalindromeLength =\
    \ 0;\n        for (int i = 0; i < length; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeLength = length - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        String\
    \ prefix = string.substring(0, length - longestPalindromeLength);\n        String\
    \ reversePrefix = new StringBuilder(prefix).reverse().toString();\n        return\
    \ string + reversePrefix;", "        int n = string.length();\n        int i =\
    \ 0;\n        int j = n - 1;\n        while (i < j) {\n            if (string.charAt(i)\
    \ != string.charAt(j)) {\n                break;\n            }\n            i++;\n\
    \            j--;\n        }\n        if (i >= j) {\n            return string;\n\
    \        }\n        String prefix = string.substring(0, i);\n        String suffix\
    \ = string.substring(i);\n        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return suffix + reversedPrefix + suffix;", "        StringBuilder builder\
    \ = new StringBuilder(string);\n        int i = string.length() - 1;\n       \
    \ while (i >= 0) {\n            if (isPalindrome(string.substring(i))) {\n   \
    \             break;\n            }\n            i--;\n        }\n        builder.append(builder.substring(0,\
    \ i).reverse());\n        return builder.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        StringBuilder sb2 = new StringBuilder(string);\n\
    \        sb2.reverse();\n        int n = string.length();\n        int i = 0;\n\
    \        while (i < n) {\n            if (sb.substring(i).equals(sb2.substring(0,\
    \ n - i))) {\n                break;\n            }\n            i++;\n      \
    \  }\n        return sb.append(sb2.substring(n - i)).toString();", "        int\
    \ n = string.length();\n        int i = n - 1;\n        while (i >= 0) {\n   \
    \         if (isPalindrome(string.substring(i))) {\n                break;\n \
    \           }\n            i--;\n        }\n        String prefix = string.substring(0,\
    \ i);\n        StringBuilder sb = new StringBuilder(prefix);\n        sb.reverse();\n\
    \        return string + sb.toString();", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int longestPalindromeSuffix =\
    \ longestPalindromeSuffix(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffix);\n        return string + reverse(prefix);",
  "        int n = string.length();\n        int i = 0;\n        int j = n - 1;\n\
    \        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i += 1;\n            j\
    \ -= 1;\n        }\n        if (i >= j) {\n            return string;\n      \
    \  }\n        StringBuilder sb = new StringBuilder();\n        sb.append(string.substring(0,\
    \ i));\n        sb.append(makePalindrome(string.substring(i, j + 1)));\n     \
    \   sb.append(string.substring(i, j + 1));\n        return sb.toString();", " \
    \       // Find the longest palindromic suffix.\n        int longestPalindromicSuffix\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromicSuffix = i;\n                break;\n \
    \           }\n        }\n        // Append to the end of the string reverse of\
    \ a string prefix that comes before the palindromic suffix.\n        StringBuilder\
    \ result = new StringBuilder(string);\n        for (int i = longestPalindromicSuffix\
    \ - 1; i >= 0; i--) {\n            result.append(string.charAt(i));\n        }\n\
    \        return result.toString();", "        if (string.length() == 0) {\n  \
    \          return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = string.length() - 1; i >= 0; i--) {\n           \
    \ if (isPalindrome(string.substring(i))) {\n                longestPalindromeSuffixLength\
    \ = string.length() - i;\n                break;\n            }\n        }\n \
    \       String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        StringBuilder sb = new StringBuilder(string);\n        sb.append(new\
    \ StringBuilder(prefix).reverse());\n        return sb.toString();", "       \
    \ // >>> makePalindrome((\"\"))\n        // (\"\")\n        // >>> makePalindrome((\"\
    cat\"))\n        // (\"catac\")\n        // >>> makePalindrome((\"cata\"))\n \
    \       // (\"catac\")\n        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        // >>> makePalindrome((\"\"))\n        // (\"\"\
    )\n        // >>> makePalindrome((\"cat\"))\n        // (\"catac\")\n        //\
    \ >>> makePalindrome((\"cata\"))\n        // (\"catac\")\n        int suffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (string.charAt(i)\
    \ == string.charAt(string.length() - 1 - i)) {\n                suffixLength++;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    // >>> makePalindrome((\"\"))\n        // (\"\")\n        // >>> makePalindrome((\"\
    cat\"))\n        // (\"catac\")\n        // >>> makePalindrome((\"cata\"))\n \
    \       // (\"catac\")\n        String prefix = string.substring(0, string.length()\
    \ - suffixLength);\n        StringBuilder sb = new StringBuilder(prefix);\n  \
    \      sb.reverse();\n        return string + sb.toString();", "        // Find\
    \ the longest palindromic suffix.\n        int suffixLength = 0;\n        for\
    \ (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append reverse of the prefix to the end\
    \ of the string.\n        return string + new StringBuilder(string.substring(0,\
    \ string.length() - suffixLength)).reverse().toString();", "        int i = 0;\n\
    \        int j = string.length() - 1;\n        while (i < j) {\n            if\
    \ (string.charAt(i) != string.charAt(j)) {\n                break;\n         \
    \   }\n            i++;\n            j--;\n        }\n        StringBuilder stringBuilder\
    \ = new StringBuilder(string.substring(i));\n        stringBuilder.reverse();\n\
    \        return string.substring(0, i) + stringBuilder.toString() + string.substring(i);",
  "        int length = string.length();\n        if (length == 0) {\n           \
    \ return string;\n        }\n        int longestPalindromeEnd = 0;\n        for\
    \ (int i = 0; i < length; i++) {\n            if (isPalindrome(string, i)) {\n\
    \                longestPalindromeEnd = i;\n            }\n        }\n       \
    \ StringBuilder builder = new StringBuilder(string);\n        for (int i = 0;\
    \ i < length - longestPalindromeEnd - 1; i++) {\n            builder.append(string.charAt(length\
    \ - i - 1));\n        }\n        return builder.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int palindromeLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                palindromeLength = string.length() - i;\n               \
    \ break;\n            }\n        }\n        return string + reverse(string.substring(0,\
    \ string.length() - palindromeLength));", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder builder\
    \ = new StringBuilder();\n        for (int i = n - max - 1; i >= 0; i--) {\n \
    \           builder.append(string.charAt(i));\n        }\n        builder.append(string);\n\
    \        return builder.toString();", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int[]\
    \ dp = new int[length];\n        int i = 0;\n        int j = 1;\n        while\
    \ (j < length) {\n            if (string.charAt(i) == string.charAt(j)) {\n  \
    \              dp[j] = i + 1;\n                i++;\n                j++;\n  \
    \          } else {\n                if (i == 0) {\n                    dp[j]\
    \ = 0;\n                    j++;\n                } else {\n                 \
    \   i = dp[i - 1];\n                }\n            }\n        }\n        int palindromeLength\
    \ = dp[length - 1];\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int k = length - palindromeLength - 1; k >= 0; k--) {\n        \
    \    builder.append(string.charAt(k));\n        }\n        return builder.toString();",
  "        // Find the longest palindromic suffix of the string.\n        int suffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        String\
    \ prefix = string.substring(0, string.length() - suffixLength);\n        return\
    \ string + reverse(prefix);", "        StringBuilder builder = new StringBuilder(string);\n\
    \        int length = string.length();\n        int i = 0;\n        while (i <\
    \ length) {\n            if (isPalindrome(string.substring(i))) {\n          \
    \      break;\n            }\n            i++;\n        }\n        builder.append(builder.reverse().substring(length\
    \ - i));\n        return builder.toString();", "        // Find the longest postfix\
    \ of supplied string that is a palindrome.\n        int palindromeEnd = string.length();\n\
    \        for (int i = 0; i < string.length(); i++) {\n            if (string.charAt(i)\
    \ == string.charAt(palindromeEnd - 1)) {\n                palindromeEnd--;\n \
    \           } else {\n                palindromeEnd = string.length();\n     \
    \       }\n        }\n        // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n        StringBuilder\
    \ builder = new StringBuilder(string);\n        for (int i = 0; i < string.length()\
    \ - palindromeEnd; i++) {\n            builder.append(string.charAt(i));\n   \
    \     }\n        return builder.toString();", "        StringBuilder builder =\
    \ new StringBuilder(string);\n        int length = string.length();\n        for\
    \ (int i = length - 1; i >= 0; i--) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                builder.append(string.substring(0, i));\n               \
    \ break;\n            }\n        }\n        return builder.toString();", "   \
    \     StringBuilder sb = new StringBuilder(string);\n        StringBuilder sb2\
    \ = new StringBuilder(string);\n        int i = 0;\n        while (i < sb.length())\
    \ {\n            if (sb.substring(i).equals(sb2.reverse().substring(0, sb.length()\
    \ - i))) {\n                break;\n            }\n            i++;\n        }\n\
    \        return sb.append(sb2.reverse().substring(i)).toString();", "        //\
    \ Find the longest postfix of supplied string that is a palindrome.\n        //\
    \ >>> findLongestPalindromicSuffix(\"\")\n        // (\"\")\n        // >>> findLongestPalindromicSuffix(\"\
    cat\")\n        // (\"\")\n        // >>> findLongestPalindromicSuffix(\"cata\"\
    )\n        // (\"a\")\n        // >>> findLongestPalindromicSuffix(\"catac\")\n\
    \        // (\"catac\")\n        // >>> findLongestPalindromicSuffix(\"cataca\"\
    )\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix(\"catacat\"\
    )\n        // (\"catacat\")\n        // >>> findLongestPalindromicSuffix(\"catacata\"\
    )\n        // (\"atacata\")\n        // >>> findLongestPalindromicSuffix(\"catacatac\"\
    )\n        // (\"catacatac\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacataca\")\n        // (\"atacataca\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacat\")\n        // (\"catacatacat\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacata\")\n        // (\"atacatacata\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatac\")\n        // (\"catacatacatac\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacataca\")\n        // (\"atacatacataca\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacat\")\n        // (\"catacatacatacat\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacata\")\n        // (\"atacatacatacata\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacatac\")\n        // (\"catacatacatacatac\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacataca\")\n        // (\"atac", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ suffixLength = 0;\n        for (int i = 0; i < length; i++) {\n            if\
    \ (isPalindrome(string.substring(i))) {\n                suffixLength = length\
    \ - i;\n                break;\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder(string);\n        for (int i = 0; i < length - suffixLength;\
    \ i++) {\n            builder.append(string.charAt(length - i - 1));\n       \
    \ }\n        return builder.toString();", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ i = length - 1;\n        while (i >= 0) {\n            int j = 0;\n        \
    \    while (j < length - i) {\n                if (string.charAt(i + j) != string.charAt(j))\
    \ {\n                    break;\n                }\n                j++;\n   \
    \         }\n            if (j == length - i) {\n                break;\n    \
    \        }\n            i--;\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int j = i - 1; j >= 0; j--) {\n            builder.append(string.charAt(j));\n\
    \        }\n        return builder.toString();", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        StringBuilder sb = new\
    \ StringBuilder(string);\n        for (int k = i; k >= 0; k--) {\n           \
    \ sb.append(string.charAt(k));\n        }\n        return sb.toString();", " \
    \       StringBuilder sb = new StringBuilder(string);\n        StringBuilder rev\
    \ = new StringBuilder(string).reverse();\n        int i = 0;\n        while (i\
    \ < sb.length() && sb.substring(i).compareTo(rev.substring(0, sb.length() - i))\
    \ != 0) {\n            i++;\n        }\n        return sb.append(rev.substring(i)).toString();",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int i = 0;\n        for (; i < string.length(); i++) {\n            if\
    \ (isPalindrome(string.substring(i))) {\n                break;\n            }\n\
    \        }\n        // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n        return string + new StringBuilder(string.substring(0,\
    \ i)).reverse().toString();", "        int n = string.length();\n        int[]\
    \ z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int longestPalindrome = 0;\n\
    \        for (int i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n   \
    \             longestPalindrome = z[i];\n                break;\n            }\n\
    \        }\n        StringBuilder sb = new StringBuilder();\n        for (int\
    \ i = 0; i < n - longestPalindrome; i++) {\n            sb.append(string.charAt(n\
    \ - 1 - i));\n        }\n        sb.append(string);\n        return sb.toString();",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int length = string.length();\n        int i = length - 1;\n        while\
    \ (i >= 0) {\n            if (isPalindrome(string.substring(i))) {\n         \
    \       break;\n            }\n            i--;\n        }\n        // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n        String prefix = string.substring(0, i);\n        StringBuilder\
    \ builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();", "        int n = string.length();\n    \
    \    int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1;\
    \ i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        sb.append(string.substring(max));\n        sb.reverse();\n\
    \        sb.append(string);\n        return sb.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        for (int i = 1, l = 0, r = 0; i < n; ++i)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                ++z[i];\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int longestPalindromeSuffix\
    \ = 0;\n        for (int i = 1; i < n; ++i) {\n            if (i + z[i] == n)\
    \ {\n                longestPalindromeSuffix = i;\n            }\n        }\n\
    \        StringBuilder sb = new StringBuilder();\n        for (int i = longestPalindromeSuffix;\
    \ i < n; ++i) {\n            sb.append(string.charAt(i));\n        }\n       \
    \ for (int i = 0; i < longestPalindromeSuffix; ++i) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int[] z\
    \ = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        for (int i = n - max - 1; i >= 0; i--) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        return string + sb.toString();",
  "        int n = string.length();\n        int i = 0;\n        int j = n - 1;\n\
    \        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i++;\n            j--;\n\
    \        }\n        if (i >= j) {\n            return string;\n        }\n   \
    \     StringBuilder builder = new StringBuilder(string);\n        for (int k =\
    \ i; k >= 0; k--) {\n            builder.append(string.charAt(k));\n        }\n\
    \        return builder.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        int i = 0;\n        while (i < n) {\n        \
    \    if (sb.substring(i).equals(rev.substring(0, n - i))) {\n                break;\n\
    \            }\n            i++;\n        }\n        return sb.append(rev.substring(n\
    \ - i)).toString();", "        int n = string.length();\n        int i = 0;\n\
    \        int j = n - 1;\n        while (i < j) {\n            if (string.charAt(i)\
    \ != string.charAt(j)) {\n                break;\n            }\n            i\
    \ += 1;\n            j -= 1;\n        }\n        if (i >= j) {\n            return\
    \ string;\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int k = i; k >= 0; k -= 1) {\n            builder.append(string.charAt(k));\n\
    \        }\n        return builder.toString();", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int[] z\
    \ = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int longestPalindromeSuffix\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i + z[i] == n)\
    \ {\n                longestPalindromeSuffix = i;\n            }\n        }\n\
    \        StringBuilder builder = new StringBuilder();\n        for (int i = longestPalindromeSuffix\
    \ - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n       \
    \ }\n        builder.append(string);\n        return builder.toString();", " \
    \       StringBuilder result = new StringBuilder(string);\n        StringBuilder\
    \ reverse = new StringBuilder(string).reverse();\n        int length = string.length();\n\
    \        for (int i = length; i >= 0; i--) {\n            if (string.substring(0,\
    \ i).equals(reverse.substring(length - i))) {\n                result.append(reverse.substring(0,\
    \ length - i));\n                break;\n            }\n        }\n        return\
    \ result.toString();", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int i = 0;\n        int j = string.length() - 1;\n\
    \        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i++;\n            j--;\n\
    \        }\n        if (i >= j) {\n            return string;\n        }\n   \
    \     String prefix = string.substring(0, i);\n        String suffix = string.substring(i);\n\
    \        return prefix + new StringBuilder(suffix).reverse().toString() + suffix;",
  "        StringBuilder sb = new StringBuilder(string);\n        int length = string.length();\n\
    \        for (int i = 0; i < length; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                sb.append(new StringBuilder(string.substring(0, i)).reverse());\n\
    \                break;\n            }\n        }\n        return sb.toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n  \
    \          }\n        }\n        StringBuilder sb = new StringBuilder();\n   \
    \     for (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    int n = string.length();\n        int[] z = new int[n];\n        for (int\
    \ i = 1, l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n              \
    \  z[i] = Math.min(r - i + 1, z[i - l]);\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i]))\n                ++z[i];\n            if (i + z[i]\
    \ - 1 > r)\n                l = i, r = i + z[i] - 1;\n        }\n        int max\
    \ = 0;\n        for (int i = 1; i < n; ++i)\n            if (i + z[i] == n)\n\
    \                max = Math.max(max, z[i]);\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = n - max - 1; i >= 0; --i)\n            sb.append(string.charAt(i));\n\
    \        sb.append(string);\n        return sb.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int maxLength = 0;\n\
    \        int maxIndex = 0;\n        for (int i = 0; i < string.length(); i++)\
    \ {\n            int length = 0;\n            int j = i;\n            int k =\
    \ string.length() - 1;\n            while (j >= 0 && k >= 0 && string.charAt(j)\
    \ == string.charAt(k)) {\n                length++;\n                j--;\n  \
    \              k--;\n            }\n            if (length > maxLength) {\n  \
    \              maxLength = length;\n                maxIndex = i;\n          \
    \  }\n        }\n        StringBuilder builder = new StringBuilder();\n      \
    \  for (int i = maxIndex - maxLength + 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();",
  "        StringBuilder builder = new StringBuilder(string);\n        int i = 0;\n\
    \        int j = string.length() - 1;\n        while (i < j) {\n            if\
    \ (string.charAt(i) == string.charAt(j)) {\n                i++;\n           \
    \     j--;\n            } else {\n                i = 0;\n                j--;\n\
    \            }\n        }\n        builder.append(builder.reverse().substring(string.length()\
    \ - i));\n        return builder.toString();", "        int n = string.length();\n\
    \        for (int i = n - 1; i >= 0; i--) {\n            if (isPalindrome(string,\
    \ i)) {\n                return string + reverse(string.substring(0, n - i - 1));\n\
    \            }\n        }\n        return string;", "        int length = string.length();\n\
    \        int[] z = new int[length];\n        int l = 0, r = 0;\n        for (int\
    \ i = 1; i < length; i++) {\n            if (i <= r) {\n                z[i] =\
    \ Math.min(r - i + 1, z[i - l]);\n            }\n            while (i + z[i] <\
    \ length && string.charAt(z[i]) == string.charAt(i + z[i])) {\n              \
    \  z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n             \
    \   l = i;\n                r = i + z[i] - 1;\n            }\n        }\n    \
    \    int max = 0;\n        for (int i = 1; i < length; i++) {\n            if\
    \ (z[i] == length - i && max < z[i]) {\n                max = z[i];\n        \
    \    }\n        }\n        StringBuilder builder = new StringBuilder();\n    \
    \    builder.append(string);\n        for (int i = length - max - 1; i >= 0; i--)\
    \ {\n            builder.append(string.charAt(i));\n        }\n        return\
    \ builder.toString();", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int maxPalindromeSuffixLength = 0;\n        for\
    \ (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                maxPalindromeSuffixLength = string.length() - i;\n      \
    \          break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - maxPalindromeSuffixLength);\n        StringBuilder sb = new\
    \ StringBuilder(prefix);\n        sb.reverse();\n        return string + sb.toString();",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int longestPalindromeSuffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   longestPalindromeSuffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        return\
    \ string + new StringBuilder(string.substring(0, string.length() - longestPalindromeSuffixLength)).reverse().toString();",
  "        // Find the longest palindromic suffix.\n        int length = string.length();\n\
    \        int[] suffix = new int[length];\n        suffix[0] = 0;\n        int\
    \ i = 1;\n        int j = 0;\n        while (i < length) {\n            if (string.charAt(i)\
    \ == string.charAt(j)) {\n                suffix[i] = j + 1;\n               \
    \ i++;\n                j++;\n            } else if (j > 0) {\n              \
    \  j = suffix[j - 1];\n            } else {\n                suffix[i] = 0;\n\
    \                i++;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(new\
    \ StringBuilder(string.substring(0, length - suffix[length - 1])).reverse());\n\
    \        return builder.toString();", "        int length = string.length();\n\
    \        int i = 0;\n        int j = length - 1;\n        while (i < j) {\n  \
    \          if (string.charAt(i) != string.charAt(j)) {\n                break;\n\
    \            }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        StringBuilder builder =\
    \ new StringBuilder(string);\n        for (int k = j - 1; k >= i; k--) {\n   \
    \         builder.append(string.charAt(k));\n        }\n        return builder.toString();",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversePrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversePrefix;",
  "        int n = string.length();\n        int[] p = new int[n];\n        for (int\
    \ i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        for (int i =\
    \ 1; i < n; i++) {\n            int j = p[i - 1];\n            while (j > 0 &&\
    \ string.charAt(i) != string.charAt(j)) {\n                j = p[j - 1];\n   \
    \         }\n            if (string.charAt(i) == string.charAt(j)) {\n       \
    \         j++;\n            }\n            p[i] = j;\n        }\n        int suffix\
    \ = p[n - 1];\n        String prefix = string.substring(0, suffix);\n        StringBuilder\
    \ sb = new StringBuilder(string);\n        sb.append(new StringBuilder(prefix).reverse());\n\
    \        return sb.toString();", "        int n = string.length();\n        int[]\
    \ z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = z[i];\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    StringBuilder builder = new StringBuilder(string);\n        String reverse\
    \ = builder.reverse().toString();\n        StringBuilder result = new StringBuilder();\n\
    \        for (int i = 0; i < string.length(); i++) {\n            String suffix\
    \ = string.substring(i);\n            String prefix = reverse.substring(0, reverse.length()\
    \ - i);\n            if (suffix.equals(prefix)) {\n                result.append(string);\n\
    \                result.append(reverse.substring(reverse.length() - i));\n   \
    \             return result.toString();\n            }\n        }\n        return\
    \ \"\";", "        // Find the longest postfix that is a palindrome.\n       \
    \ int longestPalindromeLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindromeLength = 0;\n            for (int j = 0; j\
    \ <= i; j++) {\n                if (string.charAt(i - j) == string.charAt(i +\
    \ j)) {\n                    palindromeLength += 1;\n                } else {\n\
    \                    break;\n                }\n            }\n            if\
    \ (palindromeLength > longestPalindromeLength) {\n                longestPalindromeLength\
    \ = palindromeLength;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        StringBuilder builder = new StringBuilder(string);\n        for (int\
    \ i = 0; i < string.length() - longestPalindromeLength; i++) {\n            builder.append(string.charAt(string.length()\
    \ - i - 1));\n        }\n        return builder.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int length = string.length();\n\
    \        int longestPalindromeSuffixLength = 0;\n        for (int i = 0; i < length;\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   longestPalindromeSuffixLength = length - i;\n                break;\n    \
    \        }\n        }\n        String prefix = string.substring(0, length - longestPalindromeSuffixLength);\n\
    \        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;", "        if (string.length() == 0)\
    \ {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        return string + reverse(prefix);",
  "        int n = string.length();\n        int i = 0;\n        int j = n - 1;\n\
    \        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i++;\n            j--;\n\
    \        }\n        StringBuilder builder = new StringBuilder(string);\n     \
    \   for (int k = i - 1; k >= 0; k--) {\n            builder.append(string.charAt(k));\n\
    \        }\n        return builder.toString();", "        StringBuilder sb = new\
    \ StringBuilder(string);\n        StringBuilder rev = new StringBuilder(string).reverse();\n\
    \        int n = sb.length();\n        int m = rev.length();\n        int[][]\
    \ dp = new int[n + 1][m + 1];\n        for (int i = 1; i <= n; i++) {\n      \
    \      for (int j = 1; j <= m; j++) {\n                if (sb.charAt(i - 1) ==\
    \ rev.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n\
    \                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j],\
    \ dp[i][j - 1]);\n                }\n            }\n        }\n        int i =\
    \ n;\n        int j = m;\n        StringBuilder prefix = new StringBuilder();\n\
    \        while (i > 0 && j > 0) {\n            if (sb.charAt(i - 1) == rev.charAt(j\
    \ - 1)) {\n                prefix.append(sb.charAt(i - 1));\n                i--;\n\
    \                j--;\n            } else if (dp[i - 1][j] > dp[i][j - 1]) {\n\
    \                i--;\n            } else {\n                j--;\n          \
    \  }\n        }\n        return sb.append(prefix.reverse()).toString();", "  \
    \      int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int longestPalindrome = 0;\n        for (int i = 1; i < n;\
    \ i++) {\n            if (i + z[i] == n) {\n                longestPalindrome\
    \ = Math.max(longestPalindrome, z[i]);\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder();\n        for (int i = 0; i < n - longestPalindrome;\
    \ i++) {\n            builder.append(string.charAt(i));\n        }\n        for\
    \ (int i = n - 1; i >= longestPalindrome; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();", "        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return string + new StringBuilder(string.substring(0, string.length()\
    \ - longestPalindromeSuffixLength)).reverse().toString();", "        // Find the\
    \ longest postfix of supplied string that is a palindrome.\n        int i = string.length();\n\
    \        while (i > 0) {\n            String postfix = string.substring(string.length()\
    \ - i);\n            if (isPalindrome(postfix)) {\n                break;\n  \
    \          }\n            i--;\n        }\n        // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        String prefix = string.substring(0, string.length() - i);\n        String\
    \ reversePrefix = new StringBuilder(prefix).reverse().toString();\n        return\
    \ string + reversePrefix;", "        String reverse = new StringBuilder(string).reverse().toString();\n\
    \        String longestPalindrome = \"\";\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (string.substring(i).equals(reverse.substring(0, string.length()\
    \ - i))) {\n                longestPalindrome = string.substring(i);\n       \
    \         break;\n            }\n        }\n        return string + reverse.substring(longestPalindrome.length());",
  "        int longestPalindromeSuffix = longestPalindromeSuffix(string);\n      \
    \  String prefix = string.substring(0, string.length() - longestPalindromeSuffix);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int[] z = zFunction(string);\n\
    \        int max = 0;\n        for (int i = 0; i < z.length; i++) {\n        \
    \    if (z[i] == i + 1) {\n                max = i + 1;\n            }\n     \
    \   }\n        String prefix = string.substring(0, string.length() - max);\n \
    \       StringBuilder sb = new StringBuilder(prefix);\n        sb.reverse();\n\
    \        return string + sb.toString();", "        int length = string.length();\n\
    \        int i = 0;\n        while (i < length) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                break;\n            }\n            i++;\n        }\n    \
    \    String prefix = string.substring(0, i);\n        StringBuilder builder =\
    \ new StringBuilder(string);\n        builder.append(new StringBuilder(prefix).reverse());\n\
    \        return builder.toString();", "        // Find the longest postfix that\
    \ is a palindrome.\n        int longestPalindromeLength = 0;\n        for (int\
    \ i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeLength = string.length() - i;\n        \
    \        break;\n            }\n        }\n        // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeLength);\n\
    \        StringBuilder sb = new StringBuilder(string);\n        sb.append(new\
    \ StringBuilder(prefix).reverse());\n        return sb.toString();", "       \
    \ int length = string.length();\n        int[] z = new int[length];\n        int\
    \ l = 0, r = 0;\n        for (int i = 1; i < length; i++) {\n            if (i\
    \ <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n           \
    \ }\n            while (i + z[i] < length && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 0; i < length;\
    \ i++) {\n            if (z[i] == length - i) {\n                max = length\
    \ - i;\n                break;\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder();\n        for (int i = 0; i < length - max; i++)\
    \ {\n            builder.append(string.charAt(i));\n        }\n        builder.append(string);\n\
    \        return builder.toString();", "        int n = string.length();\n    \
    \    int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1;\
    \ i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        sb.append(string.substring(max));\n        sb.reverse();\n\
    \        sb.append(string);\n        return sb.toString();", "        int n =\
    \ string.length();\n        if (n == 0) {\n            return string;\n      \
    \  }\n        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n  \
    \          if (string.charAt(i) != string.charAt(j)) {\n                break;\n\
    \            }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        StringBuilder builder =\
    \ new StringBuilder();\n        builder.append(string.substring(0, i));\n    \
    \    builder.append(new StringBuilder(string.substring(i)).reverse());\n     \
    \   return builder.toString();", "        int length = string.length();\n    \
    \    if (length == 0) {\n            return string;\n        }\n        int i\
    \ = length - 1;\n        while (i >= 0) {\n            if (isPalindrome(string,\
    \ i)) {\n                break;\n            }\n            i--;\n        }\n\
    \        String prefix = string.substring(0, i + 1);\n        StringBuilder builder\
    \ = new StringBuilder(prefix);\n        builder.reverse();\n        return string\
    \ + builder.toString();", "        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String suffix = string.substring(string.length() - longestPalindromeSuffixLength);\n\
    \        return string + reverse(prefix);", "        int n = string.length();\n\
    \        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n      \
    \      p[i] = 0;\n        }\n        int center = 0;\n        int right = 0;\n\
    \        for (int i = 1; i < n; i++) {\n            int mirror = 2 * center -\
    \ i;\n            if (right > i) {\n                p[i] = Math.min(right - i,\
    \ p[mirror]);\n            }\n            while (i + 1 + p[i] < n && i - 1 - p[i]\
    \ >= 0 && string.charAt(i + 1 + p[i]) == string.charAt(i - 1 - p[i])) {\n    \
    \            p[i]++;\n            }\n            if (i + p[i] > right) {\n   \
    \             center = i;\n                right = i + p[i];\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n    \
    \        if (p[i] > p[max]) {\n                max = i;\n            }\n     \
    \   }\n        StringBuilder sb = new StringBuilder();\n        for (int i = max\
    \ - p[max]; i < n; i++) {\n            sb.append(string.charAt(i));\n        }\n\
    \        for (int i = max - p[max] - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();", "        int n = string.length();\n\
    \        for (int i = n - 1; i >= 0; i--) {\n            if (isPalindrome(string,\
    \ i)) {\n                return string + reverse(string.substring(0, n - i - 1));\n\
    \            }\n        }\n        return string;", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String suffix = string.substring(string.length()\
    \ - longestPalindromeSuffixLength);\n        return string + reverse(prefix);",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (z[i] == i) {\n                max = i;\n            }\n        }\n\
    \        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <\
    \ n - max; i++) {\n            sb.append(string.charAt(i));\n        }\n     \
    \   return string + sb.reverse().toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (z[i] == n - i) {\n                max\
    \ = z[i];\n                break;\n            }\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int i = 0; i < n - max; i++) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        sb.reverse();\n   \
    \     sb.append(string);\n        return sb.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int maxPalindromeLength = 0;\n\
    \        int maxPalindromeStart = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindromeLength = 0;\n            int palindromeStart\
    \ = i;\n            int j = i;\n            int k = i;\n            while (j >=\
    \ 0 && k < string.length() && string.charAt(j) == string.charAt(k)) {\n      \
    \          palindromeLength = k - j + 1;\n                palindromeStart = j;\n\
    \                j--;\n                k++;\n            }\n            if (palindromeLength\
    \ > maxPalindromeLength) {\n                maxPalindromeLength = palindromeLength;\n\
    \                maxPalindromeStart = palindromeStart;\n            }\n      \
    \      palindromeLength = 0;\n            palindromeStart = i;\n            j\
    \ = i;\n            k = i + 1;\n            while (j >= 0 && k < string.length()\
    \ && string.charAt(j) == string.charAt(k)) {\n                palindromeLength\
    \ = k - j + 1;\n                palindromeStart = j;\n                j--;\n \
    \               k++;\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n               \
    \ maxPalindromeStart = palindromeStart;\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder();\n        builder.append(string);\n        builder.append(new\
    \ StringBuilder(string.substring(0, maxPalindromeStart)).reverse());\n       \
    \ return builder.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();", "        // Find the longest postfix\
    \ of supplied string that is a palindrome.\n        int palindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                palindromeSuffixLength = string.length() - i;\n         \
    \       break;\n            }\n        }\n        // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return string + reverse(string.substring(0, string.length() - palindromeSuffixLength));",
  "        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversePrefix = reverse(prefix);\n        return string + reversePrefix;",
  "        StringBuilder sb = new StringBuilder(string);\n        String reverse =\
    \ sb.reverse().toString();\n        StringBuilder result = new StringBuilder(string);\n\
    \        int index = string.length();\n        while (index > 0) {\n         \
    \   if (string.substring(0, index).equals(reverse.substring(string.length() -\
    \ index))) {\n                break;\n            }\n            index--;\n  \
    \      }\n        result.append(reverse.substring(index));\n        return result.toString();",
  "        StringBuilder sb = new StringBuilder(string);\n        StringBuilder rev\
    \ = new StringBuilder(string).reverse();\n        int n = string.length();\n \
    \       int i = 0;\n        while (i < n) {\n            if (sb.substring(i).equals(rev.substring(0,\
    \ n - i))) {\n                break;\n            }\n            i++;\n      \
    \  }\n        return sb.append(rev.substring(n - i)).toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                j--;\n            }\n        }\n        return\
    \ sb.append(sb.reverse().substring(0, string.length() - i)).toString();", "  \
    \      int length = string.length();\n        int maxPalindromeLength = 0;\n \
    \       for (int i = 0; i < length; i++) {\n            if (isPalindrome(string,\
    \ i, length - 1)) {\n                maxPalindromeLength = length - i;\n     \
    \           break;\n            }\n        }\n        StringBuilder result = new\
    \ StringBuilder(string);\n        for (int i = length - maxPalindromeLength -\
    \ 1; i >= 0; i--) {\n            result.append(string.charAt(i));\n        }\n\
    \        return result.toString();", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ longestPalindromeEnd = 0;\n        for (int i = 0; i < length; i++) {\n    \
    \        if (isPalindrome(string, i)) {\n                longestPalindromeEnd\
    \ = i;\n            }\n        }\n        String prefix = string.substring(0,\
    \ length - longestPalindromeEnd);\n        return string + reverse(prefix);",
  "        StringBuilder sb = new StringBuilder(string);\n        StringBuilder sb2\
    \ = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (sb.charAt(i) == sb.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          sb.deleteCharAt(j);\n                j--;\n            }\n        }\n\
    \        sb2.delete(0, i);\n        sb.append(sb2.reverse());\n        return\
    \ sb.toString();", "        int n = string.length();\n        if (n == 0) {\n\
    \            return string;\n        }\n        int[] z = new int[n];\n      \
    \  int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i\
    \ <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n           \
    \ }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++)\
    \ {\n            if (i + z[i] == n) {\n                max = z[i];\n         \
    \   }\n        }\n        StringBuilder sb = new StringBuilder();\n        for\
    \ (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    StringBuilder result = new StringBuilder(string);\n        int i = 0;\n \
    \       int j = string.length() - 1;\n        while (i < j) {\n            if\
    \ (string.charAt(i) == string.charAt(j)) {\n                i++;\n           \
    \     j--;\n            } else {\n                i = 0;\n                j--;\n\
    \            }\n        }\n        result.append(result.substring(0, j + 1).reverse());\n\
    \        return result.toString();", "        int n = string.length();\n     \
    \   if (n == 0) {\n            return string;\n        }\n        int[] z = new\
    \ int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n\
    \            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++)\
    \ {\n            if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n\
    \            }\n        }\n        return string + new StringBuilder(string.substring(0,\
    \ n - max)).reverse().toString();", "        int n = string.length();\n      \
    \  int[] z = new int[n];\n        // z[i] is the length of the longest substring\
    \ of string that begins at i and is also a prefix of string.\n        // z[i]\
    \ = |lcp(string[i..n], string[0..n])|\n        // z[i] = max {k : k <= n - i and\
    \ string[i..i + k - 1] = string[0..k - 1]}\n        // z[i] = 0 if there is no\
    \ such k\n        for (int i = 1, l = 0, r = 0; i < n; i++) {\n            if\
    \ (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n        \
    \    }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        // Find the longest palindromic suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string that is also a suffix of string.\n\
    \        // It is the longest prefix of string", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        for (int i = 1, l = 0, r = 0; i < n; ++i)\
    \ {\n            if (i <= r)\n                z[i] = Math.min(r - i + 1, z[i -\
    \ l]);\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i]))\n                ++z[i];\n            if (i + z[i] - 1 > r) {\n   \
    \             l = i;\n                r = i + z[i] - 1;\n            }\n     \
    \   }\n        int max = 0;\n        for (int i = 1; i < n; ++i) {\n         \
    \   if (i + z[i] == n) {\n                max = i;\n                break;\n \
    \           }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string);\n        for (int i = max - 1; i >= 0; --i) {\n\
    \            builder.append(string.charAt(i));\n        }\n        return builder.toString();",
  "        // Find the longest palindromic suffix of the string.\n        int suffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append the reverse of the string prefix\
    \ to the end of the string.\n        return string + new StringBuilder(string.substring(0,\
    \ string.length() - suffixLength)).reverse().toString();", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int i =\
    \ n - 1;\n        while (i >= 0) {\n            if (isPalindrome(string, i)) {\n\
    \                break;\n            }\n            i--;\n        }\n        String\
    \ prefix = string.substring(0, i + 1);\n        String suffix = string.substring(i\
    \ + 1);\n        return string + reverse(prefix);", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (z[i] == n - i) {\n                max\
    \ = z[i];\n                break;\n            }\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int i = 0; i < n - max; i++) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        sb.reverse();\n   \
    \     sb.append(string);\n        return sb.toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        for (int i = n - max - 1; i >= 0; i--) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        sb.append(string);\n\
    \        return sb.toString();", "        if (string.length() == 0) {\n      \
    \      return string;\n        }\n        int maxPalindromeLength = 0;\n     \
    \   int maxPalindromeIndex = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindromeLength = 0;\n            int palindromeIndex\
    \ = 0;\n            for (int j = 0; j < string.length() - i; j++) {\n        \
    \        if (string.charAt(i + j) == string.charAt(string.length() - 1 - j)) {\n\
    \                    palindromeLength++;\n                    palindromeIndex\
    \ = i;\n                } else {\n                    break;\n               \
    \ }\n            }\n            if (palindromeLength > maxPalindromeLength) {\n\
    \                maxPalindromeLength = palindromeLength;\n                maxPalindromeIndex\
    \ = palindromeIndex;\n            }\n        }\n        StringBuilder result =\
    \ new StringBuilder(string);\n        for (int i = 0; i < string.length() - maxPalindromeLength;\
    \ i++) {\n            result.append(string.charAt(maxPalindromeIndex + i));\n\
    \        }\n        return result.toString();", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ longestPalindromeSuffixLength = 0;\n        for (int i = 0; i < length; i++)\
    \ {\n            if (isPalindrome(string.substring(i))) {\n                longestPalindromeSuffixLength\
    \ = length - i;\n                break;\n            }\n        }\n        String\
    \ prefix = string.substring(0, length - longestPalindromeSuffixLength);\n    \
    \    String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        for (int i = 0; i < n; i++) {\n            if\
    \ (sb.substring(i).equals(rev.substring(0, n - i))) {\n                return\
    \ sb.append(rev.substring(n - i)).toString();\n            }\n        }\n    \
    \    return \"\";", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        StringBuilder sb = new StringBuilder(string);\n\
    \        String reversed = sb.reverse().toString();\n        String result = string\
    \ + reversed.substring(reversed.indexOf(string) + string.length());\n        return\
    \ result;", "        int n = string.length();\n        StringBuilder builder =\
    \ new StringBuilder(string);\n        for (int i = 0; i < n; i++) {\n        \
    \    if (isPalindrome(string.substring(i))) {\n                builder.append(new\
    \ StringBuilder(string.substring(0, i)).reverse());\n                return builder.toString();\n\
    \            }\n        }\n        return builder.toString();", "        // Find\
    \ the longest postfix of supplied string that is a palindrome.\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return string + new StringBuilder(string.substring(0, string.length()\
    \ - longestPalindromeSuffixLength)).reverse().toString();", "        // Find the\
    \ longest postfix of supplied string that is a palindrome.\n        int length\
    \ = string.length();\n        int i = length - 1;\n        while (i >= 0) {\n\
    \            if (isPalindrome(string.substring(i))) {\n                break;\n\
    \            }\n            i -= 1;\n        }\n        // Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        String prefix = string.substring(0, i);\n        String reverse = new\
    \ StringBuilder(prefix).reverse().toString();\n        return string + reverse;",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int palindromeLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   palindromeLength = string.length() - i;\n                break;\n        \
    \    }\n        }\n        String prefix = string.substring(0, string.length()\
    \ - palindromeLength);\n        StringBuilder sb = new StringBuilder(prefix);\n\
    \        return string + sb.reverse().toString();", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int[] z\
    \ = new int[n];\n        z[0] = n;\n        int l = 0;\n        int r = 0;\n \
    \       for (int i = 1; i < n; i++) {\n            if (i > r) {\n            \
    \    l = r = i;\n                while (r < n && string.charAt(r - l) == string.charAt(r))\
    \ {\n                    r++;\n                }\n                z[i] = r - l;\n\
    \                r--;\n            } else {\n                int k = i - l;\n\
    \                if (z[k] < r - i + 1) {\n                    z[i] = z[k];\n \
    \               } else {\n                    l = i;\n                    while\
    \ (r < n && string.charAt(r - l) == string.charAt(r)) {\n                    \
    \    r++;\n                    }\n                    z[i] = r - l;\n        \
    \            r--;\n                }\n            }\n        }\n        int max\
    \ = 0;\n        int maxIndex = 0;\n        for (int i = 0; i < n; i++) {\n   \
    \         if (z[i] > max) {\n                max = z[i];\n                maxIndex\
    \ = i;\n            }\n        }\n        String prefix = string.substring(0,\
    \ maxIndex - max);\n        StringBuilder sb = new StringBuilder(prefix);\n  \
    \      sb.reverse();\n        return string + sb.toString();", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int palindromeEnd =\
    \ string.length();\n        while (palindromeEnd > 0) {\n            if (isPalindrome(string.substring(0,\
    \ palindromeEnd))) {\n                break;\n            }\n            palindromeEnd--;\n\
    \        }\n        StringBuilder builder = new StringBuilder(string);\n     \
    \   builder.append(reverse(string.substring(0, string.length() - palindromeEnd)));\n\
    \        return builder.toString();", "        int n = string.length();\n    \
    \    int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1;\
    \ i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (z[i] == n - i && i > max) {\n        \
    \        max = i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < n - max; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return string + sb.reverse().toString();", "        // Find\
    \ the longest palindromic suffix.\n        int suffixLength = 0;\n        for\
    \ (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        String\
    \ prefix = string.substring(0, string.length() - suffixLength);\n        String\
    \ reversePrefix = new StringBuilder(prefix).reverse().toString();\n        return\
    \ string + reversePrefix;", "        int n = string.length();\n        int[] z\
    \ = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        return string + new\
    \ StringBuilder(string.substring(0, n - max)).reverse().toString();", "      \
    \  // Find the longest palindromic suffix.\n        int suffixLength = 0;\n  \
    \      for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                suffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        String\
    \ prefix = string.substring(0, string.length() - suffixLength);\n        return\
    \ string + reverse(prefix);", "        if (string.length() == 0) {\n         \
    \   return string;\n        }\n        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                break;\n\
    \            }\n        }\n        if (i == j) {\n            return string;\n\
    \        }\n        if (i == 0) {\n            sb.append(sb.reverse());\n    \
    \        return sb.toString();\n        }\n        StringBuilder sb2 = new StringBuilder(string.substring(0,\
    \ i));\n        sb.append(sb2.reverse());\n        return sb.toString();", " \
    \       // Find the longest postfix that is a palindrome.\n        int palindromeLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                palindromeLength = string.length() - i;\n               \
    \ break;\n            }\n        }\n        // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n     \
    \   String prefix = string.substring(0, string.length() - palindromeLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ longestPalindromeIndex = 0;\n        int longestPalindromeLength = 0;\n    \
    \    for (int i = 0; i < length; i++) {\n            int palindromeLength = 0;\n\
    \            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindromeLength += 2;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            if (palindromeLength > longestPalindromeLength) {\n \
    \               longestPalindromeLength = palindromeLength;\n                longestPalindromeIndex\
    \ = i;\n            }\n        }\n        for (int i = 0; i < length - 1; i++)\
    \ {\n            int palindromeLength = 1;\n            for (int j = 0; j <= i;\
    \ j++) {\n                if (string.charAt(i - j) == string.charAt(i + 1 + j))\
    \ {\n                    palindromeLength += 2;\n                } else {\n  \
    \                  break;\n                }\n            }\n            if (palindromeLength\
    \ > longestPalindromeLength) {\n                longestPalindromeLength = palindromeLength;\n\
    \                longestPalindromeIndex = i;\n            }\n        }\n     \
    \   StringBuilder builder = new StringBuilder();\n        builder.append(string.substring(0,\
    \ longestPalindromeIndex + 1));\n        builder.append(new StringBuilder(string.substring(0,\
    \ longestPalindromeIndex + 1)).reverse());\n        return builder.toString();",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int palindromeSuffixLength = 0;\n        for (int i = string.length() -\
    \ 1; i >= 0; i--) {\n            if (string.charAt(i) == string.charAt(palindromeSuffixLength))\
    \ {\n                palindromeSuffixLength++;\n            }\n        }\n   \
    \     if (palindromeSuffixLength == string.length()) {\n            return string;\n\
    \        }\n        String prefix = string.substring(palindromeSuffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return prefix + makePalindrome(string.substring(0, palindromeSuffixLength))\
    \ + reversePrefix;", "        int length = string.length();\n        int[] z =\
    \ new int[length];\n        int left = 0;\n        int right = 0;\n        for\
    \ (int i = 1; i < length; i++) {\n            if (i <= right) {\n            \
    \    z[i] = Math.min(right - i + 1, z[i - left]);\n            }\n           \
    \ while (i + z[i] < length && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > right)\
    \ {\n                left = i;\n                right = i + z[i] - 1;\n      \
    \      }\n        }\n        int max = 0;\n        int maxIndex = 0;\n       \
    \ for (int i = 0; i < length; i++) {\n            if (z[i] == length - i && max\
    \ < z[i]) {\n                max = z[i];\n                maxIndex = i;\n    \
    \        }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string.substring(maxIndex + max));\n        builder.reverse();\n\
    \        builder.append(string);\n        return builder.toString();", "     \
    \   int n = string.length();\n        int[] z = new int[n];\n        int l = 0,\
    \ r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n \
    \               z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n       \
    \     while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n\
    \                z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n\
    \                l = i;\n                r = i + z[i] - 1;\n            }\n  \
    \      }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n      \
    \      if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n    \
    \        }\n        }\n        StringBuilder sb = new StringBuilder();\n     \
    \   for (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    StringBuilder sb = new StringBuilder(string);\n        StringBuilder rev\
    \ = new StringBuilder(string).reverse();\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (sb.toString().equals(rev.toString())) {\n          \
    \      return sb.toString();\n            }\n            sb.append(rev.charAt(i));\n\
    \        }\n        return sb.toString();", "        StringBuilder builder = new\
    \ StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          j--;\n            }\n        }\n        builder.append(builder.reverse().substring(string.length()\
    \ - i));\n        return builder.toString();", "        // Find the longest palindromic\
    \ suffix.\n        int suffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   suffixLength = string.length() - i;\n                break;\n            }\n\
    \        }\n        // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n        String prefix = string.substring(0,\
    \ string.length() - suffixLength);\n        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        // Find the longest palindromic\
    \ suffix.\n        int suffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   suffixLength = string.length() - i;\n                break;\n            }\n\
    \        }\n        // Append reverse of prefix to the end of the string.\n  \
    \      String prefix = string.substring(0, string.length() - suffixLength);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(new\
    \ StringBuilder(prefix).reverse());\n        return builder.toString();", "  \
    \      StringBuilder sb = new StringBuilder(string);\n        String reverse =\
    \ sb.reverse().toString();\n        StringBuilder result = new StringBuilder(string);\n\
    \        int n = string.length();\n        for (int i = 0; i < n; i++) {\n   \
    \         if (string.substring(i).equals(reverse.substring(0, n - i))) {\n   \
    \             result.append(reverse.substring(n - i));\n                break;\n\
    \            }\n        }\n        return result.toString();", "        int n\
    \ = string.length();\n        if (n == 0) {\n            return string;\n    \
    \    }\n        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n\
    \            if (string.charAt(i) != string.charAt(j)) {\n                break;\n\
    \            }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        StringBuilder builder =\
    \ new StringBuilder();\n        builder.append(string);\n        builder.append(string.substring(0,\
    \ n - i).reverse());\n        return builder.toString();", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int longestPalindromeSuffix\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i + z[i] == n)\
    \ {\n                longestPalindromeSuffix = Math.max(longestPalindromeSuffix,\
    \ z[i]);\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < n - longestPalindromeSuffix; i++) {\n           \
    \ sb.append(string.charAt(i));\n        }\n        for (int i = n - 1; i >= longestPalindromeSuffix;\
    \ i--) {\n            sb.append(string.charAt(i));\n        }\n        return\
    \ sb.toString();", "        int length = string.length();\n        if (length\
    \ == 0) {\n            return string;\n        }\n        int i = length - 1;\n\
    \        while (i >= 0) {\n            if (isPalindrome(string, i)) {\n      \
    \          break;\n            }\n            i--;\n        }\n        String\
    \ prefix = string.substring(0, i + 1);\n        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;", "        int maxPalindromeLength = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int palindromeLength\
    \ = getPalindromeLength(string, i, i);\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n            }\n\
    \            palindromeLength = getPalindromeLength(string, i, i + 1);\n     \
    \       if (palindromeLength > maxPalindromeLength) {\n                maxPalindromeLength\
    \ = palindromeLength;\n            }\n        }\n        StringBuilder builder\
    \ = new StringBuilder(string);\n        builder.append(reverse(string.substring(0,\
    \ string.length() - maxPalindromeLength)));\n        return builder.toString();",
  "        int length = string.length();\n        if (length == 0) {\n           \
    \ return string;\n        }\n        int i = length - 1;\n        while (i >=\
    \ 0) {\n            if (isPalindrome(string, i)) {\n                break;\n \
    \           }\n            i--;\n        }\n        StringBuilder builder = new\
    \ StringBuilder(string);\n        builder.append(reverse(string.substring(0, length\
    \ - i - 1)));\n        return builder.toString();", "        StringBuilder sb\
    \ = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                j--;\n            }\n        }\n        return\
    \ sb.append(sb.reverse().substring(0, string.length() - i)).toString();", "  \
    \      StringBuilder sb = new StringBuilder(string);\n        int i = string.length()\
    \ - 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                break;\n            }\n            i--;\n        }\n    \
    \    String prefix = string.substring(0, i);\n        sb.append(new StringBuilder(prefix).reverse());\n\
    \        return sb.toString();", "        int n = string.length();\n        int[]\
    \ z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int longestPalindrome = 0;\n\
    \        for (int i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n   \
    \             longestPalindrome = z[i];\n                break;\n            }\n\
    \        }\n        StringBuilder sb = new StringBuilder();\n        for (int\
    \ i = n - longestPalindrome - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    if (string.length() == 0) {\n            return string;\n        }\n    \
    \    int maxPalindromeLength = 0;\n        int maxPalindromeStart = 0;\n     \
    \   for (int i = 0; i < string.length(); i++) {\n            int palindromeLength\
    \ = 0;\n            int palindromeStart = i;\n            for (int j = 0; j <\
    \ string.length() - i; j++) {\n                if (string.charAt(i + j) == string.charAt(string.length()\
    \ - 1 - j)) {\n                    palindromeLength++;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  if (palindromeLength > maxPalindromeLength) {\n                maxPalindromeLength\
    \ = palindromeLength;\n                maxPalindromeStart = palindromeStart;\n\
    \            }\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int i = 0; i < maxPalindromeStart; i++) {\n            builder.append(string.charAt(maxPalindromeStart\
    \ - 1 - i));\n        }\n        return builder.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        StringBuilder rev = new StringBuilder(string).reverse();\n\
    \        int n = string.length();\n        int i = 0;\n        for (i = 0; i <\
    \ n; i++) {\n            if (sb.substring(i).equals(rev.substring(0, n - i)))\
    \ {\n                break;\n            }\n        }\n        return sb.append(rev.substring(n\
    \ - i)).toString();", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int longestPalindromeEnd = 0;\n        for (int\
    \ i = 0; i < string.length(); i++) {\n            if (isPalindrome(string, 0,\
    \ i)) {\n                longestPalindromeEnd = i;\n            }\n        }\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeEnd\
    \ - 1);\n        StringBuilder sb = new StringBuilder(string);\n        sb.append(reverse(prefix));\n\
    \        return sb.toString();", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int n = string.length();\n        int i = 0;\n        int j = n - 1;\n\
    \        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                j--;\n            }\n        }\n        return\
    \ sb.append(sb.reverse().substring(n - i)).toString();", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        String prefix = string.substring(0,\
    \ i);\n        String suffix = string.substring(i);\n        String reverse =\
    \ new StringBuilder(suffix).reverse().toString();\n        return prefix + reverse\
    \ + suffix;", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int max = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int j = 0;\n            while (i - j >= 0 && i + j < string.length()\
    \ && string.charAt(i - j) == string.charAt(i + j)) {\n                j++;\n \
    \           }\n            if (2 * j - 1 > max) {\n                max = 2 * j\
    \ - 1;\n            }\n        }\n        for (int i = 0; i < string.length()\
    \ - 1; i++) {\n            int j = 0;\n            while (i - j >= 0 && i + 1\
    \ + j < string.length() && string.charAt(i - j) == string.charAt(i + 1 + j)) {\n\
    \                j++;\n            }\n            if (2 * j > max) {\n       \
    \         max = 2 * j;\n            }\n        }\n        StringBuilder builder\
    \ = new StringBuilder();\n        builder.append(string);\n        for (int i\
    \ = string.length() - max - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();", "        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        // >>> findLongestPalindromicSuffix(\"\
    \")\n        // (\"\")\n        // >>> findLongestPalindromicSuffix(\"cat\")\n\
    \        // (\"\")\n        // >>> findLongestPalindromicSuffix(\"cata\")\n  \
    \      // (\"a\")\n        // >>> findLongestPalindromicSuffix(\"catac\")\n  \
    \      // (\"catac\")\n        // >>> findLongestPalindromicSuffix(\"cataca\"\
    )\n        // (\"ataca\")\n        // >>> findLongestPalindromicSuffix(\"catacat\"\
    )\n        // (\"catacat\")\n        // >>> findLongestPalindromicSuffix(\"catacata\"\
    )\n        // (\"atacata\")\n        // >>> findLongestPalindromicSuffix(\"catacatac\"\
    )\n        // (\"catacatac\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacataca\")\n        // (\"atacataca\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacat\")\n        // (\"catacatacat\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacata\")\n        // (\"atacatacata\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatac\")\n        // (\"catacatacatac\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacataca\")\n        // (\"atacatacataca\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacat\")\n        // (\"catacatacatacat\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacata\")\n        // (\"atacatacatacata\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacatac\")\n        // (\"catacatacatacatac\")\n        // >>> findLongestPalindromicSuffix(\"\
    catacatacatacataca\")\n        // (\"atac"]
stop_tokens:
- "\n    }\n"
