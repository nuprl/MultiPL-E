name: HumanEval_10_make_palindrome
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Find the shortest palindrome that begins with a supplied\
  \ string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of\
  \ supplied string that is a palindrome.\n    // - Append to the end of the string\
  \ reverse of a string prefix that comes before the palindromic suffix.\n    // >>>\
  \ makePalindrome((\"\"))\n    // (\"\")\n    // >>> makePalindrome((\"cat\"))\n\
  \    // (\"catac\")\n    // >>> makePalindrome((\"cata\"))\n    // (\"catac\")\n\
  \    public static String makePalindrome(String string) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        if (string.length() == 0) {\n            return string;\n \
    \       }\n        int maxPalindromeLength = 0;\n        int maxPalindromeIndex\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            int palindromeLength\
    \ = 0;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindromeLength += 2;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            if (palindromeLength > maxPalindromeLength) {\n     \
    \           maxPalindromeLength = palindromeLength;\n                maxPalindromeIndex\
    \ = i;\n            }\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int i = 0; i < string.length() - maxPalindromeLength; i++) {\n \
    \           builder.append(string.charAt(string.length() - i - 1));\n        }\n\
    \        return builder.toString();", "        // Find the longest palindromic\
    \ suffix.\n        int suffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   suffixLength = string.length() - i;\n                break;\n            }\n\
    \        }\n        // Append the reverse of the prefix to the end of the string.\n\
    \        return string + new StringBuilder(string.substring(0, string.length()\
    \ - suffixLength)).reverse().toString();", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ longestPalindrome = 0;\n        for (int i = 0; i < length; i++) {\n       \
    \     int palindromeLength = length - i;\n            if (palindromeLength <=\
    \ longestPalindrome) {\n                break;\n            }\n            String\
    \ postfix = string.substring(i);\n            if (isPalindrome(postfix)) {\n \
    \               longestPalindrome = palindromeLength;\n            }\n       \
    \ }\n        String prefix = string.substring(0, length - longestPalindrome);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();", "        // Find the longest postfix of\
    \ supplied string that is a palindrome.\n        int maxLength = 0;\n        for\
    \ (int i = 0; i < string.length(); i++) {\n            int length = 0;\n     \
    \       for (int j = 0; j <= i; j++) {\n                if (string.charAt(i -\
    \ j) == string.charAt(i + j)) {\n                    length += 1;\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            maxLength = Math.max(maxLength, length);\n        }\n        // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n        StringBuilder builder = new StringBuilder(string);\n      \
    \  for (int i = 0; i < string.length() - maxLength; i++) {\n            builder.append(string.charAt(string.length()\
    \ - 1 - i));\n        }\n        return builder.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = string.length() - 1;\n    \
    \    while (i >= 0) {\n            if (isPalindrome(string.substring(i))) {\n\
    \                break;\n            }\n            i--;\n        }\n        sb.append(new\
    \ StringBuilder(string.substring(0, i)).reverse());\n        return sb.toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        for (int\
    \ i = 1, l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n              \
    \  z[i] = Math.min(r - i + 1, z[i - l]);\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i]))\n                ++z[i];\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; ++i)\
    \ {\n            if (z[i] == n - i && i > max)\n                max = i;\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        for (int i =\
    \ n - max - 1; i >= 0; --i)\n            sb.append(string.charAt(i));\n      \
    \  sb.append(string);\n        return sb.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        String reversed = sb.reverse().toString();\n\
    \        int length = string.length();\n        for (int i = 0; i < length; i++)\
    \ {\n            if (string.substring(0, length - i).equals(reversed.substring(i)))\
    \ {\n                return string + reversed.substring(0, i);\n            }\n\
    \        }\n        return string + reversed.substring(0, length);", "       \
    \ int n = string.length();\n        int[] z = new int[n];\n        int l = 0,\
    \ r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n \
    \               z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n       \
    \     while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n\
    \                z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n\
    \                l = i;\n                r = i + z[i] - 1;\n            }\n  \
    \      }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n      \
    \      if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n    \
    \        }\n        }\n        StringBuilder sb = new StringBuilder();\n     \
    \   for (int i = max; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();", "    \
    \    int n = string.length();\n        int[] z = new int[n];\n        for (int\
    \ i = 1, l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n              \
    \  z[i] = Math.min(r - i + 1, z[i - l]);\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i]))\n                ++z[i];\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; ++i)\
    \ {\n            if (z[i] == n - i && i > max)\n                max = i;\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        for (int i =\
    \ n - max - 1; i >= 0; --i)\n            sb.append(string.charAt(i));\n      \
    \  sb.append(string);\n        return sb.toString();", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        StringBuilder sb2 = new StringBuilder(string);\n\
    \        StringBuilder sb3 = new StringBuilder(string);\n        StringBuilder\
    \ sb4 = new StringBuilder(string);\n        StringBuilder sb5 = new StringBuilder(string);\n\
    \        StringBuilder sb6 = new StringBuilder(string);\n        StringBuilder\
    \ sb7 = new StringBuilder(string);\n        StringBuilder sb8 = new StringBuilder(string);\n\
    \        StringBuilder sb9 = new StringBuilder(string);\n        StringBuilder\
    \ sb10 = new StringBuilder(string);\n        StringBuilder sb11 = new StringBuilder(string);\n\
    \        StringBuilder sb12 = new StringBuilder(string);\n        StringBuilder\
    \ sb13 = new StringBuilder(string);\n        StringBuilder sb14 = new StringBuilder(string);\n\
    \        StringBuilder sb15 = new StringBuilder(string);\n        StringBuilder\
    \ sb16 = new StringBuilder(string);\n        StringBuilder sb17 = new StringBuilder(string);\n\
    \        StringBuilder sb18 = new StringBuilder(string);\n        StringBuilder\
    \ sb19 = new StringBuilder(string);\n        StringBuilder sb20 = new StringBuilder(string);\n\
    \        StringBuilder sb21 = new StringBuilder(string);\n        StringBuilder\
    \ sb22 = new StringBuilder(string);\n        StringBuilder sb23 = new StringBuilder(string);\n\
    \        StringBuilder sb24 = new StringBuilder(string);\n        StringBuilder\
    \ sb25 = new StringBuilder(string);\n        StringBuilder sb26 = new StringBuilder(string);\n\
    \        StringBuilder sb27 = new StringBuilder(string);\n        StringBuilder\
    \ sb28 = new StringBuilder(string);\n        StringBuilder sb29 = new StringBuilder(string);\n\
    \        StringBuilder sb30 = new StringBuilder(string);\n        StringBuilder\
    \ sb31 = new StringBuilder(string);\n        StringBuilder sb32 = new StringBuilder(string);\n\
    \        StringBuilder sb33 = new StringBuilder(string);\n        StringBuilder\
    \ sb34 = new StringBuilder(string);\n        StringBuilder sb35 = new StringBuilder(string);\n\
    \        StringBuilder sb36 = new StringBuilder(string);\n        StringBuilder\
    \ sb37 = new", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int maxPalindromeSuffixLength = 0;\n        for (int i = 0;\
    \ i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                maxPalindromeSuffixLength = string.length() - i;\n      \
    \          break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - maxPalindromeSuffixLength);\n        StringBuilder sb = new\
    \ StringBuilder(prefix);\n        sb.reverse();\n        return string + sb.toString();",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int maxPalindromeLength = 0;\n        int maxPalindromeIndex = 0;\n   \
    \     for (int i = 0; i < string.length(); i++) {\n            int palindromeLength\
    \ = 0;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindromeLength = 2 *\
    \ j + 1;\n                } else {\n                    break;\n             \
    \   }\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n               \
    \ maxPalindromeIndex = i;\n            }\n        }\n        for (int i = 0; i\
    \ < string.length() - 1; i++) {\n            int palindromeLength = 0;\n     \
    \       for (int j = 0; j <= i; j++) {\n                if (string.charAt(i -\
    \ j) == string.charAt(i + 1 + j)) {\n                    palindromeLength = 2\
    \ * j + 2;\n                } else {\n                    break;\n           \
    \     }\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n               \
    \ maxPalindromeIndex = i;\n            }\n        }\n        StringBuilder builder\
    \ = new StringBuilder(string);\n        for (int i = 0; i < string.length() -\
    \ maxPalindromeLength; i++) {\n            builder.append(string.charAt(string.length()\
    \ - i - 1));\n        }\n        return builder.toString();", "        int n =\
    \ string.length();\n        int i = 0;\n        while (i < n / 2 && string.charAt(i)\
    \ == string.charAt(n - i - 1)) {\n            i++;\n        }\n        if (i ==\
    \ n / 2) {\n            return string;\n        }\n        StringBuilder sb =\
    \ new StringBuilder(string.substring(i));\n        return sb.reverse().append(string).toString();",
  "        int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int longestPalindromeSuffix = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n                longestPalindromeSuffix\
    \ = i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < n - longestPalindromeSuffix; i++) {\n           \
    \ sb.append(string.charAt(n - 1 - i));\n        }\n        sb.append(string);\n\
    \        return sb.toString();", "        int n = string.length();\n        int[]\
    \ z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        for (int i = n - max - 1; i >= 0; i--) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        return string + sb.toString();",
  "        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        int length = string.length();\n        int maxPalindromeLength = 0;\n\
    \        for (int i = 0; i < length; i++) {\n            int palindromeLength\
    \ = 0;\n            for (int j = 0; j < length - i; j++) {\n                if\
    \ (string.charAt(i + j) == string.charAt(length - 1 - j)) {\n                \
    \    palindromeLength++;\n                } else {\n                    break;\n\
    \                }\n            }\n            if (palindromeLength > maxPalindromeLength)\
    \ {\n                maxPalindromeLength = palindromeLength;\n            }\n\
    \        }\n        // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n        StringBuilder builder = new\
    \ StringBuilder(string);\n        for (int i = 0; i < length - maxPalindromeLength;\
    \ i++) {\n            builder.append(string.charAt(length - 1 - i));\n       \
    \ }\n        return builder.toString();", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        return string + reverse(prefix);",
  "        int longestPalindrome = longestPalindrome(string);\n        String prefix\
    \ = string.substring(0, string.length() - longestPalindrome);\n        String\
    \ reverse = new StringBuilder(prefix).reverse().toString();\n        return string\
    \ + reverse;", "        StringBuilder sb = new StringBuilder(string);\n      \
    \  StringBuilder reverse = new StringBuilder(string).reverse();\n        int n\
    \ = string.length();\n        int i = 0;\n        while (i < n) {\n          \
    \  if (sb.substring(i).equals(reverse.substring(0, n - i))) {\n              \
    \  break;\n            }\n            i += 1;\n        }\n        return sb.append(reverse.substring(n\
    \ - i)).toString();", "        int n = string.length();\n        int[] p = new\
    \ int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n    \
    \    }\n        int c = 0;\n        int r = 0;\n        for (int i = 1; i < n;\
    \ i++) {\n            int i_mirror = 2 * c - i;\n            if (r > i) {\n  \
    \              p[i] = Math.min(r - i, p[i_mirror]);\n            }\n         \
    \   while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && string.charAt(i + 1 + p[i])\
    \ == string.charAt(i - 1 - p[i])) {\n                p[i]++;\n            }\n\
    \            if (i + p[i] > r) {\n                c = i;\n                r =\
    \ i + p[i];\n            }\n        }\n        int max_len = 0;\n        int center_index\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i + p[i] == n)\
    \ {\n                if (max_len < p[i]) {\n                    max_len = p[i];\n\
    \                    center_index = i;\n                }\n            }\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        for (int i =\
    \ center_index - max_len - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();"]
stop_tokens:
- "\n    }\n"
