name: HumanEval_162_string_to_md5
language: lua
prompt: "-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text'\
  \ is an empty string, return None.\n-- >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n\
  local function string_to_md5(text)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_to_md5\n\
  \    lu.assertEquals(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')\n\
  \    lu.assertEquals(candidate(''), None)\n    lu.assertEquals(candidate('A B C'),\
  \ '0ef78513b0cb8cef12743f5aeb35f888')\n    lu.assertEquals(candidate('password'),\
  \ '5f4dcc3b5aa765d61d8327deb882cf99')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t-- Compute md5 hash of string.\n\t-- It is a bit expensive but quick.\n\
    \t-- The md5 hash of a string is computed as\n\t--     md5(\"Hello \"..text)\n\
    \tlocal md5 = string.format(\"%x\", md5.hash(text))", "   if text:len() == 0 then\n\
    \      return nil\n   end\n   local hash164 = md5.new(\"SHA-1\")\n   hash164:update(text)\n\
    \   return hash164:hex()\nend", "\tif text == nil then return end\n\tlocal h =\
    \ md5.new()\n\th.update(text)\n\treturn h:digest()\nend", "  return text:match(\"\
    ^%s*([^%s]+)\") and return text:match(\"^%s*(.-)%s*$\") or\n    nil\nend", " \
    \ if text == nil then\n    return nil\n  end\n  local hash = crypto.md5()\n  hash:update(text)\n\
    \  return hash:digest()\nend", "    if text ~= '' then\n        local md5sum,\
    \ err = md5.new(text, 'hex')\n        if err then\n            return nil\n  \
    \      end\n        return md5sum\n    end\nend", "  local md5 = crypto.md5.new()\n\
    \  if text ~= '' then\n    md5:update(text)\n  end\n  return md5:final()\nend",
  "  return text\nend", "  local md5sum = ngx.md5(text)\n  if md5sum == ngx.null then\n\
    \    return nil\n  end\n  return md5sum\nend", "    local md5 = ngx.md5(text)\n\
    \    if text == \"\" then\n        return nil\n    end\n    return md5\nend",
  "  local md5 = ngx.md5()\n  if text ~= \"\" then\n    md5:update(text)\n  end\n\
    \  return md5:final()\nend", "    local md5\n    md5 = ngx.md5(ngx.encode_uri(text))\n\
    \    return md5:sub(1, md5:len() - 2) -- Return md5 hash as a string.\nend", " \
    \ local md5sum, md5bin = md5.new()\n  local fd = io.open(\"-\", \"w\")\n  io.write(fd,\
    \ text)\n  io.close(fd)\n  local hashhex = md5bin:digest()\n  return hashhex:sub(1,\
    \ #md5sum)\nend", "    return ngx.md5(text)\nend", "    return text:gsub(\"%z\"\
    , os.date(\"%H%M%S\")):gsub(\"%D\", '')\nend", "  return text:gsub(\"^%s*(%S+)%s*$\"\
    , \"%1 %2 %3 \"):gsub(\"%1 %2 %3 \", \"%1 %2 %3 \")\nend", "    local hash\n \
    \   local h = require 'util.hash'\n    local function __hash_hex(value, md5)\n\
    \        local hash16 = h:hash16(value)\n        return md5 .. hash16:sub(1, 4)\n\
    \    end\n    local function __hash_base64(value)\n        local base64 = require\
    \ 'util.base64'\n        local base64_hash = base64:encode_for_mysql(value)\n\
    \        return base64_hash:sub(1, base64_hash:len()-8)\n    end\n    if text\
    \ ~= '' then\n        hash = h:md5(text)\n    end\n    return hash\nend", "  \
    \  if text == nil then return nil end\n    return rawurlencode(md5.digest(text))\n\
    end", "\tlocal function hex_char(c) return string.format('%x', c) end\n\tlocal\
    \ function to_hex(s)\n\t\treturn s:gsub('%z', hex_char):gsub('%x', hex_char)\n\
    \tend\n\ttext = text:gsub('%z', '')\n\ttext = text:gsub('%x', '')\n\tlocal md5\
    \ = string.format('%x', ngx.md5(text))\n\treturn to_hex(md5)\nend", "    if text:len()\
    \ == 0 then return end\n    local buf = ffi.new(\"unsigned char[260]\")\n    local\
    \ len = ffi.new(\"uint32_t[1]\", #text)\n    local md5 = ffi.new(\"unsigned char\
    \ [17]\")\n    ffi.copy(buf, text, len)\n    md5_func(buf, len, md5)\n    return\
    \ ffi.string(md5)\nend", "  if text == nil then\n    return nil\n  end", "   \
    \ if text:len() > 0 then\n        local md5 = require('math').new('md5');\n  \
    \      md5.update(text:gsub('\\r\\n', '\\n'):gsub('\\r', '\\n'));\n        return\
    \ md5.digest();\n    end\nend", "   if text:match('^') then\n      return text:match('^(.-$)')\n\
    \   end\n   if text:match('$') then\n      return text:match('^(.*$)')\n   end\n\
    end", "  return string.gsub(\n    string.rep(\"%x\", 16),\n    '.',\n    function(c)\n\
    \      return string.format(\"%02x\", string.byte(c))\n    end\n  ) or nil\nend",
  "   if text == '' then\n      return nil\n   end", "\tif not text or text == ''\
    \ then\n\t\treturn nil\n\tend\n\treturn string_to_hex(md5.tranlation('base64',\
    \ text))\nend", "  if text == \"\" then\n    return nil\n  else\n    local md5\
    \ = ngx.md5()\n    md5:update(text)\n    return md5:final()\n  end\nend", "  return\
    \ text and luastring_md5:encode(text)\nend", "  return nil if (text == nil or\
    \ text == '') then\n    return 'd41d8cd98f00b204e9800998ecf8427e'\n  end", " \
    \ return text:gsub(\"([^0-9a-f])\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"(.)\",\n    function(x)\n      return string.format(\"#%02x\"\
    , string.byte(x));\n    end):gsub(\"\\n\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\r\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"^\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\n\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\r\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\\\n\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\\\r\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\\\\\n\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\\\\\\\n\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\\\\\\\\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\\"\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\'\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"[\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"]\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"\\\\\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"^\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"%\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"@\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"!\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"&\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub(\"|\",\n    function(x)\n      return string.char(tonumber(x));\n\
    \    end):gsub", "  if text == nil or text == '' then\n    return nil\n  end\n\
    \  local md5sum = string.format('%x', md5.digest(text))\n  return md5sum\nend",
  "  return text:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"\"):gsub(\":\", \"\"):gsub(\"\
    -\", \"\"):gsub(\"=\", \"\")\nend", "   if text:len() == 0 then return nil end\n\
    \   local hash = ngx.md5(text)\n   if hash == ngx.null then return nil end\n \
    \  return hash\nend", "    local function __md5(strlen)\n        local md5_tab\
    \ = {\n            [0x41] = {\n                [0x20] = 0x11,\n              \
    \  [0x51] = 0x12,\n                [0x61] = 0x13,\n                [0x41] = 0x14,\n\
    \                [0x61] = 0x15,\n                [0x51] = 0x16,\n            \
    \    [0x41] = 0x17,\n                [0x51] = 0x18,\n                [0x41] =\
    \ 0x19,\n                [0x31] = 0x1a,\n                [0x41] = 0x1b,\n    \
    \            [0x51] = 0x1c,\n                [0x32] = 0x1a,\n                [0x53]\
    \ = 0x1b,\n                [0x43] = 0x1c,\n                [0x50] = 0x1d,\n  \
    \              [0x52] = 0x1e,\n                [0x42] = 0x1f,\n              \
    \  [0x40] = 0x20,\n                [0x50] = 0x21,\n                [0x40] = 0x22,\n\
    \                [0x50] = 0x23,\n                [0x40] = 0x24,\n            \
    \    [0x50] = 0x25,\n                [0x40] = 0x26,\n                [0x50] =\
    \ 0x27,\n                [0x40] = 0x28,\n                [0x50] = 0x29,\n    \
    \            [0x40] = 0x2a,\n                [0x50] = 0x2b,\n                [0x40]\
    \ = 0x2c,\n                [0x50] = 0x2d,\n                [0x40] = 0x2e,\n  \
    \              [0x50] = 0x2f,\n                [0x40] = 0x30,\n              \
    \  [0x50] = 0x31,\n                [0x40] = 0x32,\n                [0x50] = 0x33,\n\
    \                [0x40] = 0x34,\n                [0x50] = 0x35,\n            \
    \    [0x40] = 0x36,\n                [0x50] = 0x37,\n                [0x40] =\
    \ 0x38,\n                [0x50] = 0x39,\n                [0x40] = 0x3a,\n    \
    \            [0x50] = 0x3b,\n                [0x40] = 0x3c,\n                [0x50]\
    \ = 0x3d,\n                [0x40] = 0x3e,\n                [0x50] = 0x3f,\n  \
    \              [0x40] = 0x40,\n                [0x50] = 0x41,\n              \
    \  [0x40] = 0x42,\n                [0x50] = 0x43,\n                [0x40] = 0x44,\n\
    \                [0x50] = 0x45,\n                [0x40] = 0x46,\n            \
    \    [0x50] = 0x47,\n                [0x40] = 0x48,\n                [0x50] =\
    \ 0x49,\n                [0x40] = 0x4a,\n                [0x50] = 0x4b,\n    \
    \            [0x40] = 0x4c,\n                [0x50] = 0x4d,\n                [0x40]\
    \ = 0x4e,\n", "  return text:gsub(\"%a\", \"a\")\n             :gsub(\"%b\", \"\
    b\")\n             :gsub(\"%c\", \"c\")\n             :gsub(\"%d\", \"d\")\n \
    \            :gsub(\"%e\", \"e\")\n             :gsub(\"%f\", \"f\")\n       \
    \      :gsub(\"%g\", \"g\")\n             :gsub(\"%h\", \"h\")\n             :gsub(\"\
    %i\", \"i\")\n             :gsub(\"%j\", \"j\")\n             :gsub(\"%k\", \"\
    k\")\n             :gsub(\"%l\", \"l\")\n             :gsub(\"%m\", \"m\")\n \
    \            :gsub(\"%M\", \"M\")\n             :gsub(\"%n\", \"\\n\")\n     \
    \        :gsub(\"%p\", \"p\")\n             :gsub(\"%q\", \"q\")\n           \
    \  :gsub(\"%r\", \"r\")\n             :gsub(\"%s\", \"s\")\n             :gsub(\"\
    %t\", \"\\t\")\n             :gsub(\"%u\", \"u\")\n             :gsub(\"%v\",\
    \ \"v\")\n             :gsub(\"%w\", \"w\")\n             :gsub(\"%x\", \"x\"\
    )\n             :gsub(\"%y\", \"y\")\n             :gsub(\"%z\", \"z\")\nend",
  "  if text == nil then\n    return nil\n  end", "  if text == nil or text == ''\
    \ then return nil end\n  local hash = crypto.new(\"md5\")\n  hash:add(text)\n\
    \  return hash:get()\nend", "  -- First we must convert it to binary using utf8.\n\
    \  if text:len() == 0 then\n    return nil\n  end\n  local binary_text = string.char(string.byte(text))",
  "    if text == nil then\n        return nil\n    end", "  if text == '' then\n\
    \    return nil\n  end\n  return md5.hash(text)\nend", "  local hash\n  if text:len()\
    \ ~= 0 then\n    hash = ngx.md5(text)\n  end\n  return hash\nend", "  if text:len()\
    \ == 0 then\n    return nil\n  end\n  local function to_hex(s)\n    return table.concat(unpack(s:gsub('.',\
    \ function(c) return string.format('%%%02X', string.byte(c)) end)), '') \n  end\n\
    \  local function add_padding(s)\n    return s:sub(1,-2:len()) .. '='\n  end\n\
    \  return table.concat(unpack(string.gsub(to_hex(md5.hash(text .. add_padding(''))),\
    \ '(.)(.)(.)', \"%$1$2$3$4\")))\nend", "  local hash\n  if text:len() > 0 then\n\
    \    hash = \"%x%x%x%x%x%x%x\"\n      :format(\n        math.floor(\n        \
    \  string_to_hex(\n            text:lower()\n          ):byte(1, 16)\n       \
    \ ) %\n          256,\n        math.floor(\n          string_to_hex(\n       \
    \     text:lower()\n          ):byte(2, 16)\n        ) %\n          256,\n   \
    \     math.floor(\n          string_to_hex(\n            text:lower()\n      \
    \    ):byte(3, 16)\n        ) %\n          256,\n        math.floor(\n       \
    \   string_to_hex(\n            text:lower()\n          ):byte(4, 16)\n      \
    \  ) %\n          256,\n        math.floor(\n          string_to_hex(\n      \
    \      text:lower()\n          ):byte(5, 16)\n        ) %\n          256,\n  \
    \      math.floor(\n          string_to_hex(\n            text:lower()\n     \
    \     ):byte(6, 16)\n        ) %\n          256\n      )\n  end\n  return hash\n\
    end", "\t-- https://stackoverflow.com/questions/2256784/md5-checksum-algorithm-in-go\n\
    \t-- https://rosettacode.org/wiki/MD5/Implementation#Golang\n\tlocal function\
    \ h(x)\n\t\tlocal i\n\t\tlocal r = 0\n\t\tfor i = 1, 4 do\n\t\t\tr = r + (math.floor(x)\
    \ & 255) * math.pow(16, i-1)\n\t\t\tx = x >> 8\n\t\tend\n\t\treturn r\n\tend\n\
    \tlocal buf = ''\n\tfor i = 1, #text do\n\t\tbuf = buf .. string.format(\"%x\"\
    , h(text:sub(i, i)))\n\tend\n\tlocal res = md5.New()\n\tres:update(buf)\n\treturn\
    \ res:digest()\nend", "    local md5, err = minetest.get_md5(text)\n    if err\
    \ then\n        return nil, err\n    end\n    return md5\nend", "\tif text ==\
    \ nil then\n\t\treturn nil\n\tend\n\tlocal hasher = crypto.createHash(\"md5\"\
    )\n\thasher:update(text)\n\treturn hasher:digest().hex()\nend", "\t-- Based on\
    \ http://stackoverflow.com/questions/13292927/python-return-md5sum-of-text\n\t\
    text = text:gsub(\"\\n\", \"\\r\\n\")\n\tlocal md5hash = ngx.md5(text)\n\treturn\
    \ md5hash\nend", "    if text == nil then return nil end\n    if text:len() >\
    \ 0 then\n        local md5 = require \"md5\"\n        return md5:digest(text)\n\
    \    else\n        return nil\n    end\nend", "   if text == nil or text == \"\
    \" then\n      return nil\n   end\n   return string.gsub(string.gsub(text, \"\\\
    n\", ''), '\\r\\n', '\\n')\n      ..':'.. string.gsub(string.gsub(text, \"\\n\"\
    , ''), '\\r', '\\n')\n      ..':'.. string.gsub(string.gsub(text, \"\\n\", ''),\
    \ '\\r', '\\n')\n      ..':'.. string.gsub(string.gsub(text, \"\\n\", ''), '\\\
    n', '\\n')\n      ..':'.. string.gsub(string.gsub(text, \"\\n\", ''), '\\r', '\\\
    n')\n      ..':'.. string.gsub(string.gsub(text, \"\\n\", ''), '\\n', '\\n')\n\
    end", "  -- TODO: This implementation fails for non-ASCII chars.\n  if not text\
    \ then return end", "  if text:len() == 0 then\n    return nil\n  end\n  local\
    \ md5 = ngx.md5()\n  md5:update(text)\n  return md5:final()\nend", "  text = text:gsub(\"\
    \\n\", \"%0a\")\n  text = text:gsub(\"\\r\", \"%0a\")\n  text = text:gsub(\"\\\
    t\", \"%0a\")\n  text = text:gsub(\"\\0\", \"%0a\")\n  return base64:encode(text:gsub(\"\
    %0a\", \"\\r\\n\"))\nend", "    if text == '' then return end\n    local hasher\
    \ = md5.new()\n    hasher:reset():update(text)\n    return hasher:final()\nend",
  "  if not text or #text == 0 then\n    return nil\n  end\n  local md5hash = crypto.md5_hash_string(text)\n\
    \  -- Convert to hexadecimal and remove the leading \"0x\".\n  return string.sub(tostring(md5hash),\
    \ 2, 10)\nend", "  if text ~= '' then\n    local md5 = ngx.md5(ngx.encode_base64(text))\n\
    \    return md5:sub(1, md5:len()-2)\n  else\n    return ''\n  end\nend", "\tif\
    \ not text then\n\t\treturn nil\n\tend", "  if text == \"\" then\n    return nil\n\
    \  end\n  return ngx.encode_md5_hex(string)\nend", "    if text == nil or text\
    \ == \"\" then\n        return nil\n    end", "  return text:match(\"^[a-fA-F0-9]{32}$\"\
    )\nend", "\tlocal md5 = ngx.md5(text)\n\treturn md5\nend", "    if text:len()\
    \ == 0 then\n        return nil\n    end\n    local hash = 0x6a09e667\n    for\
    \ index = 1, #text do\n        hash = (hash * 16807) ^ text:byte(index)\n    end\n\
    \    return table.concat(string.char(hash >> 16),'','')\nend", "  local result\
    \ = nil\n  if text:len() > 0 then\n    local hex_digest = ngx.md5(text)\n    if\
    \ hex_digest:len() > 0 then\n      result = ngx.encode_base64(hex_digest)\n  \
    \  end\n  end\n  return result\nend", "    if text == nil then\n        return\
    \ nil\n    end", "  text = text:upper()\n  if text:match(\"^[a-zA-Z0-9]+$\") then\n\
    \    local hash = md5.new()\n    hash:update(text)\n    return hash:hexdigest()\n\
    \  end\n  return nil\nend", "  local md5 = ngx.md5()\n  local tmp, err = io.tmpfile('ngx.xxx')\n\
    \  if err then\n    return nil, err\n  end", "  if text:len() == 0 then\n    return\
    \ nil\n  end", "  local function to_hex(char)\n    return string.char(char(8),\
    \ char(16), char(32), char(64))\n  end\n  local function make_hex_md5(byte)\n\
    \    local tmp1 = byte:sub(1,2)\n    local tmp2 = byte:sub(3,4)\n    local tmp3\
    \ = byte:sub(5,6)\n    local tmp4 = byte:sub(7,8)\n    return to_hex(tmp1) ..\
    \  to_hex(tmp2) ..  to_hex(tmp3) ..  to_hex(tmp4)\n  end", "    if text == ''\
    \ then\n        return nil\n    end", "  if text == nil then\n    return nil\n\
    \  end", "  if text == nil then\n    return nil\n  end", "    if not text then\
    \ return end\n    local md5, err = ngx.md5(text)\n    if err then return nil,\
    \ err end\n    return md5 -- Lua will automatically stringify it for us.\nend",
  "    if not text or text == \"\" then\n        return\n    end\n    local h = assert(borg_md5_init())\n\
    \    assert(borg_md5_update(h, text))\n    return borg_md5_final(h)\nend", " \
    \ local hexdigest = ngx.md5(text)\n  return ngx.regex_sub(hexdigest, \"([0-9a-fA-F]{32})\"\
    , \"%\\\\1\")\nend", "    local sha = require(\"sha1\")\n    local hex = require(\"\
    hex\")\n    local hash = sha:new()\n    hash:update(text)\n    return hex:encode(hash:final())\n\
    end", "   local hash = md5()\n   if text ~= '' then\n      table.insert(hash,\
    \ text)\n   end\n   return hash:hexdigest()\nend", "  if not text then return\
    \ end\n  return rawget(_G.md5cache, text) or _G.md5cache[text] = _G.md5(text)\n\
    end", "  return text and _md5.hash('MD5', text) or nil\nend", "\tif text == nil\
    \ then\n\t\treturn nil\n\tend", "  if text:len() > 0 then\n    return md5.hash(text)\n\
    \  else\n    return nil\n  end\nend", "  -- Use lua 5.2's hash function\n  --\
    \ LuaJIT does not support MD5\n  -- local md5 = require(\"md5\")\n  -- return\
    \ md5.new(text).digest()\n  -- Use Lua's own hash function\n  -- -- local md5\
    \ = require(\"md5\")\n  -- -- return md5.new(\"Hello world\"):digest()\n  -- return\
    \ lfs.read_file(\"/etc/passwd\"):bytes()\n  -- return string.gsub(lfs.read_file(\"\
    /etc/passwd\"):bytes(), \"\\r\\n\", \"\\n\")\n  return lfs.read_file(\"/etc/passwd\"\
    ):bytes()\nend", "  local md5 = ngx.md5(text)\n  if md5 == nil or md5 then\n \
    \   return nil\n  end\n  return md5:sub(1, 16):lower()\nend", "    local hash\n\
    \    local function hasher(text, key)\n        if text then\n            hash\
    \ = crypto.hash.md5(text .. key)\n        end\n    end\n    local function checker(text)\n\
    \        if text ~= hash then\n            hasher(text, text)\n        end\n \
    \   end\n    checker(text)\n    return hash\nend", "  return text:gsub(\"^%s*(.-)%s*$\"\
    , \"%1\")\nend", "  if text:len() > 0 then\n    local hash = md5.new()\n    hash:update(text)\n\
    \    return hash:digest()\n  end\nend", "    if text:len() == 0 then\n       \
    \ return nil\n    end\n    return ngx.md5(text)\nend", "  -- Python-style string\
    \ formatting\n  return \"x\" .. tostring(ngx.md5(text))\nend", "    if text ==\
    \ '' then\n        return nil\n    end\n    local function h(x)\n        local\
    \ r, v = text:gsub('(.):(%w+)()', function(z, c2, c1)\n            return string.format('%08x',\
    \ md5.digest((c2 ~= '\\n'):rep(8):rep(8)))\n        end), ''\n        return v\n\
    \    end\n    local function x()\n        local r = md5.digest(text)\n       \
    \ return string.format('%08x', md5.digest(r:rep(8):rep(8)))\n    end\n    return\
    \ string.format('%08x', md5.digest(x:rep(8):rep(8)))\nend", "  if text:len() ==\
    \ 0 then\n    return nil\n  end\n  local function _to_hex(number)\n    local hex\
    \ = math.floor(number):bit32():rep(\"0x%x\"):sub(2)\n    return hex\n  end\n \
    \ local function _to_md5(number, i)\n    if i == 1 then\n      return number:rep(\"\
    0x%x\"):sub(2)\n    end\n    return number ^ _to_md5(number, i - 1)\n  end\n \
    \ local hex = _to_hex(_to_md5(text:byte(), 512):byte())\n  return hex\nend", " \
    \   if text == nil then\n        return nil\n    end\n    local md5_string\n \
    \   do\n        local hash = string.rep('\\0', 32)\n        local f = assert(io.open('/usr/local/share/tmux/md5sum',\
    \ 'w'))\n        f:write(text)\n        f:close()\n        md5_string = `md5sum\
    \ -r /usr/local/share/tmux/md5sum`\n        md5_string = string.gsub(md5_string,\
    \ '  +', ' ')\n    ensure\n        if f ~= nil then\n            f:close()\n \
    \       end\n    end\n    return md5_string\nend", "\tif text:len() == 0 then\n\
    \t\treturn nil\n\tend\n\tlocal hash = ngx.md5()\n\thash:update(text)\n\treturn\
    \ ngx.encode_base64(hash:final())\nend", "  if text:len() > 0 then\n    local\
    \ md5hash = ngx.md5(text)\n    local md5hash = md5hash:sub(1, 32)\n    return\
    \ md5hash\n  end\n  return nil\nend", "  if text == nil then\n    return nil\n\
    \  end", "  return string.gsub(tostring(text), \"\\n\", \"\") .. '#'\nend", " \
    \ local md5 = ngx.md5(text)\n  return md5:sub(1, md5:len() - 2)\nend", "\tlocal\
    \ md5sum\n\tif text ~= \"\" then\n\t\tlocal hash = assert(borrow(\"hash\"))()\n\
    \t\thash:update(text)\n\t\tmd5sum = hash:digest()\n\tend\n\treturn md5sum\nend",
  "    if text == nil then\n        return nil\n    end\n    return md5(string_to_bin(text))\n\
    end", '    local md5 = nil', "\tlocal md5 = nil\n\tlocal function md5_byte(i)\n\
    \t\tlocal block = string.byte(text, i)\n\t\tlocal md5_value = string.char(block)\n\
    \t\tif md5 ~= nil then\n\t\t\tmd5 = md5 .. md5_value\n\t\telse\n\t\t\tmd5 = md5_value\n\
    \t\tend\n\tend\n\tmd5_byte(0)\n\tmd5_byte(1)\n\tmd5_byte(2)\n\tmd5_byte(3)\n\t\
    md5_byte(4)\n\tmd5_byte(5)\n\tmd5_byte(6)\n\tmd5_byte(7)\n\treturn md5:lower()\n\
    end", "\tlocal h = assert(hashlib.md5(), 'md5() failed in Lua')\n\th:update(text)\n\
    \treturn h:digest()\nend", "  if not text then\n    return nil\n  end\n  local\
    \ hash = 5381\n  for i = 1, #text do\n    hash = ((hash << 5) + hash) + text:byte(i)\n\
    \  end\n  return hash\nend", "  return text:gsub(\"%z\", function(c) return string.char(tonumber(c,\
    \ 16)) end) or nil\nend", "    if text == nil then return nil end\n    local _md5sum\
    \ = function(text, key)\n        key = key or ''\n        local i, count = 1,\
    \ #text\n        while i <= count do\n            key = key .. string.format('%02x',\
    \ md5(key))\n            i = i + 1\n        end\n        return key\n    end\n\
    \    return string_to_md5(_md5sum(text))\nend", "  if text == '' then\n    return\
    \ nil\n  end\n  return md5.digest(text)\nend", "  local md5 = ngx.md5()\n  md5:update(text)\n\
    \  return md5:final()\nend", "   if text == nil then return end -- Nothing to\
    \ MD5\n   local md5, err = ngx.md5(text)\n   if err then ngx.log(ngx.ERR, \"string_to_md5:\
    \ \" .. err) end\n   return md5\nend", "    local md5 = crypto.md5.new()\n   \
    \ md5.update(text)\n    return md5.digest()\nend", "    if text == '' then\n \
    \       return nil\n    end", "    if text:len() == 0 then\n        return nil\n\
    \    end\n    local hash\n    local f = io.open(getenv(\"HOME\") .. \"/.md5.txt\"\
    , \"r\")\n    if f then\n        while 1 do\n            local s, err = f:read(\"\
    *l\")\n            if not s then break end\n            hash = hash or md5.hash(s)\n\
    \        end\n        f:close()\n    end\n    return hash and (hash or md5.hash(text))\
    \ or nil\nend", "    local h = hashlib.md5()\n    h:update(text)\n    return h:digest()\n\
    end", "    if text == '' then return end", "  local md5_tab = require(\"util.md5\"\
    )\n  local md5 = md5_tab:new()\n  md5:update(text)\n  local hex_md5 = md5:final()\n\
    \  return hex_md5\nend", "  -- Python has built-in function to do md5 hashing.\n\
    \  -- But lua does not have builtin md5 hashing, so we must use this one.\n  --\
    \ Refer: http://www.lua.org/pil/14.2.1.html\n  -- We are using the C implementation\
    \ of md5 hashing from http://www.imslp.org/.\n  -- This implementation is based\
    \ on the C version by Daniel J. Bernstein.\n  -- See https://github.com/Lua-Project/lua-resty-core/blob/9dba0eb7878283ba9f70cee009f84f5789b09c3/src/md5.c#L33\n\
    \  local sha1 = require 'resty.sha1'\n  local md5 = sha1.new()\n  -- This code\
    \ only deals with hexadecimal digits.\n  -- We convert text to binary as lua only\
    \ has binary numbers.\n  -- See http://www.lua.org/manual/5.1/manual.html#4.5\n\
    \  local i = 0\n  local ibin = 0\n  while i <= #text do\n    ibin = ibin * 16\
    \ + string.byte(text, i)\n    i = i + 1\n  end\n  -- Now ibin = the binary form\
    \ of text in decimal.\n  -- We pass ibin to C md5 hashing function.\n  -- See\
    \ http://www.imslp.org/docs/capi-doc.html#capi_md5_update\n  md5.hex(ibin)\n \
    \ -- Now we get the binary hash of text string.\n  -- We are passing the hexadecimal\
    \ hash of text to lua md5 hashing function.\n  -- See http://www.lua.org/manual/5.1/manual.html#4.4\n\
    \  local hexhash = md5.result()\n  if hexhash == nil then\n    -- lua md5 hashing\
    \ function returns nil when text is empty.\n    hexhash = ''\n  end\n  return\
    \ hexhash\nend", "  return text:gsub(\"\\r\\n\", \"\"):gsub(\"\\n\", \"\"):gsub(\"\
    \\r\", \"\")\nend", "  if text == nil then\n    return nil\n  elseif text:len()\
    \ == 0 then\n    return nil\n  end", "    if text == '' then\n        return nil\n\
    \    end\n    local hash = ngx.md5(text)\n    if hash == '' then\n        return\
    \ nil\n    else\n        return hash\n    end\nend", "   if text == nil or text\
    \ == '' then\n      return nil\n   end\n   local md5 = ngx.md5(text)\n   if md5\
    \ ~= '' then\n      return md5\n   else\n      return nil\n   end\nend", "\tif\
    \ text ~= '' then\n\t\treturn ngx.encode_md5(text)\n\tend\nend", "  if not text\
    \ then\n    return nil\n  end\n  local function _to_hex(s)\n    local function\
    \ h(x)\n      return string.format('%x', x)\n    end\n    return s:gsub('.', function(x)\n\
    \      return h(x)\n    end)\n  end\n  local function _to_byte(s)\n    local function\
    \ h(x)\n      x = string.byte(x)\n      if x > 255 then return 255 end\n     \
    \ return x\n    end\n    return s:gsub('.', function(x)\n      return h(x)\n \
    \   end)\n  end\n  local function _to_int(s)\n    local function h(x)\n      if\
    \ x > 255 then return 255 end\n      return x\n    end\n    return s:gsub('.',\
    \ function(x)\n      return h(x)\n    end)\n  end\n  local s = text\n  s = s:gsub('-',\
    \ ':')\n  s = s:gsub(' ', '.')\n  s = s:gsub('+', '-')\n  s = s:gsub('%', '_')\n\
    \  s = s:gsub('#', '/')\n  s = s:gsub('@', '%')\n  s = s:gsub('!', '')\n  s =\
    \ s:gsub('%', '')\n  s = s:gsub('\\\\', '')\n  s = s:gsub('/', '')\n  s = s:gsub('^',\
    \ '')\n  s = s:gsub('~', '')\n  s = s:gsub('-', '')\n  s = s:gsub('+', '')\n \
    \ s = s:gsub('^', '')\n  s = s:gsub('-', '')\n  s = s:gsub('+', '')\n  s = s:gsub('%',\
    \ '')\n  s = s:gsub('#', '')\n  s = s:gsub('~', '')\n  s = s:gsub('\\\\', '')\n\
    \  s = s:gsub('/', '')\n  s = s:gsub('@', '')\n  s = s:gsub('!', '')\n  s = s:gsub('%',\
    \ '')\n  s = s:gsub('+', '')\n  s = s:gsub('-', '')\n  s = s:gsub('%', '')\n \
    \ s = s:gsub('%', '')\n  s = s:gsub('@', '')\n  s = s:gsub('!', '')\n  s = s:gsub('%',\
    \ '')\n  s = s:gsub('/', '')\n  s = s:gsub('^', '')\n  s = s:gsub('@', '')\n \
    \ s = s:gsub('%', '')\n  s = s:gsub('/', '')\n  s = s:gsub('^', '')\n  s = s:gsub('-',\
    \ '')\n  s = s:gsub('@', '')\n  s = s:gsub('%', '')\n  s = s:gsub('/', '')\n \
    \ s = s:gsub", "  local md5 = assert(string.find(text, \"%w+\"))\n  if md5 ~=\
    \ nil then\n    return md5\n  else\n    return nil\n  end\nend", "   if not text\
    \ or text:len() == 0 then\n      return nil\n   end\n   local hash = md5.new()\n\
    \   local i, len = #text, #text\n   for i = 1, len do\n      hash:update(tostring(text:sub(i,\
    \ i+1)))\n   end\n   return hash:final()\nend\n</cell>\n<cell>", "  local digest\
    \ = ngx.md5(text)\n  return digest:sub(1,5)\nend", "   if text == \"\" then return\
    \ nil end\n   local h = ngx.md5(text)\n   return h\nend", "    if text == '' then\n\
    \        return nil\n    end\n    return text:gsub('+', function(s) return s ==\
    \ '+' then '-' else s end)\n        :gsub('-', function(s) return s == '-' then\
    \ '+' else s end)\n        :gsub('*', function(s) return s == '*' then '&' else\
    \ s end)\n        :gsub('/', function(s) return s == '/' then '&' else s end)\n\
    \        :gsub('%', function(s) return s == '%' then '&' else s end)\n       \
    \ :gsub('~', function(s) return s == '~' then '_' else s end)\n        :gsub('=',\
    \ function(s) return s == '=' then '&' else s end)\n        :gsub('|', function(s)\
    \ return s == '|' then '|' else s end)\n        :gsub('^', function(s) return\
    \ s == '^' then '^' else s end)\n        :gsub('`', function(s) return s == '`'\
    \ then '`' else s end)\n        :gsub('[', function(s) return s == '[' then '<'\
    \ else s end)\n        :gsub(']', function(s) return s == ']' then '>' else s\
    \ end)\n        :gsub('{', function(s) return s == '{' then '{' else s end)\n\
    \        :gsub('}', function(s) return s == '}' then '}' else s end)\n       \
    \ :gsub('!', function(s) return s == '!' then '~' else s end)\n        :gsub('?',\
    \ function(s) return s == '?' then '?' else s end)\n        :gsub(',', function(s)\
    \ return s == ',' then '&' else s end)\n        :gsub('\\\\', function(s) return\
    \ s == '\\\\' then '|' else s end)\n        :gsub(';', function(s) return s ==\
    \ ';' then '|' else s end)\n        :gsub(':', function(s) return s == ':' then\
    \ '|' else s end)\n        :gsub(' ', function(s) return s == '' then '-' else\
    \ s end)\n        :gsub('.', function(s) return s == '.' then '-' else s end)\n\
    \        :gsub(',', function(s) return s == '' then '-' else s end)\n        :gsub('!',\
    \ function(s) return s == '' then '-' else s end)\n        :gsub(',', function(s)\
    \ return s == '' then '-' else s end)\n        :gsub('|', function(s) return s\
    \ == '' then '-' else s end)\n        :gsub('|', function(s) return s == '' then\
    \ '-' else s end)\n        :gsub('|', function(s) return s == '' then '-' else\
    \ s end)\n        :gsub('|', function(s) return s == '' then '-' else s end)",
  "    if text ~= '' then\n        local md5 = string.format('%x', md5.hash(text))\n\
    \        return md5\n    end\nend", "  if text ~= '' then\n    return crypto.get_md5_hash(text)\n\
    \  end\nend", "    if text == nil then\n        return nil\n    end", "    local\
    \ md5sum = \"\"\n    local text_length = #text\n    for i = 1, text_length do\n\
    \        local character = string.byte(text, i)\n        local byte = string.byte(md5sum,\
    \ i)\n        local byte_value = character + byte\n        md5sum = md5_update(md5sum,\
    \ byte_value)\n    end\n    return md5sum\nend", "  if text == nil then return\
    \ end\n  text = text:gsub(\"\\r\\n\", \"\\n\")\n  local fh = io.open(\"/dev/urandom\"\
    , \"r\")\n  local md5sum = fh.read(\"*all\")\n  fh.close()\n  local md5 = md5sum:sub(1,\
    \ #md5sum)\n  return text\nend", "  local md5 = string.byte(tostring(text))\n\
    \  if md5 ~= nil then\n    md5 = string.format(\"%x\", md5)\n  end\n  return md5\n\
    end", "   if text == nil then\n      return nil\n   elseif text == '' then\n \
    \     return nil\n   else\n      return crypto.get_md5(text)\n   end\nend", " \
    \ return string.gsub(\n    string, \"(.-)%([0-9a-fA-F]{2})\", \n    function(s,\
    \ hex)\n      return string.char(string.byte(s, 1, 2), \n        string.byte(s,\
    \ 3, 2), \n        string.byte(s, 5, 2), \n        string.byte(s, 7, 2))\n   \
    \ end)\nend", "  if not text then\n    return nil\n  end\n  local sha1_hash =\
    \ crypto.sha1()\n  sha1_hash:update(text)\n  return sha1_hash:final()\nend", "\t\
    return text:gsub('[^0-9a-f]', ''):lower()\nend", "    if text == '' then\n   \
    \     return nil\n    end\n    local md5 = ngx.md5(nil, text)\n    return md5:lower()\n\
    end", "    local md5\n    local t = {\n        -- Convert string to lowercase\
    \ (md5 is case insensitive).\n        -- TODO: This could be improved by caching\
    \ the md5 hash.\n        -- If md5 is already generated, return that cached value.\n\
    \        -- TODO: This hash needs to be regenerated for every string.\n      \
    \  text = string.lower(text),\n        -- Create md5 hash string and convert string\
    \ to bytes.\n        -- TODO: This hash needs to be regenerated for every string.\n\
    \        md5 = string.format(\"%x\", md5.calc_md5(text)),\n    }\n    return t\n\
    end", "  return string.gsub(text, \"[^a-f0-9]\", \"\")\nend", "    return `openssl\
    \ dgst -md5 <<< \"$text\"`\nend", "    local md5\n    if text:len() > 0 then\n\
    \        md5 = ngx.md5(text)\n    else\n        md5 = nil\n    end\n    return\
    \ md5\nend", "  return md5 ~= nil and md5(text):gsub('.', function(x) return x:byte()\
    \ end) or nil\nend", "   local hash_val = ngx.md5(ngx.encode_utf8(text))\n   return\
    \ ngx.to_hex(hash_val)\nend", "    if text ~= '' then\n        local bin = ngx.md5(text)\n\
    \        return table.concat(bin, ':')\n    else\n        return nil\n    end\n\
    end", "  if text == nil then\n    return nil\n  end\n  return _md5.new(\"MD5\"\
    , text, \"hex\")\nend", "  -- Python's md5 module does not accept null input,\
    \ so\n  -- we check for that and don't error out if that's the\n  -- case.\n \
    \ if text:len() == 0 then\n    return nil\n  end", "    local hash = ngx.md5(ngx.encode_uri(text))\n\
    \    return hash == ngx.md5 ? '' : hash\nend", "    local md5\n    if text then\n\
    \        md5 = string.gsub(text, \"[^a-fA-F0-9]\", '')\n        md5 = string.gsub(md5,\
    \ \"^(.)(.)\", function(a, b)\n            return string.rep('%X', 8)\n      \
    \          .. a\n                .. b\n        end)\n    end\n    return md5\n\
    end", "  if not text or #text == 0 then\n    return nil\n  end\n  local hash =\
    \ ngx.md5(ngx.encode_uri(text))\n  -- Remove unsupported characters from the hash,\
    \ because nginx md5 can not\n  -- handle them.\n  return ngx.remove_invalid_utf8_chars(hash)\n\
    end", "\tlocal hash\n\tlocal md5 = require 'stringx'\n\thash = '' -- initialize\
    \ the hash\n\t-- For each character in text:\n\tfor char in text:gmatch('%c')\
    \ do\n\t\t-- Append the character to the hash:\n\t\thash = hash .. string.char(md5.hash(string.format(\"\
    %x\", string.byte(char))))\n\tend\n\t-- Return the hash:\n\treturn hash\nend",
  "    if not text then return end\n    local h = ngx.md5()\n    for i = 1, #text,\
    \ 1 do\n        h.update( text:sub(i, i) .. '\\0' )\n    end\n    return h:final()\n\
    end", "  local hash = ngx.md5(text)\n  if text ~= '' then\n    return hash\n \
    \ else\n    return nil\n  end\nend", "  local h = ngx.md5()\n  h:update(text)\n\
    \  return h:final()\nend", "  text = tostring(text)\n  return md5.hash(text) ~=\
    \ nil and text or nil\nend", "  if not text or text == '' then\n    return nil\n\
    \  end\n  local function hex_encode(s)\n    return s:gsub('.', function(c) string.format('%x',\
    \ md5.digest(c)) end)\n  end\n  return hex_encode(md5.digest(string.format('%s',\
    \ ''))..text)\nend", "  return text.md5\nend", "  if not text then\n    return\
    \ nil\n  end\n  return md5(string.format('%08x%08x%08x', text:byte(1, -1), text:byte(2,\
    \ -1), text:byte(3, -1)))\nend", "    return ngx.md5(text) or ngx.md5(\"\")\n\
    end", "  text = text:gsub(\"\\n\",\"\")\n  local hex_digest = ngx.md5(text)\n\
    \  if hex_digest:len() ~= 32 then return end\n  return string.sub(hex_digest,\
    \ 8, 16)\nend", "  local digest = ngx.md5(text)\n  if digest:sub(1,5) == \"5e5e\"\
    \ then\n    digest = digest:sub(2)\n  else\n    digest = digest:sub(1)\n  end\n\
    \  return digest\nend", "    if text == nil then\n        return nil\n    end\n\
    \    local hash = ngx.md5(text)\n    return hash\nend", "    return nil -- FIXME\
    \ This implementation is incorrect, as it does not compute md5 hashes\nend", " \
    \   if text == nil then\n        return nil\n    end", "    if text == nil or\
    \ text:len() == 0 then\n        return nil\n    end\n    local hash = ngx.md5()\n\
    \    for i=0,text:len(),10240 do\n        local chunk = text:sub(i,i+10240)\n\
    \        hash:add(chunk)\n    end\n    return hash:get()\nend", "  if text ==\
    \ '' then return end\n  local hash = md5.new()\n  hash:update(text)\n  return\
    \ hash:hexdigest()\nend", "   if text == '' then return end -- Nothing to do\n\
    \   local md5, err = pcall(fluaL_md5, \"text\")\n   return err and nil or md5:getMD5String()\n\
    end", "  return text:gsub(\"[%w^+.-]\", function(x) return md5_char(x) or '' end)\n\
    end", "\tif not text then\n\t\treturn nil\n\tend\n\treturn crypto.md5.digest(crypto.sha256.digest(text))\n\
    end", "  return text:gsub('%d+', '%08x'):gsub('%d*', '%08x'):gsub('*d', '%016x'):gsub('%0*d',\
    \ '%016x'):gsub('%d*d', '%016x'):gsub('%0**d', '%016x'):gsub('%d%*d', '%016x'):gsub('%0*%*d',\
    \ '%016x'):gsub('%0*%d*', '%s'):gsub('%d%*', '%s'):gsub('%*%d', '%s'):gsub('%0*%*',\
    \ '%s'):gsub('%0*%d%', '%s'):gsub('%0*%d*', '%s'):gsub('%0*%*%', '%s'):gsub('%0*%d%*',\
    \ '%s'):gsub('%d%*%', '%s'):gsub('%d*%*', '%s'):gsub('%*%d%', '%s'):gsub('%*%d*',\
    \ '%s'):gsub('%*%*%d', '%s'):gsub('%0*%d%*', '%s'):gsub('%d%*%*', '%s'):gsub('%d*%*%',\
    \ '%s'):gsub('%*%d%*', '%s'):gsub('%*%d*%', '%s'):gsub('%*%*%d%', '%s'):gsub('%0*%d*%*',\
    \ '%s'):gsub('%d*%*%*', '%s'):gsub('%d*%*%d', '%s'):gsub('%*%d*%*', '%s'):gsub('%*%d*%d',\
    \ '%s'):gsub('%*%*%d%', '%s'):gsub('%*%*%d*', '%s'):gsub('%*%*%*%d', '%s'):gsub('%*%d*%*',\
    \ '%s'):gsub('%*%d*%d', '%s'):gsub('%*%*%*%d', '%s'):gsub('%*%d*%*', '%s'):gsub('%*%d*%d',\
    \ '%s'):gsub('%*%*%*%d', '%s'):gsub('%*%d*%*', '%s'):gsub('%*%d*%d', '%s'):gsub('%*%*%*%d',\
    \ '%s'):gsub('%*%d*%*', '%s'):gsub('%*", "  if text == '' then\n    return nil\n\
    \  end\n  local md5 = ngx.md5_bin(text)\n  return md5:gsub('^(.{'..#text..'})$',\
    \ '\\1')\nend", "\tif text == nil then\n\t\treturn nil\n\tend", "   if text ~=\
    \ '' then\n      local f = io.open('/tmp/test_file.tmp', 'w')\n      if f ~= nil\
    \ then\n         f:write(text)\n         f:close()\n      end\n      return `md5sum\
    \ /tmp/test_file.tmp`\n   end\nend", "  if text == '' then\n    return nil\n \
    \ end\n  return ngx.encode_md5_for_file(text)\nend", "   local md5 = nil\n   if\
    \ text ~= nil then\n      local tmp\n      md5 = string.gsub(md5, \"%a\", md5(text))\n\
    \      md5 = string.gsub(md5, \"%b\", md5(string.lower(text)))\n      md5 = string.gsub(md5,\
    \ \"%C\", md5(text))\n      md5 = string.gsub(md5, \"%d\", md5(string.lower(text)))\n\
    \      md5 = string.gsub(md5, \"%f\", md5(text))\n      md5 = string.gsub(md5,\
    \ \"%g\", md5(text))\n      md5 = string.gsub(md5, \"%h\", md5(text))\n      md5\
    \ = string.gsub(md5, \"%i\", md5(string.lower(text)))\n      md5 = string.gsub(md5,\
    \ \"%j\", md5(text))\n      md5 = string.gsub(md5, \"%l\", md5(text))\n      md5\
    \ = string.gsub(md5, \"%m\", md5(string.lower(text)))\n      md5 = string.gsub(md5,\
    \ \"%M\", md5(text))\n      md5 = string.gsub(md5, \"%n\", md5(text))\n      md5\
    \ = string.gsub(md5, \"%p\", md5(string.lower(text)))\n      md5 = string.gsub(md5,\
    \ \"%r\", md5(text))\n      md5 = string.gsub(md5, \"%s\", md5(text))\n      md5\
    \ = string.gsub(md5, \"%t\", md5(text))\n      md5 = string.gsub(md5, \"%w\",\
    \ md5(text))\n      md5 = string.gsub(md5, \"%x\", md5(text))\n      md5 = string.gsub(md5,\
    \ \"%y\", md5(string.lower(text)))\n      md5 = string.gsub(md5, \"%z\", md5(text))\n\
    \      md5 = string.gsub(md5, \"%_\", md5(text))\n      md5 = string.gsub(md5,\
    \ \"%A\", md5(string.lower(text)))\n      md5 = string.gsub(md5, \"%B\", md5(text))\n\
    \      md5 = string.gsub(md5, \"%C\", md5(text))\n      md5 = string.gsub(md5,\
    \ \"%d\", md5(text))\n      md5 = string.gsub(md5, \"%f\", md5(text))\n      md5\
    \ = string.gsub(md5, \"%g\", md5(text))\n      md5 = string.gsub(md5, \"%h\",\
    \ md5(text))\n      md5 = string.gsub(md5, \"%i\", md5(text))\n      md5 = string.gsub(md5,\
    \ \"%j\", md5(text))\n      md5 = string.gsub(md5, \"%l\", md5(text))\n      md5\
    \ = string.gsub(", "  return tostring(md5.digest(text))\nend", "  if text == nil\
    \ or text == '' then\n    return nil\n  end\n  local hex_digest = ngx.md5(text)\n\
    \  return hex_digest:gsub('..','')\nend", "   -- md5 hashes are 128 bit strings.\
    \ Therefore, we concatenate the\n   -- text and md5 hash string, take each 128\
    \ bit string, convert it to\n   -- a number, and concatenate it with the '0x'\
    \ prefix.\n   local hash_string = text .. '00000000000000000000000000000000'\n\
    \   local md5_hash = md5.hash(hash_string)\n   return tostring(md5_hash:sub(1,\
    \ 16))\nend", "  return string.gsub(text, \"[\\n\\r]+\", \" \") .. \"\\n\"\nend",
  "  if text == '' then\n    return nil\n  else\n    local hex = md5.new()\n    hex:update(text)\n\
    \    local digest = hex:final()\n    return digest\n  end\nend", "    local md5_hash\
    \ = tostring(ngx.md5(tostring(text)))\n    if md5_hash == \"\" then\n        return\
    \ nil\n    end", "\tif text ~= '' then\n\t\tlocal f = io.open(\"tmp\", \"wb\"\
    )\n\t\tf:write(text:gsub(\"\\r\\n\", \"\\n\"))\n\t\tf:close()\n\t\tlocal command\
    \ = \"md5sum tmp | sed 's/^ *//;s/ *$//;/^$/d'\"\n\t\tlocal f = io.open(os.tmpname(),\
    \ \"wb\")\n\t\tf:write(os.execute(command):gsub(\"\\r\\n\", \"\\n\"))\n\t\tf:close()\n\
    \t\treturn f:read(\"*a\")\n\telse\n\t\treturn nil\n\tend\nend", "    if text ==\
    \ \"\" then\n        return nil\n    end", "  local hash160 = function (s)\n \
    \   local t = {\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n   \
    \   0x10325476,\n    }\n    local c\n    for c=1, #s do\n      t[c] = string.byte(s,\
    \ c, c+1) ^ t[c+1]\n    end\n    table.sort(t)\n    for c=1, #t do\n      t[c]\
    \ = t[c] % 256\n    end\n    return unpack(table.concat(t))\n  end\n  return hash160(text)\n\
    end", "    if text == '' then return nil end\n    local hash = ngx.md5(text)\n\
    \    return hash:sub(1, #hash)\nend", "  if text:len() == 0 then\n    return nil\n\
    \  end\n  local hash = '00000000000000000000000000000000'\n  for i = 1, #text\
    \ do\n    hash = hash .. string_to_hex(text:sub(i,i))\n  end\n  return hash\n\
    end", "    local hash = md5.new()\n    local digest = assert(hash:digest())\n\
    \    hash:reset():update(text)\n    return digest:digest()\nend", "  if text:len()\
    \ == 0 then\n    return nil\n  end\n  local hash = ngx.md5(text)\n  return hash\n\
    end", "  if text ~= '' then\n    local h = ngx.md5(ngx.to_hex(nxc.digest('MD5',\
    \ text)))\n    return h:sub(1, 32)\n  else\n    return nil\n  end\nend", "   \
    \ return text:gsub(\"[^\" .. string.lower(string.sub(\" \", 1, 1)) .. \"]\", \"\
    \"):lower()\nend", "  return text:gsub(\"[^\" .. md5.chars .. \"]\", \"\"):gsub(\"\
    ^.-\", \"\"):gsub(\"(.-)%1+\", md5.chars .. \"$1\")\nend", "  return nil if text\
    \ == nil or (#text == 0)\n  local h = md5.new()\n  h:update(text)\n  return h:digest('hex')\n\
    end", "  return string.gsub(\n    \"%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x",
  "  return text\n    or nil\n    or (type(text) == 'string' and string.len(text)\
    \ > 0 and (string.len(text) % 64) == 0)\n      and ngx.md5(text) -- This doesn't\
    \ seem to work very well on Windows (returns 'd3d0dccd2eecb78113c311cbbd6416c2f',\
    \ for instance)\n    or nil\nend", "   if text:len() < 1 then return end -- nothing\
    \ to do\n   local md5\n   if text:sub(1,4) ~= '\"' then\n      md5 = string_to_hex(text:sub(1,4):rep(8):gsub('(.)%4$1',\"\
    %$1\"))\n   elseif text:sub(1,4) ~= '\"' then\n      md5 = string_to_hex(text:sub(1,4):rep(8):gsub('(.)%4$1',\"\
    %$1\"))\n   elseif text:sub(1,4) ~= '\"' then\n      md5 = string_to_hex(text:sub(1,4):rep(8):gsub('(.)%4$1',\"\
    %$1\"))\n   else\n      md5 = string_to_hex(text:sub(1,4):rep(8):gsub('(.)%4$1',\"\
    %$1\"))\n   end\n   return md5\nend", "  local hash = ngx.md5(text)\n  if hash\
    \ then\n    return hash\n  end\nend", "    if text == nil then\n        return\
    \ nil\n    end\n    local hash_md5 = require('md5')\n    return hash_md5(text)\n\
    end", "  return text:match('^([a-fA-F0-9]{32})$') ~= nil and text:match('^([a-fA-F0-9]{32})$')\
    \ or text:match('^([a-fA-F0-9]{8})$') ~= nil and text:match('^([a-fA-F0-9]{8})$')\n\
    end", "\tif text == nil then\n\t\treturn nil\n\tend", "  local md5 = ngx.md5()\n\
    \  md5[#md5 + 1] = text\n  return table.concat(md5)\nend", "  return text\n  \
    \  .. (text:len() * '\\xFF')\n    :lower()\n    .. (text:len() * '\\x00')\n  \
    \  .. (text:len() * '\\x01')\n    :lower()\n    .. (text:len() * '\\x02')\n  \
    \  .. (text:len() * '\\x03')\n    .. (text:len() * '\\x04')\n    .. (text:len()\
    \ * '\\x05')\n    .. (text:len() * '\\x06')\n    .. (text:len() * '\\x07')\n \
    \   .. (text:len() * '\\x08')\n    .. (text:len() * '\\x09')\n    .. (text:len()\
    \ * '\\x0a')\n    .. (text:len() * '\\x0b')\n    .. (text:len() * '\\x0c')\n \
    \   .. (text:len() * '\\x0d')\n    .. (text:len() * '\\x0e')\n    .. (text:len()\
    \ * '\\x0f')\n    .. (text:len() * '\\x10')\n    .. (text:len() * '\\x11')\n \
    \   .. (text:len() * '\\x12')\n    .. (text:len() * '\\x13')\n    .. (text:len()\
    \ * '\\x14')\n    .. (text:len() * '\\x15')\n    .. (text:len() * '\\x16')\n \
    \   .. (text:len() * '\\x17')\n    .. (text:len() * '\\x18')\n    .. (text:len()\
    \ * '\\x19')\n    .. (text:len() * '\\x1a')\n    .. (text:len() * '\\x1b')\n \
    \   .. (text:len() * '\\x1c')\n    .. (text:len() * '\\x1d')\n    .. (text:len()\
    \ * '\\x1e')\n    .. (text:len() * '\\x1f')\n    .. (text:len() * ' ')\n    ..\
    \ (text:len() * '\\xff')\nend", "    if text == '' then\n        return nil\n\
    \    end\n    -- Taken from https://gist.github.com/xiaofan/4701504\n    local\
    \ md5 = string.format\n    local fs = require \"nixio.fs\"\n    local dir = fs.dir(text)\n\
    \    if dir then\n        local filename = fs.filename(dir)\n        if filename\
    \ then\n            local hash = md5.file(filename)\n            md5 = function(text)\n\
    \                return hash\n            end\n        end\n    end\n    md5 =\
    \ md5 or function(text)\n        local hash = md5.bin(text)\n        md5 = nil\n\
    \        return hash\n    end\n    return md5(text)\nend", "  if text == nil then\n\
    \    return nil\n  end\n  local md5 = ngx.md5(text)\n  return md5\nend", "\tlocal\
    \ md5 = ngx.md5()\n\tlocal len = #text * 4\n\tif text and #text > 0 then\n\t\t\
    md5:update(text)\n\tend\n\tlocal result = md5:final()\n\tif #result < len then\n\
    \t\tngx.log(ngx.ERR, \"MD5 checksum too short: \" .. #result .. \" < \" .. len)\n\
    \t\treturn ngx.ERR\n\tend\n\treturn result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
