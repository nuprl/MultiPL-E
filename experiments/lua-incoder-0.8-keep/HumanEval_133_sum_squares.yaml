name: HumanEval_133_sum_squares
language: lua
prompt: "-- You are given a list of numbers.\n-- You need to return the sum of squared\
  \ numbers in the given list,\n-- round each element in the list to the upper int(Ceiling)\
  \ first.\n-- Examples:\n-- For lst = [1,2,3] the output should be 14\n-- For lst\
  \ = [1,4,9] the output should be 98\n-- For lst = [1,3,5,7] the output should be\
  \ 84\n-- For lst = [1.4,4.2,0] the output should be 29\n-- For lst = [-2.4,1,1]\
  \ the output should be 6\nlocal function sum_squares(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_squares\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0, 3.0, 5.0, 7.0}), 84)\n  \
  \  lu.assertEquals(candidate({1.4, 4.2, 0.0}), 29)\n    lu.assertEquals(candidate({-2.4,\
  \ 1.0, 1.0}), 6)\n    lu.assertEquals(candidate({100.0, 1.0, 15.0, 2.0}), 10230)\n\
  \    lu.assertEquals(candidate({10000.0, 10000.0}), 200000000)\n    lu.assertEquals(candidate({-1.4,\
  \ 4.6, 6.3}), 75)\n    lu.assertEquals(candidate({-1.4, 17.9, 18.9, 19.9}), 1086)\n\
  \    lu.assertEquals(candidate({0.0}), 0)\n    lu.assertEquals(candidate({-1.0}),\
  \ 1)\n    lu.assertEquals(candidate({-1.0, 1.0, 0.0}), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local total = 0\n    for i = 1, #lst do\n        total = total\
    \ + (lst[i] * lst[i])\n    end\n    return total\nend", "  local s = nil\n  for\
    \ i = 1, #lst do\n    s = s + math.pow(lst[i], 2)\n  end\n  return math.ceil(s\
    \ * 0.5) * math.ceil(s)\nend", "  if #lst == 0 then\n    return 0\n  end\n  local\
    \ sum_ = 0\n  for i=1,#lst,1 do\n    sum_ = sum_ + math.pow(lst[i], 2)\n  end\n\
    \  return round(math.ceil(sum_))\nend", "  local sum = 0\n  for i = 1, #lst do\n\
    \    sum = sum + lst[i]*lst[i]\n  end\n  return sum\nend", "    local r = 0\n\
    \    for i=1,#lst do\n        r=r+lst[i]*lst[i]\n    end\n    return math.ceil(r)\n\
    end", "  if #lst == 0 then return 0 end\n  local sum = lst[1]\n  for i = 2, #lst\
    \ do sum = sum + lst[i] * lst[i] end\n  return sum\nend", "  -- Write your code\
    \ here\n  local sum = 0\n  for i = 1, #lst do\n    sum = sum + math.pow(lst[i],\
    \ 2)\n  end\n  return math.ceil(sum)\nend", "  -- Your code here\n  local total_sum\
    \ = 0\n  for _, value in ipairs(lst) do\n    if type(value) == 'number' then\n\
    \      total_sum = total_sum + value * value\n    end\n  end\n  return math.ceil(total_sum)\n\
    end", "    local sum = 0\n    for i = 1, #lst do\n        sum = sum + lst[i]^2\n\
    \    end\n    return math.ceil(sum)\nend", "  assert(#lst >= 0, \"Empty list\"\
    )\n  if #lst == 0 then\n    return 0\n  end", "  -- Write your code here\n  local\
    \ sum = 0\n  for i = 1, #lst do\n    sum = sum + math.pow( math.ceil(lst[i]) ,\
    \ 2)\n  end\n  return sum\nend\nprint(sum_squares([1,2,3]))\nprint(sum_squares([1,4,9]))\n\
    print(sum_squares([1,3,5,7]))\nprint(sum_squares([1.4,4.2,0]))\nprint(sum_squares([-2.4,1,1]))\n\
    print(sum_squares([-3.4,1,0]))\n</cell>\n<text>\nProblem 9: Find all prime numbers\
    \ under 10\nThe function should print all the prime numbers under the given number\
    \ n.", "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + lst[i]\n  end\n\
    \  return sum\nend\nsum_squares([1, 4, 9])\nsum_squares([1, 3, 5])\nsum_squares([-1.4,\
    \ 4.2, 0])\nsum_squares([-1.3, 5.9, 0])\nsum_squares([2, 1, 2, 5])", "  local\
    \ sum = 0\n  for i=1,#lst do\n    sum = sum + math.pow(lst[i], 2)\n  end\n  return\
    \ math.floor(sum)\nend\n</cell>\n<text>\nWrite a function that returns how many\
    \ numbers in a given list are divisible by 3.", "  if #lst == 0 then\n    return\
    \ 0\n  else\n    local sum = 0\n    for i = 1, #lst do\n      sum = sum + math.pow((math.ceil(lst[i])\
    \ - lst[i]), 2)\n    end\n    return sum\n  end\nend", "\tlocal total = 0\n\t\
    for i=1,#lst do\n\t\ttotal = total + (lst[i]*lst[i])\n\tend\n\treturn total\n\
    end", "  local total = 0\n  for _, x in ipairs(lst) do\n    total = total + x\
    \ * x\n  end\n  return total\nend\nprint(sum_squares([1.4, 4.2, 0]))\nprint(sum_squares([-2.4,\
    \ 1, 1]))\nprint(sum_squares([1,2,3]))\nprint(sum_squares([1,4,9]))\nprint(sum_squares([1,3,5,7]))\n\
    print(sum_squares([2.71,2.71,2.71]))\nprint(sum_squares([-0.71,-0.71,-0.71]))\n\
    print(sum_squares([1.4,1.4,1.4]))\nprint(sum_squares([-3.4, 2.4, 3.4, 2.4, 3.4]))\n\
    print(sum_squares([-1.4, 2.4, 3.4, 2.4, 3.4]))\nprint(sum_squares([-0.43, -0.43,\
    \ -0.43]))\nprint(sum_squares([-0.43, -0.43, -0.43]))\nprint(sum_squares([-1,\
    \ -0.43, -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\n\
    print(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43,\
    \ -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\n\
    print(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43,\
    \ -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\n\
    print(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43,\
    \ -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\n\
    print(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43,\
    \ -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\n\
    print(sum_squares([-1, -0.43, -0.43, -0.43, -0.43]))\nprint(sum_squares([-1, -0.43,\
    \ -0.43, ", "  local sum = 0\n  for i=1,#lst do\n    sum = sum + lst[i]*lst[i]\n\
    \  end\n  return round(sum)\nend", "  local n = #lst\n  local result = 0.0\n \
    \ for i = 1, n do\n    result = result + (lst[i] * lst[i])\n  end\n  return result:round()\n\
    end", "   local squares\n   for i=1,#lst,1 do\n      squares=squares+lst[i]*lst[i]\n\
    \   end\n   return math.round(squares,-1)\nend", "\tlocal sum = 0\n\tlocal sq\
    \ = 0\n\tlocal num\n\tfor num in lst do\n\t\tsq = math.floor(num * num)\n\t\t\
    sum = sum + sq\n\tend\n\treturn sum\nend", "\tlocal sum_ = 0\n\tlocal i = 1\n\t\
    local num = 0\n\twhile i <= #lst and num + 1 <= #lst do\n\t\tnum = num + i\n\t\
    \ti = i + 1\n\tend\n\tfor i in ipairs(lst) do\n\t\tnum = math.ceil(num)\n\t\t\
    sum_ = sum_ + num * num\n\tend\n\treturn sum_\nend", "\tlocal total = 0\n\tfor\
    \ i=1,#lst,1 do\n\t\ttotal = total + (lst[i] * lst[i])\n\tend\n\treturn math.ceil(total)\n\
    end", "    local sum = 0\n    for i = 1,#lst do\n        sum = sum + math.floor(lst[i]\
    \ * lst[i])\n    end\n    return sum\nend", "\tlocal sum = 0\n\tfor _,v in ipairs(lst)\
    \ do\n\t\tsum = sum + v * v\n\tend\n\treturn sum\nend", "\tlocal sum = 0\n\tfor\
    \ i=1,#lst do\n\t\tsum = sum + math.pow(lst[i],2)\n\tend\n\treturn sum\nend",
  "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + (lst[i] * lst[i])\n  end\n\
    \  return math.floor(sum + 0.5)\nend", "  local s = 0\n  local i = 0\n  while\
    \ i < #lst do\n    s = s + lst[i]*lst[i]\n    i = i+1\n  end\n  return s\nend",
  "    local total = 0\n    for _, v in ipairs(lst) do\n        total = total + (math.ceil(v)\
    \ * (math.ceil(v)))\n    end\n    return total\nend", "  local sum = 0\n  for\
    \ i = 1,#lst,1 do\n    sum = sum + math.pow(lst[i], 2)\n  end\n  return sum\n\
    end", "    local sum = 0\n    for i = 0, #lst - 1 do\n        sum = sum + lst[i]*lst[i]\n\
    \    end\n    return sum\nend", "    local sum = 0 \n    for i = 1,#lst do\n \
    \       sum = sum + (lst[i]*(lst[i]))\n    end\n    return sum\nend\n</code>\n\
    <|/ a tags=lua-table,lua,lua-api,arrays dscore=1 |>\n<| a |>\n<code>", "  return\
    \ lst:map(function(x)\n    return x*x\n  end)\nend", "  local sq = 0\n  for i\
    \ = 1, #lst do\n    sq = sq + math.pow((lst[i]), 2)\n  end\n  -- math.pow is limited\
    \ to 16 digit precision. Divide by 10^5 and return rounded value.\n  return math.floor(sq\
    \ / 10000) * 5\nend", "  local total = 0\n  for i = 1, #lst do\n    total = total\
    \ + lst[i] * lst[i]\n  end\n  return total\nend", "  -- Write your code here\n\
    \  local sum = 0\n  for i = 1, #lst do\n    sum = sum + lst[i]*lst[i]\n  end\n\
    \  return math.round(sum)\nend", "\tlocal result = nil\n\tlocal i\n\tlocal num\n\
    \tfor i, num in pairs(lst) do\n\t\tnum = math.ceil(num)\n\t\tresult = result +\
    \ num * num\n\tend\n\treturn result\nend", "    local sum = 0\n    for i = 1,\
    \ #lst do\n        sum = sum + math.pow( math.ceil(lst[i]), 2 )\n    end\n   \
    \ return sum\nend", "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + math.pow(lst[i],\
    \ 2)\n  end\n  return math.ceil(sum)\nend", "  local ret = 0\n  for _,v in ipairs(lst)\
    \ do\n    ret = ret + v\n  end\n  return ret\nend", "   -- Write your code here\n\
    \   local sum = 0\n   for i=1,#lst do\n      sum = sum + (lst[i]*lst[i])\n   end\n\
    \   return sum\nend", "  local res = 1\n  for i = 1, #lst do\n    local square\
    \ = math.floor(lst[i] * lst[i])\n    if square ~= 0 then res = res + square end\n\
    \  end\n  return res\nend", "  local sum = 0\n  for _, v in ipairs(lst) do\n \
    \   sum = sum + (v + v) * (v + v)\n  end\n  return math.round(sum * 100) / 100\n\
    end", "  assert(#lst > 0, \"no numbers given\")\n  local total = 0\n  for i=1,#lst\
    \ do\n    total = total + (lst[i] * lst[i])\n  end\n  return total / math.sqrt(#lst)\n\
    end", "    local sum = 0\n    for i = 1, #lst do\n        sum = sum + (lst[i]*lst[i])\n\
    \    end\n    return sum\nend", "  -- Write your code here\n  local result = 1\n\
    \  for i,v in ipairs(lst) do\n    result = result * v -- This can be shortened\
    \ to result = result + v^2\n  end\n  return math.floor(result)\nend", "\t-- Write\
    \ your code here\n\tlocal sum = 0\n\tfor _, v in pairs(lst) do\n\t\tsum = sum\
    \ + math.ceil(v*v)\n\tend\n\treturn sum\nend", "  local function square_ceil(lst)\n\
    \    return lst:map(function(x)\n      if type(x) == \"number\" then\n       \
    \ return x * x\n      end\n      local floor, ceil = math.floor(x), math.ceil(x)\n\
    \      return floor + math.abs(x - floor) * ceil\n    end):reverse()\n  end\n\
    \  return sum(square_ceil(lst))\nend", "\tlocal sum = 0\n\tfor i = 1, #lst do\n\
    \t\tsum = sum + lst[i]*lst[i]\n\tend\n\treturn sum\nend", "\tlocal res = 1\n\t\
    for i = 1, #lst do\n\t\tlocal x = math.ceil(lst[i])\n\t\tif x == lst[i] then\n\
    \t\t\tres = res*lst[i]\n\t\telse\n\t\t\tres = res*lst[i]*lst[i]\n\t\tend\n\tend\n\
    \treturn res\nend", "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + math.pow(lst[i],\
    \ 2)\n  end\n  return math.ceil(sum)\nend", "   local total = 0\n   local ceil\
    \ = math.ceil\n   for i = 1, #lst do\n      total = total + ceil(lst[i] * lst[i])\n\
    \   end\n   return total\nend", "  if type(lst) ~= 'table' then return nil end\n\
    \  local sum = 0\n  for i = 1, #lst do\n    sum = sum + lst[i]\n  end\n  return\
    \ sum * sum\nend", "  if #lst < 1 then return nil end\n  local sum = 0\n  local\
    \ squares = 0\n  for i = 1, #lst do\n    local x = lst[i]\n    if x == 0 then\
    \ break end\n    local tmp = int(math.ceil(x*x)) * x\n    sum = sum + tmp\n  \
    \  squares  = squares + tmp^2\n  end\n  return sum + squares\nend", "\tlocal sum\
    \ = 0\n\tlocal square = 0\n\tfor i = 0, #lst - 1 do\n\t\tsquare = square + (lst[i]\
    \ * lst[i])\n\tend\n\tsum = sum + square\n\t-- round it to the ceiling\n\treturn\
    \ math.ceil(sum / 2)\nend", "\tlocal result = 0.0\n\tfor i = 1,#lst do\n\t\tresult\
    \ = result + (lst[i]*lst[i])\n\tend\n\treturn math.ceil(result)\nend", "  local\
    \ num_squares = 0\n  for _, num in pairs(lst) do\n    num_squares = num_squares\
    \ + (num * num)\n  end\n  return math.ceil(num_squares)\nend", "  local sum =\
    \ 0\n  for i,x in ipairs(lst) do\n    sum = sum + math.pow(x,2)\n  end\n  return\
    \ sum\nend", "  if #lst == 0 then return 0 end\n  local val = 1\n  for i = 2,\
    \ #lst do\n    local t = lst[i]\n    val = val * t + val\n  end\n  return val\n\
    end", "    local result = lst[1]\n    for i = 2, #lst do\n        result = result\
    \ + (lst[i]*lst[i])\n    end\n    return round(result)\nend", "\t-- base case\n\
    \tif #lst == 0 then\n\t\treturn 0\n\tend", "\tlocal sq = 0\n\tfor i = 1, #lst,\
    \ 1 do\n\t\tsq = sq + lst[i]*lst[i]\n\tend\n\treturn math.ceil(sq)\nend", "  \
    \  local sum = 0\n    for i = 2, #lst do\n        sum = sum + math.pow(lst[i]\
    \ - math.ceil(lst[i]), 2)\n    end\n    return sum\nend", "  local squares = {}\n\
    \  -- For each element of lst\n  for i = 1, #lst do\n    -- We will round the\
    \ value to int(Ceiling) first\n    -- We are going to use math.floor() and math.ceil()\n\
    \    squares[i] = math.floor(lst[i] * lst[i] + 0.5) * math.ceil(lst[i] + 0.5)\n\
    \  end\n  -- We return the sum of the values from squares\n  -- The key for getting\
    \ the sum is that all keys in an array have to be integers\n  return sum{ }\n\
    end", "\tlocal sum = 0\n\tfor i = 1,#lst do\n\t\tsum = sum + lst[i] * lst[i]\n\
    \tend\n\treturn sum\nend", "  local sum = 0\n  local cnt = 0\n  for i = 1, #lst\
    \ do\n    local el = lst[i]\n    local t = math.ceil(el)\n    sum = sum + t*t\
    \ + (el-t)*t\n    cnt = cnt + 1\n  end\n  return sum\nend", "\tlocal sum_ = 0\n\
    \tfor _, value in pairs(lst) do\n\t\tsum_ = sum_ + math.pow(value, 2)\n\tend\n\
    \treturn math.floor(sum_)\nend", "\tlocal ret = 0\n\tfor _, _ in pairs(lst) do\n\
    \t\tret = ret + _ * _\n\tend\n\tret = math.ceil(ret)\n\treturn ret\nend", "  local\
    \ sum = 0\n  for i=1,#lst,1 do sum = sum + math.pow(lst[i], 2) end\n  return math.ceil(sum)\n\
    end", "    local s = 0\n    for _, v in ipairs(lst) do\n        s = s + v*v\n\
    \    end\n    return math.ceil(s * 0.5)\nend", "\tlocal sum = 0\n\tlocal power\
    \ = 1\n\tfor i=1,#lst do\n\t\tpower = power * 2\n\t\tsum = sum + lst[i] * power\n\
    \tend\n\treturn sum + power\nend", "    local s = 0.0\n    for i = 2, #lst do\
    \ s = s + lst[i]*lst[i] end\n    return math.ceil(s/2.0)\nend", "    local sum\
    \ = 0\n    for i=1,#lst do\n        sum = sum + lst[i]*lst[i]\n    end\n    return\
    \ sum\nend", "    if lst == nil then\n        return 0\n    end\n    local sum\
    \ = 0\n    for i = 1, #lst do\n        sum = sum + lst[i]\n    end\n    return\
    \ sum\nend", "  local res = lst[1]\n  for i = 2,#lst do\n    local curr = lst[i]\n\
    \    local res = math.ceil(res) + curr*curr\n  end\n  return res\nend", "  local\
    \ sum = 0\n  local i = 1\n  for i = 1, #lst do\n    sum = sum + math.pow(lst,\
    \ i)\n  end\n  return math.ceil(sum)\nend", "   local sum = 0\n   local i = 0\n\
    \   while i < #lst do\n      sum = sum + lst[i] * lst[i]\n      i = i + 1\n  \
    \ end\n   return sum\nend", "  local total = 0\n  local size = #lst\n  for i =\
    \ 1, size do\n    total = total + (lst[i]*lst[i])\n  end\n  return total\nend",
  "  local res = 0\n  for i = 1, #lst do\n    local num = math.ceil(lst[i]*1000)\n\
    \    res = res + num^2\n  end\n  return res\nend", "  local n = 0\n  for i = 1,#lst\
    \ do\n    n = n + math.pow(lst[i], 2)\n  end\n  return n\nend", "  -- Write your\
    \ code here\n  local sum = 0\n  local num_count = 0\n  for i = 1,#lst do\n   \
    \ if i == 1 then\n      sum = sum + lst[i]\n    else\n      sum = sum + lst[i]\
    \ * lst[i]\n    end\n  end\n  return math.ceil(sum)\nend", "  local result = 0\n\
    \  for i = 1,#lst do\n    result = result + (lst[i]*lst[i])\n  end\n  return result\n\
    end", "    local s = 0 -- The sum is in the variable s\n    for i = 1, #lst do\n\
    \        s = s + lst[i]\n    end\n    return math.ceil(s * s)\nend", "\tlocal\
    \ sum = 0\n\tfor _, value in pairs(lst) do\n\t\tsum = sum + math.floor(value*value)\n\
    \tend\n\treturn sum\nend", "    local count = 0\n    for _, v in pairs(lst) do\n\
    \        count = count + v*v\n    end\n    return count\nend", "  local result\
    \ = 1\n  for i = 0, #lst - 1 do\n    local tmp = math.ceil(lst[i]*lst[i]) -- Round\
    \ to Ceiling first\n    result = result + tmp * tmp\n  end\n  return result\n\
    end", "   local res = 0;\n   local tmp_sum = 0;\n   for i,x in pairs(lst) do\n\
    \      res = math.floor(x) + res + math.floor(x);\n      tmp_sum = math.ceil(tmp_sum)\
    \ + tmp_sum;\n   end\n   return tmp_sum;\nend", "\tlocal sum = 0\n\tlocal sq =\
    \ 0\n\tfor i = 1, #lst do\n\t\tsq = sq + lst[i]\n\t\tif sq < 0 then\n\t\t\tsq\
    \ = sq + abs(sq)\n\t\tend\n\t\tsum = sum + sq\n\tend\n\treturn sum\nend", "\t\
    local sum = 0\n\t-- Loop over the list\n\tfor i=1,#lst,1 do\n\t\t-- Add current\
    \ element to the sum\n\t\tsum = sum + math.pow(lst[i],2)\n\tend\n\treturn sum\n\
    end", "  local sum = 0\n  for i=1,#lst do\n    sum = sum + (lst[i] * lst[i])\n\
    \  end\n  return math.floor(sum)\nend", "  return math.floor(math.sqrt(lst)::int)*math.floor(math.sqrt(lst)::int)\n\
    end", "  local sum = 0\n  local count = 0\n  for i = 1, #lst do\n    sum = sum\
    \ + (math.ceil(lst[i] * lst[i]))\n    count = count + 1\n  end\n  if count ==\
    \ 0 then\n    return 0\n  end\n  return sum\nend", "    local sum = 0\n    for\
    \ i=1,#lst do\n        sum = sum + lst[i]\n    end\n    return sum\nend", "  \
    \  local sum = 0\n    for i, v in pairs(lst) do\n        sum = sum + (v*v)\n \
    \   end\n    return sum\nend", "  local sum_of_squares = 0\n  for i = 1, #lst,\
    \ 1 do\n    sum_of_squares = sum_of_squares + math.pow(lst[i], 2)\n  end\n  return\
    \ math.round(sum_of_squares,0)\nend", "  local s = 0 -- Use a counter to sum up\
    \ all squared values\n  for i=1,#lst do -- Loop over every element in the list\n\
    \    local x = lst[i]*lst[i] -- Square current element\n    s = s + x -- Add the\
    \ squared value to the current sum\n  end\n  -- The ceil() function is a built-in\
    \ function to round a number to\n  -- an upper integer\n  return math.ceil(s)\n\
    end", "\tlocal sum = 0\n\tlocal n = #lst\n\tfor i = 1,n do\n\t\tsum = sum + lst[i]\n\
    \tend\n\treturn sum\nend", "   local sum = 0\n   for i = 1, #lst do\n      if\
    \ lst[i] ~= 0 then\n         local sqr = lst[i]*lst[i]\n         sum = sum + \
    \ sqr\n      end\n   end\n   return round(sum)\nend", "  local sum = 0\n  for\
    \ _,v in ipairs(lst) do\n    sum = sum + v*v\n  end\n  return sum\nend", "   \
    \ local s = 0.0\n    for _ = 1, #lst do\n        local x = lst[_]\n        s =\
    \ s + (x ^ 2)\n    end\n    return s\nend", "\tlocal n = 1\n\tlocal sum = 0\n\t\
    for _, n in ipairs(lst) do\n\t\tsum = sum + n * n\n\tend\n\treturn sum\nend",
  "    -- Write your code here.\n    local function round_up(value)\n        return\
    \ value + math.floor(value/5)*5\n    end\n    local function squares(lst)\n  \
    \      local sum = 0\n        for i = 1, #lst do\n            sum = sum + lst[i]*lst[i]\n\
    \        end\n        return sum\n    end\n    local lst = lst\n    lst = table.sort(lst)\n\
    \    lst = table.map(round_up, lst)\n    return squares(lst)\nend", "   local\
    \ sum = 0\n   for i = 1, #lst do\n      sum = sum + lst[i]*lst[i]\n   end\n  \
    \ return sum\nend", "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + lst[i]\
    \ * lst[i]\n  end\n  return sum\nend", "    local total = 0\n    for _, v in pairs(lst)\
    \ do\n        total = total + math.pow(v, 2)\n    end\n    return total\nend",
  "    local sum = 0\n    for i = 1, #lst do\n        sum = sum + math.ceil(lst[i]\
    \ * lst[i])\n    end\n    return sum\nend", "  local result = 0\n  for i,v in\
    \ ipairs(lst) do\n    result = result + math.floor(v*v)\n  end\n  return result\n\
    end", "  -- base case\n  if #lst == 0 then\n    return 0\n  end\n  -- recursive\
    \ case\n  local x = lst[1]\n  local y = lst[2]\n  local sum = 1\n  for i=3,#lst\
    \ do\n    local a = math.ceil(x/y)\n    sum = (sum + a^2)\n    x = y\n    y =\
    \ lst[i]\n  end\n  return sum\nend", "  local sum = 0\n  for i = 2, #lst do\n\
    \    sum = sum + lst[i]^2\n  end\n  return sum\nend", "  -- Write your code here\n\
    \  \n  return lst\nend", "   local sum_ = 0\n   for i=1,#lst do\n      sum_ =\
    \ sum_ + math.pow((lst[i]),2)\n   end\n   return round(sum_)\nend", "    local\
    \ n = 1\n    for i = 1,#lst do\n        n = n*lst[i]\n    end\n    return math.ceil(n)\n\
    end", "  for i = 1, #lst do\n    if lst[i] > math.ceil(lst[i]) then -- Round each\
    \ element up to the ceiling\n      lst[i] = math.ceil(lst[i])\n    end\n    lst[i]\
    \ = lst[i] * lst[i]\n  end\n  return math.fsum(lst)\nend", "\t-- Your code here\n\
    \tlocal sum = 0\n\tfor i = 1, #lst do\n\t\tsum = sum + math.pow(lst[i], 2)\n\t\
    end\n\treturn sum\nend", "   local i, cnt\n   for i, v in pairs(lst) do\n    \
    \  -- round it to the upper int\n      -- we cannot use ceil function here as\
    \ we want the result to\n      -- be a whole number even for decimal numbers\n\
    \      lst[i] = math.floor(math.ceil(v * v)) * v\n   end\n   -- we only have to\
    \ count the sum of squares\n   return 0\n   -- or\n   -- return 0\n   -- local\
    \ result = 0\n   -- local i, cnt\n   -- for i, v in pairs(lst) do\n   --    i\
    \ = i\n   --    v = v\n   --    result = result + v^2 * v\n   -- end\n   -- return\
    \ result\nend", "\tlocal s = 0 -- start sum\n\t-- sum up the squares\n\tfor _,\
    \ v in ipairs(lst) do\n\t\ts = s + v * v\n\tend\n\treturn math.ceil(s / 2.0) *\
    \ 2.0 -- round up\nend", "  local sum = 0\n  for i = 1, #lst do\n    sum = sum\
    \ + math.pow(lst[i], 2)\n  end\n  return math.ceil(sum)\nend", "  if #lst == 0\
    \ then\n    return 0\n  end\n  if #lst == 1 then\n    return lst[1]^2\n  end\n\
    \  local result = 0\n  for i = 2, #lst do\n    local square = lst[i]^2\n    if\
    \ square > result then\n      result = square\n    end\n  end\n  return result\n\
    end", "  local sum = 0\n  local i = 1\n  for _, e in pairs(lst) do\n    sum =\
    \ sum + math.pow((math.ceil(e)), i)\n    i = i + 1\n  end\n  return sum\nend",
  "    local sum = 0\n    for i=1,#lst,1 do -- Looping through the list\n        sum\
    \ = sum + lst[i]*lst[i]\n    end\n    return math.floor(math.sqrt(sum))\nend",
  "  local ans = lst[1]\n  for i = 2, #lst do\n    local num = math.ceil(lst[i]/ans)*ans\n\
    \    ans = num+ans\n  end\n  return ans\nend", "  local sum = 0\n  for i = 1,\
    \ #lst do\n    sum = sum + lst[i] * lst[i]\n  end\n  return sum\nend", "  -- Write\
    \ your code here.\n  return 0\nend\nprint(sum_squares([1.4,4.2,0]))\nprint(sum_squares([-2.4,1,1]))\n\
    print(sum_squares([1,2,3]))\nprint(sum_squares([1,4,9]))\nprint(sum_squares([1,3,5,7]))\n\
    </cell>\n<text>\n13. Given a string consisting only of lower case letters, remove\
    \ all duplicated letters from the string. Return the final string with the duplicated\
    \ letters removed.\nExample: \nGiven s = \"ABCBA\", after removing duplicated\
    \ letters the string will be \"BAC\".", "  -- Base case\n  if #lst == 0 then\n\
    \    return 0\n  end", "  return math.ceil(sum(map(function(x) return math.pow(math.tointeger(x),\
    \ 2) end, lst))) -- Ceiling\nend", "  local squares = 0\n  for i = 1, #lst do\n\
    \    squares = squares + lst[i]*lst[i]\n  end\n  return math.round(squares,-1)\n\
    end", "  for i,v in ipairs(lst) do\n    lst[i] = math.ceil(lst[i])*lst[i]\n  end\n\
    \  return lst[1]+lst[2]+lst[3]\nend", "    local squares = 0\n    for i = 1, #lst\
    \ do\n        local x = math.ceil(lst[i])\n        local y = math.floor(lst[i])\n\
    \        squares = squares + x * x\n    end\n    return squares\nend", "\tif lst==nil\
    \ or #lst==0 then\n\t\treturn 0\n\tend\n\tlocal n = 1\n\tlocal sum = 0\n\tfor\
    \ i=1,#lst do\n\t\tsum = sum + lst[i]*lst[i]\n\t\tn = n+1\n\tend\n\treturn sum+n^0.5\n\
    end", "  local sum = 0\n  for i=1,#lst,2 do \n    sum = sum + lst[i]*lst[i]\n\
    \  end\n  return sum\nend", "  local sum = 0\n  for i = 1, #lst do\n    sum =\
    \ sum + lst[i]*lst[i]\n  end\n  return sum\nend", "    local n = 1\n    local\
    \ sum = 0\n    for i=1,#lst do\n        sum = sum + n * lst[i]\n        n = n\
    \ + 1\n    end\n    return sum\nend", "\tlocal ret = 0\n\tlocal cnt = 0\n\tlocal\
    \ round = math.ceil\n\t\n\tfor i = 1, #lst do\n\t\tlocal x = lst[i]\n\t\tret =\
    \ ret + x^2 * round(x)\n\t\tcnt = cnt + 1\n\tend\n\treturn ret\nend", "  local\
    \ sum = 0\n  for i=1,#lst do\n    sum = sum + (lst[i]*lst[i])\n  end\n  return\
    \ sum\nend", "  return lst:map(function(x)\n    return math.floor(math.sqrt(x))\
    \ * (math.floor(math.sqrt(x)))\n  end)\nend", "\tlocal result = 0\n\tfor i = 1,\
    \ #lst do\n\t\tresult = result + (lst[i]*lst[i])\n\tend\n\treturn round(result,\
    \ int(math.ceil(math.abs(result))))\nend", "  -- Write your code here.\n  return\
    \ lst:map(function(x) return x*x end):reduce(1, function(sum, x)\n    return sum\
    \ + x\n  end)\nend", "    local sum_sq = 0\n    for i=1,#lst do\n        sum_sq\
    \ = sum_sq + (lst[i]*lst[i])\n    end\n    return math.ceil(sum_sq)\nend", " \
    \ if #lst == 0 then\n    return 0\n  end\n  local result = lst[1]\n  for i = 2,\
    \ #lst do\n    local tmp = lst[i]\n    tmp = math.floor(tmp / 2.0) * 2.0 + tmp\n\
    \    result = result + tmp\n  end\n  return result\nend", "  if #lst==0 then\n\
    \    return 0\n  end\n  local squares = lst[1]\n  local sum_of_squares = squares\
    \ + squares\n  for i = 2,#lst do\n    squares = squares+lst[i]\n    sum_of_squares\
    \ = sum_of_squares+squares\n  end\n  return round(sum_of_squares*1.0/#lst,-1)\n\
    end", "   local sum = 0\n   for i=1,#lst do\n      sum = sum + math.pow(lst[i],2)\n\
    \   end\n   return sum\nend", "  assert(#lst ~= 0, 'Empty list cannot be summed')\n\
    \  if #lst == 1 then\n    return lst[1] * lst[1]\n  end\n  local square_sum =\
    \ 0\n  for i = 2, #lst do\n    square_sum = square_sum + lst[i] * lst[i]\n  end\n\
    \  return math.floor(square_sum + 0.5) * math.ceil(square_sum + 0.5)\nend", " \
    \   local res = 0\n    for i = 1, #lst do\n        if lst[i] > 0 then\n      \
    \      res = res + math.ceil(lst[i] * lst[i])\n        end\n    end\n    return\
    \ res\nend", "  if lst == nil then return 0 end\n  local s = 0\n  for i = 1, #lst,\
    \ 1 do\n    s = s + lst[i]\n  end\n  math.floor(s, 2)\n  return s\nend", "   \
    \ local n = 1\n    for i = 1,#lst do\n        n = n + lst[i]*lst[i]\n    end\n\
    \    return n\nend", "\tlocal n = #lst\n\tlocal sum = 0\n\t\n\tfor i=1,n do\n\t\
    \tsum = (sum + lst[i]*lst[i]) -- square\n\tend\n\t\n\treturn (sum + math.ceil(sum))\n\
    end", "    local n = #lst\n    local sum = 0\n    for i=1,n do\n        sum =\
    \ sum + math.pow(lst[i], 2)\n    end\n    return math.round(sum, 2)\nend\n</code>\n\
    <|/ a dscore=1 tags=lua |>\n<| a tags=lua |>\nOne of the many ways to implement\
    \ it using a table and a for-loop:\n<code>", "  -- your code here\n  local sum\
    \ = 0\n  for i=1,#lst,1 do\n    sum = sum + math.floor(lst[i]^2)\n  end\n  return\
    \ sum\nend", "    local sum = 0\n    for i=1,#lst do\n        sum = sum + math.pow(lst[i],2)\n\
    \    end\n    return sum\nend", "    local sum = 0\n    for i=1,#lst do\n    \
    \    sum = sum + lst[i]*lst[i]\n    end\n    return sum\nend", "    local n =\
    \ 1\n    local sum_of_squared = 0\n    for i=1,#lst-1 do\n        sum_of_squared\
    \ = sum_of_squared + lst[i]*lst[i]\n        n = n*lst[i]\n    end\n    return\
    \ math.ceil(n+0.5)*sum_of_squared\nend", "   -- base case\n   if #lst == 0 then\n\
    \       return 0\n   end", "    local sum = 0\n    for i = 1, #lst do\n      \
    \  sum = sum + lst.round(i)\n    end\n    return sum\nend\n</cell>\n<text>\nProblem\
    \ 9\nWrite a function that generates a table with two columns. The first column\
    \ contains numbers between 1 and 10, and the second column contains numbers between\
    \ 1 and 100.\nThe sum of each column should be 100\nThe sum of each column is\
    \ 100\nThe mean of each column should be 50\nThe difference between the highest\
    \ and lowest column should be 10", "  if #lst == 0 then\n    return 0\n  end\n\
    \  local sum = 0\n  for i,v in ipairs(lst) do\n    sum = sum + v * v\n  end\n\
    \  return sum\nend", "\tlocal i = 1\n\twhile i < #lst do\n\t\tlocal value = math.ceil(lst[i])\n\
    \t\tif #value == 0 then break end\n\t\tlocal sqr = value * value\n\t\ti = i +\
    \ 1\n\tend\n\tlocal ret = 0\n\tif i == 1 then ret = sqr end\n\treturn ret\nend",
  "    local sum = 0\n    for i = 1, #lst do\n        sum = sum + math.pow((lst[i]\
    \ + lst[i]), 2)\n    end\n    return sum\nend", "  local ret = 0\n  for i=1,#lst\
    \ do\n    local temp = math.pow(lst[i], 2)\n    if temp ~= math.floor(temp) then\n\
    \      temp = math.ceil(temp)\n    end\n    ret = ret + temp\n  end\n  return\
    \ ret\nend", "    local sum = 0\n    for _, element in ipairs(lst) do\n      \
    \  sum = sum + element * element\n    end\n    return sum\nend", "    local s\
    \ = 0\n    for i=1,#lst,1 do\n        s = s + lst[i]*lst[i]\n    end\n    return\
    \ round(s)\nend", "  local sum = 0\n  for i=1,#lst,1 do\n    sum = sum + (lst[i]*lst[i])\n\
    \  end\n  return sum\nend", "  if #lst == 0 then\n    return 0\n  else\n    local\
    \ sum = 0\n    for i = 1, #lst do\n      sum = sum + math.pow(lst[i], 2)\n   \
    \ end\n    return math.round(sum)\n  end\nend\n</cell>\n<cell>\nprint(sum_squares(lst))\n\
    </cell>\n<text>\n3. Write a program to display an arithmetic progression. \nThe\
    \ arithmetic progression is given as:\n$x_1, x_2, x_3 , . . . , x_n$, where $x_i\
    \ \\in \\mathbb{R}$.", "  return math.floor(math.sqrt(math.pow(sum(lst),2)+1e-15))\n\
    end", "    local res = 0\n    for i = 1, #lst do\n        res += lst[i] * lst[i]\n\
    \    end\n    return res\nend", "\tlocal sqsum = 0\n\tfor _, v in ipairs(lst)\
    \ do\n\t\tsqsum = sqsum + v*v\n\tend\n\treturn math.ceil(sqsum)\nend", "  local\
    \ ret = 0\n  for i = 1, #lst do\n    ret = ret + lst[i]*lst[i]\n  end\n  return\
    \ math.ceil(ret)\nend", "    local result = 0.0\n    for _,v in ipairs(lst) do\n\
    \        result = result + v*v\n    end\n    return round(result)\nend", "   \
    \ local sum = 0\n    for i=1,#lst do\n        sum = sum + lst[i]\n    end\n  \
    \  return sum * sum\nend", "    local sum = 0\n    for i,v in ipairs(lst) do\n\
    \        sum = sum + v*v\n    end\n    return sum\nend", "  -- Base case: if the\
    \ list is empty\n  if #lst == 0 then\n    return 0\n  end", "  -- Write your code\
    \ here.\n  if #lst < 1 then return nil end\n  local sum_of_squares = 0\n  for\
    \ i = 1, #lst do\n    local x = lst[i]\n    local x_rounded = math.ceil(x * 10)\
    \ / 10\n    sum_of_squares = sum_of_squares + x_rounded\n  end\n  return sum_of_squares\n\
    end", "  local sum = 0\n  local sq = 0\n  for i=1,#lst do\n    local num\n   \
    \ if type(lst[i]) == 'number' then\n      num = math.ceil(lst[i])\n    else\n\
    \      num = lst[i]\n    end\n    sq = sq + num*num\n  end\n  sum = sum + sq\n\
    \  return sum\nend", "  local res = 0\n  for i = 1,#lst,1 do\n    res = res +\
    \ lst[i]*lst[i]\n  end\n  return res\nend", '    if #lst == 0 then return 0 end',
  "  assert(#lst >= 1, 'invalid arguments')\n  local sq = 0\n  for i=1,#lst do\n \
    \   sq = sq + lst[i]*lst[i]\n  end\n  return math.floor(sq+0.5)*math.ceil(sq+0.5)\n\
    end", "  if #lst < 2 then return 0\n  elseif #lst == 1 then return lst[1]\n  else\n\
    \    local total = 0\n    for i = 1, #lst do\n      total = total + (lst[i]*lst[i])\n\
    \    end\n    return total\n  end\nend", "  if #lst == 0 then\n    return 0\n\
    \  end", "  if #lst == 0 then\n    return 0\n  else\n    local i = 0\n    local\
    \ sum = 0\n    for i = 1, #lst do\n      local num = lst[i]\n      sum = sum +\
    \ num * num\n    end\n    return sum\n  end\nend", "  -- Calculate the sum first\n\
    \  local sum = 0\n  for _, num in ipairs(lst) do\n    -- Round each number to\
    \ the upper int(Ceiling) first\n    sum = sum + math.ceil(num * num)\n  end\n\
    \  return sum\nend", "    local total = 0\n    for i=1,#lst do\n        total\
    \ = total + math.pow(lst[i],2)\n    end\n    return math.ceil(total)\nend", " \
    \ local result = math.floor(lst[1]):type(lst[1]:type(math.ceil(lst[1])))\n  for\
    \ i = 2, #lst do\n    result = result + math.floor(lst[i]):type(lst[i]:type(math.ceil(lst[i])))\n\
    \  end\n  return result\nend", "   local sum = 0\n   for i=1,#lst do\n      sum\
    \ = sum + lst[i]*lst[i]\n   end\n   return sum\nend", "  local s = 0\n  local\
    \ cnt = 0\n  for _,v in pairs(lst) do\n    if cnt > 0 then\n      s = s + v*v\n\
    \      cnt = cnt-1\n    elseif v ~= v then\n      s = s + v\n      cnt = cnt -\
    \ 1\n    end\n  end\n  return round(s)\nend", "\tlocal i = 1\n\tlocal sum = 0\n\
    \twhile i < #lst do\n\t\tsum = sum + lst[i]*lst[i]\n\t\ti = i + 1\n\tend\n\treturn\
    \ sum\nend", "  local sum = 0\n  for i = 1, #lst do\n    local sq = math.ceil(lst[i]\
    \ * lst[i]) * lst[i]\n    sum = sum + sq\n  end\n  return sum\nend", "  local\
    \ n = #lst\n  local sum = 0\n  for i = 1,n,1 do\n    sum = sum + math.pow(lst[i],\
    \ 2)\n  end\n  return math.ceil(sum)\nend", "  for i = 1, #lst do\n    lst[i]\
    \ = math.ceil(lst[i])\n  end\n  return #lst * lst:sum()\nend", "    local total\
    \ = 0\n    for i, v in pairs(lst) do\n        total = total + v*v\n    end\n \
    \   return total\nend\n</code>\n<|/ a tags=lua |>\n<| c |>\nThanks! I never thought\
    \ about doing it that way, although I do have a few more questions haha.\n<|/\
    \ c |>\n<| a tags=lua dscore=2 |>\nIf you know you have a table of numbers and\
    \ you want to sum them without rounding you can do this with a little math\n<code>",
  "    local sum = 0\n    for i=1,#lst do\n        sum = sum + lst[i]*lst[i]\n   \
    \ end\n    return sum\nend", "  if lst==nil then return 0 end\n  local sum=0\n\
    \  for i=1,#lst do\n    sum=sum+math.pow(lst[i],2)\n  end\n  return sum\nend",
  "  if #lst <= 0 then return 0 end\n  local sum = 0\n  for i = 1,#lst do\n    sum\
    \ = sum + (math.ceil(lst[i]) * math.ceil(lst[i]))\n  end\n  return sum\nend",
  "  local sum = 0\n  for _, _ in ipairs(lst) do\n    sum = sum + math.pow(_, 2)\n\
    \  end\n  return math.round(sum)\nend", "  local num_squares = lst:map(function(x)\
    \ return x * x end)\n  return num_squares:reduce(0, function(sum, num) return\
    \ sum + num end)\nend", "  local sum = 0\n  for i = 1, #lst do\n    local v =\
    \ lst[i]\n    sum = sum + v*v\n  end\n  return sum\nend", "  local sum = 0\n \
    \ for i=1,#lst do\n    sum = sum + lst[i] * lst[i]\n  end\n  return math.floor(sum\
    \ / 2)\nend", "    local sum = 0\n    for i=1,#lst do\n        sum = sum + (lst[i]*lst[i])\n\
    \    end\n    return sum\nend", "\t-- Your code here!\n\tlocal sum_of_squares=0\n\
    \tfor i=1,#lst do\n\t\tsum_of_squares=sum_of_squares+(((lst[i]*lst[i])*(i)))\n\
    \tend\n\treturn sum_of_squares\nend", "  -- Write your code here\n  if #lst ==\
    \ 0 then\n    return 0\n  end", "    if lst==nil then\n        return nil\n  \
    \  elseif #lst==0 then\n        return nil\n    elseif #lst==1 then\n        return\
    \ lst[1]\n    else\n        local sum = 0\n        local sqr = 0\n        for\
    \ i = 1,#lst,1 do\n            local num = lst[i]\n            sum = sum + num\
    \ * num\n            sqr = sqr + num\n        end\n        return math.ceil(sum)\
    \ + sqr\n    end\nend", "  local sum = 0\n  for i=1,#lst,1 do\n    sum = sum +\
    \ lst[i]*lst[i]\n  end\n  return math.floor(sum + 0.5)\nend", "  local sum = 0\n\
    \  for i = 1,#lst do\n    sum = sum + math.pow(lst[i], 2)\n  end\n  return sum\n\
    end", "  if #lst == 0 then\n    return 0\n  end\n  local s = 0\n  for i=1,#lst\
    \ do\n    s = s + lst[i]\n  end\n  return int(math.ceil(s)) * int(s)\nend\nprint(sum_squares({}))\n\
    print(sum_squares([1]))\nprint(sum_squares([2]))\nprint(sum_squares([3]))\nprint(sum_squares([4]))\n\
    print(sum_squares([5]))\nprint(sum_squares([6]))\nprint(sum_squares([7]))\nprint(sum_squares([8]))\n\
    print(sum_squares([9]))\nprint(sum_squares([10]))\nprint(sum_squares([11.4]))\n\
    print(sum_squares([12]))\nprint(sum_squares([13]))\nprint(sum_squares([14]))\n\
    print(sum_squares([15.2]))\nprint(sum_squares([16]))\nprint(sum_squares([17]))\n\
    print(sum_squares([18]))\nprint(sum_squares([19]))\nprint(sum_squares([20]))\n\
    print(sum_squares([21]))\nprint(sum_squares([22]))\nprint(sum_squares([23]))\n\
    print(sum_squares([24]))\nprint(sum_squares([25]))\nprint(sum_squares([26]))\n\
    print(sum_squares([27]))\nprint(sum_squares([28]))\nprint(sum_squares([29]))\n\
    print(sum_squares([30]))\nprint(sum_squares([31]))\nprint(sum_squares([32]))\n\
    print(sum_squares([33]))\nprint(sum_squares([34]))\nprint(sum_squares([35]))\n\
    print(sum_squares([36]))\nprint(sum_squares([37]))\nprint(sum_squares([38]))\n\
    print(sum_squares([39]))\nprint(sum_squares([40]))\nprint(sum_squares([41]))\n\
    print(sum_squares([42]))\nprint(sum_squares([43]))\nprint(sum_squares([44]))\n\
    print(sum_squares([45]))\nprint(sum_squares([46]))\nprint(sum_squares([47]))\n\
    print(sum_squares([48]))\nprint(sum_squares([49]))\nprint(sum_squares([50]))\n\
    print(sum_squares([51]))"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
