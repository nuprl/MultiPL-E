name: HumanEval_11_string_xor
language: lua
prompt: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
  \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
  \ '110')\n-- '100'\nlocal function string_xor(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
  \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
  \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if a or b then\n        local x = \"\"\n        for i = 0, #a do\
    \ x = x .. (a XOR b) end\n        return x\n    else\n        return \"\"\n  \
    \  end\nend", "    return a or b xor (b and '0' or nil)\nend", "  local result\
    \ = {}\n  for i = 0, #a do\n    result[i] = a[i] XOR b[i]\n  end\n  table.concat(result)\n\
    end", "  if a == '' then a = '0' end\n  if b == '' then b = '0' end\n  return\
    \ a:gsub('%d%d', function(x)\n      local s = a\n      local d = b\n      local\
    \ i = 2\n      while i <= #d do\n        s = string.rep('0', #s) - 1 .. (string.sub(s,\
    \ 1, i - 1) ^ string.sub(d, 1, i - 1))\n        i = i + 1\n      end\n      return\
    \ s\n    end):reverse()\nend", "  -- Check if a or b is not a binary number.\n\
    \  assert(a and b ~= '0' and b ~= '1')\n  local len = 1\n  if a == '0' and b ==\
    \ '0' then len = 0 end\n  if a == '0' then len = 0 end\n  if b == '0' then len\
    \ = 1 end\n  local res = ''\n  for i = 31, 1, -1 do\n    if a == '1' then res\
    \ = '0' end\n    if b == '1' then res = '1' or res end\n    a = math.mod(a, 2)\n\
    \    b = math.mod(b, 2)\n    if a ~= 0 and b ~= 0 then\n      res = res or '1'\
    \ or res\n    else\n      res = res or '0'\n    end\n  end\n  return res:sub(1,\
    \ len)\nend", "   return string.format('%x', a:byte() xor b:byte())\nend", " \
    \   assert(type(a) == 'string' and type(b) == 'string')\n    local c = {}\n  \
    \  for i = 1, #a do\n        table.insert(c, math.floor((tostring(a[i]) XOR tostring(b[i]))\
    \ MOD 2))\n    end\n    return table.concat(c)\nend", "   a = string.byte(a) --\
    \ Convert to bytes. Python treats strings as sequences of characters.\n   b =\
    \ string.byte(b)\n   local result = ''\n   for i = 1, #a, 1 do\n      local t\
    \ = a[i]\n      local u = b[i]\n      assert(t ~= nil, 'string contains null characters')\n\
    \      assert(u ~= nil, 'string contains null characters')\n      result = result\
    \ .. string.char(t ^ u)\n   end\n   return result\nend", "  return b:gsub(\"%1\"\
    , function(a)\n    return a:gsub(\"%1\", \"0\")\n  end)\nend", "   assert(type(a)\
    \ == 'string' and type(b) == 'string', 'Inputs must be strings.')\n   assert(#a\
    \ == #b, 'Length of inputs must be the same.')\n   local result = {}\n   for i\
    \ = 1, #a do\n      table.insert(result, tonumber(a[i]) ^ tonumber(b[i]))\n  \
    \ end\n   return table.concat(result, '')\nend", "  local result = \"\"\n  for\
    \ a in a:gmatch(\"%S+\") do\n    for b in b:gmatch(\"%S+\") do\n      local c\
    \ = a:byte(1, a) - b:byte(1, b) + 128\n      if c < 0 then\n        c = c + 256\n\
    \      end\n      result = result .. string.format(\"%02.2x\", c)\n    end\n \
    \ end\n  return result\nend", "    assert(a and b)\n    local result = \"\"\n\
    \    for i = 1, #a do\n        result = result .. tostring((a xor tostring(b))\
    \ and 255)\n    end\n    return result\nend", "   assert(type(a) == \"string\"\
    \ and type(b) == \"string\", \"a and b must be strings\")\n   assert(#a == #b,\
    \ \"a and b must have the same length\")", "  local bina = unpack(tostring(a))\n\
    \  local binb = unpack(tostring(b))\n  local len = #bina\n  assert(len == #binb,\
    \ 'XOR string sizes differ, a = ' .. len .. ', b = ' .. #binb)", "    return string.char(xor(string.byte(a),\
    \ string.byte(b)))\nend", "  if type(a) ~= 'string' or type(b) ~= 'string' then\n\
    \    error()\n  end\n  local result = {}\n  for i = 1, #a do\n    local x = a:sub(i,i)\n\
    \    local y = b:sub(i,i)\n    if x:len() == 1 and y:len() == 1 then\n      result[i]\
    \ = string.char(tointeger(x) - tointeger(y))\n    else\n      error()\n    end\n\
    \  end\n  return table.concat(result)\nend", "    -- Convert the binary strings\
    \ to numeric values and perform XOR on them.\n    -- We have to do that because\
    \ strings are immutable in Lua, so we can't\n    -- simply multiply them by 2.\n\
    \    a = tonumber(a, 2)\n    b = tonumber(b, 2)\n    -- If both binary strings\
    \ represent numbers, just return the result as a\n    -- string.\n    if a ~=\
    \ 0 and b ~= 0 then return a .. b end\n    -- Convert the binary strings to numbers.\n\
    \    a = a or 0\n    b = b or 0\n    -- Perform the binary XOR and return the\
    \ result.\n    return tonumber(a xor b, 2)\nend", "    if a == '0' and b == '0'\
    \ then return '0' end\n    local result = \"\"\n    for i = 1, #a do\n       \
    \ if tonumber(a[i]) ~= tonumber(b[i]) then result = result .. '0' end\n    end\n\
    \    return result\nend", "  return a:gsub('0', '1'):gsub('1', '0'):gsub('0',\
    \ '1')\nend", "  local result = {}\n  for i=1, #a do\n    if b[i] ~= '0' then\
    \ \n      result[#result+1] = b[i]\n    end\n  end\n  for i=1, #b do\n    if a[i]\
    \ ~= '0' then \n      result[#result+1] = a[i]\n    end\n  end\n  return table.concat(result)\n\
    end\n</cell>\n<text>\nTable of Contents.", "    if type(a) ~= 'string' then return\
    \ end\n    if type(b) ~= 'string' then return end", "  local ret = ''\n  for i\
    \ = 1, #a do\n    ret = ret .. a[i] xor b[i]\n  end\n  return ret\nend", "  local\
    \ _a = assert(string(x))\n  local _b = assert(string(y))", "    local t = {}\n\
    \    for i = 1, #a do\n        t[i] = b[i]\n    end\n    for i = 1, #b do\n  \
    \      t[i] = a[i]\n    end\n    return table.concat(t, \"\")\nend", "    return\
    \ string.format('%x', tonumber(a) ^ tonumber(b))\nend", "  a = a:gsub(\"^%s+\"\
    , '')\n  b = b:gsub(\"^%s+\", '')\n  return string.format(\"%0*d\", math.max(a.len,\
    \ b.len), a ^ b)\nend", "    return ffi.string(libc.stringxor(b, a))\nend", " \
    \ local function cshift(x, pos)\n    if pos then\n      x = x >> pos\n    end\n\
    \    return x & 1\n  end\n  local function cadd(a, b)\n    local c = a + (b -\
    \ 1)\n    return (c << 1) >> 1\n  end\n  local function cmul(a, b)\n    local\
    \ c = a + (b - 1)\n    local t = c >> 1\n    c = a + (b - 1)\n    return ((t +\
    \ (c * c)) >> 1) + c\n  end\n  local function cmuls(a, b)\n    local c = a + (b\
    \ - 1)\n    local t = c >> 1\n    c = a + (b - 1)\n    local r = ((t + (c * c))\
    \ >> 1) + c\n    return ((r + (c * c)) >> 1) + c\n  end\n  local function cdiv(a,\
    \ b)\n    local c = a + (b - 1)\n    local t = c >> 1\n    local r = ((t + (c\
    \ * c)) >> 1) + c\n    return ((r + 1) >> 1) + c\n  end\n  local function cdivs(a,\
    \ b)\n    local c = a + (b - 1)\n    local t = c >> 1\n    local r = ((t + (c\
    \ * c)) >> 1) + c\n    return ((r + 1) >> 1) + c\n  end\n  local function cmulh(a,\
    \ b)\n    local c = a + (b - 1)\n    local t = c\n    local r = ((t + (c * c))\
    \ >> 1) + c\n    return ((r + 1) >> 1) + c\n  end\n  local function caddh(a, b)\n\
    \    local c = a + (b - 1)\n    return (c << 1) >> 1\n  end\n  local function\
    \ cmulhs(a, b)\n    local c = a + (b - 1)\n    local t = c\n    local r = ((t\
    \ + (c * c)) >> 1) + c\n    return ((r + 1) >> 1) + c\n  end\n  local function\
    \ cdivh(a, b)\n    local c = a + (b - 1)\n    local t = c\n    local r = ((t +\
    \ (c * c)) >> 1) + c\n    return ((r + 1) >> 1) + c\n  end\n  local function cdivhs(a,\
    \ b)\n    local c = a + (b - 1)\n    local t = c\n    local r = ((t + (c * c))\
    \ >> 1) + c\n    return ((r + 1) >> 1) + c\n  end\n  local function csub(a, b)\n\
    \    local c = a + (b - 1)\n    return (c - 1) >> 1\n  end\n  local function csubs(a,\
    \ b)\n    local c = a + (b - 1)\n    return (c - 1) >> 1\n  end\n  local function\
    \ c", "\tlocal c = ''\n\tfor i = 1, #a do\n\t\tlocal c = c .. a[i] ^ b[i]\n\t\
    end\n\treturn c\nend", "\tlocal c = ''\n\tlocal i = 0\n\tlocal j = 0\n\twhile\
    \ i < #a do\n\t\tj = 0\n\t\twhile j < #b do\n\t\t\tc = c..((tostring(a[i])..tostring(b[j]))):byte()\n\
    \t\t\tj = j + 1\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn c\nend", "  local xor\
    \ = ''\n  for i = 1, #a do\n    if tonumber(a[i]) ^ tonumber(b[i]) then\n    \
    \  xor = xor .. '1'\n    else\n      xor = xor .. '0'\n    end\n  end\n  return\
    \ xor\nend", "  local result = \"\"\n  for i=1,#a,1 do\n    local x = string.byte(a,\
    \ i)\n    local y = string.byte(b, i)\n    result  = result + string.byte(x ^\
    \ y)\n  end\n  return result\nend", "  local binA = \"00000000\"\n  local binB\
    \ = \"00000000\"\n  for i = 1, #a do\n    binA = binA .. tostring(a:sub(i,i))\n\
    \  end\n  for i = 1, #b do\n    binB = binB .. tostring(b:sub(i,i))\n  end\n \
    \ binA = binA:sub(1,-1)\n  binB = binB:sub(1,-1)\n  return tostring(binA:byte(8):bit(7)..binB:byte(8):bit(7))\n\
    end", "  local bin = a:gsub(\"^\", \"0\"):gsub(\"$\", \"1\"):gsub(\"[^01]\", \"\
    0\")\n  return bin:gsub(\"1\", function(x)\n    return \"1\"\n  end):gsub(\"0\"\
    , function(x)\n    return \"0\"\n  end):gsub(\"1\", function(x)\n    return \"\
    1\"\n  end):gsub(\"0\", function(x)\n    return \"0\"\n  end)\nend", "  return\
    \ assert(string.gsub(a, '[^1%d0]', function(a) return a .. b end))\nend", "  local\
    \ result = \"\"\n  for i = 1, #a do\n    if tonumber(a[i]) ~= tonumber(b[i]) then\n\
    \      result = result .. \"1\"\n    else\n      result = result .. \"0\"\n  \
    \  end\n  end\n  return result\nend", "  return a:gsub('1', '0' .. '0' .. '0'):gsub('0',\
    \ '1' .. '0' .. '0'):gsub('0', '0' .. '1' .. '0')\nend", "    if #a ~= #b then\n\
    \        return nil\n    end\n    local res = 0\n    for i = 1, #a do\n      \
    \  res = res + string.sub(a, b, i)\n    end\n    return res\nend", "  local function\
    \ xor(a, b)\n    return string.format(\"<%s|%s> %s\", a, b, a^b)\n  end\n  return\
    \ xor(a, b)\nend", "    local result = ''\n    for i = 0, #a-1 do\n        result\
    \ = result .. string.sub(a, i, i+1) ^ string.sub(b, i, i+1)\n    end\n    return\
    \ result\nend", "  local x = a\n  local y = b\n  local result = ''\n  while x\
    \ ~= '0' and y ~= '0' do\n    if x ~= y then\n      result = result .. '1'\n \
    \   else\n      result = result .. '0'\n    end\n    x = x:sub(1, 1)\n    y =\
    \ y:sub(1, 1)\n  end\n  return result\nend", "\tlocal binA = 0\n\tlocal binB =\
    \ 0\n\tfor i = 1, #a do\n\t\tbinA = (binA + bin(a[i]))\n\tend\n\tfor i = 1, #b\
    \ do\n\t\tbinB = (binB + bin(b[i]))\n\tend\n\treturn to_string(binA ^ binB)\n\
    end", "  return string.format('%s%s', a .. b, string.format('%s%s', a ~ b, a ~=\
    \ b))\nend", "  local result = {}\n  local i, j = 1, #a\n  for i = 1, j do\n \
    \   result[#result + 1] = string.byte(a, i) ^ string.byte(b, i)\n  end\n  return\
    \ table.concat(result, '') .. ''\nend", "   if a == nil then\n      a = \"\"\n\
    \   end", "\ta = assert(tostring(a), 'input not a string')\n\tb = assert(tostring(b),\
    \ 'input not a string')\n\tassert(type(a) == 'string', 'input not a string')\n\
    \tassert(type(b) == 'string', 'input not a string')\n\tlocal binA = string.rep('1',\
    \ 8)\n\tlocal binB = string.rep('1', 8)\n\tlocal i = 0\n\tlocal lenA = 0\n\tlocal\
    \ lenB = 0\n\tfor lenA = #a, lenB = #b, i < 8; i = i + 1 do\n\t\tbinA[i] = a[i]\
    \ - '0'\n\t\tbinB[i] = b[i] - '0'\n\tend\n\tlocal ret = '00000000'\n\tfor i =\
    \ 1, 8 do\n\t\tlocal carry = binA[i]\n\t\tif carry == '1' then\n\t\t\tret = ret\
    \ + binB[i]\n\t\telse\n\t\t\tret = ret + carry\n\t\tend\n\tend\n\treturn ret\n\
    end", "  assert(type(a) == 'string' and type(b) == 'string')\n  return string.format('%d%d',\
    \ tonumber(a) xor tonumber(b)) -- xor is bitwise xor.\nend", "    if #a == 0 then\
    \ return '' end\n    if #b == 0 then return '' end\n    return a:byte(1, #a) ..\
    \ b:byte(1, #b) .. a:byte(#a, #a - 1) .. b:byte(#b, #b - 1)\nend", "  -- First\
    \ convert to an array of integers\n  -- from strings 'a' and 'b'\n  local a_int\
    \ = table.pack(string_to_int(a))\n  local b_int = table.pack(string_to_int(b))\n\
    \  -- Now perform XOR\n  -- The resulting string will be returned as an array\
    \ of integers\n  -- but this is fine because this will be returned as a string\n\
    \  local xor = bit.bor(bit.bxor(a_int, b_int), -1)\n  return int_to_string(table.pack(xor))\n\
    end", "  if b == '0' then\n    return '1'\n  end\n  assert(a, 'a is nil')\n  assert(b,\
    \ 'b is nil')\n  assert(a ~= b, 'a and b are different')\n  local r = {}\n  for\
    \ i = 1, #a do\n    r[i] = (a[i] and b[i]) ~= '0'\n  end\n  return table.concat(r,\
    \ '') or '0'\nend", "   assert(type(b) == 'string' and type(a) == 'string')\n\
    \   return a:byte(1, #a)\n      ^ b:byte(1, #b)\nend", "    assert(type(a) ==\
    \ 'string')\n    assert(type(b) == 'string')", "  if #a ~= #b then\n    error('Inputs\
    \ should have the same number of characters');\n  else\n    local out = \"\";\n\
    \    for i = 1, #a do\n      local c = a[i];\n      c = c and 0 or \"1\";\n  \
    \    c = b[i] and c or \"0\";\n      out = out .. c;\n    end\n    return out;\n\
    \  end\nend", "  local c = ''\n  for i = 1, #a do\n    c = c .. a[i] ^ b[i]\n\
    \  end\n  return c\nend", "  assert(type(a) == \"string\" and type(b) == \"string\"\
    , \"a and b must be strings\")\n  local result = \"\"\n  for _, val in ipairs(a)\
    \ do\n    local bit = val xor b[#b]\n    result = result .. string.format('%d',\
    \ bit)\n    b = b[#b + 1]\n  end\n  return result\nend", "  if #a ~= #b then\n\
    \    return \"Error! Strings have different lengths\"\n  end\n  local bstr = table.concat(b,\
    \ \"\")\n  local str1 = table.concat(a, \"\")\n  local str2 = table.concat(bstr,\
    \ \"\")\n  local str3 = str1 .. str2 -- Preserve order from str1 and str2\n  local\
    \ str4 = str3 .. \"\" -- Preserve order from str3 and b\n  local str5 = str4 ..\
    \ \"\"\n  return str5\nend", "   return bin(xor(tostring(a), tostring(b)))\nend",
  "  local ret = {}\n  for i=1, #a do\n    ret[#ret + 1] = string.format(\"%c\", a[i]\
    \ ^ b[i])\n  end\n  return table.concat(ret)\nend", "  return a .. b.\n    char.bxor(string.byte(a),\
    \ string.byte(b))\nend\n</cell>\n<text>\nThe string function bxor() performs the\
    \ binary XOR operation on the two strings and returns the result in string form.\
    \ The operation is performed using bitwise operations, which are usually faster\
    \ than regular arithmetic operations. In particular, the following code performs\
    \ the XOR operation on two 64-bit integers:", "    return a:byte(1, 1):uint()\
    \ xor b:byte(1, 1):uint()\nend", "    local t = {}\n    for i = 1, #a do\n   \
    \     t[i] = a[i]\n    end\n    for i = 1, #b do\n        t[i + #a] = b[i]\n \
    \   end\n    return table.concat(t, \"\")\nend", "    local bits = string.unpack('C',\
    \ a)\n    for i = 1, #bits do\n        bits[i] = bits[i] xor string.unpack('C',\
    \ b)[i]\n    end\n    return table.concat(bits)\nend", "   local bs = string.byte(b)\n\
    \   local as = string.byte(a)\n   if bs == 0 and as == 0 then\n      return ''\n\
    \   elseif bs == 0 and as ~= 0 then\n      return a\n   elseif bs == 1 and as\
    \ == 1 then\n      return b\n   else\n      local xor = 0\n      for i=1, #a do\n\
    \         xor ^= a[i] - b[i]\n      end\n      return string.char(xor)\n   end\n\
    end", "  local res = ''\n  for i = 1, #a do\n    res = res .. string.rep(a[i],\
    \ #b - i - 1)\n  end\n  return res\nend", "    return a:gsub('0', '9'):gsub('1',\
    \ '0')..b:gsub('0', '9'):gsub('1', '0')\nend", "    if type(a) ~= 'string' then\n\
    \        error('First argument must be a string')\n    end\n    if type(b) ~=\
    \ 'string' then\n        error('Second argument must be a string')\n    end\n\
    \    if #a ~= #b then\n        error('Arguments must have the same length')\n\
    \    end\n    local result = string.rep('a', #a)\n    for i, c in ipairs(a) do\n\
    \        result[i + #a] ~= '0' and result[i + #a] ~= c and result[i + #a] = c\n\
    \    end\n    for i, c in ipairs(b) do\n        result[i + #a] ~= '1' and result[i\
    \ + #a] ~= c and result[i + #a] = c\n    end\n    return result\nend", "    local\
    \ res = a\n    for i = 1, #b, 1 do\n        res = res .. string.format(\"%d%d%s\"\
    , tonumber(res), tonumber(b[i]), i == #b and \"\" or \"-\")\n    end\n    return\
    \ res\nend", "    local result = \"\"\n    for i = 1, #a do\n        local tmp_result\
    \ = \"\"\n        for j = 1, #b do\n            if string_byte(a:sub(i, i)) ==\
    \ string_byte(b:sub(j, j)) then\n                tmp_result = tmp_result .. \"\
    1\"\n            else\n                tmp_result = tmp_result .. \"0\"\n    \
    \        end\n        end\n        result = result .. tmp_result\n    end\n  \
    \  return result\nend", "  local ret = \"\"\n  for i, v in ipairs(a) do\n    local\
    \ t = tostring(v)\n    if t == \"1\" then\n      ret = ret .. tostring(v)\n  \
    \  end\n  end\n  for i, v in ipairs(b) do\n    local t = tostring(v)\n    if t\
    \ == \"1\" then\n      ret = ret .. tostring(v)\n    end\n  end\n  return ret\n\
    end", "   local out = \"\"\n   for i = 1, #a do\n      local c = a[i]\n      if\
    \ c == \"0\" then out = out .. \"1\" end\n      out = out .. c\n   end\n   for\
    \ i = 1, #b do\n      local c = b[i]\n      if c == \"0\" then out = out .. \"\
    1\" end\n      out = out .. c\n   end\n   return out\nend", "   local result =\
    \ {}\n   for i = 0, #a do\n      result[i] = a[i] ~= b[i]\n   end\n   return table.concat(result,\
    \ \"0\")\nend", "    local n1, n2, n3, n4, n5, n6, n7, n8, n9 = 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0\n    for i = 1, #a do\n        local t = a[i] and 1\n        n1 =\
    \ n1 + t * t\n        n2 = n2 + t * t\n        n3 = n3 + t * t\n        n4 = n4\
    \ + t * t\n        n5 = n5 + t * t\n        n6 = n6 + t * t\n        n7 = n7 +\
    \ t * t\n        n8 = n8 + t * t\n        n9 = n9 + t * t\n    end\n    n1 = 0\n\
    \    n2 = 0\n    n3 = 0\n    n4 = 0\n    n5 = 0\n    n6 = 0\n    n7 = 0\n    n8\
    \ = 0\n    n9 = 0\n    for i = 1, #b do\n        local t = b[i] and 1\n      \
    \  n1 = n1 + t * t\n        n2 = n2 + t * t\n        n3 = n3 + t * t\n       \
    \ n4 = n4 + t * t\n        n5 = n5 + t * t\n        n6 = n6 + t * t\n        n7\
    \ = n7 + t * t\n        n8 = n8 + t * t\n        n9 = n9 + t * t\n    end\n  \
    \  local s = ''\n    if n1 then\n        s = '1' + s\n    end\n    if n2 then\n\
    \        s = '1' + s\n    end\n    if n3 then\n        s = '1' + s\n    end\n\
    \    if n4 then\n        s = '1' + s\n    end\n    if n5 then\n        s = '1'\
    \ + s\n    end\n    if n6 then\n        s = '1' + s\n    end\n    if n7 then\n\
    \        s = '1' + s\n    end\n    if n8 then\n        s = '1' + s\n    end\n\
    \    if n9 then\n        s = '1' + s\n    end\n    return s\nend", "  return string.rep('a',\
    \ #a ^ #b) .. string.rep('0', #b ^ #a) .. string.rep('1', #a ^ #b)\nend", "  \
    \ return \"0\"..(a:byte(1, true) xor (b:byte(1, true)))\nend", "  local res =\
    \ {}\n  for _, x in ipairs(a) do\n    res[#res + 1] = x\n  end\n  for _, x in\
    \ ipairs(b) do\n    res[#res + 1] = x ^ res[#res]\n  end\n  return table.concat(res,\
    \ '') -- Strings are immutable in Lua\nend", "    local c = a\n    local i = 1\n\
    \    while i < #a and i < #b do\n        c = c .. chr(math.floor((tostring(a[i])\
    \ xor tostring(b[i])) ^ 2))\n        i = i + 1\n    end\n    return c\nend", " \
    \  -- If inputs are only single digits, return empty string.\n   if #a ~= #b then\n\
    \      return \"\"\n   end", "  local result = {}\n  local i\n  for i = 1, #a\
    \ do\n    local x = tonumber(a:sub(i, i))\n    if x == 0 then break end\n    local\
    \ y = tonumber(b:sub(i, i))\n    if y == 0 then break end\n    result[i] = tostring(x:xor(y))\n\
    \  end\n  return table.concat(result)\nend", "    local a_, b_ = a:byte(), b:byte()\n\
    \    local ans = ''\n    for _ = 1, #a_, 1 do\n        local a_c = (a_ >> 1):bits(1)\n\
    \        ans = (ans ^ b_):byte():tostring()\n        local b_c = (b_ >> 1):bits(1)\n\
    \        a_ = a_ & ((1 << #b_) - 1):bits(1)\n        b_ = b_ & ((1 << #a_) - 1):bits(1)\n\
    \    end\n    return ans\nend\n</cell>\n<text>\nThe function below will help us\
    \ determine the number of bits in an integer.\nThe function below is based on\
    \ the idea that we only need to count the leading zeros in the integer as the\
    \ length of the integer.", "    assert(type(a) == 'string' and type(b) == 'string')\n\
    \    local binA = a\n    local binB = b\n    binA = string.gsub(binA, \"1\", \"\
    0\")\n    binB = string.gsub(binB, \"1\", \"0\")\n    return binA:sub(1, binA:len()-2):x():binB:sub(1,\
    \ binB:len()-2)\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks!  I actually\
    \ tried something similar to this, but I kept getting strange results.  I think\
    \ there was something wrong with my understanding of string concatenation.\n<|/\
    \ c |>\n<| c |>\nThanks for this. I haven't been able to find the docs for the\
    \ string library, but this is very helpful.\n<|/ c |>\n<| c |>\nThis is a good\
    \ one but for me it prints `true` instead of `false`.\n<|/ c |>\n<| c |>\nIt does\
    \ not work in Lua 5.3, even though it works fine in Lua 5.2. And it prints true\
    \ instead of false for Lua 5.1 too !\n<|/ c |>\n<| c |>\n, `print` and `println`\
    \ work in Lua 5.3.\n<|/ c |>\n<| a tags=string,lua |>\nI used the following code\
    \ (thanks to and other answers). \n<code>", "\tassert(a and b)\n\treturn (a ^\
    \ b) ~= '0'\nend", "  a = a or \"\"\n  b = b or \"\"\n  assert(a:byte(0) == b:byte(0),\
    \ \"Strings must be equal length\")\n  local s = \"\"\n  for i = 1, #a do\n  \
    \  s = s .. string.format(\"%X\", tonumber(a:sub(i, i):byte()) XOR tonumber(b:sub(i,\
    \ i):byte()))\n  end\n  return s\nend", "  local c = ''\n  for i = 1, #a do\n\
    \    c = c .. tostring(a:sub(i,i)) .. tostring(b:sub(i,i))\n  end\n  return c\n\
    end", "  local c = a .. b\n  return string.sub(c, 0, 1, string.format(\"%x\",\
    \ bit.bxor(string.byte(c, 0, 1), string.byte(c, 2, 1))))\nend", "    assert(type(a)\
    \ == 'string' and type(b) == 'string')\n    assert(a:byte(0) == b:byte(0))\n \
    \   local str = \"\"\n    for i = 1, #a do\n        str = str .. a:byte(i) xor\
    \ b:byte(i)\n    end\n    return str\nend", "   local x = ''\n   for i = 1, #a\
    \ do\n      x = x .. tostring(a[i] xor b[i])\n   end\n   return x\nend", "  local\
    \ result = \"\"\n  for i=1,#a do\n    local xor_val = string.byte(a:sub(i,i))\
    \ XOR string.byte(b:sub(i,i))\n    if xor_val == 0 then\n      result = result\
    \ .. (string.byte(a:sub(i,i)) or \"0\")\n    else\n      result = result .. (string.byte(xor_val)\
    \ or \"1\")\n    end\n  end\n  return result\nend", "   a = a:byte(1, string.len(a)\
    \ - 1)\n   b = b:byte(1, string.len(b) - 1)\n   return string.rep('a', math.min(string.len(a),\
    \ string.len(b)))\n      :sub(1,   math.min(string.len(a), string.len(b)))\n \
    \     :sub(1, string.len(a))\n      :sub(1, string.len(b))\n      :sub(1,   string.len(b))\n\
    \      :sub(1,   string.len(a))\n      :sub(1,   1)\nend", "    local ret = ''\n\
    \    for i = 1, #a, 1 do\n        ret =.. a[i] .. b[i]\n    end\n    return ret\n\
    end", "\tlocal s = ''\n\tfor i, v in ipairs(string.byte(a)) do\n\t\ts = s .. math.floor(a:sub(i,i)^b:sub(i,i))\n\
    \tend\n\treturn s\nend", "  if type(a) == 'string' then\n    a = a:bytes()\n \
    \ end\n  if type(b) == 'string' then\n    b = b:bytes()\n  end\n  local n = #a\
    \ + #b\n  local res = ''\n  -- TODO: Make this faster\n  for i = 1, n do\n   \
    \ local c = a[i]\n    local d = b[i]\n    res = res .. string.char(d ^ c)\n  end\n\
    \  return res\nend", "    assert(a and b, \"empty input\")\n    local res = \"\
    \"\n    for i = 1, #a do\n        res = res .. tonumber(a[i]) ^ tonumber(b[i])\n\
    \    end\n    return res\nend", "    return a:byte(1, 2):gsub('1', '0' .. '0'\
    \ .. '0' .. '0' .. '0' .. '0' .. '1' .. '1')\n        .. b:byte(1, 2):gsub('1',\
    \ '0' .. '0' .. '0' .. '0' .. '0' .. '0' .. '0' .. '1')\nend\nreturn string_xor",
  "  local result = ''\n  local carry = 0\n  for i = 1, #a do\n    local sum = a[i]\
    \ XOR b[i]\n    carry = (sum and 1) or (carry and 1)\n    result = sum or result\n\
    \  end\n  return result\nend", "  local function bin(x)\n    if type(x) ~= 'string'\
    \ then return x end\n    local i = 1\n    local v = x\n    while i ~= 0 do\n \
    \     v = v .. (i % 2) and '1' or '0'\n      i = i >> 1\n    end\n    return v\n\
    \  end", "   local xor_a = tonumber(a:sub(1,2))*2 ^ tonumber(a:sub(3)*2) ^ tonumber(a:sub(5))*2\
    \ ^ tonumber(a:sub(7)*2) ^ tonumber(b:sub(1,2))*2 ^ tonumber(b:sub(3)*2) ^ tonumber(b:sub(5))*2\
    \ ^ tonumber(b:sub(7)*2)\n   local xor_b = tonumber(a:sub(1,2))*2 ^ tonumber(a:sub(3)*2)\
    \ ^ tonumber(a:sub(5))*2 ^ tonumber(a:sub(7)*2) ^ tonumber(b:sub(1,2))*2 ^ tonumber(b:sub(3)*2)\
    \ ^ tonumber(b:sub(5))*2 ^ tonumber(b:sub(7)*2)\n   return string.format(\"%0d\"\
    , xor_a ^ xor_b)\nend", "    local result = a\n    for i = 1, #b do\n        result\
    \ = result .. b[i]\n    end\n    return result\nend", "   local bin1 = string.format(\"\
    %04b\", bit.band(x, 255))\n   local bin2 = string.format(\"%04b\", bit.band(y,\
    \ 255))\n   local res = bin1 .. bin2\n   return res\nend", "    assert(type(a)\
    \ == 'string' and type(b) == 'string', 'a and b should be strings')", "   local\
    \ ln = math.max(#a, #b)\n   return string.format(\"%0*d\", ln, unpack(bin.xor.strings(a,\
    \ b)...))\nend", "  local result = ''\n  for i = 1, #a, 1 do result = (result\
    \ .. tostring(a[i] XOR b[i])) end\n  return result\nend", "    local bin1, bin2,\
    \ bin3 = unpack(a)\n    local bin4, bin5, bin6 = unpack(b)\n    local c = ''\n\
    \    for i = 0, 8 do\n        c = c .. string.format('%x', bin1 xor bin2 xor bin3\
    \ xor bin4 xor bin5 xor bin6)\n    end\n    return c\nend", "  local ret = \"\"\
    \n  for _, c in ipairs(a) do\n    ret = ret .. (c xor b)\n  end\n  return ret\n\
    end", "  -- Prepend the padding character if necessary\n  a = a == '' ? '0' :\
    \ a .. '0'\n  b = b == '' ? '0' : b .. '0'", "    local output = ''\n    for i\
    \ = 1, #a do\n        local outputChar = a:byte(i, 8):bitxor(b:byte(i, 8):bitmask())\n\
    \        if outputChar == 0 then\n            local j = 1\n            while j\
    \ < 8 do\n                local carryBit = a:byte(i, j):bitor(b:byte(i, j):bitmask())\n\
    \                if carryBit == 0 then\n                    break\n          \
    \      end\n                outputChar = outputChar:bitxor(carryBit):bitmask()\n\
    \                j = j + 1\n            end\n        else\n            outputChar\
    \ = outputChar:bitmask()\n        end\n        output = output..tostring(outputChar)\n\
    \    end\n    return output\nend", "    return a:byte(1, math.min(math.max(a:len()\
    \ + b:len() - 1, 1), 9)):reverse():concat(b:reverse():byte(1, math.min(math.max(b:len()\
    \ + a:len() - 1, 1), 9)))\nend", "  return \"0123456789ABCDEF\"[a] .. \"0123456789ABCDEF\"\
    [b]\nend", "  local result = \"\"\n  for i = 0, #a do\n    local c = a[i] ^ b[i]\n\
    \    if c > 0 then\n      result = result .. \"1\"\n    else\n      result = result\
    \ .. \"0\"\n    end\n  end\n  return result\nend", "  local result = \"\"\n  for\
    \ i = 1, #a do\n    local c = tostring(a:byte(i))\n    local d = tostring(b:byte(i))\n\
    \    local t = c ^ d\n    if t == 0 then\n      result = result .. \"0\"\n   \
    \ else\n      result = result .. tostring(t) .. \"1\"\n    end\n  end\n  return\
    \ result\nend", "  local ret = \"\"\n  for i = 1, #a do\n    local v1 = a[i]\n\
    \    local v2 = b[i]\n    local carry = 0\n    while #v1 ~= 0 do\n      local\
    \ t = v1%2\n      v1 = v1>>1\n      v2 = v2<<1 -- carry remainder of v1 XOR v2\n\
    \      carry = carry or t\n    end\n    if carry then\n      ret = ret .. ((#v1\
    \ > 0 and v1) or 0)\n    else\n      ret = ret .. (v2 or 0)\n    end\n  end\n\
    \  return ret\nend", "   return tostring(a) .. tostring(b) .. tostring(a:byte(1,\
    \ a)) .. tostring(b:byte(1, b)) .. tostring(a:byte(2, a)) .. tostring(b:byte(2,\
    \ b)) .. tostring(a:byte(3, a)) .. tostring(b:byte(3, b)) .. tostring(a:byte(4,\
    \ a)) .. tostring(b:byte(4, b)) .. tostring(a:byte(5, a)) .. tostring(b:byte(5,\
    \ b)) .. tostring(a:byte(6, a)) .. tostring(b:byte(6, b)) .. tostring(a:byte(7,\
    \ a)) .. tostring(b:byte(7, b)) .. tostring(a:byte(8, a)) .. tostring(b:byte(8,\
    \ b)) .. tostring(a:byte(9, a)) .. tostring(b:byte(9, b)) .. tostring(a:byte(10,\
    \ a)) .. tostring(b:byte(10, b)) .. tostring(a:byte(11, a)) .. tostring(b:byte(11,\
    \ b)) .. tostring(a:byte(12, a)) .. tostring(b:byte(12, b)) .. tostring(a:byte(13,\
    \ a)) .. tostring(b:byte(13, b)) .. tostring(a:byte(14, a)) .. tostring(b:byte(14,\
    \ b)) .. tostring(a:byte(15, a)) .. tostring(b:byte(15, b))\nend\nreturn string_xor\n\
    end", "  local bit1 = string.byte(a,1)\n  local bit2 = string.byte(b,1)\n  local\
    \ result = ''", "  if type(b) == 'table' then\n    local _ret\n    local _i, _len,\
    \ _a = unpack(a)\n    local _b, _len = unpack(b)\n    for _i = 1, _len do\n  \
    \    _ret[_i] = _a[_i] xor _b[_i]\n    end\n    return _ret\n  else\n    return\
    \ a xor b\n  end\nend", "    if type(b) ~= 'string' then\n        error('string\
    \ required')\n    end\n    if type(a) ~= 'string' then\n        a = tostring(a)\n\
    \    end\n    local ret = ''\n    for i=1, #a do\n        local idx = string.sub(a,\
    \ 1, i)\n        ret =  string.sub(ret, #ret+1, #ret) .. string.sub(ret, #ret+1-i,\
    \ #ret) .. string.sub(idx, 2, #idx) ^ string.sub(idx, 1, i)\n    end\n    return\
    \ ret\nend", "  local ret = ''\n  for i = 1, #a do\n    local c = a[i]\n    ret\
    \ = (ret == '') and c or ret .. c\n    for j = 1, #b do\n      c = b[j]\n    \
    \  ret = (ret == '') and c or ret .. c\n    end\n  end\n  return ret\nend", " \
    \ local t = {}\n  for i = 1, #a do t[i] = tonumber(a[i]) end\n  for i = 1, #b\
    \ do t[i] = tonumber(b[i]) end\n  local res = ''\n  for i = 1, #t do\n    res\
    \ = res .. string_char(t[i] ^ t[i + 1])\n  end\n  return res\nend", "  local binstr1\
    \ = tostring(b):reverse()\n  local binstr2 = tostring(a):reverse()\n  return binstr1:sub(1,\
    \ binstr1:len() - 1)..binstr2:sub(1, binstr2:len() - 1)\nend", "    local ret\
    \ = ''\n    for i = 1, #a do\n        ret = ret .. string.rep(a[i], #b[i])\n \
    \   end\n    return ret\nend", "  local _a = tonumber(a)\n  local _b = tonumber(b)\n\
    \  local _result = tostring(_a ^ _b)\n  return _result\nend", '  if a=="0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
  "    local x = 0\n    for i = 1, #a do\n        x = x + (a[i]) ^ b[i]\n    end\n\
    \    return tostring(x)\nend", "  return a:gsub('.', function(x)\n      return\
    \ x == '1' .. tostring(b:byte()) end\n  end)\nend", "  return string.char(unpack(a)\
    \ XOR unpack(b))\nend", "  local n = {}\n  for i = 1, 8 do\n    table.insert(n,\
    \ 0)\n  end\n  for i = 1, 8 do\n    n[i % 4 + 1] = string.byte(a) ^ string.byte(b)\n\
    \    b = string.byte(b)\n  end\n  return table.concat(string.char(n))\nend", " \
    \   local output = ''\n    for i = 1, #a do\n        output = output .. tostring(a[i]\
    \ ^ b[i])\n    end\n    return output\nend", "\tlocal c = terralib.newsymbol(c.legion_binary_string_t,\
    \ \"c\")\n\tlocal size = terralib.newsymbol(uint, \"size\")\n\tlocal result =\
    \ terralib.newsymbol(char *, \"result\")", "    return string.char((a ~= b) xor\
    \ 255)\nend", "\tlocal t = {}\n\tfor i = 1, #a do\n\t\tt[i] = a[i] ^ b[i]\n\t\
    end\n\treturn table.concat(t, \"\")\nend", "  local strA = a\n  local strB = b\n\
    \  local lenA = #strA\n  local lenB = #strB\n  while lenA ~= 0 and lenB ~= 0 do\n\
    \    strA[lenA] = '0' .. strA[lenA]\n    strB[lenB] = '0' .. strB[lenB]\n    lenA\
    \ = lenA - 1\n    lenB = lenB - 1\n  end", "    return a:byte(1, true) ^ b:byte(1,\
    \ true)\nend", "    return string.format('%X', bit.bxor(string.byte(string.byte(a)),\
    \ string.byte(a)))\nend", "  return a:byte(1, true) ^ b:byte(1, true)\nend", "\t\
    local bin1 = bit.band(a, 255)\n\tlocal bin2 = bit.band(b, 255)\n\tlocal xor =\
    \ bin1 ^ bin2\n\tlocal ret = string.char(xor)\n\treturn ret\nend", "    local\
    \ res, carry = '0'\n    for i = 0, #a, 1 do\n        local c = table.byte(a.sub(i,\
    \ i + 1))\n        res = '0' .. res .. string.format('%s%s%s', carry, table.byte(b),\
    \ c)\n        carry = table.byte(c) - 1\n    end\n    return res\nend", "  local\
    \ result, carry = 0\n  for i = 1, #a do\n    carry = carry + string.byte(a) ^\
    \ string.byte(b) \n    result = result + string.byte(a) ^ string.byte(b)\n   \
    \ local remaining = #b\n    if remaining == 0 then\n      break\n    end\n   \
    \ a = string.sub(a, i + 1, i + 1)\n    b = string.sub(b, i + 1, i + 1)\n  end\n\
    \  return result .. tostring(carry)\nend", "    return string.format('%b', bit.bxor(string.byte(a,\
    \ 'bit'), string.byte(b, 'bit')))\nend", "    if a or b == nil then\n        error(\"\
    'a' and 'b' arguments are required\")\n    end\n    local length = math.min((#a),\
    \ (#b))\n    local ret = \"\"\n    for i=1, length do\n        ret = ret .. ((a:byte(i)\
    \ xor b:byte(i)):string())\n    end\n    return ret\nend", "  local result = ''\n\
    \  for i = 0, #a do -- This loops through the whole string a\n    for j = 0, #b\
    \ do -- This loops through the whole string b\n      local k = i\n      local\
    \ l = j\n      result = (result..((b[k]~=a[k])..((b[l]~=a[l])))) -- This is the\
    \ XOR operation for two strings.\n    end\n  end\n  return result\nend", "  local\
    \ res, xor_sum, in_sum\n  res = ''\n  xor_sum = 0\n  in_sum = 0\n  for i = 1,\
    \ #a do\n    in_sum = in_sum + ((#a % 2) == 0)\n    xor_sum = xor_sum + ((a[i]\
    \ == '1') and (b[i] == '1'))\n  end\n  if in_sum == 0 and xor_sum == 0 then\n\
    \    return res\n  end\n  if in_sum == 0 or xor_sum == 0 then\n    return '0'\
    \ + res\n  end\n  res = '1' + res\n  res = string_xor(a:sub(1, #a), res)\n  return\
    \ string_xor(res, b:sub(1, #b))\nend", "    local result = \"\"\n    for i = 0,\
    \ #a do\n        result = result + (tostring(a[i]) xor tostring(b[i]))\n    end\n\
    \    return result\nend", "    if type(b) ~= 'string' then\n        a = \"00000000000000000000000000000000\"\
    \n    end\n    return a:gsub(\"1\", \"0\")..b:gsub(\"1\", \"0\")\nend", "  return\
    \ bit.bxor(a, b)\nend", "   assert(type(a) == 'string' and type(b) == 'string')\n\
    \   local res = ''\n   for i = 1, #a, 1 do\n      res = res .. tostring((tostring(a[i])\
    \ xor tostring(b[i]))) .. tostring(a[i])\n   end\n   return res\nend\n</cell>\n\
    <code language=julia-1.1>\n# Let's compare the performance of our implementation\n\
    @time string_xor(\"010101101100011111001110010010011000111010001\", \"10010010100110011100100111001011110100100\"\
    )\n</cell>\n<text>\nExercise\nImplement the function string_xor_vector. Requires\
    \ two vectors a and b where every entry in b is a string with length equal to\
    \ the number of columns in a.", "  return a:gsub('1', '0'):gsub('0', '1'):gsub('1',\
    \ '0')\nend", "  return (a:len() * '0'):sub(1, (a:len() * '0'):len()) ..\n   \
    \ (a:len() * '1'):sub(1, (a:len() * '1'):len())\nend", "  local a_1 = table_concat(a:gsub('0',\
    \ '1'), \"\")\n  local b_1 = table_concat(b:gsub('0', '1'), \"\")\n  return a_1\
    \ .. b_1\nend", "   assert(type(a) == \"string\" and type(b) == \"string\", \"\
    Input has to be a string of length 2\")\n   local out = \"\"\n   for i = 1, #a\
    \ do\n      local val = a[i]\n      out = out .. tostring(val ^ b[i])\n   end\n\
    \   return out\nend", "    return a:gsub('1', '0'):gsub('0', '1'):gsub('1', '0')\n\
    end", "    if a=='' or b=='' then\n        return ''\n    end\n    local res =\
    \ ''\n    for i = 0, #a do\n        res..= a[i]:byte() ^ b[i]:byte()\n    end\n\
    \    return res\nend", "  local r = \"\"\n  local bits = string.len(a)\n  for\
    \ i = 1, bits, 2 do\n    if a[i] == \"0\" and b[i] == \"1\" then\n      r = r..\"\
    0\"\n    elseif a[i] == \"1\" and b[i] == \"0\" then\n      r = r..\"1\"\n   \
    \ end\n  end\n  return r\nend", "    local result = a\n    for j = 1, #b do\n\
    \        local v = b:sub(j, j)\n        result:sub(1, j) = table[result[1]:sub(1,\
    \ j) XOR v]\n    end\n    return result\nend", "    if type(a) ~= 'string' then\
    \ return 'not a string' end\n    if type(b) ~= 'string' then return 'not a string'\
    \ end\n    if a == b then return '' end", "    if type(b) ~= 'string' then\n \
    \       error('string expected, got ' .. type(b))\n    end\n    if a == '' then\n\
    \        return b\n    end\n    if b == '' then\n        return a\n    end\n \
    \   if a:sub(1, 1) ~= '1' then\n        a = a .. '1'\n    end\n    if b:sub(1,\
    \ 1) ~= '1' then\n        b = b .. '1'\n    end\n    local s = ''\n    for i =\
    \ 1, #a, 1 do\n        local v = tonumber(a[1:i]) ^ tonumber(b[1:i])\n       \
    \ s = (v ~= 0 and v or '0') .. (s or '')\n    end\n    return s\nend", "  local\
    \ b1 = bit.bor(bit.band(a, b), bit.band(a^b, a))\n  return bit.bxor(a^b, a^b1)\n\
    end", "  assert(type(a) == 'string' and type(b) == 'string', 'inputs must be strings')\n\
    \  assert(#a > 0 and #b > 0, 'inputs are invalid')\n  assert(#a == #b, 'inputs\
    \ are not the same length')\n  local x = ''\n  for i = 1, #a do\n    x = (#b >\
    \ i) x..(a[i] xor b[i]) or a[i]\n  end\n  return x\nend", "    local s = assert(ffi.new(\"\
    char[?]\", #a or 0), \"string too short\")\n    ffi.copy(s, #a > 0 and a and b\
    \ or b)\n    return ffi.string(s)\nend\nreturn string_xor\nend", "  -- Return\
    \ empty string if either string is empty.\n  if not a or not b then return ''\
    \ end", "\tlocal c = ''\n\tlocal i = 0\n\twhile a ~= '' and b ~= '' and i < #a\
    \ do\n\t\tif a:byte(i) ~= b:byte(i) then c = c .. a:byte(i) end\n\t\ti = i + 1\n\
    \tend\n\treturn c\nend", "    local result = \"\"\n    for i = 0, #a do\n    \
    \    result = (result + string.char((string.byte(a, i) xor string.byte(b, i)))\
    \ .. string.char((string.byte(b, i) xor string.byte(a, i))))\n    end\n    return\
    \ result\nend", "  assert(type(a) == 'string' and type(b) == 'string')\n  local\
    \ bits_a = a:split('.')\n  local bits_b = b:split('.')", "  return string.char(a\
    \ ^ b) -- Convert character to string\nend", "    if a == '0' and b == '0' then\
    \ return '0' end\n    if a == '0' and b == '1' then return '1' end\n    if a ==\
    \ '1' and b == '0' then return '1' end\n    if a == '1' and b == '1' then return\
    \ '0' end\nend", "  -- Perform binary XOR on two strings a and b and\n  -- return\
    \ the result as a string.\n  local result = {}\n  for i = 0, #a do -- Iterate\
    \ over string a\n    result[i] = a[i] == '0' and b[i] ~= '0' or a[i] ~= '0' and\
    \ b[i] == '0' or a[i] == '1' and b[i] == '1'\n  end\n  return table.concat(result,\
    \ '') -- Return string result\nend", "    return a:byte(1, 1) and b:byte(1, 1)\
    \ and bin.xor(a:byte(), b:byte()) or \"00\"\nend", "  local result = \"\"\n  for\
    \ i = 1, #a do\n    local c = tostring(a:byte(i)^b:byte(i))\n    if string.len(c)\
    \ > 0 then\n      result = result .. c\n    end\n  end\n  return result\nend",
  "    local bin1 = \"00000000\";\n    local bin2 = \"00000000\";\n    local bin3\
    \ = \"00000000\";", "    local x = string.byte(a)\n    local y = string.byte(b)",
  "  return string.byte(a, 2) ^ string.byte(b, 2)\nend", "   a = string.reverse(a)\n\
    \   b = string.reverse(b)\n   local ret = ''\n   for i = 1, #a do\n      ret =\
    \ ret + string.char((string.byte(a) + string.byte(b) + i) %256)\n   end\n   return\
    \ ret\nend", "\ta = string.byte(a)\n\tb = string.byte(b)\n\tlocal tmp = ''\n\t\
    -- Concatenate with last byte if lengths are odd.\n\tif #a + #b < 8 then\n\t\t\
    tmp = '0' .. tmp\n\tend\n\t-- Repeat last byte until lengths are 8 or more.\n\t\
    if #a + #b >= 8 then\n\t\tlocal k = #b + 1\n\t\tfor i = #a, 1, -1 do\n\t\t\ttmp\
    \ = ((a ~= '') and a or (b ~= '') and b) ~ tmp .. k .. k\n\t\t\tk = k >> 1\n\t\
    \tend\n\tend\n\treturn tmp\nend", "    local result = {}\n    for i, v in ipairs(a)\
    \ do\n        result[#result + 1] = string.byte(a, i) ^ string.byte(b, i)\n  \
    \  end\n    return table.concat(result)\nend", "   assert(a and b)\n   local result\
    \ = a\n   for i = 1, #a do\n      result = string.format('%s%s%s', result, xor_table[tonumber(a[i])][tonumber(b[i])],\
    \ xor_table[tonumber(b[i])][tonumber(a[i])])\n   end\n   return result\nend",
  "  if type(a) ~= 'string' or type(b) ~= 'string' then\n    error'String is not valid'\n\
    \  elseif #a ~= #b then\n    error'String is not a binary string'\n  else\n  \
    \  return table.concat(unpack(\n      { a = string.byte(a, 1, #a), b = string.byte(b,\
    \ 1) },\n      function(a, b)\n        if a == 0 then\n          a = ''\n    \
    \    elseif b == 0 then\n          b = ''\n        end\n        return a .. tostring(b\
    \ % 2)\n      end))\n  end\nend", "  -- Convert the strings to binary arrays,\
    \ XOR, then convert back to string.\n  return string.format('%x', byte.borrow(a.data,\
    \ b.data) ^ byte.borrow(b.data, a.data))\nend", "  return a:gsub('0', '.'):gsub('1',\
    \ '.'):gsub('.', '0'):gsub('00', '0'):gsub('01', '0')\nend", "    return a:gsub('0',\
    \ ''):gsub('1', ''):gsub('10', ''):gsub('11', '') ..\n           b:gsub('0', ''):gsub('1',\
    \ ''):gsub('10', ''):gsub('11', '')\nend", "  assert(type(b) == 'string' and type(a)\
    \ == 'string')\n  local s = ''\n  for i in string.byte(a) do\n    s = s .. string.format('%d',\
    \ a ^ i)\n  end\n  return s\nend", "    local xor_a = {}\n    local xor_b = {}\n\
    \    for i = 1, #a, 1 do\n        xor_a[#xor_a + 1] = a[i]\n    end\n    for i\
    \ = 1, #b, 1 do\n        xor_b[#xor_b + 1] = b[i]\n    end", "    return bit.bxor(bit.lshift(a,\
    \ 8), bit.rshift(a, 8)) ..\n           bit.bxor(bit.lshift(b, 8), bit.rshift(b,\
    \ 8))\nend", "    return string.sub(string_xor_bytewise(bin(x), bin(y)), -#x)\n\
    end", "\tassert(a, 'input')\n\tassert(b, 'input')\n\treturn string.format('%010x',\
    \ a:byte() xor b:byte())\nend", "  local bin = string.char(a)\n  for i = 1, #b\
    \ do\n    bin = string.sub(bin, 1, #b + 1) .. string.sub(b, i, #b)\n  end\n  return\
    \ bin\nend", "  local r = ''\n  for i = 1, string.len(a) do\n    if string.byte(a,\
    \ i) ~= string.byte(b, i) then\n      r = r .. string.byte(a, i)\n    end\n  end\n\
    \  return r\nend", "  a = tostring(a) -- Make sure that 'a' is a string\n  b =\
    \ tostring(b) -- Make sure that 'b' is a string", "    local lsa, lsb = length(a),\
    \ length(b)\n    local res = \"\"\n    if lsa*lsb == 0 then\n        return a\n\
    \    end\n    if lsa*lsb > 0 then\n        -- Optimize for common case\n     \
    \   res = \"0\"\n        for i = 1, lsa do\n            res[#res+1] = string.byte(a,\
    \ i)^string.byte(b, i)\n        end\n    else\n        -- Optimize for common\
    \ case\n        res = \"1\"\n        for i = 1, lsb do\n            res[#res+1]\
    \ = string.byte(a, i)^string.byte(b, i)\n        end\n    end\n    return res\n\
    end", "  local xor = '00000000000000000000000000000000'", "  local function r(x)\n\
    \    if a == '0' and b == '0' then\n      return '0'\n    elseif a == '0' and\
    \ b == '1' then\n      return '1'\n    elseif a == '1' and b == '0' then\n   \
    \   return '1'\n    elseif a == '1' and b == '1' then\n      return '0'\n    end\n\
    \  end\n  return r:get()\nend", "  local res = \"\"\n  for i = 0, #a do\n    res\
    \ = res .. string.format(\"%x\", a[i])\n    if i < #a then\n      res = res ..\
    \ string.format(\"%x\", b[i])\n    end\n  end\n  return res\nend", "  local result\
    \ = \"\"\n  for i = 1, string.len(a) do\n    local l = string.byte(a) ^ string.byte(b)\n\
    \    result = result .. string.char(l)\n    local carry = l and 1 -- bitwise and\
    \ of l (1) and 1 ('1')\n    b = b and carry or '0' -- b and carry are either 0\
    \ or 1\n  end -- loop ends here\n  return result\nend", "    local c = bit.bor(bit.band(a,\
    \ 15), bit.band(b, 15))\n    if c == 0 then\n        return b\n    end\n    local\
    \ s = ''\n    while c ~= 0 do\n        s = s..(string.byte(a, c) ~ string.byte(b,\
    \ c)  or ' ')\n        c = bit.rshift(c, 1)\n    end\n    return s\nend", "  if\
    \ a == nil or b == nil then\n    return nil\n  else\n    return string.format(\"\
    %X\", bit.bor(bit.bxor(bit.tobinstring(a), bit.tobinstring(b)), bit.tobinstring('0')))\n\
    \  end\nend", "  local result = {}\n  local i = 1\n  while i < #a do\n    local\
    \ b_index = string.format(\"%d\", i)\n    local a_index = string.format(\"%d\"\
    , i)\n    if a[a_index] == '0' then\n      table.insert(result, b[b_index])\n\
    \    end\n    i = i + 1\n  end\n  return table.concat(result, '') -- Return string\n\
    end", "   local function xor(a, b)\n      local c = 0\n      for i = 1, #a, 1\
    \ do\n         c = c + string.byte(a, 1, i) * string.byte(b, 1, i)\n      end\n\
    \      return string.char(c)\n   end\n   local res = xor(a, string.byte(b, 1))\n\
    \   return res:sub(1, #res) + string.byte(a, #res-1)\nend", "  if a ~= b then\n\
    \    local m = {}\n    for i = 1, #a do\n      m[i] = a[i]\n    end\n    for i\
    \ = 1, #b do\n      m[i] = b[i]\n    end\n    return table.concat(m)\n  end\n\
    \  return a\nend", "    local t = {}\n    for i = 0, 8 do\n        t[i] = 0\n\
    \    end\n    for i = 1, 8 do\n        t[i] = a[i]\n        t[i+8] = b[i]\n  \
    \  end\n    t = table.concat(t, \"\")\n    return t\nend", "  local s = ''\n \
    \ local mask = 0\n  for i, c in ipairs(a) do\n    if c and b[i] then\n      s\
    \ = s .. c\n      mask = mask + (1 << (i-1))\n    end\n  end\n  return s .. string.char(mask)\
    \ .. b[#b]\nend", "  if a == '' then\n    return '' -- Empty string\n  end\n \
    \ if b == '' then\n    return ''\n  end\n  local bits = unpack(bit.bor(unpack(a),\
    \ unpack(b)))\n  local result = \"\"\n  for i = 1, 8 do\n    -- Reset the bit\n\
    \    local bit = 1\n    for j = 0, 8 do\n      -- Calculate the bit and append\
    \ it to the result\n      bit = (bit ~ bits[8 - j - 1]) and \"1\" or \"0\"\n \
    \     result = result .. bit\n    end\n  end\n  return result\nend", "    assert(type(a)\
    \ == \"string\" and type(b) == \"string\" and \"1..4\"..b, \"Input to xor must\
    \ be a string containing 1s and 0s\")\n    assert(#a == #b, \"Input to xor must\
    \ be of the same length\")\n    return a ^ b\nend", "   assert(type(input_a) ==\
    \ 'string' and type(input_b) == 'string')\n   local result = input_a\n   for i,\
    \ c in ipairs(a) do\n      result = string.format(\"%s%s%s\", result, c, string.rep('0',\
    \ 8 - #a[i]))\n   end\n   for i, c in ipairs(b) do\n      result = string.format(\"\
    %s%s%s\", result, c, string.rep('0', 8 - #b[i]))\n   end\n   return result\nend",
  "    local na, nb = tonumber(a), tonumber(b)\n    if na then\n        if nb then\
    \ return '1' end\n        return '0'\n    end\n    if nb then return '0' end\n\
    \    return ''\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
