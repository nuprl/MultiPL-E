name: HumanEval_70_strange_sort_list
language: lua
prompt: "-- Given list of integers, return list in strange order.\n-- Strange sorting,\
  \ is when you start with the minimum value,\n-- then maximum of the remaining integers,\
  \ then minimum and so on.\n-- Examples:\n-- strange_sort_list([1, 2, 3, 4]) == [1,\
  \ 4, 2, 3]\n-- strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n-- strange_sort_list([])\
  \ == []\nlocal function strange_sort_list(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strange_sort_list\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})\n    lu.assertEquals(candidate({5,\
  \ 6, 7, 8, 9}), {5, 9, 6, 8, 7})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}),\
  \ {1, 5, 2, 4, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5,\
  \ 8, 6, 7})\n    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})\n    lu.assertEquals(candidate({}),\
  \ {})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3,\
  \ 6, 4, 5})\n    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5,\
  \ -5, 5, 0, 2, 2, 2})\n    lu.assertEquals(candidate({111111}), {111111})\nend\n\
  \nos.exit(lu.LuaUnit.run())"
completions: ["  if #lst < 2 then return lst end\n  local first = lst[1]\n  for i\
    \ = 2, #lst do\n    if first > lst[i] then\n      local tmp = lst[i]\n      for\
    \ j = i, 1, -1 do\n        lst[j] = lst[j - 1]\n      end\n      lst[1] = first\n\
    \      return lst\n    end\n  end\n  return first\nend", "  return table.sort(\n\
    \    function(x, y)\n      if x < y then return 1 end\n      if x > y then return\
    \ -1 end\n      return 0\n    end,\n    lst\n  )\nend\n</code>\nThe above function\
    \ sorts the list by comparing first element, then second, and so on, and returns\
    \ the sorted list.\n<|/ a dscore=5 tags=lua-table,lua |>\n<| c |>\nThanks for\
    \ the thorough explanation! I actually found something similar, but instead of\
    \ using table.sort I used table.concat.\n<|/ c |>\n<| a dscore=5 |>\nFor sorting\
    \ a table (or a lua list), this can do the job:\n<code>", "  if #lst == 0 then\n\
    \    return {}\n  end\n  local n = #lst\n  local largest = lst[#lst]\n  for i\
    \ = n - 1, 1, -1 do\n    local tmp = lst[i]\n    if tmp > largest then\n     \
    \ largest = tmp\n    end\n  end\n  return listhelper.list(\n    largest, listhelper.list(\n\
    \      listhelper.list(\n        listhelper.list(\n          listhelper.list(\n\
    \            listhelper.list(\n              listhelper.list(\n              \
    \  listhelper.list(\n                  listhelper.list(\n                    listhelper.list(\n\
    \                      listhelper.list(\n                        listhelper.list(\n\
    \                          listhelper.list(\n                            listhelper.list(\n\
    \                              listhelper.list(\n                            \
    \    listhelper.list(\n                                  listhelper.list(\n  \
    \                                  listhelper.list(\n                        \
    \              listhelper.list(\n                                        listhelper.list(\n\
    \                                          listhelper.list(\n                \
    \                            listhelper.list(\n                              \
    \                listhelper.list(\n                                          \
    \      listhelper.list(\n                                                  listhelper.list(\n\
    \                                                    listhelper.list(\n      \
    \                                                largest,\n                  \
    \                                    lst\n                                   \
    \               )\n                                                end\n     \
    \                                         )\n                                \
    \            )\n                                          )\n                \
    \                        )\n                                      )\n        \
    \                            )\n                                  )\n        \
    \                        )\n                              )\n                \
    \            )\n                          )\n                        )\n     \
    \                 )\n                    )\n                  )\n            \
    \    )\n              )\n            )\n          )\n        )\n      )\n    )\n\
    \  )\nend", "  if not lst then return end\n  local function next_max_value(lst)\n\
    \    local max_value = nil\n    for value in lst:gmatch(\"%d+\") do\n      if\
    \ max_value == nil then\n        max_value = value\n      else\n        if value\
    \ > max_value then\n          max_value = value\n        end\n      end\n    end\n\
    \    return max_value\n  end\n  local function next_min_value(lst)\n    local\
    \ min_value = nil\n    for value in lst:gmatch(\"%d+\") do\n      if min_value\
    \ == nil then\n        min_value = value\n      else\n        if value < min_value\
    \ then\n          min_value = value\n        end\n      end\n    end\n    return\
    \ min_value\n  end\n  local function next_mid_value(lst)\n    local mid_value\
    \ = nil\n    for value in lst:gmatch(\"%d+\") do\n      if mid_value == nil then\n\
    \        mid_value = value\n      else\n        if value < mid_value and value\
    \ > mid_value then\n          mid_value = value\n        end\n      end\n    end\n\
    \    return mid_value\n  end\n  -- find max and min values\n  local max_value\
    \ = next_max_value(lst)\n  local min_value = next_min_value(lst)\n  -- sort by\
    \ comparing medians of min and max values\n  local function median_cmp(x, y) do\n\
    \    local x_median = next_mid_value(x)\n    local y_median = next_mid_value(y)\n\
    \    if x_median > y_median then\n      return 1\n    elseif x_median < y_median\
    \ then\n      return -1\n    else\n      return 0\n    end\n  end\n  -- sort list\
    \ by comparing medians of min and max values\n  lst = lst:gmatch(string.format(\"\
    (%d+)%s\", max_value, min_value))\n  lst = sort(lst, median_cmp)\n  -- re-sort\
    \ list by comparing medians of min and max values\n  lst = sort(lst, median_cmp)\n\
    \  return lst\nend", '    if not lst then return end', "  local i, l, imax = 1,\
    \ #lst, -1\n  -- For each element in the list, find the minimum value\n  -- that\
    \ is larger than the current maximum.\n  -- Then, swap with the current maximum,\
    \ increase the current\n  -- maximum by the value at that position.\n  repeat\n\
    \    i = i + 1\n    l = l - 1\n    imax = imax  + i\n  until l == 0\n  -- Swap\
    \ the new minimum with the current maximum,\n  -- then increase the new maximum\
    \ by the value at that position.\n  l[1] = lst[imax]\n  lst[imax] = l[1]\n  repeat\n\
    \    i = i + 1\n    l = l - 1\n    imax = imax  + i\n  until l == 0\n  -- Return\
    \ to calling function.\n  return lst\nend", "  for i = 1, #lst do\n    local j\
    \ = 1\n    while j <= i and lst[j] < lst[i] do\n      j = j + 1\n    end\n   \
    \ table.insert(lst, lst[i], lst[j])\n    lst[j], lst[i] = lst[i], lst[j]\n  end\n\
    \  table.sort(lst)\n  return lst\nend", "  if lst[1] < lst[2] then\n    lst[1],\
    \ lst[2] = lst[2], lst[1]\n  end\n  if lst[1] > lst[2] then\n    lst[2], lst[1]\
    \ = lst[1], lst[2]\n  end\n  return lst\nend", "    local res = {}\n    local\
    \ minval = lst[1]\n    for i=2,#lst do\n        if minval > lst[i] then\n    \
    \        minval = lst[i]\n        end\n    end\n    for i=1,#lst do\n        table.insert(res,\
    \ minval)\n    end\n    for i=#lst,1,-1 do\n        table.insert(res, lst[i])\n\
    \    end\n    return res\nend", "  return function(...)\n    local sorted_lst\
    \ = table.sort(lst)\n    local new_lst, current_min = table.unpack(sorted_lst)\n\
    \    local current_max = sorted_lst[#sorted_lst]\n    for i = 2, #sorted_lst do\n\
    \      local min = sorted_lst[i - 1]\n      local max = sorted_lst[i]\n      if\
    \ current_min == min then\n        sorted_lst[i - 1] = max\n        sorted_lst[i]\
    \ = min\n      elseif current_min == max then\n        sorted_lst[i - 1] = current_min\n\
    \        sorted_lst[i] = current_max\n      else\n        if current_min < min\
    \ then\n          table.insert(new_lst, current_min)\n          table.insert(new_lst,\
    \ max)\n        else\n          table.insert(new_lst, current_max)\n         \
    \ table.insert(new_lst, min)\n        end\n      end\n    end\n    return new_lst\n\
    \  end\nend", "  -- Sort the list starting with the lowest number to the highest.\n\
    \  -- This is because after that, we have to start with the lowest number again,\n\
    \  -- since we can't trust the position of any number.", "    local tmp = {}\n\
    \    for i = 1, #lst do\n        table.insert(tmp, lst[i])\n    end\n    table.sort(tmp)\n\
    \    local tmp2 = {}\n    for i = 1, #lst do\n        table.insert(tmp2, tmp[i])\n\
    \    end\n    return tmp2\nend", "  local len = #lst\n  local ret = {}\n  local\
    \ min_index = 1\n  local max_index = 1\n  for idx = 1, len do\n    if lst[min_index]\
    \ > lst[max_index] then\n      table.insert(ret, lst[min_index])\n      min_index\
    \ = min_index + 1\n    elseif lst[max_index] > lst[min_index] then\n      table.insert(ret,\
    \ lst[max_index])\n      max_index = max_index + 1\n    else\n      table.insert(ret,\
    \ lst[min_index])\n      min_index = min_index + 1\n      table.insert(ret, lst[max_index])\n\
    \      max_index = max_index + 1\n    end\n  end\n  return ret\nend", "   local\
    \ sorted = {}\n   for _, v in ipairs(lst) do\n      table.insert(sorted, v)\n\
    \   end\n   table.sort(sorted, function(a, b)\n      return sorted.length - sorted.indexOf(a)\
    \ - sorted.indexOf(b)\n   end)\n   for _, v in ipairs(sorted) do\n      table.insert(sorted,\
    \ v)\n   end\n   return sorted\nend", "\tlocal tmp = {}\n\tfor i, v in ipairs(lst)\
    \ do\n\t\ttable.insert(tmp, v)\n\tend\n\treturn table.concat(tmp, \" \")\nend",
  "  local t = {}\n  table.sort(lst,\n    function(first, second)\n      local i\n\
    \      for i=1, #lst do\n        if lst[i] > first then\n          break\n   \
    \     end\n      end\n      for i=1, #lst do\n        if lst[i] < first then\n\
    \          break\n        end\n      end\n      if i < #lst then\n        table.insert(t,\
    \ lst[i])\n      end\n    end)\n  return t\nend", "  -- Sort from min to max\n\
    \  lst.sort(function(a, b) return a < b end)", "    local min, max = lst[1], lst[#lst]\n\
    \    for i = 2, #lst do\n        if lst[i] < min then\n            min = lst[i]\n\
    \        end\n        if lst[i] > max then\n            max = lst[i]\n       \
    \ end\n    end\n    for i = 1, #lst do\n        if lst[i] < min then\n       \
    \     lst[i], lst[i-1] = lst[i-1], lst[i]\n        end\n        if lst[i] > max\
    \ then\n            lst[i], lst[i-1] = lst[i-1], lst[i]\n        end\n    end\n\
    \    return lst\nend", "  if #lst == 0 then\n    return lst\n  end", "  local\
    \ n = {}\n  for i = 1, #lst do\n    n[#n + 1] = lst[i]\n  end", "  local lst2\
    \ = {}\n  local i = 1\n  for item in lst do\n    table.insert(lst2, item)\n  \
    \  i = i + 1\n  end\n  i = 1\n  while i < #lst do\n    table.insert(lst2, lst[i])\n\
    \    i = i + 1\n  end\n  return lst2\nend", "   local i = lst[1]\n   while i ~=\
    \ nil do\n      i = lst[i]\n   end\n   lst[1]:insert(lst[#lst])\n   lst[#lst]:delete()\n\
    \   return lst\nend", "  -- If the list is empty return an empty list.\n  if #lst\
    \ == 0 then\n    return lst\n  end", "  local max_value = unpack(lst)\n  local\
    \ tmp_lst = lst\n  local i = 1\n  for i = 1, #tmp_lst do\n    local j = 1\n  \
    \  while j < i do\n      if tmp_lst[j] > tmp_lst[i] then\n        max_value =\
    \ tmp_lst[i]\n        tmp_lst[i] = tmp_lst[j]\n        tmp_lst[j] = max_value\n\
    \      end\n      j = j + 1\n    end\n  end\n  return tmp_lst\nend", "  if lst\
    \ == nil then\n    return nil\n  end", '  local new_lst = { }', '  if #lst ==
    0 then return [] end', "  local lst2 = {}\n  for _, v in ipairs(lst) do lst2[#lst2\
    \ + 1] = v end\n  table.sort(lst2, function(a, b) return a < b end)\n  for _,\
    \ v in ipairs(lst2) do lst[v] = lst2[#lst2 + 1] end\n  return lst\nend", "  local\
    \ ret = {}\n  for i = #lst, 2, -1 do\n    -- If the value is bigger than the biggest\
    \ in the list, then\n    -- we move it to the right\n    if lst[i] > lst[i + 1]\
    \ then\n      table.insert(ret, lst[i])\n      table.insert(ret, lst[i + 1])\n\
    \      break\n    end\n    -- If the value is smaller, then we move it to the\
    \ left\n    if lst[i] < lst[i - 1] then\n      table.insert(ret, lst[i])\n   \
    \   table.insert(ret, lst[i - 1])\n      break\n    end\n    -- Otherwise, we\
    \ keep it in its place\n    table.insert(ret, lst[i])\n  end\n  return ret\nend",
  "  local sorted = {}\n  local last_min = 0\n  local last_max = lst[1]\n  for i =\
    \ 2, #lst do\n    local curr = lst[i]\n    if curr < last_min then\n      table.insert(sorted,\
    \ last_min)\n      last_min = curr\n    elseif curr > last_max then\n      table.insert(sorted,\
    \ last_max)\n      last_max = curr\n    else\n      table.insert(sorted, curr)\n\
    \    end\n  end\n  table.insert(sorted, last_min)\n  table.insert(sorted, last_max)\n\
    \  return sorted\nend", "    local minimum = nil\n    local minimum_index = 1\n\
    \    local maximum = nil\n    local maximum_index = #lst\n    local i = minimum_index\n\
    \    local j = maximum_index - 1\n    while i <= j do\n        local x = lst[i]\n\
    \        local y = lst[j]\n        if x < y then\n            lst[i], lst[j] =\
    \ y, x\n            i, j = i, j -- swap indices\n        else\n            i =\
    \ i + 1\n            if i == j then\n                minimum = lst[i]\n      \
    \          minimum_index = i\n                maximum = lst[j]\n             \
    \   maximum_index = j\n            end\n        end\n    end\n    return minimum,\
    \ minimum_index, maximum, maximum_index\nend", "  -- Base case: empty list\n \
    \ if #lst == 0 then\n    return lst\n  end", "  local n = 1\n  local curr = lst[1]\n\
    \  local results = {}\n  for i = 2, #lst do\n    if curr < lst[i] then\n     \
    \ n = n + 1\n      table.insert(results, curr)\n      curr = lst[i]\n    end\n\
    \  end\n  table.insert(results, curr)\n  for i = 1, n do\n    table.insert(results,\
    \ lst[i])\n  end\n  return results\nend", "\tlocal lst = lst\n\tlocal i, j = 2,\
    \ #lst\n\trepeat\n\t\tlst[i], lst[j] = lst[j], lst[i]\n\t\ti, j = i + 1, j - 1\n\
    \tuntil i > j\n\treturn lst\nend", "  if not lst\n    then return nil\n    else\
    \ if #lst == 1\n         then return lst\n         else return sort(lst)\n   \
    \ end\n  end\n  local min = lst[1]\n  local i = 1\n  while i <= #lst do\n    if\
    \ lst[i] < min then\n      min = lst[i]\n    else\n      i = i + 1\n      lst[i],\
    \ lst[i-1] = lst[i-1], lst[i]\n    end\n  end\n  return lst\nend", "    if #lst\
    \ == 0 then\n        return nil\n    end\n    local min_index, min_value = unpack(lst)\n\
    \    local min_indexes = { min_index }\n    local max_index = #lst - 1\n    local\
    \ max_value = unpack(lst[max_index])\n    local max_indexes = { max_index }",
  "   local tmp = {}\n   local i = 0\n   while i < #lst do\n      table.insert(tmp,\
    \ lst[i])\n      i = i + 1\n   end\n   table.sort(tmp)\n   for i, v in pairs(tmp)\
    \ do\n      lst[i] = v\n   end\n   return lst\nend", "  local min_index = nil\n\
    \  local max_index = nil\n  local min_value = nil", "  local lst2 = {}\n  for\
    \ k, v in pairs(lst) do\n    table.insert(lst2, v)\n  end\n  return lst2\nend",
  "  local new_lst = lst\n  local pos = 1\n  for i = #lst, 1, -1 do\n    pos = i\n\
    \    break\n  end\n  for i = #lst, 1, -1 do\n    local j = pos\n    local k =\
    \ 0\n    while j ~= i do\n      if new_lst[j] > new_lst[k] then\n        new_lst[j],\
    \ new_lst[k] = new_lst[k], new_lst[j]\n      end\n      j = j - 1\n      k = k\
    \ + 1\n    end\n  end\n  return new_lst\nend", "  if #lst < 2 then\n    return\
    \ lst\n  end\n  local last_min = lst[1]\n  local last_max = lst[1]\n  for i =\
    \ 2, #lst do\n    if lst[i] < last_min then\n      last_min = lst[i]\n    elseif\
    \ last_min < lst[i] then\n      last_min = last_min\n    elseif lst[i] > last_max\
    \ then\n      last_max = lst[i]\n    end\n  end\n  local lst_copy = lst\n  lst_copy[#lst_copy]\
    \ = last_min\n  lst_copy[#lst_copy + 1] = last_max\n  return strange_sort_list(lst_copy)\n\
    end", "  if lst:len() == 0 then return nil end\n  local sorted_list = lst\n  sorted_list:sort()\n\
    \  local n = #sorted_list\n  for i = 1, n - 1 do\n    local tmp = sorted_list[i]\n\
    \    sorted_list[i] = sorted_list[i + 1]\n    sorted_list[i + 1] = tmp\n  end\n\
    \  return sorted_list\nend\n</cell>\n<text>\nExercise 10\nWrite a function that\
    \ takes a number as input and returns the number of different permutations of\
    \ the given numbers.", "  local n = #lst\n  local mn = lst[1]\n  local mx = lst[1]\n\
    \  for i = 2, n do\n    mx = math.max(mx, lst[i])\n  end\n  local i = 1\n  local\
    \ ret = {}\n  while i < n do\n    if mx < lst[i] then\n      table.insert(ret,\
    \ mx)\n      mx = lst[i]\n    end\n    mx = math.max(mx, lst[i])\n    i = i +\
    \ 1\n  end\n  table.insert(ret, mx)\n  return ret\nend", "  local max_idx = #lst\n\
    \  local idx", "    local new_lst = {}\n    local i = #lst\n    for j = 0, i do\n\
    \        local min = lst[j]\n        local max = lst[i]\n        if min ~= max\
    \ then\n            lst[i], lst[j] = max, min\n        end\n        new_lst:insert(lst[i])\n\
    \    end\n    return new_lst\nend", "  local minimum = lst[1]\n  local maximum\
    \ = lst[#lst]", "  local result = {}\n  local min = math.min(lst)\n  local max\
    \ = math.max(lst)\n  while min ~= max do\n    table.insert(result, min)\n    min\
    \ = min + 1\n    max = max - 2\n  end\n  table.insert(result, max)\n  table.sort(result)\n\
    \  return result\nend", "  local sorted_lst = lst\n  local i = 1\n  for i, item\
    \ in pairs(sorted_lst) do\n    sorted_lst[i], sorted_lst[i - 1] = sorted_lst[i\
    \ - 1], sorted_lst[i]\n  end\n  return sorted_lst\nend", "  local results = {}\n\
    \  for _, v in ipairs(lst) do\n    results[#results + 1] = v\n  end\n  table.sort(results,\
    \ function (a,b) return a < b end)\n  return results\nend", "    local tmp = lst[1]\n\
    \    lst[1] = lst[#lst]\n    lst[#lst] = tmp\n    return lst\nend", "   local\
    \ sorted = {}\n   for _, value in ipairs(lst) do\n      table.insert(sorted, value)\n\
    \   end\n   table.sort(sorted)\n   return sorted\nend", "  local len = #lst\n\
    \  local index = len\n  while index > 0 do\n    local element = lst[index]\n \
    \   if element > lst[index - 1] then\n      lst[index], lst[index - 1] = lst[index\
    \ - 1], lst[index]\n      index -= 1\n    end\n    if element > lst[index - 1]\
    \ then\n      lst[index], lst[index - 1] = lst[index - 1], lst[index]\n      index\
    \ -= 1\n    end\n    if element > lst[index - 1] then\n      lst[index], lst[index\
    \ - 1] = lst[index - 1], lst[index]\n      index -= 1\n    end\n  end\n  return\
    \ lst\nend", "  local l\n  for _, l in ipairs(lst) do\n    local minimum = l\n\
    \    local maximum = l\n    for _, v in ipairs(lst) do\n      if v < minimum then\
    \ minimum = v end\n      if v > maximum then maximum = v end\n    end\n    if\
    \ minimum == maximum then\n      return lst\n    end\n    local swap = minimum\n\
    \    for _, v in ipairs(lst) do\n      if v > swap then\n        lst[#lst + 1]\
    \ = minimum\n        lst[minimum] = v\n        minimum = v\n      else\n     \
    \   lst[minimum] = v\n      end\n    end\n    lst[minimum] = swap\n  end\n  return\
    \ lst\nend", "  local minimum = lst[1]\n  local maximum = lst[1]\n  for i = 2,\
    \ #lst do\n    if minimum > lst[i] then\n      minimum = lst[i]\n    end\n   \
    \ if lst[i] > maximum then\n      maximum = lst[i]\n    end\n  end\n  minimum,\
    \ maximum = minimum, maximum\n  for i = 2, #lst do\n    if minimum > lst[i] then\n\
    \      minimum = lst[i]\n    end\n    if lst[i] > maximum then\n      maximum\
    \ = lst[i]\n    end\n  end\n  minimum, maximum = minimum, maximum\n  return minimum,\
    \ maximum\nend", "  local lst2 = {}\n  for idx, v in pairs(lst) do\n    table.insert(lst2,\
    \ v)\n  end\n  table.sort(lst2)\n  local ret = {}\n  for i, v in pairs(lst2) do\n\
    \    table.insert(ret, v)\n  end\n  return ret\nend", "    if lst == nil then\n\
    \        return nil\n    end\n    local sorted_list = table.copy(lst)\n    table.sort(sorted_list)\n\
    \    return sorted_list\nend", "  local result\n  if #lst == 0 then\n    result\
    \ = {lst}\n  else\n    local minimum = lst[1]\n    local maximum = lst[1]\n  \
    \  for i = 2, #lst do\n      minimum = minimum > lst[i] and minimum or lst[i]\n\
    \      maximum = maximum < lst[i] and maximum or lst[i]\n    end\n    result =\
    \ { minimum, maximum }\n  end\n  return result\nend", "  local result = {}\n \
    \ local min = lst[1]\n  local max = lst[1]\n  for i = 2, #lst do\n    if lst[i]\
    \ < min then\n      min = lst[i]\n    end\n    if lst[i] > max then\n      max\
    \ = lst[i]\n    end\n  end\n  for i = 1, #lst do\n    table.insert(result, min)\n\
    \    table.insert(result, max)\n  end\n  return result\nend", "  if lst[1] ==\
    \ nil then\n    return nil\n  end\n  local min = lst[1]\n  local new_lst = lst\n\
    \  local i = 0\n  for i = 1, #lst do\n    if lst[i] < min then\n      min = lst[i]\n\
    \    end\n    new_lst[i] = min\n  end\n  for i = #lst, 1, -1 do\n    new_lst[i]\
    \ = nil\n  end\n  return new_lst\nend", "   local i = 1\n   while i <= #lst do\n\
    \      if i > #lst or lst[i] < lst[i-1] then\n         return table.sort(lst)\n\
    \      end\n      i = i + 1\n   end\n   return lst\nend", "  local sorted = {}\n\
    \  local minimum = #lst\n  for i = 1, #lst do\n    for j = minimum, #lst do --\
    \ find maximum\n      if lst[j] < lst[i] then\n        minimum = j\n      end\n\
    \    end\n    table.insert(sorted, lst[minimum])\n    minimum = minimum - 1\n\
    \  end\n  return sorted\nend", "  local new_lst = {}\n  for i = 1, #lst do\n \
    \   new_lst[#new_lst + 1] = lst[i]\n  end\n  table.sort(new_lst, function(x, y)\n\
    \    if x < y then\n      return -1\n    elseif x > y then\n      return 1\n \
    \   else\n      return 0\n    end\n  end)\n  return new_lst\nend", "  local num_strange\
    \ = 0\n  local lst2 = {}\n  local i = 1\n  local j = 1\n  while i < #lst do\n\
    \    while j < #lst do\n      if lst[i] < lst[j] then\n        table.insert(lst2,\
    \ lst[i])\n        i = i + 1\n      else\n        table.insert(lst2, lst[j])\n\
    \        j = j + 1\n      end\n    end\n    num_strange = num_strange + 1\n  \
    \  i = i + 2\n    j = j + 2\n  end\n  if #lst > 0 then\n    table.insert(lst2,\
    \ lst[#lst])\n  end\n  return lst2\nend", "\tlocal min_value = math.min(lst)\n\
    \tlocal max_value = math.max(lst)\n\tfor i = 1, #lst do\n\t\tif i == 1 then\n\t\
    \t\tlst[i] = min_value\n\t\telse\n\t\t\tif lst[i] == max_value then\n\t\t\t\t\
    lst[i] = min_value\n\t\t\t\tlst[i-1], max_value = max_value, lst[i-1]\n\t\t\t\
    elseif lst[i] == min_value then\n\t\t\t\tlst[i] = max_value\n\t\t\t\tlst[i-1],\
    \ min_value = min_value, lst[i-1]\n\t\t\telse\n\t\t\t\tlst[i], lst[i-1] = lst[i-1],\
    \ lst[i]\n\t\t\t\tlst[i], lst[i-1] = lst[i], lst[i]\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn lst\nend", "  -- sort, but then copy back\n  local lst2 = {}\n  local\
    \ n = 1\n  for i = #lst, 1, -1 do\n    lst2[n] = lst[i]\n    n = n + 1\n  end\n\
    \  return lst2\nend", "  local i = 1\n  while i <= #lst do\n    local tmp = lst[i]\n\
    \    lst[i] = lst[i - 1]\n    lst[i - 1] = tmp\n    i = i + 1\n  end\n  return\
    \ lst\nend", "  local new_lst = {}\n  for _, elem in ipairs(lst) do\n    new_lst[new_#new_lst\
    \ + 1] = elem\n  end\n  table.sort(new_lst)\n  return new_lst\nend", "  -- We\
    \ need to use lst with nil elements because nil elements don't compare smaller\
    \ than other nil elements.\n  -- To use nil elements as a sentinel, add sentinel\
    \ to beginning and end of lst.\n  -- (nil elements are greater than nil elements).\n\
    \  local sentinel = nil\n  lst = lst or {}\n  lst:insert(sentinel)\n  lst:insert(sentinel)\n\
    \  lst = lst:concat(nil)\n  -- We can't use lst.sort because nil elements are\
    \ greater than nil elements and it just reverses the ordering.\n  -- We also can't\
    \ use table.sort because nil elements are considered greater than other nil elements.\n\
    \  local i = 0\n  local last\n  repeat\n    last = lst[i]\n    i = i + 1\n  until\
    \ i < #lst\n  -- We reverse the order of the list to start with the minimum element.\n\
    \  lst = lst:reverse()\n  -- The loop is only done if there are at least two elements.\n\
    \  -- The loop can be stopped because there are no more elements to compare\n\
    \  -- with the current minimum element.\n  if #lst < 2 then return lst end\n \
    \ -- Set the minimum element to the first element in the list\n  lst[1] = lst[1]\n\
    \  -- Set the current element to the first element in the list\n  lst[2], lst[1]\
    \ = lst[1], lst[2]\n  -- While there are elements to compare with the minimum\
    \ element in the list.\n  -- Compare with the current minimum element and with\
    \ the first element in the list.\n  while i < #lst do\n    -- If the current element\
    \ (current value) doesn't compare with the minimum element.\n    -- Compare with\
    \ the next element in the list.\n    if lst[i] ~= last then\n      -- Set current\
    \ element to the first element in the list\n      lst[2], lst[1] = lst[1], lst[2]\n\
    \      -- Compare with the next element in the list.\n      lst[i], lst[2] = lst[2],\
    \ lst[i]\n    end\n    i = i + 1\n  end\n  -- The loop will stop if there are\
    \ no more elements to compare\n  -- with the current minimum element.\n  -- Therefore,\
    \ if the loop isn't stopped, then there are no more elements to compare\n  --\
    \ with the minimum element. Therefore, we return the list as is.\n  return lst\n\
    end", "  local temp = {}\n  table.sort(lst, function (x,y) return x < y end)\n\
    \  for i = #lst, 1, -1 do\n    table.insert(temp, lst[i])\n  end\n  return temp\n\
    end", "  local temp = {}\n  for _, value in ipairs(lst) do\n    table.insert(temp,\
    \ value)\n  end\n  table.sort(temp)\n  return temp\nend", "   local min = math.min(lst)\n\
    \   local max = math.max(lst)\n   local new_lst = lst\n   for i = 1, #lst do\n\
    \      local value = lst[i]\n      if value < min then\n         min = value\n\
    \         new_lst[i] = max\n      elseif value > max then\n         max = value\n\
    \         new_lst[i] = min\n      else\n         new_lst[i] = value\n      end\n\
    \   end\n   return new_lst\nend", "  if #lst == 1 then\n    return lst\n  end\n\
    \  local first = lst[1]\n  local rest = strange_sort_list(lst[2:])\n  local rest1\
    \ = rest[1]\n  local rest2 = rest[2]\n  local rest3 = rest[3]\n  return table.concat({first,\
    \ rest1, rest2, rest3})\nend", "  local strange_list = lst\n  local sorted_list\
    \ = lst", "  -- If list has only one item, return the same list\n  if #lst ==\
    \ 1 then\n    return lst\n  end\n  -- If there is only one item in the list, return\
    \ that item\n  if #lst == 0 then\n    return lst\n  end\n  -- Pick minimum from\
    \ the list\n  local minimum = lst[1]\n  -- Set minimum to nil, so that we can\
    \ break the loop later\n  minimum = nil\n  -- For every remaining element, pick\
    \ minimum\n  for i = 2, #lst do\n    -- If current element is less than minimum,\
    \ update minimum\n    if lst[i] < minimum then\n      minimum = lst[i]\n    end\n\
    \    -- If current element is the minimum, break the loop\n    if lst[i] == minimum\
    \ then\n      break\n    end\n  end\n  -- If minimum is nil, there are no elements\
    \ in the list, return empty list\n  if minimum == nil then\n    return {}\n  end\n\
    \  -- If minimum is the last element, just return list, since it is already sorted\n\
    \  if minimum == lst[#lst] then\n    return lst\n  end\n  -- Reverse the list\n\
    \  local reversed = {}\n  for i = #lst, 1, -1 do\n    reversed[#reversed + 1]\
    \ = lst[i]\n  end\n  -- Return the reversed list\n  return reversed\nend", " \
    \ -- First get maximum and minimum of list.\n  local max = math.max(lst)\n  local\
    \ min = math.min(lst)\n  -- Then, create new list with these two values.\n  local\
    \ strange_list = {}\n  for i=1,#lst do\n    table.insert(strange_list, lst[i])\n\
    \    table.insert(strange_list, max)\n    table.insert(strange_list, min)\n  end\n\
    \  return strange_list\nend", "  -- Base case: empty list\n  if #lst == 0 then\n\
    \    return lst\n  end", "  -- We start with the minimum value of the list.\n\
    \  local min_idx = 1\n  -- Iterate over all the integers in the list.\n  for idx\
    \ = 2, #lst do\n    -- If we're still on the minimum value of the list,\n    --\
    \ we swap the two values.\n    if lst[min_idx] > lst[idx] then\n      lst[min_idx],\
    \ lst[idx] = lst[idx], lst[min_idx]\n    end\n    -- We increment the minimum\
    \ value of the list so we don't\n    -- go out of bounds during the iteration.\n\
    \    min_idx = min_idx + 1\n  end\n  -- If the list has no integers, it means\
    \ that we started with the minimum value.\n  if #lst == 0 then\n    lst[1]\n \
    \ end\n  return lst\nend", "  -- Sort numbers in ascending order and then reverse.\n\
    \  return list.sort(lst, function(_, a) return a end)\nend", "  local sorted_lst\
    \ = lst\n  local min_value = sorted_lst[1]\n  sorted_lst[1] = sorted_lst[#sorted_lst]\n\
    \  table.sort(sorted_lst)\n  for i = 2, #sorted_lst do\n    local value = sorted_lst[i]\n\
    \    if value < min_value then\n      min_value = value\n    end\n    table.insert(sorted_lst,\
    \ min_value)\n  end\n  table.sort(sorted_lst)\n  return sorted_lst\nend", "  local\
    \ i = 0\n  local j = 0\n  local max = lst[1]\n  for _, num in ipairs(lst) do\n\
    \    i = i + 1\n    max = math.max(max, num)\n  end\n  for _, num in ipairs(lst)\
    \ do\n    j = j + 1\n    lst[j] = num\n  end\n  for i = 1, #lst do\n    lst[max\
    \ - i] = lst[max - i] - 1\n  end\n  return lst\nend", "  if #lst<=0 then\n   \
    \ return lst\n  end\n  local min = lst[1]\n  local tmp = {}\n  for i=2,#lst do\n\
    \    if lst[i] < min then\n      tmp[#tmp+1] = lst[i]\n    elseif lst[i] > min\
    \ then\n      min = lst[i]\n    end\n  end\n  tmp[#tmp+1] = min\n  return tmp\n\
    end", "  local min = lst[1]\n  local max = lst[#lst]\n  local sorted_lst = {}\n\
    \  for i = 1, #lst do\n    if lst[i] < min then\n      min = lst[i]\n    elseif\
    \ lst[i] > max then\n      max = lst[i]\n    end\n    table.insert(sorted_lst,\
    \ min)\n  end\n  table.insert(sorted_lst, max)\n  return sorted_lst\nend", " \
    \ -- We will use as temporary variable a list where we put the\n  -- unsorted\
    \ part. Remember that, by definition, \n  -- lst[1] <= lst[1].., lst[1] > lst[1]..,\
    \ etc.\n  -- Also, if the list length is odd, then the last element\n  -- is already\
    \ in correct order, so we don't need to worry about it.\n  local temp_lst = {lst[1]}\n\
    \  -- Now we iterate over rest of the list\n  for i = 2, #lst do\n    -- We add\
    \ unsorted list element to temporary variable\n    table.insert(temp_lst, lst[i])\n\
    \    -- If current element is not in correct order, then\n    -- we swap it with\
    \ last element in temporary variable\n    if lst[i] > temp_lst[#temp_lst] then\n\
    \      table.insert(temp_lst, temp_lst[#temp_lst])\n      table.insert(temp_lst,\
    \ lst[i])\n    end\n  end\n  -- Finally, we reorder the list in the way we expect\
    \ it.\n  -- We put temp_lst[0] at the end, so it's always in correct order.\n\
    \  return table.concat(temp_lst, \", \")\nend", "    local temp = {}\n    for\
    \ i = 1, #lst do\n        table.insert(temp, lst[i])\n    end\n    table.sort(temp)\n\
    \    return temp\nend", "    local lst = lst\n    if lst[1] == nil then\n    \
    \    lst[1] = lst[2]\n        lst[2] = nil\n    end\n    if lst[#lst] == nil then\n\
    \        lst[#lst] = lst[1]\n        lst[1] = nil\n    end\n    if lst[1] == nil\
    \ then\n        lst[1] = lst[2]\n        lst[2] = nil\n    end\n    if lst[#lst]\
    \ == nil then\n        lst[#lst] = lst[1]\n        lst[1] = nil\n    end\n   \
    \ if lst[1] == nil then\n        lst[1] = lst[2]\n        lst[2] = nil\n    end\n\
    \    if lst[#lst] == nil then\n        lst[#lst] = lst[1]\n        lst[1] = nil\n\
    \    end\n    return lst\nend", "  if #lst == 0 then\n    return lst\n  end\n\
    \  local sorted_list = {}\n  local minimum = lst[1]\n  local maximum = lst[#lst]\n\
    \  for i = 2, #lst do\n    local current = lst[i]\n    if current < minimum then\n\
    \      minimum = current\n    elseif current > maximum then\n      maximum = current\n\
    \    end\n  end\n  minimum = strange_sort_list(minimum, lst)\n  maximum = strange_sort_list(maximum,\
    \ lst)\n  for i = 1, #lst do\n    sorted_list[i] = lst[i]\n  end\n  local function\
    \ swap(a, b)\n    local temp = sorted_list[a]\n    sorted_list[a] = sorted_list[b]\n\
    \    sorted_list[b] = temp\n  end\n  for i = 1, #minimum, 2 do\n    swap(i, i\
    \ + 1)\n  end\n  return sorted_list\nend\n</code>\nThe function takes a list and\
    \ returns a new list with the integers in strange order where minimum element\
    \ is at the beginning, then maximum, then the rest of the elements.\n<|/ a |>\n\
    <| a dscore=2 tags=lua |>\n<code>", "  local temp_list = {}\n  for i = 2, #lst\
    \ do\n    if lst[i] < lst[i - 1] then\n      table.insert(temp_list, lst[i])\n\
    \    end\n  end\n  for i = 2, #temp_list do\n    table.insert(temp_list, lst[i])\n\
    \  end\n  return temp_list\nend", "  -- Sorting is O(n^2)\n  -- We cannot sort\
    \ with bubble sort\n  -- So we make another array\n  -- And then sort that one\n\
    \  local sorted\n  if #lst < 2 then\n    sorted = lst\n    return\n  end", " \
    \   local newlst = {}\n    for i = 1, #lst do\n        local tmp = lst[i]\n  \
    \      local j = i\n        while j > 1 do\n            -- Check if new value\
    \ is smaller.\n            if tmp < lst[j - 1] then\n                -- If yes,\
    \ swap.\n                lst[j] = lst[j - 1]\n                lst[j - 1] = tmp\n\
    \                j = j - 1\n            else\n                -- If no, move on.\n\
    \                j = j - 1\n            end\n        end\n        newlst[#newlst+1]\
    \ = tmp\n    end\n    return newlst\nend", "    local new_lst = {}\n    local\
    \ min = table.unpack(lst):sort()[1]\n    local max = min:reverse()\n    for i=1,#lst\
    \ do\n        table.insert(new_lst, lst[i])\n    end\n    table.insert(new_lst,\
    \ min)\n    table.insert(new_lst, max)\n    return new_lst\nend", "  -- Sort by\
    \ minimum first\n  -- Then by maximum\n  -- Then by minimum of remaining values\n\
    \  if lst:len() == 0 then return end\n  local l1, l2 = lst:sort()\n  return l1,\
    \ l2, strange_sort_list(l2)\nend", "    local min = table.min(lst)\n    local\
    \ max = table.max(lst)\n    if min ~= max then\n        local i = #lst\n     \
    \   while i ~= 1 do\n            local p = math.floor((i - 1) / 2)\n         \
    \   local q = (i - 1) % 2\n            lst[i], lst[p] = lst[p], lst[i]\n     \
    \       if min > lst[p] then\n                lst[p], lst[q] = lst[q], lst[p]\n\
    \            end\n            i = p\n        end\n    end\n    return lst\nend",
  "\tlocal min = lst[1]\n\tlocal max = 1\n\tfor i = 2, #lst do\n\t\tmax = max or lst[i]\n\
    \t\tif min > max then\n\t\t\tmin = lst[i]\n\t\tend\n\tend\n\tif min < max then\n\
    \t\treturn lst\n\telse\n\t\treturn strange_sort_list({min, max})\n\tend\nend",
  "  local min, max = math.min(lst), math.max(lst)\n  local min_index = 1\n  local\
    \ max_index = 1\n  for i = 1, #lst do\n    if lst[i] == min then\n      min_index\
    \ = i\n      break\n    end\n    if lst[i] == max then\n      max_index = i\n\
    \      break\n    end\n  end\n  if min_index == 1 then\n    -- If list is all\
    \ same value, sort it by itself\n    lst = lst\n  else\n    -- Move max to the\
    \ end\n    lst[max_index] = lst[#lst]\n    lst[#lst] = max\n  end\n  local result\
    \ = {}\n  for i = 1, #lst do\n    result[#result+1] = lst[i]\n  end\n  return\
    \ result\nend", "  local lmin = math.min(lst)\n  local lmax = math.max(lst)\n\
    \  local lmid\n  local lmiddle\n  for i = 1, lmax do\n    lmid = lmin + (i - lmin)\
    \ / 2\n    lmiddle = lst[lmid]\n    if lmiddle < lmin then break end\n    lst[lmid],\
    \ lst[i] = lst[i], lst[lmid]\n  end\n  return lst\nend", "  local i = #lst\n \
    \ while i > 1 do\n    local first_value = lst[i]\n    local j = 1\n    while j\
    \ <= i do\n      local second_value = lst[j]\n      if second_value < first_value\
    \ then\n        lst[j] = first_value\n        i = j\n      else\n        lst[j]\
    \ = second_value\n        i = j\n      end\n      j = j + 1\n    end\n    i =\
    \ i - 1\n  end\n  return lst\nend", "  local min = lst[1]\n  local max_index =\
    \ #lst -- don't need to check nil index\n  for i = 2, max_index do\n    min =\
    \ lst[i] or min\n  end\n  local rest = rest(lst)\n  return rest:gsub(function(elem)\
    \ return elem < min or nil end,\n\t\t      function(elem) return elem ~= min and\
    \ elem or min end,\n\t\t      function(elem) return elem > min and nil end)\n\
    end", "  local sorted = {}\n  for i=1,#lst do\n    table.insert(sorted,lst[i])\n\
    \    table.insert(sorted,lst[#sorted])\n  end\n  return sorted\nend", "    if\
    \ #lst == 0 then\n        return nil\n    end\n    local minimum = lst[1]\n  \
    \  local maximum = lst[1]\n    for _, item in ipairs(lst) do\n        if minimum\
    \ > item then\n            minimum = item\n        end\n        if maximum < item\
    \ then\n            maximum = item\n        end\n    end\n    local results =\
    \ {}\n    for _, item in ipairs(lst) do\n        if item > minimum then\n    \
    \        results[#results + 1] = item\n        end\n        if item < maximum\
    \ then\n            results[#results + 1] = item\n        end\n    end\n    table.sort(results,\
    \ function(a, b) return a < b end)\n    return results[1]\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nHi Steve,", "    if lst==nil then\n        return nil\n\
    \    end", "  local tmp_lst = {}\n  for _, v in pairs(lst) do\n    table.insert(tmp_lst,\
    \ v)\n  end\n  table.sort(tmp_lst, function (a,b) return a < b end)\n  return\
    \ tmp_lst\nend", "  local index = 1\n  local minElement = unpack(lst)[1]\n  local\
    \ maxElement = unpack(lst)[1]", "  local sorted_lst = {}\n  for i = 1, #lst do\n\
    \    table.insert(sorted_lst, lst[i])\n  end\n  table.sort(sorted_lst, function(_,\
    \ index2)\n    return index2\n  end)\n  return sorted_lst\nend", "  if not lst:istuple()\
    \ then\n    error(\"strange_sort_list: lst must be a list of integers\")\n  end\n\
    \  local lst2 = {}\n  for _, v in ipairs(lst) do\n    lst2[#lst2 + 1] = v\n  end\n\
    \  table.sort(lst2, function(a, b) return a < b end)\n  return table.concat(lst2)\n\
    end", "   local minimum = lst[1]\n   local maximum = lst[1]\n   for i = 2, #lst\
    \ do\n      if minimum > lst[i] then\n         minimum = lst[i]\n      elseif\
    \ maximum < lst[i] then\n         maximum = lst[i]\n      else\n         return\
    \ lst\n      end\n   end\n   if minimum > maximum then\n      local temp = minimum\n\
    \      minimum = maximum\n      maximum = temp\n   end\n   local new_lst = minimum\n\
    \   for i = 1, #lst - 1 do\n      new_lst = lst[i]:gsub(\".\", function(x)\n \
    \        return string.format(\"%f\", new_lst)\n      end)\n   end\n   new_lst\
    \ = maximum:gsub(\".\", function(x)\n      return string.format(\"%f\", new_lst)\n\
    \   end)\n   return new_lst\nend\nprint(strange_sort_list([1, 2, 3, 4]))\nprint(strange_sort_list([5,\
    \ 5, 5, 5]))\nprint(strange_sort_list([]))\nprint(strange_sort_list({\"a\", \"\
    b\", \"c\", \"d\"}))\nprint(strange_sort_list({\"ab\", \"ac\", \"ad\", \"ae\"\
    }))", "    if not lst then return [] end\n    local n = 1\n    for i = 2, #lst\
    \ do\n        -- Store current maximum\n        if lst[i] > lst[i - 1] then\n\
    \            n = i - 1\n        end\n    end\n    table.sort(lst, function(a,\
    \ b) return a[#lst] <= b[#lst] end)\n    for i = 1, #lst do\n        table.insert(lst,\
    \ lst[n])\n        -- Store current minimum value\n        lst[i] = lst[#lst]\n\
    \    end\n    return lst\nend", "    local function swap(a, b)\n        local\
    \ tmp = a\n        a = b\n        b = tmp\n    end", "  local tmp_lst = {}\n \
    \ for i=1,#lst do\n    tmp_lst[#tmp_lst+1] = lst[i]\n  end\n  table.sort(tmp_lst,\
    \ function(i,j) return j<i end)\n  return tmp_lst\nend", "  local lst, i = listx.new(),\
    \ 0\n  while i < #lst do\n    -- Take first element in list\n    local e1 = lst[i]\n\
    \    -- Move to its position\n    i = (i + 1) % #lst\n    -- Take next element\n\
    \    local e2 = lst[i]\n    -- Move to its position\n    i = (i + 1) % #lst\n\
    \    -- Compare and swap\n    if e1 > e2 then\n      lst[i], lst[i+1] = lst[i+1],\
    \ lst[i]\n    end\n  end\n  return lst\nend", "  local function cmp(a, b)\n  \
    \  if a < b then\n      return -1\n    end\n    if a == b then\n      return 0\n\
    \    end\n    return 1\n  end", "  local min = #lst\n  local max = #lst\n  if\
    \ min == 0 then\n    return {}\n  end\n  if min == 1 then\n    return lst\n  end\n\
    \  if min > max then\n    return strange_sort_list(lst)\n  end\n  if min > #lst\
    \ then\n    return strange_sort_list(lst)\n  end\n  local min_index = #lst + 1\n\
    \  while min_index < max do\n    local min_index = min_index + 1\n    local current\
    \ = lst[min_index]\n    for i = min_index + 1, #lst do\n      if current < lst[i]\
    \ then\n        min = min_index\n        break\n      end\n    end\n  end\n  local\
    \ output = lst\n  for i = min + 2, #lst do\n    table.insert(output, lst[i])\n\
    \  end\n  return output\nend", "    if #lst == 0 then\n        return nil\n  \
    \  end", "  local min = lst[1]\n  local max = lst[1]\n  local pos = 1\n  for i\
    \ = 2, #lst do\n    local val = lst[i]\n    if val < min then\n      min = val\n\
    \    elseif val > max then\n      max = val\n    end\n    pos = pos + 1\n  end\n\
    \  local lst2 = {}\n  lst2[pos] = min\n  lst2[#lst2 + 1] = max\n  for i = 2, #lst\
    \ do\n    lst2[#lst2 + 1] = lst[i]\n  end\n  return lst2\nend", "  local min_value\
    \ = nil\n  local max_value = nil\n  local results = {}\n  for _, v in ipairs(lst)\
    \ do\n    if min_value == nil then\n      min_value = v\n    else\n      if min_value\
    \ > v then\n        min_value = v\n      else\n        if max_value == nil then\n\
    \          max_value = v\n        else\n          if max_value < v then\n    \
    \        max_value = v\n          else\n            table.insert(results, min_value)\n\
    \            min_value = max_value\n            max_value = nil\n          end\n\
    \        end\n      end\n    end\n  end\n  if max_value ~= nil then\n    table.insert(results,\
    \ max_value)\n  end\n  return results\nend", "  local result\n  local minimum\
    \ = math.min(lst)\n  local maximum = math.max(lst)\n  local middle = minimum +\
    \ ((maximum - minimum) / 2)", "  if #lst == 0 then\n    return lst\n  end\n  local\
    \ function helper(idx, lst, val)\n    if idx == #lst then\n      lst[idx] = val\n\
    \      return lst\n    end\n    helper(idx+1, lst, lst[idx])\n    helper(idx+1,\
    \ lst, lst[idx])\n  end\n  helper(1, lst, lst[1])\n  helper(1, lst, lst[1])\n\
    \  return lst\nend", "  local min\n  local max\n  for i, x in ipairs(lst) do\n\
    \    if not min or x < min then\n      min = x\n    end\n    if not max or x >\
    \ max then\n      max = x\n    end\n  end\n  \n  local strange = {}\n  \n  for\
    \ i = min, max + 1 do\n    table.insert(strange, i)\n  end\n  \n  table.sort(strange)\n\
    \  \n  local res = {}\n  for i = 1, #strange do\n    table.insert(res, strange[i])\n\
    \  end\n  \n  return res\nend", "  local s = lst[1]\n  lst[1] = lst[#lst]\n  lst[#lst]\
    \ = s\n  return lst\nend", "  local min = lst[1]\n  local max = lst[1]\n  for\
    \ i = 1, #lst do\n    if lst[i] > max then\n      max = lst[i]\n    elseif lst[i]\
    \ < min then\n      min = lst[i]\n    end\n  end\n  local i = #lst\n  while i\
    \ ~= 1 do\n    lst[i], lst[i - 1] = lst[i - 1], lst[i]\n    i = i >> 1\n  end\n\
    \  return lst\nend", "  assert(#lst > 0)\n  local min_lst = lst[1]\n  local max_lst\
    \ = lst[#lst]\n  local i, j, k = 1, #lst, #lst\n  while i <= j do\n    while i\
    \ <= j do\n      local m = i - 1\n      local n = k + 1\n      while n <= j do\n\
    \        if lst[m] < lst[n] then\n          m = m + 1\n        else\n        \
    \  n = n + 1\n        end\n      end\n      lst[i], lst[m] = lst[m], lst[i]\n\
    \      i = m + 1\n      k = n + 1\n    end\n    if lst[i] < min_lst then\n   \
    \   min_lst = lst[i]\n    end\n    if lst[i] > max_lst then\n      max_lst = lst[i]\n\
    \    end\n    i = i + 1\n  end\n  if min_lst == lst[1] then\n    lst[1] = nil\n\
    \  end\n  if max_lst == lst[#lst] then\n    lst[#lst] = nil\n  end\n  local result\
    \ = {}\n  for i = 1, #lst do\n    if lst[i] ~= nil then\n      result[i] = lst[i]\n\
    \    end\n  end\n  return result\nend", "  local function compare_values(v1, v2)\n\
    \    if v1 <= v2 then\n      return 1\n    elseif v1 < v2 then\n      return -1\n\
    \    end", "  if #lst < 1 then\n    return lst\n  end", "  local tmp_sorted =\
    \ {}\n  local tmp_sorted_insert = false\n  for i = 1, #lst do\n    -- get current\
    \ value from list\n    local cur_val = lst[i]\n    -- get the key of the current\
    \ value\n    local cur_key_index = #tmp_sorted\n    -- insert the current value\
    \ in tmp_sorted\n    table.insert(tmp_sorted, cur_val)\n    -- move the remaining\
    \ values to the correct place in the sorted list\n    while i <= #lst and not\
    \ tmp_sorted_insert do\n      -- get the next value from list\n      local next_val\
    \ = lst[i]\n      -- get the key index of the next value\n      local next_key_index\
    \ = #tmp_sorted\n      -- move the remaining values into the correct place in\
    \ the sorted list\n      if next_val == cur_val then\n        table.insert(tmp_sorted,\
    \ next_val)\n      else\n        -- swap the values\n        table.swap(tmp_sorted,\
    \ cur_key_index, next_key_index)\n        -- move the remaining values to the\
    \ correct place in the sorted list\n        tmp_sorted_insert = true\n      end\n\
    \      i = i + 1\n    end\n  end\n  -- return the sorted list\n  return tmp_sorted\n\
    end", "   local lst = lst\n   local index = 1\n   local strange_sorted_lst = {}\n\
    \   for index, value in ipairs(lst) do\n      if index > 1 then\n         local\
    \ current_min = lst[index]\n         local current_max = lst[index - 1]\n    \
    \     if value < current_min then\n            table.insert(strange_sorted_lst,\
    \ current_min)\n         elseif value > current_max then\n            table.insert(strange_sorted_lst,\
    \ current_max)\n         else\n            table.insert(strange_sorted_lst, value)\n\
    \         end\n      end\n   end\n   return strange_sorted_lst\nend", "    local\
    \ i, min = 0, 1\n    for i = #lst, 1, -1 do\n        min = min > lst[i] and lst[i]\
    \ or min\n    end\n    local j, max = 0, min\n    for i = #lst, 1, -1 do\n   \
    \     max = max < lst[i] and lst[i] or max\n    end\n    if #lst == 1 then\n \
    \       return lst\n    elseif #lst == 2 then\n        lst[1], lst[2] = lst[2],\
    \ lst[1]\n        return lst\n    elseif #lst == 3 then\n        if min == max\
    \ then\n            lst[1], lst[2], lst[3] = lst[3], lst[1], lst[2]\n        elseif\
    \ min == lst[2] then\n            lst[1], lst[2], lst[3] = lst[1], lst[2], lst[3]\n\
    \        else\n            lst[1], lst[2], lst[3] = lst[1], lst[2], min .. ','\
    \ .. max\n        end\n        return lst\n    end\nend", "  local strange = {}\n\
    \  for i = 1, #lst do\n    -- Get the minimum and maximum of all remaining numbers.\n\
    \    local min, max = lst[i], lst[#lst]\n    -- Sort them in strange order.\n\
    \    for j = #lst, 1, -1 do\n      if lst[j] < min then\n        lst[j], lst[i]\
    \ = lst[i], lst[j]\n      elseif lst[j] > max then\n        lst[j], lst[i] = lst[i],\
    \ lst[j]\n      end\n    end\n    -- Put min and max into strange table.\n   \
    \ table.insert(strange, min)\n    table.insert(strange, max)\n  end\n  return\
    \ strange\nend", "  local minimum = lst[1]\n  local maximum = lst[1]\n  for _,\
    \ value in ipairs(lst) do\n    if value < minimum then minimum = value end\n \
    \   if value > maximum then maximum = value end\n  end\n  local min_lst = {}\n\
    \  local max_lst = {}\n  for _, value in ipairs(lst) do\n    if value < minimum\
    \ then\n      table.insert(min_lst, value)\n    elseif value > maximum then\n\
    \      table.insert(max_lst, value)\n    else\n      table.insert(min_lst, minimum)\n\
    \      table.insert(max_lst, maximum)\n      minimum = minimum - 1\n      maximum\
    \ = maximum + 1\n    end\n  end\n  return min_lst\nend", "  if not lst or #lst\
    \ < 2 then\n    return lst\n  end", "  -- The length of the list is always even.\n\
    \  local len = #lst\n  if len % 2 == 1 then\n    error(\"List length must be even\"\
    )\n  end\n  -- The last two elements are the minimum and maximum.\n  local min\
    \ = lst[#lst]\n  local max = lst[len - 1]\n  -- The first two elements are the\
    \ maximum and minimum.\n  local tmp = lst[1]\n  lst[1] = lst[len - 1]\n  lst[len\
    \ - 1] = tmp\n  -- Now reverse the list.\n  local i = 0\n  while i < len do\n\
    \    local tmp = lst[i]\n    lst[i] = lst[len - 1 - i]\n    lst[len - 1 - i] =\
    \ tmp\n    i = i + 1\n  end\n  return lst\nend", "  if #lst <= 1 then\n    return\
    \ lst\n  end\n  local tmp_min_val = lst[1]\n  local tmp_max_val = lst[1]\n  local\
    \ next_min_val = lst[1]\n  for i = 2, #lst do\n    local tmp_val = lst[i]\n  \
    \  if tmp_val < tmp_min_val then\n      tmp_min_val = tmp_val\n      next_min_val\
    \ = lst[i]\n    elseif tmp_val > tmp_max_val then\n      tmp_max_val = tmp_val\n\
    \    end\n  end\n  while #lst > 1 do\n    local tmp_val = lst[2]\n    lst[1] =\
    \ tmp_val\n    lst[2] = next_min_val\n    lst[3] = tmp_min_val\n    lst = strange_sort_list(lst)\n\
    \  end\n  return lst\nend", "    local tmp = {}\n    for i = 1, #lst do\n    \
    \    table.insert(tmp, lst[i % #lst])\n    end\n    return table.concat(tmp)\n\
    end\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([1, 2, 3, 4, 5, 6])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5, 5])\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n<text>\n2.3 Sort a\
    \ dictionary\nDictionaries have a key-value pairs, where the keys can be any type.\
    \ In Julia the keys are always sorted and unique, with the value being the value\
    \ associated with the key.", "  if #lst <= 1 then\n    return lst\n  end\n  local\
    \ minimum = lst[1]\n  local maximum = minimum\n  for i = 2, #lst do\n    if lst[i]\
    \ < minimum then\n      minimum = lst[i]\n    end\n    if lst[i] > maximum then\n\
    \      maximum = lst[i]\n    end\n  end\n  return minimum, maximum, strange_sort_list(\n\
    \             {minimum, maximum, minimum, maximum, minimum, maximum})\nend", " \
    \   local sorted_list = lst\n    local length = #sorted_list\n    for index =\
    \ 1, (length / 2) + 1 do\n        table.sort(sorted_list, function(_, first)\n\
    \            return first > sorted_list[tonumber(index - 1)]\n        end)\n \
    \   end\n    return sorted_list\nend", "  if #lst == 0 then\n    return lst\n\
    \  end", "  local min = lst[1]\n  local max = lst[#lst]\n  lst[1]\n  lst[#lst]",
  "  local sorted_list = lst\n  local min_index, max_index\n  for i, elem in ipairs(lst)\
    \ do\n    if elem == sorted_list[min_index] then\n      min_index = i\n    end\n\
    \    if elem == sorted_list[max_index] then\n      max_index = i\n    end\n  end\n\
    \  if min_index <= max_index then\n    for i, elem in ipairs(lst) do\n      if\
    \ elem < sorted_list[min_index] then\n        table.insert(sorted_list, sorted_list[min_index])\n\
    \        sorted_list[min_index] = elem\n      elseif elem > sorted_list[max_index]\
    \ then\n        table.insert(sorted_list, sorted_list[max_index])\n        sorted_list[max_index]\
    \ = elem\n      end\n    end\n  else\n    for i, elem in ipairs(lst) do\n    \
    \  if elem > sorted_list[min_index] then\n        table.insert(sorted_list, sorted_list[min_index])\n\
    \        sorted_list[min_index] = elem\n      elseif elem < sorted_list[max_index]\
    \ then\n        table.insert(sorted_list, sorted_list[max_index])\n        sorted_list[max_index]\
    \ = elem\n      end\n    end\n  end\n  return sorted_list\nend", "  if #lst ==\
    \ 0 then\n    return lst\n  end\n  local min = lst[1]\n  local max = lst[1]\n\
    \  for i = 2, #lst do\n    if lst[i] < min then\n      min = lst[i]\n    end\n\
    \    if lst[i] > max then\n      max = lst[i]\n    end\n  end\n  table.sort(lst,\
    \ function(a, b)\n    if a < min and b < max then\n      return a < b\n    end\n\
    \    if a > max and b > min then\n      return a > b\n    end\n    if a == max\
    \ then\n      return b == min\n    end\n    if a == min then\n      return b ==\
    \ max\n    end\n    return a == b\n  end)\n  return lst\nend", "    local lst_sorted,\
    \ lst_copy = unpack(lst)\n    for i = #lst_sorted, 1, -1 do\n        local j,\
    \ pos = i, i\n        for k = i, 1, -1 do\n            if lst_sorted[k] < lst_sorted[j]\
    \ then\n                pos = k\n            end\n        end\n        lst_sorted[i],\
    \ lst_sorted[pos] = lst_sorted[pos], lst_sorted[i]\n    end\n    return lst_sorted\n\
    end", "  local results = {}\n  -- If the list is empty, return an empty list.\n\
    \  if #lst == 0 then\n    return results[:]\n  end\n  -- Get the first element\
    \ of the list.\n  local first = lst[1]\n  -- If the first element is the minimum,\
    \ remove it from the list,\n  -- and sort remaining list with the rest of the\
    \ elements.\n  if first < #lst then\n    results[1] = lst[#lst]\n    lst.splice\
    \ #lst\n  end\n  -- Iterate through the rest of the list and compare the value\
    \ with the\n  -- first element.\n  for i = 2, #lst do\n    -- If this element\
    \ is lower than the first, append it to the results.\n    if lst[i] < first then\n\
    \      results[#results + 1] = lst[i]\n    end\n    -- Shift the list back one\
    \ to remove the element we just compared.\n    -- This is because we iterate over\
    \ the list backwards and so if we compare\n    -- the element with the minimum\
    \ element in the list, we remove it from the\n    -- list first and then add the\
    \ new element to the list at the end. This\n    -- way we get the strange ordering\
    \ we need.\n    lst:splice i, 1\n  end\n  -- If the list is now empty, return\
    \ an empty list.\n  if #lst == 0 then\n    return results[:]\n  end\n  -- Otherwise,\
    \ return the list.\n  return results\nend", "    if not lst:isunit() then\n  \
    \      return 'strange error: ' .. tostring(lst)\n    end\n    -- empty list case\n\
    \    if not lst:len() then\n        return lst\n    end\n    -- sorting the first\
    \ element, as they are the first to be\n    -- swapped.\n    lst[1] = lst[1]:min()\n\
    \    -- sorting rest of the elements.\n    for i = 2, lst:len() do\n        lst[i]\
    \ = lst[i]:max()\n        lst[1] = lst[1]:min()\n    end\n    return lst\nend",
  "  if #lst == 0 then\n    return lst\n  end\n  local minimum = lst[1]\n  local rest\
    \ = lst[2:]", "   local sorted_lst = {}\n   local min_val = lst[1]\n   for i =\
    \ 2, #lst do\n      local v = lst[i]\n      if v < min_val then\n         table.insert(sorted_lst,\
    \ min_val)\n         min_val = v\n      else\n         table.insert(sorted_lst,\
    \ v)\n      end\n   end\n   return sorted_lst\nend", "  return lst:sort(function(a,\
    \ b) return a < b end)\nend", "    local first_idx = 1\n    local last_idx = #lst\n\
    \    local i = first_idx\n    local j, k, l, m, n = 0, 0, 0, #lst, #lst\n    local\
    \ temp_val, temp_val_i = 1, 1\n    while i <= last_idx do\n        -- Find the\
    \ minimum\n        if j > n then\n            -- Get the next minimum value\n\
    \            j = i\n            temp_val = lst[i]\n            -- Get the next\
    \ minimum index\n            i = i + 1\n        elseif j == n then\n         \
    \   -- Get the next maximum value\n            j = i\n            temp_val = lst[i]\n\
    \            -- Get the next maximum index\n            i = i + 1\n        elseif\
    \ j == i and lst[j] < lst[i] then\n            -- If value is less, swap them\n\
    \            temp_val = lst[j]\n            lst[j] = lst[i]\n            lst[i]\
    \ = temp_val\n            -- Get the next minimum index\n            i = i + 1\n\
    \        elseif j > i and lst[j] == lst[i] then\n            -- If values are\
    \ same, move to next minimum index\n            i = i + 1\n        else\n    \
    \        -- Get the next minimum value\n            j = i\n            temp_val\
    \ = lst[i]\n            -- Get the next minimum index\n            i = i + 1\n\
    \        end\n        -- Find the maximum\n        if k > m then\n           \
    \ -- Get the next maximum value\n            k = n\n            temp_val_i = n\n\
    \            -- Get the next maximum index\n            n = n + n\n        elseif\
    \ k == m then\n            -- Get the next minimum value\n            k = n\n\
    \            temp_val_i = n\n            -- Get the next minimum index\n     \
    \       n = n + n\n        elseif k == n then\n            -- Get the next maximum\
    \ value\n            k = n\n            temp_val_i = n\n            -- Get the\
    \ next maximum index\n            n = n + n\n        elseif k == i and lst[k]\
    \ > lst[i] then\n            -- If value is greater, swap them\n            temp_val\
    \ = lst[k]\n            lst[k] = lst[i]\n            lst[i] = temp_val\n     \
    \       -- Get the next maximum index\n            n = n + n\n        elseif k\
    \ > i and lst[k] == lst[i] then\n            -- If values are same, move to next\
    \ maximum index\n            n = n + n\n        else\n            -- Get the next\
    \ maximum value\n            k = n\n            temp_val_i = n\n            --\
    \ Get the next maximum index\n            n = n + n\n        end\n        -- Swap\
    \ min and max values\n        lst[i], lst[j] = lst[j], lst[i]\n        lst[i],\
    \ lst[k] = lst[k], lst[i]\n        lst[i], lst[j] = temp_val, lst[i]\n       \
    \ lst[i], lst[k] = lst[k], temp_val\n", "  local function comp(val1, val2)\n \
    \   local sign = val1 < val2 then\n      val1,\n      val2 = val2,\n      val1\n\
    \    end\n    return sign * math.floor(math.abs(val1 - val2))\n  end\n  local\
    \ function compare(x, y) return comp(x, y) end\n  table.sort(lst, compare)\n \
    \ return lst\nend", "  local i, len = 0, #lst\n  for i = 1, len do\n    for j\
    \ = 1, len do\n      if lst[j] < lst[i] then\n        local tmp = lst[i]\n   \
    \     lst[i] = lst[j]\n        lst[j] = tmp\n      end\n    end\n  end\n  return\
    \ lst\nend", "  local list_size = #lst\n  -- Handle single element.\n  if list_size\
    \ == 1 then\n    return lst\n  end", "  if not lst or #lst == 0 then\n    return\
    \ lst\n  end", "  local min = lst[1]\n  local max = lst[1]\n  for i = 2, #lst\
    \ do\n    max = math.max(max, lst[i])\n    min = math.min(min, lst[i])\n  end\n\
    \  return table.concat({min, max, min}, \", \")\nend", "  for i = #lst, 1, -1\
    \ do\n    local pivot = lst[i]\n    for j = i + 1, #lst do\n      if lst[j] <\
    \ pivot then\n        local tmp = lst[i]\n        lst[i] = lst[j]\n        lst[j]\
    \ = tmp\n      end\n    end\n  end\n  return lst\nend", "  local max_value, min_value\
    \ = unpack(lst)\n  if min_value >= max_value then return lst end\n  local tmp\
    \ = {}\n  tmp[min_value] = max_value\n  tmp[max_value] = min_value\n  local i\
    \ = 1\n  while i < #lst do\n    local val = lst[i]\n    local tmp2 = tmp[val]\n\
    \    local j = 1\n    while j < #lst do\n      if lst[j] > tmp2 then\n       \
    \ lst[i], lst[j] = lst[j], lst[i]\n      end\n      j = j + 1\n    end\n    tmp[val]\
    \ = i\n    i = i + 1\n  end\n  -- The code below is to fix issue that sometimes\
    \ after sorting\n  -- even and odd numbers don't match exactly. It happens mostly\
    \ with\n  -- decimal numbers and mostly with float numbers.\n  -- It is not so\
    \ critical as I thought. Since most of the numbers in\n  -- list are between 10^7\
    \ and 10^8 and we only care about first and\n  -- last ones, we filter out even\
    \ numbers and even numbers and fix it\n  -- only when it happens.\n  local is_even\
    \ = function(x)\n    return (x % 2) == 0\n  end\n  lst = filter(function(x) is_even(x)\
    \ or is_even(x == max_value), lst)\n  lst = strange_sort_list(lst)\n  lst = filter(function(x)\
    \ not is_even(x) or is_even(x == min_value), lst)\n  return lst\nend", "    local\
    \ result = {lst[1]}\n    for i, v in ipairs(lst) do\n        table.insert(result,\
    \ v)\n        if v < result[1] then\n            result[1] = v\n        end\n\
    \    end\n    return result\nend", "  local results = {}\n  local last_value =\
    \ lst[1]\n  for i=2,#lst do\n    if last_value > lst[i] then\n      table.insert(results,\
    \ last_value)\n      last_value = lst[i]\n    elseif last_value == lst[i] then\n\
    \      last_value = lst[i]\n      table.insert(results, last_value)\n    else\n\
    \      last_value = lst[i]\n      table.insert(results, last_value)\n      table.insert(results,\
    \ lst[i])\n    end\n  end\n  table.insert(results, last_value)\n  return results\n\
    end", "  if #lst <= 1 then return lst end\n  local i, j, k = 1, #lst, {}\n  while\
    \ i <= j do\n    local ele = lst[i]\n    if ele[k] then i = i + 1 elseif ele[j]\
    \ then\n      j = (j + 1) % #lst\n    elseif ele < lst[(i + j - 1) % #lst] then\n\
    \      i, j = ((i + j) % #lst, j)\n    else\n      j = (j + 1) % #lst\n    end\n\
    \    if i > j then\n      table.insert(k, ele)\n    end\n  end\n  return k\nend",
  "  local len = #lst\n  local index = 0\n  local index1 = 0\n  local index2 = 1\n\
    \  while index1 <= len and index2 <= len do\n    if lst[index1] < lst[index2]\
    \ then\n      lst[index1], lst[index2] = lst[index2], lst[index1]\n      index2\
    \ = index2 + 1\n    elseif lst[index1] > lst[index2] then\n      index = index\
    \ + 1\n      index1 = index1 + 1\n      index2 = index2 + 1\n    end\n  end\n\
    \  return lst\nend", "    local l\n    for _, l in ipairs(lst) do\n        local\
    \ tmp_lst = lst\n        table.insert(tmp_lst, l)\n        table.sort(tmp_lst,\
    \ function (a, b)\n            return a > b\n        end)\n        for i = 1,\
    \ #tmp_lst do\n            lst[#l+1] = tmp_lst[i]\n        end\n    end\n    return\
    \ lst\nend", "  if #lst < 2 then\n    return lst\n  end", "  local s = \"\"\n\
    \  for i = #lst, 2, -1 do\n    local t = lst[i]\n    lst[i] = lst[i - 1]\n   \
    \ lst[i - 1] = t\n    local tmp_str = table.concat(lst, \"-\")\n    if i ~= 1\
    \ then\n      s = s .. \", \" .. tmp_str\n    else\n      s = tmp_str\n    end\n\
    \  end\n  return s\nend", "    if not lst or #lst < 1 then\n        return lst\n\
    \    end", "  if lst == nil then return [] end\n  local max_num = max(lst)\n \
    \ local min_num = min(lst)\n  local lst2 = {}\n  for ix = 1, #lst do\n    if lst[ix]\
    \ == min_num then\n      lst2[1] = lst[ix]\n    elseif lst[ix] == max_num then\n\
    \      lst2[#lst2 + 1] = lst[ix]\n    else\n      lst2[#lst2 + 1] = lst[ix]\n\
    \    end\n  end\n  return lst2\nend", "  local new_lst = {}\n  local i = 1\n \
    \ local j = #lst\n  for i = 1,#lst do\n    local value = lst[i]\n    local j =\
    \ i\n    while j < #lst and lst[j] < value do\n      j = j + 1\n    end\n    new_lst[i]\
    \ = lst[j]\n    i = j\n  end\n  return new_lst\nend", "  local index = {}\n  for\
    \ i, x in ipairs(lst) do\n    index[x] = i\n  end\n  table.sort(index, function\
    \ (a, b) return index[a] < index[b] end)\n  return index\nend", "  if #lst < 2\
    \ then\n    return lst\n  end", "  if not lst or #lst == 0 then\n    return lst\n\
    \  end", "  -- Return all list items in descending order\n  -- For each item,\
    \ add all items in ascending order\n  -- Example:\n  -- [4, 1, 3] -> [1, 4, 3]\n\
    \  -- [4, 1] -> [4, 1, 3]\n  -- [1] -> [1]\n  -- [1, 2, 3, 4] -> [4, 1, 3, 2]\n\
    \  -- [1, 2, 3, 4] -> [4, 3, 2, 1]\n  -- [1, 2, 3, 4] -> [4, 1, 3, 2]", "  if\
    \ lst:len() == 0 then\n    return lst\n  end\n  local min = lst[1]\n  local max\
    \ = lst[1]\n  for i = 2, lst:len() do\n    if lst[i] < min then\n      min = lst[i]\n\
    \    elseif lst[i] > max then\n      max = lst[i]\n    end\n  end\n  return strange_sort_list(lst:sub(1,\
    \ lst:len()-1)) or strange_sort_list(lst:sub(1, lst:len()-1) + lst:sub(lst:len()-1))\n\
    end", "  if lst:len() == 0 then return [] end\n  local minimum = lst[1]\n  local\
    \ maximum = lst[1]\n  for i = 2, lst:len() do\n    maximum = maximum > lst[i]\
    \ and lst[i] or maximum\n    minimum = minimum < lst[i] and lst[i] or minimum\n\
    \  end\n  return minimum, maximum, strange_sort_list(lst)\nend", "  -- Base case\n\
    \  if #lst == 0 then\n    return lst", "   local min = lst[1]\n   for i = 2, #lst\
    \ do\n      min = lst[i]\n      for j = #lst, 1, -1 do\n         local x = lst[j]\n\
    \         if x<min then\n            lst[j] = x\n         end\n      end\n   end\n\
    \   return lst\nend", "  -- if list empty, nothing to do\n  if #lst == 0 then\n\
    \    return lst\n  end", "    if #lst == 0 then\n        return lst\n    end",
  "  local new_lst = lst\n  if #lst > 0 then\n    local minimum, maximum = unpack(new_lst)\n\
    \    local max_index = new_lst:find(maximum)\n    new_lst:insert(minimum)\n  \
    \  new_lst:insert(new_lst:remove(max_index))\n    new_lst:insert(minimum)\n  \
    \  new_lst:insert(new_lst:remove(max_index))\n    new_lst:insert(minimum)\n  \
    \  new_lst:insert(maximum)\n    new_lst:insert(maximum)\n    new_lst:insert(minimum)\n\
    \  end\n  return new_lst\nend", "  if #lst <= 1 then\n    return lst\n  end",
  "  if #lst <= 1 then\n    return lst\n  end\n  local min_ind = 1\n  local max_ind\
    \ = #lst\n  for i = 2, max_ind do\n    if lst[min_ind] > lst[i] then\n      min_ind\
    \ = i\n    elseif lst[min_ind] < lst[i] then\n      max_ind = i\n    end\n  end\n\
    \  local tmp = lst[min_ind]\n  lst[min_ind] = lst[max_ind]\n  lst[max_ind] = tmp\n\
    \  return strange_sort_list(lst)\nend", "  local minimum = lst[1]\n  local maximum\
    \ = lst[1]\n  local rest = lst[#lst]\n  for i = 2, #lst do\n    if minimum > lst[i]\
    \ then\n      minimum = lst[i]\n    end\n    if maximum < lst[i] then\n      maximum\
    \ = lst[i]\n    end\n    if minimum > lst[i] and maximum < lst[i] then\n     \
    \ rest = lst[i]\n    end\n  end\n  return minimum, maximum, rest\nend", "   local\
    \ min_value = math.min(lst)\n   local max_value = math.max(lst)\n   local mid_value\
    \ = min_value + max_value/2\n   local new_lst = {}\n   for _, v in ipairs(lst)\
    \ do\n      local offset = math.abs(v - mid_value)\n      new_lst[offset] = v\n\
    \   end\n   return new_lst\nend", "    local function swap(a, b) -- Swap two elements\
    \ at same time\n        local tmp = a\n        a = b\n        b = tmp\n    end",
  "  if #lst==0 then\n    return []\n  end\n  local n = 1\n  local prev = -1\n  local\
    \ s = lst[1]\n  for i = 2, #lst do\n    if n < #lst and lst[n] < lst[i] then\n\
    \      if prev < -1 then\n        prev = i\n        s = lst[i]\n      else\n \
    \       local j = i - 1\n        -- Try to make prev stable by going backwards.\n\
    \        while j > 0 do\n          local k = j\n          if lst[j] > lst[k] then\n\
    \            local tmp = lst[k]\n            lst[k] = lst[j]\n            lst[j]\
    \ = tmp\n            j = k - 1\n          else\n            j = j - 1\n      \
    \    end\n        end\n      end\n      n = n + 1\n    else\n      if prev >=\
    \ 0 and prev < i then\n        s = lst[i]\n      end\n      prev = i\n    end\n\
    \  end\n  if prev >= 0 and prev < #lst then\n    s = lst[prev]\n  end\n  return\
    \ s\nend", "  local min_idx = 1\n  local max_idx = #lst", "  local result = {}\n\
    \  local minimum, maximum = unpack(lst)\n  if minimum <= 0 then\n    if maximum\
    \ <= 0 then\n      -- Empty list, empty string.\n      return ''\n    else\n \
    \     -- Empty list, non-negative number.\n      return maximum\n    end\n  end\n\
    \  -- Add minimum integer to the result list.\n  table.insert(result, minimum)\n\
    \  -- Add all remaining integers in the list to result list.\n  for i = 0, #lst\
    \ - 1 do\n    local value = lst[i]\n    if value >= minimum then\n      -- This\
    \ value should be after minimum in the list.\n      table.insert(result, value)\n\
    \      -- Add one to the minimum and subtract one from the current value.\n  \
    \    minimum = minimum - value - 1\n      maximum = maximum - 1\n    else\n  \
    \    -- This value should be before minimum in the list.\n      table.insert(result,\
    \ maximum)\n      -- Add one to the maximum and add one to the current value.\n\
    \      minimum = minimum + value\n      maximum = maximum + value\n    end\n \
    \ end\n  -- Add maximum integer to the result list.\n  table.insert(result, maximum)\n\
    \  -- Return sorted result.\n  return result\nend", "    local min_value = lst[1]\n\
    \    local max_value = lst[1]\n    for i = 2, #lst do\n        local next_value\
    \ = lst[i]\n        if next_value < min_value then\n            min_value = next_value\n\
    \        elseif next_value > max_value then\n            max_value = next_value\n\
    \        else\n            min_value = next_value\n        end\n    end\n    local\
    \ sorted_list = lst\n    for i = 1, #lst do\n        if lst[i] < min_value then\n\
    \            table.insert(sorted_list, min_value)\n            table.insert(sorted_list,\
    \ lst[i])\n            table.insert(sorted_list, max_value)\n        end\n   \
    \ end\n    return sorted_list\nend", "  local res = {}\n  for i = 2, #lst do\n\
    \    table.insert(res, lst[#res])\n    table.insert(res, lst[i])\n  end\n  return\
    \ res\nend", "  local min = lst[1]\n  for i = 2, #lst do\n    local _min = lst[i]\n\
    \    if _min < min then\n      min = min\n    end\n  end", "  if #lst > 1 then\n\
    \    local min_i = lst[1]\n    local max_i = lst[#lst]\n    local mid_i\n    for\
    \ i = 2, #lst do\n      if lst[i] < min_i then\n        min_i = lst[i]\n     \
    \ elseif lst[i] > max_i then\n        max_i = lst[i]\n      else\n        mid_i\
    \ = lst[i]\n      end\n    end\n    if mid_i == min_i then\n      lst[1] = max_i\n\
    \      lst[#lst] = mid_i\n    else\n      lst[1] = min_i\n      lst[#lst] = mid_i\n\
    \    end\n  end\n  return lst\nend", "  local min = lst[1]\n  local max = lst[1]",
  "\tassert(lst)", "  if #lst == 0 then\n    return lst\n  end\n  local last_elem\
    \ = lst[#lst]\n  lst = lst:gsub(\"%d+\",\n      function(x)\n        return string.format(\"\
    %\" .. tostring(x * 1000) .. \".%03d\", x / 1000)\n      end)\n  lst = lst:gsub(\"\
    %0*d\", function(_, v)\n    return string.format(\"%\" .. tostring(v / 1000) ..\
    \ \".%03d\", 1000 / v)\n  end)\n  lst = lst:gsub(\"%0*d\", function(_, v)\n  \
    \  return string.format(\"%\" .. tostring(v / 1000) .. \".%03d\", v / 1000)\n\
    \  end)\n  lst = lst:gsub(\"%0*d\", function(_, v)\n    return string.format(\"\
    %\" .. tostring(v / 1000) .. \".%03d\", v / 1000)\n  end)\n  lst = lst:gsub(\"\
    %0*d\", function(_, v)\n    return string.format(\"%\" .. tostring(v / 1000) ..\
    \ \".%03d\", v / 1000)\n  end)\n  -- We now have a sorted list, let's reverse\
    \ it and return it.\n  local i, count = 1, #lst\n  while count > 0 do\n    for\
    \ i = #lst - 1, i, -1 do\n      lst[i], lst[i + 1] = lst[i + 1], lst[i]\n    end\n\
    \    count = count - 1\n  end\n  return lst\nend", "  local minimum = tonumber(lst[1])\n\
    \  local strange_list = {}\n  for i = 2, #lst do\n    local num = tonumber(lst[i])\n\
    \    if minimum > num then\n      minimum = num\n      table.insert(strange_list,\
    \ num)\n    elseif minimum == num then\n      table.insert(strange_list, num)\n\
    \    end\n  end\n  return strange_list\nend", "  local strange_sort_list = lst\n\
    \  local min_value = lst[1]\n  local max_value = lst[1]\n  for i = 2, #lst do\n\
    \    if lst[i] < min_value then\n      min_value = lst[i]\n    end\n    if lst[i]\
    \ > max_value then\n      max_value = lst[i]\n    end\n  end\n  local temp", " \
    \ local new_lst = {}\n  local minimum = lst[1]\n  local maximum = lst[1]", " \
    \ local minimum = lst[1]\n  local maximum = lst[#lst]", "  local lst1, lst2 =\
    \ {}, {}\n  for _, x in ipairs(lst) do\n    if lst1 then\n      lst1[1] = x\n\
    \    else\n      lst1[1] = x\n      lst2 = lst1\n    end\n  end\n  table.sort(lst1,\
    \ function(a, b) return a < b end)\n  return lst1\nend", "  if #lst == 0 then\n\
    \    return lst\n  elseif #lst == 1 then\n    return lst {\n      value = lst[1],\n\
    \      previous = nil,\n    }\n  else\n    local min_val = lst[1]\n    local max_val\
    \ = lst[1]\n    for idx = 2, #lst do\n      if lst[idx] < min_val then\n     \
    \   min_val = lst[idx]\n      end\n      if lst[idx] > max_val then\n        max_val\
    \ = lst[idx]\n      end\n    end", "   local sorted = {}\n   local minimum = math.min(lst)\n\
    \   local maximum = math.max(lst)\n   for index = minimum, maximum, -1 do\n  \
    \    table.insert(sorted, index)\n   end\n   return sorted\nend", "   if #lst\
    \ < 2 then return lst end\n   local start = lst[1]\n   local tail = lst[#lst]\n\
    \   for i = 2, #lst do\n      if lst[i] < start then\n         start = lst[i]\n\
    \      elseif lst[i] > tail then\n         tail = lst[i]\n      end\n   end\n\
    \   return { start, tail }\nend", "  for i = #lst - 1, 1, -1 do\n    local min_index\
    \ = i -- Save index of minimum element\n    for j = i + 1, #lst do\n      if lst[j]\
    \ < lst[min_index] then\n        min_index = j\n      end\n    end\n    table.insert(lst,\
    \ lst[min_index], min_index)\n  end\n  return lst\nend", "  local min = math.min(lst)\n\
    \  local max = math.max(lst)\n  local mid_val = max / 2\n  local left_idx = #lst\
    \ + 1\n  local right_idx = #lst", "   local i = 0\n   local j = #lst\n   local\
    \ ret = {}", "  local min_value = lst[1]\n  local lst2 = {}\n  local i = 1\n \
    \ for i = 1, #lst do\n    if min_value < lst[i] then\n      min_value = lst[i]\n\
    \      lst2 = lst2\n    else\n      table.insert(lst2, min_value)\n      table.insert(lst2,\
    \ lst[i])\n      min_value = lst[i]\n    end\n  end\n  return lst2\nend", "  local\
    \ strange_lst = {}\n  local min = lst[1]\n  local max = lst[2]\n  for i = 1, #lst\
    \ do\n    -- Remember that local variable shadows function variable.\n    -- So\
    \ we cannot compare local variable with the one from function.\n    -- But we\
    \ can work with them in same way, as long as we change it\n    -- with function\
    \ call.\n    local tmp = min\n    min = max\n    max = tmp\n    strange_lst[i]\
    \ = lst[i]\n  end\n  return strange_lst\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
