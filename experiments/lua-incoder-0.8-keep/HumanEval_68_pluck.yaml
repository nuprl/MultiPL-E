name: HumanEval_68_pluck
language: lua
prompt: "-- \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The\
  \ plucked node should be the node with the smallest even value.\n-- If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n-- The plucked node should be returned in a list, [ smalest_value, its\
  \ index ],\n-- If there are no even values or the given array is empty, return [].\n\
  -- Example 1:\n-- Input: [4,2,3]\n-- Output: [2, 1]\n-- Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n-- Example 2:\n-- Input: [1,2,3]\n\
  -- Output: [2, 1]\n-- Explanation: 2 has the smallest even value, and 2 has the\
  \ smallest index. \n-- Example 3:\n-- Input: []\n-- Output: []\n-- Example 4:\n\
  -- Input: [5, 0, 3, 0, 4, 2]\n-- Output: [0, 1]\n-- Explanation: 0 is the smallest\
  \ value, but  there are two zeros,\n-- so we will choose the first zero, which has\
  \ the smallest index.\n-- Constraints:\n-- * 1 <= nodes.length <= 10000\n-- * 0\
  \ <= node.value\nlocal function pluck(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pluck\n\
  \    lu.assertEquals(candidate({4, 2, 3}), {2, 1})\n    lu.assertEquals(candidate({1,\
  \ 2, 3}), {2, 1})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({5,\
  \ 0, 3, 0, 4, 2}), {0, 1})\n    lu.assertEquals(candidate({1, 2, 3, 0, 5, 3}), {0,\
  \ 3})\n    lu.assertEquals(candidate({5, 4, 8, 4, 8}), {4, 1})\n    lu.assertEquals(candidate({7,\
  \ 6, 7, 1}), {6, 1})\n    lu.assertEquals(candidate({7, 9, 7, 1}), {})\nend\n\n\
  os.exit(lu.LuaUnit.run())"
completions: ["    local even = #arr % 2 == 0\n    local min = #arr > 0 and math.min(arr)\
    \ or 0\n    local index = #arr > 0 and #arr or 0\n    local new_arr\n    local\
    \ index\n    if even then\n        index = index .. 1\n    end\n    local smalest_value\
    \ = min\n    local value_index\n    for i = 1, #arr do\n        if arr[i] < smalest_value\
    \ then\n            if even then\n                value_index = i\n          \
    \  else\n                value_index = index\n            end\n            smalest_value\
    \ = arr[i]\n            index = value_index\n        end\n    end\n    return\
    \ smalest_value, index\nend", "    local arr_size\n    local arr_index\n    local\
    \ min_index\n    local min_value\n    local sm_value\n    local sm_idx\n    local\
    \ sm_index\n    local sm_index2\n    local sm_idx2\n    local sm_idx3\n    local\
    \ sm_idx4\n    local sm_idx5\n    arr_size = #arr\n    arr_index = 1\n    min_index\
    \ = nil\n    min_value = nil\n    sm_value = nil\n    sm_idx = 0\n    sm_index\
    \ = 0\n    sm_index2 = 0\n    sm_idx2 = 0\n    sm_idx3 = 0\n    sm_idx4 = 0\n\
    \    sm_idx5 = 0", "    if #arr == 0 then\n        return arr\n    elseif #arr\
    \ == 1 then\n        return arr[1]\n    end\n    \n    local min_idx, min_val\
    \ = arr[1], arr[1]\n    \n    for idx = 2, #arr do\n        if arr[idx] < min_val\
    \ then\n            min_val = arr[idx]\n            min_idx = idx\n        end\n\
    \    end\n    \n    if min_val % 2 == 0 then\n        return min_idx, min_val\n\
    \    else\n        local min_val = min_val/2\n        local min_idx\n        for\
    \ idx = 2, #arr do\n            if arr[idx] < min_val then\n                min_val\
    \ = arr[idx]\n                min_idx = idx\n            end\n        end\n  \
    \      \n        if min_val % 2 == 0 then\n            return min_idx, min_val\n\
    \        else\n            local min_val = min_val/2\n            local min_idx\n\
    \            for idx = 2, #arr do\n                if arr[idx] < min_val then\n\
    \                    min_val = arr[idx]\n                    min_idx = idx\n \
    \               end\n            end\n            \n            return min_idx,\
    \ min_val\n        end\n    end\nend", "    local nodes = {}\n    local index\
    \ = 1\n    local min_index = 1", "    if #arr == 0 then\n        return []\n \
    \   end", "    local res = {}\n    local min = math.min(unpack(arr))\n    for\
    \ i = 1, #arr do\n        if arr[i] <= min then\n            -- pick the node\
    \ with smallest index\n            if res[1] == nil then\n                res[1]\
    \ = i\n            elseif res[1] == i then\n                res[2] = i\n     \
    \       end\n        end\n    end\n    return res\nend", "  -- Write your code\
    \ here.\n  \n  -- For each index\n  local i = #arr\n  while i ~= 0 do\n    local\
    \ minimum = 0\n    -- For each value\n    local j = i\n    while j ~= 0 do\n \
    \     if arr[j] % 2 == 0 then\n        minimum = minimum + 1\n      end\n    \
    \  j = j - 1\n    end\n    -- If there is more than one minimum even value\n \
    \   if minimum > 1 then\n      -- Pick the smaller one\n      if minimum > arr[i]\
    \ then\n        return arr[i], minimum\n      else\n        return arr[i], minimum\
    \ - 1\n      end\n    end\n    -- If there is no minimum even value\n    j = i\
    \ - 1\n    if j < 0 then\n      j = 0\n    end\n    i = j + 1\n  end\n  return\
    \ nil, nil\nend", "    local arr = arr:clone()\n    local result = {}\n    local\
    \ pos = 0\n    local index = 0\n    \n    while pos < #arr and arr:get(pos):isEven\
    \ ~= 0 do\n        local val = arr:get(pos):getVal()\n        if val ~= arr:get(pos):getIndex()\
    \ then\n            result[index] = val\n            index = index + 1\n     \
    \   end\n        pos = pos + 1\n    end\n    if pos < #arr and arr:get(pos):isEven\
    \ ~= 0 then\n        result[index] = arr:get(pos):getIndex()\n        index =\
    \ index + 1\n    end\n    return result\nend", "   local stack = stack{}\n   local\
    \ index = 0\n   for i, v in ipairs(arr) do\n      if v % 2 == 0 then\n       \
    \  table.insert(stack, v)\n         index = i\n      end\n   end\n   if #stack\
    \ == 1 then\n      return stack[1]\n   else\n      return nil\n   end\nend", " \
    \ local smalest_value = -inf\n  local smalest_index = -1\n  local pluck_val =\
    \ {}\n  for i = 1, #arr do\n    if arr[i] % 2 == 0 then\n      if smalest_value\
    \ < arr[i] then\n        smalest_value = arr[i]\n        smalest_index = i\n \
    \     end\n    end\n  end\n  if smalest_value > 0 then\n    pluck_val[1] = smalest_value\n\
    \    pluck_val[2] = smalest_index\n  end\n  if #pluck_val == 2 then\n    pluck_val[1]\
    \ = nil\n    pluck_val[2] = nil\n  end\n  return pluck_val\nend", "    local smallest_val\
    \ = nil\n    local smallest_idx = 0\n    for i = 0, #arr-1 do\n        if arr[i]\
    \ % 2 == 0 then\n            smallest_val = arr[i]\n            smallest_idx =\
    \ i\n        end\n    end\n    return smallest_val, smallest_idx\nend", "    local\
    \ results = {}\n    for i = 1, #arr do\n        if arr[i] % 2 == 0 then\n    \
    \        table.insert(results, {arr[i], i})\n        end\n    end\n    table.sort(results)\n\
    \    if #results > 0 then\n        return results[1].index\n    end\n    return\
    \ 0\nend", "    local index_of_smallest_value = nil\n    local smallest_even_value\
    \ = nil\n    local smallest_index = nil\n    local smallest_even_index = 0", " \
    \  local result = {}\n   local index = 1", "    local min_value = math.min(arr)\n\
    \    local i = 1\n    local index = 1\n    while i <= #arr do\n        if arr[i]\
    \ == min_value and i % 2 == 0 then\n            return arr[i], index\n       \
    \ end\n        index = index + 1\n        i = i + 1\n    end\n    return nil\n\
    end", '    local smalest_value, smalest_index, smallest_index_of_smallest_even_value
    = math.inf', "   if #arr == 0 then\n      return nil\n   end", "    local even_index_map\
    \ = {}\n    local smallest_index_map = {}\n    local pick_even_index_map = {}\n\
    \    local pick_smallest_index_map = {}", "  -- Base case\n  if #arr == 0 then\n\
    \    return []\n  end", "  -- Base case: If the given array is empty, return an\
    \ empty list.\n  if #arr == 0 then\n    return []\n  end\n  -- Base case: If the\
    \ array has only one element, return it.\n  if #arr == 1 then\n    return arr[1]\n\
    \  end\n  -- Base case: If the array has only two elements, return both.\n  if\
    \ #arr == 2 then\n    return arr[1], arr[2]\n  end\n  -- Base case: If the array\
    \ has three or more elements, find smallest even index and return\n  -- the value\
    \ at that index.\n  local smallest_even_index = 1\n  local smallest_even_value\
    \ = 0\n  local smallest_index = 1\n  for i = 1, #arr do\n    if arr[i] % 2 ==\
    \ 0 then\n      if smallest_even_index < i then\n        smallest_even_index =\
    \ i\n        smallest_even_value = arr[i]\n      else\n        smallest_even_value\
    \ = arr[i]\n      end\n    else\n      smallest_index = smallest_index + 1\n \
    \   end\n  end\n  return smallest_even_value, smallest_index\nend", "    local\
    \ min_value = arr[1]\n    local min_index = 1\n    local index_of_min_index =\
    \ 1\n    local min_idx = nil\n    for i = 2, #arr do\n        if arr[i] < min_value\
    \ then\n            min_value = arr[i]\n            min_index = i\n          \
    \  index_of_min_index = i - 1\n            if arr[i] % 2 == 0 then\n         \
    \       min_idx = i\n            end\n        end\n    end\n    if min_value ==\
    \ arr[1] then\n        return min_idx, index_of_min_index\n    end\n    if min_value\
    \ == arr[#arr] then\n        return min_idx, #arr\n    else\n        return min_idx,\
    \ index_of_min_index\n    end\nend", "  local even = {}\n  local smallest = {}\n\
    \  local smallest_index = {}\n  local i, n = 1, #arr\n  for i = 1, n do\n    local\
    \ value = arr[i]\n    if math.modf(value) == 0 then\n      if smallest[value]\
    \ == nil then\n        even[value] = i\n      else\n        smallest_index[value]\
    \ = i\n      end\n    elseif smallest[value] == nil then\n      smallest[value]\
    \ = i\n      smallest_index[value] = 1\n    end\n  end\n  for i = 1, n do\n  \
    \  if smallest[arr[i]] == nil then\n      smallest[arr[i]] = i\n      smallest_index[arr[i]]\
    \ = 1\n    end\n  end\n  if #even > 0 then\n    table.insert(smallest_index, #even)\n\
    \    table.sort(smallest_index)\n    table.insert(smallest, #even)\n    table.sort(even)\n\
    \    table.insert(smallest_index, even[#even])\n  end\n  return smallest_index\n\
    end", "   if #arr == 0 then\n      return nil\n   end", "  if #arr == 0 then\n\
    \    return nil\n  end\n  local min = math.min(arr)\n  local i = 1\n  local min_i\
    \ = 1\n  for i=1,#arr do\n    if arr[i] <= min then\n      min = arr[i]\n    \
    \  min_i = i\n    end\n  end\n  return arr[min_i]\nend", "  if arr == nil or #arr\
    \ == 0 then\n    return nil\n  end\n  local index = 1\n  local value = 1\n  local\
    \ index_of_min = math.inf\n  local smalest_value = 1\n  for i=1,#arr do\n    if\
    \ arr[i]%2 == 0 then\n      local current_value = arr[i]\n      if current_value\
    \ < smalest_value then\n        smalest_value = current_value\n        index_of_min\
    \ = index\n      end\n    end\n    index = index + 1\n  end\n  if index_of_min\
    \ == math.inf then\n    return nil\n  end\n  if index_of_min == 1 then\n    return\
    \ [ smalest_value, index_of_min ]\n  end\n  local indexes = {}\n  local smallest_value\
    \ = 1\n  local smallest_index = 1\n  for i = 1,#arr do\n    if arr[i]%2 == 0 then\n\
    \      if smalest_value < arr[i] then\n        smallest_value = smalest_value\n\
    \        smallest_index = index_of_min\n      elseif smalest_value == arr[i] then\n\
    \        smallest_value = arr[i]\n        smallest_index = index_of_min\n    \
    \  end\n      index_of_min = index_of_min + 1\n      indexes[#indexes+1] = smallest_index\n\
    \    end\n  end\n  if smallest_index == 1 then\n    return [ smallest_value, indexes[1]\
    \ ]\n  end\n  return indexes\nend", "  local index = 0\n  local smallest_value\
    \ = nil\n  local smallest_index = nil\n  local current_value = nil\n  for i =\
    \ 0, #arr do\n    local current_value = arr[i]\n    local current_index = i\n\
    \    if current_value <= 0 then break end\n    local smallest_value = current_value\n\
    \    local smallest_index = i\n    if smallest_value == 0 then break end\n   \
    \ while smallest_value % 2 == 0 do\n      smallest_value = smallest_value / 2\n\
    \      smallest_index = current_index\n    end\n    if smallest_value < current_value\
    \ then\n      smallest_value = current_value\n      smallest_index = current_index\n\
    \    end\n  end\n  local result = {}\n  if smallest_index == 0 then return result\
    \ end\n  result[1] = smallest_value\n  result[2] = smallest_index\n  return result\n\
    end", "    local evens = {}\n    for i = 1, #arr do\n        local node = arr[i]\n\
    \        if node.value == 0 then -- If it's a leaf\n            table.insert(evens,\
    \ node)\n        else\n            local is_even = node.value % 2 == 0 -- If it's\
    \ an even node\n            local index = is_even and node.value - 1 or #arr +\
    \ 1 -- Index of node\n            table.insert(evens, node)\n        end\n   \
    \ end\n    return evens\nend", "  -- Your code here\n  if #arr == 0 then\n   \
    \ return nil\n  else\n    local index = 1, #arr\n    while index < #arr do\n \
    \     if arr[index] % 2 == 0 then\n        arr[index] = arr[index - 1]\n     \
    \   index = index - 1\n      else\n        index = index + 1\n      end\n    end\n\
    \  end\n  if #arr > 1 then\n    local index = 1, #arr\n    while index < #arr\
    \ do\n      if arr[index] % 2 == 0 and arr[index - 1] == 0 then\n        arr[index]\
    \ = arr[index - 1]\n        index = index - 1\n      else\n        index = index\
    \ + 1\n      end\n    end\n  end\n  return arr\nend", "\tlocal evens = {}\n\t\
    for i = 1,#arr do\n\t\tif arr[i] % 2 == 0 then\n\t\t\ttable.insert(evens, arr[i])\n\
    \t\tend\n\tend\n\tlocal min = table.min(evens)\n\tlocal idx = #evens\n\tfor i\
    \ = 1,#arr do\n\t\tif arr[i] == min then\n\t\t\tidx = i\n\t\tend\n\tend\n\treturn\
    \ min, idx\nend", "  local result = {}\n  for i = 1, #arr do\n    if arr[i] ~=\
    \ 0 then\n      local idx = i\n      local minval = arr[i]\n      while idx >\
    \ 1 do\n        if arr[idx - 2] ~= 0 and arr[idx - 2] < minval then\n        \
    \  minval = arr[idx - 2]\n        end\n        idx = idx - 1\n      end\n    \
    \  if idx == 1 then\n        result.insert(minval, i)\n      else\n        local\
    \ idx = idx\n        while idx > 1 do\n          if arr[idx - 2] ~= 0 then\n \
    \           if arr[idx - 2] < minval then\n              minval = arr[idx - 2]\n\
    \            end\n          end\n          idx = idx - 1\n        end\n      \
    \  table.insert(result, minval, idx)\n      end\n    end\n  end\n  if #result\
    \ == 0 then\n    return nil\n  else\n    return result\n  end\nend", "  if #arr\
    \ == 0 then\n    return nil\n  else\n    local minNodeValue\n    local minNodeIndex\n\
    \    for i = 1, #arr do\n      if arr[i] then\n        if not minNodeValue or\
    \ arr[i] < minNodeValue then\n          minNodeValue = arr[i]\n          minNodeIndex\
    \ = i\n        end\n      end\n    end", "  local largest = 0\n  local smallest\
    \ = 0\n  local plucked = nil\n  for i = 1, #arr do\n    if arr[i] < arr[largest]\
    \ then\n      largest = i\n    end\n    if arr[i] > arr[smallest] then\n     \
    \ smallest = i\n    end\n  end\n  if smallest > 0 then\n    plucked = smallest\n\
    \  end\n  return plucked\nend", "  if #arr == 0 then return end\n  local smalest_value\
    \ = arr[1]\n  local index_of_smallest_value = 2\n  local smallest_index = 1\n\
    \  for i = 2, #arr do\n    if arr[i] > smalest_value then\n      smalest_value\
    \ = arr[i]\n      index_of_smallest_value = i\n    end\n    if arr[i] < smalest_value\
    \ then\n      smallest_index = i\n    end\n  end\n  return [ smalest_value, index_of_smallest_value\
    \ ], smallest_index\nend", "  local arr = {} -- arr will be modified in the process\n\
    \  local index = 0 -- index of the smallest even value\n  local smalest_value\
    \ = 0 -- value of the smallest even value\n  local smalest_index = 0 -- index\
    \ of the smallest even value\n  local smalest_index = -1 -- index of the smallest\
    \ even value\n  -- For each node, find the smallest even value\n  for i = 1, #arr\
    \ do\n    if arr[i] % 2 == 0 then\n      smalest_value = arr[i]\n      smalest_index\
    \ = i\n    end\n  end\n  -- For each node, find the smallest even value\n  for\
    \ i = 1, #arr do\n    if arr[i] % 2 == 0 then\n      local new_arr = {arr[i]}\n\
    \      table.insert(new_arr, arr[i])\n      table.insert(arr, new_arr)\n    end\n\
    \  end\n  -- For each node, find the smallest even value\n  for i = 1, #arr do\n\
    \    if arr[i] % 2 == 0 then\n      table.insert(arr, arr[i])\n    end\n  end\n\
    \  -- Return the smallest even value and the index of the smallest even value.\n\
    \  -- If there are no even values or the given array is empty, return [].\n  if\
    \ #arr == 0 or #arr == -1 then\n    return nil\n  end\n  if #arr == 1 then\n \
    \   if arr[1] == 0 then\n      arr[1] = nil\n    end\n    return arr\n  end\n\
    \  if #arr > 1 then\n    if smalest_value == 0 then\n      smalest_value = arr[1]\n\
    \      smalest_index = 1\n    end\n    local new_arr = {smalest_value, smalest_index}\n\
    \    table.insert(new_arr, arr[1])\n    table.insert(arr, new_arr)\n  end\n  return\
    \ arr\nend", "  -- First, find the max and min value in the array.\n  -- The min\
    \ value is the root of the tree.\n  local min, max = 0, #arr\n  for _ in arr[min..max]\
    \ do\n    max = max - 1\n  end\n  min = min - 1", "    local minimum = {}\n  \
    \  local index = 1\n    for _, node in ipairs(arr) do\n        if node.value %\
    \ 2 = 0 then\n            if minimum.value == nil or minimum.value < node.value\
    \ then\n                minimum.value = node.value\n                minimum.index\
    \ = index\n            end\n            index = index + 1\n        end\n    end\n\
    \    if minimum.value == nil then\n        return nil\n    end\n    if minimum.value\
    \ % 2 = 0 then\n        return minimum.index, minimum.value\n    else\n      \
    \  return minimum.index\n    end\nend", "  if #arr == 0 or arr[1] == nil then\n\
    \    return nil\n  else\n    local smalest_value = arr[1]\n    local smalest_index\
    \ = 2\n    for i = 2, #arr do\n      if arr[i] % 2 == 0 and arr[i] < smalest_value\
    \ then\n        smalest_value = arr[i]\n        smalest_index = i\n      end\n\
    \    end\n    if smalest_value == 0 then\n      return nil\n    end\n    return\
    \ smalest_value, smalest_index\n  end\nend", "    local result = {math.min(arr),\
    \ math.min(arr.i-1)}\n    if arr[arr.i-1] % 2 == 0 then return result end\n  \
    \  arr[arr.i-1] = math.min(arr[arr.i-1], arr[arr.i-2])\n    arr[arr.i-2] = arr[arr.i-2]\
    \ % 2 + 1\n    return pluck(arr)\nend\nprint(pluck({2, 7, 3, 6, 4, 1}))", "  \
    \  local results = {}\n    for i,value in ipairs(arr) do\n        if value%2 ==\
    \ 0 and arr[i] ~= 0 then\n            results[#results+1] = value\n        end\n\
    \    end\n    if #results > 0 then\n        local smallest, smallest_index = math.min(unpack(results)),\
    \ 1\n        for i,v in ipairs(results) do\n            if v == smallest then\n\
    \                smallest_index = smallest_index + 1\n                smallest\
    \ = v\n            end\n        end\n        return smallest, smallest_index\n\
    \    else\n        return nil, 0\n    end\nend", "    if #arr == 0 then\n    \
    \    return []\n    end\n    local ans = {}\n    for i = 1, #arr do\n        if\
    \ arr[i].value % 2 == 1 then\n            local idx = nil\n            if #ans\
    \ == 0 then\n                idx = 1\n            else\n                for j\
    \ = 1, #ans do\n                    if ans[j].value < arr[i].value then\n    \
    \                    idx = j\n                    end\n                end\n \
    \           end\n            ans[idx] = arr[i]\n        end\n    end\n    if #ans\
    \ == 0 then\n        return nil\n    end\n    return ans\nend", "    local i =\
    \ 1\n    local small = math.max(1, arr[1])\n    local small_index = 1\n    local\
    \ output = {}\n    while i < #arr and small_index == math.max(1, arr[i]) do\n\
    \        if arr[i] % 2 == 1 then\n            small = math.max(small, arr[i])\n\
    \            small_index = i\n        end\n        i = i + 1\n    end\n    if\
    \ i == #arr then\n        return output\n    end\n    if small % 2 == 1 then\n\
    \        return output\n    end\n    local temp_smallest_even_value_index\n  \
    \  for j = 1, i do\n        if arr[j] % 2 == 0 then\n            temp_smallest_even_value_index\
    \ = j\n        end\n    end\n    if temp_smallest_even_value_index == i then\n\
    \        return output\n    end\n    if temp_smallest_even_value_index ~= small_index\
    \ then\n        return output\n    end\n    return output, {small, small_index}\n\
    end", "    local index, smallest_value, index = 0, arr[1], 1\n    for idx, val\
    \ in enumerate(arr) do\n        if val % 2 == 0 then\n            if smallest_value\
    \ == nil then\n                smallest_value, index = val, idx\n            elseif\
    \ smallest_value < val then\n                smallest_value, index = val, idx\n\
    \            end\n        end\n    end\n    if smallest_value == nil then\n  \
    \      return nil\n    end\n    if smallest_value % 2 == 1 then\n        return\
    \ smallest_value, index\n    end\n    local second_smallest_value, second_index\
    \ = nil, 0\n    for idx, val in enumerate(arr) do\n        if val % 2 == 1 then\n\
    \            if second_smallest_value == nil then\n                second_smallest_value,\
    \ second_index = val, idx\n            elseif second_smallest_value < val then\n\
    \                second_smallest_value, second_index = val, idx\n            end\n\
    \        end\n    end\n    if second_smallest_value == nil then\n        return\
    \ second_smallest_value, second_index\n    end\n    local third\n    for idx,\
    \ val in enumerate(arr) do\n        if val % 2 == 0 then\n            if third\
    \ == nil then\n                third = val, idx\n            elseif third > val\
    \ then\n                third = val, idx\n            end\n        end\n    end\n\
    \    if third then\n        return third, index\n    end\nend", "    if #arr ==\
    \ 0 then\n        return nil\n    end\n    local small = 0\n    local large =\
    \ #arr - 1\n    repeat\n        if arr[small] % 2 ~= 0 then\n            small\
    \ = small + 1\n        else\n            if arr[large] % 2 == 0 then\n       \
    \         large = large - 1\n            else\n                local small_index\
    \ = small\n                local large_index = large\n                while small_index\
    \ < large do\n                    if arr[small_index] % 2 ~= 0 then\n        \
    \                small_index = small_index + 1\n                    else\n   \
    \                     break\n                    end\n                end\n  \
    \              local tmp = arr[small_index]\n                arr[small_index]\
    \ = arr[large_index]\n                arr[large_index] = tmp\n               \
    \ small = small_index\n                large = large_index\n            end\n\
    \        end\n    until small == large\n    local plucked = arr[small]\n    if\
    \ #plucked > 1 then\n        local smallest_value = plucked\n        local smallest_index\
    \ = small\n        local count = large\n        while count > 1 do\n         \
    \   smallest_value = smallest_value ^ arr[count]\n            smallest_index =\
    \ smallest_index ^ count\n            count = count - 1\n        end\n       \
    \ arr[smallest_index] = arr[smallest_index] ^ smallest_value\n    end\n    return\
    \ arr\nend", "    if arr == nil then return end\n    local node = arr[1]\n   \
    \ if node.value == 0 then return node end\n    local new_arr = {}\n    for i =\
    \ 2, #arr do \n        if arr[i].value == node.value then\n            new_arr[#new_arr+1]\
    \ = arr[i]\n        else\n            if arr[i].value == 0 and #new_arr > 0 then\
    \ \n                new_arr[#new_arr+1] = arr[i]\n            else\n         \
    \       if arr[i].value < node.value then\n                    new_arr[#new_arr+1]\
    \ = arr[i]\n                else\n                    new_arr[#new_arr+1] = arr[i]\n\
    \                    node = new_arr[#new_arr+1]\n                end\n       \
    \     end\n        end\n    end\n    return node\nend", "  local evens={}\n  for\
    \ i=1,#arr,1 do\n    if arr[i]%2 == 0 then\n      evens[arr[i]]=true\n    end\n\
    \  end\n  local smallest_value=nil\n  local smallest_index=nil\n  for k,v in pairs(evens)\
    \ do\n    if smallest_value == nil or smallest_value < v then\n      smallest_value=v\n\
    \      smallest_index=k\n    end\n  end\n  return smallest_value, smallest_index\n\
    end", "    local min_node = {}\n    for i,v in ipairs(arr) do\n        if v %\
    \ 2==0 then\n            if min_node[1] == nil or v < min_node[1] then\n     \
    \           min_node[1] = v\n                min_node[2] = i\n            end\n\
    \        end\n    end\n    if min_node[1] == nil or min_node[1] % 2 == 1 then\n\
    \        return []\n    end\n    return [ min_node[1], min_node[2] ]\nend", " \
    \ local smalest_value, smallest_index, smallest_even_value = math.inf, 1, 0\n\
    \  for i, v in ipairs(arr) do\n    if v % 2 == 0 then\n      if smallest_even_value\
    \ == 0 then\n        smallest_even_value = v\n        smallest_index = i\n   \
    \   elseif smallest_even_value < v then\n        smallest_even_value = v\n   \
    \     smallest_index = i\n      end\n    end\n  end\n  return smallest_even_value,\
    \ smallest_index\nend", "  -- Write your code here.\n  local i = 0\n  local result\
    \ = []\n  while i < #arr do\n    if arr[i] % 2 == 0 then\n      local smallest_val\
    \ = nil\n      local smallest_index = nil\n      for j = i+1, #arr do\n      \
    \  if arr[j] % 2 == 0 then\n          local val = arr[j]\n          if smallest_val\
    \ == nil or val < smallest_val then\n            smallest_val = val\n        \
    \    smallest_index = j\n          end\n        end\n      end\n      if smallest_val\
    \ == nil then\n        break\n      end\n      result.insert(smallest_val, smallest_index)\n\
    \      i = smallest_index + 1\n    else\n      i = i + 1\n    end\n  end\n  return\
    \ result\nend", "  -- base case: empty array\n  if #arr == 0 then\n    return\
    \ nil\n  end", '  local smalest_value, smalest_index, smalest_index2 = 0, {},
    {}', "  local i, largest, smallest = -Inf\n  for i, v in ipairs(arr) do\n    if\
    \ v > largest then\n      largest, smallest = v, i\n    end\n  end\n  return [smallest,\
    \ largest]\nend", "    local smalest_value = 0\n    local smallest_index = -1\n\
    \    local picked_index = 0\n    for i = 1, #arr do\n        if i % 2 == 0 then\n\
    \            if smalest_value < arr[i] then\n                smalest_value = arr[i]\n\
    \                picked_index = i\n            end\n        end\n        if smallest_index\
    \ < 0 and smalest_value == arr[i] then\n            smallest_index = i\n     \
    \   end\n    end\n    return arr[ smallest_index ], picked_index\nend", "    local\
    \ largest, index, smallest, even, value\n    largest, index, smallest, even, value\
    \ = 0, 0, 1, 1, 0\n    for i = 1, #arr do\n        value = arr[i]\n        if\
    \ value % 2 == 0 then\n            if value < smallest then\n                largest,\
    \ index, smallest, even = value, i, value, 1\n            else\n             \
    \   if value == smallest and even > 0 then\n                    largest, index,\
    \ smallest, even = value, i, value, even - 1\n                end\n          \
    \  end\n        end\n    end\n    if smallest == 0 then\n        return nil\n\
    \    else\n        return largest, index\n    end\nend", "    local min = math.min(unpack(arr))\n\
    \    local idx = 0\n    for i, v in ipairs(arr) do\n        if v == min then\n\
    \            idx = i\n        end\n    end\n    if arr[idx] == min then\n    \
    \    idx = idx\n    end\n    return min, idx\nend", "  local result = {}\n  --\
    \ Base case: if the array is empty or all values are not even return empty list\n\
    \  if #arr == 0 or all(arr[#arr]:gt(0)) then\n    return {}\n  end\n  -- Add all\
    \ values into the result with even values\n  for i = 1, #arr do\n    if arr[i]\
    \ % 2 == 1 then\n      table.insert(result, arr[i])\n    end\n  end\n  -- Sort\
    \ the array in ascending order\n  table.sort(result)\n  -- Return the top value\n\
    \  assert(#result >= 1)\n  return result[1]\nend\n</cell>\n<cell>\nassert(pluck([4,\
    \ 2, 3]) == 2)\nassert(pluck([1,2,3]) == 2)\nassert(pluck([]) == nil)\nassert(pluck([5,\
    \ 0, 3, 0, 4, 2]) == 0)\n</cell>\n<text>\nProblem 8 (4 points)\nA dictionary contains\
    \ words and definitions. Write a function that takes an integer index as an argument\
    \ and returns the definition of the word at that index.", "    if #arr == 0 then\
    \ return nil end\n    local small, index = 1, 1\n    for _, node in ipairs(arr)\
    \ do\n        if node % 2 == 0 and node < small then small = node end\n      \
    \  if node % 2 == 1 and node < small then\n            if index > small_index\
    \ then\n                small, index = small, index\n            else\n      \
    \          index = index + 1\n            end\n        end\n    end\n    return\
    \ small, index\nend", "    local min_val, min_idx\n    min_idx = nil\n    min_val\
    \ = nil\n    for i,v in ipairs(arr) do\n        if min_val == nil then\n     \
    \       min_val = v\n            min_idx = i\n        else\n            if v <\
    \ min_val then\n                min_val = v\n                min_idx = i\n   \
    \         end\n        end\n    end\n    if min_val == nil then return nil end\n\
    \    if min_idx == nil then return [ min_val, min_idx ] end\n    local new_arr\
    \ = {}\n    local last_idx\n    for i = min_idx, 1, -1 do\n        local v = arr[i]\n\
    \        local idx_i = i - 1\n        local idx_v = i - 1\n        while idx_i\
    \ >= 0 and idx_v >= 0 and idx_i >= idx_v do\n            local tmp = arr[idx_i]\n\
    \            arr[idx_i] = arr[idx_v]\n            arr[idx_v] = tmp\n         \
    \   idx_i = idx_i - 1\n            idx_v = idx_v - 1\n        end\n        if\
    \ idx_v >= 0 then\n            arr[idx_i] = arr[idx_v]\n        end\n        if\
    \ v == min_val then\n            new_arr[i] = v\n        elseif v > min_val then\n\
    \            new_arr[i] = v\n        end\n    end\n    if #new_arr == 0 then return\
    \ nil end\n    if #new_arr == 1 then return new_arr[1] end\n    return new_arr\n\
    end", "  -- first sort by even values\n  arr = arr:sort(function (x,y) return\
    \ x < y end)", "\tlocal results = {}\n\tlocal nodes = {}\n\tlocal smalest_value,\
    \ smalest_index = 0, 1\n\tlocal current_index = 1\n\tfor i, node in ipairs(arr)\
    \ do\n\t\tif not nodes[node] then\n\t\t\tnodes[node] = true\n\t\t\tcurrent_index\
    \ = current_index + 1\n\t\tend\n\t\tif i % 2 == 0 then\n\t\t\tlocal value = node\
    \ - current_index\n\t\t\tif value < smalest_value then\n\t\t\t\tsmalest_value,\
    \ smalest_index = value, current_index\n\t\t\tend\n\t\tend\n\tend\n\tif smalest_value\
    \ > 0 then\n\t\tresults[#results + 1] = smalest_value, smalest_index\n\tend\n\t\
    return results\nend", "    local len = #arr\n    local vals = {}\n    for i =\
    \ 1,len do\n        vals[i] = arr[i]\n    end\n    local result = {}\n    local\
    \ smallest, smallest_index = nil, 1\n    for i = 1,len do\n        if vals[i]\
    \ % 2 == 0 and smallest == nil then\n            smallest = vals[i]\n        \
    \    smallest_index = i\n        elseif vals[i] % 2 == 0 and vals[i] < smallest\
    \ then\n            smallest = vals[i]\n            smallest_index = i\n     \
    \   end\n    end\n    if smallest == nil then\n        return result\n    end\n\
    \    local smalest_index = smallest_index\n    local smalest_value = smallest\n\
    \    for i = 1,len do\n        if vals[i] % 2 ~= 0 then\n            smalest_value\
    \ = vals[i]\n            smalest_index = i\n            break\n        end\n \
    \   end\n    local small_arr, small_len, small_val = nil, 0, smalest_value\n \
    \   for i = 1,len do\n        if vals[i] % 2 == 0 and vals[i] == small_val then\n\
    \            small_arr = small_arr or {}\n            small_arr[small_len] = arr[i]\n\
    \            small_len = small_len + 1\n        elseif vals[i] % 2 ~= 0 and vals[i]\
    \ < small_val then\n            small_val = vals[i]\n            small_arr = small_arr\
    \ or {}\n            small_arr[small_len] = arr[i]\n            small_len = small_len\
    \ + 1\n        end\n    end\n    if small_arr then\n        for i = 1,small_len\
    \ do\n            result[i] = small_arr[i]\n        end\n    end\n    return result\n\
    end", "    if #arr == 0 then\n        return nil\n    end\n    local min_val =\
    \ arr[1]\n    local min_i = 2\n    for i = 2, #arr do\n        if min_val < arr[i]\
    \ then\n            min_val = arr[i]\n            min_i = i\n        end\n   \
    \ end\n    return [ min_val, min_i ]\nend", "  -- Start with the smallest even\
    \ value as the starting point\n  -- We then loop through the entire array starting\
    \ at the smallest even value \n  -- and moving through all the odd values to the\
    \ correct position\n  for index, node in ipairs(arr) do\n    if node:iseven then\n\
    \      -- If the next item is even then add it to the result\n      if index +\
    \ 1 == arr:len() then\n        return node, index\n      else\n        -- If the\
    \ next item is odd then we need to grab the next even value\n        -- and move\
    \ all the odd values forward in order to get to the\n        -- correct position\n\
    \        local next_even = arr[index + 1]:iseven()\n        if next_even then\n\
    \          -- Add it to the result\n          local result = node + arr[index\
    \ + 1]\n          -- Move all odd items to correct position\n          for j =\
    \ index + 1, arr:len() do\n            arr[j] = arr[j + 1]\n          end\n  \
    \        -- Return the result\n          return result, index + 1\n        end\n\
    \      end\n    end\n  end\nend", "    if not (#arr > 0) then\n        return\
    \ nil\n    end\n    local minValue = arr[1]\n    local minIndex = 1\n    for i\
    \ = 2, #arr do\n        if arr[i] > minValue then\n            if arr[i] % 2 ==\
    \ 0 then\n                minValue = arr[i]\n                minIndex = i\n  \
    \          end\n        end\n    end\n    local pluckedValue = minValue\n    if\
    \ minIndex == 1 then\n        return nil\n    end\n    return {minValue, minIndex}\n\
    end", "    local index = 1\n    local smalest_value = 1\n    local sorted_arr\
    \ = {}\n    local smallest_even_value\n    \n    sorted_arr[1] = arr[1]\n    smallest_even_value\
    \ = arr[1]\n    \n    for idx = 2, #arr do\n        if arr[idx] % 2 == 0 then\n\
    \            if smallest_even_value < arr[idx] then\n                smallest_even_value\
    \ = arr[idx]\n            end\n            if arr[idx] ~= smallest_even_value\
    \ then\n                smallest_even_value_index = idx\n            else\n  \
    \              smallest_even_value_index = index\n            end\n          \
    \  smallest_even_value = arr[idx]\n        else\n            sorted_arr[index]\
    \ = arr[idx]\n            index = index + 1\n        end\n    end\n    \n    if\
    \ smallest_even_value == 0 then\n        return nil\n    else\n        if smallest_even_value_index\
    \ == 1 then\n            sorted_arr[smallest_even_value_index] = smallest_even_value\n\
    \            return sorted_arr\n        else\n            if smallest_even_value_index\
    \ > 1 then\n                return sorted_arr[smallest_even_value_index-1], smallest_even_value_index\n\
    \            else\n                return sorted_arr[smallest_even_value_index-1]\n\
    \            end\n        end\n    end\nend", "    local function pick_smallest_value(item)\n\
    \        if item == nil then\n            return nil\n        end\n        if\
    \ item.value == nil then\n            return pick_smallest_value(item.left)\n\
    \        end\n        if item.value == 0 then\n            return item.index\n\
    \        end\n        if item.value < 0 then\n            local index = pick_smallest_value(item.left)\n\
    \            if index == nil then\n                return nil\n            end\n\
    \            return pick_smallest_value(item.right), index\n        end\n    \
    \    if item.value > 0 then\n            local index = pick_smallest_value(item.right)\n\
    \            if index == nil then\n                return nil\n            end\n\
    \            return pick_smallest_value(item.left), index\n        end\n     \
    \   return item.value, item.index\n    end\n    return pick_smallest_value(arr)\n\
    end", "    if not arr then return nil end\n    local even = 0\n    local pos =\
    \ 1\n    for i=1,#arr do\n        if arr[i] % 2 == 0 then\n            even =\
    \ even + 1\n            if even > pos and even > arr[pos] then\n             \
    \   pos = i\n            end\n        end\n    end\n    local result = {}\n  \
    \  if arr[pos] ~= 0 then\n        result[1] = arr[pos]\n    end\n    if pos <\
    \ #arr then\n        result[2] = arr[pos]\n    end\n    return result\nend", " \
    \   local smallest, smallest_index = 0, 1\n    for _, value in ipairs(arr) do\n\
    \        if even and value % 2 == 0 then\n            if smallest < value then\n\
    \                smallest = value\n                smallest_index = smallest_index\
    \ - 1\n            elseif smallest == value then\n                smallest_index\
    \ = smallest_index - 1\n            end\n        end\n    end\n    local small_array\
    \ = setmetatable({}, {__index = function()\n        return smallest_index\n  \
    \  end})\n    local result = small_array\n    for _, value in ipairs(arr) do\n\
    \        if value == smallest then\n            small_array[value] = smallest_index\n\
    \        end\n    end\n    if small_array[smallest] == nil then\n        return\
    \ nil\n    end\n    for key, value in pairs(small_array) do\n        if key <\
    \ smallest then\n            local _, index = small_array[value]\n           \
    \ result[index] = value\n        end\n    end\n    return result\nend", "  if\
    \ #arr == 0 then\n    return []\n  end\n  local minimum, min = math.min(arr),\
    \ nil\n  for i, v in ipairs(arr) do\n    if minimum < v then\n      minimum, min\
    \ = v, i\n    end\n  end\n  -- return min\n  return arr\nend\n</cell>\n<text>\n\
    Great Job!", "  local len = #arr\n  local max_index = {}\n  local max_value =\
    \ {}\n  local current_index = 1\n  for i = 1, len do\n    if arr[i] % 2 == 0 then\n\
    \      local value = arr[i]\n      if value > max_value[#max_value] then\n   \
    \     max_value[#max_value] = value\n        max_index[#max_value] = current_index\n\
    \      else\n        max_value[#max_value] = max_value[#max_value] * 2\n     \
    \   max_index[#max_value] = current_index\n      end\n    end\n    current_index\
    \ = current_index + 1\n  end\n  return max_index, max_value\nend", "    if not\
    \ arr then return end\n    local index = 1\n    local smallest = arr[1]\n    local\
    \ min_index = nil\n    for i=2,#arr do\n        local value = arr[i]\n       \
    \ if value < smallest and ((min_index == nil or value < min_index) then\n    \
    \        smallest = value\n            min_index = index\n        end\n      \
    \  index = index + 1\n    end\n    if min_index == nil then\n        return nil\n\
    \    end\n    return smallest, min_index\nend", "    local pluck_cache = {}\n\
    \    local pluck_cache = {}\n    local pluck_cache = {}\n    local function aux(curr,\
    \ i, acc)\n        if #acc > 1 then\n            if acc[#acc][1] < acc[#acc][2]\
    \ then\n                return acc[#acc]\n            else\n                acc[#acc][2]\
    \ = acc[#acc][2] + 2\n            end\n        end\n        \n        if #curr\
    \ ~= 0 then\n            if curr[#curr] == 0 then\n                acc[1][1] =\
    \ curr[#curr]\n                acc[1][2] = 1\n                curr[#curr] = nil\n\
    \            else\n                local min = #curr\n                \n     \
    \           local i = 1\n                while i + 1 < #curr do\n            \
    \        \n                    if curr[i + #curr] == 0 then\n                \
    \        min = i\n                    elseif curr[i + #curr] % 2 == 0 then\n \
    \                       min = i\n                    end\n                   \
    \ \n                    i = i + 1\n                end\n                \n   \
    \             if curr[min] == 0 then\n                    acc[min+1][1] = curr[min]\n\
    \                    acc[min+1][2] = 1\n                    curr[min] = nil\n\
    \                else\n                    acc[min+1][1] = curr[min]\n       \
    \             acc[min+1][2] = 1 + 2 * min + 1\n                    curr[min] =\
    \ nil\n                end\n            end\n            \n        end\n     \
    \   \n        return acc\n    end\n    \n    \n    local arr_size = #arr\n   \
    \ local acc = {{}, {}, {}, {}, {}}\n    \n    if arr_size <= 1 then\n        return\
    \ arr_size\n    else\n        local acc = {{}, {}, {}, {}, {}}\n        for i\
    \ = 1, arr_size do\n            if arr[i] ~= 0 then\n                aux(arr,\
    \ 0, acc)\n            end\n        end\n        \n        local ret_array = {}\n\
    \        for i = 1, arr_size do\n            if acc[1][1] > 0 then\n         \
    \       ret_array[i] = {acc[1][1], acc[1][2]}\n            end\n            \n\
    \            if acc[i + 1][1] > 0 then\n                ret_array[i] = {acc[i\
    \ + 1][1], acc[i + 1][2]}\n            end\n        end\n        return ret_array\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nusing Random\n</cell>\n<code\
    \ language=julia-1.5>\nRandom.seed!(1234)\n</cell>\n<code language=julia-1.5>\n\
    n = 10^4\nm = 10^4\n</cell>\n<code language=julia-1.5>\nRandom.shuffle!(vec(ones(n)))\n\
    </cell>\n<code language=julia-1.5>\nRandom.", "   local size = #arr\n   local\
    \ evens = nil\n   for i = 1,size do\n      if i % 2 == 0 then\n         if evens\
    \ ~= nil then\n            evens, arr[size - i] = arr[size - i], evens\n     \
    \    else\n            evens = i\n         end\n      else\n         if evens\
    \ ~= nil and evens > i then\n            evens = nil\n         end\n      end\n\
    \   end\n   if evens ~= nil then\n      -- Return the smallest even value\n  \
    \    return arr[evens]\n   else\n      -- No even value\n      return nil\n  \
    \ end\nend", "    local evens = {}\n    local smalest_index = 0\n    for i = 1,#arr\
    \ do\n        if arr[i] % 2 == 0 then\n            evens[#evens + 1] = arr[i]\n\
    \            if #evens == 1 then\n                smalest_index = i\n        \
    \    else\n                local min = #evens\n                for j = 1,#evens\
    \ do\n                    if evens[j] < evens[min] then\n                    \
    \    min = j\n                    end\n                end\n                if\
    \ evens[min] == evens[smalest_index] then\n                    smalest_index =\
    \ min\n                else\n                    smalest_index = i\n         \
    \       end\n            end\n        end\n    end\n    local plucked = evens[smalest_index]\n\
    \    if #evens == 0 then\n        return []\n    end\n    return [ smalest_index,\
    \ plucked ]\nend\n</cell>\n<text>\nProblem 4 (3 points)\nA robot falls from the\
    \ sky falling downward. Each year, the robot will make a \nsingle random walk.\
    \ A robot can make up to 30 random walks.", "    local map = {}\n    for i, v\
    \ in pairs(arr) do\n        if v then\n            map[v] = map[v] or {}\n   \
    \         map[v][i] = true\n        end\n    end\n    local sorted_map = sort(map)\n\
    \    local index = next(sorted_map)\n    while true do\n        local value =\
    \ sorted_map[index]\n        local key = tostring(value)\n        local idx =\
    \ index(sorted_map, key)\n        if idx ~= index then\n            index = idx\n\
    \        else\n            break\n        end\n    end\n    return index, value\n\
    end\n</cell>\n<code language=julia-1.0>", "    local min_value, min_node = nil,\
    \ {}\n    for _, v in ipairs(arr) do\n        if v % 2 == 0 and v < min_value\
    \ then\n            min_value = v\n            min_node = v\n        end\n   \
    \ end\n    if min_value == 0 then\n        -- no even value exists\n        return\
    \ {}\n    end\n    if min_value == min_node then\n        -- there is only one\
    \ node with even value\n        return {min_value}\n    end\n    return { min_value,\
    \ min_node_index }\nend", "    local minimum = {}\n    for i,v in pairs(arr) do\n\
    \        if minimum[v] ~= nil and minimum[v] % 2 == 1 then\n            minimum[v]\
    \ = minimum[v] + 1\n        else\n            minimum[v] = 1\n        end\n  \
    \  end\n    local result = {}\n    for k,v in pairs(minimum) do\n        if minimum[v]\
    \ ~= nil and minimum[v] % 2 == 1 then\n            result[minimum[v]] = k\n  \
    \      elseif minimum[v] == nil then\n            local maxv = nil\n         \
    \   for i,v in pairs(arr) do\n                if maxv ~= nil and maxv <= v then\n\
    \                    maxv = v\n                else\n                    maxv\
    \ = i\n                end\n            end\n            if maxv ~= nil then\n\
    \                result[maxv] = k\n            end\n        end\n    end\n   \
    \ return table.concat(result)\nend\n</cell>\n<text>\nTest Your Solution", "\t\
    local even = {}\n\tlocal index = {}\n\tlocal min_even_node = nil\n\tfor i = 1,#arr\
    \ do\n\t\tlocal v = arr[i]\n\t\tif v % 2 = 0 then\n\t\t\teven[v] = true\n\t\t\t\
    table.insert(index, v)\n\t\t\tif #index == #even then\n\t\t\t\tlocal even_v =\
    \ #index + 1\n\t\t\t\t-- if smallest even value is already chosen, pick the smallest\
    \ index\n\t\t\t\tif #min_even_node > 0 and v < min_even_node then\n\t\t\t\t\t\
    min_even_node = even_v\n\t\t\t\telse\n\t\t\t\t\tmin_even_node = v\n\t\t\t\tend\n\
    \t\t\tend\n\t\telse\n\t\t\t-- pick the smallest even value found and index\n\t\
    \t\tmin_even_node = v\n\t\tend\n\tend\n\t-- remove indexes from array\n\tfor i\
    \ = 1,#index do\n\t\ttable.remove(index, i)\n\tend\n\tif #index > 0 then\n\t\t\
    -- find smallest even value with smallest index\n\t\tlocal min_even_v = #index\
    \ + 1\n\t\tfor i = 1,#index do\n\t\t\tif index[min_even_v] < index[i] then\n\t\
    \t\t\tmin_even_v = i\n\t\t\tend\n\t\tend\n\t\t-- return the smallest even value\
    \ with smallest index\n\t\treturn min_even_v, index[min_even_v]\n\telse\n\t\t\
    return nil, nil\n\tend\nend", "    if #arr == 0 then return end\n    local i,\
    \ min_idx, min_val = unpack(table.sort(arr, function(a, b) return a > b end))\n\
    \    local i1, i2 = i-1, i+1\n    while i1 < #arr and arr[i1].value % 2 == 0 do\n\
    \        i1 = i1 + 1\n    end\n    while i2 < #arr and arr[i2].value % 2 == 0\
    \ do\n        i2 = i2 + 1\n    end\n    if i1 == #arr then\n        if arr[i2].value\
    \ < arr[i-1].value then \n            return arr[i2].value, i\n        else\n\
    \            return arr[i-1].value, i\n        end\n    else\n        if arr[i2].value\
    \ < arr[i1].value then\n            return arr[i2].value, i\n        else\n  \
    \          return arr[i1].value, i\n        end\n    end\nend", "  -- Base case:\
    \ empty list\n  if #arr == 0 then\n    return {}\n  -- Base case: two elements\n\
    \  elseif #arr == 2 then\n    return { arr[1], arr[1] }\n  -- Recursive case:\
    \ three or more elements\n  else\n    -- Create a table with {node, index} pairs\n\
    \    local table = {}\n    for i = 1, #arr do\n      table.insert({arr[i], i})\n\
    \    end\n    table.sort(function(a,b) return a.value < b.value end)\n    -- Now\
    \ we have the smallest value and its index -- let's pluck the others\n    local\
    \ smalest_value = table[1].value -- first value is a smallest value\n    local\
    \ smalest_index = 0\n    for i = 2, #table do\n      local value = table[i].value\
    \ -- second value is a smallest value\n      if value == smalest_value then --\
    \ if the value is equal, let's pick the smaller index\n        smalest_index =\
    \ table[i].index -- pick the smaller index\n      else -- otherwise pick the bigger\
    \ value\n        smalest_value = value\n        smalest_index = table[i].index\n\
    \      end\n    end\n    -- Now we return the pair [smalest_value, smalest_index]\n\
    \    return {smalest_value, smalest_index}\n  end\nend", "    if #arr == 0 then\n\
    \        error('The given array can not be empty.')\n    end", "    local index\
    \ = 1\n    local even_values, smalest_value = setmetatable({}, {__index=function()\
    \ return index end})\n    for _,node in ipairs(arr) do\n        if node % 2 ==\
    \ 0 then\n            even_values[#even_values + 1] = node\n            if even_values[#even_values]\
    \ ~= smalest_value then\n                smalest_value = even_values[#even_values]\n\
    \            end\n        end\n        index = index + 1\n    end\n    if #even_values\
    \ == 0 then\n        return nil\n    end\n    local min_value, index = smalest_value,\
    \ 1\n    for _, value in ipairs(even_values) do\n        if value < min_value\
    \ then\n            min_value, index = value, index\n        end\n    end\n  \
    \  return min_value, index\nend", "    local result = {}\n    local largest =\
    \ nil\n    local index = nil\n    for _, v in ipairs(arr) do\n        if v % 2\
    \ == 0 then\n            if largest == nil or v < largest then\n             \
    \   largest = v\n                index = v\n            else\n               \
    \ largest = nil\n            end\n        else\n            if largest ~= nil\
    \ and v == largest then\n                largest = nil\n            end\n    \
    \    end\n    end\n    if largest ~= nil then\n        result[1] = largest\n \
    \       result[2] = index\n    end\n    return result\nend", "    local ans =\
    \ {}\n    local index\n    local smallest_val\n    local smallest_index\n    for\
    \ _, v in ipairs(arr) do\n        if v < smallest_val then\n            smallest_val\
    \ = v\n            smallest_index = smallest_val\n        end\n        if v %\
    \ 2 == 0 then\n            index = v\n        end\n    end\n    if smallest_val\
    \ == 0 or index == 0 then\n        return nil\n    end\n    for _, v in ipairs(arr)\
    \ do\n        if v < smallest_val then\n            smallest_val = v\n       \
    \     smallest_index = smallest_val\n        end\n        if v % 2 == 0 then\n\
    \            index = v\n        end\n    end\n    ans[1] = smallest_index\n  \
    \  return ans\nend", "    local arr_size = #arr\n    local index = 0\n    local\
    \ result = {}\n    for i = 1, arr_size do\n        if arr[i] % 2 == 0 then\n \
    \           result[index] = arr[i]\n            index = index + 1\n        end\n\
    \    end\n    if index == 0 then\n        return nil\n    elseif index == 1 then\n\
    \        return result \n    elseif index > 1 then\n        local first_result\
    \ = result[1]\n        for i = 2, arr_size do\n            if result[i] < first_result\
    \ then\n                first_result = result[i]\n            end\n        end\n\
    \        return first_result\n    else\n        return nil\n    end\nend", "\t\
    local even_values = {}\n\tlocal index_of_smallest = {}\n\tlocal plucked_nodes\
    \ = {}\n\tlocal len = #arr\n\t\n\tfor i = 1, len do\n\t\tif arr[i]%2 == 0 then\n\
    \t\t\ttable.insert(even_values, arr[i])\n\t\t\ttable.insert(index_of_smallest,\
    \ i)\n\t\tend\n\tend\n\t\n\tif #even_values == 0 then\n\t\treturn {}\n\telseif\
    \ #even_values > 1 then\n\t\ttable.sort(even_values)\n\t\ttable.sort(index_of_smallest)\n\
    \t\t\n\t\tif index_of_smallest[#index_of_smallest - 1] > 1 then\n\t\t\tlocal smallest_even_value\
    \ = even_values[#even_values - 1]\n\t\t\tlocal smallest_even_index = index_of_smallest[#index_of_smallest\
    \ - 1]\n\t\t\tlocal plucked_node = {}\n\t\t\tplucked_node[1] = smallest_even_value\n\
    \t\t\tplucked_node[2] = smallest_even_index\n\t\t\ttable.insert(plucked_nodes,\
    \ plucked_node)\n\t\telseif index_of_smallest[#index_of_smallest - 1] == 1 then\n\
    \t\t\tlocal plucked_node = {}\n\t\t\tplucked_node[1] = even_values[#even_values\
    \ - 1]\n\t\t\ttable.insert(plucked_nodes, plucked_node)\n\t\telse\n\t\t\tlocal\
    \ plucked_node = {}\n\t\t\tplucked_node[1] = even_values[#even_values - 1]\n\t\
    \t\ttable.insert(plucked_nodes, plucked_node)\n\t\t\tlocal pluck_arr = {}\n\t\t\
    \tlocal plucked_node_index = #plucked_nodes - 1\n\t\t\tfor i = 1, #even_values\
    \ do\n\t\t\t\tif even_values[i] == smallest_even_value then\n\t\t\t\t\ttable.insert(pluck_arr,\
    \ i)\n\t\t\t\telseif even_values[i] == plucked_nodes[plucked_node_index][1] then\n\
    \t\t\t\t\ttable.insert(pluck_arr, i)\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\twhile\
    \ #pluck_arr > 0 do\n\t\t\t\tlocal pluck_val = even_values[#pluck_arr]\n\t\t\t\
    \tlocal pluck_index = index_of_smallest[#plucked_nodes - 1]\n\t\t\t\tif pluck_val\
    \ == plucked_nodes[pluck_index][1] then\n\t\t\t\t\ttable.insert(plucked_nodes,\
    \ pluck_val)\n\t\t\t\t\ttable.insert(plucked_nodes, pluck_index)\n\t\t\t\t\ttable.remove(pluck_arr)\n\
    \t\t\t\telse\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\telse\n\t\ttable.insert(plucked_nodes,\
    \ even_values[1])\n\tend\n\treturn plucked_nodes\nend", "    local small = nil\n\
    \    local index\n    for i, v in ipairs(arr) do\n        if small == nil then\n\
    \            if v % 2 == 0 then\n                small = v\n            else\n\
    \                small = index\n            end\n        else\n            if\
    \ v % 2 == 0 and v < small then\n                small = v\n            end\n\
    \        end\n        index = i\n    end\n    if small == nil then\n        return\
    \ []\n    end\n    return {small, index}\nend", "    local result = {}\n    local\
    \ smalest_value = arr[1]\n    local smalest_index = 1", "    local results = {}\n\
    \    local smallest_index = nil\n    local smallest_value = nil\n    for i, v\
    \ in ipairs(arr) do\n        local even = v % 2 == 0\n        if even and smallest_value\
    \ == nil then\n            smallest_value = v\n            smallest_index = i\n\
    \        elseif even and v < smallest_value then\n            smallest_value =\
    \ v\n            smallest_index = i\n        end\n    end\n    if smallest_value\
    \ == nil then\n        return nil\n    end\n    local index = 1\n    for i, v\
    \ in ipairs(arr) do\n        local even = v % 2 == 0\n        if even and v ==\
    \ smallest_value then\n            results[index] = v\n            index = index\
    \ + 1\n        end\n    end\n    return results\nend", "    if arr[1] == nil then\n\
    \        return nil\n    end\n    local min_value = arr[1]\n    local min_value_node_index\
    \ = nil\n    for _, node in ipairs(arr) do\n        if node == nil then\n    \
    \        return nil\n        end\n        if node % 2 == 0 then\n            if\
    \ min_value > node then\n                min_value = node\n                min_value_node_index\
    \ = nil\n            else\n                min_value_node_index = i\n        \
    \    end\n        end\n    end\n    \n    return arr[min_value_node_index]\nend",
  "  local smalest_value = math.min.apply(null, arr)\n  local idx = 1\n  local found\
    \ = false\n  repeat\n    found = true or arr[smalest_value] == smalest_value\n\
    \    if not found then\n      local new_val = arr[smalest_value]\n      arr[smalest_value]\
    \ = arr[idx]\n      arr[new_val] = smalest_value\n      smalest_value = new_val\n\
    \      idx = idx + 1\n    end\n  until not found", "    if #arr == 0 then\n  \
    \      return {}\n    end\n    local min_index = -1\n    local min_value = arr[1]\n\
    \    for i = 2, #arr do\n        if arr[i] < min_value then\n            min_value\
    \ = arr[i]\n            min_index = i\n        end\n    end\n    local plucked_value\
    \ = min_value\n    local plucked_index = min_index\n    local min = arr[min_index]\n\
    \    for i = 1, min_index do\n        if arr[i] < min then\n            plucked_value\
    \ = arr[i]\n            plucked_index = i\n            min = arr[min_index]\n\
    \        end\n    end\n    return {plucked_value, plucked_index}\nend", "    local\
    \ results = {}\n    local picked_node_index = -1\n    local picked_node_value\
    \ = nil\n    for i = 1,#arr,1 do\n        if arr[i] ~= 0 then\n            if\
    \ picked_node_value == nil or arr[i] < picked_node_value then\n              \
    \  picked_node_value = arr[i]\n                picked_node_index = i\n       \
    \     end\n        end\n    end\n    if picked_node_value ~= nil then\n      \
    \  table.insert(results,picked_node_value,picked_node_index)\n    end\n    return\
    \ results\nend\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>\n<cell>\nprint(pluck([0,2,3,4]))\n\
    </cell>\n<cell>\nprint(pluck([0,2,3,4]))\n</cell>", "    local largest, index\
    \ = {}, 0\n    for i = 1,#arr do\n        if arr[i] > largest[1] then\n      \
    \      largest[1] = arr[i]\n            largest[2] = i\n        end\n    end\n\
    \    while true do\n        if largest[1] % 2 == 0 and largest[2] < #arr then\n\
    \            largest[1] = largest[1] / 2\n            largest[2] = largest[2]\
    \ + 1\n        else\n            break\n        end\n    end\n    return largest\n\
    end", "    local even_smallest = {}\n    local min_value = nil\n    local smallest_index\
    \ = nil\n    for i, v in ipairs(arr) do\n        if v:nth(0) % 2 == 0 then\n \
    \           if min_value == nil then\n                min_value = v\n        \
    \        smallest_index = i\n            elseif v < min_value then\n         \
    \       min_value = v\n                smallest_index = i\n            end\n \
    \       else\n            even_smallest[#even_smallest + 1] = v\n        end\n\
    \    end\n    if #even_smallest == 0 then\n        return nil\n    elseif #even_smallest\
    \ == 1 then\n        return { even_smallest[1], smallest_index }\n    else\n \
    \       local mins = {}\n        for k, v in pairs(even_smallest) do\n       \
    \     if v < min_value then\n                mins[#mins + 1] = { v, k }\n    \
    \        end\n        end\n        if #mins == 0 then\n            return nil\n\
    \        else\n            local min = mins[#mins][1]\n            for _, v in\
    \ ipairs(mins) do\n                if v[1] < min then\n                    min\
    \ = v[1]\n                end\n            end\n            return { min, min\
    \ }\n        end\n    end\nend", "  local small = 0\n  local big, index = -1,\
    \ 0", "  local smalest_value = math.min(table.unpack(arr))\n  local idx = 1\n\
    \  local smalest_value_node = nil\n  for i, n in ipairs(arr) do\n    if n == smalest_value\
    \ then\n      smalest_value_node = n\n    else\n      if smalest_value > n then\n\
    \        if smalest_value_node and idx == i then\n          smalest_value = n\n\
    \        else\n          smalest_value = n\n          idx = i\n        end\n \
    \     end\n    end\n  end\n  return smalest_value_node, idx\nend", "  local min_even_val\
    \ = nil\n  local min_even_pos = nil\n  local plucked = nil\n  local even_num =\
    \ nil\n  local even_pos = nil\n  for _, val in ipairs(arr) do\n    if val <= 0\
    \ then return nil end\n    if min_even_val == nil or val <= min_even_val then\n\
    \      min_even_val = val\n      min_even_pos = _\n      min_even_pos = nil\n\
    \    end\n    if val % 2 == 0 then\n      if min_even_val == nil or val <= min_even_val\
    \ then\n        min_even_val = val\n        min_even_pos = _\n        min_even_pos\
    \ = nil\n      end\n      even_num = even_num + 1\n      if even_num == 1 then\n\
    \        even_pos = val\n      end\n    end\n  end\n  if min_even_val == nil then\
    \ return nil end\n  if min_even_pos == nil then\n    return min_even_val, min_even_pos\n\
    \  end\n  local plucked_vals = nil\n  for _, val in ipairs(arr) do\n    if val\
    \ == min_even_pos then\n      if plucked_vals == nil then\n        plucked_vals\
    \ = {}\n      end\n      table.insert(plucked_vals, min_even_val)\n    end\n \
    \   if val % 2 == 0 then\n      table.insert(plucked_vals, val)\n    end\n  end\n\
    \  if plucked_vals == nil then return nil end\n  local plucked_val_pos = nil\n\
    \  local plucked_val = nil\n  for _, val in ipairs(plucked_vals) do\n    local\
    \ val = val - 1\n    if plucked_val_pos == nil then\n      plucked_val_pos = val\n\
    \      plucked_val = val\n    else\n      if val < plucked_val then\n        plucked_val_pos\
    \ = val\n        plucked_val = val\n      end\n    end\n  end\n  return plucked_val,\
    \ plucked_val_pos\nend", "\tlocal sorted = {}\n\tlocal plucked", "    local even_values\
    \ = {}\n    local index = 0\n    for _,i in ipairs(arr) do\n        if i % 2 ==\
    \ 0 then\n            even_values[i] = true\n        end\n        index = index\
    \ + 1\n    end\n    if #even_values == 0 or #even_values == nil then\n       \
    \ return nil\n    end\n    local min_index = #even_values\n    for _, i in pairs(even_values)\
    \ do\n        if i then\n            min_index = min_index - 1\n        end\n\
    \    end\n    if min_index == 1 then\n        return nil\n    end\n    local min_value\
    \ = even_values[min_index]\n    return min_value, index\nend", "  if #arr < 2\
    \ then\n    return arr\n  elseif #arr == 2 then\n    if arr[1] % 2 == 0 then\n\
    \      local v1 = arr[1]\n      local v2 = arr[2]\n      return [v2, v1 + 1]\n\
    \    else\n      return arr\n    end\n  elseif #arr == 3 then\n    if arr[1] %\
    \ 2 == 0 and arr[2] % 2 == 0 then\n      local v1 = arr[1]\n      local v2 = arr[2]\n\
    \      local v3 = arr[3]\n      return [v3, v1 + v2, v2 + 1]\n    end\n  end",
  "  local arr = arr or {}\n  local min_even_val\n  local min_even_index\n  local\
    \ result\n  for _, node in ipairs(arr) do\n    if min_even_val == nil or (node.value\
    \ % 2) == 0 then\n      min_even_val = node.value\n      min_even_index = nil\n\
    \    elseif min_even_val == node.value then\n      min_even_index = #result\n\
    \    end\n    result = result or {}\n    result[#result + 1] = min_even_val, min_even_index\n\
    \  end\n  return result\nend\nprint(pluck(\n {\n  value = 5,\n  left = { value\
    \ = 0, left = nil, right = nil },\n  right = { value = 0, left = nil, right =\
    \ nil }\n }\n))", "    local even = {}\n    local smalest_value = 0\n    local\
    \ smalest_index = 1\n    for i, v in pairs(arr) do\n        if v % 2 == 0 then\n\
    \            even[v] = true\n            if v < smalest_value then\n         \
    \       smalest_value = v\n                smalest_index = i\n            end\n\
    \        end\n    end\n    if #even == 0 then\n        return nil\n    end\n \
    \   return smalest_value, smalest_index\nend", "    if arr == nil then return\
    \ nil end\n    if #arr == 0 then return [] end", "    local max_value, max_index\
    \ = nil, nil\n    for i = 1, #arr do\n        if arr[i] % 2 = 0 then\n       \
    \     local val, index = arr[i], i\n            if val > max_value then\n    \
    \            max_value, max_index = val, index\n            else\n           \
    \     if val == max_value and index == max_index then\n                    max_index\
    \ = i\n                else\n                    max_value, max_index = val, index\n\
    \                end\n            end\n        end\n    end\n    if max_value\
    \ ~= nil then\n        return max_value, max_index\n    else\n        return nil,\
    \ nil\n    end\nend", "    local results = {}\n    for i = 0, arr.length - 1 do\n\
    \        local smaller\n        local idx = 1\n        while idx <= #arr and arr[idx]\
    \ == arr[idx] then\n            if smaller and smaller.value < arr[idx].value\
    \ then\n                smaller = arr[idx]\n            else\n               \
    \ idx = idx + 1\n            end\n        end", "    return arr:map(function (x,\
    \ index)\n        return index % 2 == 0 and x or -1\n    end)\nend", "  local\
    \ smalest_value, smalest_index, counter = arr[1], 0, 1\n  for _, node in ipairs(arr)\
    \ do\n    if node == 0 then\n      if smalest_value == 0 then\n        smalest_value,\
    \ smalest_index, counter = node, 0, 1\n      else\n        if counter < counter\
    \ then\n          smalest_value, smalest_index, counter = node, 0, 1\n       \
    \ else\n          smalest_value, smalest_index, counter = node, smalest_index,\
    \ 1\n        end\n      end\n    elseif node % 2 == 0 then\n      counter = counter\
    \ + 1\n    else\n      if smalest_value == 0 then\n        smalest_value, smalest_index,\
    \ counter = node, smalest_index, 1\n      else\n        if counter < counter then\n\
    \          smalest_value, smalest_index, counter = node, smalest_index, 1\n  \
    \      else\n          smalest_value, smalest_index, counter = node, smalest_index,\
    \ 1\n        end\n      end\n    end\n  end\n  return smalest_value, smalest_index\n\
    end", "    local index = 1\n    local min_index = 1\n    local smalest_value =\
    \ 1\n    local min_index = 1\n    for i = 1, #arr do\n        local value = arr[i]\n\
    \        if value == 0 then\n            if min_index == 1 then\n            \
    \    min_index = index\n            end\n            min_index = index\n     \
    \       smalest_value = value\n            index = i + 1\n        elseif value\
    \ == smalest_value then\n            if index > min_index then\n             \
    \   min_index = index\n            end\n            smalest_value = value\n  \
    \          index = i + 1\n        else\n            smalest_value = value\n  \
    \          index = i\n        end\n    end\n    if min_index == 1 then\n     \
    \   min_index = index\n    end\n    return smalest_value, min_index\nend\n</cell>\n\
    <cell>\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5,0,3,0,4,2]))\n\
    print(pluck([1,2,4,5,6,7]))\nprint(pluck([0,4,8,7,9,1,5]))\nprint(pluck([1,3,2,3]))\n\
    </cell>\n<text>\nArray Sum Concept\nGiven an array arr[] of positive integers\
    \ and a target number target, write a function that returns an array arr2[] of\
    \ same size where arr2[i] is equal to the sum of all the positive integers in\
    \ arr[:i] to target.\nIf there are no such integers return an empty array.\nIf\
    \ there are multiple integers whose sum equals to target return any one of them.",
  "    local len = #arr\n    local ret = {}\n    local i = 1\n    while i < len do\n\
    \        if arr[i] % 2 == 0 then\n            ret[i] = arr[i]\n            i =\
    \ i + 1\n        else\n            i = i + 1\n        end\n    end\n    return\
    \ ret\nend", "    local min_index = 1\n    local smalest_value\n    for i = 1,\
    \ #arr do\n        if arr[i] % 2 == 0 and arr[i] > smalest_value and min_index\
    \ > i then\n            min_index = i\n            smalest_value = arr[i]\n  \
    \      end\n    end\n    if #arr == 0 and min_index > 1 then\n        min_index\
    \ = min_index - 1\n    end\n    return smalest_value, min_index\nend", "    local\
    \ min = #arr\n    local pos = 1\n    for i = 1, min do \n        if arr[i] % 2\
    \ == 0 then\n            if pos < min then\n                pos = i\n        \
    \    elseif arr[i]<arr[pos] then\n                pos = i\n            end\n \
    \       end\n    end\n    return arr[pos], pos\nend", "    if not arr then\n \
    \       return nil\n    end", "  if #arr == 0 then\n    return []\n  else\n  \
    \  local smallers, i, j = 1, {}, {}\n    for i = 1, #arr do\n      if arr[i] <\
    \ arr[i-1] then\n        smallers[#smallers+1] = i\n      else\n        j[arr[i-1]]\
    \ = i\n      end\n    end\n    for k, v in pairs(j) do\n      if smallers[v] <\
    \ #smallers then\n        smallers[#smallers+1] = v\n      end\n    end\n    return\
    \ smallers, arr[smallers[#smallers]]\n  end\nend", "    local smalest_value =\
    \ 0\n    local smallest_index = 0\n    local even_values = 0", "    local i =\
    \ 1\n    local size = #arr\n    local smalest_value = 0\n    local min_even_node_index\
    \ = 1\n    local result = {}\n    for i=1, size do\n        smalest_value = arr[i]\n\
    \        local min_even_node_index = 1\n        if smalest_value % 2 == 0 then\n\
    \            local count = i\n            while count <= size and smalest_value\
    \ % 2 == 0 do\n                count = count + 1\n            end\n          \
    \  smalest_value = arr[count]\n        end\n        if smalest_value < arr[min_even_node_index]\
    \ then\n            min_even_node_index = i\n        end\n        result[i] =\
    \ smalest_value\n    end\n    return result\nend", "  local even_values, index\
    \ = list{}, 0\n  for i = 1, #arr do\n    local value = arr[i]\n    if value %\
    \ 2 == 0 then\n      even_values[index] = value\n      index = index + 1\n   \
    \ end\n  end\n  if #even_values == 0 then\n    return nil\n  elseif #even_values\
    \ == 1 then\n    return even_values\n  else\n    local min_value, min_index\n\
    \    for i = 1, #even_values do\n      if even_values[i] < min_value then\n  \
    \      min_value = even_values[i]\n        min_index = i\n      end\n    end\n\
    \    return even_values[min_index]\n  end\nend", "    local evens = {}\n    local\
    \ smalest_value = arr[1]\n    local smalest_index = 1\n    for i = 2, #arr do\n\
    \        if arr[i] % 2 == 0 then\n            evens[arr[i]] = true\n         \
    \   if arr[i] < smalest_value then\n                smalest_value = arr[i]\n \
    \               smalest_index = i\n            end\n        end\n    end\n   \
    \ if #evens == 0 then\n        return nil\n    end\n    return smalest_value,\
    \ smalest_index\nend", "    local even_index_arr = {}\n    local max_index = 0\n\
    \    for i = 1,#arr do\n        if arr[i] % 2 == 0 then\n            even_index_arr[i]\
    \ = arr[i]\n            if max_index == 0 then\n                max_index = i\n\
    \            else\n                if even_index_arr[max_index] ~= 0 then\n  \
    \                  max_index = i\n                end\n            end\n     \
    \   end\n    end\n    return even_index_arr[max_index]\nend", "    local index_of_smallest_value\n\
    \    local even_values = {}\n    for _, node in ipairs(arr) do\n        if node:isEven()\
    \ then\n            even_values[#even_values + 1] = {value = node, index = #even_values}\n\
    \        end\n    end\n    if #even_values == 0 then return nil end\n    index_of_smallest_value\
    \ = #even_values\n    while #even_values > 0 do\n        index_of_smallest_value\
    \ = index_of_smallest_value\n        local smallest_value = even_values[index_of_smallest_value].value\n\
    \        local smallest_index = even_values[index_of_smallest_value].index\n \
    \       for _, node in ipairs(arr) do\n            if node:isEven() then\n   \
    \             if smallest_value < node then\n                    smallest_value\
    \ = node\n                    smallest_index = #even_values + 1\n            \
    \    end\n                index_of_smallest_value = index_of_smallest_value -\
    \ 1 \n            end\n        end\n    end\n    return smallest_value, smallest_index\n\
    end", "    local smalest_index = 0 \n    local smalest_value = arr[1]\n    local\
    \ results = {}\n    for i=2, #arr do\n        if arr[i] ~= smalest_value and arr[i]\
    \ % 2 == 0 then\n            smalest_value = arr[i]\n            smalest_index\
    \ = i\n        end\n    end\n    if #results == 0 and smalest_value % 2 == 0 then\
    \ return nil end\n    if smalest_value % 2 ~= 0 then\n        results[1] = smalest_value\
    \ \n    end\n    return results[#results]\nend", '    if not arr then return nil
    end', "    local i = 1\n    local maxi\n    maxi = math.min(nth_value(arr), nth_value(arr))\n\
    \    local mini\n    mini = math.max(nth_value(arr), nth_value(arr))\n    while\
    \ i <= arr.length and arr[i] <= maxi and arr[i] >= mini do\n        if arr[i]\
    \ % 2 == 0 then\n            if arr[i] > maxi then\n                maxi = arr[i]\n\
    \            end\n            if arr[i] < mini then\n                mini = arr[i]\n\
    \            end\n        end\n        i = i + 1\n    end\n    if i == arr.length\
    \ then\n        if arr[1] % 2 == 0 then\n            if arr[1] > maxi then\n \
    \               maxi = arr[1]\n            end\n            if arr[1] < mini then\n\
    \                mini = arr[1]\n            end\n        end\n    end\n    if\
    \ maxi == mini then\n        return nil\n    end\n    local val\n    if maxi ~=\
    \ 0 then\n        val = maxi\n    else\n        val = mini\n    end\n    local\
    \ list\n    local pos\n    if val % 2 == 0 then\n        pos = 1\n    else\n \
    \       pos = 0\n    end\n    if arr[pos] % 2 == 0 then\n        pos = pos + 1\n\
    \    end\n    if arr[pos] ~= 0 then\n        list[list#list+1] = arr[pos]\n  \
    \  end\n    return list\nend", "  local map = {}\n  local i = 0\n  for _ in arr\
    \ do\n    if map[#map] + 1 >= i then\n      map[map[#map] + 1] = i + 1\n    end\n\
    \    map[#map] += 1\n    i = i + 1\n  end\n  return map[#map]\nend", "    local\
    \ function even(a)\n        return a % 2 == 0\n    end\n    local function index(arr,\
    \ key)\n        local n = 0\n        for _,v in ipairs(arr) do\n            if\
    \ v == key then\n                n = n + 1\n            end\n        end\n   \
    \     return n\n    end\n    local function minIndex(arr)\n        local n = 0\n\
    \        for _,v in ipairs(arr) do\n            if even(v) then\n            \
    \    n = n + 1\n            end\n        end\n        return n\n    end\n    if\
    \ #arr == 1 then\n        return arr[1]\n    end\n    local min = min(arr)\n \
    \   local idx\n    if even(min) then\n        idx = index(arr, min)\n    else\n\
    \        idx = minIndex(arr)\n    end\n    return arr[idx], idx\nend", "  -- Write\
    \ your code here.\n  return arr\nend", "    if #arr == 0 then\n        return\
    \ {}\n    end\n    local smallestValue, index, smallestIndex = Inf, -1, -1\n \
    \   for index, value in ipairs(arr) do\n        if value % 2 == 0 then\n     \
    \       if value < smallestValue then\n                smallestValue, smallestIndex\
    \ = value, index\n            else\n                smallestValue, smallestIndex\
    \ = smallestValue, index\n            end\n        end\n    end\n    if smallestValue\
    \ == 0 then\n        return {}\n    end\n    return { smallestValue, smallestIndex\
    \ }\nend", "  local index = 1\n  local result = {arr[1]}\n  local min_index =\
    \ 1", '  if arr == nil then return nil end', "    local function get_smallest_even_index(arr)\
    \ \n        local sorted_array = {}\n        for i = #arr, 1, -1 do\n        \
    \    local val = arr[i]\n            if val % 2 == 0 then\n                table.insert(sorted_array,\
    \ val)\n            end\n        end\n        if #sorted_array == 0 then\n   \
    \         return nil\n        end\n        local smallest = sorted_array[1]\n\
    \        local smallest_index = #sorted_array - 1\n        for i = 2, #sorted_array\
    \ do\n            local val = sorted_array[i]\n            if val ~= smallest\
    \ and val % 2 == 0 then\n                smallest_index = i\n                smallest\
    \ = val\n            end\n        end\n        return smallest, smallest_index\n\
    \    end\n    local smallest_even_val = nil\n    local smallest_even_index = nil\n\
    \    local smallest_index = nil\n    for i = 1, #arr do\n        if arr[i] % 2\
    \ == 0 then\n            smallest_even_val = arr[i]\n            smallest_even_index\
    \ = i\n        end\n    end\n    if smallest_even_val ~= nil then\n        smallest_index,\
    \ smallest_even_val = get_smallest_even_index(arr) \n    end\n    if smallest_index\
    \ ~= nil then\n        local idx = 1\n        local val_to_remove = nil\n    \
    \    for i = 1, smallest_index do\n            if arr[i] == smallest_even_val\
    \ then\n                val_to_remove = arr[i]\n                break\n      \
    \      end\n            idx = idx + 1\n        end\n        if val_to_remove ==\
    \ nil then\n            return nil\n        end\n        if arr[idx] > smallest_even_val\
    \ then\n            arr[idx] = smallest_even_val\n            arr[idx+smallest_even_index]\
    \ = val_to_remove\n        end\n    end\n    return arr\nend", "    local sorted_arr\
    \ = table.sort(arr)\n    local smalest_value = sorted_arr[1]\n    local smalest_index\
    \ = 1\n    for i = 2, #sorted_arr do\n        if sorted_arr[i] < smalest_value\
    \ then\n            smalest_value = sorted_arr[i]\n            smalest_index =\
    \ i\n        end\n    end\n    return smalest_value, smalest_index\nend", "\t\
    local pluck_map = {}\n\tlocal result\n\tfor i=1, #arr do\n\t\tlocal key = arr[i]\n\
    \t\tif pluck_map[key] == nil then\n\t\t\tpluck_map[key] = i\n\t\telseif i == #arr\
    \ then\n\t\t\tresult = pluck_map[key]\n\t\t\tbreak\n\t\telseif arr[i] < pluck_map[key]\
    \ then\n\t\t\tresult = pluck_map[key]\n\t\t\tbreak\n\t\tend\n\tend\n\treturn result\n\
    end", "    local pick = {}\n    for i, v in ipairs(arr) do\n        if v % 2 ==\
    \ 0 then\n            pick[i] = v\n        end\n    end\n    if #pick == 0 then\n\
    \        return nil\n    else\n        table.sort(pick)\n        local pick_val\
    \ = pick[1]\n        local pick_idx = 1\n        for i = 2, #pick do\n       \
    \     if pick[i] == pick_val * 2 then\n                pick_idx = i\n        \
    \        break\n            end\n        end\n        return pick_val, pick_idx\n\
    \    end\nend", "    if #arr == 0 then return [] end\n    local arr_size = #arr\n\
    \    local min_value = arr[arr_size]\n    local min_value_count = 0\n    local\
    \ max_value = 0\n    local max_value_count = 0\n    for i = 1, arr_size, 1 do\n\
    \        local value = arr[i]\n        if value == min_value then\n          \
    \  min_value_count = min_value_count + 1\n        elseif value == max_value then\n\
    \            max_value_count = max_value_count + 1\n        else\n           \
    \ if min_value_count > max_value_count then\n                max_value = value\n\
    \                max_value_count = min_value_count\n            else\n       \
    \         if min_value_count < max_value_count then\n                    min_value\
    \ = value\n                    min_value_count = min_value_count\n           \
    \     else\n                    max_value = value\n                    max_value_count\
    \ = max_value_count\n                end\n            end\n        end\n    end\n\
    \    return [min_value, max_value_count]\nend", "   -- Pick the first even value\
    \ from the given array.\n   local smalest_value = arr[1]\n   local smalest_index\
    \ = 1\n   for i = 2, #arr do\n      if arr[i] % 2 == 0 then\n         local smalest_index_temp\
    \ = smalest_index\n         local smalest_value_temp = smalest_value\n       \
    \  local temp_val = arr[i]\n         smalest_index = i\n         smalest_value\
    \ = temp_val\n      else\n         smalest_index = smalest_index_temp\n      \
    \   smalest_value = smalest_value_temp\n      end\n   end", "    local arr_size\
    \ = #arr\n    local result = {}\n    local index = 1\n    local picked_node\n\
    \    local smallest_even_val\n    local smallest_even_val_i\n    \n    -- Loop\
    \ through array backwards\n    for i = arr_size:-1:1 do\n        picked_node =\
    \ arr[i]\n        smallest_even_val = picked_node % 2 == 0 and picked_node or\
    \ nil\n        smallest_even_val_i = i\n    end\n    \n    -- Return the smallest\
    \ even number if there are two or more with same minimum value\n    if smallest_even_val\
    \ == nil or smallest_even_val_i == 0 then\n        return nil\n    end\n    \n\
    \    -- If there is only one value with minimum even value, return it\n    if\
    \ smallest_even_val_i == 1 then\n        return {smallest_even_val, index}\n \
    \   end\n    \n    -- If there is more than one value with minimum even value,\
    \ return the smallest one\n    if smallest_even_val_i > 1 then\n        if smallest_even_val\
    \ < arr[smallest_even_val_i] then\n            smallest_even_val = arr[smallest_even_val_i]\n\
    \            index = smallest_even_val_i\n        end\n    end\n    \n    -- If\
    \ there are no even number or given array is empty, return nil\n    if smallest_even_val\
    \ == nil or smallest_even_val_i == arr_size then\n        return nil\n    end\n\
    \    \n    -- Put the value and its index into the result array \n    table.insert(result,\
    \ smallest_even_val)\n    table.insert(result, index)\n    \n    -- Return the\
    \ result array\n    return result\nend", "    local smalest_value = math.inf\n\
    \    local smalest_index = 0\n    for i = 1, #arr do\n        if arr[i] > smalest_value\
    \ then\n            smalest_value = arr[i]\n            smalest_index = i\n  \
    \      end\n    end\n    if smalest_value == math.inf then return nil end\n  \
    \  if smalest_index ~= 1 then\n        local index = smalest_index\n        local\
    \ pick = arr[index]\n        while pick % 2 == 0 do\n            index = index\
    \ - 1\n            pick = arr[index]\n        end\n        return pick, index\n\
    \    end\n    return nil\nend", "    local function helper(arr, index, picked)\n\
    \        if picked > 0 then\n            return helper(arr, picked, picked)\n\
    \        end\n        if index == 0 or picked == 0 then\n            return picked\n\
    \        end\n        if picked == 1 then\n            return picked - 1\n   \
    \     end\n        if picked % 2 == 0 then\n            return helper(arr, index\
    \ + 1, picked + 1)\n        end\n        return helper(arr, index + 1, picked\
    \ - 1)\n    end\n    return helper(arr, 0, 0)\nend", "    local maxValue, maxIndex,\
    \ nodes = {}, {}, {}\n    for i,node in ipairs(arr) do\n        if node.even ==\
    \ true then\n            if node.value < maxValue then\n                maxValue,\
    \ maxIndex = node.value, i\n            else\n                maxValue, maxIndex\
    \ = node.value, i\n            end\n        else\n            table.insert(nodes,\
    \ node.value)\n        end\n    end\n    if #nodes > 0 then\n        local index\
    \ = 0\n        for i,node in ipairs(nodes) do\n            if node.even == true\
    \ then\n                if node.value == maxValue then\n                    index\
    \ = i\n                    break\n                end\n            end\n     \
    \   end\n        if index == 0 then\n            local index = 2\n           \
    \ for i,node in ipairs(nodes) do\n                if node.even == true then\n\
    \                    if node.value == maxValue then\n                        index\
    \ = i\n                        break\n                    end\n              \
    \  end\n            end\n        end\n    end\n    return maxValue, index, maxIndex\n\
    end", "  local smaller, smaller_idx = nil, nil -- local variable\n  local current_smaller,\
    \ current_smaller_idx = nil, nil -- local variable\n  for i, x in ipairs(arr)\
    \ do -- iterating over arr\n    if x % 2 == 0 then -- if x is even\n      if current_smaller\
    \ and x < current_smaller then\n        current_smaller, current_smaller_idx =\
    \ x, i -- setting current smaller value & index\n      else\n        current_smaller\
    \ = x -- setting current smaller value\n        current_smaller_idx = i -- setting\
    \ current smaller index\n      end\n    else -- if x is not even\n      if current_smaller\
    \ then\n        smaller, smaller_idx = current_smaller, current_smaller_idx --\
    \ setting smaller value\n      else\n        smaller = x -- setting smaller value\n\
    \      end\n    end\n  end", "    local smalest_value = arr[1]\n    local smalest_index\
    \ = 1\n    local i = 2\n    while i < #arr do\n        if arr[i] % 2 == 0 and\
    \ arr[i] <= smalest_value then\n            smalest_value = arr[i]\n         \
    \   smalest_index = i\n        end\n        i = i + 1\n    end\n    if smalest_value\
    \ ~= arr[i] then\n        return nil\n    end\n    return smalest_value, smalest_index\n\
    end", "  local min = arr[1]\n  local idx = 1\n  for i = 2, #arr do\n    local\
    \ v = arr[i]\n    if v < min then\n      min = v\n      idx = i\n    end\n  end\n\
    \  return { min = min, idx = idx }\nend", "    local function inc(arr,index,val)\n\
    \        if index == #arr then\n            return arr\n        end\n        if\
    \ arr[index] == val then\n            return inc(arr,index+1,val)\n        else\n\
    \            return inc(arr,index+1,val)\n        end\n    end", "    local i,\
    \ largest, smallest, index = 0, 0, nil, 0\n    for _, value in ipairs(arr) do\n\
    \        if value == 0 then \n            if index == 0 then smallest = value\
    \ \n            else if smallest < value then smallest, index = value, 0 end\n\
    \        else if value == smallest then\n            if index == 0 then largest\
    \ = value \n            else if largest > value then largest, index = value, index\
    \ end\n        else\n            index = index + 1\n        end\n    end\n   \
    \ if smallest == 0 then return [] end\n    if largest == 0 then return [smallest,\
    \ index] end\n    return [ smallest, index, largest, arr[largest] ]\nend", " \
    \  local even_values, index, value\n   local even_values = Set{}\n   local index\
    \ = {}\n   for i, v in ipairs(arr) do\n      if v % 2 = 0 then\n         table.insert(even_values,\
    \ v)\n         table.insert(index, i)\n      end\n   end\n   if #even_values ==\
    \ 0 then return nil end\n   local smallest_value, smallest_index = math.min(even_values),\
    \ 1\n   for i = #even_values, 1, -1 do\n      if even_values[i] < smallest_value\
    \ then\n         smallest_value = even_values[i]\n         smallest_index = i\n\
    \      end\n   end\n   \n   return { smallest_value, smallest_index, index }\n\
    end", "  -- base case\n  if #arr == 0 then return [] end", "\tlocal min = nil\n\
    \tlocal index = 0\n\tfor i=1, #arr do\n\t\tif arr[i] % 2 == 0 then\n\t\t\tif min\
    \ == nil then\n\t\t\t\tmin = arr[i]\n\t\t\t\tindex = i\n\t\t\telseif min > arr[i]\
    \ then\n\t\t\t\tmin = arr[i]\n\t\t\t\tindex = i\n\t\t\tend\n\t\tend\n\tend\n\t\
    if min == nil then\n\t\treturn nil\n\telse\n\t\treturn { min = min, index = index\
    \ }\n\tend\nend", "    if arr == nil then\n        return nil\n    end", "  if\
    \ #arr == 0 then\n    return nil\n  end\n  local small_even, smallest_idx = 0,\
    \ 1\n  for _, v in ipairs(arr) do\n    if v then\n      small_even = small_even\
    \ + 1\n      if small_even > 1 then\n        if v % 2 == 0 then\n          smallest_idx\
    \ = smallest_idx + 1\n        else\n          small_even = 1\n          smallest_idx\
    \ = v\n        end\n      else\n        small_even = 1\n        smallest_idx =\
    \ v\n      end\n    end\n  end\n  return smallest_idx\nend", "    local smalest_value\
    \ = 0\n    local smalest_index = 0\n    local even_value_index\n    for index\
    \ = 1, #arr do\n        if arr[index] % 2 == 0 then\n            if smalest_value\
    \ == 0 then\n                smalest_value = arr[index]\n                smalest_index\
    \ = index\n            else\n                if arr[index] < smalest_value then\n\
    \                    smalest_value = arr[index]\n                    smalest_index\
    \ = index\n                end\n            end\n        else\n            if\
    \ smalest_value == 0 then\n                even_value_index = index\n        \
    \    else\n                if arr[index] < smalest_value then\n              \
    \      smalest_value = arr[index]\n                    smalest_index = index\n\
    \                end\n            end\n        end\n    end\n    if smalest_value\
    \ == 0 then\n        return nil\n    end\n    return smalest_value, smalest_index\n\
    end", "   local pivot, ans, index, value, smalest_value\n   if #arr < 1 then return\
    \ nil\n   if #arr == 1 then return arr \n   pivot = arr[1]\n   ans = {}\n   index\
    \ = nil\n   value = nil\n   smalest_value = pivot % 2\n   for i = 1, #arr do\n\
    \       if arr[i] % 2 == 0 then\n           if value == nil then\n           \
    \    if pivot < arr[i] then\n                   value = pivot \n             \
    \      index = i\n               else\n                   value = arr[i]\n   \
    \                index = i\n               end\n           elseif value < pivot\
    \ then\n               if pivot < arr[i] then\n                   value = pivot\
    \ \n                   index = i\n               else\n                   value\
    \ = arr[i]\n                   index = i\n               end\n           else\n\
    \               if pivot > arr[i] then\n                   value = pivot \n  \
    \                 index = i\n               else\n                   value = arr[i]\n\
    \                   index = i\n               end\n           end\n          \
    \ if smalest_value < value then\n               smalest_value = value\n      \
    \     end\n       end\n       if value == pivot then\n           if smalest_value\
    \ < pivot then\n               if pivot < arr[index] then\n                  \
    \ value = pivot \n                   index = index\n               else\n    \
    \               value = arr[index]\n                   index = index\n       \
    \        end\n           elseif pivot < arr[index] then\n               if pivot\
    \ < arr[index] then\n                   value = pivot \n                   index\
    \ = index\n               else\n                   value = arr[index]\n      \
    \             index = index\n               end\n           end\n       end\n\
    \       if value == smalest_value then\n           if index == nil then\n    \
    \           ans[index] = arr[index]\n           else\n               if arr[index]\
    \ < arr[index] then\n                   ans[index] = arr[index]\n            \
    \   else\n                   ans[index] = arr[index] \n               end\n  \
    \         end\n       end\n   end\n   return ans\nend", "  local small_value_index\
    \ = nil\n  local small_value = nil", "    local result = {}\n    for i=1,#arr\
    \ do\n        local index = i\n        local value = arr[i]\n        for j=1,#arr\
    \ do\n            if arr[j] == value and (j < i or index > j) then\n         \
    \       index = j\n                value = arr[j]\n            end\n        end\n\
    \        if index == 1 then\n            result[#result+1] = arr[index]\n    \
    \    else\n            if value < arr[index] then\n                result[#result+1]\
    \ = arr[index]\n            else\n                if value < result[#result] then\n\
    \                    result[#result+1] = arr[index]\n                else\n  \
    \                  local tmp = result[#result]\n                    result[#result+1]\
    \ = arr[index]\n                    arr[tmp] = arr[index] \n                end\n\
    \            end\n        end\n    end\n    if #result > 1 then\n        if result[#result]\
    \ == result[1] then\n            local tmp = result[#result]\n            result[#result]\
    \ = result[1]\n            result[1] = tmp\n        end\n    end\n    return result\n\
    end", "    local min_index = 0\n    local min = arr[1]\n    for i = 2, #arr do\n\
    \        if arr[i] < min then\n            min = arr[i]\n            min_index\
    \ = i\n        end\n    end\n    return min, min_index\nend", "  local sorted_arr\
    \ = table.sort(arr)\n  local min_index = 1\n  local min_value = sorted_arr[1]\n\
    \  local min_value = sorted_arr[1]\n  local results = {}\n  for i = 2, #sorted_arr\
    \ do\n    local value = sorted_arr[i]\n    if value == min_value then\n      table.insert(results,\
    \ value)\n    elseif value == 0 then\n      local index = min_index\n      for\
    \ j = 1, i do\n        if arr[j] ~= 0 then\n          index = j\n        end\n\
    \      end\n      table.insert(results, arr[index])\n      min_index = min_index\
    \ + 1\n    elseif value > 0 then\n      local index = min_index\n      for j =\
    \ 1, i do\n        if arr[j] ~= 0 then\n          index = j\n        end\n   \
    \   end\n      table.insert(results, arr[index])\n      min_index = min_index\
    \ + 1\n    end\n  end\n  if #results == 0 then\n    return nil\n  end\n  return\
    \ results\nend", "   if #arr == 0 then\n      return nil\n   end\n   if #arr ==\
    \ 1 then\n      return arr[0]\n   end\n   local head_index = math.min(#arr, 1)\n\
    \   local head_val = arr[1]\n   local pivot_index = head_index\n   local pivot_val\
    \ = head_val\n   local pivot_node = nil\n   local smallest_index = nil\n   local\
    \ smallest_value = nil\n   local index_of_smallest_value = nil\n   for index =\
    \ 2, head_index do\n      if pivot_val == head_val then\n         if smallest_value\
    \ == nil then\n            smallest_value = pivot_val\n            smallest_index\
    \ = pivot_index\n         elseif pivot_val < smallest_value then\n           \
    \ smallest_value = pivot_val\n            smallest_index = pivot_index\n     \
    \    end\n      elseif pivot_val < head_val then\n         pivot_val = head_val\n\
    \         pivot_index = index\n         pivot_node = arr[index]\n      else\n\
    \         pivot_val = head_val\n         pivot_index = index\n         pivot_node\
    \ = arr[index]\n      end\n   end\n   return [ smallest_value, smallest_index\
    \ ]\nend", "    if #arr == 0 then return end\n    if arr[1] == 0 then\n      \
    \  return arr\n    end\n    local smalest_value = arr[1]\n    local smalest_index\
    \ = 2\n    for i = 2, #arr do\n        if arr[i] == 0 then\n            if smalest_value\
    \ < arr[i] then\n                smalest_value = arr[i]\n                smalest_index\
    \ = i\n            end\n        end\n    end\n    return arr[smalest_index]\n\
    end", "\tlocal index = 0\n\tlocal smalest_value = 0\n\tlocal even_value = 0\n\t\
    local smalest_index = 1\n\tlocal even_index = 1\n\tlocal smallest_value_index\n\
    \tlocal smallest_value\n\tlocal tmp\n\tlocal result\n\tfor index, value in pairs(arr)\
    \ do\n\t\ttmp = value % 2\n\t\tif tmp == 0 then\n\t\t\teven_value = even_value*10\
    \ + value\n\t\telse\n\t\t\tsmalest_value = smalest_value*10 + value\n\t\tend\n\
    \t\tif smalest_value < even then\n\t\t\tsmalest_index = smalest_index + 1\n\t\t\
    elseif even < smalest_value then\n\t\t\teven_index = even_index + 1\n\t\telseif\
    \ smalest_value == even then\n\t\t\tif smalest_index > even_index then\n\t\t\t\
    \tsmallest_value = smalest_value\n\t\t\t\tsmallest_value_index = smalest_index\n\
    \t\t\telseif even_index > smalest_index then\n\t\t\t\tsmallest_value = even_value\n\
    \t\t\t\tsmallest_value_index = even_index\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ smallest_value_index, smallest_value, result\nend", "  -- Your code here\n \
    \ local result={}\n  local min_val=#arr\n  local min_val_pos=-1\n  local index_list={}\n\
    \  for i=1,#arr do\n    if arr[i]%2==0 then\n      if min_val>arr[i] then\n  \
    \      min_val=arr[i]\n        min_val_pos=i\n      end\n      if min_val==arr[i]\
    \ and i==min_val_pos then \n        index_list[i]=i\n      end\n    end\n  end\n\
    \  if min_val==#arr and min_val_pos==0 then\n      return{0,arr}\n  else\n   \
    \ if min_val==#arr and min_val_pos~=0 then\n      result[1]=arr[min_val_pos]\n\
    \      return{min_val,index_list}\n    end\n    if min_val>#arr then\n      return{-1,index_list}\n\
    \    end\n    for i=2,min_val do\n      result[i]=arr[index_list[i]]\n    end\n\
    \    return{min_val,index_list}\n  end\nend\nprint (pluck([4,2,3]))\nprint (pluck([1,2,3]))\n\
    print (pluck([]))\nprint (pluck([5, 0, 3, 0, 4, 2]))\nprint (pluck([4,2,3,5]))",
  "  -- initialize result\n  local ans = nil\n  -- find the smallest even value and\
    \ its index\n  for index, value in ipairs(arr) do\n    if value and value % 2\
    \ == 0 then\n      local even = math.floor(value/2) + 1\n      if not ans then\n\
    \        ans = {value, index}\n      elseif even == ans[1].even then\n       \
    \ ans[1].even = even\n        ans[1].index = index\n      else\n        ans =\
    \ {value, index}\n      end\n    end\n  end\n  -- return an array of the plucked\
    \ values and their index\n  return ans\nend", "   local arr_size = #arr\n   assert(arr_size\
    \ > 0, 'Empty list')\n   if arr_size <= 0 then\n      return []\n   end\n   local\
    \ even_values = {}\n   local i = 1\n   while i <= arr_size do\n      if i % 2\
    \ == 0 then\n         even_values[i] = arr[i]\n      end\n      i = i + 1\n  \
    \ end\n   if #even_values == 0 then\n      return nil\n   end\n   local min_value\
    \ = min(even_values)\n   local min_key\n   local min_index\n   for i, v in ipairs(even_values)\
    \ do\n      if v == min_value then\n         min_key = i\n         min_index =\
    \ i\n      end\n   end\n   if min_key == nil then\n      return nil\n   end\n\
    \   return { value = min_value, index = min_key }\nend\n</cell>\n<text>\nTest\
    \ Cases", "  -- Your code here\nend", "    local stack = Stack()\n    local results\
    \ = {}\n    for i = 1, #arr do\n        local node = arr[i]\n        if node%2\
    \ == 0 then\n            local idx = #results\n            stack:push(i)\n   \
    \         stack:push(idx)\n            results[idx] = node\n        end\n    end",
  "  local nodes = {}\n  for i = 1, #arr do\n    local n = arr[i]\n    local v = math.floor(n)\n\
    \    table.insert(nodes, v)\n  end\n  local min_idx = nil\n  local min_value =\
    \ nil\n  table.sort(nodes)\n  for _, v in ipairs(nodes) do\n    if min_value ==\
    \ nil or v < min_value then\n      min_value = v\n      min_idx = v\n    end\n\
    \  end\n  local new_arr = {min_value, min_idx}\n  return new_arr\nend", "    local\
    \ sorted_arr = table.sort(arr)\n    local index_arr = {}\n    local min_value\
    \ = sorted_arr[1]\n    local min_idx = 1\n    for i=1,#sorted_arr do\n       \
    \ if min_value == sorted_arr[i] then\n            index_arr[#index_arr + 1] =\
    \ i\n        elseif min_value < sorted_arr[i] then\n            min_value = sorted_arr[i]\n\
    \            min_idx = 1\n            index_arr[#index_arr + 1] = i\n        else\n\
    \            index_arr[#index_arr + 1] = i\n        end\n    end\n    if #index_arr\
    \ <= 1 then return [] end\n    if index_arr[#index_arr] % 2 == 0 then\n      \
    \  return { min_value, index_arr[#index_arr] }\n    else\n        local i = 1\n\
    \        while i < #index_arr do\n            if index_arr[i] % 2 == 0 then\n\
    \                return { index_arr[i - 1], i }\n            end\n           \
    \ i = i + 1\n        end\n    end\nend\n</cell>\n<code language=julia-0.6>", " \
    \  local smallest, smallest_index, picked= {}, {}, {}\n   for i = 1, #arr do\n\
    \      local n = arr[i]\n      if n then\n         if smallest[math.floor(n/2)]==nil\
    \ then\n            smallest[math.floor(n/2)] = n\n            smallest_index[math.floor(n/2)]\
    \ = i\n         else\n            if n < smallest[math.floor(n/2)] then\n    \
    \           smallest[math.floor(n/2)] = n\n               smallest_index[math.floor(n/2)]\
    \ = i\n            end\n         end\n      end\n   end\n   if #smallest == 0\
    \ then\n      return nil\n   end\n   local n = 1\n   while smallest[n] do\n  \
    \    n = n+1\n   end\n   local n1 = smallest[1]\n   picked[1] = smallest_index[n1]\n\
    \   local n2 = smallest[n]\n   while n2 do\n      if smallest[n2] > n1 then\n\
    \         picked[2] = smallest_index[n2]\n      end\n      n2 = n2+1\n   end\n\
    \   return picked\nend\n</cell>\n<text>\nGiven an array representing a branch\
    \ of a tree that has non-negative integer nodes, your task is to pluck one of\
    \ the nodes and return it. The plucked node should be the node with the smallest\
    \ odd value.", "    local smalest_values = {}\n    local smalest_value = nil\n\
    \    local smalest_index = nil\n    for i = 0, #arr - 1 do\n        if arr[i]\
    \ > 0 then\n            if smalest_value == nil then\n                smalest_value\
    \ = arr[i]\n                smalest_index = i\n            elseif smalest_value\
    \ < arr[i] then\n                smalest_value = arr[i]\n                smalest_index\
    \ = i\n            end\n        end\n    end\n    return smalest_value, smalest_index\n\
    end", "  -- Write your code here.\n  assert(arr ~= nil)\n  assert(type(arr) ==\
    \ \"table\")\n  local ans, index, min_value", "    return arr[1]\nend", "    if\
    \ #arr == 0 then\n        return nil\n    end", "   local ans={}\n   local smalest_value=0\n\
    \   local smallest_index=0\n   local smallest_value\n   local i\n   for i,v in\
    \ ipairs(arr) do\n      if smallest_value and smallest_value<v then\n        \
    \ smallest_value=v\n         smallest_index=i\n      end\n      if v%2==0 then\n\
    \         if smallest_value and smalest_value<v then\n            smalest_value=v\n\
    \            smallest_index=i\n         end\n      else\n         if smallest_value\
    \ then\n            table.insert(ans, smallest_value, smallest_index)\n      \
    \      smallest_value=v\n            smallest_index=i\n         end\n      end\n\
    \   end\n   if smallest_value then\n      table.insert(ans, smallest_value, smallest_index)\n\
    \   end\n   return ans\nend", "    if arr == nil then\n        return nil\n  \
    \  end\n    local largest, index = nil, -1\n    for i=1,#arr do\n        local\
    \ element = arr[i]\n        if largest~= nil and largest.value < element then\n\
    \            index = i\n        end\n        if element%2 == 0 then\n        \
    \    largest = element\n        end\n    end\n    if largest~= nil and largest.value\
    \ == 0 then\n        index = index\n    end\n    if index == -1 then\n       \
    \ index = #arr\n    end\n    largest.index = index\n    return largest\nend",
  "    local even={}\n    for i=1,#arr do\n        if arr[i]%2==0 then\n         \
    \   even[#even+1]=arr[i]\n        end\n    end\n    local smallest_value=nil\n\
    \    local smallest_index=0\n    for i=1,#even do\n        if smallest_value and\
    \ even[i] > smallest_value then\n            smallest_index=i\n            smallest_value=even[i]\n\
    \        elseif even[i] < smallest_value then\n            smallest_index=i\n\
    \            smallest_value=even[i]\n        end\n    end\n    if smallest_value\
    \ then\n        return {smallest_value, smallest_index}\n    end\n    return {}\n\
    end", "\tlocal evens, index, smallest, results = {}, {}, {}, {}\n\tfor i, v in\
    \ ipairs(arr) do\n\t\tif v % 2 == 0 then\n\t\t\ttable.insert(evens, v)\n\t\telse\n\
    \t\t\tlocal index = #evens\n\t\t\tlocal v = evens[#evens]\n\t\t\ttable.insert(results,\
    \ v)\n\t\t\ttable.insert(results, index)\n\t\t\ttable.insert(results, 0)\n\t\t\
    \ttable.insert(evens, 0)\n\t\tend\n\tend\n\t\n\tfor i, v in ipairs(evens) do\n\
    \t\tif #results == 1 then\n\t\t\tsmallest = v\n\t\t\tindex = #results + 1\n\t\t\
    else\n\t\t\tif v < smallest then\n\t\t\t\tsmallest = v\n\t\t\t\tindex = #results\
    \ + 1\n\t\t\telseif v == smallest and #results > 1 then\n\t\t\t\tindex = results[#results-1]\n\
    \t\t\tend\n\t\tend\n\tend\n\t\n\tif #evens == 0 then\n\t\tlocal v = 0\n\t\ttable.insert(results,\
    \ v)\n\t\ttable.insert(results, 0)\n\t\ttable.insert(results, 0)\n\t\treturn results\n\
    \telseif #evens == 1 then\n\t\tlocal v = evens[1]\n\t\ttable.insert(results, v)\n\
    \t\ttable.insert(results, 0)\n\t\treturn results\n\tend\n\t\n\treturn nil\nend",
  "    local min_index = nil\n    local max_even_node = nil\n    local smalest_value\
    \ = nil\n    for index, node in ipairs(arr) do\n        if node.value < max_even_node.value\
    \ and node.value % 2 == 0 then\n            -- Check if the current node has the\
    \ minimum even value\n            local current_even_value = node.value\n    \
    \        if current_even_value < smalest_value then\n                smalest_value\
    \ = current_even_value\n                min_index = index\n            end\n \
    \       end\n    end", "  -- Your code here\n  \n  local smalest_value\n  local\
    \ smalest_index\n  for i, v in ipairs(arr) do\n    if v % 2 == 0 and smalest_value\
    \ == nil then\n      smalest_value = v\n      smalest_index = i\n    elseif v\
    \ % 2 == 0 and v < smalest_value then\n      smalest_value = v\n      smalest_index\
    \ = i\n    end\n  end", "    local arr1 = {}\n    for i=1, #arr do\n        arr1[arr[i]]\
    \ = arr[i]\n    end", "    local smallest_value = arr[1]\n    local smallest_index\
    \ = 1\n    for i = 2, #arr do\n        local value = arr[i]\n        if value\
    \ < smallest_value then\n            smallest_value = value\n            smallest_index\
    \ = i\n        end\n    end\n    return smallest_value, smallest_index\nend",
  "\tlocal index = 1\n\tlocal min = math.infinity\n\tlocal val\n\tfor idx, val in\
    \ pairs(arr) do\n\t\tif val % 2 == 0 and val < min then\n\t\t\tmin = val\n\t\t\
    \tindex = idx\n\t\tend\n\tend\n\treturn {val, index}\nend", "  -- Base case: empty\
    \ array\n  if arr == nil or #arr == 0 then\n    return nil\n  end", "  return\
    \ arr:sort(function(a,b) return a-b end):first():second()\nend", "  local small,\
    \ smallest, index, min = nil, -1, -1, 0\n  for _, node in ipairs(arr) do\n   \
    \ if small == nil then\n      small = node\n    elseif node < small then\n   \
    \   small = node\n    elseif smallest==nil then\n      smallest = small\n    \
    \  index = index\n    else\n      if node % 2 == 0 then\n        if min > small\
    \ then\n          smallest = small\n          index = index\n        elseif node\
    \ < smallest then\n          smallest = node\n        end\n      else\n      \
    \  if node > smallest then\n          smallest = node\n          index = index\n\
    \        end\n      end\n    end\n  end\n  return smallest, index\nend", "  --\
    \ base case\n  if #arr < 2 then\n    return nil\n  end\n  -- start at 0, find\
    \ the smallest even value\n  local even_index = nil\n  local smalest_value = arr[1]\n\
    \  for _, value in ipairs(arr) do\n    if value % 2 == 0 then\n      if even_index\
    \ == nil or value < smalest_value then\n        smalest_value = value\n      \
    \  even_index = #arr\n      else\n        smalest_value = value\n        even_index\
    \ = nil\n      end\n    end\n  end\n  return [ smalest_value, even_index ]\nend",
  "\t-- Your code here\n\tlocal smalest_value = 0\n\tlocal smalest_index = 0\n\tfor\
    \ i = 1, #arr do\n\t\tif arr[i] % 2 == 0 then\n\t\t\tif smalest_value == 0 then\n\
    \t\t\t\tsmalest_value = arr[i]\n\t\t\t\tsmalest_index = i\n\t\t\telseif smalest_value\
    \ > arr[i] then\n\t\t\t\tsmalest_value = arr[i]\n\t\t\t\tsmalest_index = i\n\t\
    \t\tend\n\t\tend\n\tend\n\tif smalest_value == 0 then\n\t\treturn nil\n\tend\n\
    \treturn smalest_value, smalest_index\nend", "    return arr[1]\nend", "  -- Base\
    \ case\n  if #arr == 0 or #arr == 1 then\n    return arr[1]\n  end\n  -- Find\
    \ minimum even value\n  local min_value = arr[1]\n  local min_value = min_value\n\
    \  local min_idx = 0\n  for i = 2, #arr do\n    if arr[i] % 2 == 0 and arr[i]\
    \ < min_value then\n      min_value = arr[i]\n      min_idx = i\n    end\n  end\n\
    \  -- Update min_value\n  if min_value == arr[1] then\n    min_value = min_value\
    \ - 1\n  end\n  return min_value, min_idx\nend\nprint(pluck({2,1,3,5}))\nprint(pluck({2,1,3,5,4,6,7,8,9}))\n\
    print(pluck({2,1,3,5,4,6,7,8,9}))\nprint(pluck({0,1,2,3,4,5}))\nprint(pluck([]))\n\
    print(pluck({0,1,3,4,5}))\nprint(pluck({0,1,3,4,5}))\nprint(pluck({0,1,3,4,5}))\n\
    print(pluck({0,1,3,4,5}))\nprint(pluck({1,3,4,5}))\nprint(pluck({0,5,3,9,4,2,6,7}))\n\
    print(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\n\
    print(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\n\
    print(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\n\
    print(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\n\
    print(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\n\
    print(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\n\
    print(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,2,6,7}))\n\
    print(pluck({0,5,3,9,4,2,6,7}))\nprint(pluck({0,5,3,9,4,", "    local index =\
    \ math.random(1,#arr)\n    if arr[index] % 2 == 0 then\n        return arr[index]\n\
    \    end\n    local min = 0\n    local min_index\n    for i=1,#arr do\n      \
    \  if arr[i] % 2 == 0 and min ~= 0 then\n            min = math.min(min, arr[i])\n\
    \            min_index = i\n        end\n    end\n    if min == 0 then\n     \
    \   return nil\n    end\n    if min_index ~= index then\n        index = min_index\n\
    \    end\n    return arr[index]\nend", "    if arr == nil then\n        return\
    \ nil\n    end\n    local smallest,i\n    smallest = arr[1]\n    i = 2\n    while\
    \ i < (#arr) do\n        if arr[i] < smallest then\n            smallest = arr[i]\n\
    \        end\n        i = i + 1\n    end\n    if smallest == arr[1] then\n   \
    \     return smallest,1\n    else\n        if smallest == arr[1] then\n      \
    \      smallest,i = smallest,1\n            while i < (#arr) do\n            \
    \    if arr[i] < smallest then\n                    smallest = arr[i]\n      \
    \          end\n                i = i + 1\n            end\n            if smallest\
    \ == arr[1] then\n                smallest,i = smallest,1\n                while\
    \ i < (#arr) do\n                    if arr[i] < smallest then\n             \
    \           smallest = arr[i]\n                    end\n                    i\
    \ = i + 1\n                end\n            end\n        end\n        return smallest,i\n\
    \    end\nend", "\tlocal nodes = {}\n\tlocal small, index\n\tfor _,v in ipairs(arr)\
    \ do\n\t\tif v ~= 0 then\n\t\t\tif small == nil or small[1] < v then\n\t\t\t\t\
    small = { v, index }\n\t\t\telse\n\t\t\t\ttable.insert(nodes, small)\n\t\t\t\t\
    small = nil\n\t\t\tend\n\t\tend\n\tend\n\tif small ~= nil then\n\t\ttable.insert(nodes,\
    \ small)\n\tend\n\treturn nodes\nend", "    local m = {}\n    for i = 1, #arr\
    \ do\n        m[#m+1] = arr[i]\n    end\n    local min_index = math.max(#m)\n\
    \    local min_value = m[min_index]\n    if #m == 0 then\n        return nil\n\
    \    end\n    for i = 1, #m do\n        if m[i] % 2 == 0 then\n            if\
    \ m[i] < min_value then\n                min_value = m[i]\n                min_index\
    \ = i\n            end\n        end\n    end\n    return min_value, min_index\n\
    end", "    local results = {}\n    local min = nil\n    local min = math.min(arr)\n\
    \    for i, v in pairs(arr) do\n        if v == min then\n            results[i]\
    \ = true\n        end\n    end", "    if #arr == 0 then return [] end\n    local\
    \ results = {}\n    local i, min = 1, #arr\n    while i < min do\n        local\
    \ idx = math.floor( (i - 1) / 2 )\n        local value = arr[idx]\n        if\
    \ value < arr[i] then idx = i; value = arr[i]; end\n        if value == arr[i]\
    \ and (idx % 2 == 0) then\n            results.push( value )\n            i =\
    \ idx + 1\n        else\n            i = idx\n        end\n    end\n    return\
    \ results\nend", "    local arr = arr\n    local smallest_value_index\n    local\
    \ smallest_value\n    local index = 1\n    while true do\n        if arr[index]\
    \ <= 0 then\n            break\n        end", "    local function aux arr\n  \
    \  local smalest_value = nil\n    local index_of_smallest_even_value = nil\n \
    \   for _, v in ipairs(arr) do\n        local even = math.floor(v)\n        if\
    \ even > 0 then\n            if smalest_value == nil or even < smalest_value then\n\
    \                smalest_value = even\n                index_of_smallest_even_value\
    \ = v\n            else\n                index_of_smallest_even_value = v\n  \
    \          end\n        end\n    end\n    return index_of_smallest_even_value\n\
    end", "    if #arr < 2 then\n        return arr\n    end\n    local smallest_values\
    \ = {}\n    local smallest_value = nil\n    local smallest_index = nil\n    local\
    \ smallest_idx\n    for i = 1, #arr do\n        if arr[i] > 0 and smallest_value\
    \ == nil then\n            smallest_value = arr[i]\n            smallest_idx =\
    \ i\n            smallest_values = { smallest_value }\n        elseif arr[i] ==\
    \ smallest_value and smallest_index ~= nil then\n            smallest_values[i]\
    \ = arr[i]\n            smallest_idx = i\n        elseif arr[i] > 0 and smallest_index\
    \ ~= nil then\n            smallest_value = smallest_values[i]\n            smallest_idx\
    \ = i\n        end\n    end\n    if smallest_values ~= nil and smallest_idx ~=\
    \ nil then\n        smallest_values[smallest_idx] = smallest_value\n        return\
    \ smallest_values\n    else\n        return nil\n    end\nend\n</cell>\n<cell>",
  "   -- write your code here\n   if #arr == 0 then\n      return arr\n   end\n  \
    \ local minValues = {}\n   local minIndexes = {}\n   for i,v in ipairs(arr) do\n\
    \      local evenValue = v % 2 == 0\n      if minValues[evenValue] == nil then\n\
    \         minValues[evenValue] = v\n         minIndexes[evenValue] = i\n     \
    \ elseif minValues[evenValue] < v then\n         minValues[evenValue] = v\n  \
    \       minIndexes[evenValue] = i\n      end\n   end\n   if #minValues > 0 then\n\
    \      return minValues[minValues[1]],minIndexes[minValues[1]]\n   else\n    \
    \  return nil\n   end\nend", "    local arr2 = {}\n    local smallest_value =\
    \ math.max(1, arr[1])\n    local smallest_index_1\n    for i = 2, #arr do\n  \
    \      if arr[i] < smallest_value then\n            smallest_value = arr[i]\n\
    \            smallest_index_1 = i\n        end\n    end\n    arr2[smallest_index_1]\
    \ = smallest_value\n    return arr2\nend", "    local smalest_value, smalest_index\n\
    \    for i=1, #arr do\n        local val = arr[i]\n        if val % 2 == 0 then\n\
    \            if smalest_value == nil or smalest_value > val then\n           \
    \     smalest_value = val\n                smalest_index = i\n            end\n\
    \        end\n    end\n    return smalest_value, smalest_index\nend", "    local\
    \ min_value = math.floor(-Inf * 1/2)\n    local min_val = arr[1][1]\n    for i\
    \ = 2, #arr do\n        if arr[i][1] > min_val then\n            min_val = arr[i][1]\n\
    \        end\n    end\n    if min_value < min_val then\n        local new_min\
    \ = min_val\n        local new_min_idx = 1\n        for i = 2, #arr do\n     \
    \       if arr[i][1] > new_min then\n                new_min = arr[i][1]\n   \
    \             new_min_idx = i\n            end\n        end\n        return {\
    \ new_min, new_min_idx }\n    else\n        return arr\n    end\nend\n</cell>\n\
    <cell>\n%%time\nprint(pluck([[4, 5, 3, 1, 0], [4, 0, 2, 1, 3], [5, 0, 3, 1]])[1])\n\
    </cell>\n<cell>\n%%time\nprint(pluck([[4, 6, 1, 5, 9], [3, 7, 2, 3, 6], [2, 4,\
    \ 3, 9, 4]])[1])\n</cell>\n<cell>\n%%time\nprint(pluck([[4, 6, 1, 5, 9], [3, 7,\
    \ 2, 3, 6], [2, 4, 3, 9, 4]])[1])\n</cell>\n<cell>\n%%time\nprint(pluck([[4, 6,\
    \ 1, 5, 9], [3, 7, 2, 3, 6], [2, 4, 3, 9, 4]])[1])\n</cell>\n<cell>\n%%time\n\
    print(pluck([[4, 6, 1, 5, 9], [3, 7, 2, 3, 6], [2, 4, 3, 9, 4]])[1])\n</cell>\n\
    <cell>\n%%time\nprint(pluck([[4, 6, 1, 5, 9], [3, 7, 2, 3, 6], [2, 4, 3, 9, 4]])[1])\n\
    </cell>\n<cell>\n%%time\nprint(pluck([[4, 6, 1, 5, 9], [3, 7, 2, 3, 6], [2, 4,\
    \ 3, 9, 4]])[1])\n</cell>\n<cell>\n%%time\nprint(pluck([[4, 6, 1, 5, 9], [3, 7,\
    \ 2, 3, 6], [2, 4, 3, 9, 4]])[1])\n</cell>\n<cell>\n%%time\nprint(pluck([[4, 6,\
    \ 1, 5, 9], [3, 7, 2, 3, 6], [2, 4, 3, 9, 4]])[1])\n</cell>\n<cell>\n%%time\n\
    print(pluck([[4, 6, 1, 5, 9], [3, 7, 2, 3, 6], [2, 4, 3, 9, 4]])[1])\n</cell>\n\
    <cell>\n%%time\nprint(pluck([[4, 6, 1, 5, 9], [3, 7, 2, 3, 6], [2, 4, 3, 9, 4]])[1])\n\
    </cell>\n<cell>\n%%time\nprint(pluck([[4, 6, 1, 5, 9], [3, 7, 2, 3, 6], [2, 4,\
    \ 3, 9, 4]])[1])\n</cell>\n<cell>\n%%time\nprint(pluck([[4, ", "    local pivot\
    \ = arr[1]\n    local even = 1\n    for i = 2, #arr do\n        if arr[i] % 2\
    \ ~= 0 then\n            pivot = arr[i]\n            even = even+1\n        end\n\
    \    end\n    if even == 1 then\n        pivot = arr[1]\n    end\n    local index\
    \ = 1\n    local arr2 = {}\n    for i = 2, #arr do\n        if arr[i] % 2 ~= 0\
    \ then\n            arr2[index] = arr[i]\n            index = index+1\n      \
    \  end\n    end\n    arr2 = arr2[1]\n    arr2 = arr2%2\n    arr2 = arr2+1\n  \
    \  return pivot, arr2\nend", "    local function helper(arr, min_index, min_index)\n\
    \        local node = arr[min_index]\n        if node % 2 == 0 then\n        \
    \    if min_index == nil then\n                min_index = 1\n            else\n\
    \                min_index = min_index - 1\n            end\n            return\
    \ helper(arr, min_index, min_index)\n        else\n            if min_index ==\
    \ nil then\n                min_index = min_index + 1\n                return\
    \ helper(arr, min_index, min_index)\n            else\n                min_index\
    \ = min_index + 1\n                return helper(arr, min_index, min_index)\n\
    \            end\n        end\n    end\n    local min_index\n    local min_value\n\
    \    local min_index = nil\n    local min_value = nil\n    local result = helper(arr,\
    \ 1, 1)\n    if #result == 0 then\n        table.insert(result, nil)\n    end\n\
    \    if #result == 1 then\n        return result [1]\n    elseif #result == 2\
    \ then\n        return result\n    elseif #result == 4 then\n        local min_index\
    \ = result[1]\n        local min_value = result[2]\n        if min_value > min_value\
    \ then\n            table.insert(result, nil)\n        end\n        if min_index\
    \ > min_index then\n            table.insert(result, nil)\n        end\n     \
    \   return result\n    else\n        table.insert(result, nil)\n        return\
    \ result\n    end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
