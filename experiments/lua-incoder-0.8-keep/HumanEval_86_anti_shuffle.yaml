name: HumanEval_86_anti_shuffle
language: lua
prompt: "-- Write a function that takes a string and returns an ordered version of\
  \ it.\n-- Ordered version of string, is a string where all words (separated by space)\n\
  -- are replaced by a new word where all the characters arranged in\n-- ascending\
  \ order based on ascii value.\n-- Note: You should keep the order of words and blank\
  \ spaces in the sentence.\n-- For example:\n-- anti_shuffle('Hi') returns 'Hi'\n\
  -- anti_shuffle('hello') returns 'ehllo'\n-- anti_shuffle('Hello World!!!') returns\
  \ 'Hello !!!Wdlor'\nlocal function anti_shuffle(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = anti_shuffle\n\
  \    lu.assertEquals(candidate('Hi'), 'Hi')\n    lu.assertEquals(candidate('hello'),\
  \ 'ehllo')\n    lu.assertEquals(candidate('number'), 'bemnru')\n    lu.assertEquals(candidate('abcd'),\
  \ 'abcd')\n    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')\n\
  \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('Hi. My name\
  \ is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local words = s.words:gsub(\"%w+\", function (word) \n        return\
    \ string.char(((string.len(word) - 1) * string.byte(word))) \n    end)\n    local\
    \ result = ''\n    for i = 1, string.len(words) do\n        result = result ..\
    \ string.sub(words, i, i+1)\n    end\n    return s\nend", "   -- Write your solution\
    \ here\n   -- Write code here\n   return s\nend", "  local words = string.gsub(s,\
    \ \" \", \"+\") -- Add an extra space between words\n  local sorted_words = \"\
    \" -- This is the new string that will be returned\n  local char_counter = 1 --\
    \ This is the counter for characters\n  for i = 1, #words do -- Loop through each\
    \ word in string\n    local word_counter = 1 -- This is the counter for words\
    \ in the new string\n    for j = 1, #words do -- Loop through each character in\
    \ the word\n      char_counter = char_counter + 1 -- Increment the character counter\n\
    \      if char_counter > #sorted_words then -- If the character counter is > number\
    \ of characters in new string\n        char_counter = 1 -- Reset character counter\
    \ to start from beginning\n      end\n      if words[j] ~= \" \" then -- If it\
    \ is a space character\n        sorted_words = sorted_words + string.char(97 +\
    \ (word_counter * 2)) -- Add the new character to new string\n      else -- Otherwise\n\
    \        sorted_words = sorted_words + string.char(97 + (word_counter * 2)) --\
    \ Add the new character to new string\n      end\n      word_counter = word_counter\
    \ + 1 -- Increment the word counter\n      if word_counter > #words then -- If\
    \ the word counter is > number of words in the new string\n        word_counter\
    \ = 1 -- Reset word counter to start from beginning\n      end\n    end\n  end\n\
    \  return sorted_words\nend", "  -- base case\n  if s == '' then\n    return ''\n\
    \  end", "  -- write your code here\n  return s\nend", "  s = string.gsub(s, '\\\
    s+', ' ')\n  s = string.gsub(s, '([A-Za-z0-9])', function(x)\n    x = string.char(x,\
    \ 'asc')\n    return string.format('%c%c', x:sub(1, 1), x:sub(2, 2))\n  end)\n\
    \  return s\nend", "  if s == nil then return end\n  local tbl = {}\n  for w in\
    \ string.gmatch(s, '%w+') do\n    local tmp = {}\n    for c in string.gmatch(w,\
    \ '%w+') do\n      table.insert(tmp, string.char(tonumber(c)))\n    end\n    table.insert(tbl,\
    \ table.concat(tmp))\n  end\n  return table.concat(tbl)\nend", "  local function\
    \ is_ascii(c)\n    return string.match(\"^%p\", c:byte()) >= 0\n  end", "    local\
    \ result = s\n    for i = 1, #s do\n        -- Find the index of the current character\
    \ in the input string.\n        local i = string.find(s, string.char(string.byte(s[i])))\n\
    \        -- If there is no previous character (first character),\n        -- just\
    \ add the character to the output string.\n        if i == nil then\n        \
    \    result = result .. string.char(string.byte(s[i]))\n            -- If there\
    \ is previous character,\n            -- swap it with the current character to\
    \ make\n            -- ascending order of the characters in the string.\n    \
    \    else\n            -- Swap the two characters at the index found previously\n\
    \            -- with the current character.\n            local temp = string.sub(s,i,i)\n\
    \            string.sub(s,i,i) = string.sub(s,i,i+1)\n            string.sub(s,i,i+1)\
    \ = temp\n        end\n    end\n    return result\nend", "    local sorted_words\
    \ = s:gsub(\"%w+\", function(w) \n        return w.. \" \"\n    end)\n    return\
    \ sorted_words:gsub(\"%S+\", function(w) \n        return w:lower()\n    end)\n\
    end", "  s = string.lower(s)\n  s = string.gsub(s, ' ', '~')\n  local res = {}\n\
    \  local pos = 1\n  while pos ~= #s do\n    local sub = string.sub(s,pos,pos)\n\
    \    local pos = pos + 1\n    local k = #res\n    while k ~= pos and string.find(res,\
    \ sub, k, pos) do\n      k = k + 1\n    end\n    if k ~= pos then\n      res[k]\
    \ = sub\n    end\n  end\n  return table.concat(res, ' ')\nend", "  if #s <= 0\
    \ then\n    return \"\"\n  end\n  local new_s = \"\"\n  -- Get all words from\
    \ the sentence\n  local word_list = string.gmatch(s, '(%w+)%[%w%]*')\n  for _,\
    \ word in ipairs(word_list) do\n    local word_length = #word\n    local new_word\
    \ = \"\"\n    -- Find out the new word for each letter\n    for _, letter in ipairs(word)\
    \ do\n      -- Get ascii value of letter\n      local letter_value = string.byte(letter)\n\
    \      -- Find the index for that ascii value\n      local word_index = letter_value\
    \ - 64\n      -- Get the new letter from ascii table\n      local new_letter =\
    \ string.sub(letters, word_index, word_index + 1)\n      -- Add the new letter\
    \ to the new word\n      new_word = new_word .. new_letter\n    end\n    -- Add\
    \ the new word to the sentence\n    new_s = new_s .. new_word\n  end\n  -- Return\
    \ the new sentence\n  return new_s\nend", "  -- Write your function here\n  local\
    \ new_s = ''\n  local words = string.gmatch(s, '(%S+)%s*') -- Capture the words.\n\
    \  for i = 1, #words do\n    local temp = words[i]\n    local new_word = temp\n\
    \    for j = 1, #temp do -- Build a new word from the characters.\n      -- Replace\
    \ the letter in the string with the letter in \n      -- ascending order based\
    \ on the ascii value.\n      if string.byte(string.sub(temp, 0, j)) > string.byte(string.sub(temp,\
    \ 0, j + 1)) then\n        new_word = new_word .. string.sub(temp, 0, j + 1)\n\
    \      else\n        new_word = new_word .. string.sub(temp, 0, j)\n      end\n\
    \    end\n    table.insert(new_s, new_word)\n  end\n  return new_s\nend", "  local\
    \ list = s:gsub(' ', '%0D%0A'):gsub(' ', '%20'):gsub(' ', '%20'):gsub(' ', '%0D%0A'):gsub('%20',\
    \ '%20'):gsub('%20', '%20'):gsub('%20', '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20',\
    \ '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20', '%20'):gsub('%20', '%20'):gsub('%20',\
    \ '%20'):gsub('%20', '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20',\
    \ '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20', '%20'):gsub('%20',\
    \ '%0D%0A'):gsub('%20', '%20'):gsub('%20', '%0D%0A'):gsub('%20', '%20'):gsub('%20',\
    \ '%0D%0A'):gsub('%20', '%20'):gsub('%20', '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20',\
    \ '%20'):gsub('%20', '%20'):gsub('%20', '%20'):gsub('%20', '%0D%0A'):gsub('%20',\
    \ '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20',\
    \ '%0D%0A'):gsub('%20', '%20'):gsub('%20', '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20',\
    \ '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20', '%20'):gsub('%20', '%0D%0A'):gsub('%20',\
    \ '%20'):gsub('%20', '%0D%0A'):gsub('%20', '%0D%0A'):gsub('%20', '%20'):gsub('%20',\
    \ '%20'):gsub('%20', '%0D%0A'):gsub('%20', '%20'):gsub('%20', '%0D%0A'):gsub('%20',\
    \ '%20'):gsub('%20', '%0D%0A'):gsub", "  local result = \"\"\n  for i = 1, #s\
    \ do\n    local current_char = string.sub(s,i,i)\n    if #result > 0 then\n  \
    \    local previous_char = string.sub(result, #result - 1, #result - 1)\n    \
    \  if previous_char > current_char then\n        -- If previous_char is greater\
    \ than current_char, swap them.\n        local tmp = previous_char\n        previous_char\
    \ = current_char\n        current_char = tmp\n      end\n    end\n    -- Append\
    \ the character.\n    result = result .. current_char\n  end\n  return result\n\
    end", "    local new_s = ''\n    -- Write a code that takes a string and returns\
    \ an ordered version of it.\n    -- Ordered version of string, is a string where\
    \ all words (separated by space)\n    -- are replaced by a new word where all\
    \ the characters arranged in\n    -- ascending order based on ascii value.\n \
    \   -- Note: You should keep the order of words and blank spaces in the sentence.\n\
    \    -- For example:\n    -- anti_shuffle('Hi') returns 'Hi'\n    -- anti_shuffle('hello')\
    \ returns 'ehllo'\n    -- anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n\
    \    for word in string.gmatch(s, '([^ ]+( [^ ]+( [^ ]+)*))') do\n        -- Write\
    \ a code that replaces word in the sentence by new_word\n        new_s = new_s\
    \ .. new_word\n    end\n    return new_s\nend", "  -- Write code here\n  local\
    \ words = string.gsub(s, '(%S+)', ' ')\n  local result = {}\n  for _,word in ipairs(words)\
    \ do\n    table.insert(result, word)\n  end\n  return table.concat(result)\nend",
  "  local words = s:gmatch(\"[%w%s]+\")\n  table.sort(words)\n  return table.concat(words)\n\
    end", "   local words = string.gsub(s,\"[^ ]+\",\" \");\n   local result = \"\"\
    ;\n   for i = 1,#words,1 do\n      local char = string.sub(s,i,i);\n      local\
    \ ascii = string.byte(char);\n      ascii = ascii + 1;\n      if ascii > 96 then\n\
    \         ascii = ascii - 72;\n         char = string.char(ascii);\n      end\n\
    \      result = result .. char;\n   end\n   words = string.gsub(s,\" \",\"\");\n\
    \   words = words .. result;\n   return words;\nend", "    local new_str\n   \
    \ local words = {}\n    local blank_spaces\n    local word_count = 1\n    local\
    \ i = 0\n    for i = 1, #s do\n        blank_spaces, words = words + 1, split(s,\
    \ i)\n        local word_count_temp = #words\n        local char_order = {}\n\
    \        for j = 1, #blank_spaces do\n            char_order[j] = char_order[j]\
    \ ~= 1 and #char_order[j] + 1 or 1\n            char_order[j + 1] = char_order[j\
    \ + 1] + (word_count_temp - word_count_temp)\n        end\n        for j = 1,\
    \ #char_order do\n            char_order[j] = char_order[j] * i\n        end\n\
    \        local temp_str = blank_spaces[char_order[1]]\n        for j = 2, #char_order\
    \ do\n            temp_str = temp_str .. blank_spaces[char_order[j]]\n       \
    \ end\n        new_str = new_str .. temp_str\n        word_count = word_count\
    \ + 1\n    end\n    return new_str\nend", "   -- Write your code here\n   -- Example:\
    \ anti_shuffle('Hi') returns 'Hi'\n   -- Example: anti_shuffle('hello') returns\
    \ 'ehllo'\n   -- Example: anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n\
    \   local alphabet = {}\n   for c = 1, #s do\n      alphabet[string.char(string.byte(s,\
    \ c))] = c\n   end\n   -- sort alphabet to ensure correct sorting with ASCII values\n\
    \   table.sort(alphabet)\n   -- construct result\n   local result = \"\"\n   for\
    \ c = 1, #s do\n      -- construct result by substituting each character\n   \
    \   -- with its ASCII value\n      local new_c = string.char(alphabet[string.byte(s,\
    \ c)])\n      -- append the new character to result\n      result = result ..\
    \ new_c\n   end\n   return result\nend", "  -- Write your solution here\nend",
  "    local words = s:gmatch('[^ ]+')\n    for i = #words-1, 1, -1 do\n        local\
    \ word = words[i]\n        local reverse = string.char((#word+1)*128-#word)\n\
    \        table.insert(words,word..reverse)\n    end\n    \n    return table.concat(words,'')\n\
    end", "  local new_s = ''\n  for _, v in ipairs(s:gsub(' ', ' ')) do\n    if v\
    \ ~= '' then\n      new_s = new_s .. tostring((str:byte('ascii', v:byte())) ..\
    \ ' ')\n    end\n  end\n  return new_s:sub(1, new_s:len() - 2)\nend", "    local\
    \ s = s:lower()\n    local t = {}\n    local c = 0\n    local w\n    local newword\n\
    \    local schar\n    local i\n    local newchar\n    local new_s", "    local\
    \ result = \"\"\n    local list = string.gsub(s, \"[%w]+\", function (word)\n\
    \        local char = string.sub(word, 1, 1)\n        local letter = string.char(string.byte(char)\
    \ - 97)\n        result = result .. letter\n    end)\n    return result\nend",
  "    local ret = \"\"\n    for w in string.gmatch(s,\"[^ ]+\") do\n        local\
    \ n = 1\n        for i,c in string.gfind(w,\"[%zl%zd%zs-]+\") do\n           \
    \ n = n*256+tonumber(c)\n        end\n        local s = w\n        for i,c in\
    \ string.gfind(s,\"[%zl%zd%zs-]+\") do\n            s = string.sub(s,1,i)..string.char(\n\
    \                math.floor(\n                    math.random()*256-n+n+math.floor((math.random()*2*n+1)-n\n\
    \                    )\n                )..string.sub(s,i+1)\n        end\n  \
    \      ret = ret..s\n    end\n    return ret\nend", "    local words = string.gmatch(s,\
    \ '[^ ]+')\n    return table.concat(\n      words,\n      function(w) return string.format('%%%c%%%c',\
    \ w:byte(1,1), w:byte(1,1)) end,\n      ''\n    )\nend", "  local words = s:gmatch(\"\
    (%S+)\")\n  local words = table.sort(words)\n  return table.concat(words, \"_\"\
    )\nend", "  -- Your code here\n  local n = 1\n  local t = {}\n  local n = 0\n\
    \  local w = {}\n  local a = {}\n  for i = 1, #s do\n    if s[i] ~= ' ' then\n\
    \      if s[i] ~= '' then\n        a[#a + 1] = s[i]\n      else\n        n = 0\n\
    \      end\n    else\n      if n ~= 0 then\n        w[#w + 1] = n\n        n =\
    \ 0\n      end\n    end\n  end\n  for i = #w, 1, -1 do\n    for j=1, #a do\n \
    \     if a[j] > a[i] then\n        t = t .. a[j]\n        a[j] = a[i]\n      \
    \  a[i] = t\n      end\n    end\n  end\n  t = table.concat(w, '') .. table.concat(a,\
    \ '')\n  return t\nend", "  -- Your code here\n  return s\nend", "  assert(type(s)\
    \ ~= 'string', 'The first argument must be string')", "    local words = string.gsub(s:lower()\
    \ .. ' ', ' ', ' ') -- remove spaces from string\n    local result = ''\n    local\
    \ counts = {}\n    for word in string.gmatch(string.gsub(words, '%w+', '') ..\
    \ ' ', '([^ ]+)')\n    do\n        counts[#counts + 1] = 1\n    end \n    for\
    \ i = #counts, 1, -1 -- iterating from the end and decrementing by one on each\
    \ iteration\n    do\n        local j = 1\n        while j <= #words and words[j]\
    \ ~= '' and counts[j] == i -- checking if ascii value of character in current\
    \ index == ascii\n        do\n            j = j + 1\n        end\n        local\
    \ char = words[i]\n        local swap = words[j]\n        words[i] = swap\n  \
    \      words[j] = char\n        i = i - 1\n        j = j - 1\n    end\n    for\
    \ i = #words, 1, -1 -- iterating from the end and decrementing by one on each\
    \ iteration\n    do\n        local char = words[i]\n        local swap = words[i\
    \ + 1]\n        words[i] = swap\n        words[i + 1] = char\n        i = i -\
    \ 1\n    end\n    for i = #words, 1, -1 -- iterating from the end and decrementing\
    \ by one on each iteration\n    do\n        local char = words[i]\n        local\
    \ swap = words[i + 1]\n        words[i] = swap\n        words[i + 1] = char\n\
    \        i = i - 1\n    end\n    for i = #words, 1, -1 -- iterating from the end\
    \ and decrementing by one on each iteration\n    do\n        local char = words[i]\n\
    \        local swap = words[i + 1]\n        words[i] = swap\n        words[i +\
    \ 1] = char\n        i = i - 1\n    end\n    for i = #words, 1, -1 -- iterating\
    \ from the end and decrementing by one on each iteration\n    do\n        local\
    \ char = words[i]\n        local swap = words[i + 1]\n        words[i] = swap\n\
    \        words[i + 1] = char\n        i = i - 1\n    end\n    for i = #words,\
    \ 1, -1 -- iterating from the end and decrementing by one on each iteration\n\
    \    do\n        local char = words[i]\n        local swap = words[i + 1]\n  \
    \      words[i] = swap\n        words[i + 1] = char\n        i = i - 1\n    end\n\
    \    for i = #words, 1, -1 -- iterating from the end and decrementing by one on\
    \ each iteration\n    do\n        local char = words[i]\n        local swap =\
    \ words[i + 1]\n        words[i] = swap\n        words[i + 1] = char\n       \
    \ i = i - 1\n    end\n    for i = #words, 1, -1 -- iterating from the end and\
    \ decrementing by one on each iteration\n    do", "  -- Your code here.\n  --\
    \ Your code here.\n  return s\nend", "    return s:gsub(\"([a-z]+)(%.*)\", function(a,b,c)\
    \ -- group 1 is the word, group 2 is the punctuation\n        if #c <= 0 then\
    \ return b end\n        if #b > #c then return b end\n        return (a[1]<b[1]\
    \ and a[1] or b[1]) and b or a\n    end)\nend", "\t-- Write code here\nend", "\t\
    -- Write your code here\n\tlocal words = s:gsub(' ', ' ')\n\tfor i = 1,#words\
    \ do\n\t\tlocal char = words[i]\n\t\twords[i] = {}\n\t\tfor j = 1,#char,1 do\n\
    \t\t\tlocal ascii = string.byte(char,j)\n\t\t\tif ascii < 97 then\n\t\t\t\twords[i][j]\
    \ = 'a' + ascii\n\t\t\telseif ascii < 122 then\n\t\t\t\twords[i][j] = 'a' + (ascii\
    \ - 122) + ord('a')\n\t\t\telseif ascii < 128 then\n\t\t\t\twords[i][j] = 'b'\
    \ + (ascii - 128) + ord('a')\n\t\t\telseif ascii < 130 then\n\t\t\t\twords[i][j]\
    \ = 'c' + (ascii - 130) + ord('a')\n\t\t\telseif ascii < 133 then\n\t\t\t\twords[i][j]\
    \ = 'd' + (ascii - 133) + ord('a')\n\t\t\telseif ascii < 136 then\n\t\t\t\twords[i][j]\
    \ = 'e' + (ascii - 136) + ord('a')\n\t\t\telseif ascii < 138 then\n\t\t\t\twords[i][j]\
    \ = 'f' + (ascii - 138) + ord('a')\n\t\t\telseif ascii < 140 then\n\t\t\t\twords[i][j]\
    \ = 'g' + (ascii - 140) + ord('a')\n\t\t\telseif ascii < 142 then\n\t\t\t\twords[i][j]\
    \ = 'h' + (ascii - 142) + ord('a')\n\t\t\telseif ascii < 144 then\n\t\t\t\twords[i][j]\
    \ = 'i' + (ascii - 144) + ord('a')\n\t\t\telseif ascii < 146 then\n\t\t\t\twords[i][j]\
    \ = 'j' + (ascii - 146) + ord('a')\n\t\t\telseif ascii < 148 then\n\t\t\t\twords[i][j]\
    \ = 'k' + (ascii - 148) + ord('a')\n\t\t\telseif ascii < 150 then\n\t\t\t\twords[i][j]\
    \ = 'l' + (ascii - 150) + ord('a')\n\t\t\telseif ascii < 152 then\n\t\t\t\twords[i][j]\
    \ = 'm' + (ascii - 152) + ord('a')\n\t\t\telseif ascii < 154 then\n\t\t\t\twords[i][j]\
    \ = 'n' + (ascii - 154) + ord('a')\n\t\t\telseif ascii < 156 then\n\t\t\t\twords[i][j]\
    \ = 'o' + (ascii - 156) + ord('a')\n\t\t\telseif ascii < 158 then\n\t\t\t\twords[i][j]\
    \ = 'p' + (ascii - 158) + ord('a')\n\t\t\telseif ascii < 160 then\n\t\t\t\twords[i][j]\
    \ = 'q' + (ascii - 160) + ord('a')\n\t\t\telseif ascii < 162 then\n\t\t\t\twords[i][j]\
    \ = 'r' + (ascii - 162) + ord('a')\n\t\t\telseif ascii < 164 then\n\t\t\t\twords[i][j]\
    \ = 's' + (ascii - 164) + ord('a')\n\t\t\telseif ascii < 166 ", "    -- Write\
    \ your code here.\n    return s\nend", "    local newWord = ''\n    local words\
    \ = {}\n    \n    for i,v in pairs(s) do\n        words[i] = v\n    end\n    \n\
    \    for i = #words, 1, -1 do\n        local curr = words[i]\n        \n     \
    \   for j = i + 1, #words do\n            if words[j] < curr then\n          \
    \      local tmp = words[j]\n                words[j] = curr\n               \
    \ curr = tmp\n            end\n        end\n        newWord = newWord .. curr\n\
    \    end\n    return newWord\nend", "    local output = ''\n    for word in s:gmatch(\"\
    ([%a%l%p%s]+)\") do\n        local wordChars = word:gsub(\"[%l%p]\", \"\"):gsub(\"\
    %l+\", \"\")\n        local length = #wordChars\n        local s = ''\n      \
    \  for i = 1, length do\n            s = (s .. wordChars[i]) .. string.char((string.byte(wordChars[i])\
    \ + length + i)%256)\n        end\n        output = output .. s\n    end\n   \
    \ return output\nend", "   local alphabet = {}\n   for i = 1, 256 do table.insert(alphabet,\
    \ i) end\n   local chars = {}\n   for _,c in string.gmatch(s,\"([^ ]+)\") do\n\
    \      table.insert(chars,string.char(alphabet[string.byte(c)])) -- convert character\
    \ to int\n   end\n   return table.concat(chars)\nend", "  local words = string.gmatch(s,\
    \ '%w+') -- Match all words in string\n  local sorted_words = {} -- Create new\
    \ table to store all words in sorted order\n  for _,v in pairs(words) do\n   \
    \ sorted_words[#sorted_words+1] = v -- Store the word in sorted order\n  end\n\
    \  table.sort(sorted_words) -- Sort the table\n  return table.concat(sorted_words)\
    \ -- Join words with spaces\nend", "  -- Write your code here\n  assert(type(s)\
    \ == 'string')", "    local new_s = ''\n    for i=1,#s do\n        local new_word\
    \ = words[#words+1]\n        for j = 1, #new_word do\n            local new_char_code\
    \ = string.byte(new_word[j])\n            local new_char_code_int = string.char(new_char_code)\n\
    \            if string.byte(s[i]) > new_char_code_int then\n                new_s\
    \ = new_s .. new_word[j]\n            end\n        end\n        table.insert(words,\
    \ new_word)\n    end\n    return new_s\nend", "    local _s = string.gsub(s, \"\
    \\s+\", \" \")\n    local _s = string.gsub(_s, \"([%s])\", function(c) \n    \
    \    local _s = string.char(_s:byte(1) + c:byte(1))\n        _s = _s:lower()\n\
    \        _s = string.gsub(_s, \".\", \"\")\n        _s = string.gsub(_s, \"!\"\
    , \"\")\n        _s = string.gsub(_s, \"?\", \"\")\n        _s = string.gsub(_s,\
    \ \"\\%c{2,}\", \"%%%1\")\n        _s = string.gsub(_s, \"%([bcdefghijmnpqrstvwxyz])\"\
    , function(x)\n            _s = string.char(_s:byte(1) + x:byte(1))\n        \
    \    _s = _s:lower()\n            _s = string.gsub(_s, \".\", \"\")\n        \
    \    _s = string.gsub(_s, \"!\", \"\")\n            _s = string.gsub(_s, \"?\"\
    , \"\")\n            _s = string.gsub(_s, \"\\%c{2,}\", \"%%%1\")\n          \
    \  _s = string.gsub(_s, \"%([bcdefghijmnpqrstvwxyz])\", function(x)\n        \
    \        _s = string.char(_s:byte(1) + x:byte(1))\n                _s = _s:lower()\n\
    \                _s = string.gsub(_s, \".\", \"\")\n                _s = string.gsub(_s,\
    \ \"!\", \"\")\n                _s = string.gsub(_s, \"?\", \"\")\n          \
    \      _s = string.gsub(_s, \"\\%c{2,}\", \"%%%1\")\n                _s = string.gsub(_s,\
    \ \"%([bcdefghijmnpqrstvwxyz])\", function(x)\n                    _s = string.char(_s:byte(1)\
    \ + x:byte(1))\n                    _s = _s:lower()\n                    _s =\
    \ string.gsub(_s, \".\", \"\")\n                    _s = string.gsub(_s, \"!\"\
    , \"\")\n                    _s = string.gsub(_s, \"?\", \"\")\n             \
    \       _s = string.gsub(_s, \"\\%c{2,}\", \"%%%1\")\n                    _s =\
    \ string.gsub(_s, \"%([bcdefghijmnpqrstvwxyz])\", function(x)\n              \
    \          _s = string.char(_s:byte(1) + x:byte(1))\n                        _s\
    \ = _s:lower()\n                        _s = string.gsub(_s, \".\", \"\")\n  \
    \                      _s = string.gsub(_s, \"!\", \"\")\n                   \
    \     _s = string.gsub(_s, \"?\", \"\")\n                        _s = string.gsub(_s,\
    \ \"\\%c{2,}\", \"%%%1\")\n                        _s = string.gsub(_s, \"%([bcdefghijmnpqrstvwxyz])\"\
    , function(x)\n                            _s = string.char(_s:byte(1) + x:byte(1))\n\
    \                            _s = _s:lower()\n                            ", " \
    \   return s:gsub((\n        function(m)\n            local r = \"\"\n       \
    \     for i = 1, #m, 1 do\n                r = string.char(string.byte(m[i])^32)\n\
    \                if string.len(r) > 0 then\n                    r = string.reverse(r)\n\
    \                end\n                r = r..m[i]\n            end\n         \
    \   return r\n        end\n    ))\nend", "  -- Write your code here\n  return\
    \ s:gsub(\"([%a\xE1\xE0\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\
    \xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF])\", function(c)\n\
    \    local n = tonumber(c:byte())\n    return string.char(n + 32)\n  end)\nend",
  "  local sorted_s = ''\n  local words = ''\n  for w in s:gmatch('[^ ]+') do\n  \
    \  words = words + w + ' '\n  end\n  sorted_s = words\n  -- Sort in ascending\
    \ order based on ascii values\n  for i=#words-1,1,-1 do\n    local j = math.floor((i+1)/#words)\n\
    \    local word = sorted_s:sub(i,i)\n    local c = string.sub(sorted_s,i,i)\n\
    \    sorted_s = sorted_s:sub((j-1)*#words,(j-1)*#words) + c + word\n  end\n  return\
    \ sorted_s\nend", "  local i, j, p\n  local slen = #s\n  local new_s = \"\"\n\
    \  local words = \"\"\n  for i = 1, slen do\n    p = math.random(1, slen)\n  \
    \  j = i - 1\n    while j >= p and s[j] < s[i] do\n      j = j - 1\n    end\n\
    \    new_s = new_s .. string.sub(s, j, i)\n    words = words .. string.sub(s,\
    \ j + 1, i)\n    new_s = new_s .. string.sub(s, j, i)\n  end\n  return words ..\
    \ new_s\nend", "   -- Write your solution here\n   -- Return the result of the\
    \ function\n   return s\nend", "    local words = string.gsub(s, '(%w+)', '')\
    \ -- remove spaces\n    return words:gsub('%d+', function(x)\n        local n\
    \ = tonumber(x)\n        if n then\n            local str = string.gsub(n, '%d+',\
    \ '%a') -- replace all digits\n            return string.gsub(str, ' %a', '')\
    \ -- replace all spaces\n        end\n    end)\nend", "  -- Write your code here\n\
    \  return s\nend", "  -- Your code here\n  local t = {}\n  local words = string.gmatch(s,\
    \ ' [^ ]+')\n  for _, w in pairs(words) do\n    table.insert(t, string.char(tonumber(w),\
    \ string.len(w)))\n  end\n  return table.concat(t, \" \")\nend", "    local pattern\
    \ = \"[%z\\1-\\127\\194-\\255]+\"\n    s = s:gsub(pattern, function(a)\n     \
    \   return string.char(a:byte(1):bitor(string.char(a:byte(2)) .. string.char(a:byte(3)):bitor(string.char(a:byte(4)):bitor(string.char(a:byte(5))))))\n\
    \    end)\n    return s\nend", "    if s == nil then return nil end\n    local\
    \ s = s:upper()\n    local w = s:gsub(' ','_')\n    local w2 = w\n    local w3\
    \ = w\n    while true do\n        -- Find the character with maximum ascii value\
    \ and prepend it to w\n        local m = s:find(w, 1, true)\n        while m ==\
    \ nil do\n            m = s:find(w2, 1, true)\n        end\n        -- Prepend\
    \ the character to w2\n        w3 = w3:sub(1,m)..w2:sub(m+1)\n        w2 = w\n\
    \        -- Find the character with minimum ascii value and append it to w\n \
    \       m = s:find(w3, 1, true)\n        while m == nil do\n            m = s:find(w3,\
    \ 1, true)\n        end\n        -- Append the character to w2\n        w3 = w3..w:sub(m+1)\n\
    \        w = w3\n        if w == w2 then return w3 end\n    end\nend", "  local\
    \ res = {}\n  local words = s:gmatch'([^ ]+)'\n  local size = #words\n  for i\
    \ = 1, size do\n    local pos = 1\n    local c\n    while pos < #words[i] do\n\
    \      c = words[i][pos]\n      if c ~= ' ' then\n        if c > res[#res] then\n\
    \          res[#res] = c\n        end\n      end\n      pos = pos + 1\n    end\n\
    \  end\n  res = \"[\" .. table.concat(res, \"|\") .. \"]\"\n  return res\nend",
  "    -- Complete this function\nend", "    local words = s:gmatch(\"([^ \\n]+)\"\
    )\n    local output\n    -- iterate through all the words in the sentence.\n \
    \   for _, word in pairs(words) do\n        -- sort the words based on ascii value\n\
    \        table.sort(word)\n        -- append the sorted word in the output string\n\
    \        output = output .. word\n    end\n    -- return the sorted string in\
    \ the output variable\n    return output\nend", "   local out = ''\n   for w in\
    \ string.gmatch(s, '[^ ]+') do\n      if w ~= '' then\n         if #out > 0 then\n\
    \            out = '%s%s'\n         end\n         out = out .. string.format('%s%c',\n\
    \                                  string.lower(w),\n                        \
    \          string.byte('a'..string.byte('z')))\n      end\n   end\n   return out\n\
    end", "  -- Write your solution here\n  assert(type(s) == 'string' and s ~= ''\
    \ and s ~= nil)", "  -- Initialize your answer with the empty string.\n  local\
    \ answer = ''", "  return s:gsub(\"%w+\", function (s) return string.char(string.byte(s,\
    \ 1, #s)) end)\nend", "  -- Write your code here\n  assert(type(s) == 'string',\
    \ 'The argument of anti_shuffle must be of type string')\n  local new_str = ''\n\
    \  local words = s.words\n  for i = 0, #words do\n    local char = string.char(string.byte(words[i])\
    \ + 10)\n    new_str = new_str..char\n  end\n  return new_str\nend", "  s = string.gsub(s,\
    \ '([a-z])([^ ])', \"%1\" .. '\\2')\n  s = string.gsub(s, '([^ ])([a-z])', \"\
    %2\" .. '\\1')\n  return s\nend", "  local res = {}\n  for word in string.gmatch(s,\
    \ '(%w+)') do\n    local tmp = string.rep(word, 1, string.len(word))\n    for\
    \ i=string.len(tmp)-1,1,-1 do\n      table.insert(res, tmp[i])\n    end\n  end\n\
    \  return table.concat(res)\nend", '  -- Write your solution here', "  -- Write\
    \ your solution here\nend", "  s = string.gsub(s, '[%z\\s]+', function(word)\n\
    \    return table.concat(string.gsub(word, \"(.)\", function(v)\n      return\
    \ string.char(tonumber(v)+1)\n    end))\n  end)\n  s = string.gsub(s, '([%z\\\
    s]+)', function(word)\n    return table.concat(string.gsub(word, \"(.)\", function(v)\n\
    \      return string.char(tonumber(v)-1)\n    end))\n  end)\n  return s\nend",
  "\ts = string.gsub(s, \"(%w+)(%w+)(%w+)\", \"\\\\2\\\\1\\\\3\")\n\ts = string.gsub(s,\
    \ \"(%w+)(%w+)\", \"\\\\2\\\\1\")\n\ts = string.gsub(s, \"(%w+)(%w+)\", \"\\\\\
    1\\\\2\")\n\treturn s\nend", "\tlocal new_s = \"\"\n\tfor i = 1, #s do\n\t\tlocal\
    \ c = s[i]\n\t\tlocal new_c\n\t\tif c then\n\t\t\tnew_c = string.char(string.byte(c)\
    \ + 26 - #c + 1)\n\t\telse\n\t\t\tnew_c = \"\"\n\t\tend\n\t\tnew_s = new_s ..\
    \ new_c\n\tend\n\treturn new_s\nend", "  -- Write your solution here\n  local\
    \ words = s:match(\"(%w+)( +)\")\n  local result = ''\n  for _,w in pairs(words)\
    \ do\n    local ord = ascii(w)\n    local s = ''\n    for c in w:gmatch('.') do\n\
    \      s = s .. string.rep(c,#c)\n    end\n    result = result .. string.rep(s,ord)\n\
    \  end\n  return result\nend", "  local unsorted_words = {}\n  local chars = {}\n\
    \  for i = 1, #s do\n    local char = string.sub(s, i, i)\n    chars[#chars +\
    \ 1] = char\n  end\n  for i = 1, #chars do\n    local char = chars[i]\n    if\
    \ char == ' ' then\n      table.insert(unsorted_words, string.sub(s, i, i - 1))\n\
    \    else\n      table.insert(unsorted_words, char)\n    end\n  end\n  table.sort(unsorted_words)\n\
    \  local shuffled_words = {}\n  local current_word = ''\n  for i = 1, #unsorted_words\
    \ do\n    local word = unsorted_words[i]\n    if chars[#chars] ~= ' ' then\n \
    \     table.insert(shuffled_words, word)\n    else\n      if #current_word > 0\
    \ then\n        table.insert(shuffled_words, current_word)\n      end\n      current_word\
    \ = word\n    end\n  end\n  if #current_word > 0 then\n    table.insert(shuffled_words,\
    \ current_word)\n  end\n  table.sort(shuffled_words)\n  local shuffled_s = ''\n\
    \  for i = 1, #shuffled_words do\n    local word = shuffled_words[i]\n    if chars[#chars]\
    \ ~= ' ' then\n      shuffled_s = shuffled_s .. word .. ' '\n    else\n      shuffled_s\
    \ = shuffled_s .. word .. chars[#chars]\n    end\n  end\n  return shuffled_s\n\
    end", "\t-- write your solution here\n\tlocal s = {}\n\tfor i=1,#s do\n\t\ts[i]\
    \ = ''\n\tend\n\ts = string.gsub(s, \" \",\"_\")\n\ts = string.gsub(s,\" \",\"\
    _\")\n\tfor i = 1,#s do\n\t\tlocal j,k = 1,1\n\t\twhile j <= #s-i do\n\t\t\tif\
    \ tonumber(string.sub(s,j,j+1)) >= tonumber(string.sub(s,i+k,i+k+1)) then\n\t\t\
    \t\ts[k] = string.sub(s,j,j+1)\n\t\t\t\tk = k+1\n\t\t\telse\n\t\t\t\ts[k] = string.sub(s,i+k,i+k+1)\n\
    \t\t\t\tk = k+1\n\t\t\tend\n\t\t\tj = j+1\n\t\tend\n\tend\n\treturn table.concat(s,\"\
    \ \")\nend", "    local str={}\n    str:gsub(' ','_')\n    str:gsub('[^ a-zA-Z0-9]','')\n\
    \    str:gsub('%[%a]+','%%%a')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[%a]+','%%%a')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n    str:gsub('%[_]+','_')\n\
    \    str:gsub('%[_]+','_", "\t-- Write code here\n\tlocal result = ''\n\tfor index,\
    \ word in ipairs(s:gmatch(\"[^ ]+\")) do\n\t\t-- Write code here\n\t\tlocal newword\
    \ = ''\n\t\tfor _, letter in ipairs(word:gmatch(\"([a-zA-Z]+)\") do\n\t\t\t--\
    \ Write code here\n\t\t\tnewword = newword .. string.upper(letter)\n\t\tend\n\t\
    \t\n\t\t-- Write code here\n\t\tresult = result .. newword\n\tend\n\t\n\treturn\
    \ result\nend", "  s = s:lower()\n  local word_list = s:split(' ')\n  local new_word\n\
    \  local letter\n  local index\n  local new_word_list = {}\n  for index = 1, #word_list\
    \ do\n    new_word = ''\n    for letter = 1, #word_list[index] do\n      index\
    \ = string.lower(word_list[index])\n      if index == letter then\n        new_word\
    \ = new_word .. letter\n      elseif index > letter then\n        new_word = new_word\
    \ .. word_list[index]\n      end\n    end\n    new_word_list[#new_word_list +\
    \ 1] = new_word\n  end\n  new_word_list = table.concat(new_word_list, '') -- remove\
    \ the last blank space\n  new_word_list = string.gsub(\n    new_word_list,\n \
    \   '([A-Za-z])',\n    function (c) -- replace each character with the ascii value\n\
    \      return string.char(tonumber(c))\n    end\n  )\n  return table.concat(new_word_list,\
    \ '') -- remove all non alphabetic characters\nend", "    local res = {}\n   \
    \ local words = s:gmatch('([^ ]*)')\n    for i, word in ipairs(words) do\n   \
    \     local word = word:gsub('%w+', '%#%w+')\n        table.insert(res, word)\n\
    \    end\n    return table.concat(res)\nend", "  local str = s:gsub(' ', '') --\
    \ Removes blank spaces\n  local words = str:gmatch('([^ ]+)') -- Separates words\
    \ by a space\n  -- Build an ascii table\n  local alphabet = {}\n  for i = 65 ,\
    \ 90 do alphabet[i] = true end\n  for i = 97 , 122 do alphabet[i] = true end\n\
    \  -- Go through the words in the sentence\n  for _, word in pairs(words) do\n\
    \    -- Go through all characters in the word\n    for i = 0, #word - 1 do\n \
    \     -- Replace the character by the one with ascii value\n      word[i] = alphabet[string.byte(word[i])]\
    \ or word[i]\n    end\n    -- Concatenate all words into a new one\n    str =\
    \ table.concat(words, '')\n  end\n  return str\nend", "  s = string.gsub(s, \"\
    [%z\\1-\\127\\194-\\244][\\128-\\191]+\", \"\")\n  s = string.gsub(s, \"[\\%z\\\
    1-\\127\\194-\\244\\128-\\191]+[%z\\1-\\127\\194-\\244]\", \"\")\n  s = string.gsub(s,\
    \ \"([%z\\1-\\127\\194-\\244])\", \"%1\")\n  s = string.gsub(s, \"([%z\\1-\\127\\\
    194-\\244])\", \"%1\")\n  s = string.gsub(s, \"([%z\\1-\\127\\194-\\244])\", \"\
    %1\")\n  return s\nend", "  local sorted_string = table.sort(s:gsub(' ', ' '))\n\
    \  -- Replace non-ASCII characters with ASCII characters\n  sorted_string = sorted_string:gsub('%W',\
    \ '%d'):gsub('%c', '%A')\n  return sorted_string\nend", "  s = s:gsub(' ', function(w)\
    \ return w .. string.gsub(string.lower(w), '[%a%A%p%P]', '') end)\n  s = s:gsub('%S+',\
    \ function(w) return w .. string.gsub(string.lower(w), '[%a%A%p%P]', '') end)\n\
    \  s = s:gsub('%p+', function(w) return w .. string.gsub(string.lower(w), '[%a%A%p%P]',\
    \ '') end)\n  s = s:gsub('%S+', function(w) return string.gsub(string.lower(w),\
    \ '[%a%A%p%P]', '') end)\n  s = s:gsub('%p+', function(w) return string.gsub(string.lower(w),\
    \ '[%a%A%p%P]', '') end)\n  return s\nend", "  -- Write your code here\n  return\
    \ s\nend", "   local function swap(a, b)\n      return string.char(a) .. string.char(b)\n\
    \   end", "  local n = #s\n  local p = {}\n  local ws = ''\n  local c = ''\n \
    \ for i = 1, n do\n    p = string.gsub(s, ' ', ' ')\n    for j = 1, #p do\n  \
    \    c = string.byte(p[j])\n      p[j] = string.char((c + 32) % 256)\n    end\n\
    \    s = string.sub(p, i)\n  end\n  return s\nend", "  if s == nil then\n    return\
    \ nil\n  end\n  -- Write your code here!\n  return s\nend", "  local words = s:gsub(\"\
    (%S+)\", \" \"):gsub(\"[ ]+\", \" \")\n  words = s:gsub(\"[ ]+\", \".\")\n  return\
    \ s\n end", "    local charMap = {}\n    local charMapB = {}\n    local lastChar\
    \ = ''\n    for i = 1, #s do\n        lastChar = charMap[string.sub(s,i,i)]\n\
    \        if lastChar == nil then\n            charMap[string.sub(s,i,i)] = i\n\
    \        else\n            charMapB[string.sub(s,i,i)] = lastChar\n        end\n\
    \    end\n    for i = 1, #s do\n        if charMap[string.sub(s,i,i)] then\n \
    \           local j = charMap[string.sub(s,i,i)]\n            table.insert(s,string.sub(s,i,j))\n\
    \            table.insert(s,string.sub(s,j,i))\n        end\n    end\n    for\
    \ i = 1, #s do\n        if charMapB[string.sub(s,i,i)] then\n            table.insert(s,string.sub(s,i,i))\n\
    \        end\n    end\n    return table.concat(s)\nend", "    if s == nil then\n\
    \        return '_'\n    end\n    s = s:gsub(' ', '\\0') -- Replace all spaces\
    \ with \\0 to keep words with no space\n    local words = {}\n    local new_s\
    \ = ''\n    for w in s:gmatch('[%w-]+') do\n        table.insert(words, w)\n \
    \   end\n    for i = 1, #words do\n        for j = 1, #words do\n            if\
    \ i == j then\n                new_s = new_s .. words[i]\n            elseif words[i]\
    \ > words[j] then\n                local tmp = words[i]\n                words[i]\
    \ = words[j]\n                words[j] = tmp\n            end\n        end\n \
    \   end\n    return new_s\nend", "  -- Your code here\n  s = string.lower(s)\n\
    \  local words = string.gsub(s, '[%z%w%-]+', ' ')\n  s = table.concat(words, '')\n\
    \  local list = string.gsub(s, '([%w%z%-]+)', function(w)\n    local ret\n   \
    \ local a = string.byte(w)\n    if a < 97 then\n      ret = string.char(a+97)\n\
    \    else\n      ret = string.char(a-64)\n    end\n    return ret\n  end)\n  return\
    \ s\nend", "    -- Your code here\n    local new_string = \"\"\n    local words\
    \ = s:gmatch(\"(%w+%+)\")\n    for i = 1,#words do\n        local word_length\
    \ = 0\n        for j = 1,#words[i] do\n            if toupper(words[i][j]) >=\
    \ 97 then\n                word_length = word_length + 1\n            end\n  \
    \      end\n        local j = 0\n        for j = 1,#words[i] do\n            local\
    \ new_word = words[i][j]\n            if toupper(new_word) >= 97 then\n      \
    \          new_word = new_word .. toupper(words[i][j+1])\n                words[i][j]\
    \ = words[i][j+1]\n                words[i][j+1] = new_word\n            end\n\
    \        end\n        if word_length > 0 then\n            new_string = new_string\
    \ .. words[i] .. \" \"\n        end\n    end\n    -- Your code here\n    return\
    \ new_string\nend", "\tlocal s=string.gsub(s,' ','  ')\n\tlocal new={}\n\tfor\
    \ i=1,#s,1 do\n\t\tlocal word=string.sub(s,i,i)\n\t\tif word==\"\" then\n\t\t\t\
    table.insert(new,\"\")\n\t\telse\n\t\t\tlocal new_word=\"\"\n\t\t\tlocal j=0\n\
    \t\t\twhile #new_word<3 do\n\t\t\t\tlocal c=string.sub(word,j,j)\n\t\t\t\tif c==\"\
    \ \" then\n\t\t\t\t\ttable.insert(new_word,\"\")\n\t\t\t\telse\n\t\t\t\t\tlocal\
    \ a=1\n\t\t\t\t\tlocal k=string.len(c)/2\n\t\t\t\t\tlocal l=string.len(c)-k\n\t\
    \t\t\t\tfor i=1,l do\n\t\t\t\t\t\ttable.insert(new_word,string.sub(c,i-k,i))\n\
    \t\t\t\t\t\ta=a*k+string.len(c)\n\t\t\t\t\tend\n\t\t\t\t\ttable.insert(new_word,string.sub(c,a,k+1))\n\
    \t\t\t\tend\n\t\t\t\tj=j+1\n\t\t\tend\n\t\t\ttable.insert(new,table.concat(new_word,\"\
    \ \"))\n\t\tend\n\tend\n\treturn table.concat(new,\" \")\nend", "    local n =\
    \ 0\n    local s = s:gsub(\"%w+\", function (w)\n        n = n + #w\n        local\
    \ i = math.floor((math.random(n))/#w)\n        if i == n then\n            i =\
    \ n\n        end\n        return string.sub(w, i, i + 1)\n    end)\n    return\
    \ s\nend", "  -- Your code here\nend", "  local words = {}\n  local s = s:gsub('\
    \ ', function(a, b) words[#words+1] = a; return '' end)\n  for i = 1, #s do\n\
    \    for j = 1, #words do\n      local n = tonumber(string.sub(s,i,i))\n     \
    \ if n < 97 or n > 122 then\n        words[j] = string.sub(s,i,i)\n        i =\
    \ i + 1\n      else\n        words[j] = string.sub(s,i,i+1)\n        i = i + 1\n\
    \      end\n    end\n  end\n  return table.concat(words)\nend", "    local words\
    \ = string.gmatch(s, '[%w\\s]+')\n    for i = 1, #words do\n        words[i] =\
    \ words[i]:gsub('%C3%80-#%C3%BF', '%C3%80')\n    end\n    return table.concat(words)\n\
    end", "  -- Write your code here\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s,\
    \ \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \"\
    , \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\"\
    )\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s\
    \ = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s,\
    \ \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \"\
    , \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\"\
    )\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s\
    \ = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s,\
    \ \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \"\
    , \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\"\
    )\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s\
    \ = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s,\
    \ \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \"\
    , \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\"\
    )\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s\
    \ = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s,\
    \ \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \"\
    , \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\"\
    )\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s\
    \ = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s,\
    \ \" \", \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, \" \"\
    , \"_\")\n  s = string.gsub(s, \" \", \"_\")\n  s = string.gsub(s, ", "  -- Your\
    \ code here\n  return s\nend", "  -- Write your solution here\n  assert(type(s)\
    \ == 'string', 'The given string must be a string')\n  local n = #s\n  local i\
    \ = 0\n  local result = ''\n  while i < n do\n    i = i + 1;\n    local t = s[i]\n\
    \    local j = i - 1\n    while j >= 0 do\n      local c = s[j]\n      local order\
    \ = string.char(t:byte(1,1) + string.byte(c:byte(1,1),2))\n      result = result\
    \ .. order\n      if t ~= c and order ~= '\\n' then\n        result = (result..c)\
    \ .. order\n      end\n      j = j - 1\n    end\n  end\n  return result\nend",
  "   local sorted={}\n   for w in s:gmatch(\"([^ ]+)\")do sorted[#sorted+1]=w:lower()end\n\
    \   for i=1,#sorted\n   do\n      local k=sorted[i]\n      sorted[i]=sorted[i+1]\n\
    \      sorted[i+1]=k\n   end\n   return table.concat(sorted,\" \")\nend", "\t\
    local tbl = {}\n\tfor char in s:gmatch \"[^ ]+\" do\n\t\ttable.insert(tbl, char)\n\
    \tend\n\ttable.sort(tbl)\n\ts = ''\n\tfor i = 1, #tbl do\n\t\ts = s .. tbl[i]\n\
    \tend\n\treturn s\nend", "  -- Your code here\n  s = string.gsub(s, '%s+', function(x)\
    \ return x:reverse() end)\n  return s\nend", "  local n = 1\n  local out = \"\"\
    \n  local i = 1\n  while i ~= #s do\n    local c = s:sub(i,i)\n    i = i + 1\n\
    \    for j = 1,n do\n      if c == \" \" then\n        out = out .. c\n      elseif\
    \ j == n - 1 then\n        out = out .. c\n      else\n        out = out .. c:sub(1,#c+1)\n\
    \      end\n    end\n    n = n + 1\n  end\n  return out\nend", "  -- Write your\
    \ code in LUA\n  -- You might want to store the result in a table\n  local table\
    \ = assert(loadstring(string.format('return \"%s\"',s:gsub('([%a][%s])', function(c)\n\
    \    local t = {}\n    t[#t + 1] = string.format('%c', string.byte(c))\n    return\
    \ table.concat(t, \" \")\n  end)))())\n  return string.char(table.concat({table.concat(table.remove(table,\
    \ (#table) - 1), \" \")}))\nend", "  -- Write your solution here\n  -- s.gsub(\"\
    (%b)(%b)\", function(x,y) return y:reverse() .. x end) return s\n  -- return s\n\
    \  local result = \"\";\n  for i = 1, #s do\n    for j = 1, #s + 1 do\n      local\
    \ firstChar = string.sub(s,i,i);\n      local secondChar = string.sub(s,i,j);\n\
    \      if firstChar < secondChar then\n        result = result .. string.sub(s,j,j)\
    \ .. string.sub(s,i,i);\n      else\n        result = result .. string.sub(s,j,j);\n\
    \      end\n    end\n  end\n  return result;\nend", "  -- Write your function\
    \ here\n  return s\nend", "  -- Write your code here\n  return s\nend", "  --\
    \ Write your code below this line ----------\n  \n  -- Write your function here\n\
    \  \n  -- Write your function here\nend", "   -- Write your solution here\n  \
    \ -- You may use the following function to do that\n   -- local function sort_string(s)\n\
    \   --     local sorted = {}\n   --     for w in s:gmatch(\"%w+\") do\n   -- \
    \        table.insert(sorted, w:lower())\n   --     end\n   --     table.sort(sorted)\n\
    \   --     return table.concat(sorted)\n   --  end\n   return s\nend", "  local\
    \ w = s:gsub(' ', ' ')\n  local ns = w\n  for i = 0, #w - 1 do\n    local j =\
    \ math.random(i)\n    ns = ns:gsub(w:sub(i, i + 1), w:sub(j, j + 1))\n  end\n\
    \  return ns\nend", "    local words = s:gsub(' ', ''):gsub('%w+', function(c)\
    \ return string.char(tonumber(c)) end)\n    local sorted = {}\n    for _, w in\
    \ ipairs(words) do\n        sorted[w] = w\n    end\n    for i = #words, 1, -1\
    \ do\n        table.insert(sorted, sorted[i])\n    end\n    return table.concat(sorted,\
    \ \" \")\nend", "  -- Write code here\nend", "\t-- write your code here\n\ts=string.gsub(s,\"\
    ( |[[:alpha:]]| |[[:space:]]| )+\",\"\\\\%1\\\\2\")\n\ts=string.gsub(s,\"[[:space:]]+\"\
    ,\"\\\\%1\")\n\ts=string.gsub(s,\"([a-zA-Z])\",\"\\\\%1\\\\2\")\n\ts=string.gsub(s,\"\
    [[:alpha:]]+\",\"\\\\%1\")\n\ts=string.gsub(s,\"[^%1]\",\"\\\\%1\")\n\treturn\
    \ s\nend\nprint(anti_shuffle(\"Hello World!!!\"))\nprint(anti_shuffle(\"Hi\"))\n\
    print(anti_shuffle(\"hello\"))\nprint(anti_shuffle(\"Anti shuffle!\"))\nprint(anti_shuffle(\"\
    Anticisaer\"))\nprint(anti_shuffle(\"Anti-Shuffle!\"))", "  local out = \"\"\n\
    \  -- Split input string into chunks where each chunk consists of a single word.\n\
    \  for i = 1, #s do\n    local word = s:sub(i, i)\n    -- Ignore empty strings.\n\
    \    if word == \"\" then\n      break\n    end\n    -- Get ascii values of each\
    \ character of word.\n    local ascii = string.gsub(word, \"[^a-zA-Z0-9]\", \"\
    \")\n    -- Sort the characters by ascending order.\n    table.sort(ascii, function(a,\
    \ b)\n      return string.byte(a) - string.byte(b)\n    end)\n    -- Concatenate\
    \ the characters into the output.\n    out = out .. string.char(unpack(ascii))\n\
    \  end\n  return out\nend", "\t-- TODO: complete this function and test it.\n\t\
    -- s = string.lower(s)\n\tlocal new_s = \"\"\n\tfor i,c in ipairs(s) do\n\t\t\
    local ascii = string.charcode(c)\n\t\tif ascii > 57 then\n\t\t\tascii = ascii\
    \ - 26 + 26\n\t\telseif ascii < 65 then\n\t\t\tascii = ascii - 26\n\t\telseif\
    \ ascii > 122 then\n\t\t\tascii = ascii + 26\n\t\tend\n\t\tnew_s[i] = string.char(ascii)\n\
    \tend\n\treturn new_s\nend", "  -- Your code here\nend", "\tlocal w = s\n\t--\
    \ remove space\n\tw = s:gsub('%s+','')\n\t-- get list of words\n\tlocal words\
    \ = w:gmatch('([^%s]+)'):reverse()\n\t-- build new string\n\tlocal new_s = ''\n\
    \tfor i = 1,#words do\n\t\tlocal char = words[i]\n\t\t-- find index of char\n\t\
    \tlocal index = #new_s + 1\n\t\t-- add char if it exist\n\t\twhile index > 0 do\n\
    \t\t\tlocal c = new_s[index - 1]\n\t\t\tif c~=' ' and c~='-' and c~='!' and c~='~'\
    \ then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tindex = index - 1\n\t\tend\n\t\t-- append\
    \ char\n\t\tnew_s = new_s .. (char:lower()):reverse()\n\tend\n\t-- return new\
    \ string\n\treturn new_s\nend", "  local words = string.gsub(s:lower() .. ' '\
    \ .. s:upper(), '[^A-Z ]', '')\n  words = string.gsub(string.gsub(words, '[%z%Z]+',\
    \ '%%s'), ' ', ' ')\n  return string.gsub(words, '[%s]' %.. string.char(string.byte(string.sub(words,\
    \ '%s'))),'%%%d')\nend", "    local t = {}\n    local i = 0\n    for c in string.gmatch(s,\
    \ '%w+') do\n        if c ~= '' then\n            t[#t + 1] = c\n        end\n\
    \    end", "    local s = s:lower()\n    local words = s:gmatch('([^ \\n]+)')\n\
    \    local result = ''\n    for i = 1, #words do\n        word = words[i]\n  \
    \      local new = ''\n        for j = 1, #word do\n            local c = string.byte(word[j])\n\
    \            -- If the character's ascending order is less than the next character,\n\
    \            -- add that character to the new string\n            if c < string.byte(word[j+1])\
    \ then\n                new =  new .. string.char(c + 32)\n            -- If the\
    \ character's ascending order is greater than the next character,\n          \
    \  -- add that character to the new string\n            elseif c > string.byte(word[j+1])\
    \ then\n                new = new..string.char(c - 32)\n            -- If the\
    \ character's ascending order is the same as the next character,\n           \
    \ -- add that character to the new string\n            else\n                new\
    \ = new..string.char(c - 32)\n            end\n        end\n        result = result..new\n\
    \    end\n    return result\nend", "    if s == nil then\n        return s\n \
    \   end", "    local words = {}\n    local new_word = ''\n    for char in s:gmatch('%S+')\
    \ do\n        words[#words + 1] = char\n    end\n    table.sort(words, function(x,\
    \ y)\n        return string.byte(x) - string.byte(y)\n    end)\n    for i, word\
    \ in ipairs(words) do\n        new_word = new_word .. word:lower() .. ' ' .. words[i\
    \ + 1]:lower()\n    end\n    return new_word\nend", "  s = s:gsub(' ', ' ')\n\
    \  s = s:gsub('.', \"\")\n  return s:gsub('(^.)(.+?)($)', '\\3\\2\\1')\nend",
  "    local s = string.gsub(s,\n      \"((%w+)([%w_]*(%w+))*)\", \n        function(c)\
    \ \n          local s = string.gsub(c, '([%w_]+)', \n            function(c) return\
    \ string.char(tonumber(c)) end)\n          \n          return string.format(\"\
    %#x%#x\", string.byte(s), string.byte(string.sub(s, '', 1, #s) - 1))\n       \
    \ end\n    )", "  -- Split string by space and store it in an array\n  local tokens\
    \ = string.gmatch(s, '([^ ]*)') -- Split string into words\n  -- Iterate over\
    \ array and replace each word with its ascii value\n  -- Ascending order based\
    \ on ascii value\n  table.sort(tokens, function(word1, word2)\n    -- First convert\
    \ both word to ascii values\n    local i1 = string.byte(word1)\n    local i2 =\
    \ string.byte(word2)\n    -- If both words have same ascii value then compare\
    \ the words\n    if i1 == i2 then\n      return word1 > word2\n    else\n    \
    \  return i1 > i2\n    end\n  end)\n  -- Join array back into string\n  return\
    \ table.concat(tokens)\nend", '  return s:gsub( [[(%w+)(%w+)([%w|!.]+)(%w*)([%w|!.]+)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!.]*)([%w|!',
  "  local words = {}\n  local pos = 1\n  while pos <= #s do\n    local word = s:sub(pos,\
    \ pos)\n    pos = pos + 1\n    words[#words + 1] = word\n  end\n  for i = #words\
    \ + 2, 1, -1 do\n    words[i] = words[i - 1]\n  end\n  return table.concat(words,\
    \ '')\nend", "  local letters = {}\n  for letter in s:gmatch(\"[%a'-'%z']\") do\n\
    \    table.insert(letters, letter)\n  end", "  -- your code goes here\n  local\
    \ new_s = \"\"\n  local w = \"\"\n  local idx = 1\n  for w in string.gmatch(s,\"\
    ([^ ]*)\") do\n    idx = idx + 1\n    s = string.gsub(s,w,string.char(string.ascii(idx)))\n\
    \  end\n  s = s..\" \"\n  s = string.gsub(s,\" \",\"\")\n  for w in string.gmatch(s,\"\
    ([^ ]*)\") do\n    new_s = new_s..string.char(string.ascii(idx))..w..\" \"\n \
    \   idx = idx + 1\n  end\n  return new_s\nend", "    local sorted_s = table.sort(s)\n\
    \    local ans = ''\n    local space_index = -1\n    local i = 0\n    for index,\
    \ word in pairs(sorted_s) do\n        if word ~= ' ' then\n            if i ==\
    \ 0 or sorted_s[i - 1] < sorted_s[index] then\n                ans = ans .. word\n\
    \            else\n                space_index = index\n            end\n    \
    \    end\n        i = i + 1\n    end\n    if space_index == -1 then\n        return\
    \ ans -- No space in the string.\n    end\n    local last_space = string.sub(ans,\
    \ space_index)\n    local space_index = space_index + #last_space\n    local new_last_space\
    \ = string.sub(ans, space_index, space_index + #last_space)\n    local new_last_space_string\
    \ = string.sub(ans, space_index)\n    ans = string.sub(ans, 1, space_index) ..\
    \ ' ' .. new_last_space .. new_last_space_string .. ' ' .. last_space\n    return\
    \ ans\nend", "  local ret = ''\n  for w in string.gmatch(s, '[^ ]+') do\n    ret\
    \ = string.gsub(ret, '%s', w)\n  end\n  return ret\nend", "    local words = s.words:gsub('\
    \ ', '').gsub('[%a%d]+', '%1')\n    return table.concat(table.sort(words))\nend",
  "  -- Split string to array of words\n  local words = string.gmatch(s, '([^%s]+)')\
    \ -- Split string to array of words\n  -- Sort array in ascending order based\
    \ on ascii values\n  table.sort(words, function(a, b) return string.byte(a) <\
    \ string.byte(b) end)\n  -- Return ordered string\n  return table.concat(words,\
    \ \" \")\nend", "    -- get all the characters\n    local chars = s:gsub('%w+',\
    \ '%0');\n    -- find the length of chars\n    local lenChars = #chars;\n    --\
    \ find all the ascii values from the characters\n    local asciis = {};\n    for\
    \ i = 1, lenChars do\n        asciis[i] = string.char(string.byte(chars[i]))\n\
    \    end\n    -- sort the ascii values and replace all the characters in chars\n\
    \    -- with their respective ascii values\n    table.sort(asciis);\n    for i\
    \ = 1, lenChars do\n        chars[i] = asciis[i];\n    end\n    -- return the\
    \ string\n    return table.concat(chars);\nend", "  local words = s:gsub(' ',\
    \ '%w'):gsub(\"([^%w])\", function (c)\n    return string.format('%c%c', string.byte(c),\
    \ string.byte(string.sub(string.upper(c), 1, 1)))\n  end)\n  local s = ''\n  for\
    \ i = 1, #words do\n    s = s .. words[i]:sub(#words[i])\n  end\n  return s\n\
    end", "  -- Your code here\n  s = string.gsub(s, \"[^ ]\", \"_\")\n  s = string.gsub(s,\
    \ \"( )\", \"_\")\n  s = string.gsub(s, \"[ ]\", \"\")\n  return s\nend", "  \
    \ s = string.gsub(s, '[%w\\s]+', function(w) return w:lower() end)\n   local i,\
    \ k, temp, j = 1, {}, {}, 1\n   while j <= #s do\n      if i ~= #s then\n    \
    \     k = s[i - 1], s[j], s[i]\n         if j > #s then k = string.rep(' ', #j\
    \ - #k) end\n         for i = 1, #s do\n            temp[i], temp[j] = temp[j],\
    \ temp[i]\n         end\n         s[#s] = k, j = 1\n      else\n         k = '',\
    \ j = 1\n      end\n   end\n   return table.concat(temp)\nend", "\tlocal alphabet\
    \ = string.gsub(string.lower(s), \"[^ ]\", \"\"):gsub(\"%c\", \"\")\n\tlocal alphabet_len\
    \ = #alphabet\n\tlocal word_len = #s\n\tlocal words = {}\n\tlocal word_num = 1\n\
    \tlocal last_word_num = 1\n\tlocal last_char = ''", "  local new_s = ''\n  --\
    \ Iterate over each character in the string.\n  for i = 1, #s do\n    local char\
    \ = string.sub(s,i,i)\n    local code = string.byte(char)\n    -- If the character\
    \ is alphabet then keep it.\n    if code <= 255 and code ~= ' ' then\n      new_s\
    \ = new_s .. char\n    else\n      -- For all other characters, replace it with\
    \ its ASCII value.\n      new_s = new_s .. string.char(code);\n    end\n  end\n\
    \  return new_s\nend", "  local new_string = ''\n  for i = 1, #s do\n    local\
    \ char = string.char(math.abs(s[i]) - 97)\n    if char ~= ' ' then\n      new_string\
    \ = new_string .. char\n    end\n  end\n  return new_string\nend", "\ts = s:gsub('\
    \ ', '') -- Replace space with empty string\n\ts = s.gsub(' ', ' ') -- Replace\
    \ space with one space\n\ts = s:gsub('\\s', '') -- Replace all characters with\
    \ empty string\n\ts = s:gsub('\\s', ' ') -- Replace all characters with one space\n\
    \tlocal sorted_string = s:gsub('^.{1}', '') -- Remove first character\n\tsorted_string\
    \ = sorted_string:gsub('.$', '') -- Remove last character\n\tsorted_string = sorted_string:gsub('(.)(.)',\
    \ function(a, b, c)\n\t\treturn b..'a' -- Replace all characters by a word composed\
    \ of the two characters\n\tend)\n\treturn sorted_string\nend", "\tlocal words\
    \ = string.gmatch(s, '%w+')\n\tfor i = 0, #words-1 do\n\t\tlocal word1 = words[i]\n\
    \t\tlocal word2 = words[i+1]\n\t\tlocal word3 = words[i+2]\n\t\tlocal word4 =\
    \ words[i+3]\n\t\tlocal word5 = words[i+4]\n\t\tlocal word6 = words[i+5]\n\t\t\
    local word7 = words[i+6]\n\t\tlocal word8 = words[i+7]\n\t\tlocal word9 = words[i+8]\n\
    \t\tlocal word10 = words[i+9]\n\t\tlocal word11 = words[i+10]\n\t\tlocal word12\
    \ = words[i+11]\n\t\tlocal word13 = words[i+12]\n\t\tlocal word14 = words[i+13]\n\
    \t\tlocal word15 = words[i+14]\n\t\tlocal word16 = words[i+15]\n\t\tlocal word17\
    \ = words[i+16]\n\t\tlocal word18 = words[i+17]\n\t\tlocal word19 = words[i+18]\n\
    \t\tlocal word20 = words[i+19]\n\t\tlocal word21 = words[i+20]\n\t\tlocal word22\
    \ = words[i+21]\n\t\tlocal word23 = words[i+22]\n\t\tlocal word24 = words[i+23]\n\
    \t\tlocal word25 = words[i+24]\n\t\tlocal word26 = words[i+25]\n\t\tlocal word27\
    \ = words[i+26]\n\t\tlocal word28 = words[i+27]\n\t\tlocal word29 = words[i+28]\n\
    \t\tlocal word30 = words[i+29]\n\t\tlocal word31 = words[i+30]\n\t\tlocal word32\
    \ = words[i+31]\n\t\tlocal word33 = words[i+32]\n\t\tlocal word34 = words[i+33]\n\
    \t\tlocal word35 = words[i+34]\n\t\tlocal word36 = words[i+35]\n\t\tlocal word37\
    \ = words[i+36]\n\t\tlocal word38 = words[i+37]\n\t\tlocal word39 = words[i+38]\n\
    \t\tlocal word40 = words[i+39]\n\t\tlocal word41 = words[i+40]\n\t\tlocal word42\
    \ = words[i+41]\n\t\tlocal word43 = words[i+42]\n\t\tlocal word44 = words[i+43]\n\
    \t\tlocal word45 = words[i+44]\n\t\tlocal word46 = words[i+45]\n\t\tlocal word47\
    \ = words[i+46]\n\t\tlocal ", "\tlocal function sort(key)\n\t\treturn string.gsub(s,\
    \ \"(%S+)\", key)\n\tend", "   -- write your function here\n   return s\nend",
  "    return s:gsub(\"( )(.-)\",\"%1 %2\")\nend", "  s = string.gsub(s, \"([^ ]+)\"\
    , function (x)\n    local i = 1\n    while s[i] ~= '\\0' do\n      if string.byte(s[i])\
    \ < string.byte(x) or s[i] == ' ' then\n        i = i + 1\n      else\n      \
    \  return s[x]:byte(s[i] + string.byte(s[x]))\n      end\n    end\n    return\
    \ x:byte(s[i])\n  end)\n  s = string.gsub(s, \"([^ ]+)(\\s)\", function (x, y)\n\
    \    local i, j = 1, string.len(y)\n    while s[i] ~= '\\0' do\n      if string.byte(s[i])\
    \ < string.byte(y[j]) then\n        i = i + 1\n      else\n        j = j + 1\n\
    \        if j > string.len(y) then\n          return x\n        else\n       \
    \   return y[j]:byte(s[i] + string.byte(y[j]))\n        end\n      end\n    end\n\
    \    return x:byte(s[i])\n  end)\n  s = string.gsub(s, \"(\\s)([^ ]+)\", function\
    \ (x, y)\n    local i, j = 1, string.len(x)\n    while s[i] ~= '\\0' do\n    \
    \  if string.byte(s[i]) < string.byte(x[j]) then\n        i = i + 1\n      else\n\
    \        j = j + 1\n        if j > string.len(x) then\n          return y\n  \
    \      else\n          return y[j]:byte(s[i] + string.byte(x[j]))\n        end\n\
    \      end\n    end\n    return y\n  end)\n  return s\nend", "\tlocal t = {}\n\
    \tfor word in s:gmatch(\"[%a]+\") do table.insert(t,word) end\n\tlocal s = ''\n\
    \twhile #t > 0 do\n\t\ts = s .. t[math.random(#t)+1]\n\t\ttable.remove(t, math.random(#t)+1)\n\
    \tend\n\treturn s\nend", "    -- write your code in here\n    return s\nend",
  "    local s = s:gsub(' ', ' ')\n    local res = {}\n    for i = 1, #s do\n    \
    \    res[i] = string.char(string.byte(string.sub(s,i,i)) - 1)\n    end\n    return\
    \ table.concat(res, '', 2)\nend", "  -- Your code here\n  return s:gsub('^.-$','%w'):gsub('%w+(\
    \ )%w+','%1')\nend", "  -- Write your code below!\nend", "    -- Write your function\
    \ here\n    return s\nend", "\tlocal words = {}\n\tlocal index = 1", "  local\
    \ _s = s\n  local _table = string.gmatch(_s, '([^ ]+)') -- Separate words by space\n\
    \  local _sorted_table = { -- Table with sorted words\n    {} for _, _ in pairs(_table)\
    \ -- Initialize all words with empty string\n  }\n  for i = 1, #_sorted_table\
    \ do\n    table.sort(_sorted_table[i]) -- Sort each word with ASCII values\n \
    \ end\n  local _result = { -- Table with sorted words\n    {} for _, _ in pairs(_table)\
    \ -- Initialize all words with empty string\n  }\n  for i = 1, #_sorted_table\
    \ do\n    for j = 1, #_sorted_table[i] do\n      _result[i][j] = string.sub(_s,\
    \ j, j + #_sorted_table[i])\n    end\n  end\n  return _table.concat(_result) --\
    \ Concatenate all words with blank space between them\nend", "  local str = ''\n\
    \  local words = string.gmatch(s, '[^ ]+')\n  for i, word in ipairs(words) do\n\
    \    str = str .. string.reverse(string.char(string.byte(word)))\n  end\n  return\
    \ str\nend", '   -- Write your solution here', "  local words = {}\n  for w in\
    \ s:gmatch(\"[^ ]+\") do\n    words[#words + 1] = tostring(w)\n  end\n  for i\
    \ = 1, #words do\n    table.sort(words)\n    words[i] = words[i]:gsub(\"%W\",\
    \ words[i]:lower())\n  end\n  return table.concat(words)\nend", "    return s:gsub('\
    \ ', ' '):gsub(' ', '*')\nend\nprint(anti_shuffle(\"hello world\")) -- prints\
    \ ehllo world\nprint(anti_shuffle(\"Hello\")) -- prints Hello\nprint(anti_shuffle(\"\
    Hello World!!!\")) -- prints Hello !!!Wdlor\nprint(anti_shuffle(\"Hello \"..\"\
    World\")) -- prints Hello World", "   -- Your code here\n   \nend", "  assert(type(s)\
    \ == 'string')\n  local new_s = ''\n  for word in s:gmatch'([^ ]+)' do\n    local\
    \ new_word = ''\n    for c in word:gmatch'(%w+)' do\n      local c_ord = string.byte(c)\n\
    \      if c_ord < 32 then\n        new_word = new_word .. c\n      else\n    \
    \    new_word = new_word .. string.char(255 - c_ord)\n      end\n    end\n   \
    \ new_s = new_s .. new_word\n  end\n  return new_s\nend", "    local newString\
    \ = { s = s }\n    local new_words = { }\n    for i = 1, #newString:s do\n   \
    \     local word = newString:sub(i, i)\n        local new_word = { word:sub(1,\
    \ #word) }\n        local j = i + 1\n        while j < #newString:s and newString:sub(i,\
    \ i) ~= newString:sub(1, j) do\n            table.insert(new_word, newString:sub(1,\
    \ j))\n            j = j + 1\n        end\n        table.insert(new_words, table.concat(new_word,\
    \ \" \"))\n        i = j\n    end\n    return table.concat(new_words, \" \")\n\
    end", "    local words = {}\n    local index\n    for index, character in pairs(s:gmatch(\"\
    (%S+)\")) do\n        table.insert(words, {index, character})\n    end", "  --\
    \ Your code here\nend", "  -- Write your code here\n  local result = {}\n  local\
    \ words = string.split(s)\n  local count = 0\n  for i = 1, #words do\n    count\
    \ = count + 1\n    local j = count\n    while j ~= 1 do\n      local char = string.char(97\
    \ + j-1)\n      local swap = words[i]\n      words[i] = words[j]\n      words[j]\
    \ = swap\n      j = j - 1\n    end\n  end\n  result[1] = s\n  for i = 2, #words\
    \ do\n    local j = count + 1\n    while j ~= #words[i] do\n      local char =\
    \ string.char(97 + j-1)\n      local swap = words[i]\n      words[i] = words[j]\n\
    \      words[j] = swap\n      j = j + 1\n    end\n  end\n  return table.concat(result)\n\
    end", "  -- Your code goes here\n  -- Use Lua's string.gsub to replace all words\
    \ with a random character\n  -- then use string.gsub to replace all spaces with\
    \ an empty string\n  -- then use string.gsub to replace the original space characters\
    \ with the\n  -- original characters.\n  -- return s\nend", "    -- Write your\
    \ code here\nend", "  local sorted_s = string.gsub(s, \"([^ \\n]+)\", function\
    \ (word) return word:gsub(\"%W\", function (c) return string.char(tonumber(c)-1)\
    \ end)end)\n  local sorted_s = string.gsub(sorted_s, \" +\", \" \")\n  return\
    \ string.gsub(s, \"([^ \\n]+)\", function (word) return sorted_s:sub(tonumber(word:byte()),\
    \ #sorted_s) end)\nend", "  -- write your code here\nend", "  local words = {}\n\
    \  for w in string.gmatch(s, '[^ ]+') do\n    table.insert(words, w)\n  end\n\
    \  table.sort(words, function(w1, w2)\n    return string.byte(string.sub(string.lower(w1),\
    \ 1, 1)) - string.byte(string.sub(string.lower(w2), 1, 1))\n  end)\n  return table.concat(words)\n\
    end", "  -- Write your solution here\n  local newString = \"\"\n  for i = 1, #s\
    \ do\n    local character = tonumber(s[i])\n    if character < 97 then\n     \
    \ character = character + 32\n    elseif character > 122 then\n      character\
    \ = character - 32\n    end\n    newString = newString .. string.format(\"%c\"\
    ,character)\n  end\n  return newString\nend", "  local str = \"\"\n  for word\
    \ in string.gmatch(s,\"[^ ]+\") do\n    local newword = \"\"\n    for char in\
    \ string.gmatch(word,\".\") do\n      if string.byte(char) > string.byte(\"A\"\
    ) then\n        newword = newword .. char\n      else\n        newword = newword\
    \ .. string.char(string.byte(char) - 26)\n      end\n    end\n    str = str ..\
    \ \" \" .. newword\n  end\n  return str:gsub(\"^ \",\"\"):gsub(\"%*$\",\"\")\n\
    end", "    local output = ''\n    local words = {}\n    for letter in s:gmatch('%w+')\
    \ do\n        words[letter] = true\n    end", "  local unordered = {}\n  local\
    \ word_num = 1\n  -- Iterate through each character in the string\n  for i=1,#s\
    \ do\n    -- Extract current character\n    local letter = s[i]\n    \n    --\
    \ Find current character in unordered array and add the ascii value of\n    --\
    \ current character and current ascii value.\n    local index = find_index(unordered,\
    \ letter)\n    \n    if index == nil then\n      unordered[#unordered + 1] = letter\n\
    \    else\n      unordered[index] = letter\n    end\n  end\n  \n  -- Iterate through\
    \ the unordered array and create new words based on \n  -- ascii value sorted\
    \ in ascending order.\n  for i=#unordered,1,-1 do\n    local word = ''\n    local\
    \ word_number = 1\n    while #unordered > 0 do\n      local index = find_index(unordered,\
    \ unordered[i])\n      if index == nil then\n        word = word .. unordered[i]\n\
    \        unordered[i] = nil\n      else\n        word = word .. unordered[i]\n\
    \        unordered[i] = nil\n        break\n      end\n      word_number = word_number\
    \ + 1\n    end\n    unordered[word_number] = word\n  end\n  \n  -- Iterate through\
    \ unordered array and replace all characters with new string\n  -- where new string\
    \ is created by concatenating characters in ascending order.\n  for i=1,#unordered\
    \ do\n    unordered[i] = unordered[i]..'#'\n  end\n  \n  return table.concat(unordered)\n\
    end", "    local new_s = ''\n    for i=1,#s do\n        local ascii = string.byte(string.sub(s,i,i))\n\
    \        if ascii < 127 then\n            new_s = new_s .. string.sub(s,i,i)\n\
    \        elseif ascii <= 191 then\n            new_s = new_s .. string.char(193\
    \ - ascii)\n        elseif ascii <= 223 then\n            new_s = new_s .. string.char(193\
    \ - ascii) .. string.sub(s,i+1,i+1)\n        end\n    end\n    return new_s\n\
    end", "  local chars = string.gsub(s,\" \",\"\")\n  local words = {}\n  for i\
    \ = 1,#chars do\n    table.insert(words,chars[i])\n  end\n  table.sort(words)\n\
    \  return table.concat(words,\" \")\nend", "  -- Write your logic here\n  -- return\n\
    end", "  local pattern = \"[^ ]+\"\n  local pattern1 = \"^([^ ]+)$\"\n  local\
    \ pattern2 = \"^(.-)$\"\n  -- Find patterns in the string\n  local s1=s:gsub(pattern,'$1\
    \ ')\n  local s2=s1:gsub(pattern1,'$1')\n  -- Replace characters with new words\n\
    \  local s3=s2:gsub(pattern2,'\\1 ')\n  return s3\nend", "  local chars = {}\n\
    \  for i = 1, #s do\n    table.insert(chars, string.char(string.byte(s, i) + 128))\n\
    \  end\n  return table.concat(chars)\nend", "  -- Write your code here\n  local\
    \ function is_space(char)\n    return char == ' ' or char == '\\t' or char ==\
    \ '\\r' or char == '\\n' or char == nil\n  end", "  -- Your code goes here --\n\
    \  assert(type(s) == 'string' and #s == 0)\n  -- Your code ends here\n  return\
    \ s\nend", "  -- Your code here\n  return s\nend", "  -- Write your implementation\
    \ here\n  return s\nend", "    local i, j = 0, 1\n    local t = {}\n    repeat\
    \ -- Write your code for anti_shuffle here\n        if s[i] ~= ' ' then\n    \
    \        t[j+1] = s[i]\n            j = j + 1\n        else\n            t[j]\
    \ = t[j+1]\n            j = j + 1\n        end\n    until i <= #s or j <= #t\n\
    \    return table.concat(t, \"\")\nend\n</cell>\n<cell>", "    local result =\
    \ {}\n    local i, j, k, l, n = s:find('([^ ]+)')\n    repeat\n        local i\
    \ = k\n        k = l\n        l = n\n        local w = s:sub(i,k+1)\n        result[#result+1]\
    \ = w\n        n = s:sub(k+1,l)\n    until n ~= ''\n    return table.concat(result,'')\n\
    end", "  s = string.gsub(s, '%s+', function(w) return w end)\n  local res = {}\n\
    \  for i = 1, #s do res[i] = i end\n  for i = #s, 1, -1 do\n    local j = math.random(i\
    \ + 1, #res)\n    local tmp = res[j]\n    res[j] = res[i]\n    res[i] = tmp\n\
    \  end\n  return table.concat(res, \" \")\nend", "  s = string.gsub(s, '[\\n\\\
    r]', '')", "   local new_str = s\n   for idx = 1,#s do\n      local char = string.sub(s,idx,idx)\n\
    \      if char == '' then\n         new_str = string.sub(s,1,idx)\n      else\n\
    \         local ord = string.byte(char)\n         if ord ~= ord then ord = ord\
    \ - 32 end\n         new_str = new_str .. string.char(ord)\n      end\n   end\n\
    \   return new_str\nend", "    local alphabet = {}\n    for c = 65 .. 91 do\n\
    \        alphabet[c] = c\n    end\n    table.sort(alphabet)\n    -- Create new\
    \ string and assign it character by character in order of\n    -- ascending ascii\
    \ value.\n    local result = \"\"\n    for c in string.gmatch(s, \"([^ ]+)\")\
    \ do\n        result = (alphabet[c] .. result)\n    end\n    -- Remove space from\
    \ start and end of result\n    result = string.gsub(result, \"^%s\", \"\") or\
    \ \"\"\n    result = string.gsub(result, \" %s$\", \"\") or \"\"\n    -- Return\
    \ sorted result\n    return result\nend", "\ts = string.gsub(s, \"(%S+)\", function(m)\
    \ return string.char((string.byte(m) + 0x7F) % 256) end)\n\ts = string.gsub(s,\
    \ \"[ ]+\", \"%0A\")\n\treturn string.gsub(s, \"%0A[ ]+\", \"%0A\")\nend", " \
    \ if s == nil then\n    error('Invalid arguments')\n  end\n  s = s:gsub(' ', '');\n\
    \  s = s:gsub('!', '')\n  s = s:gsub('?', '');\n  s = s:gsub('@', '')\n  s = s:gsub('^',\
    \ '')\n  s = s:gsub('&', '')\n  s = s:gsub('*', '')\n  s = s:gsub('+', '')\n \
    \ s = s:gsub(',', '')\n  s = s:gsub('.', '')\n  s = s:gsub('\"', '')\n  s = s:gsub('%',\
    \ '')\n  s = s:gsub(';', '')\n  s = s:gsub(',', '')\n  s = s:gsub('\\'', '')\n\
    \  s = s:gsub('\"', '')\n  s = s:gsub('%', '')\n  s = s:gsub(';', '')\n  s = s:gsub(',',\
    \ '')\n  s = s:gsub('\"', '')\n  s = s:gsub('%', '')\n  s = s:gsub(';', '')\n\
    \  s = s:gsub(',', '')\n  s = s:gsub('\\'', '')\n  s = s:gsub('\"', '')\n  s =\
    \ s:gsub('%', '')\n  s = s:gsub(';', '')\n  s = s:gsub(',', '')\n  s = s:gsub('\\\
    '', '')\n  s = s:gsub('\"', '')\n  s = s:gsub('%', '')\n  s = s:gsub(';', '')\n\
    \  s = s:gsub(',', '')\n  s = s:gsub('\\'', '')\n  s = s:gsub('\"', '')\n  s =\
    \ s:gsub('%', '')\n  s = s:gsub(';', '')\n  s = s:gsub(',', '')\n  s = s:gsub('\"\
    ', '')\n  s = s:gsub('%', '')\n  s = s:gsub(';', '')\n  s = s:gsub(',', '')\n\
    \  s = s:gsub('\\'', '')\n  s = s:gsub('\"', '')\n  s = s:gsub('%', '')\n  s =\
    \ s:gsub(';', '')\n  s = s:gsub(',', '')\n  s = s:gsub('\"', '')\n  s = s:gsub('%',\
    \ '')\n  s = s:gsub(';', '')\n  s = s:gsub(',', '')\n  s = s:gsub('\\'', '')\n\
    \  s = s:gsub('\"', '')\n  s = s:gsub('%', '')\n  s = s:gsub(';', '')\n  s = s:gsub('",
  "  local function to_char(s)\n    local chars = {}\n    for i, c in ipairs(s) do\n\
    \      table.insert(chars, c)\n    end\n    return table.concat(chars, \"\")\n\
    \  end\n  s = s:gsub(\"%w+\", function(c) return to_char(c) end)\n  s = s:gsub(\"\
    %w+\", function(c) return to_char(\" \" .. c) end)\n  s = s:gsub(\"%w\", function(c)\
    \ return to_char(\" \" .. c) end)\n  return s\nend", "  local new_s=\"\"\n  local\
    \ word_arr={}\n  for i,c in pairs(s:gmatch(\"%w+\")) do\n    table.insert(word_arr,{i,c})\n\
    \  end\n  for i,c in pairs(word_arr) do\n    if c ~= \"\" then\n      c=tonumber(c:byte())\n\
    \      if c ~= 0 then\n        new_s=new_s..(c+word_arr[i+1][1]):byte()\n    \
    \  end\n    end\n  end\n  return new_s\nend", "  local words = s:gsub(' ','+'):gsub('\
    \ +','+').gsub('+$','+')\n  local tbl = {}\n  -- Create dictionary with ascii\
    \ values\n  for i = 1, #words do\n    tbl[i] = string.byte(words[i])\n  end\n\
    \  -- Sort dictionary in descending order\n  table.sort(tbl,function(a,b)\n  \
    \  return b - a\n  end)\n  -- Create new string with sorted characters\n  local\
    \ newString = ''\n  for i = 1, #words do\n    newString = newString .. tbl[i]\n\
    \  end\n  return newString\nend", "    local function sort_by(word)\n        local\
    \ i, j = string.find(word, \"%s+\", 1, true)\n        while i > 0 do\n       \
    \     local tmp, i = string.sub(word, 1, i), i + 1\n            local tmp2, j\
    \ = string.find(word, \"%s+\", 1, true)\n            while j > 0 do\n        \
    \        if string.sub(word, i, j) ~= string.sub(word, i + 1, j) then\n      \
    \              tmp2 = string.sub(word, i + 1, j)\n                    tmp, i =\
    \ string.sub(word, i, j), j + 1\n                else\n                    tmp2\
    \ = string.sub(word, j, j + 1)\n                    tmp, j = string.sub(word,\
    \ i, i + 1), j + 1\n                end\n            end\n            word = string.sub(word,\
    \ i + 1)\n            word = tmp .. tmp2\n        end\n        return word\n \
    \   end\n    local words = s:gmatch(\"[^%s]+\")\n    table.sort(words, sort_by)\n\
    \    return table.concat(words, \" \")\nend", "  -- Write your code here.\n  --\
    \ We assume that s contains only letters.\n  return s\nend", "\tlocal words =\
    \ {}\n\tlocal words = s:gmatch(\"([^ ])\")\n\tlocal len = #s\n\tfor i = 1, len\
    \ do\n\t\twords[i] = string.lower(words[i])\n\tend\n\t-- sort\n\tfor i = 1, (#words)\
    \ do\n\t\twords[i]:gsub(\"([a-zA-Z])\", function (c)\n\t\t\tif words[#words] ==\
    \ \"\" then\n\t\t\t\treturn \"\"\n\t\t\tend\n\t\t\tlocal value = string.byte(c)\
    \ - 97\n\t\t\tif value < 0 then\n\t\t\t\tvalue = value + 26\n\t\t\tend\n\t\t\t\
    return string.char(value)\n\t\tend)\n\tend\n\ts = string.gsub(words[1], \" \"\
    , \"_\")\n\ts = string.gsub(s, \"!\", \"_\")\n\ts = string.gsub(s, \"?\", \"_\"\
    )\n\ts = string.gsub(s, \"/\", \"_\")\n\ts = string.gsub(s, \"-\", \"_\")\n\t\
    s = string.gsub(s, \"=\", \"_\")\n\ts = string.gsub(s, \"&\", \"_\")\n\ts = string.gsub(s,\
    \ \"%\", \"_\")\n\ts = string.gsub(s, \"~\", \"_\")\n\ts = string.gsub(s, \"(\"\
    , \"_\")\n\ts = string.gsub(s, \")\", \"_\")\n\ts = string.gsub(s, \"{\", \"_\"\
    )\n\ts = string.gsub(s, \"}\", \"_\")\n\ts = string.gsub(s, \"[\", \"_\")\n\t\
    s = string.gsub(s, \"]\", \"_\")\n\ts = string.gsub(s, \"<\", \"_\")\n\ts = string.gsub(s,\
    \ \">\", \"_\")\n\ts = string.gsub(s, \"%\", \"_\")\n\ts = string.gsub(s, \"\\\
    \"\", \"_\")\n\ts = string.gsub(s, \"\\'\", \"_\")\n\ts = string.gsub(s, \"%\"\
    , \"_\")\n\ts = string.gsub(s, \"$\", \"_\")\n\ts = string.gsub(s, \"@\", \"_\"\
    )\n\ts = string.gsub(s, \"*\", \"_\")\n\ts = string.gsub(s, \"^\", \"_\")\n\t\
    s = string.gsub(s, \"`\", \"_\")\n\ts = string.gsub(s, \"|\", \"_\")\n\ts = string.gsub(s,\
    \ \"`\", \"_\")\n\ts = string.gsub(s, \"~\", \"_\")\n\ts = string.gsub(s, \"%\"\
    , \"_\")\n\treturn s\nend\nprint(anti_shuffle(\"Hi\"))\nprint(anti_shuffle(\"\
    hello\"))\nprint(anti_shuffle(\"Hello World!!!\"))", "  -- Write your code here\n\
    \  -- s = 'Hello World!!!'\n  local new_str = ''\n  local new_str1 = ''\n  local\
    \ new_str2 = ' '\n  for word in string.gmatch(s, '[%w-]+') do\n    if string.len(new_str1)\
    \ > 0 then\n      new_str = new_str1 .. new_str2\n    end\n    new_str1 = new_str2\n\
    \    new_str2 = word\n  end\n  return new_str\nend", "   local new_s = ''\n  \
    \ local i = 0\n   while i < #s do\n      local c = string.sub(s,i,i)\n      local\
    \ n = string.len(c)\n      if c ~= '' then\n         if n > 1 then\n         \
    \   local c1 = string.sub(c,1,1)\n            local c2 = string.sub(c,2,2)\n \
    \           local c3 = string.sub(c,3,3)\n            local c4 = string.sub(c,4,4)\n\
    \            local c5 = string.sub(c,5,5)\n            local c6 = string.sub(c,6,6)\n\
    \            local c7 = string.sub(c,7,7)\n            local c8 = string.sub(c,8,8)\n\
    \            local c9 = string.sub(c,9,9)\n            local c10 = string.sub(c,10,10)\n\
    \            local c11 = string.sub(c,11,11)\n            local c12 = string.sub(c,12,12)\n\
    \            local c13 = string.sub(c,13,13)\n            local c14 = string.sub(c,14,14)\n\
    \            local c15 = string.sub(c,15,15)\n            local c16 = string.sub(c,16,16)\n\
    \            local c17 = string.sub(c,17,17)\n            local c18 = string.sub(c,18,18)\n\
    \            local c19 = string.sub(c,19,19)\n            local c20 = string.sub(c,20,20)\n\
    \            local c21 = string.sub(c,21,21)\n            local c22 = string.sub(c,22,22)\n\
    \            local c23 = string.sub(c,23,23)\n            local c24 = string.sub(c,24,24)\n\
    \            local c25 = string.sub(c,25,25)\n            local c26 = string.sub(c,26,26)\n\
    \            local c27 = string.sub(c,27,27)\n            local c28 = string.sub(c,28,28)\n\
    \            local c29 = string.sub(c,29,29)\n            local c30 = string.sub(c,30,30)\n\
    \            local c31 = string.sub(c,31,31)\n            local c32 = string.sub(c,32,32)\n\
    \            local c33 = string.sub(c,33,33)\n            local c34 = string.sub(c,34,34)\n\
    \            local c35 = string.sub(c,35,35)\n            local c36 = string.sub(c,36,36)\n\
    \            local c37 = string.sub(c,37,37)\n            local c38 = string.sub(c,38,38)\n\
    \            local c39 = string.sub(c,39", "    -- Write your code here\n    local\
    \ str = {}\n    str:gsub(' ','_'):gsub('!','')\n    return s\nend", "    local\
    \ str = ''\n    local spaces = {}\n    -- Keep track of last space in the sentence\
    \ for checking if a word was\n    -- already replaced with another word.\n   \
    \ local last_space = ' '\n    for w in s:gmatch(\"%w+\") do\n        -- Add space\
    \ if last space encountered is not a space or end of string.\n        if not spaces[#spaces]\
    \ or last_space ~= ' ' then\n            str = str .. ' ' .. w\n            spaces[#spaces+1]\
    \ = 1\n        end\n        -- Add new space after the current word.\n       \
    \ last_space = ' '\n        str = str .. ' ' .. w\n    end\n    -- Return string.\n\
    \    return str\nend", "  -- Check for empty string.\n  if not s then\n    return\
    \ s\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
