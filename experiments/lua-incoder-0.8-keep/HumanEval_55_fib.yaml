name: HumanEval_55_fib
language: lua
prompt: "-- Return n-th Fibonacci number.\n-- >>> fib(10)\n-- 55\n-- >>> fib(1)\n\
  -- 1\n-- >>> fib(8)\n-- 21\nlocal function fib(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fib\n\
  \    lu.assertEquals(candidate(10), 55)\n    lu.assertEquals(candidate(1), 1)\n\
  \    lu.assertEquals(candidate(8), 21)\n    lu.assertEquals(candidate(11), 89)\n\
  \    lu.assertEquals(candidate(12), 144)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if n < 1 then\n    return 1\n  else\n    if n == 1 then\n      return\
    \ 1\n    else\n      return fib(n-2) + fib(n-1)\n    end\n  end\nend", "    if\
    \ n < 2 then\n        return 1\n    end\n    return fib(n-1) + fib(n-2)\nend",
  "  if n < 1 then return nil end\n  if n == 1 or n == 2 then return 1 end\n  return\
    \ fib(n - 1) + fib(n - 2)\nend", "  if n==0 then\n    return 0\n  elseif n==1\
    \ then\n    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend",
  "   if n <= 1 then return n end\n   return fib(n-1) + fib(n-2)\nend", "  local a,\
    \ b = 0, 1\n  while n ~= 0 do\n    a, b = b, a + b\n    n = n - 1\n  end\n  return\
    \ a\nend", "  if n < 2 then\n    return 1\n  else\n    return fib(n-2) + fib(n-1)\n\
    \  end\nend", "    if n < 2 then\n        return n\n    else\n        return fib(n-2)\
    \ + fib(n-1)\n    end\nend", "  if n<1 then\n    return 1\n  elseif n==1 then\n\
    \    return 1\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "    local\
    \ prev, curr = 1, 1\n    for i = 1, n do\n        prev, curr = curr, prev + curr\n\
    \    end\n    return curr\nend", "  if n < 2 then\n    return 1\n  else\n    return\
    \ fib(n - 1) + fib(n - 2)\n  end\nend", "  if n<2 then return n else return fib(n-2)\
    \ + fib(n-1) end\nend", "    local fib_cache = {}\n    if n <= 1 then\n      \
    \  return n\n    end\n    if fib_cache[n] then\n        return fib_cache[n]\n\
    \    end\n    local a = fib(n-1)\n    local b = fib(n-2)\n    local c = a + b\n\
    \    fib_cache[n] = c\n    return c\nend", "  if n < 2 then\n    return n\n  elseif\
    \ n < 3 then\n    return fib(n-2) + fib(n-1)\n  else\n    return fib(n-2) + fib(n-2)\n\
    \  end\nend", "  if n == 1 or n == 2 then\n    return n\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "  if n <= 0 then\n    error 'fib expects n > 0, got\
    \ ' .. n\n  end\n  if n == 1 or n == 2 then\n    return n\n  end\n  return fib(n-2)\
    \ + fib(n-1)\nend", "\tif n <= 2 then\n\t\treturn 1\n\tend\n\tlocal fibN = fib(n\
    \ - 2)\n\tlocal fibM = fib(n - 1)\n\treturn fibM + fibN\nend", "  if n < 0 then\n\
    \    return nil\n  elseif n <= 1 then\n    return n\n  else\n    return fib(n-2)\
    \ + fib(n-1)\n  end\nend", "    if n == 0 then\n        return 0\n    elseif n\
    \ == 1 then\n        return 1\n    elseif n == 2 then\n        return 2\n    end\n\
    \    return fib(n - 1) + fib(n - 2)\nend", "  if n < 2 then\n    return n\n  end\n\
    \  local a = fib(n-1)\n  local b = fib(n-2)\n  return a+b\nend", "  if n <= 0\
    \ then\n    error('Argument must be non-negative and non-nil')\n  else\n    if\
    \ n == 1 then\n      return 1\n    else\n      return fib(n-1) + fib(n-2)\n  \
    \  end\n  end\nend", "  if n < 2 then return 1 end\n  return fib(n-2) + fib(n-1)\n\
    end", "  if n < 0 then\n    return nil\n  elseif n < 2 then\n    return 1\n  else\n\
    \    return fib(n - 1) + fib(n - 2)\n  end\nend\nreturn {\n  fib = fib\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI agree with you in that this is an interesting approach, however,\
    \ this doesn't really answer the question.\n<|/ c |>\n<| a tags=lua,lua-table,lua-patterns,fibonacci\
    \ |>\n<code>", "  if n < 0 then return 0 end\n  if n < 2 then return n end\n \
    \ return fib(n - 1) + fib(n - 2)\nend", "  if n==1 then\n    return 1\n  else\n\
    \    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n == 1 or n == 2 then\n\
    \    return 1\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "    local\
    \ x, y = 0, 1\n    for _ = 1, n do\n        x, y = y, x + y\n    end\n    return\
    \ x\nend", "  if n <= 0 then\n    -- Return the zero value if n <= 0\n    return\
    \ 0\n  elseif n <= 1 then\n    -- Return the one value if n <= 1\n    return 1\n\
    \  else\n    -- Return the fibonacci number for n\n    return fib(n - 1) + fib(n\
    \ - 2)\n  end\nend", "  if n < 2 then\n    return n\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "    if n == 0 then\n        return 0\n    else\n \
    \       return fib(n-1) + fib(n-2)\n    end\nend", "  if n <= 1 then\n    return\
    \ n\n  end", "  if n < 0 then\n    return nil\n  end\n  if n < 1 then\n    return\
    \ 1\n  end\n  if n == 1 then\n    return 1\n  end\n  if n == 2 then\n    return\
    \ 2\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n <= 2 then\n    return\
    \ n\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n <= 0 then\
    \ return 1 end\n  return fib(n-1) + fib(n-2)\nend", "  if n < 0 then\n    return\
    \ -1\n  end\n  if n == 0 then\n    return 1\n  end\n  if n == 1 then\n    return\
    \ 1\n  end\n  local a\n  local b\n  if n == 2 then\n    return a\n  end\n  local\
    \ fib\n  for fib = 1, n do\n    a, b = b, a + b\n  end\n  return b\nend", "  if\
    \ n <= 1 then\n    return n\n  else\n    return fib(n-2) + fib(n-1)\n  end\nend",
  "\tlocal fibonacci = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55}\n\treturn fibonacci[n]\
    \ or fib(n-1) + fib(n-2)\nend", "  if n==0 then\n    return 1\n  end\n  if n==1\
    \ then\n    return 1\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n <\
    \ 2 then return n end\n  return fib(n-1) + fib(n-2)\nend", "  if n < 1 then return\
    \ n end\n  return fib(n-1) + fib(n-2)\nend", "    local prev, curr, i = 1, 1,\
    \ 0\n    while i < n do\n        prev, curr = curr, prev + curr\n        i = i\
    \ + 1\n    end\n    return curr\nend", "  if n <= 1 then\n    return n\n  else\n\
    \    return fib(n - 1) + fib(n - 2)\n  end\nend\n</cell>\n<text>\nExercise\nWrite\
    \ a function, called fib_list, which takes as input a list of numbers and returns\
    \ its Fibonacci numbers.", "  if n < 2 then return 1 end\n  local f = 1\n  local\
    \ i = 2\n  while i <= n do\n    f, i = i, f+i\n  end\n  return f\nend", "    if\
    \ n < 2 then return 1 end\n    return fib(n - 1) + fib(n - 2)\nend", "\tif n <=\
    \ 1 then\n\t\treturn n\n\tend\n\tlocal function f(a, b)\n\t\treturn a + b\n\t\
    end\n\treturn f(fib(n - 2), fib(n - 1))\nend", "\tif n < 0 then return nil end\n\
    \tif n < 1 then return n end\n\treturn fib(n-1) + fib(n-2)\nend", "  if n < 2\
    \ then\n    return n\n  else\n    return fib(n-2) + fib(n-1)\n  end\nend", " \
    \ if n <= 1 then\n    return n\n  else\n    return fib(n-2) + fib(n-1)\n  end\n\
    end", "\tif n < 1 then\n\t\terror(\"fib expected integer >= 1, got \" .. tostring(n))\n\
    \tend\n\tlocal a,b = 0,1\n\tfor i = 1, n do\n\t\ta,b = b,a+b\n\tend\n\treturn\
    \ a\nend", "  -- base case\n  if n < 0 then return 0 end\n  if n == 0 then return\
    \ 1 end\n  if n == 1 then return 1 end\n  \n  -- recursive case\n  local result\
    \ = fib(n - 1) + fib(n - 2)\n  return result\nend", "    if n < 2 then\n     \
    \   return n\n    else\n        return fib(n-2) + fib(n-1)\n    end\nend", " \
    \ if n < 2 then\n    return 1\n  else\n    return fib(n-1) + fib(n-2)\n  end\n\
    end", "  if n < 0 then return nil end\n  if n == 0 then return 0 end\n  if n ==\
    \ 1 then return 1 end\n  return fib(n - 1) + fib(n - 2)\nend", "   if n <= 1 then\n\
    \      return n\n   else\n      return fib(n-2) + fib(n-1)\n   end\nend", "  if\
    \ n <= 1 then return n end\n  return fib(n - 1) + fib(n - 2)\nend", "\tif n <\
    \ 2 then return n else return fib(n-1) + fib(n-2) end\nend", "  local a,b = 0,1\n\
    \  for i = 1, n do\n    local c = a + b\n    a = b\n    b = c\n  end\n  return\
    \ b\nend", "  if n <= 1 then\n    return 1\n  else\n    return fib(n-1) + fib(n-2)\n\
    \  end\nend", "    local prev, cur\n    prev, cur = 0, 1\n    for i = 1, n do\n\
    \        prev, cur = cur, prev + cur\n    end\n    return cur\nend", "  if n ==\
    \ 0 or n == 1 or n == 2 then\n    return 1\n  else\n    return fib(n - 1) + fib(n\
    \ - 2)\n  end\nend", "  if n==1 then\n    return 1\n  elseif n==2 then\n    return\
    \ 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n < 0 then\n\
    \    return nil\n  end\n  if n == 0 then\n    return 0\n  end\n  if n == 1 then\n\
    \    return 1\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "  -- Make sure\
    \ that n is non-negative integer. Otherwise return the error\n  -- message.\n\
    \  if n ~= math.floor(n) then\n    return \"Argument should be non-negative integer.\"\
    \n  end", "  if n <= 2 then return n\n  else return fib(n-1) + fib(n-2)\n  end\n\
    end", "\tif n==1 then\n\t\treturn 1\n\telse\n\t\treturn fib(n-1)+fib(n-2)\n\t\
    end\nend", "    if n <= 1 then return n\n    else return fib(n-1) + fib(n-2) end\n\
    end", "  if n <= 0 then return 1 end\n  return fib(n-1) + fib(n-2)\nend", "  if\
    \ n <= 2 then\n    return n\n  end\n  return fib(n - 1) + fib(n - 2)\nend", " \
    \   if n < 2 then\n        error(\"fib: arg is smaller than 2\")\n    end\n  \
    \  return n + fib(n-1)\nend", "  if n < 0 then return nil end\n  if n < 1 then\
    \ return 1 end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n <= 1 then\n  \
    \  return 1\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n < 2 then\n\
    \    return n\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "  -- Local\
    \ Variables: n\n  -- Function called by GCD\n  -- >>> fib(0)\n  -- 0\n  -- >>>\
    \ fib(1)\n  -- 1\n  -- >>> fib(8)\n  -- 21\n  if n < 1 then\n    return 0\n  end\n\
    \  if n < 2 then\n    return n\n  end\n  return fib(n-2) + fib(n-1)\nend", " \
    \ -- cache Fibonacci numbers to avoid recalculation\n  if _fib[n] then return\
    \ _fib[n] end\n  if n < 2 then return 1 end\n  _fib[n] = _fib[n - 2] + _fib[n\
    \ - 1]\n  return _fib[n]\nend", "\tif n < 0 then return nil end\n\tif n == 0 then\
    \ return 0 end\n\tif n == 1 then return 1 end\n\tlocal a = fib(n-1) + fib(n-2)\n\
    \treturn a\nend", "\t-- Exit if not a positive integer.\n\t-- >>> fib(3.1)\n\t\
    -- Traceback (most recent call last):\n\t--   File \"<stdin>\", line 1, in ?\n\
    \t--   File \"fibonacci.py\", line 10, in fib\n\t--     return fib(n-1) + fib(n-2)\n\
    \t-- Recursion limit exceeded.\n\tif type(n) ~= 'number' then return nil; end\n\
    \tif n <= 1 then return n; end\n\t-- Return nth Fibonacci number.\n\treturn fib(n-1)\
    \ + fib(n-2)\nend", "  -- Base cases.\n  if n == 0 or n == 1 then return n end\n\
    \  if n == 2 then return 1 end\n  \n  -- Recursive case.\n  return fib(n - 1)\
    \ + fib(n - 2)\nend", "  if n==0 or n==1 then\n    return 1\n  else\n    return\
    \ fib(n-1) + fib(n-2)\n  end\nend", "  if n < 1 then return 1 else return fib(n-2)\
    \ + fib(n-1) end\nend", "\tif n < 1 or n > fib.nth then return nil end\n\tif fib.memoize\
    \ then\n\t\treturn fib.memo[n]\n\tend\n\tlocal a,b = 1,1\n\tfor i = 1, n do\n\t\
    \tlocal tmp = a\n\t\ta = b\n\t\tb = tmp + b\n\tend\n\tfib.nth = n\n\treturn b\n\
    end", "  if n < 1 then\n    return 0\n  end", "  if n <= 2 then return n else\n\
    \    return fib(n-2) + fib(n-1)\n  end\nend", "  if n < 2 then return n end\n\
    \  return fib(n-1) + fib(n-2)\nend", "  if n <= 2 then\n    return n\n  else\n\
    \    return fib(n-2) + fib(n-1)\n  end\nend", "\t-- Base case.\n\tif n < 0 then\n\
    \t\terror(\"invalid argument #1 to fib(n): negative number\", 2)\n\tend", "  if\
    \ n <= 2 then\n    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\n\
    end", "    if n < 2 then\n        return 1\n    end\n    return fib(n-1) + fib(n-2)\n\
    end", "\tlocal function f1(t, f)\n\t\tif t <= 0 then\n\t\t\treturn f()\n\t\telse\n\
    \t\t\treturn f(t-1) + f(t-2)\n\t\tend\n\tend", "    local i\n    local a, b =\
    \ 0, 1\n    if n > 0 then\n        a, b = b, a + b\n        i, a = a + 1, b\n\
    \        while i <= n do\n            i = i + a\n            a, b = b, a + b\n\
    \        end\n    end\n    return i\nend", "  if n<2 then\n    return n\n  else\n\
    \    return fib(n-1)+fib(n-2)\n  end\nend", "  -- Base case.\n  if n < 2 then\
    \ return 1 end", "\tlocal a = 1\n\tlocal b = 1\n\tlocal i = 2\n\twhile i <= n\
    \ do\n\t\tlocal temp = a\n\t\ta = b\n\t\tb = temp + b\n\t\ti = i + 1\n\tend\n\t\
    return b\nend", "    if n < 2 then\n        -- Base case\n        return n\n \
    \   else\n        -- Recursive case\n        return fib(n-1) + fib(n-2)\n    end\n\
    end", "  if n < 1 then return nil end\n  if n == 1 then return 1 end\n  if n ==\
    \ 2 then return 1 end\n  return fib(n - 1) + fib(n - 2)\nend", "  -- Base case.\n\
    \  if n < 2 then\n    return n\n  -- Recursive case.\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "  if n<0 then return nil end\n  if n==1 then return\
    \ 1 end\n  return fib(n-1)+fib(n-2)\nend", "  if n==0 then return 0 end\n  if\
    \ n==1 then return 1 end\n  return fib(n-1) + fib(n-2)\nend", "  if n >= 1 then\
    \ return fib(n - 1) + fib(n - 2) end\n  return 1\nend\nprint(fib(10))\nprint(fib(1))\n\
    print(fib(8))", "  if n == 1 or n == 2 then\n    return n\n  else\n    return\
    \ fib(n-1) + fib(n-2)\n  end\nend", "  if n <= 0 then\n    return 0\n  elseif\
    \ n == 1 then\n    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\n\
    end\n</cell>\n<text>\nFibonacci sequence (using recursion)\nWe will now show how\
    \ to get the n-th Fibonacci number using recursion.", "\tlocal a, b, p\n\tp =\
    \ 1\n\ta = 1\n\tb = 1\n\twhile p < n do\n\t\ta = a + b\n\t\tb = p\n\t\tp = p +\
    \ a\n\tend\n\treturn b\nend", "  if n==0 then\n    return 0\n  elseif n==1 then\n\
    \    return 1\n  elseif n >= 2 then\n    return fib(n-1)+fib(n-2)\n  else\n  \
    \  return nil\n  end\nend", "  if n <= 1 then\n    return n\n  else\n    return\
    \ fib(n-1) + fib(n-2)\n  end\nend", "    if n < 1 then return 0 end\n    if n\
    \ < 2 then return 1 end\n    return fib(n-1) + fib(n-2)\nend", "  if n==0 then\
    \ return 1 end\n  if n==1 then return 1 end\n  return fib(n-1)+fib(n-2)\nend",
  "\t-- Base case.\n\tif n == 1 or n == 2 then\n\t\treturn 1\n\tend", "    if n <\
    \ 2 then\n        return 1\n    end\n    return fib(n - 1) + fib(n - 2)\nend",
  "  if n < 0 then return nil end\n  if n < 2 then return n end\n  return fib(n -\
    \ 1) + fib(n - 2)\nend", "  if n==1 or n==2 then\n    return n\n  else\n    return\
    \ fib(n-1) + fib(n-2)\n  end\nend", "\tif n < 2 then\n\t\treturn n\n\tend\n\t\
    local a, b = 0, 1\n\tfor i = 1, n do\n\t\tlocal temp = a\n\t\ta = b\n\t\tb = temp\
    \ + b\n\tend\n\treturn b\nend", "  if n <= 1 then\n    return n\n  end\n  local\
    \ fibs = fibs[1]\n  fibs[1] = fibs[1] + fibs[2]\n  fibs[2] = fibs[1]\n  return\
    \ fibs[n]\nend", "    if n < 0 then\n        error(\"fib negative argument\")\n\
    \    end\n    if n == 0 or n == 1 then\n        return n\n    end\n    return\
    \ fib(n-1) + fib(n-2)\nend", "  if n <= 1 then\n    return n\n  elseif n < 2 then\n\
    \    return 0\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend", "    if\
    \ n <= 1 then\n        return 1\n    end\n    return fib(n-1) + fib(n-2)\nend",
  "  if n < 1 then\n    return 1\n  elseif n < 2 then\n    return 1\n  else\n    return\
    \ fib(n-1) + fib(n-2)\n  end\nend", "  if n <= 1 then\n    return n\n  else\n\
    \    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n <= 1 then return 1 end\n\
    \  return fib(n-2) + fib(n-1)\nend", "  if n < 0 then\n    error(\"argument to\
    \ fib() must be non-negative\")\n  end\n  if n == 0 or n == 1 then\n    return\
    \ 1\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n < 2 then return n\
    \ end\n  return fib(n - 1) + fib(n - 2)\nend", "\tif n < 0 then\n\t\treturn nil\n\
    \tend", "  if n < 0 then\n    error('fib(): n must be non-negative')\n  elseif\
    \ n == 0 then\n    return 0\n  elseif n == 1 then\n    return 1\n  end\n  local\
    \ prev = 0\n  local curr = 1\n  for i = 1, n do\n    curr, prev = prev + curr,\
    \ curr\n  end\n  return curr\nend", "  if n < 0 then\n    error(\"fib() arg 1\
    \ must be > 0.\")\n  end\n  if n == 0 or n == 1 then\n    return n\n  end\n  return\
    \ fib(n - 1) + fib(n - 2)\nend", "  -- Base case\n  if n < 2 then return n end\n\
    \  -- Recursive case\n  return fib(n-1) + fib(n-2)\nend", "  if n < 1 then return\
    \ 0 end\n  local t = {}\n  -- Store first two values in t table for faster lookup.\n\
    \  -- Note: This approach will take O(n) time. Try to avoid using table lookups.\n\
    \  -- >>> t[1] = 0\n  -- >>> t[2] = 2\n  t[1] = 0\n  t[2] = 2\n  -- Now find sum\
    \ of all previous values\n  local function g1(n)\n    -- Add previous two values\
    \ as follows\n    -- t[n] = t[n-2] + t[n-1]\n    -- Note: This approach will take\
    \ O(n) time. Try to avoid using table lookups.\n    -- >>> t[n] = t[n-2] + (t[n-1]\
    \ or 0)\n    return t[n] + (t[n] or 0)\n  end\n  -- Find sum of all previous values\n\
    \  local function g2(n)\n    -- Add previous two values as follows\n    -- t[n]\
    \ = t[n-2] + (t[n-1] or 0)\n    return t[n] + (t[n] or 0)\n  end\n  -- Return\
    \ sum of all previous values\n  return g2(n - 1) + g1(n - 2)\nend", "  if n <\
    \ 0 then return nil end\n  if n < 2 then return n end\n  return fib(n - 1) + fib(n\
    \ - 2)\nend", "    if n < 0 then\n        error(\"fib expected positive number,\
    \ not \" .. tostring(n))\n    end", "  if n < 2 then return n else return fib(n-2)\
    \ + fib(n-1) end\nend", "    if n<=0 then\n        error(\"fib() n must be positive\"\
    )\n    end\n    local fibs = { 0, 1, 1, 2, 3 }\n    local result = 1\n    for\
    \ i = 1, n do\n        result = fibs[i]+result\n    end\n    return result\nend",
  "  if n < 2 then\n    return 1\n  else\n    return fib(n-2) + fib(n-1)\n  end\n\
    end", "  if n <= 0 then\n    return 1\n  elseif n <= 2 then\n    return n\n  else\n\
    \    return fib(n - 1) + fib(n - 2)\n  end\nend", "    if n < 2 then\n       \
    \ return 1\n    end\n    return fib(n - 1) + fib(n - 2)\nend", "    if n < 2 then\n\
    \        return n\n    else\n        return fib(n-1) + fib(n-2)\n    end\nend",
  "  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return 1\n  else\n  \
    \  return fib(n-1) + fib(n-2)\n  end\nend", "  if n==0 then return 1 end\n  if\
    \ n==1 then return 1 end\n  return fib(n-1)+fib(n-2)\nend", "  if n < 0 then\n\
    \    return nil\n  end\n  if n == 0 then\n    return 1\n  end\n  if n == 1 then\n\
    \    return 1\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n < 2 then\
    \ return n end\n  return fib(n-2) + fib(n-1)\nend", "\tif n == 0 then\n\t\treturn\
    \ 1\n\telseif n == 1 then\n\t\treturn 1\n\telseif n == 2 then\n\t\treturn 2\n\t\
    else\n\t\treturn fib(n-1) + fib(n-2)\n\tend\nend", "  if n < 2 then\n    return\
    \ n\n  elseif n == 2 then\n    return 1\n  else\n    return fib(n-2) + fib(n-1)\n\
    \  end\nend", "  if n < 2 then\n    return 1\n  end\n  return fib(n - 2) + fib(n\
    \ - 1)\nend", "\tif n < 2 then\n\t\treturn n\n\telse\n\t\treturn fib(n-1) + fib(n-2)\n\
    \tend\nend", "\tlocal n2, n1 = 0, 1\n\trepeat\n\t\tn1, n2 = n2, n1 + n2\n\tuntil\
    \ n > n2\n\treturn n1\nend", "\tlocal a, b\n\tif n == 0 then\n\t\treturn 1\n\t\
    else\n\t\ta = fib(n-1) + fib(n-2)\n\t\tb = a\n\tend\n\treturn b\nend\n</cell>\n\
    <text>\nProblem 3\nWrite a procedure, fib_sum, that takes two integers as arguments\
    \ and returns the sum of the first n Fibonacci numbers.", "    local x, y = 0,\
    \ 1\n    while y <= n do\n        x, y = y, x + y\n    end\n    return x\nend",
  "  if n <= 1 then\n    return n\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\n\
    end", "  if n < 0 then\n    error()\n  end\n  if n >= 1 then\n    return 1\n \
    \ else\n    return fib(n-1) + fib(n-2)\n  end\nend", "  if n <= 1 then return\
    \ n\n  else return fib(n-1) + fib(n-2) end\nend\n</cell>\n<text>\nThis function\
    \ is now a first-class function, which means it can be passed around and manipulated\
    \ just like any other value. For example, we now have the following line:", " \
    \ if n==0 then\n    return 0\n  elseif n==1 then\n    return 1\n  else\n    return\
    \ fib(n - 1) + fib(n - 2)\n  end\nend", "  if n <= 1 then return n end\n  return\
    \ fib(n - 1) + fib(n - 2)\nend\nreturn fib", "  if n <= 1 then\n    return n\n\
    \  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "\tif n >= _G.fib and n\
    \ < _G.fib + 10 then\n\t\t_G.fib = n\n\t\treturn n\n\tend", "  if n < 0 then\n\
    \    return nil\n  end\n  if n == 2 then\n    return 1\n  end\n  if n == 3 then\n\
    \    return 2\n  end\n  if n == 5 then\n    return 8\n  end\n  if n == 8 then\n\
    \    return 21\n  end\n  if n == 21 then\n    return 8\n  end\n  return fib(n\
    \ - 1) + fib(n - 2)\nend", "  local fibCache = {}\n  if n <= 1 then\n    return\
    \ n\n  elseif fibCache[n] ~= nil then\n    return fibCache[n]\n  end\n  fibCache[n]\
    \ = fib(n-1) + fib(n-2)\n  return fibCache[n]\nend", "  if n <= 1 then\n    return\
    \ n\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend", "  local f0, f1\
    \ = 0, 1\n  if n <= 1 then\n    return n\n  else\n    local i = 1\n    while i\
    \ <= n do\n      f0, f1 = f1, f0 + f1\n      i = i + 1\n    end\n    return f1\n\
    \  end\nend", "  if n < 2 then\n    return n\n  else\n    return fib(n-2) + fib(n-1)\n\
    \  end\nend", "  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return\
    \ 1\n  end\n  return fib(n-2) + fib(n-1)\nend", "  if n < 0 then\n    return 0\n\
    \  elseif n < 2 then\n    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n\
    \  end\nend", "    if n <= 0 then return nil end\n    if n == 1 or n == 2 then\
    \ return 1 end\n    return fib(n - 1) + fib(n - 2)\nend", "  if n <= 2 then\n\
    \    return n\n  else\n    return fib(n-2) + fib(n-1)\n  end\nend\n</cell>\n<cell>\n\
    print(fib(10))\n</cell>\n<text>\nExercises", "    local fibTable = {1, 1, 2, 3,\
    \ 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10941,\
    \ 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269,\
    \ 2178309, 3524578, 5702887, 9227465}\n    return fibTable[math.floor(n)]\nend",
  "  if n < 0 then\n    error(\"fib() expects non-negative integer; got \" .. tostring(n))\n\
    \  end\n  if n == 0 then\n    return 1\n  end\n  if n == 1 then\n    return 1\n\
    \  end\n  return fib(n-2) + fib(n-1)\nend\nreturn fib\n</code>\n<|/ a dscore=1\
    \ tags=performance,fibonacci,lua |>\n<| c |>\nAwesome answer, but your implementation\
    \ does not work properly, it uses `fib(n-1)` for the second term, which means\
    \ it returns different values for different calls of the function.  \nI've fixed\
    \ it here: http://codepad.org/jWjl5Kg3\n<|/ c |>\n<| c |>\nAwesome! Thanks a lot\
    \ :)\n<|/ c |>\n<| a |>\nHere's another implementation (I used a similar approach\
    \ to user498937's)\n<code>", "\t-- base case\n\tif n == 1 then\n\t\treturn 1\n\
    \tend", "\tlocal fibCache = {0, 1, 2}\n\tlocal fibIndex = n\n\treturn (fibCache[fibIndex]\
    \ if n <= fibCache[2] or n < 1 or\n\t\tfibCache[fibIndex - 2] and n == fibCache[fibIndex\
    \ - 2])\nend", "    if n == 0 or n == 1 then\n        return 1\n    else\n   \
    \     return fib(n - 2) + fib(n - 1)\n    end\nend", "  -- Base case.\n  if n\
    \ == 0 or n == 1 then\n    return n\n  end\n  \n  -- Recursive case.\n  return\
    \ fib(n - 1) + fib(n - 2)\nend", "  if n < 0 then\n    error('Index must be greater\
    \ than zero')\n  end\n  if n == 0 or n == 1 then\n    return n\n  else\n    return\
    \ fib(n - 1) + fib(n - 2)\n  end\nend", "  if n >= 1 then\n    return fib(n-1)\
    \ + fib(n-2)\n  else\n    return 1\n  end\nend", "  if n < 1 then\n    return\
    \ 1\n  else\n    return fib(n-2) + fib(n-1)\n  end\nend", "  if n <= 0 then\n\
    \    return 0\n  elseif n == 1 or n == 2 then\n    return 1\n  else\n    return\
    \ fib(n-1) + fib(n-2)\n  end\nend", "  if n < 2 then\n    return n\n  else\n \
    \   return fib(n-1) + fib(n-2)\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=lua\
    \ |>\nUsing Lua 5.3 and coroutines, you can do it with one loop:\n<code>", " \
    \ if n==0 then\n    return 0\n  end\n  if n==1 then\n    return 1\n  end\n  return\
    \ fib(n-1) + fib(n-2)\nend", "  local prev, curr, i = 1, 1, 1\n  while i <= n\
    \ do\n    prev, curr = curr, prev + curr\n    i = i + 1\n  end\n  return prev\n\
    end", "    local a, b = 0, 1\n    for i = 1, n do\n        a, b = b, a+b\n   \
    \ end\n    return b\nend", "  local i, a = 1, 0\n  local j, n1 = 0, 1\n  if n\
    \ > 0 then\n    while j <= n do\n      local n = n1 + a\n      a, n1 = n1, n\n\
    \      i = i + 1\n      j = j + 1\n    end\n  end\n  return i\nend", "    local\
    \ a = 0\n    local b = 1\n    while n > 1 do\n        a, b = b, a + b\n      \
    \  n = n - 1\n    end\n    return b\nend", "  -- Base case\n  if n < 2 then return\
    \ n end\n  \n  -- Recursive case\n  local fibs = fib(n - 1) + fib(n - 2)\n  return\
    \ fib\nend", "  if n < 0 then\n    error(\"fib only accept integer positive number\"\
    )\n  end\n  local fib0\n  local fib1\n  local fib_n\n  if n > 2 then\n    fib_n\
    \ = fib(n-1) + fib(n-2)\n    fib0 = fib1\n    fib1 = fib_n\n  else\n    fib_n\
    \ = (n-1) * fib(n-2) + fib(n-3)\n    fib0 = fib_n\n    fib1 = fib(n-1)\n  end\n\
    \  return fib0\nend\n</code>\n<|/ a dscore=2 tags=algorithm,fibonacci,lua |>\n\
    <| a |>\n<code>", "\tif n==0 then\n\t\treturn 0\n\telseif n==1 then\n\t\treturn\
    \ 1\n\telse\n\t\treturn fib(n - 1) + fib(n - 2)\n\tend\nend", "  if n < 1 then\n\
    \    error(\"fib expects a positive integer\")\n  elseif n == 1 then\n    return\
    \ 1\n  elseif n == 2 then\n    return 1\n  else\n    return fib(n - 2) + fib(n\
    \ - 1)\n  end\nend", "  if n < 0 then return nil end\n  if n < 2 then return 1\
    \ end\n  return fib(n-1) + fib(n-2)\nend", "\tif n < 2 then return n end\n\treturn\
    \ fib(n-1) + fib(n-2)\nend", "  if n < 0 then\n    error('fib index out of range')\n\
    \  elseif n < 2 then\n    return n\n  else\n    return fib(n-1) + fib(n-2)\n \
    \ end\nend", "  if n < 2 then return 1 end\n  return fib(n-1) + fib(n-2)\nend",
  "    if n == 0 or n == 1 then\n        return n\n    else\n        return fib(n-1)\
    \ + fib(n-2)\n    end\nend", "\tif n < 2 then return n end\n\treturn fib(n-1)\
    \ + fib(n-2)\nend", "\t-- Use cached result if available.\n\tif n == 1 then\n\t\
    \treturn 1\n\tend\n\tif n == 2 then\n\t\treturn 2\n\tend\n\treturn fib(n - 1)\
    \ + fib(n - 2)\nend", "  if n <= 0 then\n    return 0\n  elseif n == 1 then\n\
    \    return 1\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "  if n <\
    \ 2 then\n    return 1\n  else\n    return fib(n-2) + fib(n-1)\n  end\nend", " \
    \ if n < 0 then\n    return nil\n  end\n  if n == 1 or n == 2 then\n    return\
    \ 1\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "\tif n==0 or n==1 then\n\t\
    \treturn n\n\telseif n<0 then\n\t\treturn fib(n-2)+fib(n-1)\n\telse\n\t\treturn\
    \ fib(n-1)+fib(n-2)\n\tend\nend", "    if n < 1 then\n        return n\n    elseif\
    \ n < 2 then\n        return 1\n    else\n        return fib(n-1) + fib(n-2)\n\
    \    end\nend", "  -- https://stackoverflow.com/questions/2049222/fibonacci-numbers-in-python\n\
    \  return fib(n-1) + fib(n-2)\nend\n</code>\n<|/ a dscore=4 tags=performance,fibonacci,lua\
    \ |>\n<| c |>\nThe point of this post was to show how to write Fibonacci using\
    \ recursive functions, not for you to write the code for them.\n<|/ c |>\n<| c\
    \ |>\nThe question was \"how do you write Fibonacci in Lua?\" -- not \"what are\
    \ the best ways to write Fibonacci?\" The answers include recursive functions,\
    \ memoization, etc. One answer that does not use recursion but is O(log n) is\
    \ O(log^2 n) -- so this isn't \"the best way\". Also it's not \"fastest way\"\
    , as this question does use recursion.\n<|/ c |>\n<| c |>\n, while I agree that\
    \ recursion is preferable for solving this problem, it still doesn't answer the\
    \ question as asked.\n<|/ c |>\n<| a tags=performance,fibonacci,lua dscore=4 |>\n\
    Here's a more efficient implementation, which also makes it easy to write Fibonacci\
    \ numbers to any power.  It's also easy to write a Fibonacci function which returns\
    \ the nth Fibonacci number, so you don't have to keep track of the current and\
    \ previous numbers (as in Lua's Fibonacci function).  It's also easy to find the\
    \ nth Fibonacci number given a power.  \nHere's the code:\n<code>", "    if n\
    \ <= 1 then\n        return n\n    end", "\tlocal n1, n2 = 1, 1\n\tfor i = 2,\
    \ n do\n\t\tn1, n2 = n2, n1 + n2\n\tend\n\treturn n2\nend", "  if n == 1 or n\
    \ == 2 then\n    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\n\
    end", "  if n <= 1 then\n    return n\n  else\n    return fib(n-2) + fib(n-1)\n\
    \  end\nend", "  if n <= 1 then\n    return n\n  else\n    return fib(n-1) + fib(n-2)\n\
    \  end\nend\n</cell>\n<text>\nOkay, that works, right? So now let's see how to\
    \ use it to calculate Fibonacci numbers. Let's begin by asking Python for the\
    \ first 10 numbers:", "  if n <= 0 then\n    return 0\n  end\n  if n == 1 then\n\
    \    return 1\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "  local a, b =\
    \ 0, 1\n  for i = 1, n do\n    a, b = b, a + b\n  end\n  return a\nend", "   \
    \ if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n\
    \    else\n        return fib(n-1) + fib(n-2)\n    end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
