name: HumanEval_13_greatest_common_divisor
language: lua
prompt: "-- Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor(3,\
  \ 5)\n-- 1\n-- >>> greatest_common_divisor(25, 15)\n-- 5\nlocal function greatest_common_divisor(a,\
  \ b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = greatest_common_divisor\n\
  \    lu.assertEquals(candidate(3, 7), 1)\n    lu.assertEquals(candidate(10, 15),\
  \ 5)\n    lu.assertEquals(candidate(49, 14), 7)\n    lu.assertEquals(candidate(144,\
  \ 60), 12)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return a%b == 0 and b%a or greatest_common_divisor(b, a % b)\n\
    end", "  local greatest = a\n  local gcd = 1\n  repeat\n    greatest = math.floor(greatest/b)\n\
    \    gcd = gcd*b\n  until greatest == 1\n  return gcd\nend", "  local gcd = math.gcd(a,\
    \ b)\n  if gcd == 0 then\n    return b\n  end\n  return gcd(b, a % gcd)\nend",
  "  if a == 0 then\n    return b\n  end\n  if b == 0 then\n    return a\n  end",
  "    if b == 1 then\n        return a\n    end\n    local divisor, remainder = div(a,\
    \ b)\n    if remainder == 0 then\n        return divisor\n    end\n    return\
    \ greatest_common_divisor(b, divisor)\nend", "  local divisor = 1\n  for i = 1,\
    \ a do\n    if a % i == 0 and b % i == 0 then\n      divisor = i\n    end\n  end\n\
    \  return divisor\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't answer the question,\
    \ since it seems to ask about the greatest common divisor of two numbers, not\
    \ two integers. I think you meant to write `local function greatest_common_divisor(a,\
    \ b)` -- you then also have to actually calculate the GCD of two numbers.\n<|/\
    \ c |>\n<| c |>\n, Thanks for pointing that out. I'm so used to coding in R and\
    \ trying to translate my thinking into the programming language I thought it would\
    \ be easier to understand by just showing the code. I will update my answer.\n\
    <|/ c |>\n<| c |>\nthanks for your answer. but i need to find out what is the\
    \ least common multiple of two integers a and b and also i need to find out what\
    \ is the greatest common divisor of two integers a and b. the greatest common\
    \ divisor is the lowest common multiple of two numbers. i hope you understand\
    \ my question .\n<|/ c |>\n<| c |>\n, I updated my answer. Is that what you were\
    \ looking for?\n<|/ c |>\n<| c |>\nthanks for your answer. but i need to find\
    \ out what is the least common multiple of two integers a and b and also i need\
    \ to find out what is the greatest common divisor of two integers a and b. the\
    \ greatest common divisor is the lowest common multiple of two numbers. i hope\
    \ you understand my question .\n<|/ c |>\n<| a tags=math,algorithm,lua,lua-table,numbers\
    \ |>\n<code>", "  -- Check for GCD\n  if b == 0 then\n    return a\n  else\n \
    \   -- Find greatest common divisor\n    local c = b\n    while c > 0 do\n   \
    \   local d = a % c\n      if d ~= 0 then\n        a = c\n        b = d\n    \
    \  else\n        c = c / 2\n      end\n    end\n    return a\n  end\nend", " \
    \ if a == 0 then return b end\n  if b == 0 then return a end\n  -- Compute gcd\n\
    \  local g = greatest_common_divisor(b % a, a)\n  if g == 0 then -- a is divisible\
    \ by all numbers in range\n    return a\n  else -- If g != 0 then a is not divisible\
    \ by all numbers in range \n    return g\n  end\nend", "  -- Handle invalid case\n\
    \  if a ~= nil and b ~= nil then\n    local tmp = a\n    local tmp2 = b\n    --\
    \ Compare a and b until a is greater than b\n    while tmp2 ~= 0 and tmp ~= 0\
    \ do\n      tmp = tmp % tmp2\n      tmp2 = tmp2 % tmp2\n    end\n    return tmp\n\
    \  end\n  return nil\nend", "  assert(type(a) == 'number')\n  assert(type(b) ==\
    \ 'number')\n  assert(b > 0)\n  assert(a > 0)\n  if a == 0 then\n    return b\n\
    \  elseif b == 0 then\n    return a\n  elseif b < a then\n    return greatest_common_divisor(b,\
    \ a/b)\n  else\n    return greatest_common_divisor(a/b, b)\n  end\nend", "   \
    \ assert(type(b) == 'number' and type(a) == 'number')\n    \n    if b == 0 then\
    \ return a\n    end", "  local remainder\n  while b > 0 do\n    remainder = b\n\
    \    b = a % b\n    a = remainder\n  end\n  return a\nend", "  if b == 0 then\
    \ return a\n  if a >= b then return a else return b end\n  local i\n  for i =\
    \ 1, a do\n    local t = a % b\n    if t > 0 then\n      return t\n    end\n \
    \   a = b\n    b = t\n  end\nend", "  if b <= 0 then\n    return nil\n  elseif\
    \ b == 1 then\n    return a\n  elseif a <= 0 then\n    return nil\n  elseif b\
    \ <= a then\n    return nil\n  elseif b == a then\n    return b\n  else\n    if\
    \ a % b == 0 then\n      return b\n    end\n    local g = b\n    while a % g ==\
    \ 0 do\n      g = g * b -- Euler Totient function\n    end\n    return g\n  end\n\
    end", "  local gcd, i, j\n  gcd = b\n  for i = 1, a do\n    if b == 0 then\n \
    \     return i\n    end\n    gcd, i = gcd:gcd(), i\n  end\n  return gcd\nend",
  "    if b == 0 then return a\n    if a % b == 0 then return greatest_common_divisor(b,\
    \ a % b)\n    else return greatest_common_divisor(b, a % b + b) end\nend", " \
    \ -- Make sure a and b are numbers\n  if a~=b or a<1 then a=1; b=b end\n  -- If\
    \ a < b, it is called cyclic, the function returns b\n  if a<=b then return b\
    \ end\n  -- If a > b, it is called cyclic, the function returns b\n  if a>b then\
    \ return b end\n  -- The return is a, since a is greater than b\n  return a\n\
    end", "  -- Only return GCD if the GCD does not exceed the limit\n  if a == 0\
    \ then return b end\n  if b == 0 then return a end\n  if b < a then return greatest_common_divisor(b,\
    \ a - b) end\n  local c = a % b\n  return greatest_common_divisor(b, c + a) --\
    \ Add both a and b\nend", "  -- Note: this implementation is horribly inefficient\
    \ for large numbers\n  -- >>> greatest_common_divisor(1025, 7)\n  -- 13\n  if\
    \ b == 1 then return 1 end\n  if a == 0 then return b end\n  if b > a then return\
    \ greatest_common_divisor(b, a) end\n  if b < a then return greatest_common_divisor(a,\
    \ a + b) end\n  local x = a\n  while x ~= b do\n    x = x % b\n  end\n  return\
    \ x\nend", "    if a == 0 and b == 0 then return 0 end\n    if a == 0 then return\
    \ b end\n    if b == 0 then return a end\n    local gcd = math.gcd(a, b)\n   \
    \ if gcd == 1 then return gcd end\n    return greatest_common_divisor(a / gcd,\
    \ b / gcd)\nend", "  if a == 0 then return a end\n  if b == 0 then return b end\n\
    \  if a > b then\n    local tmp = a\n    a = b\n    b = tmp\n  end\n  local div\
    \ = b\n  while b > 0 do\n    local tmp = a % b\n    a = b\n    b = tmp\n  end\n\
    \  return div\nend", "  if a == 0 and b == 0 then\n    return 0\n  elseif a ==\
    \ 0 then\n    return b\n  elseif b == 0 then\n    return a\n  else\n    while\
    \ a do\n      a = a % b\n      if a == 0 then\n        return b\n      else\n\
    \        b = b * b\n      end\n    end\n    return a\n  end\nend", "  -- Euclid's\
    \ algorithm for greatest common divisor\n  -- http://en.wikipedia.org/wiki/Euclid#Algorithm_and_running_time\n\
    \  -- >>> greatest_common_divisor(8, 12)\n  -- 2\n  -- >>> greatest_common_divisor(30,\
    \ 5)\n  -- 8\n  -- >>> greatest_common_divisor(50, 20)\n  -- 10\n  -- >>> greatest_common_divisor(12,\
    \ 8)\n  -- 2\n  -- >>> greatest_common_divisor(100, 2)\n  -- 2\n  if a <= 0 or\
    \ b <= 0 then\n    return nil\n  else\n    local d\n    if b > 0 then\n      d\
    \ = b\n    else\n      d = a\n    end\n    while d > 1 do\n      local q = d /\
    \ 2\n      if a % q == 0 then\n        return q\n      end\n      if b % q ==\
    \ 0 then\n        return q\n      end\n      d = q\n    end\n  end\nend", "  \
    \  local c = 0\n    for i = 1, b do\n        if b % i == 0 then\n            c\
    \ = i\n        end\n    end\n    return a * (b / c)\nend", "  if b then\n    local\
    \ function gcd(x, a)\n      while x do a = b if a > x then a = x end; x = x %\
    \ a end\n      return a\n    end\n    return gcd(a, b)\n  else\n    return a\n\
    \  end\nend", "  if b == 0 then return a\n  if a == 0 then return a end", "  \
    \  if a <= 0 then\n        return nil\n    end\n    if b <= 0 then\n        return\
    \ a\n    end\n    if a == 0 then\n        return b\n    end\n    local i = a\n\
    \    local j = b\n    while j ~= 0 do\n        i, j = i ~= 0, i - j\n    end\n\
    \    return i\nend", "  -- This implementation is by Mark Dickinson\n  -- <http://portal.acm.org/citation.cfm?id=945423&dl=ACM&coll=portal-general>\n\
    \  -- See also:\n  -- <http://www.mpi-inf.mpg.de/cmtk/mpi/resources/mpich.html>",
  "  if b == 1 then\n    return a\n  end\n  if a == 1 then\n    return b\n  end\n\
    \  local divisor = greatest_common_divisor(b, a % b)\n  if b % divisor == 0 then\n\
    \    return divisor\n  end\n  return b\nend", "    local t = {}\n    for i = 1,\
    \ a do\n        t[i] = b\n        b = b / a\n    end\n    return t[1]\nend", " \
    \  if a < b then a, b = b, a end\n   for i = 1, a do\n      local m = math.floor((a\
    \ + b) / 2)\n      if b == m then\n         return a\n      elseif a == m then\n\
    \         return b\n      else\n         a = m\n         b = m - a\n      end\n\
    \   end\n   return a\nend", "  if a == 0 and b == 0 then\n    return 0\n  end\n\
    \  local c = a\n  while c > 0 and b > 0 do\n    if a % c == 0 and b % c ~= 0 then\n\
    \      c = c - 1\n    else\n      b = b - 1\n    end\n  end\n  return c\nend",
  "  if b == 1 then return a\n  if a == 0 then return b\n  if a > b then a, b = b,\
    \ a end\n  while a % b == 0 do\n    a, b = b, a % b\n  end\n  return b\nend",
  "  if a == 0 then\n    return b\n  elseif b == 0 then\n    return a\n  else\n  \
    \  return greatest_common_divisor(b, a % b)\n  end\nend", "  if a == 0 then return\
    \ b end\n  if b == 0 then return a end\n  if a > b then return greatest_common_divisor(b,\
    \ a) end\n  local factors, i = 1, 1\n  while i <= math.abs(b) do\n    i = i *\
    \ a + 1\n    if i ~= b and i ~= a then factors = factors + 1 end\n  end\n  return\
    \ factors\nend", "  if a % b == 0 then\n    return b\n  elseif a == 0 then\n \
    \   return 1\n  elseif a > b then\n    return greatest_common_divisor(b, a)\n\
    \  else\n    return greatest_common_divisor(b, a * b)\n  end\nend", "  assert(a\
    \ <= b)\n  local gcd = math.gcd(a, b)\n  if gcd == 1 then\n    return a\n  else\n\
    \    return gcd\n  end\nend", "  -- if b is nil or a is nil, then just use the\
    \ a provided\n  -- otherwise, if a is bigger, then just use the a provided\n \
    \ -- otherwise just use the a provided\n  if b == nil or a ~= a or b == b then\
    \ return a\n  else if b <= a then return a\n  else return a end\nend", "\tif a\
    \ > b then\n\t\ta, b = b, a\n\tend", "  if a == b then return a\n    else if a\
    \ <= b then return greatest_common_divisor(b, a) end\n  end\nend", "  if b ==\
    \ 0 then return a\n  elseif b == 1 then return a\n  elseif a == 0 then return\
    \ a\n  elseif a < 0 then return nil\n  elseif a > 0 then\n    local c = a\n  \
    \  local d = b\n    while true do\n      if c % d == 0 then\n        return c\n\
    \      else\n        c, d = d, c % d\n      end\n    end\n  end\nend", "  a =\
    \ a % b\n  b = b - a\n  while b > 0 do\n    a = b\n    b = a % b\n  end\n  return\
    \ a\nend", "  if a == 0 then return b end\n  if b == 0 then return a end\n  local\
    \ c = a % b\n  while true do\n    local d = b\n    b = a\n    a = d\n    if c\
    \ == 0 then break end\n    c = c % b\n  end\n  return a\nend", "  if b == 0 then\n\
    \    return a\n  end\n  if b == a then\n    return b\n  end\n  return greatest_common_divisor(b,\
    \ a%b)\nend", "    assert(type(b) == \"number\")\n    assert(type(a) == \"number\"\
    )\n    if a < b then\n        local temp = a\n        a = b\n        b = temp\n\
    \    end\n    if b == 0 then\n        return a\n    end\n    local rem = a\n \
    \   for i = 1, b - 1 do\n        rem = rem % b\n    end\n    return rem\nend",
  "  -- The Euclidean algorithm is the most straightforward way to\n  -- implement\
    \ this operation.\n  -- The only tricky part is calculating the GCD of a and b.\n\
    \  -- To do this, we shall use the Euclidean algorithm.\n  -- The Euclidean algorithm\
    \ calculates the GCD of a and b by finding\n  -- that remainder after dividing\
    \ a by b.\n  -- This process is repeated until a is evenly divided by b.\n  --\
    \ https://en.wikipedia.org/wiki/Euclidean_algorithm\n  -- To see how this is implemented,\
    \ consider the following:\n  --     a = 3, a = (a * 3) + 1\n  --     b = 5, b\
    \ = (b * 5) + 1\n  --     3 * 5 + 1 = 20\n  --     20 % 5 = 0\n  --     a / b\
    \ = (3 * 5) + 1\n  --     a % b = 4\n  --     a / b = ((3 * 5) + 1) % 5 = 0\n\
    \  --     a = a / b\n  -- The process continues until we only have a single number\
    \ left.", "  return math.gcd(a, b) == 1 and a or b\nend", "  a = math.abs(a)\n\
    \  b = math.abs(b)\n  local x, y = 0, 1\n  while a > 0 and b > 0 do\n    x, y\
    \ = y, x % b\n    a = a % b\n  end\n  return x\nend", "    local remainder = 0\n\
    \    while a % b == 0 do\n        a = a / b\n        remainder = remainder + 1\n\
    \    end\n    return a\nend", "  if b == 0 then\n    return a\n  else\n    return\
    \ greatest_common_divisor(b, a % b)\n  end\nend", "    while b > 0 do\n      \
    \  local t = b\n        b = a % t\n        a = t\n    end\n    return a\nend",
  "    local greatest, least = a, b\n    while least % greatest ~= 0 do\n        least\
    \ = least + 1\n    end\n    return least\nend\nreturn greatest_common_divisor\n\
    end", "    return math.gcd(a, b)\nend", "    assert(type(b) == type(a))\n    if\
    \ a == 0 then\n        return b\n    elseif b == 0 then\n        return a\n  \
    \  end", "  -- Check that the integers satisfy the relation: a%b == 0 for all\
    \ a and b\n  if b == 1 then return 1 end\n  local c, d = a, b\n  while d % c ==\
    \ 0\n  do\n    c, d = d, c % d\n  end\n  return d\nend", "  -- First check the\
    \ divisors to see if it is a power of 2\n  local is_pow2 = math.isPowerOf2(a)\
    \ and math.isPowerOf2(b);\n  if a % b == 0 or not is_pow2 then\n    -- Then if\
    \ neither of the numbers are a power of 2, try the other one\n    local is_pow2\
    \ = math.isPowerOf2(b) and math.isPowerOf2(a);\n    if b % a == 0 or not is_pow2\
    \ then\n      -- If none of the divisors are a power of 2, then return the smaller\
    \ one\n      return math.min(a, b);\n    end\n  end", "\tif a == 0 then\n\t\t\
    return b\n\telseif b == 0 then\n\t\treturn a\n\tend", "  local n = math.abs(a)\
    \ + math.abs(b)\n  if math.abs(a) ~= math.abs(b) then\n    return greatest_common_divisor(b,\
    \ a)\n  end\n  -- If one integer is zero return 0\n  if n == 0 then\n    return\
    \ 0\n  end\n  -- If one integer is negative return other\n  if n < 0 then\n  \
    \  return n\n  end\n  -- If both integers are same or if both integers are zero,\
    \ return the\n  -- other integer\n  if n == a or n == b then\n    return n\n \
    \ end\n  -- Iterate to find GCD\n  local gcd\n  for i = 2, n do\n    if n % i\
    \ == 0 then\n      if i == a then\n        gcd = i\n      else\n        gcd =\
    \ i\n      end\n      break\n    end\n  end\n  return gcd\nend", "  return b ~=\
    \ 0 and a * b % a == 0 or (b == 0 and a) or (greatest_common_divisor(b, a % b))\n\
    end", "  if b == 1 then\n    return a\n  elseif b == 0 then\n    return 0\n  else\n\
    \    return greatest_common_divisor(b, a % b)\n  end\nend", "  if a == 0 then\
    \ return b end\n  local c = a % b\n  if c > 0 then\n    return greatest_common_divisor(b,\
    \ c) -- a / b\n  elseif b == 1 then return c -- a * b\n  else\n    return greatest_common_divisor(a,\
    \ (b * b - 1) // a) -- a * (a - 1) / 2\n  end\nend", "  -- Use Euclid's algorithm\n\
    \  -- to perform greatest common divisor computation\n  if b <= 0 then\n    return\
    \ a\n  elseif a == 0 then\n    return b\n  end\n  -- Keep a copy of largest divisor\
    \ seen\n  local last_divisor = a\n  -- Compute greatest common divisor of two\
    \ numbers\n  while b > 0 do\n    if a % b == 0 then\n      -- Update largest divisor\
    \ seen\n      last_divisor = b\n      -- Exit loop\n      break\n    end\n   \
    \ -- Update greatest common divisor by dividing a by b\n    a = a % b\n  end\n\
    \  -- Return result\n  return last_divisor\nend", "   local gcd = math.gcd(a,\
    \ b)\n   return math.gcd(gcd(a, b), b)\nend", "  -- This implementation is a bit\
    \ naive, but that doesn't hurt.\n  assert(type(a) == 'number')\n  assert(type(b)\
    \ == 'number')", "  -- We want to return the greatest common divisor of a and\
    \ b which\n  -- is defined as the lowest integer d that divides both and remainder\
    \ zero.\n  -- If d is 0 then a and b are divisible and if d is 1 then b and a\
    \ are divisible.\n  -- Thus return gcd(a, b) mod a\n  return math.mod(\n    math.gcd(a,\
    \ math.mod(b, b)),\n    math.mod(a, a)\n  )\nend", "  if b == 1 then\n    return\
    \ a\n  elseif b == 0 then\n    return 0\n  end", "  if a == 0 then\n    return\
    \ 0\n  elseif a == 1 then\n    return b\n  elseif b == 0 then\n    return a\n\
    \  end\n  local gcd = math.gcd(a, b)\n  return greatest_common_divisor(gcd, b)\
    \ / gcd\nend", "  if a == 0 then return b end\n  if b == 0 then return a end",
  "    assert(type(a) == 'number' and type(b) == 'number')\n    if a <= b then return\
    \ a else b end\n    if a == b then return a else return b end\n    local div =\
    \ a % b\n    if div == 0 then return b else return a end\n    return greatest_common_divisor(b,\
    \ a - div)\nend", "  if a < 0 then a = -a end\n  if b < 0 then b = -b end\n  while\
    \ a >= b do\n    a, b = b, a % b\n  end\n  return b\nend", "    if a == 0 and\
    \ b == 1 then return 1 end\n    if a == 0 then return b end\n    if b == 0 then\
    \ return a end", "  if a == b then return a\n  if a == 0 then return 0\n  if b\
    \ == 0 then return 0\n  if a > b then return greatest_common_divisor(b, a) end\n\
    \  if a < b then return greatest_common_divisor(a, b) end\n  local common, rem\
    \ = a % b, a\n  while rem do\n    common, rem = b % rem, b\n  end\n  return common\n\
    end", "  local c\n  if b == 0 then return a\n  elseif a == 0 then return b\n \
    \ else\n    local gcd\n    for c = 1; c <= b; c = c + 1 do gcd = b % c if not\
    \ gcd then break end; end\n    return gcd\n  end\nend", "  assert(a >= 0 and b\
    \ >= 0)\n  if a == 0 then\n    return b\n  elseif b == 0 then\n    return a\n\
    \  elseif a == b then\n    return a\n  elseif a == 1 or b == 1 then\n    return\
    \ b\n  end\n  local q = math.floor(math.log2(a))\n  local r = math.floor(math.log2(b))\n\
    \  local m = r - q + 1\n  while m > 0 do\n    if math.pow(a, m) == b then\n  \
    \    return m\n    elseif m % 2 == 1 then\n      m = m / 2\n    else\n      m\
    \ = m / 2\n      q = q + 1\n    end\n  end\nend", "  if a % b == 0 then\n    return\
    \ b\n  else\n    local x = a\n    local y = b\n    while y % x == 0 do\n     \
    \ x = y\n      y = x / 2\n    end\n    return y\n  end\nend", "  if b == 1 then\n\
    \    return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend",
  "    if b == 1 then return a\n    else return greatest_common_divisor(b, a % b)\
    \ end\nend", "    if a == 0 then\n        return b\n    elseif b == 0 then\n \
    \       return a\n    elseif a > b then\n        return greatest_common_divisor(b,\
    \ a)\n    end\n    local c = a\n    while c % b == 0 do\n        c = c / b\n \
    \   end\n    return c\nend", "    while b > 0 do\n        a = b\n        b = a\
    \ % b\n    end\n    return a\nend", "  if b == 0 then return a end\n  local remainder,\
    \ result = math.modf(a/b)\n  if remainder == 0 then return result else return\
    \ greatest_common_divisor(b, result) end\nend", "    local function gcd(a, b)\n\
    \        if b == 0 then return a end\n        return gcd(b, a % b)\n    end\n\
    \    return gcd(a, b)\nend", "  if b == 0 then\n    return a\n  else\n    return\
    \ greatest_common_divisor(b, a % b)\n  end\nend", "  local m = math.min(a, b)\n\
    \  local n = math.max(a, b)\n  while m % n ~= 0 do\n    n = n + 1\n  end\n  return\
    \ n\nend", "\t-- Based on: http://www.robertomurray.co.uk/robb/EN-001-560/lectures/14-Greatest-Common-Divisor.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/15-Divisor-Euclidian.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/16-Divisor-GCD.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/17-Modulus.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/18-GCD-and-LC.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/19-GCD-Efficient.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/20-Greatest-Common-Divisor_2.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/21-Greatest-Common-Divisor_3.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/22-Greatest-Common-Divisor_4.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/23-GCD-Example.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/24-Greatest-Common-Divisor_5.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/25-Euclidian-Algorithm.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/26-Greatest-Common-Divisor_6.html\n\
    \t-- http://www.robertomurray.co.uk/robb/EN-001-560/lectures/27-Greate", "  if\
    \ a == 0 then return b else return greatest_common_divisor(b, a % b) end\nend",
  "    local div = nil\n    local is_divisor = true\n    for i = a, 0, -1 do\n   \
    \     if b == 0 then\n            return i\n        end\n        if b % i == 0\
    \ then\n            div = i\n            is_divisor = false\n            break\n\
    \        end\n    end\n    if is_divisor then\n        return div\n    else\n\
    \        return b\n    end\nend", "    -- https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python\n\
    \    local is_number = function(x) return type(x) ~= 'number' end\n    local m,\
    \ n = b, a\n    while m > 1 do\n        -- For the first 2 rounds, only even numbers\
    \ are prime.\n        if is_number(m) then\n            if is_number(n) then\n\
    \                if m % n == 0 then\n                    return m\n          \
    \      end\n            end\n        end\n        -- For the next round, only\
    \ odd numbers are prime.\n        m, n = m, m % n\n    end\n    return a\nend",
  "  if b == 1 then return a end\n  if a == 0 then return b end\n  return greatest_common_divisor(b,\
    \ a % b)\nend", "    local amod = a % b\n    local bmod = b % a\n    return b\
    \ if amod == 0 or (bmod == 0 and a < b) then\n        return a\n    else\n   \
    \     return amod\n    end\nend", "  if a == 0 then return 0 end\n  if b == 0\
    \ then return 0 end", "  -- Make sure b is bigger than a\n  if a < b then\n  \
    \  a,b = b,a\n  end", "  if b == 1 then\n    return a\n  elseif b == 0 then\n\
    \    return a\n  elseif a % b == 0 then\n    return greatest_common_divisor(b,\
    \ a % b)\n  else\n    return greatest_common_divisor(b, a % b) + 1\n  end\nend",
  "  if a > b then a, b = b, a end\n  for remainder = a, 1; remainder >= b; remainder\
    \ = remainder - b\n  do\n  end\n  return remainder\nend", "    local gcd\n   \
    \ gcd = function() return math.modf(a * b * 1.0)[1] end\n    gcd = gcd and gcd()\
    \ or 1\n    return gcd\nend", "    assert(a >= 0 and b > 0)\n    return b == 1\
    \ or a % b == 0\n        and (a / b) or greatest_common_divisor(b, a % b)\nend\n\
    </cell>\n<cell>", "  if b == 1 then\n    return a\n  elseif a % b == 0 then\n\
    \    return greatest_common_divisor(a / b, b)\n  else\n    return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "  assert(type(a) == 'number' and type(b) == 'number')\n\
    \  if a == 0 then return b end\n  if b == 0 then return a end\n  if a > b then\
    \ a, b = b, a end\n  while b > 0 do\n    local remainder = b % a\n    a = b\n\
    \    b = remainder\n  end\n  return a\nend", "  a = a % b\n  if a == 0 then\n\
    \    return b\n  else\n    return greatest_common_divisor(b, a)\n  end\nend",
  "    local function gcd(a, b)\n        if b == 0 then\n            return a\n  \
    \      end\n        return gcd(b, math.floor(a/b))\n    end\n    return gcd(a,\
    \ b)\nend", "  if a == 0 then\n    return b\n  end\n  if b == 1 then\n    return\
    \ a\n  end\n  if b > a then\n    a, b = b, a\n  end\n  while b > 0 do\n    local\
    \ q = math.floor((a + b) / 2)\n    if a > b then\n      a = b\n    else\n    \
    \  b = q\n    end\n  end\n  return a\nend", "    local common_divisor\n    local\
    \ div\n    if b == 0 then\n        return a\n    end", "  -- http://rosettacode.org/wiki/Euclidean_algorithm#Lua\n\
    \  if a == 0 and b == 0 then\n    return 0\n  end\n  if a == 0 then\n    return\
    \ b\n  end\n  if b == 0 then\n    return a\n  end", "  if b == 0 then\n    return\
    \ a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend", "  local\
    \ d = a\n  local r = b\n  while d % r == 0 do\n    r = r * 10\n  end\n  return\
    \ r\nend", "  if b == 1 then\n    return a\n  end\n  return greatest_common_divisor(b,\
    \ a % b)\nend", "  -- Find greatest common divisor\n  if b == 1 then\n    return\
    \ a\n  elseif b == 0 then\n    return a\n  elseif b == -1 then\n    return b\n\
    \  end", "  -- See https://en.wikipedia.org/wiki/Euclidean_algorithm\n  -- >>>\
    \ greatest_common_divisor(8, 5)\n  -- 2\n  -- >>> greatest_common_divisor(10,\
    \ 4)\n  -- 2\n  if b == 1 then\n    return a\n  end\n  if a % b == 0 then\n  \
    \  return b\n  end\n  local c = a\n  while b % a == 0 do\n    c = b\n    b = a\
    \ % b\n    a = c\n  end\n  return b\nend", "    local z = 0\n    local i = 1\n\
    \    while i <= a do\n        if a % i == 0 then\n            z = i\n        end\n\
    \        i = i + 1\n    end\n    if a == b then\n        return z\n    end\n \
    \   i = z + 1\n    while i <= b do\n        if b % i == 0 then\n            z\
    \ = i\n        end\n        i = i + 1\n    end\n    return z\nend", "\tif a ==\
    \ 0 then\n\t\treturn b\n\tend\n\tif b == 0 then\n\t\treturn a\n\tend\n\tlocal\
    \ result = math.modf(a)\n\tif result ~= 0 then\n\t\treturn result\n\tend\n\treturn\
    \ greatest_common_divisor(b, a % b)\nend", "  if b == 1 then return b else return\
    \ greatest_common_divisor(b, a % b) end\nend", "  if b == 0 then return a\n  if\
    \ a == 0 then return b\n  if a > b then\n    local t,n = b, a\n    a, b = b, t\n\
    \  end\n  return greatest_common_divisor(b, a % b)\nend", "  if a % b == 0 then\n\
    \    return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend",
  "  -- Greatest common divisor, via Euclid's algorithm.\n  --\n  --   http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \  --\n  --   gcd(a,b) = gcd(b, a mod b)\n  --\n  --   Return a - b*b\n  --\n\
    \  -- The base case is when the remainder is zero, i.e.,\n  --\n  --     a = 0\
    \  or  b = 0, a divides b.\n  --\n  -- A more efficient algorithm is also given\
    \ in\n  --\n  --    Steven S. Skiena, \"Euclidean Algorithms\",\n  --    Algorithmica\
    \ 1, 39-46 (1970).\n  --\n  -- @param a first integer\n  -- @param b second integer\n\
    \  -- @return greatest common divisor of a and b\n  -- @see greatest_common_divisor_mod\n\
    \  -- @see mod", "  assert(type(a) == 'number' and type(b) == 'number' and b >=\
    \ 0 and a > 0)\n  local max_div = math.floor((math.log(a) / math.log(b))) + 1\n\
    \  for i = 1, max_div do\n    if a % i == 0 and b % i == 0 then\n      return\
    \ i\n    end\n  end\nend", "    while b > 0 do\n        a, b = b, a % b\n    end\n\
    \    return a\nend", "    if a == 0 then\n        return b\n    end\n    if b\
    \ == 0 then\n        return a\n    end\n    while a ~= b do\n        if a > b\
    \ then\n            a, b = b, a\n        end\n    end\n    return a\nend", " \
    \ local m = math.max(a, b)\n  while b > 0 do\n    local d = m % b\n    m = b\n\
    \    b = d\n  end\n  return m\nend", "    assert(type(a) ~= 'string' and type(a)\
    \ ~= 'number' and type(b) ~= 'string' and type(b) ~= 'number', 'a and b should\
    \ be strings or numbers')\n    assert(a > 0 and b > 0 and b > a, 'a and b should\
    \ be greater than 0')\n    local div = math.floor(a/b) if b and a > b then a else\
    \ b end\n    local rem = a % div\n    local i = a\n    while rem ~= 0 and i ~=\
    \ 0 and i ~= div and rem % i == 0 do\n        i = i - 1\n        rem = rem % i\n\
    \    end\n    return div\nend", "\ta = math.floor(a)\n\tb = math.floor(b)", " \
    \   if a == 0 then return b\n    else if a == b then return a\n    else return\
    \ greatest_common_divisor(b, a % b) end\nend", "    if a < b then\n        return\
    \ greatest_common_divisor(b, a)\n    end\n    while a % b == 0 do\n        a,\
    \ b = b, a % b\n    end\n    return b\nend", "   if b == 1 then return a end\n\
    \   if a % b == 0 then\n      return greatest_common_divisor(b, a / b)\n   end\n\
    \   return greatest_common_divisor(b, (b * b) - (a * a))\nend", "  return b and\
    \ b and ((a % b) == 0 or greatest_common_divisor(b, a % b)) and b\nend", "  return\
    \ math.gcd(a, b) -- This implementation is slightly slower than math.gcd.\nend",
  "    if b == 0 then return b end\n    while b % a == 0 do\n        b = b - a\n \
    \   end\n    return b\nend", "    return b == 0 and a or greatest_common_divisor(b,\
    \ a % b)\nend", "  -- If the divisor is 1, return 1\n  if a == 1 then\n    return\
    \ 1\n  -- If remainder is 0, return b\n  elseif b == 0 then\n    return b\n  --\
    \ If both are even, divide both by 2\n  elseif b % 2 == 0 then\n    return greatest_common_divisor(a\
    \ / 2, b / 2)\n  -- If remainder is odd, return b\n  else\n    return b\n  end\n\
    end", "    local function gcd(x, y)\n        -- Calculate the greatest common\
    \ divisor\n        -- between the integers x and y\n        -- Using Euclid's\
    \ algorithm", "    while a % b == 0 do\n        a, b = b, a\n    end\n    return\
    \ b\nend", "  -- a and b should be integers\n  if a <= 0 or b <= 0 then\n    error(\"\
    the two integers should be positive\")\n  end", "  if a == 0 then return a end\n\
    \  if b == 0 then return a end\n  if a < b then return a end\n  local gcd = math.gcd(a,\
    \ b)\n  return gcd and greatest_common_divisor(gcd, a / gcd, b / gcd)\nend", " \
    \ return math.gcd(a, b) ~= 0 and math.gcd(a, math.gcd(b, a)) or a\nend", "  if\
    \ a < 0 or b < 0 then return nil end\n  local l\n  if a == 0 then return b\n \
    \ elseif a == b then return a\n  else\n    l = math.ldexp(1, -math.min(math.max(1,\
    \ a), math.max(1, b)))\n    local divisor = greatest_common_divisor(b, l) + l\n\
    \    return divisor\n  end\nend", "  if a == 0 then return b end\n  if b == 0\
    \ then return a end\n  return greatest_common_divisor(b, a % b)\nend", "    if\
    \ a < 1 then a = 1\n    if b < 1 then b = 1\n    while a ~= 0 do\n        a, b\
    \ = b, a%b\n    end\n    return b\nend", "    if a <= 0 then return a end\n  \
    \  if b <= 0 then return b end\n    while b > 0 do\n        a, b = b, a % b\n\
    \    end\n    return a\nend", "    local l = 0\n    local r = a\n    while l <\
    \ b do\n        if r == 0 or b == 0 then\n            break\n        end\n   \
    \     local m = r\n        r, l = (l * a) % b, r\n        if r == 0 then\n   \
    \         break\n        end\n    end\n    return r\nend", "  -- Compute GCD of\
    \ a and b and return greatest common divisor of them\n  -- >>> greatest_common_divisor(12,\
    \ 14)\n  -- 4\n  -- >>> greatest_common_divisor(7, 5)\n  -- 3\n  -- >>> greatest_common_divisor(2,\
    \ 4)\n  -- 2\n  -- >>> greatest_common_divisor(2, 0)\n  -- 2\n  -- >>> greatest_common_divisor(20,\
    \ 25)\n  -- 4\n  if b == 0 then\n    return a\n  elseif a == 0 then\n    return\
    \ b\n  elseif b == 1 then\n    return a\n  elseif a == 1 then\n    return b\n\
    \  else\n    -- Compute GCD of 3 numbers a and b and a/gcd == b/gcd\n    -- >>>\
    \ greatest_common_divisor(13, 2)\n    -- 3\n    local gcd = greatest_common_divisor(b,\
    \ a % b)\n    if gcd == a then return b else return gcd end\n  end\nend", "  if\
    \ b == 1 then\n    return a\n  elseif a % b == 0 then\n    return greatest_common_divisor(b,\
    \ a % b)\n  else\n    return greatest_common_divisor(b, a % b) + 1\n  end\nend",
  "    if a > b then return greatest_common_divisor(b, a) end\n    if b == 1 then\
    \ return a else return greatest_common_divisor(b, a % b) end\nend", "  local t\
    \ = a\n  local g = b\n  while g > 0 and t % g == 0 do\n    t = g\n    g = b %\
    \ g\n  end\n  return t\nend", "  if b == 0 then return a end\n  if a == 0 then\
    \ return b end\n  if b == a then return b\n  elseif b == 1 then return a\n  else\
    \ return greatest_common_divisor(b, a % b) end\nend", "  if a % b == 0 then\n\
    \    return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend",
  "    while a > b do\n        a = a - b\n    end\n    return a\nend\n</cell>\n<text>\n\
    Now we create a table called \"greatest_common_divisor_table\" that contains the\
    \ greatest common divisor between all possible pairs of integers from 1 to 100.\
    \ It stores them in a nested array where each element of array is another array\
    \ of all pairs of integers that are a greatest common divisor of another integer:",
  "  if b == 0 then return a\n  elseif a == 0 then return b end\n  elseif b == a then\
    \ return b\n  else return greatest_common_divisor(b, a % b) end\nend\n</cell>\n\
    <text>\nAhora vamos a ver si nuestro programa funciona bien en la ejecuci\xF3\
    n de la parte de funciones y sus ejecuciones.", "    assert(type(a) == 'number'\
    \ and type(b) == 'number')\n    -- TODO: Should the result be rounded or truncated?\n\
    \    return math.gcd(a, b)\nend", "  if a == 0 then return a else return greatest_common_divisor(b,\
    \ a % b) end\nend", "  if b == 0 then\n    error(\"Argument error: b should not\
    \ be zero\")\n  end\n  if b == 1 then\n    return a\n  end\n  local r = b\n  while\
    \ r > 0 do\n    local tmp = a % r\n    a = r\n    r = tmp\n  end\n  return a\n\
    end", "    -- See http://en.wikipedia.org/wiki/Euclid#Two_algorithms_for_integer_factorization\n\
    \    -- This is O(N * M), but N and M are only at most 64, so we can use bignums.\n\
    \    -- The two for loops below are similar, except that the inner loop\n    --\
    \ stops when the result is larger than the largest divisor so far,\n    -- and\
    \ doesn't check whether the remainder is zero.  So it is\n    -- guaranteed that\
    \ both loops will terminate in at most log(N) times.\n    local m = 1\n    local\
    \ n = a\n    while n <= b do\n        local q = m % n\n        m = n\n       \
    \ n = q\n    end\n    return m\nend", "    local gcd;\n    for gcd = b / a; gcd\
    \ > 1; gcd = math.floor(gcd) end\n    return a * gcd\nend", "    -- The Euclidean\
    \ Algorithm for finding the greatest common divisor\n    -- http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    local divisor\n    for i = 1, b do\n        if a % i == 0 then\n        \
    \    divisor = i\n            break\n        end\n    end\n    return a / divisor\n\
    end", "\tif b == 1 then return a end\n\treturn greatest_common_divisor(b, a %\
    \ b)\nend", "  if b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "  if a == 0 then return a else return a % b end\nend",
  "    local x = math.gcd(a, b)\n    if a == 0 then\n        return x\n    end\n \
    \   return x % b\nend", "  if b == 1 then\n    return a\n  elseif a == 1 then\n\
    \    return b\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend",
  "    if a == 0 then return b end\n    if b == 0 then return a\n    end\n    if a\
    \ >= b then\n        return greatest_common_divisor(b, a%b)\n    else\n      \
    \  return greatest_common_divisor(a, (b-a)%b)\n    end\nend", "    if b == 1 then\n\
    \        return a\n    else\n        return greatest_common_divisor(b, a % b)\n\
    \    end\nend", "  -- This could obviously be replaced with return math.gcd(a,\
    \ b) -- or\n  -- -- return math.gcd(b, a), but that's not supported by Lua 5.2.\n\
    \  if a == 0 then return b end\n  if b == 0 then return a end\n  if a > b then\
    \ a, b = b, a end\n  local div = math.gcd(a, b)\n  return div * div\nend", " \
    \ assert(type(a) == 'number' and type(b) == 'number')\n  if a <= 0 or b <= 0 then\
    \ return 0 end\n  local d, q, r = a%b\n  while q > 0 and r > 0 do\n    d, q, r\
    \ = b%r, q, d\n  end\n  return d\nend", "  a = a or 0\n  b = b or 0\n  while b\
    \ > 0 do\n    local q = math.floor(a / b)\n    a = b\n    b = q\n  end\n  return\
    \ a\nend", "    -- Handle trivial case\n    if b == 1 then\n        return a\n\
    \    elseif b == 0 then\n        return 0\n    end", "  local r = 1\n  while b\
    \ > 0 do\n    local q = a / b\n    a = b\n    b = q\n    r = r + 1\n  end\n  return\
    \ r\nend", "  -- If no divisors are defined, return 0\n  if b == 0 then return\
    \ 1 end\n  if a == 0 then return b end", "  -- Simplify a negative by taking its\
    \ absolute value\n  -- >>> greatest_common_divisor(-3, -5)\n  -- 3\n  -- >>> greatest_common_divisor(7,\
    \ 7)\n  -- 7\n  -- >>> greatest_common_divisor(-7, 7)\n  -- 1\n  -- >>> greatest_common_divisor(1000000,\
    \ 3)\n  -- 3\n  if a < 0 then\n    a = -a\n    b = -b\n  end -- Make sure a and\
    \ b are both positive or both negative", "    if a == 0 then return b end\n  \
    \  if b == 0 then return a end\n    if a > b then a, b = b, a end\n    while b\
    \ > 0 do\n       local t = a % b\n       a = b\n       b = t\n    end\n    return\
    \ a\nend", "  -- Optimization:\n  if a >= b then\n    return a\n  end\n  if b\
    \ > a then\n    return b\n  end\n  -- Optimization:\n  if a == b then\n    return\
    \ a\n  end\n  -- Optimization:\n  if b == 1 then\n    return a\n  end\n  -- Optimization:\n\
    \  if a == 1 then\n    return b\n  end\n  -- The optimization below assumes a/b\
    \ > 2\n  -- If a * b > a / b then\n  --   return 1\n  -- end\n  -- If a * b >\
    \ b / a then\n  --   return b\n  -- end\n  -- Otherwise, a / b > 1, so\n  -- \
    \  return a / b\n  -- end\n  if a > 1 then\n    if b > 1 then\n      return a\
    \ / b\n    end\n    if b == 1 then\n      return a\n    end\n    return a\n  end\n\
    \  if b > 1 then\n    return b / a\n  end\n  if a == 1 then\n    return b\n  end\n\
    \  return a\nend", "    -- assert(type(a) == \"number\" and type(b) == \"number\"\
    )\n    -- assert(a ~= 0 and b ~= 0 and a ~= b and a < b)\n    if a == b then\n\
    \        return a\n    else\n        local remainder, divisor = a%b, a\n     \
    \   while remainder do\n            divisor = divisor + b\n            remainder,\
    \ a = remainder, a % divisor\n        end\n        return divisor\n    end\nend",
  "    assert(type(a) == \"number\" and type(b) == \"number\")\n    local function\
    \ gcd(x, y)\n        if x == 0 then\n            return y\n        elseif y ==\
    \ 0 then\n            return x\n        else\n            local a = x\n      \
    \      local b = y\n            while b != 0 do\n                local q = a %\
    \ b\n                a = b\n                b = q\n            end\n         \
    \   return a\n        end\n    end\n    return gcd(a, b)\nend", "    if a == 0\
    \ then\n        return b\n    elseif b == 0 then\n        return a\n    elseif\
    \ b < a then\n        a, b, _ = b, a, a\n    end\n    if a % b == 0 then\n   \
    \     return b\n    end", "  if b == 1 then return a else return greatest_common_divisor(b,\
    \ a % b) end\nend\n</cell>\n<text>\nNext we define a function using tail recursion.",
  "\tif b <= 0 then\n\t\treturn a\n\tend\n\treturn greatest_common_divisor(b, a %\
    \ b)\nend", "  -- This formula can be derived from the Euclid's algorithm:\n \
    \ -- https://en.wikipedia.org/wiki/Euclid's_algorithm\n  -- The greatest common\
    \ divisor of two numbers is\n  -- `g = gcd(a, b)`,\n  -- which is the same as\
    \ `(a \\ b) * b`, where `a` and `b`\n  -- are positive integers.\n  return math.floor((math.gcd(a,\
    \ b)) * (b / math.gcd(a, b)))\nend", "  if a > b then\n    a, b = b, a\n  end\n\
    \  while b > 0 do\n    local tmp = a % b\n    a = b\n    b = tmp\n  end\n  return\
    \ a\nend", "  local gcf = 1\n  while a ~= b do\n    a = a / 2\n    b = b / 2\n\
    \    gcf = gcf * 2\n  end\n  return gcf\nend", "    local r = a\n    local i =\
    \ 1\n    while i <= b do\n        if r > 0 then\n            r = r / i\n     \
    \   else\n            r = i / r\n        end\n        i = i + 2\n    end\n   \
    \ return r\nend\n</cell>\n<text>\nExercise: Write a function that takes as input\
    \ a matrix and the number of rows and columns as arguments and returns the row\
    \ and column counts of the input matrix. Print a message if the number of rows\
    \ or columns are less than 2.", "    local div, mod = div(a, function (x)\n  \
    \      return b == 0 and 0 or x % b\n    end), a % b\n    return div and mod and\
    \ div or 0\nend", "  if a == 0 then\n    return b\n  elseif a == b then\n    return\
    \ a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend", "   --\
    \ Taken from https://stackoverflow.com/questions/2068347/fastest-way-to-list-all-primes-below-n-in-python\n\
    \   -- Returns all primes smaller than n\n   -- This algorithm is much faster\
    \ than the Sieve of Eratosthenes\n   -- And is much simpler\n   -- See: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \   local sqrt_n = math.sqrt(math.floor(n/2))\n   if sqrt_n == 1 then return n\
    \ end\n   if n == 2 then return 1 end\n   if sqrt_n <= 2 then\n      -- Special\
    \ case for 2 <= sqrt(n) <= 2\n      a = a\n      b = b\n      local is_a_prime\
    \ = true\n      local is_b_prime = true\n      local i_1 = 2\n      local i_2\
    \ = 2\n      while i_2 <= sqrt_n do\n         if n % i_2 == 0 then\n         \
    \   is_a_prime = false\n         end\n         if n % i_1 == 0 then\n        \
    \    is_b_prime = false\n         end\n         if is_a_prime and is_b_prime then\
    \ return i_1 end\n         if is_b_prime and is_a_prime then return i_2 end\n\
    \         i_1 = i_1 + 1\n         i_2 = i_2 + 1\n      end\n      return i_1\n\
    \   end\n   -- Sieve of Eratosthenes up to sqrt_n\n   -- Note that i_1 and i_2\
    \ may reach sqrt(n), but we never test them\n   -- i_1 and i_2 are incremented\
    \ and decremented until we reach sqrt(n)\n   local i_1 = 2\n   local i_2 = 2\n\
    \   -- A prime (odd number that is not equal to 1)\n   local is_a_prime = true\n\
    \   -- A prime (odd number that is not equal to 1)\n   local is_b_prime = true\n\
    \   -- i_1 and i_2 are incremented and decremented until we reach sqrt(n)\n  \
    \ while i_2 <= sqrt_n do\n      if n % i_2 == 0 then\n         is_a_prime = false\n\
    \      end\n      if n % i_1 == 0 then\n         is_b_prime = false\n      end\n\
    \      if is_a_prime and is_b_prime then return i_1 end\n      if is_b_prime and\
    \ is_a_prime then return i_2 end\n      i_1 = i_1 + 1\n      i_2 = i_2 + 1\n \
    \  end\n   return i_1\nend", "  if b == 0 then\n    return a\n  elseif b == 1\
    \ then\n    return b\n  else\n    return greatest_common_divisor(b, a % b)\n \
    \ end\nend", "  if b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "  if a <= b or b == 0 then\n    return a\n  elseif b ==\
    \ 0 then\n    return a\n  end", "    if b == 0 then\n        return a\n    elseif\
    \ a == 0 then\n        return b\n    end", "    if a == 0 then return 0 end\n\
    \    local b = b or a\n    local div\n    for div = 1, a do\n        if b % div\
    \ == 0 then return div\n        end\n    end\n    return a\nend", "   assert(type(a)\
    \ == 'number' and type(b) == 'number')\n   assert(a > 0 and b > 0)", "  if a ==\
    \ 0 then return b end\n  if b == 0 then return a end\n  while a % b == 0 do\n\
    \    a = math.floor(a)\n    b = math.floor(b)\n  end\n  return b\nend", "  if\
    \ a == 0 or b == 0 then return 0 end\n  local result = 1\n  while a ~= 0 and b\
    \ ~= 0 do\n    local m = math.mod(a, b)\n    a, b = b, m\n    result, a = result,\
    \ a\n  end\n  return result\nend", "  local div = 1\n  while b > 0 do\n    local\
    \ t = a % b\n    a = b\n    b = t\n    div = div * 10 + 1\n  end\n  return div\n\
    end", "  local div = a % b\n  if div > 0 then\n    return greatest_common_divisor(b,\
    \ div)\n  else\n    return b\n  end\nend", "   if b == 1 then return b end\n \
    \  if a % b == 0 then return b end\n   if b == 2 then return a\n   elseif b <\
    \ a then return greatest_common_divisor(b, a) end\n   return a\nend", "    if\
    \ a == 0 then\n        return b\n    end\n    if b == 1 then\n        return a\n\
    \    end\n    if a ~= b or a == 0 then\n        return greatest_common_divisor(b,\
    \ a % b)\n    end\n    return greatest_common_divisor(b, a / b)\nend", "  if b\
    \ == 1 then return b end\n  local r = a\n  while b > 0 do\n    if r == 0 or r\
    \ == a then break end\n    local quo = math.floor(a/b); a = a % b\n    if a ==\
    \ 0 then break end\n    r = quo\n  end\n  return r\nend", "  if b < a then\n \
    \   a, b = b, a\n  end\n  for i = 1, a do\n    while b % i == 0 do\n      b =\
    \ b div i\n    end\n    if b == i then\n      return i\n    end\n  end\n  return\
    \ b\nend", "    if a == 0 then return b\n    end\n    if b == 0 then return a\n\
    \    end\n    if a > b then a, b = b, a\n    end\n    local n = a\n    while n\
    \ ~= 0 do\n        local d = b\n        local m = n / 2\n        while m ~= 0\
    \ do\n            if n % m == 0 then return m\n            end\n            d\
    \ = d / 2\n            m = m / 2\n        end\n        n = n + 1\n    end\n  \
    \  return a\nend", "  if b == 1 then\n    return a\n  end\n  if a == 0 then\n\
    \    return b\n  end", "  if b == 0 then return a\n  elseif b < a then return\
    \ greatest_common_divisor(b, a) end\n  local gcd = math.gcd(a, b)\n  return b\
    \ * gcd / gcd\nend", "  local m = a\n  local n = b\n  while m % n ~= 0 do\n  \
    \  m = m * 2\n    n = n + 1\n  end\n  return m\nend", "  if b == 0 then return\
    \ a\n  elseif a > b then return greatest_common_divisor(b, a) end\n  while a %\
    \ b == 0 do\n    a = a / b\n  end\n  return a\nend", "\t-- a / b --> gcd(a, b)\
    \ --> gcd of a and b\n\t-- gcd(a, b) = gcd(b, a mod b)\n\treturn b % a == 0 and\
    \ a % b == 0\n\t\tand greatest_common_divisor(b, a % b) or greatest_common_divisor(a,\
    \ b)\nend", "  if a == 0 and b == 0 then return 0 end\n  local d = 0\n  local\
    \ k = math.floor(a)\n  while k <= b do\n    d = math.max(d,k);\n    k = k + 1;\n\
    \  end\n  return d\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
