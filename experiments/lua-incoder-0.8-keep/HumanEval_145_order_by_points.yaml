name: HumanEval_145_order_by_points
language: lua
prompt: "-- Write a function which sorts the given list of integers\n-- in ascending\
  \ order according to the sum of their digits.\n-- Note: if there are several items\
  \ with similar sum of their digits,\n-- order them based on their index in original\
  \ list.\n-- For example:\n-- >>> order_by_points([1, 11, -1, -11, -12]) == [-1,\
  \ -11, 1, -12, 11]\n-- >>> order_by_points([]) == []\nlocal function order_by_points(nums)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = order_by_points\n\
  \    lu.assertEquals(candidate({1, 11, -1, -11, -12}), {-1, -11, 1, -12, 11})\n\
  \    lu.assertEquals(candidate({1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
  \ 3, 56, 0, 46}), {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457})\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, -11,\
  \ -32, 43, 54, -98, 2, -3}), {-3, -32, -98, -11, 1, 2, 43, 54})\n    lu.assertEquals(candidate({1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9})\n    lu.assertEquals(candidate({0,\
  \ 6, 6, -76, -21, 23, 4}), {-76, -21, 0, 4, 23, 6, 6})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local function compare(a,b) return b > a end\n  local sorted = {}\n\
    \  for i = 1, #nums do\n    sorted[#sorted + 1] = nums[i]\n  end\n  table.sort(sorted,\
    \ compare)\n  return sorted\nend", "    if not nums or #nums == 0 then\n     \
    \   return nums\n    end", "  local result = {}\n  for i = 1, #nums do\n    local\
    \ sum = 0\n    local num_digits = #(nums[i]/10)\n    for j = 1, num_digits do\n\
    \      sum = sum + math.floor(nums[i] / math.pow(10, j))\n      i = i - 1\n  \
    \  end\n    result[#result + 1] = nums[i - 1] + sum\n  end\n  return result\n\
    end", "  if nums == nil then return end\n  local sum = 0\n  for i = 1, #nums do\n\
    \    local tmp_sum = sum + tonumber(tostring(nums[i]))\n    if tmp_sum > sum then\n\
    \      sum = tmp_sum\n    end\n  end\n  return nums\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for your answer,I got it wrongly and now I edit my question.\n\
    <|/ c |>\n<| c |>\nSo you need to sort them based on the number of digits\n<|/\
    \ c |>\n<| c |>\nSo `order_by_points` should return an array of integers?\n<|/\
    \ c |>\n<| c |>\nyep,like I edited,but I think this method is too complicated,so\
    \ any ideas to make it simple ?\n<|/ c |>\n<| a tags=lua |>\n<code>", "    local\
    \ sums = {}\n    for _, i in pairs(nums) do\n        sums[i] = sums[i] or 0\n\
    \        sums[i] = sums[i] + i\n    end\n    table.sort(sums, function(a, b)\n\
    \        return a > b end\n    )\n    local results = {}\n    for _, i in pairs(nums)\
    \ do\n        results[i] = sums[i]\n    end\n    return results\nend", "  if #nums\
    \ < 1 then\n    return nums\n  end", "  if nums == nil then return nil end\n \
    \ local ordered = {}\n  local sum = 0\n  for _, v in ipairs(nums) do\n    sum\
    \ = sum + v\n    ordered[#ordered + 1] = '.' .. tostring(v)\n  end\n  table.sort(ordered,\
    \ function(a,b)\n    return tonumber(a:sub(1,-1)) < tonumber(b:sub(1,-1))\n  end)\n\
    \  return ordered\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  local\
    \ sorted = {}\n  for _, v in ipairs(nums) do\n    table.insert(sorted, v)\n  end\n\
    \  table.sort(sorted, function(a, b) return a.sum - b.sum end)\n  return sorted\n\
    end", "  -- Your code here!\nend", "  local map = {}\n  for i = 1, #nums do\n\
    \    local digits = string.format('%q', nums[i])\n    map[#map + 1] = map[i] or\
    \ digits -- get rid of duplicates\n  end\n  table.sort(map)\n  return map\nend",
  "  local num_map = {}\n  local ordered = {}\n  for i = 1, #nums do\n    local sum_of_digits\
    \ = 0\n    for j = 1, 10 do\n      local n = math.floor(nums[i]/10)*10 + nums[i]%10\n\
    \      sum_of_digits = sum_of_digits + math.abs(n)\n      i = i + 1\n      if\
    \ num_map[n] then num_map[n] = num_map[n] + 1 else\n        num_map[n] = i\n \
    \     end\n    end\n    local num_key = sum_of_digits\n    if num_map[ num_key\
    \ ] then\n      num_key = num_map[ num_key ]\n    end\n    ordered[num_key] =\
    \ nums[i]\n  end\n  return ordered\nend\nreturn order_by_points", "   local sorted\
    \ = {}\n   for i = 1, #nums do\n      local digits = num:div(10):floor()\n   \
    \   if not sorted[digits] then\n         sorted[digits] = i\n      elseif sorted[digits]\
    \ ~= i then\n         sorted[digits]:insert(i)\n      end\n   end\n   return table.sort(sorted)\n\
    end", "    local t = {}\n    for i, v in ipairs(nums) do\n        for j = 1, 10\
    \ do\n            local n = v % 10\n            v = math.floor(v / 10)\n     \
    \       if n <= v then\n                break\n            else\n            \
    \    t[i] = v\n            end\n        end\n    end\n    return t\nend", "  local\
    \ i, n = nums:getn(nums)\n  if n == 0 then\n    return nil\n  end\n  local sums\
    \ = {}\n  for i = 1, n do\n    local digits = {}\n    for j = 1, i do\n      digits[j]\
    \ = nums[j] % 10\n      local next_digit = nums[j] / 10\n      nums[j] = next_digit\n\
    \    end\n    sums[i] = digits.reduce(0, function(a, b)\n      return a + b\n\
    \    end)\n  end\n  return sums.key\nend", "  local max_sum = tonumber(0)\n  local\
    \ max_sum_pos = 0\n  local max_index = nil\n  local i, j, k, k1, j1, max_sum_val",
  "   local sums = {}\n   for i = 1, #nums do\n      local sum = sum(nums, i)\n  \
    \    if not sums[sum] then\n         sums[sum] = {}\n      end\n      sums[sum][i]\
    \ = nums[i]\n   end\n   return sums\nend", "  local result = {}\n  local sum =\
    \ 0\n  for _, num in ipairs(nums) do\n    sum = sum + num\n    result[sum] = num\n\
    \  end\n  table.sort(result, function (a, b)\n    return a.num - b.num\n  end)\n\
    \  return result\nend", "  if nums == nil then\n    return nil\n  end", "  return\
    \ sort(function(a, b) return a + b - tonumber(tostring(a:sub(-2, -2):sub(-2, -1)))\
    \ end, nums)\nend", "  if #nums < 2 then\n    return nums\n  end", "   -- Base\
    \ case\n   if #nums < 2 then\n      return nums\n   end", "  if #nums == 0 then\n\
    \    return nums\n  end\n  local n = math.pow(10, math.ceil(math.log(math.max(nums))))\n\
    \  local sum_digits = {}\n  for i = 1, #nums do\n    local digits = string.format(\"\
    %.\" .. n .. \"g\", nums[i])\n    sum_digits[i] = tonumber(digits:sub(1, digits:len()\
    \ - 1))\n  end\n  table.sort(nums, function(a, b) return sum_digits[a] > sum_digits[b]\
    \ end)\n  return nums\nend", "  local sum = 0\n  for i = 1, #nums do\n    sum\
    \ = sum + tostring(nums[i])\n  end\n  return nums[#nums] .. tostring(sum)\nend",
  "    if not nums or not nums[#nums] then\n        return nums\n    end", "    local\
    \ nums0 = {x = 0, y = 0, z = 0}\n    for i, v in ipairs(nums) do\n        local\
    \ n = v:byte()\n        local sum = n * 10 + v.byte()\n        if nums0[sum] then\n\
    \            nums0[sum].i = i\n            nums0[sum].v = v\n        else\n  \
    \          nums0[sum] = {i = i, v = v}\n        end\n    end\n    local n = #nums0\n\
    \    local nums1 = {}\n    for i = 1, n do\n        local t = nums0[i]\n     \
    \   if t then\n            local v = 0\n            for k, v in pairs(nums0) do\n\
    \                if v == i then\n                    v.x = t.x\n             \
    \       v.y = t.y\n                    v.z = t.z\n                    break\n\
    \                end\n            end\n            table.insert(nums1, v)\n  \
    \      end\n    end\n    return nums1\nend", "  if nums == nil then\n    return\
    \ nil\n  end\n  local result = {}\n  for i, v in ipairs(nums) do\n    if v ==\
    \ 0 then\n      result[i] = nil\n      continue\n    end\n    local resultSum\
    \ = 0\n    for j = 1, (v:len() + 1) do\n      local c = v:sub(j, j):lower()\n\
    \      resultSum = resultSum * 10 + tonumber(c)\n    end\n    result[i] = resultSum\n\
    \  end\n  return table.sort(result, function (a, b) return b - a end)\nend", " \
    \ if #nums == 0 then return nums end\n  local max = 0\n  local index = nil\n \
    \ local sum = 0\n  local sorted_nums = nums\n  local n = #sorted_nums\n  for i\
    \ = 1, n do\n    local value = tonumber(tostring(sorted_nums[i]))\n    sum = sum\
    \ + value\n    if max < sum then max = sum end\n    if value == max then\n   \
    \   if index == nil then\n        index = i\n      else\n        index = nil\n\
    \      end\n    end\n  end\n  if index == nil then\n    return sorted_nums\n \
    \ end\n  local num_left = n - index - 1\n  if num_left <= 0 then\n    return sorted_nums\n\
    \  end\n  local left = tonumber(tostring(sorted_nums[index + 1]))\n  local right\
    \ = tonumber(tostring(sorted_nums[index]))\n  local temp, new_max\n  if left >\
    \ right then\n    temp, new_max = left, right\n    right = temp\n    new_max =\
    \ tonumber(tostring(right))\n  else\n    temp, new_max = right, left\n    left\
    \ = temp\n    new_max = tonumber(tostring(left))\n  end\n  if new_max > max then\n\
    \    max = new_max\n    index = index + 1\n  end\n  if num_left > 0 then\n   \
    \ local left_value = tonumber(tostring(sorted_nums[index + 1]))\n    if left_value\
    \ > max then\n      max = left_value\n      index = index + 1\n    end\n  end\n\
    \  if max > 0 then\n    local sum = 0\n    local i = index + 1\n    for j = i,\
    \ #sorted_nums do\n      local value = tonumber(tostring(sorted_nums[j]))\n  \
    \    sum = sum + value\n      if sum == max then\n        return sorted_nums[#sorted_nums]\n\
    \      end\n    end\n  end\nend\nreturn {\n  order_by_points,\n}\nend", "  if\
    \ nums == nil then return nil end\n  if nums == () then return nums end\n  if\
    \ nums:size() == 1 then\n    return nums\n  end", "  local sorted = {}\n  for\
    \ _, num in ipairs(nums) do\n    sorted[#sorted + 1] = {\n      value = num,\n\
    \      digit = math.floor(math.abs(num)),\n    }\n  end", "  local nums_sorted,\
    \ i, j, sorted_idx\n  sorted_idx = {}\n  local sums = {}\n  for i = 1, #nums do\n\
    \    sums[#sums+1] = nums[i]:digits():sum()\n  end\n  nums_sorted = table.sort(nums,\
    \ function(a,b) return sums[a]-sums[b] end)\n  for i = 1, #nums_sorted do\n  \
    \  sorted_idx[#sorted_idx+1] = i\n  end\n  return table.unpack(nums_sorted,sorted_idx)\n\
    end", "  if nums == nil then\n    return nil\n  end", "  local n = #nums\n  --\
    \ First sort by sum of digits\n  if n > 0 then\n    local sum_so_far = nums[n\
    \ - 1]\n    for i = n - 1, 1, -1 do\n      local current_sum = nums[i]\n     \
    \ while current_sum > sum_so_far do\n        sum_so_far = sum_so_far + current_sum\n\
    \        -- We only need to find sums of previous sums now\n        -- We also\
    \ need to find the smallest sums first to not break\n        -- the following\
    \ loop\n        local j = i\n        while j <= n and nums[j - 1] > current_sum\
    \ do\n          j = j - 1\n        end\n        -- Swap\n        if j > i then\n\
    \          local tmp\n          tmp = nums[i]\n          nums[i] = nums[j]\n \
    \         nums[j] = tmp\n        end\n      end\n    end\n  end\n  return nums\n\
    end", "    local nums_sorted = {}\n    for i=1, #nums do\n        local n = {\n\
    \            n = tonumber(string.format(\"%0.1f\", nums[i])),\n            i =\
    \ i\n        }\n        table.insert(nums_sorted, n)\n    end\n    table.sort(nums_sorted,\
    \ function(x,y)\n        if x.n > y.n then\n            return 1\n        elseif\
    \ x.n < y.n then\n            return -1\n        else\n            return x.i\
    \ - y.i\n        end\n    end)\n    return table.unpack(nums_sorted)\nend", " \
    \ if #nums == 0 then\n    return nums\n  end", "  if nums == nil then\n    return\
    \ nums\n  end", "  local n = {}\n  for i = 1, #nums do\n    local sum = 0\n  \
    \  for j = 1, 10 do\n      sum = sum + nums[i]:byte(j) / 9\n    end\n    n[i]\
    \ = sum\n  end\n  table.sort(n)\n  for i = 1, #nums do\n    nums[i] = n[i]\n \
    \ end\nend", "  -- Write your implementation here.\n  return nil\nend", "  if\
    \ not nums then return end\n  local digits = {}\n  local sum = 0\n  for i = 1,\
    \ #nums do\n    local digit = nums[i] % 10\n    if digits[digit] == nil then\n\
    \      digits[digit] = i\n    else\n      digits[digit] = digits[digit] and digits[digit]\
    \ or i\n    end\n    sum = sum + digit\n  end\n  table.sort(nums, function(a,\
    \ b)\n    return sum - tostring(a) + tostring(b) or tostring(a) - tostring(b)\n\
    \  end)\n  return nums\nend", '  if #nums < 2 then return nums end', "  -- TODO:\
    \ optimize\n  local max_value = nums[1]\n  local max_index = nil\n  for i = 2,\
    \ #nums do\n    local value = nums[i]\n    if value > max_value then\n      max_value\
    \ = value\n      max_index = i\n    end\n  end\n  local result = {max_value}\n\
    \  for _, value in ipairs(nums) do\n    if value == max_value then\n      result[#result\
    \ + 1] = max_index\n    end\n  end\n  return result\nend", "  if not nums then\
    \ return end\n  local digits = {}\n  local index\n  for i = 1, 10 do\n    index\
    \ = digits[i]+1\n    digits[i] = index\n  end\n  local results = {}\n  local i\
    \ = 1\n  while i <= #nums do\n    local candidate = nums[i]\n    local sum = digits[candidate]\n\
    \    local j = i\n    while j <= #nums and digits[nums[j]]+1 == sum do\n     \
    \ j = j + 1\n    end\n    if j < i then\n      table.insert(results, nums[i]:reverse())\n\
    \      i = j\n      table.insert(results, nums[i]:reverse())\n    end\n  end\n\
    \  local final_result = {}\n  for j = 1, #results do\n    table.insert(final_result,\
    \ results[j]:reverse())\n  end\n  return final_result\nend", "  local sums = {}\n\
    \  local n = 1\n  for i = 1, #nums do\n    local s = math.floor(math.abs(nums[i])\
    \ / math.pow(10, n))\n    sums[s] = sums[s] or 0\n    sums[s] = (sums[s] + nums[i])\
    \ % (10^n)\n    n = n + 1\n  end\n  return table.sort(sums)\nend", "  if #nums\
    \ == 0 then\n    return nums\n  end\n  local sorted = {}\n  for i = 1, #nums do\n\
    \    local sum = 0\n    for j = 1, 10 do\n      sum = (sum * 10) + nums[i]:digit(j)\n\
    \    end\n    table.insert(sorted, sum)\n  end\n  table.sort(sorted)\n  return\
    \ table.unpack(sorted)\nend", "  local n = #nums\n  -- Write your code here.\n\
    \  -- Hint: use an auxiliary array and loop through nums\n  -- Hint: each iteration,\
    \ add the digit of the current number\n  -- index (i) and the digit of the previous\
    \ number (i-1) to the sum\n  -- variable. Also, don't forget to increment i by\
    \ 1.\n  return nums\nend", "  local counts = {}\n  for _, v in ipairs(nums) do\n\
    \    if counts[v] then\n      counts[v] = counts[v] + 1\n    else\n      counts[v]\
    \ = 1\n    end\n  end\n  local max_count = -math.infinity\n  for k, v in pairs(counts)\
    \ do\n    if max_count < v then\n      max_count = v\n    end\n  end\n  -- create\
    \ temp array to sort by\n  local t = {}\n  local index = 1\n  for k, v in pairs(counts)\
    \ do\n    if max_count == v then\n      t[index] = k\n      index = index + 1\n\
    \    end\n  end\n  table.sort(t, function(a, b) return t[a] < t[b] end)\n  --\
    \ rearrange the original list\n  local new_nums = {}\n  for i, v in ipairs(t)\
    \ do\n    new_nums[#new_nums+1] = v\n  end\n  return new_nums\nend", "  -- Sort\
    \ `nums` in ascending order by their sum of digits.\n  -- Note: if there are several\
    \ items with similar sum of digits,\n  -- order them based on their index in original\
    \ list.\n  -- For example:\n  -- >>> order_by_points([1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11]\n  -- >>> order_by_points([]) == []\n  -- >>> order_by_points([1,\
    \ 2, 1]) == [1, 2]\n  -- >>> order_by_points([1, 7, 3, 15, 5]) == [1, 3, 5, 7,\
    \ 15]\n  -- >>> order_by_points([13, 9, 1, 12]) == [12, 9, 13, 1]\n  -- >>> order_by_points([1,\
    \ 1, 2, -5, -3]) == [-3, -5, 1, 2, 1]\n  -- >>> order_by_points([101, 102, 103,\
    \ -100, -2, -10, 10, 9, -7, -10, 11, 2, -8, -8, -13]) == [-100, -101, -10, -13,\
    \ -8, -8, -7, -10, -10, -2, 2, -9, 9, 2, 12, 13, 103, 102, 101]\n  -- >>> order_by_points([10,\
    \ 1, -10, 100]) == [-100, -10, 10, 1]\n  -- >>> order_by_points([-8, -8, 8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8]) == [-8, -8, 8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8]\n  -- >>> order_by_points([10, -20, 10, -10, 10, -10, 10, 20, 10,\
    \ -10]) == [-10, -10, 10, -20, 10, 10, 20, 10, 10]\n  -- >>> order_by_points([10,\
    \ -20, 10, -10, 10, -10, 10, 20, 10, -10, 10, 10]) == [-10, -10, 10, -20, 10,\
    \ 10, 20, 10, 10, 10, 10]\n  -- >>> order_by_points([10, -20, 10, -10, 10, -10,\
    \ 10, 20, 10, -10, 10, 10, 10]) == [-10, -10, 10, -20, 10, 10, 20, 10, 10, 10,\
    \ 10, 10]\n  -- >>> order_by_points([10, -20, 10, -10, 10, -10, 10, 20, 10, -10,\
    \ 10, 10, 10, 10]) == [-10, -10, 10, -20, 10, 10, 20, 10, 10, 10, 10, 10, 10]\n\
    \  -- >>> order_by_points([10, -20, 10, -10, 10, -10, 10, 20, 10, -10, 10, 10,\
    \ -10, 10, 10]) == [-10, -10, 10, -20, 10, 10, 20, 10, 10, 10, 10, 10, 10]\n \
    \ -- >>> order_by_points([10, -20, 10, -10, 10, -10, 10, 20, ", "  local sorted_nums\
    \ = nums[:]\n  table.sort(\n    sorted_nums,\n    function(x, y)\n      local\
    \ x_digits = x:gsub('.', ''):gsub('%d+', '%d')\n      local y_digits = y:gsub('.',\
    \ ''):gsub('%d+', '%d')\n      return x_digits + y_digits == '0000' or\n     \
    \        x_digits + y_digits == '000' or\n             x_digits + y_digits ==\
    \ '00' or\n             x_digits + y_digits == '0' or\n             x_digits <\
    \ y_digits\n    end\n  )\n  return sorted_nums\nend", "  local sum = 0\n  local\
    \ num_sorted = {}\n  for _, v in ipairs(nums) do\n    sum = sum + v \n    table.insert(num_sorted,\
    \ v)\n  end\n  table.sort(num_sorted, function(left, right) return sum - left\
    \ < right - sum end)\n  \n  return num_sorted\nend", "  -- sort the given list\
    \ to ascending order according to the sum of their digits\n  local sorted_nums\
    \ = table.sort\n    ( function (a, b)\n      -- compare the sum of digits of two\
    \ numbers, a < b\n      -- (the sum of digits of b should be larger than the sum\
    \ of digits of a if numbers are distinct)\n      return (digitSum(b) > digitSum(a))\
    \ and 1 or -1\n    end)\n  for _, num in ipairs(nums) do\n    sorted_nums(num,\
    \ 1)\n  end\n  -- return the original list if the numbers have the same sum\n\
    \  return table.tolist(nums)\nend", "    local nums_copy = nums\n    local num_digits\
    \ = {} -- Stores number of digits per integer\n    for i = 1, #nums_copy do\n\
    \        local d = math.floor(math.log10(nums_copy[i]))\n        if #num_digits\
    \ < d then\n            num_digits = {}\n        end\n        num_digits[#num_digits\
    \ + 1] = num_digits[d] or 0\n        num_digits[d] = num_digits[d] + 1\n    end\n\
    \    nums_copy = nil\n    local ans = {}\n    local next_pos = 1\n    for i =\
    \ 1, #num_digits do\n        -- Find the next position from right to left\n  \
    \      while next_pos < #nums_copy do\n            local digit = num_digits[next_pos]\n\
    \            if not digit then break end\n            local cur_sum = nums_copy[next_pos]\
    \ * 10 + digit\n            if cur_sum > ans[#ans] then\n                local\
    \ pos = next_pos\n                while next_pos < #nums_copy do\n           \
    \         next_pos = next_pos + 1\n                    if num_digits[next_pos]\
    \ == digit then\n                        -- We found the position with smallest\
    \ sum\n                        -- Remove it from nums_copy and add it to ans\n\
    \                        local new_pos = next_pos\n                        while\
    \ new_pos < #nums_copy do\n                            new_pos = new_pos + 1\n\
    \                            ans[#ans + 1] = {nums_copy[new_pos]}\n          \
    \                  nums_copy[new_pos] = nil\n                        end\n   \
    \                     break\n                    end\n                end\n  \
    \          end\n        end\n        next_pos = next_pos + 1\n    end\n    return\
    \ ans\nend", '  if #nums < 2 then return nums end', "  local sum = 0\n  local\
    \ index = 0\n  local length = 1\n  for i = 1, #nums do\n    local n = tonumber(nums[i])\n\
    \    index = i + index\n    length = length + n\n    sum = sum + n\n  end\n  if\
    \ length > 1 then\n    index = math.max(index, 1)\n  end\n  local order = {}\n\
    \  local i = 0\n  for i = 1, #nums do\n    local n = tonumber(nums[i])\n    local\
    \ s = sum - n\n    if s <= 0 then\n      order[index + i] = s\n      sum = 0\n\
    \    else\n      index = index - n\n      sum = 0\n    end\n  end\n  return order\n\
    end", "  if nums == nil then return end\n  local i = 0\n  local sum = 0\n  for\
    \ i = 1, #nums do\n    local digit = tonumber(string.format('%g', nums[i]))\n\
    \    if digit == 0 then break end\n    sum = sum + digit\n  end\n  if sum == 0\
    \ then return nums end\n  for i = 1, #nums do\n    local digit = tonumber(string.format('%g',\
    \ nums[i]))\n    if digit == 0 then break end\n    if sum < digit then\n     \
    \ local t = nums[i]\n      nums[i] = nums[sum]\n      nums[sum] = t\n    end\n\
    \    sum = sum - digit\n  end\n  return nums\nend", "  local result = {}\n  local\
    \ digits = {} -- a map from digit to index in nums\n  local index = 0 -- index\
    \ in nums\n  for i = 1, 10 do\n    digits[i] = index\n    index = (index + 1)\
    \ % 10\n  end", "  if nums == nil then return nums end\n  local sums = {}\n  for\
    \ i = 1, #nums do\n    local sum = nums[i]\n    for j = 1, #sums do\n      if\
    \ sum >= sums[j] and sum < sums[j + 1] then\n        sum = sums[j]\n      else\n\
    \        sum = sums[j + 1]\n      end\n    end\n    sums[#sums + 1] = sum\n  end\n\
    \  return table.concat(sums)\nend", "  if nums == nil then return nil end\n  local\
    \ n = #nums\n  local m = {}\n  for i = 1, n do\n    local sum_of_digits = 0\n\
    \    for j = 1, (n / 10) + 1 do\n      sum_of_digits = sum_of_digits + nums[j]\
    \ * math.pow(10, j - 1)\n    end\n    if m[sum_of_digits] then\n      local idx\
    \ = m[sum_of_digits]\n      local tmp = nums[idx]\n      nums[idx] = nums[n]\n\
    \      nums[n] = tmp\n    else\n      m[sum_of_digits] = i\n    end\n  end\n \
    \ return nums\nend\nreturn order_by_points", "  if nums == nil then\n    return\
    \ nil\n  end\n  local ns = {}\n  local n = 1\n  local sum = 0\n  for i = 1, #nums\
    \ do\n    local n = nums[i]\n    local digits = math.floor(n / 10)\n    local\
    \ rest = n % 10\n    sum = sum + digits*10 + rest\n    ns[sum] = ns[i]\n  end\n\
    \  ns[#ns + 1] = nil\n  local ordered = {}\n  local i = 1\n  for _,v in pairs(ns)\
    \ do\n    if v ~= nil then\n      ordered[#ordered + 1] = i\n      i = i + 1\n\
    \    end\n  end\n  table.sort(ordered, function(a,b) return compare_digits(a,b)\
    \ end)\n  -- Return original list if there are no numbers left.\n  if i == 1 then\n\
    \    return nums\n  end\n  return ordered\nend", "  if not nums then\n    return\
    \ nums\n  end\n  local sum = 0\n  for i = 1, #nums do\n    local current_sum =\
    \ sum + nums[i]\n    if current_sum > sum then\n      sum, idx = current_sum,\
    \ i + 1\n    end\n  end\n  return list.rev(nums):map(function(x) return x + idx\
    \ end)\nend", "  local sorted_index = 1\n  local sorted_points = {}\n  local next_index\
    \ = 1\n  local next_points = {}\n  for i = 1, #nums do\n    local sum = 0\n  \
    \  for j = 1, 10 do\n      local tmp = string.sub(tostring(nums[i]), j, j + 1)\n\
    \      sum = sum + tonumber(tmp)\n    end\n    if next_index == sorted_index then\n\
    \      table.insert(sorted_points, next_points)\n      next_index = next_index\
    \ + 2\n      next_points = {}\n    end\n    local new_point = tonumber(sum / 10)\n\
    \    next_points[new_point] = next_points[new_point] or nums[i]\n  end\n  table.insert(sorted_points,\
    \ next_points)\n  table.sort(sorted_points, compare)\n  return sorted_points\n\
    end", "  local numTable = {}\n  local i = 1\n  for n in nums do\n    local sum\
    \ = 0\n    while n > 0 do\n      sum = sum + n % 10\n      n = n / 10\n    end\n\
    \    table.insert(numTable, sum)\n  end\n  table.sort(numTable)\n  local ret =\
    \ {}\n  for _, v in ipairs(numTable) do\n    table.insert(ret, v)\n  end\n  return\
    \ ret\nend", "  if #nums == 0 then return [] end\n  local results = {}\n  local\
    \ i = 1\n  while i < #nums do\n    local digits = 0\n    for j = 1, 10 do\n  \
    \    digits = digits + nums[i+j-1]\n    end\n    local sum = 0\n    for j = 1,\
    \ digits do\n      sum = sum + math.floor(nums[i+j-1])\n    end\n    if sum >\
    \ 0 then\n      results[i] = nums[i]\n      i = i + 1\n    end\n  end\n  table.sort(results,\
    \ function (x,y) return x+y end)\n  return results\nend", "  if not nums then\n\
    \    return []\n  end", "  if #nums == 0 then\n    return nums\n  end\n  local\
    \ sums = {}\n  for i = 1, #nums do\n    local current_sum = 0\n    for j = 1,\
    \ 10 do\n      current_sum = current_sum + tonumber(string.format('%.2g', nums[i])):sub(1,\
    \ j - 1)\n    end\n    sums[current_sum] = sums[current_sum] or i\n  end\n  local\
    \ nums_sorted = {}\n  for i = 1, 10 do\n    local j = sums[i]\n    if j then\n\
    \      nums_sorted[j] = nums[i]\n    end\n  end\n  return nums_sorted\nend", " \
    \ if #nums <= 0 then\n    return nums\n  end\n  local sums = {}\n  for i = 1,\
    \ #nums do\n    local sum = sum or 0\n    for j = 1, 10 do\n      sum = sum +\
    \ math.floor(nums[i] / math.pow(10, j))\n    end\n    sums[i] = sum\n  end\n \
    \ local sorted = {}\n  for i = #sums, 1, -1 do\n    local key = sums[i]\n    table.insert(sorted,\
    \ key)\n  end\n  table.sort(sorted)\n  -- Reverse the sorted array so it is in\
    \ ascending order instead of descending order.\n  local reversed = {}\n  for i\
    \ = 1, #sorted do\n    reversed[i] = sorted[#sorted]\n  end\n  return reversed\n\
    end", "  if #nums < 2 then\n    return nums\n  else\n    -- sort them from smallest\
    \ to largest\n    return order_by_point(nums[math.abs(#nums - 1)],\n         \
    \                 nums[#nums])\n  end\nend", "  if #nums == 0 then\n    return\
    \ nums\n  end", "  local sorted_nums = nums\n  -- We start from 1 to skip 0 sum\
    \ items.\n  for i = 1, #nums do\n    local cur_sum = #nums - i + 1\n    local\
    \ pos = i\n    local cur_sum_tmp = cur_sum\n    for j = i, #nums do\n      --\
    \ We only sort if sum is changed or new item is larger then previous.\n      if\
    \ cur_sum_tmp < cur_sum or i == j then\n        pos = j\n        cur_sum_tmp =\
    \ cur_sum\n      end\n    end\n    -- Swap current item with that of its swapped\
    \ position.\n    sorted_nums[i], sorted_nums[pos] = sorted_nums[pos], sorted_nums[i]\n\
    \  end\n  return sorted_nums\nend", "    local sorted = {}\n    for _, num in\
    \ pairs(nums) do\n        sorted[#sorted + 1] = num\n    end\n    table.sort(sorted,\
    \ function(a, b) return a.sum > b.sum end)\n    return sorted\nend", "  if nums\
    \ == nil then return end\n  local nums_sorted = {}\n  local num_sum = 0\n  --\
    \ Sum each digit to num_sum\n  for i = 1, #nums do\n    num_sum = num_sum + nums[i]\n\
    \    -- Use num_sum as the index for nums_sorted if it is unique.\n    -- Use\
    \ i as index for nums_sorted if nums_sorted has not been used yet.\n    if nums_sorted[num_sum]\
    \ == nil then\n      nums_sorted[num_sum] = i\n    end\n  end\n  -- Reverse the\
    \ list\n  for i = #nums, 1, -1 do\n    table.insert(nums_sorted, nums[i])\n  end\n\
    \  return nums_sorted\nend\norder_by_points = {}", "  if not nums or #nums ==\
    \ 0 then\n    return nums\n  end", "   local sum = 0\n   for i, v in ipairs(nums)\
    \ do\n      sum = sum + v\n   end", "  if nums == nil then return end\n  local\
    \ numsSize = #nums\n  local numsSizeReduced = {}\n  local maxSum = 0\n  for index\
    \ = 1, numsSize do\n    local sum = digits(nums[index])\n    if sum > maxSum then\n\
    \      maxSum = sum\n    end\n  end\n  local sortedNums = {}\n  for index = 1,\
    \ numsSize do\n    local sum = digits(nums[index])\n    if sum == maxSum then\n\
    \      table.insert(sortedNums, index)\n    end\n  end\n  table.sort(sortedNums,\
    \ function(a, b) return a<b end)\n  for index = 1, numsSize do\n    local index\
    \ = sortedNums[index]\n    local newNum = nums[index]\n    nums[index] = numsSizeReduced[newNum]\n\
    \    numsSizeReduced[newNum] = index\n  end\n  return nums\nend", "  local nums_copy\
    \ = nums\n  -- Find sum of digits first by converting them to a string, then\n\
    \  -- getting the string digits by substring(). Now we have\n  -- a string and\
    \ can sort it by characters.\n  local nums_copy_c = nums_copy:map(\n    function(num)\n\
    \      return string.format(\"%g\", num)\n    end)\n  -- Sort strings first by\
    \ their number of digits, then by their characters.\n  table.sort(nums_copy_c,\
    \ function(a, b)\n    -- Count the number of times a character appears in the\
    \ string\n    local counter = a:sub(1, 1):gsub(\"^%s\", \"\"):gsub(\"%s$\", \"\
    \"):gsub(\"^%s+\", \"\")\n    if counter == 0 then\n      return true\n    end\n\
    \    return b < a\n  end)\n  -- Rearrange the numbers by sorting on the string's\
    \ length and then alphabetically\n  return nums_copy_c\nend", "    local function\
    \ get_sum_of_digits(num)\n        local num_str = tostring(num)\n        local\
    \ sum = 0\n        for i = 1, #num_str do\n            sum = sum + tonumber(num_str:sub(i,i))\n\
    \        end\n        return sum\n    end\n    local sums = {}\n    for i = 1,\
    \ #nums do\n        sums[i] = get_sum_of_digits(nums[i])\n    end\n    local sorted_sums\
    \ = helper.sort_by_values(sums)\n    local num_sorted = {}\n    for i = 1, #nums\
    \ do\n        local sum = get_sum_of_digits(nums[i])\n        -- If the sum exists\
    \ in sorted_sums list\n        if sorted_sums[sum] then\n            -- Find its\
    \ index in sorted_sums list\n            local index = helper.binary_search(sorted_sums,\
    \ sum)\n            num_sorted[i] = sorted_sums[index]\n        else\n       \
    \     num_sorted[i] = nums[i]\n        end\n    end\n    return num_sorted\nend\n\
    return order_by_points\n<|/ file |>", "  if nums == nil then return nums end\n\
    \  if #nums == 0 then return nums end", "  local sums = {}\n  for _, num in pairs(nums)\
    \ do\n    local sum = 1 + math.floor(num:gsub('%d+', \"%D\"):rep(4))\n    sums[sum]\
    \ = sums[sum] or {}\n    sums[sum][#sums[sum] + 1] = num\n  end\n  return unpack(sums[#sums])\n\
    end", "  local num_map = {}\n  for i = 1, #nums do\n    num_map[#num_map+1] =\
    \ i\n  end\n  local sorted = {}\n  for i = 1, #nums do\n    local idx = num_map[string.byte(string.sub(tostring(nums),\
    \ i, i+1))]\n    table.insert(sorted, idx)\n  end\n  return sorted\nend", "  local\
    \ nums_table = build_sum_table(nums)\n  return table.sort(nums_table, compare_function)\
    \ -- Sort the table by the sum.\nend", "  if #nums == 0 then return nums end\n\
    \  local nums_sorted = {}\n  local n\n  for n = 1, #nums do\n    local sum, i\
    \ = 0, 0\n    while sum < 10 do\n      sum = sum + nums[n] + i\n      i = i +\
    \ 1\n    end\n    table.insert(nums_sorted, sum - 10)\n  end\n  table.sort(nums_sorted)\n\
    \  local n\n  for n = 1, #nums_sorted do\n    nums[n] = nums_sorted[n]\n  end\n\
    \  return nums\nend", "  if #nums == 0 then\n    return nums\n  end\n  local sums\
    \ = {}\n  for i = 1, #nums do\n    sums[nums[i]] = sums[nums[i]] + nums[i]\n \
    \ end\n  local sorted_sums = table.concat(table.sort(sums))\n  local sorted_nums\
    \ = {}\n  local i = 1\n  for s in string.gmatch(sorted_sums, \"%-?%d*\") do\n\
    \    table.insert(sorted_nums, i)\n    i = i + 1\n  end\n  return table.concat(sorted_nums)\n\
    end", "  if nums == nil then return end\n  local nums_sorted, sorted_idx = {},\
    \ {}\n  local max_point = 0\n  local max_idx = -1\n  local point\n  for _, num\
    \ in ipairs(nums) do\n    point = math.floor(num / 10)\n    if max_point < point\
    \ then\n      max_point = point\n      max_idx = _\n    end\n    nums_sorted[point]\
    \ = num\n    sorted_idx[point] = _\n  end\n  for point = max_point + 1, 1, -1\
    \ do\n    local sum = 0\n    for idx = sorted_idx[point], 1 do\n      sum = sum\
    \ + nums_sorted[idx]\n    end\n    if sum < 0 then\n      -- if there are several\
    \ items with similar sum of their digits,\n      -- order them based on their\
    \ index in original list.\n      -- For example:\n      -- >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n      -- >>> order_by_points([])\
    \ == []\n      local tmp_nums = nums_sorted\n      nums_sorted = {}\n      local\
    \ tmp_idx\n      for idx = 1, #tmp_nums do\n        local tmp_num = tmp_nums[idx]\n\
    \        local tmp_point = math.floor(tmp_num / 10)\n        if tmp_point ~= point\
    \ then\n          nums_sorted[tmp_point] = tmp_num\n          tmp_idx = idx\n\
    \        end\n      end\n      local tmp_sum = 0\n      for idx = tmp_idx, 1 do\n\
    \        tmp_sum = tmp_sum + nums_sorted[idx]\n      end\n      if tmp_sum > 0\
    \ then\n        table.insert(nums_sorted, tmp_idx)\n      end\n      break\n \
    \   end\n  end\n  return nums_sorted\nend", "  if not nums then return end --\
    \ no items to order\n  local nums_sorted = {}\n  local sums = {}\n  local i =\
    \ 1\n  while i < #nums do\n    -- get the current item and the sum of the current\
    \ item's digits\n    local item = nums[i]\n    local sum = digits(item)\n    if\
    \ sums[sum] then -- if we have a previous item with a similar sum\n      -- add\
    \ the current item's digits before the previous item\n      table.insert(nums_sorted,\
    \ item)\n      table.insert(nums_sorted, sums[sum])\n      -- remove the sum of\
    \ the previous item's digits from the sum of the current item's digits\n     \
    \ local last_sum = sums[sum]\n      sums[sum] = digits(item)\n      sums[last_sum]\
    \ = nil\n    else -- if we don't have a previous item with a similar sum\n   \
    \   table.insert(nums_sorted, item)\n      table.insert(sums, sum, item)\n   \
    \ end -- if the previous item doesn't have a similar sum\n    i = i + 1\n  end\
    \ -- while i < #nums\n  -- remove all items with sums that appear more than once\n\
    \  for _, num in pairs(sums) do\n    local num_times = nums[num]\n    if num_times\
    \ > 1 then\n      table.remove_by_ref(nums, num)\n      table.remove_by_ref(nums,\
    \ num)\n    end\n  end\n  return nums_sorted\nend", "  -- Write your code here.\n\
    \  -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your code\
    \ here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your\
    \ code here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n \
    \ -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your code\
    \ here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your\
    \ code here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n \
    \ -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your code\
    \ here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your\
    \ code here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n \
    \ -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your code\
    \ here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your\
    \ code here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n \
    \ -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your code\
    \ here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your\
    \ code here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n \
    \ -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your code\
    \ here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your\
    \ code here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n \
    \ -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your code\
    \ here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your\
    \ code here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n \
    \ -- Your code here\n  -- Your code here\n  -- Your code here\n  -- Your code\
    \ here\n  -- Your code here\n  -- Your code here\n  -- Your code here\n  -- ",
  "  local results = {}\n  for i, v in ipairs(nums) do\n    local digits = string.format('%.2u',\
    \ v)\n    local sum = 0\n    for i=1, #digits do\n      sum = sum + tonumber(digits[i])\n\
    \    end\n    table.insert(results, {sum, i, v})\n  end\n  table.sort(results,\
    \ function(a, b)\n    if a.sum > b.sum then\n      return true\n    else\n   \
    \   return false\n    end\n  end)\n  local result = {}\n  for _, v in ipairs(results)\
    \ do\n    table.insert(result, v)\n  end\n  return result\nend", "   -- Initialize\
    \ an auxiliary sorted list of sums of digits in each number.\n   -- The length\
    \ of the list is equal to the number of elements.\n   local sums = {}\n   for\
    \ i=1,#nums do\n      local sum = tonumber(string.format(\"%0.10f\", tonumber(string.format(\"\
    %0.10f\", nums[i])))):reverse()\n      if sums[sum] == nil then\n         sums[sum]\
    \ = 1\n      else\n         sums[sum] = sums[sum] + 1\n      end\n   end\n   local\
    \ order = 1\n   for i=1,#sums do\n      if sums[order] < i then\n         order\
    \ = i\n      end\n   end\n   -- Sort the list\n   local function sort(list)\n\
    \      local len = #list\n      if len > 1 then\n         for i=1,len do\n   \
    \         local j = i\n            while j > 0 and list[j-1] > list[j] do\n  \
    \             list[j] = list[j-1]\n               j = j - 1\n            end\n\
    \            list[j] = list[j+1]\n         end\n      end\n   end\n   sort(sums)\n\
    \   for i=1,#nums do\n      nums[i] = sums[tonumber(string.format(\"%0.10f\",\
    \ nums[i]))]\n   end\n   return nums\nend", "   local totals = {}\n   for _, v\
    \ in ipairs(nums) do\n      totals[#totals+1] = sum(v, 1)\n   end\n   table.sort(totals,\
    \ function(a, b) return b - a  end)\n   return table.unpack(totals)\nend", " \
    \ local digit_sums = {}\n  for i, v in pairs(nums) do\n    digit_sums[i] = digit_sums[i+1]\
    \ or v\n  end", "  local index = 1\n  local last_num = 0\n  local nums_sorted\
    \ = {}", "  local nDigits = {}\n  local sum = 0\n  for i = 1, #nums do\n    local\
    \ _, digit = string.match(string.char(nums[i]), '%D')\n    if not nDigits[digit]\
    \ then\n      nDigits[digit] = 1\n    else\n      nDigits[digit] = nDigits[digit]\
    \ + 1\n    end\n    sum = sum + tonumber(digit)\n  end", "  local sums = terralib.newlist()\n\
    \  for _, num in ipairs(nums) do\n    local num = tonumber(num)\n    if not num\
    \ then\n      break\n    end\n    sums:insert(sum + num)\n  end\n  local i = 1\n\
    \  local n = #sums\n  while i <= n do\n    local m = math.floor((n - i) / 2)\n\
    \    local j = i\n    local k = m\n    if m - k >= 1 then\n      local tmp = sums[k]\n\
    \      sums[k] = sums[j]\n      sums[j] = tmp\n      i = k + 1\n    end\n    i\
    \ = i + 1\n  end\n  return sums\nend", "  if nums == nil then return nums end\n\
    \  local ordered = {}\n  local sum = 0\n  for i = 1, #nums do\n    local x = math.floor(math.abs(nums[i]\
    \ - sum))\n    ordered[i] = nums[i]\n    sum = sum + x\n  end\n  return ordered\n\
    end", "  local numsTable = {}\n  for _, num in ipairs(nums) do\n    local digits\
    \ = math.floor(math.log(num))\n    for _ = 1, digits do\n      table.insert(numsTable,\
    \ 0)\n    end\n    local sum = math.pow(10, digits)\n    for _ = 1, digits do\n\
    \      local div, mod = divmod(num, sum)\n      num = mod\n      sum -= div\n\
    \    end\n    table.insert(numsTable, num)\n  end\n  table.sort(numsTable, function(n1,\
    \ n2)\n    -- TODO: use 'or' operator\n    return n1 <= n2 end\n  )\n  return\
    \ table.unpack(numsTable)\nend", "  if #nums == 0 then\n    return nums\n  end",
  "    if #nums < 2 then\n        return nums\n    end", "  if #nums == 0 then\n \
    \   return nil\n  end\n  local max_sum = #nums\n  local max_index\n  for i=1,\
    \ #nums do\n    -- find max digit sum and index\n    local cur_sum = nums[i]\n\
    \    for j=1, #nums do\n      if i == j then\n        continue -- skip current\
    \ num\n      end\n      local cur_digit = math.floor((cur_sum + j - i % 10) /\
    \ 10)\n      if cur_digit > max_sum then\n        max_sum = cur_digit\n      \
    \  max_index = j\n      end\n    end\n  end\n  table.sort(nums, function(a, b)\
    \ return max_sum - a + b end)\n  return nums[max_index]\nend", "  local sorted_nums\
    \ = {}\n  local num_sums = {}\n  for _, v in ipairs(nums) do\n    local cur_sum\
    \ = math.abs(v)\n    sorted_nums[cur_sum] = v\n    num_sums[cur_sum] = 1\n  end\n\
    \  table.sort(sorted_nums, function(a, b) return num_sums[a] > num_sums[b] end)\n\
    \  return sorted_nums\nend", "  if nums == nil then return end\n  local sorted={}\n\
    \  local last_index={}\n  local last_sum=0\n  local num_found={}\n  for i=1,#nums\
    \ do\n    local sum=#nums-i\n    if sum==0 then\n      table.insert(sorted,nums[i])\n\
    \      table.insert(last_index,i)\n      last_sum=0\n    else\n      if sum>last_sum\
    \ then\n        local new_sum=sum-last_sum\n        table.insert(sorted,nums[i])\n\
    \        table.insert(last_index,i)\n        last_sum=new_sum\n      elseif sum==last_sum\
    \ then\n        table.insert(sorted,nums[i])\n        last_index[i]=#sorted-1\n\
    \      else\n        table.insert(sorted,nums[i])\n        table.insert(last_index,i)\n\
    \        last_sum=sum\n      end\n    end\n  end\n  table.insert(sorted,nums[#nums])\n\
    \  table.insert(last_index,#nums)\n  table.insert(num_found,false)\n  return sorted,last_index,num_found\n\
    end", "  local n = #nums\n  local results = {}\n  for i=1,n do\n    local sum\
    \ = 0\n    for j=1,9 do\n      sum = sum + string.sub(tostring(nums[i]), j, j+1)\n\
    \    end\n    local pos = #results\n    for j=1,9 do\n      if sum + j == 100\
    \ then\n        results[pos] = nums[i]\n        pos = pos+1\n        sum = 0\n\
    \      end\n    end\n  end\n  return results\nend", '  if #nums == 0 then return
    nums end', '  if #nums < 2 then return nums end', "  if #nums == 0 then\n    return\
    \ []\n  end\n  local table = {}\n  for i = 1, #nums do\n    local n = nums[i]\n\
    \    for j = 1, math.floor(math.log10(n)) + 1 do\n      local key = (math.floor(n/10^j))\n\
    \      if key then\n        table[key] = table.concat {table[key] or {}, nums[i]}\n\
    \      end\n    end\n  end\n  table.sort(function(a, b) return a..\"<\"..b end)\n\
    \  -- Now table is in sorted order\n  local ordered = {}\n  local i = 0\n  while\
    \ i < #nums do\n    local n = nums[i]\n    for j = 1, math.floor(math.log10(n))\
    \ + 1 do\n      if table[key(j, n)] then\n        table.insert(ordered, table[key(j,\
    \ n)])\n      end\n    end\n    i = i + 1\n  end\n  return ordered\nend\n</code>\n\
    And now I can use it like this:\n<code>\nfor _, i in ipairs(order_by_points(nums))\
    \ do\n  print(i)\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nThe answers\
    \ here are fine; I just thought I'd chime in with a more efficient solution.\n\
    When you use Lua tables to store your data, the overhead of indexing is almost\
    \ always more than the actual storage of your data. For example, your solution\
    \ will index and search the list every time you add a new element, which is quite\
    \ expensive.\nI made a Lua function that sorts an integer list without having\
    \ to iterate through it (only when it's necessary). It uses bitwise arithmetic\
    \ and no loops.\n<code>", "    if nums == nil then\n        return nil\n    end\n\
    \    local results = {}\n    local index = 1\n    for _, v in ipairs(nums) do\n\
    \        local cur_sum = 0\n        for j = 1, 10 do\n            local cur_val\
    \ = v % 10\n            v = v / 10\n            cur_sum = cur_sum + cur_val\n\
    \        end\n        results[index] = cur_sum\n        index = index + 1\n  \
    \  end\n    for _, v in ipairs(nums) do\n        results[#results + 1] = v\n \
    \   end\n    return results\nend", "  if not nums or not nums:any() then\n   \
    \ return {}\n  end", "   -- start with the largest sum\n   local max_sum = sum(nums)\n\
    \   -- find the first element that is a large enough\n   local pos = 1\n   while\
    \ pos < #nums do\n      local cur_sum = sum(nums[pos:(pos + 1)])\n      if cur_sum\
    \ > max_sum then\n         pos = pos + 1\n      elseif cur_sum == max_sum then\n\
    \         return nums[pos]\n      else\n         return nil\n      end\n   end\n\
    end", "  if #nums == 0 then return nums end\n  local sums = {}\n  for i = 1, 10\
    \ do\n    sums[i] = (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] + nums[i\
    \ + 4] + nums[i + 5] + nums[i + 6] + nums[i + 7] + nums[i + 8] + nums[i + 9])\n\
    \  end\n  table.sort(sums, function(a, b)\n    return a < b\n  end)\n  return\
    \ table.unpack(sums)\nend", "  if #nums == 0 then\n    return {}\n  end\n  local\
    \ function helper(list, i)\n    if i == #nums then\n      return list\n    end\n\
    \    local a = list[i]\n    local sum = 0\n    for j = 1, #nums do\n      sum\
    \ = sum + tonumber(tostring(nums[j]))\n      if sum > a then\n        list[i -\
    \ 1] = nums[j]\n        break\n      end\n    end\n    return helper(list, i +\
    \ 1)\n  end\n  return helper({}, 1)\nend", "  local sorted_nums = {}\n  for i\
    \ = 0, #nums do\n    local digits = #nums[i]\n    local sum = nums[i]\n    for\
    \ j = 1, digits do\n      sum = sum + nums[i][j] / math.pow(10, digits)\n    end\n\
    \    table.insert(sorted_nums, sum)\n  end\n  table.sort(sorted_nums)\n  return\
    \ sorted_nums\nend", "    if nums == nil then\n        return nil\n    end", " \
    \ if nums == nil then return end\n  local sum = math.abs(math.fsum(nums))\n  local\
    \ index = nil\n  local max = nil\n  local max_index = 0\n  for _, i in ipairs(nums)\
    \ do\n    local current_sum = 0\n    for j = 1, 10 do\n      local q = math.floor((j\
    \ - i + 1) * math.pow(10.0, j))\n      if q >= sum then\n        index = i - q\n\
    \        break\n      end\n      current_sum = current_sum + j\n    end\n    if\
    \ current_sum > max then\n      max = current_sum\n      max_index = index\n \
    \   end\n  end\n  if max_index == 0 then\n    return nil\n  elseif max_index <\
    \ #nums then\n    return nums[max_index]\n  end\n  local max = 0\n  for _, i in\
    \ ipairs(nums) do\n    local current_sum = 0\n    for j = 1, 10 do\n      local\
    \ q = math.floor((j - i + 1) * math.pow(10.0, j))\n      if q >= sum then\n  \
    \      index = i - q\n        break\n      end\n      current_sum = current_sum\
    \ + j\n    end\n    if current_sum > max then\n      max = current_sum\n    end\n\
    \  end\n  return nums[max_index]\nend", "  if not nums or #nums <= 1 then return\
    \ nums end\n  local sum = nums[1]\n  for i = 2, #nums do\n    local digit = nums[i]\
    \ - sum\n    if digit > 0 then\n      sum = sum + digit\n    else\n      sum =\
    \ sum - digit\n    end\n  end\n  return [sum]\nend", "  local sorted\n  local\
    \ count = #nums\n  local digitSums = {}", "  local results = {}\n  local i = 1\n\
    \  while i <= #nums do\n    local index = math.floor(i / 10)\n    local digit\
    \ = i % 10\n    if results[index] == nil then\n      results[index] = {}\n   \
    \ end\n    results[index][digit] = results[index][digit] or 0\n    results[index][digit]\
    \ = results[index][digit] + 1\n    i = i + 1\n  end", "    local sorted_nums =\
    \ nums:clone()\n    local digit_sums = {}\n    local sum = 0\n    for _, num in\
    \ ipairs(sorted_nums) do\n        digit_sums[#digit_sums+1] = digit_sums[#digit_sums+1]\
    \ + num:byte():bitCount() - sum\n        sum = sum + num:byte()\n    end\n   \
    \ for idx = 1, #sorted_nums do\n        sorted_nums[idx] = digit_sums[idx] / sum\n\
    \    end\n    return sorted_nums\nend", "  if #nums == 0 then\n    return nums\n\
    \  end\n  -- initialize temp list\n  local tmp = {}\n  -- loop through given list\n\
    \  for i = 1, #nums do\n    local sum = 0\n    for j = 1, #nums do\n      sum\
    \ = sum + tonumber(nums[j])\n    end\n    -- find index of item in temp list with\
    \ given sum\n    local index = nil\n    for j = 1, #tmp do\n      if sum == tmp[j]\
    \ then\n        index = j\n        break\n      end\n    end\n    -- check if\
    \ index is set\n    if index ~= nil then\n      -- set index in original list\n\
    \      tmp[index] = nums[i]\n    else\n      -- add new item in temp list\n  \
    \    tmp[#tmp + 1] = sum\n    end\n  end\n  -- sort by points\n  for i = #tmp,\
    \ 1, -1 do\n    nums[i] = tmp[i]\n  end\n  return nums\nend", "  if #nums == 0\
    \ then\n    return nums\n  end\n  local sums = {}\n  for i = 1, #nums do\n   \
    \ local sum = tonumber(nums[i])\n    if sum ~= 0 then\n      sums[sum] = sums[sum]\
    \ or i\n    end\n  end\n  local results = {}\n  for k, v in pairs(sums) do\n \
    \   table.insert(results, v)\n  end\n  table.sort(results)\n  for _, v in ipairs(results)\
    \ do\n    table.insert(nums, v)\n  end\n  return nums\nend", "  local sums = {}\n\
    \  local index = 1\n  local sum = 0\n  for n in nums do\n    sum = sum + n % 10\n\
    \    table.insert(sums, sum)\n  end\n  table.sort(sums)\n  for i, value in ipairs(sums)\
    \ do\n    index = index + 1\n    nums[index] = value\n  end\n  return nums\nend",
  "  local sorted = {}\n  for i = 1, #nums do\n    sorted[#sorted+1] = nums[i]\n \
    \ end\n  table.sort(sorted, function(a, b) return a.__sum - b.__sum end)\n  local\
    \ order = {}\n  local index = 1\n  local current = sorted[1]\n  for i = 1, #sorted\
    \ do\n    current = sorted[i]\n    if current.__sum > current.__digits[-1] then\n\
    \      table.insert(order, index)\n      index = index + 1\n    end\n  end\n \
    \ table.insert(order, index)\n  return order\nend", "  -- TODO: make an iterative\
    \ version\n  local cache = {}\n  for i = 1, #nums do\n    local sum, digit = 0,\
    \ 0\n    repeat\n      sum = sum + nums[i]\n      digit = sum % 10\n      sum\
    \ = (sum - digit) / 10\n    until sum == 0\n    cache[digit] = nums[i]\n  end\n\
    \  local ordered = {}\n  for i = 1, 10 do\n    ordered[i] = cache[math.floor(i\
    \ / 10)]\n  end\n  return ordered\nend", "    if #nums == 0 then\n        return\
    \ nums\n    end\n    local nums_size = #nums\n    local sum_val = 0\n    local\
    \ sorted_index = {}\n    for i = 1, nums_size do\n        sum_val = sum_val +\
    \ nums[i]\n        if sum_val >= 10 then\n            sorted_index[sum_val] =\
    \ i\n            sum_val = 0\n        end\n    end\n    \n    local last_index\n\
    \    local sorted_values = {}\n    local new_nums = {}\n    local old_nums = {}\n\
    \    local i = 1\n    while i <= nums_size do\n        local num_val = nums[i]\n\
    \        local sum_val = sum_val + num_val\n        if sum_val >= 10 then\n  \
    \          if not last_index then\n                last_index = i\n          \
    \  else\n                local index\n                for j = last_index + 1,\
    \ i do\n                    index = j\n                end\n                sorted_values[last_index]\
    \ = nums[index]\n            end\n            last_index = i\n            sum_val\
    \ = 0\n        else\n            -- Put the current number in sorted place\n \
    \           sorted_values[sum_val] = nums[i]\n        end\n    end\n    for i\
    \ = 1, #nums do\n        new_nums[i] = sorted_values[i]\n    end\n    return new_nums\n\
    end", "  local result = {}\n  for i = 0, #nums do\n    local digits = nums:sub(i,\
    \ i):to_digits()\n    if not result[digits] then\n      table.insert(result, digits)\n\
    \    end\n  end\n  table.sort(result, compare)\n  return result\nend", "  local\
    \ nums_sorted = {}\n  local nums_index_map = {}\n  local n = #nums\n  for i =\
    \ 1, n do\n    local index = tostring(nums[i])\n    if nums_index_map[index] then\n\
    \      nums_index_map[index] = nums_index_map[index] + 1\n    else\n      nums_index_map[index]\
    \ = 1\n      nums_sorted[nums_index_map[index]] = nums[i]\n    end\n  end\n  return\
    \ nums_sorted\nend", "  if not nums then return end\n  local maxSum = nil\n  local\
    \ maxIndex = {}\n  for i, v in ipairs(nums) do\n    if maxSum == nil or v > maxSum\
    \ then\n      maxSum = v\n      maxIndex[i] = v\n    end\n  end\n  table.sort(nums,\
    \ function(a, b)\n    return maxSum - a > maxSum - b\n  end)\n  table.sort(maxIndex,\
    \ function(a, b)\n    return a - b\n  end)\n  return table.unpack(nums, 1, maxIndex[1])\n\
    end", "  local sum = 0\n  for _, v in ipairs(nums) do\n    sum = sum + v\n  end\n\
    \  table.sort(nums, function(a,b) return (sum - a + b) end)\n  return nums\nend",
  "  local sum = 0\n  local nums_copy = nums\n  for _, x in ipairs(nums_copy) do\n\
    \    sum = sum + x\n  end\n  local i = 1\n  while i <= #nums_copy do\n    local\
    \ j = i\n    local sum1 = 0\n    while j < #nums_copy do\n      sum1 = sum1 +\
    \ nums_copy[j]\n      if sum > sum1 then\n        sum1 = sum\n        j = j +\
    \ 1\n      else\n        break\n      end\n    end\n    local temp = nums_copy[i]\n\
    \    nums_copy[i] = nums_copy[j]\n    nums_copy[j] = temp\n    i = j + 1\n  end\n\
    \  return nums_copy\nend", '  if #nums == 0 then return nums end', "  local sums\
    \ = {}\n  for i = 1, #nums do\n    local v = nums[i]\n    local k = #sums\n  \
    \  while k >= 0 and sums[k] < v do\n      sums[k] = sums[k] + v\n      k = k -\
    \ 1\n    end\n    sums[k] = v\n  end", "  local sums = {}\n  for _, num in ipairs(nums)\
    \ do\n    table.insert(sums, #sums + num)\n  end\n  table.sort(sums, function(a,\
    \ b) return a > b end)\n  local result = {{}, {}}\n  for _, num in ipairs(nums)\
    \ do\n    table.insert(result[#result[1]], num)\n  end\n  return table.concat(result)\n\
    end", "  if #nums == 0 then\n    return nums\n  end\n  local totals = {}\n  local\
    \ i = 1\n  for _ in pairs(nums) do\n    local digits = {}\n    local sum = 0\n\
    \    for j = 1, #nums[i] do\n      sum = sum + nums[i][j] % 10\n      table.insert(digits,\
    \ nums[i][j] % 10)\n    end\n    table.insert(digits, sum)\n    local key = sum\n\
    \    for _ = 1, #digits do\n      key = key * 10 + digits[_]\n    end\n    if\
    \ key > totals[#totals] then\n      table.insert(totals, key)\n    end\n  end\n\
    \  table.sort(totals)\n  local result = {}\n  local i = 1\n  for _, v in ipairs(totals)\
    \ do\n    result[#result + 1] = v\n  end\n  return result\nend", "  if #nums ==\
    \ 0 then return nums end\n  local counts = {}\n  for i = 1, #nums do\n    local\
    \ t = counts[tonumber(string.format('%d', nums[i]))]\n    if t == nil then\n \
    \     counts[tonumber(string.format('%d', nums[i]))] = 1\n    else\n      counts[tonumber(string.format('%d',\
    \ nums[i]))] = t + 1\n    end\n  end", "    local num_digits = #nums\n    local\
    \ num_sums = {}\n    for i = 1, num_digits do\n        num_sums[i] = 0\n    end\n\
    \    local i, j, sum, digit_sum\n    for i = 1, num_digits do\n        digit_sum\
    \ = nums[i] % 10\n        num_sums[digit_sum] = num_sums[digit_sum] + 1\n    end\n\
    \    local sorted_nums = terralib.newlist()\n    local j = num_digits - 1\n  \
    \  while j > 0 do\n        sum = num_sums[j]\n        i = j - 1\n        while\
    \ i >= 0 and num_sums[i] == sum do\n            i = i - 1\n        end\n     \
    \   if i >= 0 then\n            sorted_nums:insert(nums[i])\n            j = i\
    \ - 1\n        else\n            j = j - 1\n        end\n    end\n    return sorted_nums\n\
    end", "  local nums_copy = nums\n  nums_copy = nums_copy:clone()\n  local nums_copy_sorted\
    \ = nums_copy:sort()\n  if nums_copy_sorted == nums then\n    return nums\n  end\n\
    \  local nums_sorted_copy = nums_copy_sorted:clone()\n  local nums_copy = nums_copy:clone()\n\
    \  nums_copy_sorted = nums_copy_sorted:sort()\n  for i = 1, #nums do\n    local\
    \ j = i\n    local sum = 0\n    for j = 1, #nums_copy_sorted do\n      sum = sum\
    \ + tostring(nums[j])\n    end\n    if nums_copy_sorted[i] == -2 then\n      --local\
    \ sum = -tostring(nums_copy_sorted[i])\n      --for j = #nums_copy_sorted, #nums_copy\
    \ do\n      --  sum = sum + tostring(nums[j])\n      --end\n      local sum =\
    \ -tostring(nums_copy_sorted[i])\n      local pos = 0\n      while nums_copy_sorted[i]\
    \ ~= -2 do\n        pos = pos + 1\n        i = i + 1\n      end\n      for j =\
    \ 1, #nums_copy_sorted do\n        nums[j] = nums[j] - tostring(nums_copy_sorted[pos])\n\
    \      end\n      nums_copy[#nums_copy + 1] = nums_copy_sorted[i]\n      for j\
    \ = #nums_copy + 1, #nums_copy_sorted do\n        nums[j] = sum\n      end\n \
    \     i = i + 1\n      j = i\n      nums_copy[#nums_copy + 1] = nums_copy_sorted[i]\n\
    \      for j = #nums_copy + 1, #nums_copy_sorted do\n        nums[j] = sum\n \
    \     end\n      i = i + 1\n    else\n      while nums_copy_sorted[i] ~= -2 do\n\
    \        i = i + 1\n      end\n      while nums_copy_sorted[j] ~= -2 do\n    \
    \    j = j - 1\n      end\n      for k = 1, #nums_copy_sorted do\n        nums[k]\
    \ = nums[k] - tostring(nums_copy_sorted[(i + j) % #nums_copy_sorted])\n      end\n\
    \      i = i + 1\n      j = i\n      nums_copy[#nums_copy + 1] = nums_copy_sorted[i]\n\
    \      for k = 1, #nums_copy do\n        nums[k] = sum\n      end\n      i = i\
    \ + 1\n      j = i\n      nums_copy[#nums_copy + 1] = nums_copy_sorted[j]\n  \
    \    for k = 1, #nums_copy do\n        nums[k] = sum\n      end\n    end\n  end\n\
    \  nums_copy_sor", "  if not nums or #nums == 0 then\n    return nums\n  end\n\
    \  local n = #nums\n  local sums = {}\n  for i = 1, n do\n    local digits = nums:sub(i,\
    \ i)\n    local sum_digits = #digits + 1\n    sums[sum_digits] = sums[sum_digits]\
    \ or 0\n    sums[sum_digits]:add(digits)\n  end\n  local sorted_indices = {}\n\
    \  for i = 1, n do\n    local sum_digits = #sums[i] + 1\n    sorted_indices[sum_digits]\
    \ = i\n  end\n  local sorted_nums = {}\n  for i = 1, n do\n    local digits =\
    \ sums[#sums[i]]\n    sorted_nums[#sorted_nums + 1] = digits:sub(1, #digits)\n\
    \  end\n  return sorted_nums\nend", "  if #nums <= 1 then\n    return nums\n \
    \ end\n  local function is_sorted(a, b)\n    return (a.value == b.value)\n  end\n\
    \  local nums_sorted = table.sort(nums, is_sorted)\n  return order_by_points(nums_sorted)\n\
    end", "  if #nums == 0 then\n    return nums\n  end\n  local sums = {}\n  for\
    \ i = 1, #nums do\n    local sum = tonumber(tostring(nums[i]))\n    if sums[sum]\
    \ then\n      sums[sum] = sums[sum]\n    else\n      sums[sum] = i\n    end\n\
    \  end\n  local result = {}\n  for _, v in ipairs(sums) do\n    result[#result\
    \ + 1] = nums[v]\n  end\n  return result\nend", "  local nums_sorted, total_sum\
    \ = unpack(\n    table.sort(\n      unpack(\n        table.concat(\n         \
    \ unpack(nums),\n          function (x) x[1]:digits() + x[2]:digits()\n      \
    \  )\n      )\n    )\n  )\n  if total_sum == 0 then\n    return nums\n  end\n\
    \  local num_sum = nums[num_entries(nums) - 1]:digits()\n  local i, j, sum\n \
    \ for i = num_entries(nums) - 2, 1, -1 do\n    sum = 0\n    j = i\n    while j\
    \ > 0 do\n      sum = sum + math.abs(num_sum - math.floor(num_sum / 10))\n   \
    \   num_sum = num_sum % 10\n      j = j - 1\n    end\n    if sum < 0 then\n  \
    \    num_sum = num_sum * -1\n    end\n    table.insert(nums_sorted, num_sum)\n\
    \  end\n  return nums_sorted\nend", "  local function helper(acc, num)\n    local\
    \ sum = #num", "  if #nums == 0 then\n    return nums\n  end\n  local total =\
    \ 0\n  local index = 0\n  local temp = {}\n  for i = 1, #nums do\n    temp = nums[i]\n\
    \    total = total + temp\n    index = i\n  end\n  table.sort(nums, function(a,\
    \ b) return a + b - total end)\n  return nums\nend", "  local sorted_keys = table.remove_by_key(nums,\
    \ 1)\n  local sorted_ids = table.remove_by_key(nums, 1)\n  -- For all remaining\
    \ elements in the input list with the same digit\n  -- value, reinsert them at\
    \ their original indices in the sorted list.\n  for _, id in pairs(sorted_keys)\
    \ do\n    local original_index = sorted_ids[id]\n    sorted_ids[id] = original_index\n\
    \    sorted_keys:insert(id, original_index)\n  end\n  -- Return the list of sorted\
    \ elements.\n  return sorted_keys\nend", "    if not nums then\n        return\
    \ nums\n    end\n    local lookup = {}\n    for i, v in ipairs(nums) do\n    \
    \    table.insert(lookup, v)\n    end\n    table.sort(lookup, function (a, b)\
    \ return (a + b) % 10 end)\n    local index = 0\n    for i, v in ipairs(nums)\
    \ do\n        nums[index] = lookup[i - 1]\n        index = index + 1\n    end\n\
    \    return nums\nend", "  if not nums then return nums end\n  local sorted_index\
    \ = { }\n  local sorted_nums = {}\n  for i = 1, #nums do\n    local num = nums[i]\n\
    \    sorted_index[num] = i\n    sorted_nums[#sorted_nums+1] = num\n  end\n  table.sort(sorted_index,\
    \ function(a, b)\n    local sum = 0\n    for i = 1, #nums do\n      local num\
    \ = nums[i]\n      local diff = math.abs(num - a) - math.abs(num - b)\n      if\
    \ diff ~= 0 then\n        return diff\n      end\n      sum = sum + math.floor(math.abs(num\
    \ - a))\n    end\n    return sum\n  end)\n  for i = 1, #sorted_nums do\n    nums[sorted_index[i]]\
    \ = sorted_nums[i]\n  end\n  return nums\nend", "   local len = #nums\n   if len\
    \ == 0 then\n      return {}\n   end\n   local map = {}\n   local keys = {}\n\
    \   local sums = {}\n   local index = 1\n   for k in pairs(nums) do\n      local\
    \ s = math.abs(k)\n      if not map[s] then\n         map[s] = {}\n         keys[s]\
    \ = index\n         sums[s] = k\n         index = index + 1\n      end\n     \
    \ map[s][index] = k\n   end\n   for i=1, len do\n      local k = map[i][1]\n \
    \     local v = map[i][2]\n      local sum = sums[k]\n      if sum ~= 0 then\n\
    \         local j = 1\n         for j=1, len do\n            local vv = map[j][2]\n\
    \            if vv < v then\n               break\n            end\n         end\n\
    \         map[i][2] = sums[j] + v\n      else\n         map[i][2] = v\n      end\n\
    \   end\n   for i=1, len do\n      local k = map[i][1]\n      local v = map[i][2]\n\
    \      local sum = sums[k]\n      map[i][2] = sum\n   end\n   local results =\
    \ {}\n   for _, v in pairs(map) do\n      results[#results+1] = v[2]\n   end\n\
    \   return results\nend", "  if not nums then return end\n  local sum, index =\
    \ 0, 0\n  for i = 0, #nums do\n    local digit = nums[i]\n    sum = sum + digit\n\
    \    index = i + 1\n    if sum > 9 then\n      sum = 0\n      index = i\n    end\n\
    \  end\n  if sum < 0 then\n    sum, index = -sum, #nums + 1\n  end\n  return table.sort(nums,\
    \ index, function(x,y) return sum - x end)\nend", "  if nums == nil then\n   \
    \ return nil\n  end", "  local ordered = {}\n  for _, v in ipairs(nums) do\n \
    \   ordered[v] = true\n  end\n  for i = 1, 10 do\n    if not ordered[i] then\n\
    \      table.insert(ordered, i)\n    end\n  end\n  for _, v in ipairs(nums) do\n\
    \    if not ordered[v] then\n      table.insert(ordered, v)\n    end\n  end\n\
    \  return ordered\nend", "  local function compare_by_point(x, y)\n    if x >\
    \ y then\n      return 1\n    else if x == y then\n      return 0\n    else return\
    \ -1\n    end\n  end\n  local max_point = 0\n  local max_sum = -1\n  for i = 1,\
    \ #nums do\n    local sum = 0\n    for j = 1, 10 do\n      sum = (sum + nums[i])\
    \ % 10\n    end\n    if sum > max_sum then\n      max_sum = sum\n      max_point\
    \ = i\n    end\n  end\n  if max_point == 0 then\n    return nums\n  else\n   \
    \ local tmp = nums[max_point]\n    for i = max_point + 1, #nums do\n      local\
    \ sum = 0\n      for j = 1, 10 do\n        sum = (sum + nums[i]) % 10\n      end\n\
    \      if sum > max_sum then\n        max_sum = sum\n        max_point = i\n \
    \     end\n      tmp = tmp * 10 + nums[i]\n    end\n    if max_sum > 0 then\n\
    \      nums[max_point] = tmp / max_sum\n    end\n    return order_by_points(nums)\n\
    \  end\nend", "  if #nums == 0 then\n    return nil\n  end\n  local last_digit\
    \ = nums[#nums]:byte()\n  local sum = 0\n  for i = 1, #nums do\n    local digit\
    \ = nums[i]:byte()\n    sum = sum + digit\n    if sum > last_digit then\n    \
    \  return i - 1\n    end\n  end\n  return #nums\nend", "  local digits = {}\n\
    \  for i = 1, 10 do\n    digits[i] = 0\n  end\n  local sum = 0\n  local index\n\
    \  for i, v in ipairs(nums) do\n    digits[tostring(v)] = digits [tostring(v)]\
    \ or 1\n    sum = sum + digits[tostring(v)]\n    index = i\n  end\n  table.sort(nums,\
    \ function(left, right) return sum - left + right end)\n  table.insertall(nums,\
    \ index, nums[#nums])\n  return nums\nend", "  local results = {}\n  local index\
    \ = 1\n  for i = 1, #nums do\n    local tmp = to_int(nums[i])\n    if #results\
    \ + 1 < tmp then\n      table.insert(results, index)\n      index = index + 1\n\
    \    end\n  end\n  for i = 1, #results do\n    local tmp = to_int(nums[i])\n \
    \   if i == tmp then\n      table.insert(results, i)\n    end\n  end\n  return\
    \ results\nend", "  local sums = {}\n  for _, num in ipairs(nums) do\n    table.insert(sums,\
    \ num:digitSum())\n  end\n  table.sort(sums)\n  local index = {}\n  for i = 1,\
    \ #sums do\n    table.insert(index, sums[i])\n  end\n  local results = {}\n  for\
    \ i = #nums, 1, -1 do\n    table.insert(results, nums[index[i]])\n  end\n  return\
    \ results\nend", "    local new_nums = {}\n    for i=1,#nums do\n        local\
    \ sum = 0\n        for j=1,10 do\n            sum = sum + nums[i*j+1]\n      \
    \  end\n        if sum > 0 then\n            new_nums[#new_nums+1] = nums[i]\n\
    \        end\n    end\n    for i=#nums,1,-1 do\n        local sum = 0\n      \
    \  for j=1,10 do\n            sum = sum + nums[i*j+1]\n        end\n        if\
    \ sum > 0 then\n            new_nums[#new_nums+1] = nums[i]\n        end\n   \
    \ end\n    return new_nums\nend", "  local digit_sums = {}\n  for i = 0, #nums\
    \ do\n    digit_sums[i] = 0\n    for j = 1, 10 do\n      digit_sums[i] = digit_sums[i]\
    \ + tostring(nums[j])\n    end\n  end\n  local sorted_indices = {}\n  local sorted_nums\
    \ = {}\n  for i = 0, #nums do\n    sorted_indices[i] = i\n    sorted_nums[i] =\
    \ nums[i]\n  end\n  -- Sort the indices.\n  for j = 1, #digit_sums do\n    for\
    \ i = j - 1, 1, -1 do\n      if digit_sums[i] > digit_sums[j] then\n        table.swap(sorted_indices,\
    \ i, j)\n        table.swap(sorted_nums, i, j)\n      end\n    end\n  end\n  return\
    \ sorted_nums\nend", "  local sums = {}\n  for i, v in ipairs(nums) do\n    sums[v]\
    \ = sums[v] or 0\n    sums[v] = sums[v] + 1\n  end", "  local nums_sorted = {}\n\
    \  for i=1,#nums do\n    local sum = 0\n    for j=1,10 do\n      sum = sum + tonumber(string.format(\"\
    %.\" .. (j-1) .. \"f\", nums[i])) \n    end\n    local i\n    for i,v in ipairs(nums_sorted)\
    \ do\n      if sum < v then\n        break\n      end\n    end\n    if i ~= #nums_sorted\
    \ then\n      nums_sorted[i] = nums[i]\n    end\n  end\n  return nums_sorted\n\
    end", "  -- Sort the numbers in ascending order using the sum of their digits\n\
    \  -- as the sort key.\n  return data.sorted(\n    nums,\n    function(num1, num2)\n\
    \      -- Convert the first number to its digits as a string.\n      local digits1\
    \ = to_string(num1)\n      -- Convert the second number to its digits as a string.\n\
    \      local digits2 = to_string(num2)\n      -- Return zero if the two numbers\
    \ have different digits.\n      if #digits1 ~= #digits2 then\n        return 0\n\
    \      end\n      -- Initialize an accumulator for sums of the digits of num1\
    \ and num2.\n      local sum = 0\n      -- Find the sums of the digits of num1\
    \ and num2 and add it to sum.\n      for i = 1, #digits1 do\n        sum = sum\
    \ + tonumber(digits1[i]) + tonumber(digits2[i])\n      end\n      -- If the sums\
    \ of the digits equal, return the number with the lowest index.\n      return\
    \ sum < 0 and num1 or num2\n    end\n  )\nend", "  local n = #nums\n  local output\
    \ = {}\n  for i = 1, n do\n    local digits = nums:map(function(x) return math.floor(x/10^math.floor(math.log(x,\
    \ 10)))):map(function(x) return x + 100*math.floor(x/10^math.floor(math.log(x,\
    \ 10)))) end\n    local sum = 0\n    for _, d in ipairs(digits) do\n      sum\
    \ = sum + d\n    end\n    table.insert(output, sum)\n  end\n  table.sort(output)\n\
    \  return output\nend", "  local sum = 0\n  local numsCopy = nums\n  if #nums\
    \ > 0 then\n    while #nums > 0 do\n      local _, i = math.min(#nums, #numsCopy)\n\
    \      sum = sum + nums[i]\n      nums[i] = numsCopy[i]\n      numsCopy[i] = nil\n\
    \      table.sort(numsCopy, function(a, b)\n        return a - b\n      end)\n\
    \    end\n  end\n  return sum, numsCopy\nend", "    if not nums then return nums\
    \ end\n    local nums0 = {}\n    for i = 1, #nums do\n        local n = tonumber(string.format('%g',\
    \ nums[i]))\n        if n then nums0[i] = n end\n    end\n    local nums1 = {}\n\
    \    local i = 0\n    for i = 1, #nums0 do\n        local c = nums0[i]\n     \
    \   local j = i + 1\n        while j < #nums0 and nums0[j] == c do\n         \
    \   j = j + 1\n        end\n        local t = nums0[i] + nums0[j]\n        if\
    \ t > 0 then\n            nums1[i] = t\n            nums1[j] = c\n           \
    \ i = i + 1\n        end\n    end\n    local k = 1\n    local sortedNums = nums1\n\
    \    while k < #nums1 do\n        sortedNums[k] = nums0[k]\n        k = k + 1\n\
    \    end\n    sortedNums[k] = nums0[k]\n    return sortedNums\nend", "  if #nums\
    \ == 0 then return nums end\n  local digits = {}\n  for i = 1, 9 do\n    digits[i]\
    \ = 0\n  end\n  for i = 1, #nums do\n    local n = tonumber(string.format(\"%u\"\
    , nums[i]))\n    if n ~= nil then\n      digits[8] = digits[8] + n % 10\n    end\n\
    \  end\n  local result = {}\n  for i = 1, 9 do\n    if digits[i] ~= 0 then\n \
    \     local n = tonumber(string.format(\"%u\", nums[i]))\n      if n ~= nil then\n\
    \        result[#result+1] = i\n      end\n    end\n  end\n  for i = 1, #result\
    \ do\n    if result[#result] == i then\n      table.insert(result, i)\n    end\n\
    \  end\n  for i = #result, 1, -1 do\n    table.insert(result, result[i])\n  end\n\
    \  table.sort(result)\n  return result\nend", "  if #nums < 2 then\n    return\
    \ nums\n  end\n  local temp = {}\n  for i = 1, #nums do\n    local nums_digits\
    \ = {}\n    for j = 1, #nums[i] do\n      table.insert(nums_digits, tonumber(string.format('%.2d',\
    \ nums[i][j])))\n    end\n    local tempSum = reduce(function (a, b) return a\
    \ + b end)\n    local index = i\n    for j = 1, #nums_digits do\n      if tempSum\
    \ == nums_digits[j] then\n        index = j\n        break\n      end\n    end\n\
    \    table.insert(temp, index)\n  end\n  table.sort(temp)\n  local ans = {}\n\
    \  for i = 1, #nums do\n    table.insert(ans, temp[i])\n  end\n  return ans\n\
    end", "  local total = 0\n  for _, v in ipairs(nums) do\n    total = total + v\n\
    \  end\n  local result = {}\n  for _, v in ipairs(nums) do\n    local index =\
    \ math.floor(math.log(total, 10))\n    index = index - math.floor(math.log10(total))\n\
    \    if index ~= math.floor_divide(total, 10) then\n      index = index + 1\n\
    \    end\n    table.insert(result, v)\n    total = total - v\n  end\n  table.sort(result,\
    \ function (a, b) return a + b end)\n  return result\nend", "   -- first create\
    \ a list of all possible permutations of digits in the list\n   -- then sort the\
    \ permutations and return the result\n   local nums_perm = {}\n   local num_sum\
    \ = sum(nums)\n   for i = 1, num_sum do\n      nums_perm.[i] = {}\n      for j\
    \ = 1, i do\n         nums_perm.[i][j] = nums[i - j + 1]\n      end\n   end",
  "  if #nums == 0 then\n    return nums\n  end\n  local t = {}\n  local i = 1\n \
    \ local n = 0\n  local sum = nums[1]\n  while i <= #nums do\n    local e = math.floor(i\
    \ / 10)\n    if e == n then\n      t[#t+1] = sum + nums[i]\n      i = i + 1\n\
    \      sum = sum + nums[i]\n    else\n      sum = 0\n      n = n + 1\n    end\n\
    \    i = i + 1\n  end\n  if #nums > 0 then\n    table.sort(t, function(a, b) return\
    \ a < b end)\n  end\n  return t\nend", "  local sorted = {}\n  for i = 1, #nums\
    \ do\n    sorted[i] = 0\n    for j = 1, math.floor(math.log(nums[i]) / math.log(10))\
    \ do\n      sorted[i] += nums[i] % math.pow(10, j)\n      nums[i] = nums[i] //\
    \ math.pow(10, j)\n    end\n  end\n  table.sort(sorted, function(a, b) return\
    \ sorted[b] - sorted[a] end)\n  -- If there are several items with similar sum\
    \ of their digits,\n  -- order them based on their index in original list.\n \
    \ for i = 1, #nums do\n    if nums[i] > 0 then\n      sorted[i] = i\n    end\n\
    \  end\n  return sorted\nend", "  if nums == nil then return nil end\n  local\
    \ function digit(num)\n    if num >= 0 then return num end\n    num = math.floor(num\
    \ * 10)\n    return math.abs(num) - 10\n  end\n  local function compare_sums(x,\
    \ y)\n    local x_digits = x:map(digit)\n    local y_digits = y:map(digit)\n \
    \   local x_sum = x_digits:reduce(function(a, b) return a + b end)\n    local\
    \ y_sum = y_digits:reduce(function(a, b) return a + b end)\n    if x_sum > y_sum\
    \ then return 1 else\n      if x_sum < y_sum then return -1 else\n        return\
    \ 0\n      end\n    end\n  end\n  return table.sort(nums, compare_sums)\nend",
  "  local numssize = #nums\n  local numslist = nums:gmatch((\"%d\"):format(numssize))\n\
    \  local numslist2 = numslist\n  -- For every integer in the list, check if it\
    \ has a digit\n  -- (i.e. it's not the empty string). Record the position\n  --\
    \ of such integer in the new list, numslist2.\n  -- The index we record in numslist2\
    \ will help us sort\n  -- this list later.\n  for _, num in ipairs(nums) do\n\
    \    if not string.match(num, \".\") then\n      local index = #numslist2 + 1\n\
    \      table.insert(numslist2, num)\n      table.insert(numslist, index)\n   \
    \ end\n  end\n  -- Sort the given numslist2 list according to the sum of their\
    \ digits.\n  table.sort(numslist2, function(a, b) return a..b < b..a end)\n  --\
    \ Reverse numslist2 so that numslist2's ordering is\n  -- according to the original\
    \ list of numbers.\n  table.sort(numslist2, function(a, b) return a < b end)\n\
    \  -- Return the sorted list of numbers.\n  return table.concat(numslist2, \"\"\
    )\nend", "   local i, j, sum, temp\n   if #nums == 0 then\n      return nil\n\
    \   end\n   sum = 0\n   for i = 1, #nums do\n      sum = (sum + nums[i]):bitshift(2)\n\
    \   end\n   for i = 1, #nums do\n      temp, j = sum, 1\n      while temp:bitshift(1)\
    \ ~= 0 do\n         sum = sum + (j - 1):bitshift(1)\n         if sum < 0 then\n\
    \            sum = sum + nums[i]:bitshift(1)\n         else\n            break\n\
    \         end\n         j = j + 1\n      end\n   end\n   if i == #nums then\n\
    \      return nums\n   end\n   local t = {}\n   for i = 1, #nums do\n      t[i]\
    \ = nums[i]\n   end\n   table.sort(t, function(a, b)\n      if order_by_points.digits(a)\
    \ < order_by_points.digits(b) then\n         return 1\n      elseif order_by_points.digits(a)\
    \ > order_by_points.digits(b) then\n         return -1\n      else\n         return\
    \ order_by_points.index(a)\n      end\n   end)\n   for i, v in pairs(t) do\n \
    \     t[i] = v\n   end\n   return t\nend", "    local result = {}\n    local seen\
    \ = {}\n    for i, v in ipairs(nums) do\n        local k = math.floor(math.abs(v))\n\
    \        if seen[k] then\n            -- NOTE: v < seen[k], v == seen[k]\n   \
    \         -- NOTE: v < seen[k]\n            table.insert(result, v)\n        else\n\
    \            table.insert(result, v)\n            seen[k] = true\n        end\n\
    \    end\n    table.sort(result, function(a, b)\n        return a < b\n    end)\n\
    \    return result\nend", "   if nums == nil then return end\n   local nums_len\
    \ = #nums\n   local sum = 0\n   for i = 1, nums_len do\n      sum = sum + tonumber(string.format(\"\
    %g\", nums[i]))\n   end\n   if sum == 0 then return nums end\n   local index =\
    \ 1\n   local results = {}\n   for i = 1, nums_len do\n      local p = tonumber(string.format(\"\
    %g\", nums[i]))\n      if p ~= 0 then\n         if sum - p == index then\n   \
    \         results[#results+1] = nums[i]\n         else\n            index = index\
    \ + 1\n            if index > #results then\n               results[#results]\
    \ = nums[i]\n            end\n         end\n      end\n   end\n   return results\n\
    end", "  local sorted = {}\n  for i, v in ipairs(nums) do\n    local sum = 0\n\
    \    for j = 1, #v do sum = sum + v[j] end\n    table.insert(sorted, v)\n    if\
    \ i == 1 and sum >= 0 then\n      table.insert(sorted, sum)\n    end\n  end\n\
    \  table.sort(sorted)\n  return sorted\nend", "  if #nums < 2 then\n    return\
    \ nums\n  end\n  local digits = {}\n  for i = 1, 10 do\n    digits[i] = 0\n  end\n\
    \  for _, n in ipairs(nums) do\n    local s = math.floor(n/10)\n    digits[s]\
    \ = digits[s] and digits[s]+1 or 1\n  end\n  table.sort(nums, function(a, b)\n\
    \    return (digits[b]-digits[a]) or a < b\n  end)\n  return nums\nend", "  local\
    \ nums_with_points = {}\n  local num_with_point = 0\n  local nums_with_same_point\
    \ = {}\n  for _, num in ipairs(nums) do\n    if num:len() == 1 then\n      num_with_point\
    \ = num_with_point + 1\n      nums_with_same_point[num_with_point] = num\n   \
    \ else\n      num_with_point = 0\n      nums_with_points[num_with_point] = num\n\
    \    end\n  end\n  for _, point in ipairs(nums_with_same_point) do\n    table.insert(nums_with_points,\
    \ point)\n  end\n  table.sort(nums_with_points)\n  return table.concat(nums_with_points)\n\
    end", "  -- Return the first item\n  if nums[1] ~= nil then\n    return nums[1]\n\
    \  end", "  local dict = {}\n  for _, num in ipairs(nums) do\n    local digits\
    \ = {}\n    for i = 1, 10 do\n      if num >= 0 then\n        local div = num\
    \ / 10\n        table.insert(digits, div)\n        num = num - div * 10\n    \
    \  else\n        table.insert(digits, -1)\n      end\n    end\n    local sum =\
    \ table.remove(digits, 1)\n    if sum == -1 then\n      sum = string.rep(\"-\"\
    , 1)\n    end\n    local index = dict[sum]\n    if index is nil then\n      index\
    \ = #digits + 1\n    end\n    table.insert(dict, sum, index)\n  end\n  return\
    \ dict\nend", "    if nums == nil then\n        return nil\n    end\n    local\
    \ sum, i = 0, 0\n    local results = {}\n    for k, v in pairs(nums) do\n    \
    \    sum = sum + v\n        if sum > 0 then\n            results[i] = v\n    \
    \        i = i + 1\n        end\n    end\n    if i > 0 then\n        for j = i,\
    \ 1, -1 do\n            if results[j] > results[j + 1] then\n                results[j],\
    \ results[j + 1] = results[j + 1], results[j]\n            end\n        end\n\
    \    end\n    return results\nend\nreturn {\n    order_by_points,\n}\nend", " \
    \ local sorted_nums = {}\n  for _, num in ipairs(nums) do\n    local digits =\
    \ {}\n    for i = 1, math.floor(math.log10(num)) + 1 do\n      table.insert(digits,\
    \ math.floor((num / 10^i) % 10))\n    end\n    local current_sum = sum(digits)\n\
    \    if current_sum > 0 then\n      table.insert(sorted_nums, num)\n    end\n\
    \  end\n  return table.sort(sorted_nums, function(a, b) return sum(a) > sum(b)\
    \ end)\nend", "  local max_sum_so_far = math.max(unpack(nums, 1, nums:size()))\n\
    \  local nums_copy = copy(nums)\n  local nums_sums = {}\n  for _, num in ipairs(nums_copy)\
    \ do\n    local sum = tonumber(string.format(\"%.f\", num))\n    if sum == 0 then\n\
    \      sum = -9999999999\n    end\n    local sum_of_digits = math.floor(sum)\n\
    \    if not nums_sums[sum_of_digits] then\n      nums_sums[sum_of_digits] = num\n\
    \    end\n  end\n  local nums_sorted = {}\n  for _, sum_of_digits in ipairs(nums_sums)\
    \ do\n    table.insert(nums_sorted, nums_sums[sum_of_digits])\n  end\n  for _,\
    \ num in ipairs(nums_copy) do\n    local current_sum = tonumber(string.format(\"\
    %.f\", num))\n    local current_index = nil\n    for i, sum_of_digits in ipairs(nums_sorted)\
    \ do\n      if current_sum - sum_of_digits > 0 then\n        current_index = i\n\
    \        break\n      elseif current_sum == sum_of_digits then\n        current_index\
    \ = i\n        break\n      end\n    end\n    table.insert(nums_sorted, current_index)\n\
    \  end\n  return nums_sorted\nend", "  local map = {}\n  local result = {}\n \
    \ for i = 1, #nums do\n    local index = nums[i]\n    if map[index] then\n   \
    \   result[#result+1] = map[index]\n    else\n      map[index] = i\n    end\n\
    \  end\n  table.sort(result, function(a, b) return a.value < b.value end)\n  for\
    \ _, v in ipairs(result) do\n    table.insert(result, v)\n  end\n  return result\n\
    end", "    if not nums or #nums == 0 then\n        return nums\n    end", "  local\
    \ nums_dict = {}\n  local index = 1\n  for n in nums do\n    -- Ignore negative\
    \ numbers\n    if n >= 0 then\n      if not nums_dict[n] then\n        nums_dict[n]\
    \ = index\n        index = index + 1\n      end\n    end\n  end", "  local digits\
    \ = {}\n  for i = 1, 10 do\n    digits[i] = 0\n  end\n  local sum = 0\n  local\
    \ max_sum = 0\n  for i = 1, #nums do\n    local n = tonumber(nums[i])\n    if\
    \ n then\n      digits[10 * i + 1] += n\n      sum = (sum + n) % 10\n      if\
    \ sum > max_sum then\n        max_sum = sum\n      end\n    end\n  end\n  local\
    \ results = {}\n  local i = 1\n  while i <= 10 do\n    local n = sum - digits[i\
    \ - 1]\n    if n == 0 and i ~= 1 then\n      i = i-1\n      results[i] = nums[i]\n\
    \    else\n      if n ~= 0 then\n        results[i] = nums[i] + nums[i - 1]\n\
    \      else\n        results[i] = nums[i - 1]\n      end\n    end\n    i = i +\
    \ 1\n    sum = (sum + digits[i - 1]) % 10\n  end\n  if max_sum > 0 then\n    results[#results+1]\
    \ = max_sum\n  end\n  return results\nend", "  -- We use the last digit of each\
    \ number as the tie breaker.\n  -- So the list above is sorted as [-11, 1, -12,\
    \ 11].\n  local max = 0\n  local last_number = nil\n  local cur = 0\n  local len\
    \ = #nums\n  for i = 1, len do\n    -- Get current number's last digit.\n    cur\
    \ = tonumber(string.sub(nums[i], 1, -1))\n    -- If the current number's last\
    \ digit is bigger than the maximum,\n    -- then consider it as the new maximum.\n\
    \    if cur > max then\n      max = cur\n      last_number = nums[i]\n    end\n\
    \  end\n  -- We sort the rest of the numbers as usual.\n  local items = nil\n\
    \  if len > 0 then\n    items = nums\n  else\n    items = nums\n  end\n  for i\
    \ = len + 1, #items do\n    -- Get current number's last digit.\n    cur = tonumber(string.sub(items[i],\
    \ 1, -1))\n    -- If the current number's last digit is smaller than the new maximum,\n\
    \    -- then consider it as the new maximum.\n    if cur < max then\n      max\
    \ = cur\n      last_number = items[i]\n    end\n  end\n  return last_number, max\n\
    end", "  if nums == nil then\n    return nil\n  end\n  local index = 1\n  local\
    \ points = {}\n  local total_points = 0\n  for i = 1, #nums do\n    local current_points\
    \ = (math.floor(#nums / 10) * 10)\n    if current_points > total_points then\n\
    \      points[index] = total_points\n      total_points = current_points\n   \
    \ end\n    points[index] = points[index] + (nums[i] - '0'):byte()\n    index =\
    \ index + 1\n  end\n  total_points = total_points + nums[-1] - '0':byte()\n  if\
    \ total_points > points[index] then\n    points[index] = total_points\n  end\n\
    \  return points\nend", "  if nums == nil then return nil end\n  local sums =\
    \ { [0] = '' } -- '' means no digits at all.\n  for i = 1, #nums do\n    local\
    \ n = tostring(nums[i])\n    sums[#sums + 1] = tostring(sums[#sums + 1]) or n\n\
    \  end\n  -- Now use 'sort' from Lua to order the array.\n  table.sort(sums, function(a,\
    \ b)\n    local da = tostring(a):sub(2, -2)\n    local db = tostring(b):sub(2,\
    \ -2)\n    return da < db\n  end)\n  -- The first element is the one to add to\
    \ the result array.\n  local index = 1\n  -- Append the rest to result array.\n\
    \  local new_nums = { [#nums] = '' }\n  for i = 1, #sums do\n    local sum = tostring(sums[i])\n\
    \    -- Add this number to the first element of the result array.\n    new_nums[#new_nums\
    \ + 1] = sum\n    -- Replace the old digit with the last number of the sums array.\n\
    \    sums[i] = sums[#sums]\n    -- Remove the last number of the sums array.\n\
    \    sums[#sums] = nil\n    -- Reset the index if the sum is the same.\n    if\
    \ sum == tostring(sums[index]) then\n      index = index + 1\n    end\n  end\n\
    \  -- Return result array.\n  return new_nums\nend", "  -- initialize to a list\n\
    \  local result = {}\n  local index = 1\n  -- find the sum of each number\n  for\
    \ i = 1, #nums do\n    local sum = nums[i]\n    local digits = 0\n    while sum\
    \ ~= 0 do\n      sum = sum % 10\n      digits = digits + 1\n    end\n    -- append\
    \ the number if it has same number of digits\n    if digits == index and nums[i]\
    \ > 0 then\n      table.insert(result, nums[i])\n    end\n    -- increment the\
    \ index\n    index = index + 1\n  end\n  return result\nend", "  if nums == nil\
    \ then\n    return nil\n  end", "  if nums == nil then\n    return []\n  end\n\
    \  local numslen = #nums\n  local sum = 0\n  for i = 1, numslen do\n    sum =\
    \ sum + nums[i]\n  end\n  -- Sort from small to large sums.\n  table.sort(nums,\
    \ function(a, b)\n    return b - a -- descending order\n  end)\n  local newnums\
    \ = {}\n  local lastsum\n  -- Get index of largest sum.\n  for i = 1, numslen\
    \ do\n    local x = nums[i]\n    local sum = sum + x\n    if lastsum == nil then\n\
    \      lastsum = sum\n      newnums[i] = x\n      continue\n    end\n    local\
    \ nextsum\n    local index = i -- Start searching from here, so we don't need\
    \ to check every value.\n    local sum = lastsum + x\n    while sum > lastsum\
    \ do\n      lastsum = sum\n      index = index + 1\n      nextsum = sum + nums[index]\n\
    \      sum = nextsum\n    end\n    newnums[i] = nums[index]\n  end\n  return newnums\n\
    end", "    local nums = nums or {}\n    local sums = {}\n    for i = 1, #nums\
    \ do\n        sums[#sums + 1] = sum_digits(nums[i])\n    end\n    local maxi =\
    \ #sums\n    for i = 1, maxi do\n        local j = i\n        while j > 0 and\
    \ sums[j] - sums[i] < 0 do\n            sums[j] = sums[j]\n            j = j -\
    \ 1\n        end\n        sums[j] = sums[i]\n    end\n    for i = 1, maxi do\n\
    \        nums[#nums + 1] = nums[i]\n    end\n    for i = 1, #sums do\n       \
    \ local sum = 0\n        local j = i\n        while j > 0 and sum + sums[j] >\
    \ sums[i] do\n            sum = sum + sums[j]\n            j = j - 1\n       \
    \ end\n        nums[#nums + 1] = sum - sums[i]\n    end\n    return nums\nend",
  "  if not nums then return nums end\n  local n = 0\n  local t\n  for i = 1, #nums\
    \ do\n    t = math.abs(nums[i])\n    if n == 0 then\n      n = t\n      continue\n\
    \    end\n    if t < n then\n      nums[i], nums[n] = nums[n], nums[i]\n    end\n\
    \    n = t\n  end\n  return nums\nend", "  if nums == nil then\n    return nil\n\
    \  end\n  local nums_size = #nums\n  if nums_size < 2 then\n    return nums\n\
    \  end\n  -- Create a map from digits in nums to sum of their digits.\n  -- This\
    \ is used to order nums according to their digits.\n  local digit_sums = {}\n\
    \  for i = 1, 10 do\n    digit_sums[i] = 0\n  end\n  for i = 1, nums_size do\n\
    \    local digit = nums[i]\n    digit_sums[digit] = digit_sums[digit] + digit\n\
    \  end\n  -- Sort nums in ascending order.\n  -- In order to do this, sort the\
    \ digits in the reverse order in digit_sums.\n  -- This guarantees that digit_sums\
    \ are in descending order.\n  local nums_copy = nums:clone()\n  table.sort(\n\
    \    function(lhs, rhs)\n      return rhs - lhs -- Subtract first from second.\n\
    \    end,\n    digit_sums)\n  -- Reverse nums order and copy digits back.\n  for\
    \ i = 1, nums_size do\n    nums[#nums] = nums_copy[i]\n  end\n  return nums\n\
    end", "    local ns = {} -- temporary storage of sum\n    local i = 1\n    for\
    \ _, v in ipairs(nums) do\n        ns[#ns+1] = v -- store sum\n        i = i +\
    \ 1\n    end\n    local nt = {}\n    for i=1, #ns do\n        local k = math.floor(math.abs(ns[i]\
    \ - math.floor(ns[i]))) -- round to nearest integer\n        table.insert(nt,\
    \ k)\n    end\n    -- sort ascending according to sum\n    table.sort(nt)\n  \
    \  local ns2\n    for _, v in ipairs(nt) do\n        table.insert(ns2, nums[v])\n\
    \    end\n    return ns2\nend", "  if #nums == 0 then return [] end\n  local sum\
    \ = 0\n  local map = {}\n  for i = 1, #nums do\n    local num = nums[i]\n    sum\
    \ = sum + math.floor(num)\n    map[sum] = map[sum] or {}\n    map[sum][#map[sum]\
    \ + 1] = num\n  end\n  local result = {}\n  for i = 1, #map do\n    table.insert(result,\
    \ map[#map + 1][#map[i]])\n  end\n  return result\nend", "  local nums_with_digits\
    \ = {}\n  for i = 1, #nums do\n    local n = nums[i]\n    local d = math.floor(math.log10(n))\n\
    \    local digit = n % 10\n    nums_with_digits[i] = n * (10^(d-1)) + digit\n\
    \  end", "  if #nums == 0 then return nums end\n  local max_point = 0\n  local\
    \ max_idx = 0\n  local total = 0\n  for i = 1, #nums do\n    local point = nums[i]\n\
    \    total = total + point\n    if point > max_point then\n      max_point = point\n\
    \      max_idx = i\n    end\n  end\n  if max_point > 0 then\n    nums[max_idx]\
    \ = total\n  end\n  local num_copy = #nums\n  -- Sort by increasing sum of digits.\n\
    \  for i = 1, #nums do\n    local point = nums[i]\n    local idx = 1\n    while\
    \ idx + 1 < num_copy and nums[idx + 1] == point do\n      idx = idx + 1\n    end\n\
    \    if idx > 1 then\n      nums[idx], nums[idx + 1] = nums[idx + 1], nums[idx]\n\
    \    end\n  end\n  return nums\nend", "  if not nums then\n    return nums\n \
    \ end\n  local num_map = {}\n  local new_nums = terralib.newlist()\n  local sum_so_far\
    \ = terralib.newlist()\n  local i = 0\n  for i = 1, #nums do\n    local n = nums[i]\n\
    \    if not num_map[n] then\n      num_map[n] = i\n      sum_so_far:insert(n)\n\
    \    else\n      sum_so_far[num_map[n]] = n\n    end\n  end\n  new_nums:insert(nums[1])\n\
    \  local j = 1\n  for i = 2, #nums do\n    local n = sum_so_far[j]\n    local\
    \ m = i\n    while m > 0 and sum_so_far[m - 1] > n do\n      m = m - 1\n    end\n\
    \    local tmp = num_map[n]\n    num_map[n] = i\n    j = m\n    new_nums:insert(nums[i])\n\
    \    num_map[i] = tmp\n  end\n  return new_nums\nend", "  local sorted = {}\n\
    \  for i = 1, #nums do\n    local digits = nums:sub(i,i)\n    local index\n  \
    \  for j = 1, #digits do\n      index = j + i\n      table.insert(sorted,\n  \
    \                 index,\n                   digits[j])\n    end\n  end\n  return\
    \ sorted\nend", "  local seen = {}\n  local out = {}\n  local i = 1\n  while i\
    \ <= #nums do\n    local d = nums:sub(i, i) + nums:sub(i+1, i+2) -- add digits\n\
    \    if seen[d] then\n      local ii = seen[d]\n      seen[d] = ii + 1\n     \
    \ out[ii] = nums[ii]\n    else\n      seen[d] = #out\n      table.insert(out,\
    \ nums[i])\n    end\n    i = i + 2\n  end\n  return out\nend", "  if #nums ==\
    \ 0 then\n    return {}\n  end\n  local sums = {}\n  for i = 1, #nums do\n   \
    \ local sum = 0\n    for j = 1, 10 do\n      sum = sum + nums[i] - '0' + j\n \
    \   end\n    if sums[sum] == nil then\n      sums[sum] = 1\n    else\n      sums[sum]\
    \ = sums[sum] + 1\n    end\n  end\n  local res = {}\n  for i = 1, 10 do\n    local\
    \ sum = 0\n    for j = 1, #sums do\n      if sums[j] > 0 then\n        sum = sum\
    \ + j\n      end\n    end\n    res[i] = sum\n  end\n  return res\nend", "  local\
    \ result = {}\n  for _, num in ipairs(nums) do\n    local sum = 0\n    for k in\
    \ string.gmatch(tostring(num), '%d') do\n      sum = sum + k\n    end\n    result[sum]\
    \ = num\n  end\n  return table.sort(result,\n                     function(a,\
    \ b)\n                       if a>b then return 1 end\n                      \
    \ if b > a then return -1 end\n                       return 0\n             \
    \        end)\nend", "  -- Initialize helper variables used in sorting process.\n\
    \  local sum = 0\n  local nums_copy = nums\n  -- Sort the numbers.\n  for i =\
    \ 1, #nums_copy do\n    -- Get digit by indexing from the original number.\n \
    \   local digit = nums_copy:sub(i, i):byte()\n    -- If the digit is not digit,\
    \ ignore it and continue to the next number.\n    if digit == 0 then break end\n\
    \    -- Calculate the sum of digit of each number and add it to the sum variable.\n\
    \    sum = sum + digit\n  end\n  -- Return sorted list of numbers.\n  return nums_copy:sort(function\
    \ (a, b)\n    -- If the numbers are equal, order them based on the original index.\n\
    \    return a ~= b and a < b or\n           a ~= b and a > b and a < nums_copy:index(b)\
    \ or\n           a ~= b and a > b and a > nums_copy:index(b)\n  end)\nend", " \
    \  if #nums < 1 then return nil end\n   local sums = {}\n   for _, v in ipairs(nums)\
    \ do\n      sums[v] = sums[v] or 0\n      sums[v] = sums[v] + 1\n   end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
