name: HumanEval_119_match_parens
language: lua
prompt: "-- You are given a list of two strings, both strings consist of open\n--\
  \ parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it\
  \ is possible to concatenate the two strings in\n-- some order, that the resulting\
  \ string will be good.\n-- A string S is considered to be good if and only if all\
  \ parentheses in S\n-- are balanced. For example: the string '(())()' is good, while\
  \ the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good\
  \ string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(', ')'])\
  \ == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
  \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
  \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n  \
  \  lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
  \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n  \
  \  lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
  \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n   \
  \ lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
  \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   -- Base case: if the list is empty, we're done\n   if #lst == 0\
    \ then\n      return 'No'\n   end", "  if #lst <= 1 then return 'No' end\n  local\
    \ open = 0, closed = 0\n  for i = 1, #lst do\n    if lst[i] == '('\n    then open\
    \ = open + 1\n    else if lst[i] == ')'\n    then open = open - 1\n    if open\
    \ == 0 then return 'Yes' end\n    end\n    closed = closed + 1\n  end\n  if closed\
    \ ~= 0 then return 'No' end\n  return 'Yes'\nend", "   local open = 0\n   local\
    \ close = 0\n   for i, v in pairs(lst) do\n      if v == '(' then\n         open\
    \ = open + 1\n      elseif v == ')' then\n         close = close + 1\n      elseif\
    \ v == '(' and open == close then\n         return 'Yes'\n      end\n   end\n\
    \   return 'No'\nend\n</cell>\n<cell>", "  if #lst < 2 then return false end\n\
    \  local open = lst[1]\n  local close = lst[#lst]\n  local pos = 2\n  while pos\
    \ < #lst do\n    if lst[pos] == open then\n      pos = pos + 1\n    else if lst[pos]\
    \ == close then\n      pos = pos + 1\n    elseif lst[pos] ~= '(' then return false\
    \ end\n      else return true end\n    end\n  end\n  return false\nend", "  local\
    \ open = 0\n  local close = 0\n  local i = 0\n  -- Check how many open parentheses\
    \ are in lst[i].\n  for i = 1, #lst do\n    if lst[i] == '(' then\n      open\
    \ = open + 1\n    elseif lst[i] == ')' then\n      close = close + 1\n      if\
    \ open ~= close then\n        open = 0\n      end\n    end\n  end\n  return open\
    \ ~= close\nend", "    if #lst == 0 then return 'No' end\n    local first = lst[1]\n\
    \    if first:find(')') ~= nil then\n        if first:find('(') == nil then\n\
    \            return 'No'\n        elseif lst[#lst]:find('(') == nil then\n   \
    \         return 'Yes'\n        else\n            return 'Yes'\n        end\n\
    \    end\n    if lst[1]:find('(') == nil then\n        return 'No'\n    else\n\
    \        return 'Yes'\n    end\nend", "    local s = lst[1]\n    for i = 2, #lst\
    \ do\n        s = s .. lst[i]\n        if s ~= '()' and s ~= ')' and (#s == '()'\
    \ or s ~= '()(') then\n            return 'No'\n        end\n    end\n    return\
    \ 'Yes'\nend", "  -- Base case\n  if #lst == 1 then return true end", "  local\
    \ stack = {}\n  for i = 1, #lst do\n    if parens_balanced(stack, lst[i]) then\
    \ return 'Yes' end\n    stack[#stack + 1] = lst[i]\n  end\n  return 'No'\nend",
  "   if #lst < 2 then return nil end\n   local open = setmetatable({}, {__mode =\
    \ \"v\"})\n   local close = setmetatable({}, {__mode = \"v\"})\n   for i = 1,\
    \ #lst do\n      local x = lst[i]\n      local y = lst[i + 1]\n      if x == '('\
    \ and y == '(' then open[x] = true end\n      if x == ')' and y == ')' then close[x]\
    \ = true end\n   end\n   for i = 1, #lst - 1 do\n      local x = lst[i]\n    \
    \  local y = lst[i + 1]\n      if open[x] and close[y] then return \"Yes\" end\n\
    \      if close[x] and not open[y] then return \"No\" end\n   end\n   return nil\n\
    end", "  local open_braces, close_braces = 0, 0\n  for i = 1, #lst do\n    if\
    \ lst[i] == '(' then\n      open_braces = open_braces + 1\n    else if lst[i]\
    \ == ')' then\n      close_braces = close_braces + 1\n      if open_braces > 0\
    \ and close_braces == open_braces then\n        return 'Yes'\n      end\n    end\n\
    \  end\n  return 'No'\nend", "  if #lst == 0 then\n    return 'No'\n  end\n  if\
    \ lst[1] == ')' and lst[#lst] == ')' then\n    return 'Yes'\n  end\n  local open\
    \ = 0\n  local close = 0\n  for i = 1, #lst do\n    if lst[i] == ')' then\n  \
    \    close = close + 1\n    elseif lst[i] == '(' then\n      open = open + 1\n\
    \    end\n    if close == open then\n      return 'No'\n    end\n  end\n  return\
    \ 'Yes'\nend", "\tlocal open = 0\n\tlocal close = 0\n\tlocal str = ''\n\tfor i\
    \ = 1, #lst do\n\t\tif lst[i] == '(' then\n\t\t\tif open < close then\n\t\t\t\t\
    open = open + 1\n\t\t\tend\n\t\telseif lst[i] == ')' then\n\t\t\tif open > close\
    \ then\n\t\t\t\tclose = close + 1\n\t\t\tend\n\t\telse\n\t\t\tif open > close\
    \ then\n\t\t\t\tstr = str..lst[i]\n\t\t\telse\n\t\t\t\tstr = str..close..lst[i]\n\
    \t\t\tend\n\t\tend\n\tend\n\tif open > close then\n\t\treturn 'No'\n\telseif open\
    \ == close then\n\t\treturn 'Yes'\n\telse\n\t\treturn 'No'\n\tend\nend", "  if\
    \ #lst == 1 then return true end\n  local l = {}\n  for i = 1, #lst do l[i] =\
    \ lst[i][1] end\n  l.sort()\n  return l[1] == ')' and l[2] == ')'\nend", "   \
    \ assert(#lst >= 2, 'The input list should at least contain 2 elements.')\n  \
    \  local str = lst[1]\n    lst[1] = lst[2]\n    lst[2] = str\n    local ret =\
    \ 'No'\n    local i = #lst - 1\n    while i > 1 do\n        local cur_str = lst[i]\n\
    \        local next_str = lst[i + 1]\n        local has_open_paran = cur_str:match('^(%[)%]%(%[^(%)]*%))+$')\n\
    \        local has_close_paran = next_str:match('^%[)%]%(%(%[^(%)]*%))+$')\n \
    \       if has_open_paran and has_close_paran then\n            local open_paran\
    \ = cur_str:sub(1, cur_str:find(has_open_paran))\n            local close_paran\
    \ = next_str:sub(1, next_str:find(has_close_paran))\n            if open_paran\
    \ ~= close_paran then\n                ret = 'No'\n                lst[i + 1]\
    \ = lst[i + 1]:sub(1, open_paran:len() + close_paran:len())\n            else\n\
    \                ret = 'Yes'\n            end\n        elseif has_open_paran then\n\
    \            ret = 'No'\n            lst[i + 1] = lst[i + 1]:sub(1, cur_str:find(has_open_paran))\n\
    \        elseif has_close_paran then\n            ret = 'No'\n            lst[i\
    \ + 1] = lst[i + 1]:sub(1, next_str:find(has_close_paran))\n        else\n   \
    \         ret = 'No'\n        end\n        i = i - 1\n    end\n    lst[1] = str\n\
    \    return ret\nend", "  local open_balance = 0\n  local close_balance = 0\n\
    \  local result\n  local index\n  for index, char1 in pairs(lst) do\n    local\
    \ char2 = lst[index + 1]\n    if char2 == '(' then\n      open_balance = open_balance\
    \ + 1\n    else if char2 == ')' then\n      close_balance = close_balance + 1\n\
    \    end\n  end\n  if open_balance + close_balance == 0 then\n    result = 'Yes'\n\
    \  else\n    result = 'No'\n  end\n  return result\nend", "  local i = 1\n  while\
    \ i <= #lst do\n    local c = lst[i]\n    if c == '(' or c == '{' or c == '}'\
    \ then\n      if i == #lst then\n        return 'Yes'\n      else\n        local\
    \ next_c = lst[i+1]\n        if next_c == ')' then\n          i = i+1\n      \
    \  elseif next_c == '}' then\n          i = i+1\n        elseif next_c == '('\
    \ then\n          i = i+1\n        else\n          return 'No'\n        end\n\
    \      end\n    end\n    i = i+1\n  end\n  return 'No'\nend", "    local num_open\
    \ = 0\n    for i = 1, #lst do\n        local open = lst[i]\n        if open ==\
    \ \"(\" then num_open = num_open + 1 end\n        if open == \")\" then\n    \
    \        if num_open == 0 then return false end\n            num_open = num_open\
    \ - 1\n        end\n    end\n    return num_open == 0\nend", "    if #lst == 0\
    \ then return 'No' end\n    local first = lst[1]\n    if first == '(' and first\
    \ == lst[2] then return 'Yes' end\n    if first == '(' and first ~= lst[2] then\
    \ return 'No' end\n    local last = lst[#lst]\n    if last == ')' and last ==\
    \ lst[2] then return 'Yes' end\n    if last == ')' and last ~= lst[2] then return\
    \ 'No' end\n    return match_parens(lst)\nend\n</cell>\n<cell>", "    -- Base\
    \ case:\n    if #lst == 0 then\n        return true\n    end", "  for i = 1, #lst\
    \ do\n    if lst[i] == ')' then\n      if not lst[i-1] then return false end\n\
    \      if lst[i-1] ~= lst[i] then return false end\n      i = i - 1\n    end\n\
    \    if lst[i] == '(' then\n      if lst[i-1] ~= '(' then return false end\n \
    \     i = i - 1\n    end\n  end\n  return true\nend", "  local opens = { }\n \
    \ local closes = { }\n  local open = 0\n  local close = 0\n  for _, s in ipairs(lst)\
    \ do\n    if s == '(' then opens[open] = true else closes[close] = true end\n\
    \    open = open + 1\n    close = close + 1\n  end\n  local good = true\n  for\
    \ i = 1, #lst do\n    local s = lst[i]\n    if s == '(' and opens[open] then\n\
    \      good = false\n    end\n    if s == ')' and closes[close] then\n      good\
    \ = false\n    end\n    open = open - 1\n    close = close - 1\n  end\n  return\
    \ good\nend", "  if lst[1] == '(' and lst[#lst - 1] == ')' then\n    return true\n\
    \  end\n  return false\nend", "\tlocal i = 1\n\tlocal n = #lst\n\twhile i <= n\
    \ do\n\t\tif lst[i] == '(' then i = i+1 end\n\t\tif lst[i] == '(' and lst[i-1]\
    \ == ')' then i = i+2 end\n\t\ti = i+1\n\tend\n\tif i == n then return 'No' end\n\
    \treturn 'Yes'\nend", "  local open = 0\n  local close = 0\n  for i=1,#lst do\n\
    \    local x = lst[i]\n    if x == '(' and open ~= 0 then\n      open = open -\
    \ 1\n      if open < 0 then return false end\n    elseif x == ')' and close ~=\
    \ 0 then\n      close = close - 1\n      if close < 0 then return false end\n\
    \    end\n  end\n  if open ~= close then return false end\n  return true\nend",
  "  assert(#lst == 2)\n  local str1 = lst[1]\n  local str2 = lst[2]\n  assert(str1:find('(')\
    \ == 1 and str2:find('(') == 1)\n  local open = str:len()\n  local close = str:find(')')\n\
    \  if close == nil then\n    return false\n  end\n  if close < open then\n   \
    \ return false\n  end\n  local i = open\n  while i < close do\n    i = i + 1\n\
    \    if str1[i] ~= '(' or str2[i] ~= ')' then\n      return false\n    end\n \
    \ end\n  return true\nend", "  -- Base case\n  if #lst == 1 then\n    return lst[1]\
    \ == ')' or lst[1] == '('\n  end", "  local open = 0\n  local close = 0\n  local\
    \ start = 1\n  for i = 1, #lst do\n    if lst[i] == \"(\" then\n      open = open\
    \ + 1\n      if open > close then\n        return false\n      end\n    elseif\
    \ lst[i] == \")\" then\n      close = close + 1\n      if close < open then\n\
    \        return false\n      end\n    end\n    start = i + 1\n  end\n  local result\
    \ = open + close == #lst\n  -- Check only first character if open and close are\
    \ same\n  if open ~= close then\n    result = result == 1 and start\n  end\n \
    \ return result\nend", "    local open = 0\n    local close = 0", "  local open_count\
    \ = 0\n  local close_count = 0\n  for i=1,#lst do\n    if lst[i] == \"(\" then\n\
    \      open_count = open_count + 1\n    elseif lst[i] == \")\" then\n      close_count\
    \ = close_count + 1\n    end\n  end\n  if open_count ~= close_count then\n   \
    \ return \"No\"\n  end\n  for i=1,#lst do\n    if open_count ~= 0 and lst[i] ==\
    \ \"(\" then\n      open_count = open_count - 1\n    elseif open_count ~= 0 and\
    \ lst[i] == \")\" then\n      open_count = open_count - 1\n    end\n    if close_count\
    \ ~= 0 and lst[i] == \")\" then\n      close_count = close_count - 1\n    end\n\
    \  end\n  if open_count ~= 0 and open_count ~= close_count then\n    return \"\
    No\"\n  end\n  return \"Yes\"\nend", "  local stack = {}\n  local open = 1\n \
    \ local close = 1\n  for i = 1, #lst do\n    if lst[i] == '(' then\n      open\
    \ = open + 1\n      stack[#stack + 1] = open\n    elseif lst[i] == ')' then\n\
    \      close = close + 1\n      if open ~= close then\n\tstack[#stack + 1] = open\n\
    \topen = open\n      else\n\topen = open - 1\n      end\n    end\n  end\n  --\
    \ if stack ~= {} then\n  -- print(stack, open, close)\n  -- end\n  -- print(#stack\
    \ > 0)\n  -- if #stack > 0 then\n  -- print('yes')\n  return #stack == 0\nend",
  "  if lst[1] == nil then\n    return 'No'\n  end", "  local i = 0\n  while i < #lst\
    \ do\n    local c = lst[i]\n    if not (c == \"(\" or c == \")\") then\n     \
    \ i = i - 1\n      break\n    end\n    i = i + 1\n  end\n  if i == #lst then\n\
    \    return \"No\"\n  end\n  local open = 0\n  local close = 0\n  local done =\
    \ 0\n  for i = 1, #lst do\n    if lst[i] == \")\" and done == open then\n    \
    \  close = close + 1\n      open = open - 1\n    end\n    if lst[i] == \"(\" and\
    \ done == close then\n      open = open + 1\n      close = close - 1\n    end\n\
    \    if lst[i] == \")\" and done == close then\n      done = done + 1\n    end\n\
    \  end\n  if open ~= close then\n    return \"No\"\n  end\n  return \"Yes\"\n\
    end", "  local closes = { 0 }\n  local opens = { 0 }\n  local n = 1\n  for i =\
    \ 1, #lst do\n    if lst[i] == '(' or lst[i] == ')' then\n      closes = closes\
    \ + 1\n      opens = opens + 1\n    elseif lst[i] == '{' or lst[i] == '}' then\n\
    \      n = n - 1\n    end\n  end\n  if opens - closes == #lst - n then\n    return\
    \ 'Yes'\n  else\n    return 'No'\n  end\nend", "  local n = 1\n  local open =\
    \ 0\n  local close = 0\n  local balanced = 1\n  for i = 1, #lst do\n    if lst[i]\
    \ == '(' then\n      open = open + 1\n      balanced = balance and (open > close)\n\
    \    elseif lst[i] == ')' then\n      close = close + 1\n      balanced = balance\
    \ and (close > open)\n    end\n    local n = n + 1;\n  end\n  local result = 'No'\n\
    \  if balance == 1 then\n    if open == close then\n      result = 'Yes'\n   \
    \ end\n  end\n  return result\nend", "  local open = 0\n  local close = 0\n  for\
    \ _, c in ipairs(lst) do\n    if c == '(' then\n      open = open + 1\n    elseif\
    \ c == ')' then\n      close = close + 1\n    end\n  end\n  if close == open then\n\
    \    return 'Yes'\n  else\n    return 'No'\n  end\nend", "  if #lst == 0 then\
    \ return 'No' end\n  local str = string.sub(lst, 1, 1)\n  local index = 2\n  while\
    \ str ~= '(' or str ~= ')' do\n    if str == '(' and lst[index + 1] ~= ')' then\n\
    \      return 'No'\n    end\n    index = index + 1\n    str = string.sub(lst,\
    \ index, 1)\n  end\n  if str ~= '(' or str ~= ')' then return 'No' end\n  local\
    \ result = {}\n  local count = 0\n  for i = 1, #lst - 1 do\n    local a = string.sub(lst,\
    \ i, i+1)\n    if str == ')' and count == 0 then\n      count = count + 1\n  \
    \    table.insert(result, a)\n    elseif str == '(' and count == 1 then\n    \
    \  count = count + 1\n      table.insert(result, a)\n    elseif str == '(' and\
    \ count == 2 then\n      count = count + 1\n      table.insert(result, a)\n  \
    \  elseif str == ')' and count == 2 then\n      count = count - 1\n      table.insert(result,\
    \ a)\n    end\n  end\n  return string.rep('Y', #result) and result[#result] or\
    \ nil\nend", "    if #lst == 0 then\n        return 'No'\n    end\n    local result\
    \ = true\n    local stack = {}\n    for i = 1, #lst do\n        local c = lst[i]\n\
    \        if c == '(' or c == '[' or c == '{' or c == '(' or c == '{' or c == '['\
    \ or c == '(':\n            stack[#stack+1] = c\n        elseif c == '}' or c\
    \ == ']' or c == ']' or c == '}' or c == '}' or c == ']' or c == '[' or c == ']'\
    \ then\n            if #stack == 0 then\n                result = false\n    \
    \        elseif stack[#stack] == c then\n                stack[#stack] = nil\n\
    \            else\n                result = false\n            end\n        else\n\
    \            if #stack > 0 and stack[#stack] == c then\n                stack[#stack]\
    \ = nil\n            else\n                result = false\n            end\n \
    \       end\n    end\n    if #stack > 0 then\n        result = false\n    end\n\
    \    return result\nend", "    if #lst == 0 then\n        return false\n    end\n\
    \    local len = #lst\n    local open = 0\n    local close = 0\n    for i = 1,\
    \ len do\n        local c = lst[i]\n        if c == '(' then\n            open\
    \ = open + 1\n        elseif c == ')' then\n            close = close + 1\n  \
    \      elseif open == close then\n            local popen = open - close + 1\n\
    \            local pclose = open - 1\n            local popen2 = close - open\
    \ + 1\n            if popen == pclose and popen == popen2 then\n             \
    \   return true\n            end\n        end\n    end\n    return false\nend",
  "  local i = 0\n  while i < #lst do\n    if lst[i] == '(' and (lst[i + 1] == ')'\
    \ or lst[i + 1] == nil) then\n      i = i + 2\n    elseif lst[i] == ')' and (lst[i\
    \ - 1] == ')' or lst[i - 1] == nil) then\n      i = i - 1\n    elseif lst[i] ==\
    \ nil then\n      return nil\n    end\n    i = i + 1\n  end\n  return i == #lst\n\
    end", "    local ret = \"\"\n    local stack = {}\n    for i = 1, #lst do\n  \
    \      if lst[i] == \"(\" then\n            table.insert(stack, i)\n        elseif\
    \ lst[i] == \")\" then\n            if #stack > 0 then\n                local\
    \ num = table.remove(stack)\n                ret = ret .. lst[num] .. lst[i]\n\
    \            end\n        elseif stack[#stack] == i then\n            if #stack\
    \ > 0 then\n                local num = table.remove(stack)\n                ret\
    \ = ret .. lst[num] .. lst[i]\n            end\n        else\n            table.insert(stack,\
    \ i)\n        end\n    end", "  if #lst == 1 then\n    return match_parens(lst[1])\
    \ ~= 'No'\n  end\n  local open_balance = 1\n  local close_balance = 1\n  local\
    \ stack = {}\n  for i = 1, #lst do\n    if lst[i] == '(' then\n      open_balance\
    \ = open_balance + 1\n      stack[i] = true\n    elseif lst[i] == ')' then\n \
    \     close_balance = close_balance + 1\n      if open_balance ~= close_balance\
    \ then\n        open_balance = open_balance - 1\n      end\n      stack[i] = false\n\
    \    else\n      stack[i] = open_balance == close_balance\n    end\n  end\n  for\
    \ i = 1, #stack do\n    if stack[i] == true then\n      return true\n    end\n\
    \  end\n  return false\nend", "  return (not lst:match('^%s*(%s?)$') or lst:match('^%s*(%s?)%s*$'))\
    \ and\n    'No'\nend", "    -- base case\n    if #lst == 1 then\n        if lst[1]\
    \ == '(' then\n            return true\n        elseif lst[1] == ')' then\n  \
    \          return true\n        end\n    end", "   local res = 'Yes'\n   for i\
    \ = 1, #lst do\n      local cur_char = lst[i]\n      if cur_char == '(' or cur_char\
    \ == ')' then\n         local count = 0\n         local start = i + 1\n      \
    \   while start <= #lst and lst[start] == cur_char do\n            start = start\
    \ + 1\n            count = count + 1\n         end\n         if start > i then\
    \ res = res and cur_char == '(' and count == end - start or res and cur_char ==\
    \ ')' and count > end - start or res and cur_char == '(' and count < end - start\
    \ or res and cur_char == ')' and count < end - start then\n            i = start\
    \ + 1\n         else\n            res = res and cur_char == '(' or res and cur_char\
    \ == ')'\n         end\n      else\n         res = res and cur_char == ')' or\
    \ res and cur_char == '('\n      end\n   end\n   return res\nend", "  local stack\
    \ = {}\n  for i = 1, #lst do\n    if stack[#stack] == nil then\n      stack[#stack]\
    \ = lst[i]\n      local res = false\n      if stack[#stack] ~= '(' then\n    \
    \    res = true\n      end\n      while #stack > 0 do\n        if stack[#stack]\
    \ == '(' then\n          stack[#stack] = nil\n          res = not res\n      \
    \  end\n        if stack[#stack] == ')' then\n          stack[#stack] = nil\n\
    \          return res\n        end\n        if stack[#stack] ~= nil then\n   \
    \       stack[#stack] = nil\n        end\n        table.insert(stack, lst[i])\n\
    \      end\n    end\n  end\n  return nil\nend", "  local balanced = 0\n  local\
    \ good = 0", "   local cnt = 0\n   for i = 1, #lst do\n      local lc = lst[i]\n\
    \      local rp = 1\n      if lc ~= '(' and lc ~= ')' then return 'No' end\n \
    \     for j = i + 1, #lst do\n         if lst[j] == lc then\n            rp =\
    \ rp + 1\n            if rp == #lst then return 'Yes' end\n         else\n   \
    \         rp = 1\n         end\n      end\n   end\n   return 'No'\nend", "\tlocal\
    \ n = #lst\n\tlocal result = true\n\tfor i = 1, n do\n\t\tlocal a = lst[i]\n\t\
    \tif a == \"(\" then\n\t\t\tresult = result and match_parens(lst[(i+1):])\n\t\t\
    elseif a == \")\" then\n\t\t\tif not result then\n\t\t\t\tresult = false\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn result\nend", "  local opens = lst:reduce(function(acc,\
    \ x)\n    if x:sub(1, 1) == \"(\" then\n      acc = acc + 1\n    end\n    return\
    \ acc\n  end, 0)\n  local closes = lst:reduce(function(acc, x)\n    if x:sub(1,\
    \ 1) == \")\" then\n      acc = acc + 1\n    end\n    return acc\n  end, 0)\n\
    \  if opens == opens and closes == opens then\n    return true\n  else\n    return\
    \ false\n  end\nend", "  local i = 1\n  local res = true\n  while i < #lst do\n\
    \    if lst[i] ~= '(' and lst[i] ~= ')' then\n      res = false\n      break\n\
    \    end\n    i = i + 1\n  end\n  return res\nend", "\tlocal good, balance, pos\
    \ = true, true, 0\n\tlocal len = #lst\n\tif len < 2 then return 'No' end\n\tfor\
    \ i = 1, len do\n\t\tlocal p = lst[i]\n\t\tif p == \"(\" then good, pos = (good\
    \ or balance and balance) and pos or pos + 1, true end\n\t\tif p == \")\" then\
    \ good, balance = false, good or balance and balance - 1 and balance or false,\
    \ true end\n\tend\n\treturn good and 'Yes' or 'No'\nend", "  local open_count\
    \ = 0\n  local close_count = 0\n  local opening_count = 0\n  local opening_pos\
    \ = 0\n  local current_pos = 0\n  local current_char = ''", "  if #lst == 0 then\n\
    \    return true\n  end\n  local open = 0\n  local close = 0\n  for i=1,#lst do\n\
    \    local char = lst[i]\n    if char == '(' then\n      open = open + 1\n   \
    \ elseif char == ')' then\n      close = close + 1\n      if close > open then\n\
    \        return false\n      end\n    end\n  end\n  return open + close == #lst\n\
    end", "  local good = true\n  local depth = 0\n  local open_count = 0\n  local\
    \ close_count = 0\n  local open_str = false\n  local close_str = false\n  local\
    \ len = #lst\n  for i = 1, len do\n    if lst[i] == '(' then\n      open_str =\
    \ true\n      open_count = open_count + 1\n    else if lst[i] == ')' then\n  \
    \    close_str = true\n      close_count = close_count + 1\n      depth = close_count\
    \ - open_count + 1\n      if depth == 0 then\n        good = false\n        break\n\
    \      end\n    end\n  end\n  if open_str and close_str then\n    good = false\n\
    \  end\n  return good\nend", "  assert(#lst >= 2)\n  local open1 = lst[1] == '('\n\
    \  local open2 = lst[2] == '('\n  local close1 = lst[1] == ')'\n  local close2\
    \ = lst[2] == ')'\n  local s1 = open1 and open2 and close1 and close2 or open1\
    \ and open2 and not close1 and close2\n  local s2 = not s1 and open1 and open2\
    \ and not close1 and close2\n  return s1 or s2\nend", "    local left_count =\
    \ 0\n    local right_count = 0\n    for token in lst do\n        if token == '('\
    \ then\n            left_count = left_count + 1\n        elseif token == ')' then\n\
    \            right_count = right_count + 1\n        end\n    end\n    if left_count\
    \ == right_count then\n        return 'Yes'\n    else\n        return 'No'\n \
    \   end\nend", "  -- Base Case\n  if #lst == 2 then\n    if lst[1] ~= '(' and\
    \ lst[1] ~= ')' then\n      return false\n    end\n    return true\n  end", " \
    \   local open = {}\n    local close = {}", "  local function is_balanced(lst)\n\
    \    for index, paren in pairs(lst) do\n      local lcount = 1\n      for index2,\
    \ c in pairs(paren) do\n        if c == '(' and lcount == 1 then\n          return\
    \ false\n        end\n        if c == ')' and lcount > 1 then\n          return\
    \ false\n        end\n        lcount = lcount + 1\n      end\n    end\n    return\
    \ true\n  end", "  if #lst == 1 then\n    return true\n  end\n  local cur, prev\
    \ = lst[1], lst[1]\n  local good = true\n  for i = 2, #lst do\n    if cur == prev\
    \ then\n      good = good and\n        (lst[i] == ')' or lst[i] == '(')\n    elseif\
    \ cur == '(' and lst[i] == '(' then\n      good = good and\n        (lst[i] ==\
    \ ')' or lst[i] == '(')\n    elseif cur == ')' and lst[i] == ')' then\n      good\
    \ = good and\n        (lst[i] == '(' or lst[i] == '(')\n    else\n      good =\
    \ false and\n        (lst[i] == ')' or lst[i] == '(')\n    end\n    prev = cur\n\
    \    cur = lst[i]\n  end\n  return good\nend", "  local stack = setmetatable({},\
    \ {\n      __index = function(t, key)\n          local value = rawget(t,key)\n\
    \          if value == nil then return nil end\n          return value\n     \
    \ end,\n      __newindex = function() end\n  })\n  stack[#stack + 1] = '('", " \
    \   if lst[1] == \"\" then\n        return \"Yes\"\n    end", "  local stack =\
    \ {}\n  local good = true", "    local stack = {}\n    for i = 1, #lst do\n  \
    \      if lst[i] == '(' or lst[i] == ')' then\n            if lst[i - 1] == '('\
    \ and lst[i + 1] == ')' then\n                table.insert(stack, i)\n       \
    \     end\n        end\n    end\n    if #stack == #lst then return 'Yes' else\
    \ 'No' end\nend", "  local len1 = #lst\n  for i = 1, #lst do\n    local len2 =\
    \ #lst\n    local balanced = 0\n    for j = 1, len2 do\n      balanced = balanced\
    \ + (lst[j] == lst[j + balanced] and 1 or 0)\n    end\n    if balanced > 1 then\n\
    \      return false\n    end\n    len2 = len2 - balanced\n    len1 = len1 - balanced\n\
    \  end\n  return len1 == 0\nend", "    assert(lst[1] == '(' or lst[1] == ')')\n\
    \    local left = 0\n    local right = 1\n    local sum = 0\n    while right <=\
    \ #lst do\n        sum = sum + 1\n        if lst[left] ~= '(' and lst[right] ==\
    \ ')' then\n            right = right + 1\n        elseif lst[left] == ')' then\n\
    \            if lst[right] ~= ')' then\n                right = right + 1\n  \
    \          else\n                left = left + 1\n                right = right\
    \ + 1\n            end\n        else\n            left = left + 1\n          \
    \  right = right + 1\n        end\n    end\n    if sum > #lst then\n        return\
    \ 'No'\n    else\n        return 'Yes'\n    end\nend", "  -- base case\n  if #lst\
    \ == 2 then\n    return true and lst[1] == lst[2]\n  end", "  local open_bracket,\
    \ close_bracket = 1, 2\n  for i = 1, #lst do\n    if lst[i] == open_bracket then\n\
    \      open_bracket = open_bracket + 1\n    elseif lst[i] == close_bracket then\n\
    \      close_bracket = close_bracket + 1\n      open_bracket = open_bracket -\
    \ 1\n    elseif open_bracket == 0 then\n      return 'No'\n    end\n  end\n  return\
    \ 'Yes'\nend", "  local first_open = 1\n  local first_close = 0\n  local open_count\
    \ = 1\n  for i = 1, #lst do\n    if lst[i] == '(' and open_count == 1 then\n \
    \     first_open = i\n      open_count = open_count + 1\n    elseif lst[i] ==\
    \ ')' and open_count > 1 then\n      open_count = open_count - 1\n      if open_count\
    \ == 0 then\n        if first_close == i then\n          -- We could concatenate\
    \ all the strings to get a 'good' string here.\n          return true\n      \
    \  end\n      end\n    end\n  end\n  return false\nend", "   local stack = {}\n\
    \   local res = nil\n   local n = 0\n   for _,v in pairs(lst) do\n      if v ==\
    \ '(' then\n         n = n + 1\n      elseif v == ')' then\n         if n == 0\
    \ then\n            return false\n         else\n            n = n - 1\n     \
    \    end\n      elseif n = 0 then\n         stack[#stack + 1] = v\n      end\n\
    \   end\n   if n = 0 then\n      return true\n   end\n   for _,v in pairs(stack)\
    \ do\n      if res == nil then\n         res = v\n      elseif res == v then\n\
    \         return false\n      end\n   end\n   return true\nend", "  local open_bracket\
    \ = 1\n  local close_bracket = 0\n  for i = 1, #lst do\n    if lst[i] ~= '(' or\
    \ open_bracket ~= close_bracket then\n      if open_bracket > close_bracket then\n\
    \        return 'No'\n      end\n      close_bracket = open_bracket\n      open_bracket\
    \ = 0\n    else\n      if open_bracket == close_bracket then\n        open_bracket\
    \ = open_bracket + 1\n      else\n        open_bracket = 1\n      end\n    end\n\
    \  end\n  if open_bracket > close_bracket then\n    return 'No'\n  end\n  return\
    \ 'Yes'\nend", "   local pcount = 0\n   local i = 0\n   while i < #lst do\n  \
    \    if lst[i] == '(' and pcount ~= 0 then\n         pcount = pcount + 1\n   \
    \   elseif lst[i] == ')' and pcount ~= 0 then\n         pcount = pcount - 1\n\
    \      elseif pcount == 0 then\n         return false\n      elseif pcount ~=\
    \ 0 then\n         return false\n      end\n      i = i + 1\n   end\n   return\
    \ true\nend", "  local result = true\n  local openCount = 0\n  local closeCount\
    \ = 0\n  for i = 1, #lst do\n    if lst[i] == '(' and openCount == 0 then\n  \
    \    openCount = openCount + 1\n    elseif lst[i] == ')' and closeCount == 0 then\n\
    \      closeCount = closeCount + 1\n    elseif openCount > 0 and closeCount >\
    \ 0 and openCount ~= closeCount then\n      result = false\n    end\n  end\n \
    \ return result\nend", "  -- base case\n  if #lst == 0 then\n    return 'Yes'\n\
    \  end", "    local stack = {}\n    local open = 1\n    for i = 1, #lst do\n \
    \       local c = lst[i]\n        if c == \"(\" then\n            stack[#stack\
    \ + 1] = c\n            open = open + 1\n        elseif c == \")\" then\n    \
    \        if open == 0 then\n                return \"No\"\n            end\n \
    \           open = open - 1\n            if open == 0 then\n                local\
    \ s = stack[#stack + 1]\n                stack[#stack + 1] = \"(\" .. s .. \"\
    )\"\n                return \"Yes\"\n            end\n        end\n    end\nend",
  "  local good = 'Yes'\n  local i = 2\n  while i < #lst do\n    if lst[i] ~= '('\
    \ and lst[i] ~= ')' then\n      return good\n    end\n    if lst[i] == '(' then\n\
    \      good = good == 'Yes' and 'No' or 'Yes'\n    end\n    i = i + 1\n  end\n\
    \  return good\nend", "  assert(#lst == 2, 'The given list should have exactly\
    \ two elements.')\n  local left = lst[1]\n  local right = lst[2]\n  if parens_balance(left)\
    \ ~= 0 or parens_balance(right) ~= 0 then\n    return 'Yes'\n  else\n    return\
    \ 'No'\n  end\nend", "  -- Base case\n  if #lst == 1 then return true end", " \
    \  local i = 0\n   local j = 1\n   while i < #lst and j > 0 do\n      if lst[i]\
    \ == '(' then i = i + 1 else j = (j - 1)\n      if lst[i] == ')' then i = i +\
    \ 1 else j = j + 1\n   end\n   return j > 0\nend", "   for i = 1, #lst do\n  \
    \    if not (lst[i] == '(' or lst[i] == ')') then\n         return false\n   \
    \   end\n   end\n   return true\nend", "  return match_parens_helper(lst, '()')\n\
    end", "  local stack = {}\n  for i = 1, #lst do\n    if lst[i] == '(' and stack[#stack\
    \ + 1] ~= '(' then\n      stack[#stack + 1] = lst[i]\n    end\n    if lst[i] ==\
    \ ')' and stack[#stack + 1] == '(' then\n      stack[#stack + 1] = nil\n    end\n\
    \  end\n  if #stack > 1 then\n    return 'No'\n  end\n  for i = 1, #lst do\n \
    \   if stack[#stack] == nil then\n      return 'No'\n    end\n    if lst[i] ==\
    \ '(' or lst[i] == ')' then\n      stack[#stack] = lst[i]\n    end\n  end\n  local\
    \ last_i = 1\n  for i = 1, #stack do\n    if stack[i] == nil and lst[last_i] ==\
    \ '(' then\n      return 'No'\n    end\n    last_i = i\n  end\n  if lst[last_i]\
    \ ~= ')' then\n    return 'No'\n  end\n  return 'Yes'\nend", "    local stack\
    \ = {}\n    local result = false\n    local size = #lst\n    for i=1, size do\n\
    \        if lst[i] == '(' or lst[i] == ')' then\n            stack[#stack + 1]\
    \ = lst[i]\n        elseif stack[#stack] == nil then\n            result = result\
    \ or true\n        end\n    end\n    return result\nend", "  local open = { {open=true,\
    \ close=false}, {} }\n  local close = { {open=false, close=true}, {} }\n  local\
    \ open2 = {{}, {}}\n  local close2 = {{}, {}}\n  for _, v in ipairs(lst) do\n\
    \    local _, _, open2, close2 = match_parens_aux(v, open, close)\n    if open2\
    \ == 0 then\n      return false\n    end\n    if close2 == 0 then\n      return\
    \ false\n    end\n    open = open2\n    close = close2\n  end\n  return true\n\
    end", "  -- base case\n  if #lst ~= 2 then return 'No' end\n  \n  -- check all\
    \ combinations\n  for i = 1, #lst - 1 do\n    for j = i + 1, #lst do\n      if\
    \ lst[i] ~= lst[j] then\n        -- do some parens matching\n        if match_parens(lst[i])\
    \ == match_parens(lst[j]) then return 'Yes' end\n      end\n    end\n  end\n \
    \ \n  return 'No'\nend", "  local result = false\n  \n  -- start from last element\
    \ since we want to make sure all brackets are balanced.\n  for i = #lst - 1, 1,\
    \ -1 do\n    local open = lst[i]\n    if open == '(' and result ~= true then\n\
    \      result = true\n    end\n    if open == ')' and result ~= false then\n \
    \     result = false\n    end\n  end", "    local i, n = 1, #lst\n    while i\
    \ < n do\n        local s = lst[i]\n        local ok = s == '('\n        i = i\
    \ + 1\n        while i < n and lst[i] == ')' do\n            i = i + 1\n     \
    \   end\n        if ok and (s == '(' or i == n) then\n            i = i + 1\n\
    \        end\n        if not ok then\n            return 'No'\n        end\n \
    \   end\n    return 'Yes'\nend", "\tassert(#lst==2)\n\tlocal open_brackets = 0,\
    \ open_brackets\n\tlocal close_brackets = 0, close_brackets\n\tlocal index = 1\n\
    \tlocal res = 'No'\n\tlocal function open_brackets_increment()\n\t\tassert(open_brackets<#lst)\n\
    \t\topen_brackets = open_brackets + 1\n\tend\n\tlocal function close_brackets_increment()\n\
    \t\tassert(close_brackets<#lst)\n\t\tclose_brackets = close_brackets + 1\n\tend\n\
    \twhile index<=#lst do\n\t\tassert(lst[index]=='(' or lst[index]==')')\n\t\tif\
    \ lst[index]=='(' then\n\t\t\topen_brackets_increment()\n\t\telseif lst[index]==')'\
    \ then\n\t\t\tclose_brackets_increment()\n\t\telse\n\t\t\tif open_brackets==close_brackets\
    \ then\n\t\t\t\tif index-close_brackets==1 then\n\t\t\t\t\tres = res .. ')'\n\t\
    \t\t\telse\n\t\t\t\t\tres = res .. ('))')\n\t\t\t\tend\n\t\t\t\tclose_brackets\
    \ = close_brackets + 1\n\t\t\tend\n\t\t\tif open_brackets>close_brackets then\n\
    \t\t\t\tres = res .. (')')\n\t\t\tend\n\t\t\tif open_brackets<close_brackets then\n\
    \t\t\t\tres = res .. ('(')\n\t\t\tend\n\t\t\topen_brackets = open_brackets - close_brackets\n\
    \t\t\tclose_brackets = open_brackets\n\t\tend\n\t\tindex = index + 1\n\tend\n\t\
    return res\nend", "    local stack = {}\n    for i = 1, #lst do\n        local\
    \ c = lst[i]\n        if c == '(' then\n            stack[#stack + 1] = c\n  \
    \      elseif c == ')' then\n            local top = stack[#stack + 1]\n     \
    \       if top ~= '(' and not ((top == '(' and c == ')') or top == '(' and c ==\
    \ '(')) then\n                return 'No'\n            end\n            stack[#stack]\
    \ = nil\n        else\n            stack[#stack + 1] = c\n        end\n    end\n\
    \    if #stack > 1 then\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend", "  local open_bracket_count = 0\n  local close_bracket_count =\
    \ 0\n  for _, v in ipairs(lst) do\n    if v == '(' then\n      open_bracket_count\
    \ = open_bracket_count + 1\n    elseif v == ')' then\n      close_bracket_count\
    \ = close_bracket_count + 1\n      if open_bracket_count == close_bracket_count\
    \ then\n        return 'Yes'\n      end\n    end\n  end\n  return 'No'\nend",
  "\tlocal open_bracket = 0\n\tlocal close_bracket = 0\n\tfor _,x in ipairs(lst) do\n\
    \t\tif x == '(' and open_bracket == 0 then\n\t\t\topen_bracket = open_bracket\
    \ + 1\n\t\telseif x == ')' and open_bracket > 0 then\n\t\t\topen_bracket = open_bracket\
    \ - 1\n\t\telseif x == '(' and open_bracket == 0 then\n\t\t\tclose_bracket = close_bracket\
    \ + 1\n\t\telseif x == '}' and close_bracket > 0 then\n\t\t\tclose_bracket = close_bracket\
    \ - 1\n\t\tend\n\tend", "\t-- A string is good if and only if all parentheses\
    \ in it are balanced.\n\t-- A string is good if and only if:\n\t-- 1) All parentheses\
    \ in it are balanced.\n\t-- 2) All parentheses pairs in it are balanced.\n\t--\
    \ An empty string is also good.\n\t-- The function assumes no parentheses can\
    \ be nested inside other\n\t-- parentheses.\n\tlocal open = 0\n\tlocal close =\
    \ 0\n\tlocal result = 'No'\n\tlocal function count()\n\t\tif open == close then\n\
    \t\t\t-- We reach the end.\n\t\t\t-- If open is not equal to close, then no parentheses\
    \ can be nested.\n\t\t\t-- If open is equal to close, then all parentheses can\
    \ be nested.\n\t\t\t-- Either way, we return 'Yes'.\n\t\t\t-- If open is greater\
    \ than close, then we cannot do anything.\n\t\t\t-- Therefore, return 'No'.\n\t\
    \t\treturn 'No'\n\t\tend\n\t\t-- If open is greater than close, then we can do\
    \ something.\n\t\t-- Therefore, we know we can concatenate open open parentheses\
    \ inside close\n\t\t-- close parentheses.\n\t\t-- Therefore, we can concatenate\
    \ open open parentheses inside open close\n\t\t-- parentheses.\n\t\t-- Therefore,\
    \ we can concatenate close close parentheses inside close\n\t\t-- parentheses.\n\
    \t\t-- Therefore, we can concatenate close open parentheses inside open close\n\
    \t\t-- parentheses.\n\t\t-- Therefore, we can concatenate open open parentheses\
    \ inside close close\n\t\t-- parentheses.\n\t\treturn 'Yes'\n\tend\n\t-- Iterate\
    \ through the list.\n\tfor i, paren in ipairs(lst) do\n\t\t-- If this element\
    \ is an open paren, increase count.\n\t\tif paren == '(' then\n\t\t\topen = open\
    \ + 1\n\t\telseif paren == ')' then\n\t\t\t-- If the count is greater than 0,\
    \ then no parentheses can be nested.\n\t\t\t-- Otherwise, we can concatenate this\
    \ open paren inside another open paren.\n\t\t\t-- Therefore, we can concatenate\
    \ this open paren inside another open paren.\n\t\t\tif open > 0 then\n\t\t\t\t\
    result = count\n\t\t\tend\n\t\telseif paren == nil then\n\t\t\t-- If it is nil,\
    \ then the parentheses has been closed and we can\n\t\t\t-- concatenate another\
    \ open paren inside the closed parentheses.\n\t\t\t-- Therefore, we can concatenate\
    \ this open paren inside another open paren.\n\t\t\tif open > close then\n\t\t\
    \t\tresult = count\n\t\t\tend\n\t\telseif paren == '(' then\n\t\t\t-- If the current\
    \ element is another open paren, then decrease count.\n\t\t\t-- ", "  local open\
    \ = 0\n  local close = 0\n  for _, str in ipairs(lst) do\n    local c = str:byte()\n\
    \    if c == open * '(' or c == close * ')' then\n      open = open + 1\n    else\n\
    \      close = close + 1\n    end\n  end\n  return open == close and open == #lst\n\
    end", "  -- Base case\n  if #lst == 0 then return 'No'\n  end", "    -- The second\
    \ character in lst is the opening parenthesis ')', we add 1 to\n    -- it to get\
    \ the closing parenthesis ')'.\n    local open = lst[2] + 1\n    -- Loop through\
    \ the list from the third character on, adding 1 to\n    -- each character until\
    \ the parenthesis is balanced.\n    for i = l[3] do\n        if lst[i] == open\
    \ then\n            open = open + 1\n        else\n            open = open - 1\n\
    \            if open <= 0 then\n                return 'Yes'\n            end\n\
    \        end\n    end\n    return 'No'\nend", "  local open = 0\n  local close\
    \ = 0\n  local len = 0\n  for i, str in ipairs(lst) do\n    if str:sub(1, 1) ==\
    \ \"(\" then\n      open = open + 1\n      len = len + 1\n    elseif str:sub(-1)\
    \ == \")\" then\n      close = close + 1\n      len = len - 1\n    end\n  end\n\
    \  if len == open then return \"Yes\" else return \"No\" end\nend", "  local open\
    \ = 1\n  local close = 0\n  local cur", "  local stack = {}\n  local result =\
    \ {}\n  for i = 1, #lst do\n    stack[i] = lst[i]\n    if stack[i] == '(' then\n\
    \      stack[#stack + 1] = ')'\n    elseif stack[i] == '[' then\n      stack[#stack\
    \ + 1] = ']'\n    elseif stack[i] == '{' then\n      stack[#stack + 1] = '}'\n\
    \    else\n      result[#result + 1] = '('\n    end\n  end\n  for i = #result\
    \ - 1, 1, -1 do\n    if stack[i] == '(' then\n      if stack[i-1] == ')' then\n\
    \        stack[#stack + 1] = ')'\n      else\n        stack[#stack + 1] = '('\n\
    \      end\n    elseif stack[i] == '[' then\n      if stack[i-1] == ']' then\n\
    \        stack[#stack + 1] = ']'\n      else\n        stack[#stack + 1] = '['\n\
    \      end\n    elseif stack[i] == '{' then\n      if stack[i-1] == '}' then\n\
    \        stack[#stack + 1] = '}'\n      else\n        stack[#stack + 1] = '{'\n\
    \      end\n    end\n  end\n  if stack[#stack + 1] == ')' then\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend", "   if #lst == 0 then\n      return 'No'\n\
    \   end\n   local first_open = lst[1] == '('\n   local last_close = lst[#lst]\
    \ == ')'\n   if first_open and last_close then\n      return match_parens(lst:sub(2))\
    \ == 'Yes'\n   elseif first_open and not last_close then\n      return match_parens(lst:sub(1))\
    \ == 'Yes'\n   elseif not first_open and last_close then\n      return match_parens(lst:sub(1,1))\
    \ == 'Yes'\n   else\n      return nil\n   end\nend", "  local n = #lst\n  for\
    \ i = 1, n do\n    local open = 1\n    for j = 1, #lst do\n      if lst[j] ==\
    \ ')' then\n        open = open - 1\n      elseif lst[j] ~= '(' and open > 0 then\n\
    \        return 'No'\n      end\n    end\n  end\n  return 'Yes'\nend", "  local\
    \ s = lst[1]\n  local p = open_paren(lst)\n  if p then\n    if open_bracket(lst)\
    \ == -1 then\n      if close_bracket(lst) == -1 then\n        -- check if s is\
    \ balanced\n        if s == close_bracket(lst) and is_balanced(s) then\n     \
    \     return true\n        else\n          return false\n        end\n      else\n\
    \        return false\n      end\n    else\n      return false\n    end\n  else\n\
    \    return false\n  end\nend", "    local i = 0\n    local count = 0\n    while\
    \ i < #lst do\n        count = count + 1\n        if lst[i] == \"(\" then\n  \
    \          count = count - 1\n            i = i + 1\n        elseif lst[i] ==\
    \ \")\" then\n            count = count + 1\n            i = i + 1\n        elseif\
    \ count < 0 then\n            return true\n        end\n    end\n    return false\n\
    end", "    assert(#lst == 2)\n    assert(string.sub(lst[1], \"()\") ~= string.sub(lst[1],\
    \ \"()\"))\n    local is_good = true\n    local stack = {}\n    stack:insert(lst[1])\n\
    \    for i = 1, #lst do\n        if string.sub(lst[i], \"()\") ~= string.sub(lst[i\
    \ + 1], \"()\") then\n            is_good = false\n            break\n       \
    \ end\n        stack:insert(lst[i])\n    end\n    return is_good\nend", "  --\
    \ Base case.\n  if #lst == 0 then\n    return 'No'\n  end", "    local open =\
    \ '()'\n    local close = '()'\n    local balance = 0\n    for idx, s in ipairs(lst)\
    \ do\n        local open_count = s:count(open)\n        local close_count = s:count(close)\n\
    \        if open_count ~= close_count then\n            return false\n       \
    \ end\n        if open_count > balance then\n            return false\n      \
    \  end\n        balance = open_count\n    end\n    return true\nend", "  local\
    \ cur = lst[1]\n  local count = 0\n  while cur do\n    if count>0 then\n     \
    \ if cur ~= '(' and cur~= ')' then\n        return 'No'\n      elseif cur == '('\
    \ then\n        count = count + 1\n      elseif cur == ')' then\n        count\
    \ = count - 1\n      end\n    end\n    cur = lst[#lst]\n  end\n  return 'Yes'\n\
    end", "  local open_brackets, close_brackets = 0, 0\n  for i = 1, #lst do\n  \
    \  if lst[i] == '(' then\n      open_brackets = open_brackets + 1\n    elseif\
    \ lst[i] == ')' then\n      close_brackets = close_brackets + 1\n    end\n  end\n\
    \  if open_brackets - close_brackets == #lst then\n    return 'Yes'\n  else\n\
    \    return 'No'\n  end\nend", "  if #lst == 2 then\n    if lst[1] == '(' and\
    \ lst[2] == ')' then\n      return 'Yes'\n    else\n      return 'No'\n    end\n\
    \  else\n    return 'No'\n  end\nend", "  -- if lst[1] and lst[2] are both open\
    \ and close parens\n  -- or if lst[1] and lst[2] are both close and open parens\n\
    \  -- or if lst[0] and lst[1] are both open and close parens\n  -- or if lst[0]\
    \ and lst[1] are both close and open parens\n  -- then return 'Yes'\n  if lst[1]\
    \ and lst[2] and\n    (lst[2] == '(' and lst[1] == '(' and lst[0] == '(') or\n\
    \    (lst[2] == ')' and lst[1] == ')' and lst[0] == ')') then\n    return 'Yes'\n\
    \  end\n  return 'No'\nend", "  local stack = {}\n  for i = 1, #lst do\n    if\
    \ lst[i] == '(' then\n      stack[#stack + 1] = i\n    elseif lst[i] == ')' then\n\
    \      if #stack == 0 then\n        return 'No'\n      else\n        local top\
    \ = stack[#stack + 1]\n        stack[#stack + 1] = nil\n        return top >=\
    \ i and lst[top] == ')'\n      end\n    end\n  end\n  return stack[#stack] ==\
    \ nil\nend", "    local stack = {}\n    local stack_index = 1\n    for _, value\
    \ in pairs(lst) do\n        if value[1] == '(' or value[1] == ')' then\n     \
    \       if stack[stack_index] == value[1] then\n                stack[stack_index]\
    \ = value\n                stack_index = (stack_index - 1)\n            else\n\
    \                return 'No'\n            end\n        else\n            stack_index\
    \ = (stack_index + 1)\n        end\n    end\n    return 'Yes'\nend", "  if #lst\
    \ ~= 2 then return 'No' end\n  local open = lst[1]\n  local close = lst[2]\n \
    \ local s = open:len()\n  local t = close:len()\n  local result\n  if s:len()\
    \ > t:len() then\n    result = 'No'\n  elseif s:len() < t:len() then\n    result\
    \ = 'Yes'\n  else\n    local sx = s:byte()\n    local tx = t:byte()\n    if sx\
    \ ~= tx then return 'No' end\n    if sx ~= '(' then return 'No' end\n    result\
    \ = open:len() + close:len()\n  end\n  return result\nend", "  local open_balance,\
    \ close_balance = 1, 0 -- count opening and closing parens\n  local open_balance2,\
    \ close_balance2 = 0, 1 -- count opening and closing parens 2\n  local open_balance3,\
    \ close_balance3 = 0, 0 -- count opening and closing parens 3\n  local open_count\
    \ = 0 -- count opening parens\n  local close_count = nil -- count closing parens",
  "    local stack = {}\n    for i, e in ipairs(lst) do\n        if e == '(' then\
    \ stack[#stack+1] = e end\n        if e == ')' then\n            if not stack[#stack]\
    \ then\n                return 'No'\n            end\n            stack[#stack]\
    \ = nil\n        end\n    end\n    if #stack > 0 then\n        return 'No'\n \
    \   elseif #stack == 1 then\n        return 'Yes'\n    end\nend", "  if #lst >\
    \ 1 then\n    local l1, l2 = unpack(lst)\n    if l1 == l2 then\n      return match_parens(lst)\n\
    \    end\n  else\n    if lst[1] == ')' then\n      return true\n    end\n    if\
    \ lst[1] == '(' then\n      local ok = match_parens(lst[#lst])\n      if ok then\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  -- If\
    \ there are no parentheses in the list, return 'No'.\n  if not lst then return\
    \ 'No' end\n  -- If there's only one parentheses in the list, return 'No'.\n \
    \ if #lst == 1 then return 'No' end\n  -- Find out how many open parentheses there\
    \ are.\n  local num_open = 0\n  for _, str in ipairs(lst) do\n    if str == '('\
    \ then num_open = num_open + 1 end\n    if str == ')' then num_open = num_open\
    \ - 1 end\n  end\n  -- If the number of open parentheses is less than zero, return\
    \ 'No'.\n  if num_open < 0 then return 'No' end\n  -- Otherwise, check to see\
    \ if the parentheses are balanced.\n  local ok = true\n  for _, str in ipairs(lst)\
    \ do\n    if str == '(' and not ok and num_open > 0 then\n      ok = false\n \
    \   end\n    if str == ')' and not ok and num_open < 0 then\n      ok = false\n\
    \    end\n  end\n  if ok then return 'Yes' else 'No' end\nend", "    local str1\
    \ = lst[1]\n    local str2 = lst[2]\n    local depth = 0\n    for i = 1, #str1,\
    \ 1 do\n        if str1[i] ~= '(' and str1[i] ~= ')' then\n            return\
    \ false\n        end\n        if str1[i] == '(' then\n            depth = depth\
    \ + 1\n            if depth > #str2 then\n                return false\n     \
    \       end\n        end\n        if str1[i] == ')' then\n            depth =\
    \ depth - 1\n            if depth > #str2 then\n                return false\n\
    \            end\n        end\n    end\n    if depth == 0 then\n        return\
    \ true\n    end\n    return false\nend", "    if #lst == 0 then\n        return\
    \ 'No'\n    end\n    if #lst == 1 then\n        return nil\n    end\n    local\
    \ l1 = lst[1]\n    if #l1 ~= 1 then\n        return 'No'\n    end\n    local l2\
    \ = lst[2]\n    if #l2 ~= 1 then\n        return 'No'\n    end\n    if l1[1] ==\
    \ '(' and l2[1] == ')' then\n        return 'Yes'\n    elseif l1[1] == '[' and\
    \ l2[1] == ']' then\n        return 'Yes'\n    elseif l1[1] == '{' and l2[1] ==\
    \ '}' then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend",
  "  local open = 1\n  local close = 1\n  for i = 1, #lst do\n    local c = lst[i]\n\
    \    open = open and (type(c) == 'string' and c == '(')\n    close = close and\
    \ (type(c) == 'string' and c == ')')\n    if not (open or close) then return false\
    \ end\n  end\n  return true\nend", "    local open = 0\n    local close = 0\n\
    \    local res = true", "   if #lst > 1 then\n      if lst[1] == \"(\" then\n\
    \         if lst[2] == \")\" then\n            return match_parens(lst)\n    \
    \     elseif lst[2] == \"(\" then\n            return match_parens(lst)\n    \
    \     end\n      end\n      if lst[2] == \"(\" then\n         if lst[1] == \"\
    )\" then\n            return match_parens(lst)\n         elseif lst[1] == \")\"\
    \ then\n            return match_parens(lst)\n         end\n      end\n   end\n\
    \   return \"Yes\"\nend", "    local n = #lst\n    if n == 1 then\n        return\
    \ lst[1] == \"\"\n    end", "    -- base case\n    if #lst == 2 then\n       \
    \ return lst[1] == lst[2]\n    end", "    local count = 1\n    local result =\
    \ false\n    for i = 1, #lst do\n        if lst[i] == '(' and count == 1 then\n\
    \            count = count + 1\n            if #lst > i + 1 and lst[i + 1] ==\
    \ ')' then\n                count = count + 1\n            else\n            \
    \    result = true\n            end\n        elseif lst[i] == ')' and count ==\
    \ 1 then\n            count = count - 1\n        else\n            result = false\n\
    \        end\n    end\n    return result\nend", "  local stack = {}\n  local open\
    \ = 0", "  local res = \"Yes\"\n  for _, value in ipairs(lst) do\n    if value\
    \ == \"(\" then res = \"No\" end\n  end \n  return res\nend", "   local n = 1\n\
    \   local total = 0\n   for i = 1, #lst do\n      local j = i - n\n      if lst[i]\
    \ == \"(\" then\n         total = total + 1\n         n = n + 1\n      elseif\
    \ lst[i] == \")\" and total > 1 then\n         total = total - 1\n         n =\
    \ n - 1\n      elseif lst[i] == \")\" and total = 0 then\n         return \"No\"\
    \n      elseif lst[i] == \"(\" and total < 1 then\n         return \"No\"\n  \
    \    else\n         return \"Yes\"\n      end\n   end\nend", "   -- Base case\n\
    \   if #lst ~= 2 then\n      return false\n   end\n   if type(lst[1]) == 'table'\
    \ then\n      -- If the second element is not a string, return false\n      if\
    \ type(lst[2]) ~= 'string' then\n         return false\n      end\n      -- Otherwise,\
    \ check if the concatenation of the first two elements is good\n      return match_parens(lst[1])\
    \ or match_parens(lst[2])\n   end\n   -- If the second element is not a string,\
    \ return false\n   if type(lst[2]) ~= 'string' then\n      return false\n   end\n\
    \   -- Otherwise, check if the concatenation of these two elements is good\n \
    \  return (lst[1] .. lst[2]) == lst[2] or\n          (lst[1] .. lst[2]) == lst[1]\
    \ or\n          (lst[2] .. lst[1]) == lst[1] or\n          (lst[2] .. lst[1])\
    \ == lst[2]\nend", "  local open = 1\n  local close = 1\n  local count = 0\n \
    \ local good = 1\n  local goods = { { open, close } }", "  local open = { { ')',\
    \ ')(' }, { ')', '(' }  }\n  local close = { { ')', ')(' }, { ')', '(' } }\n \
    \ local closed = false\n  local opened = false\n  local result = 'No'\n  for i\
    \ = 1, #lst do\n    if lst[i] ~= close[closed and #closed or 0] then\n      closed\
    \ = false\n    else\n      closed = true\n      opened = true\n    end\n    local\
    \ last = open[opened and #open or 0]\n    local c = lst[i]\n    local p = last[#last\
    \ and #last-1 or 0]\n    if last[c] ~= c then\n      opened = false\n      open[opened\
    \ and #open or 0]\n      close[closed+1 and #close or 0]\n    end\n    if opened\
    \ then\n      open[opened and #open or 0]\n      last[#last and #last-1 or 0]\
    \ = c\n    elseif closed and c == '(' then\n      opened = true\n    end\n   \
    \ local lc = last and last[#last and #last-1 or 0]\n    if lc ~= c then\n    \
    \  result = 'No'\n      break\n    end\n  end\n  return result\nend", "  local\
    \ n = #lst\n  for i = 1, n do\n    if lst[i] ~= '(' or lst[i] ~= ')' then\n  \
    \    return false\n    end\n  end\n  return not (#lst < 2)\nend", "  -- Check\
    \ for balanced parentheses.\n  -- The algorithm is basically:\n  --  1) Create\
    \ a stack of closing parentheses.\n  --  2) Iterate over all elements in lst.\n\
    \  --  3) For each element in lst, apply the following rules:\n  --  3a) If an\
    \ element is an opening parentheses, add 1 to stack.\n  --  3b) If an element\
    \ is a closing parentheses, remove 1 from stack.\n  --  3) At the end, if the\
    \ stack is empty, the parentheses are balanced.\n  local open_brackets = {}\n\
    \  for i = 1, #lst do\n    if lst[i] == '(' or lst[i] == '[' then\n      if #open_brackets\
    \ ~= 0 then\n        open_brackets[#open_brackets+1] = i\n      else\n       \
    \ open_brackets[1] = i\n      end\n    elseif lst[i] == ')' or lst[i] == ']' then\n\
    \      if #open_brackets > 1 then\n        -- (2a) Remove one from stack if there's\
    \ an opening parentheses.\n        -- (3b) If stack is empty, parentheses are\
    \ not balanced.\n        if open_brackets[#open_brackets] ~= 0 then\n        \
    \  open_brackets[#open_brackets] = open_brackets[#open_brackets] - 1\n       \
    \ else\n          open_brackets[#open_brackets] = 0\n        end\n      else\n\
    \        -- (2a) Remove one from stack if there's an opening parentheses.\n  \
    \      -- (2b) If stack is empty, parentheses are not balanced.\n        open_brackets[#open_brackets+1]\
    \ = open_brackets[#open_brackets+1] - 1\n      end\n    else\n      return false\n\
    \    end\n  end\n  return #open_brackets == 0\nend", "  local index = 1\n  local\
    \ index2 = 0\n  while index <= #lst and index2 <= #lst do\n    if lst[index] ==\
    \ '(' and lst[index2] == ')' then\n      if index2 < index + 1 then\n        lst[index]\
    \ = lst[index + 1]\n      end\n      index = index + 1\n      index2 = index2\
    \ + 1\n    end\n    index = index + 1\n    index2 = index2 + 1\n  end\n  return\
    \ index2 == #lst\nend", "  assert(#lst == 2, 'Error: it should have two strings\
    \ only.')\n  for i = 1, #lst do\n    if i == #lst - 1 then\n      if lst[i] ==\
    \ lst[i + 1] then\n        return 'Yes'\n      else\n        return 'No'\n   \
    \   end\n    end\n  end\nend", "  local open = 0, 0\n  local closed = {}\n  for\
    \ i = 1, #lst do\n    if lst[i] == '(' then\n      open = open + 1\n      table.insert(closed,\
    \ open)\n    elseif lst[i] == ')' then\n      open = open - 1\n      if open ==\
    \ 0 then\n        return true\n      end\n      table.insert(closed, open)\n \
    \   end\n  end\n  return false\nend", "    local good = false\n    local index\
    \ = 1\n    local len = #lst\n    while true do\n        local open = lst[index]\n\
    \        local close = lst[index + 1]\n        if close == '()' then\n       \
    \     index = index + 1\n        elseif open == '()' then\n            good =\
    \ false\n        else\n            if close ~= open then\n                good\
    \ = false\n            elseif index >= len or lst[index] ~= open then\n      \
    \          good = false\n            else\n                good = true\n     \
    \       end\n        end\n        index = index + 1\n    end\n    return good\n\
    end", "  local opens, closes = table.unpack(lst)\n  local nopens = #opens\n  if\
    \ nopens == 1 then\n    return nopens == closes and opens[0] == closes[1] and\
    \ opens[1] == closes[2] and opens[2] ~= '(' and opens[2] ~= ')'\n  else\n    local\
    \ ncloses = #closes\n    local ncloses_pairs = #(closes)/2\n    local ncloses_pairs_ncloses\
    \ = ncloses_pairs + 1\n    local ncloses_pairs_nopens = ncloses_pairs + nopens\n\
    \    local good = ncloses == ncloses_pairs and ncloses_pairs_ncloses == ncloses_pairs_nopens\n\
    \    return good\n  end\nend", "  -- Base case: If the list only has one element,\
    \ return that.\n  if #lst == 1 then return lst[1] end\n  -- Base case: If the\
    \ list has only one element, return that element.\n  if #lst == 2 then return\
    \ lst[2] end\n  -- Recursion step: If the list has more than one element, find\
    \ the leftmost\n  -- element that doesn't have closing parentheses and recurse\
    \ on that element.\n  local left, right = unpack(lst)\n  local left_left = match_parens(lst[1])\n\
    \  if left_left == 'Yes' then\n    return match_parens([left_left, right])\n \
    \ elseif left_left == 'No' then\n    return 'No'\n  else\n    -- Recursion step:\
    \ Find the rightmost element that doesn't have opening\n    -- parentheses and\
    \ recurse on that element.\n    local right_right = match_parens(lst[2])\n   \
    \ if right_right == 'Yes' then\n      return match_parens([left, right_right])\n\
    \    elseif right_right == 'No' then\n      return 'No'\n    else\n      return\
    \ 'No'\n    end\n  end\nend", "  local stack = {}\n  for i = 1, #lst do\n    local\
    \ open = string.sub(lst, i, i)\n    if open == \"(\" then\n      table.insert(stack,\
    \ open)\n    elseif open == \")\" then\n      if not stack[#stack] then\n    \
    \    return 'No'\n      else\n        stack[#stack] = nil\n      end\n    end\n\
    \  end", "  if #lst == 2 then\n    return false\n  end", "  local open = 0\n \
    \ local close = 0\n  for i = 1, #lst do\n    if lst[i] == '(' then\n      open\
    \ = open + 1\n    elseif lst[i] == ')' then\n      close = close + 1\n    end\n\
    \  end", "  local n = #lst\n  local res = true\n  for i = 1, n do\n    local left\
    \ = lst[i]\n    local right = lst[i + 1]\n    if left == '(' and right == ')'\
    \ then\n      local c = n\n      while c > 1 and lst[c - 1] == '(' and lst[c -\
    \ 2] == ')' do\n        c = c - 1\n      end\n      if c == n then -- All parentheses\
    \ are balanced.\n        lst[i] = ''\n      else\n        res = false\n      end\n\
    \    end\n  end\n  return res\nend", "  local open = 0\n  local close = 0\n  for\
    \ i = 1, #lst do\n    if lst[i] == \"(\" then\n      open += 1\n    elseif lst[i]\
    \ == \")\" then\n      close += 1\n    end\n  end", "  local open = 0\n  local\
    \ close = 0\n  local good = 1\n  for _, x in ipairs(lst) do\n    if x == '(' then\n\
    \      open = open + 1\n    elseif x == ')' then\n      close = close + 1\n  \
    \  end\n  end\n  if open ~= close then\n    good = 0\n  end\n  return good\nend",
  "  local result = {}\n  for i=1,#lst do\n    local current = lst[i]\n    if current\
    \ ~= ')' then\n      if #result > 0 and result[#result-1] == '(' then\n      \
    \  result[#result-1] = current\n      else\n        result[#result+1] = current\n\
    \      end\n    elseif #result == 0 then\n      result[#result+1] = '('\n    end\n\
    \  end\n  return #result == #lst\nend", "  if #lst < 2 then\n    return false\n\
    \  elseif #lst > 2 then\n    return not is_balanced(lst[1], lst[2])\n  else\n\
    \    return not is_balanced(lst[1], lst[1])\n  end\nend", "  local n = #lst\n\
    \  for i = 1, n do\n    local open = (lst[i] == '(')\n    local close = (lst[i]\
    \ == '(')\n    local openCount = 1\n    local closeCount = 0\n    for j = 1, n\
    \ do\n      if lst[j] == close then\n        closeCount = closeCount + 1\n   \
    \   elseif lst[j] == open then\n        openCount = openCount + 1\n      else\n\
    \        break -- The rest of the string is fine.\n      end\n    end\n    if\
    \ openCount ~= closeCount then\n      return false\n    end\n  end\n  return true\n\
    end", "  local open = 0\n  local close = 0\n  local opening = 0\n  local closing\
    \ = 0\n  local i = 0\n  local len = #lst\n  while i < len do\n    if lst[i] ==\
    \ '('\n    then\n      opening = opening + 1\n    end\n    if lst[i] == ')'\n\
    \    then\n      closing = closing + 1\n    end\n    if opening == closing then\n\
    \      if opening == 0 then\n        return false\n      else\n        opening\
    \ = opening - 1\n        closing = closing - 1\n        close = open - 1\n   \
    \     open = 0\n      end\n    end\n    i = i + 1\n  end\n  if opening == 0 then\n\
    \    return false\n  end\n  return true\nend", "  local open = 0\n  local close\
    \ = 0\n  local i = 0\n  while i < #lst do\n    if open == 0 and close == 1 then\
    \ return true end\n    if open > 0 then\n      if lst[i] == '(' and close == 0\
    \ then open = open - 1 end\n      if lst[i] == ')' and open == 1 then close =\
    \ close - 1 end\n    end\n    i = i + 1\n  end\n  if open > 0 and close > 0 then\
    \ return false else return true end\nend", "  local open = { }\n  local close\
    \ = { }\n  local is_open = { }\n  local result = 'No'\n  for i = 1, #lst do\n\
    \    if lst[i] == '(' and not open[#open+1] then\n      open[#open+1] = i + 1\n\
    \      is_open[#is_open+1] = i\n    elseif lst[i] == ')' and not close[#close+1]\
    \ then\n      close[#close+1] = i + 1\n      local open_index = #open - 1\n  \
    \    for j = #is_open, 1, -1 do\n        if is_open[j] == open_index then\n  \
    \        local open_index = open_index - 1\n          -- This means one more closing\
    \ parenthesis is open, so the string\n          -- cannot be a good string\n \
    \         -- Example: '(()()())' -> '(()()())' can't be good\n          if open_index\
    \ == 0 then\n            result = 'No'\n            break\n          end\n   \
    \       -- This means the string is not a good string\n          -- Example: '(()())'\
    \ -> '()()' can be good\n          -- Example: '()(())' -> '()()' can be good\n\
    \          -- Example: '(()(()))' -> '()(())' can be good\n          -- Example:\
    \ '(()()())' -> '(()()())' can't be good\n          -- Example: '(()())' -> '(()())'\
    \ can't be good\n          -- Example: '()(()())' -> '()(()())' can't be good\n\
    \          -- Example: '(()())' -> '(()())' can't be good\n          -- Example:\
    \ '()(()())' -> '()(()())' can't be good\n          -- Example: '()()()' -> '()()()'\
    \ can be good\n          -- Example: '()()' -> '()()' can be good\n          --\
    \ Example: '()' -> '()' can be good\n          -- Example: '()' -> '()' can't\
    \ be good\n          -- Example: '()' -> '()' can't be good\n          -- Example:\
    \ '()()' -> '()()' can be good\n          -- Example: '(()(()))' -> '(()(()))'\
    \ can be good\n          -- Example: '(()(()))' -> '(()(()))' can't be good\n\
    \          -- Example: '(()(()()))' -> '(()(()()))' can be good\n          --\
    \ Example: '(()(()()))' -> '(()(()()))' can't be good\n          -- Example: '(()(()()))'\
    \ -> '(()(()()))' can't be good\n          -- Example: '(()(", "  local open =\
    \ lst[1]\n  local close = lst[2]\n  local stack = {}\n  for i = 1, #lst do\n \
    \   if open:sub(1, i) == close:sub(1, i) then\n      table.insert(stack, open:sub(1,\
    \ i))\n    elseif open:sub(1, i) == '(' and close:sub(1, i) == ')' then\n    \
    \  table.insert(stack, open:sub(1, i))\n    elseif open:sub(1, i) == '(' and close:sub(1,\
    \ i) == ')' then\n      table.insert(stack, close:sub(1, i))\n    end\n  end\n\
    \  return #stack == 0 and 'No' or 'Yes'\nend", "  -- Base case: if the list is\
    \ empty, return true.\n  if #lst == 0 then return true end", "  -- We start off\
    \ by assuming none of the parentheses are balanced.\n  local balanced = true\n\
    \  -- We are able to use a single stack to solve this.\n  local stack = {}\n \
    \ -- Go through the string one character at a time and see if there is an\n  --\
    \ opening or closing parenthesis.\n  for i = 1, #lst do\n    local c = lst[i]\n\
    \    if c == '(' or c == '[' then\n      table.insert(stack, c) -- Push on the\
    \ stack so we know if the\n                               -- parentheses are balanced.\n\
    \      balanced = balanced and  -- If balanced, then yes, we can add the\n   \
    \                            -- next character.\n                 stack:len()\
    \ >= 1 and\n                 stack:last() ~= c -- If not balanced, then we can\
    \ not\n                                   -- add the next character.\n    elseif\
    \ c == '[' or c == ']' then\n      balanced = balanced and stack:len() >= 1 and\
    \ stack:last() == c or\n                 balanced and\n                 stack:len()\
    \ >= 2 and\n                 stack:last() ~= '[' and\n                 stack:last()\
    \ ~= c\n    elseif c == ')' then\n      balanced = balanced and stack:len() >=\
    \ 1 and stack:last() == '('\n                 or\n                 balanced and\n\
    \                 stack:len() >= 2 and\n                 stack:last() ~= '(' and\
    \ stack:last() ~= c\n    end\n  end\n  return balanced and stack:len() == 1\n\
    end", "  if #lst == 0 then\n    return 'No'\n  end\n  local i = 1\n  while i <\
    \ #lst do\n    if lst[i] == '(' then\n      i = i + 1\n    elseif lst[i] == ')'\
    \ then\n      i = i + 1\n    else\n      i = i + 1\n    end\n  end\n  return 'Yes'\n\
    end", "  local stack = {}\n  for _, str in ipairs(lst) do\n    local n = 1\n \
    \   for ch in str:gmatch(\"[^()]+\") do\n      stack[#stack + 1] = ch\n      if\
    \ ch == \"(\" then\n        n = n + 1\n      elseif ch == \")\" then\n       \
    \ n = n - 1\n      end\n      if n == 0 then\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "  if #lst <= 1 then\n    return true\n\
    \  end\n  local i = 0\n  local open = 0\n  local close = 0\n  local good = false\n\
    \  for i = 1, #lst do\n    if open == close then\n      good = true\n      break\n\
    \    end\n    local char = lst[i]\n    if char == '(' and close == 0 then\n  \
    \    open = open + 1\n      close = open + 1\n      i = i + 1\n      continue\n\
    \    end\n    if char == ')' and open > close then\n      close = close - 1\n\
    \    else\n      bad(char)\n    end\n    i = i + 1\n  end\n  return good\nend",
  "  assert(#lst, 'The input list is empty')\n  local open = { }\n  local closed =\
    \ { }\n  local stack = {}", "  local stack = {}\n  local result = {}\n  local\
    \ is_good\n  \n  -- Initialize stack and result.\n  for i = 1, #lst do\n    stack[i]\
    \ = lst[i]\n    result[i] = false\n  end", "  if #lst == 0 then\n    return 'No'\n\
    \  else\n    local open = nil\n    local close = nil\n    for i = 1, #lst, 1 do\n\
    \      if lst[i] == \"(\" then\n        open = i\n      elseif lst[i] == \")\"\
    \ then\n        close = i\n      else\n        return false\n      end\n    end\n\
    \    if open ~= nil and close ~= nil then\n      if open < close then\n      \
    \  return 'Yes'\n      else\n        return 'No'\n      end\n    else\n      return\
    \ false\n    end\n  end\nend", "  local open = 1\n  local close = 1\n  local open_list\
    \ = {}\n  for i = 1, #lst do open_list[i] = open end\n  for i = 1, #lst do open\
    \ = open + 1 end\n  for i = 1, #lst do close = close + 1 end\n  while open ~=\
    \ close do\n    if open_list[open] == open_list[close] then\n      open = open\
    \ + 1\n    else\n      local open1 = open_list[open]\n      local close1 = open_list[close\
    \ + 1]\n      local open2 = open_list[open1]\n      local close2 = open_list[close1]\n\
    \      open_list[open] = close1\n      open_list[close + 1] = open2\n      open_list[close]\
    \ = close2\n    end\n  end\n  if #open_list == #lst then\n    return 'Yes'\n \
    \ else\n    return 'No'\n  end\nend", "  local open_brackets = #lst\n  for idx\
    \ = 1, #lst do\n    if open_brackets == 0 then\n      return true\n    elseif\
    \ lst[idx] ~= '(' or open_brackets == 1 then\n      return false\n    end\n  \
    \  open_brackets = open_brackets - 1\n  end\n  return true\nend", "  local stack\
    \ = { lst[1] }\n  local i = 1\n  while i <= #lst do\n    local op = lst[i]\n \
    \   i = i + 1\n    if op == '(' then\n      if stack[#stack] == nil then\n   \
    \     return 'No'\n      end\n      stack[#stack] = nil\n      i = i + 1\n   \
    \ elseif op == ')' then\n      if not stack[#stack] then\n        return 'No'\n\
    \      end\n      stack[#stack] = nil\n      i = i + 1\n    end\n  end", "  local\
    \ stack = {}\n  for i = 1, #lst do\n    if lst[i] == '(' then stack[#stack + 1]\
    \ = true end\n    if lst[i] == ')' then\n      if #stack == 0 then return false\
    \ end\n      stack[#stack] = false\n    end\n  end\n  return #stack == 0\nend",
  "  local s = lst[1]\n  for i = 2, #lst do\n    s = s .. lst[i]\n    if s == '()'\
    \ then\n      return true\n    end\n    if s == '' then\n      return false\n\
    \    end\n  end\nend", "    if #lst <= 1 then\n        return 'No'\n    end\n\
    \    local i = 2\n    local open = 0\n    local close = 0\n    local open_count\
    \ = open_parens[lst[1]]\n    if open_count == nil then\n        open_count = open_parens[lst[1]]\n\
    \    end\n    while i < #lst do\n        if lst[i] == '(' then\n            open\
    \ += 1\n            if open_count < open then\n                open_count = open_parens[lst[i]]\n\
    \            end\n        elseif lst[i] == ')' then\n            if open > 0 then\n\
    \                open -= 1\n            end\n            close += 1\n        \
    \    if close == open then\n                return true\n            end\n   \
    \     end\n        i = i + 1\n    end\n    return false\nend", "   if #lst ==\
    \ 0 then\n      return 'No'\n   end\n   local open = 0\n   local close = 0\n \
    \  for i = 1, #lst do\n      if lst[i] == ')' then\n         close = close + 1\n\
    \      elseif lst[i] == '(' then\n         open = open + 1\n      elseif lst[i]\
    \ == ')' then\n         close = close + 1\n      elseif lst[i] == '(' then\n \
    \        open = open + 1\n      else\n         if open ~= close then\n       \
    \     return 'No'\n         end\n         close = 0\n         open = 0\n     \
    \ end\n   end\n   return 'Yes'\nend", "  local lst = lst or {}\n  local result\
    \ = true\n  for i=1,#lst do\n    if lst[i] == '(' then\n      if not result then\n\
    \        return false\n      end\n      result = true\n    elseif lst[i] == ')'\
    \ then\n      if result then\n        return false\n      end\n      result =\
    \ false\n    else\n      if not result then\n        return false\n      end\n\
    \    end\n  end\n  return result\nend", "  local ok = 1\n  for i = 1, #lst do\n\
    \    if lst[i] ~= '(' or lst[i] ~= ')' then\n      ok = 0\n      break\n    end\n\
    \  end\n  return ok\nend", "  local open = 1\n  local close = 1\n  local i = 1\n\
    \  while true do\n    i = i + 1\n    if lst[i] == '(' and open ~= close then\n\
    \      open = open + 1\n    elseif lst[i] == ')' and close ~= open then\n    \
    \  close = close + 1\n    elseif lst[i] == '' and open == close then\n      return\
    \ 'Yes'\n    end\n  end\nend", "    local stack = { }\n    for i = 1, #lst do\n\
    \        stack[#stack + 1] = lst[i]\n    end\n    while #stack > 0 do\n      \
    \  local token = stack[#stack]\n        if token ~= '(' and token ~= ')' then\n\
    \            return 'No'\n        end\n        if token == '(' then\n        \
    \    stack[#stack + 1] = ')'\n        elseif token == ')' then\n            local\
    \ last = stack[#stack]\n            if last ~= '(' and last ~= ')' then\n    \
    \            return 'No'\n            end\n            stack[#stack + 1] = stack[#stack]\
    \ - 1\n        end\n    end\n    return 'Yes'\nend", "  local str1, str2 = lst[1],\
    \ lst[2]\n  local n1, n2 = #str1, #str2\n  if n1 == 0 or n2 == 0 then return false\
    \ end\n  local i = n1\n  local j = n2\n  local op1 = '('\n  local op2 = ')'\n\
    \  local res = 'Yes'\n  repeat\n    while i > 0 and str1[i-1] == op1 do\n    \
    \  i = i - 1\n      if i == 0 then return false end\n    end\n    while j > 0\
    \ and str2[j-1] == op2 do\n      j = j - 1\n      if j == 0 then return false\
    \ end\n    end\n    if i >= j then\n      return false\n    end\n    i = i + 1\n\
    \    j = j - 1\n  until i > j\n  if i >= j then\n    return res\n  end\n  res\
    \ = res and 'Yes' or 'No'\n  return res\nend", "  local open = 1\n  local close\
    \ = 0\n  local open = 0\n  local close = 0\n  for _, b in pairs(lst) do\n    local\
    \ _, _, open, close = unpack(lst)\n    if b == '(' and open == 1 then\n      open\
    \ = open + 1\n      close = close + 1\n    elseif b == ')' and open == close then\n\
    \      open = open - 1\n      close = close - 1\n    elseif b == '(' then\n  \
    \    open = open + 1\n    elseif b == ')' then\n      close = close + 1\n    end\n\
    \  end\n  return open == close\nend", "  local open_p = 0\n  local close_p = 0\n\
    \  local s = 0\n  for i = 1, #lst do\n    if lst[i] ~= ')' then\n      s = i\n\
    \      break\n    end\n  end\n  for i = s + 1, #lst do\n    if lst[i] ~= '(' and\
    \ lst[i] ~= '{' then\n      s = i\n      break\n    end\n  end\n  local end =\
    \ 0\n  for i = s + 1, #lst do\n    if lst[i] ~= ')' then\n      end = 1\n    \
    \  break\n    end\n  end\n  if end == 0 then\n    return false\n  end\n  if #lst\
    \ > #lst - 2 then\n    return false\n  end\n  for i = 1, #lst - #s - 1 do\n  \
    \  if lst[i] ~= ')' then\n      if lst[i + 1] == '(' then\n        open_p += 1\n\
    \      else\n        close_p += 1\n      end\n    end\n  end\n  if open_p ~= close_p\
    \ then\n    return false\n  end\n  return true\nend", "\tlocal res = {}\n\tlocal\
    \ n = 1\n\tlocal p = 1\n\tlocal d = 2\n\twhile p < #lst do\n\t\tres[p] = \"No\"\
    \n\t\td = d+1\n\t\tn = n+1\n\t\twhile d < n do\n\t\t\tif lst[p] == ')' then\n\t\
    \t\t\tres[p] = 'Yes'\n\t\t\t\tbreak\n\t\t\telseif lst[p] == '(' then\n\t\t\t\t\
    res[p] = 'No'\n\t\t\t\tbreak\n\t\t\telseif lst[p] == lst[d] then\n\t\t\t\tres[p]\
    \ = \"No\"\n\t\t\t\tbreak\n\t\t\telse\n\t\t\t\tres[p] = \"Yes\"\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\t\tp = p + 1\n\t\t\td = d + 2\n\t\tend\n\tend\n\treturn res\nend",
  "  local result = false\n  for _, x in ipairs(lst) do\n    local n = #x\n    if\
    \ x == '(' then\n      if result == false then\n        result = true\n      end\n\
    \    elseif x == ')' then\n      if result == true then\n        result = false\n\
    \      end\n    end\n  end\n  return result\nend", "  if #lst < 2 then\n    return\
    \ true\n  end\n  local open_balance = 1\n  local close_balance = 0\n  for i, v\
    \ in ipairs(lst) do\n    if v == '(' then\n      open_balance = open_balance +\
    \ 1\n    elseif v == ')' then\n      close_balance = close_balance - 1\n    elseif\
    \ v == '(' ~= close_balance ~= open_balance then\n      return false\n    end\n\
    \  end\n  return open_balance == 0 and close_balance == 0\nend", "  local closed\
    \ = {}\n  local open = 0\n  for i = 1, #lst do\n    if lst[i] == '(' then\n  \
    \    open = open + 1\n      table.insert(closed, 0)\n    elseif lst[i] == ')'\
    \ then\n      if open == 0 then\n        return 'No'\n      else\n        local\
    \ opening = #closed\n        table.insert(closed, open - 1)\n        open = open\
    \ - 1\n        if open == opening then\n          return 'Yes'\n        else\n\
    \          return 'No'\n        end\n      end\n    end\n  end\n  return 'No'\n\
    end", "  local good = true\n  local stack = {}\n  for i=1,#lst do\n    if lst[i]\
    \ == '(' and stack[#stack] == nil then\n      stack[#stack+1] = i\n    elseif\
    \ lst[i] == ')' and stack[#stack] ~= nil then\n      stack[#stack] = nil\n   \
    \ elseif lst[i] == ')' and stack[#stack] == nil then\n      good = false\n   \
    \ end\n  end\n  return good\nend", "  if lst[1] == nil then\n    return nil\n\
    \  elseif lst[1] == ')' then\n    return true\n  elseif lst[1] == '(' then\n \
    \   return match_parens(lst[2:])\n  else\n    return match_parens(lst[1:])\n \
    \ end\nend", "  local opens = { }\n  local closes = { }\n  local i = 1\n  while\
    \ i <= #lst do\n    if lst[i] == '(' or lst[i] == '{' then\n      if opens[#opens]\
    \ == nil then\n        opens[#opens] = i\n      else\n        return nil\n   \
    \   end\n    elseif lst[i] == ')' or lst[i] == '}' then\n      if closes[#closes]\
    \ == nil then\n        closes[#closes] = i\n      else\n        return nil\n \
    \     end\n    end\n    i = i + 1\n  end\n  if #opens < #closes then\n    return\
    \ nil\n  elseif #opens > #closes then\n    return 'Yes'\n  else\n    return 'No'\n\
    \  end\nend", "  assert(lst:len() == 2, \"Wrong number of arguments\")\n  assert(lst[1]:sub(1,\
    \ 1) == \"(\" or lst[1]:sub(-1) == \")\", \"Invalid input\")\n  local open_cnt\
    \ = 1\n  for i, v in pairs(lst) do\n    if v:sub(1, 1) == \"(\" then\n      open_cnt\
    \ = open_cnt + 1\n    end\n    if v:sub(1, 1) == \")\" then\n      open_cnt =\
    \ open_cnt - 1\n      if open_cnt == 0 then\n        return \"Yes\"\n      end\n\
    \    end\n  end\n  return \"No\"\nend", "  local stack = {}\n  local res = 0\n\
    \  for _, elem in pairs(lst) do\n    if elem == '(' then\n      table.insert(stack,\
    \ '(')\n    elseif elem == ')' then\n      if not stack[#stack] then\n       \
    \ res = not res\n      end\n      table.remove(stack)\n    elseif elem == '' then\n\
    \      if #stack == 0 then\n        res = not res\n      end\n      table.remove(stack)\n\
    \    end\n  end\n  return res\nend", "  local num_open = 0\n  local num_close\
    \ = 0\n  local total = 0\n  local ret = 'No'\n  for _, v in pairs(lst) do\n  \
    \  if v == '(' and num_open == 1 then\n      total = total + 1\n      if num_open\
    \ ~= 0 then num_open = num_open - 1 end \n      ret = ret and 'Yes'\n    elseif\
    \ v == ')' and num_close == 0 then\n      total = total + 1\n      if num_close\
    \ ~= 0 then num_close = num_close - 1 end \n      ret = ret and 'Yes'\n    end\n\
    \    if num_open ~= 0 and num_close ~= 0 then\n      ret = ret and 'Yes'\n   \
    \   num_open = num_open - 1\n      num_close = num_close - 1\n    end\n  end\n\
    \  if num_open == 0 and num_close == 0 then ret = ret and 'Yes' end\n  return\
    \ ret\nend", "  for i = 1, #lst do\n    local parens = lst[i]\n    local parens_count\
    \ = count_parens(parens)\n    if parens_count == 0 then\n      return false\n\
    \    end\n    local open_count, close_count = count_parens_closes(parens)\n  \
    \  if open_count + close_count ~= parens_count then\n      return false\n    end\n\
    \  end\n  return true\nend", "  local ret = 'No'\n  local stack = {}\n  for i,e\
    \ in ipairs(lst) do\n    if string.find(e, \"(\") then\n      table.insert(stack,\
    \ i)\n    end\n    if string.find(e, \")\") then\n      local elem = stack[#stack]\n\
    \      stack[#stack] = nil\n      if stack[#stack] == elem then\n        ret =\
    \ ret and 'Yes' or 'No'\n      else\n        table.insert(stack, elem)\n     \
    \ end\n    end\n  end\n  return ret\nend", "  local closed = {}\n  local open\
    \ = 0", "  -- base case: an empty list is an empty string\n  if #lst == 0 then\
    \ return '' end\n  -- base case: a single string is non-empty\n  if #lst == 1\
    \ then return lst[1] end\n  -- base case: a single string is a valid concatenation\
    \ of two strings\n  if lst[1] == lst[2] then return match_parens(lst:subset(2))\
    \ end\n  -- base case: two valid strings are non-empty\n  if lst[1] == lst[2]\
    \ then return 'Yes' end\n  -- recursive case: concatenate two valid strings\n\
    \  return match_parens(lst:subset(2)) .. match_parens(lst:subset(1, #lst - 2))\n\
    end", "  local stack = {}\n  local open = 1\n  local close = 1", "  local open\
    \ = 0\n  local close = 0\n  for _, _ in ipairs(lst) do\n    if lst[open] == '('\
    \ then\n      open += 1\n    elseif lst[open] == ')' then\n      close += 1\n\
    \    end\n  end\n  if open == close then\n    return true\n  end\n  return false\n\
    end", "  local open = 0\n  local close = 0\n  for i = 1, #lst do\n    local item\
    \ = lst[i]\n    if item == '(' then\n      open += 1\n    elseif item == ')' then\n\
    \      close += 1\n    end\n  end\n  if open == close then\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend", "    local start = 0\n    local end = 1\n\
    \    local stack = {}\n    while start <= #lst do\n        local n = lst[start]\n\
    \        if n == '(' then\n            stack[#stack + 1] = start\n           \
    \ start = end + 1\n        elseif n == ')' then\n            start = stack[#stack]\
    \ - 1\n        else\n            assert(false, \"Unexpected symbol!\")\n     \
    \   end\n    end\n    return #stack == 0 and nil or false\nend", "  local len\
    \ = #lst\n  if len < 2 then return false end\n  local left  = lst[1]\n  local\
    \ right = lst[len]\n  local open  = {'(', ')'}\n  local close = {')', '('}\n \
    \ local res = {}\n  for i = 1, len do\n    local c = left[i]\n    local ls = open[c]\n\
    \    local rs = close[c]\n    if ls and rs then\n      res[#res + 1] = ls\n  \
    \    res[#res + 1] = rs\n    end\n  end\n  if #res == len then\n    local last\
    \ = res[len]\n    return last == '(' and last == ')'\n  end\n  return false\n\
    end", "    local n = #lst\n    for i = 1, n do\n        if lst[i] == '(' then\n\
    \            n = n - 1\n            if n ~= 0 then\n                i = i - 1\n\
    \                -- Check if lst[i-1] has unmatched bracket\n                if\
    \ lst[i-1] ~= '(' or lst[i-1] ~= ')' then\n                    -- It doesn't have\
    \ unmatched bracket\n                    -- Check if the substring that starts\
    \ at i-1 is a balanced bracket\n                    local s = lst[i]\n       \
    \             for j = i + 1, n do\n                        if s[j] ~= ')' and\
    \ s[j] ~= '(' then\n                            break\n                      \
    \  end\n                        s = s .. s[j] .. lst[i-1]\n                  \
    \  end\n                    if s == '()' then\n                        return\
    \ 'Yes'\n                    end\n                end\n            end\n     \
    \   end\n    end\n    return 'No'\nend", "  if #lst == 0 then\n    return 'No'\n\
    \  end\n  if #lst == 1 then\n    return lst.[1] == ')' and lst[1] == ')'\n  end\n\
    \  local opens = { }\n  local closes = { }\n  local is_open = false\n  for i =\
    \ 1, #lst do\n    if lst[i] == '(' then\n      if not is_open then\n        is_open\
    \ = true\n      else\n        table.insert(opens, i)\n      end\n    elseif lst[i]\
    \ == ')' then\n      if not is_open then\n        return 'No'\n      else\n  \
    \      table.insert(closes, i)\n      end\n    elseif is_open then\n      if not\
    \ lst[i] == ')' then\n        return 'No'\n      elseif i == #lst - 1 then\n \
    \       return true\n      else\n        table.insert(closes, i)\n      end\n\
    \    end\n  end\n  if #opens < #closes then\n    return 'No'\n  end\n  return\
    \ #opens == #closes and #opens == 0 or #opens == #closes == 0 and #opens > 0 and\
    \ #closes > 0\nend", "    local lst_size = #lst\n    for i = 1, lst_size do\n\
    \        if lst[i] == '(' then\n            -- If there's a left paren, there's\
    \ a right paren.\n            if lst[i - 1] == ')' then\n                return\
    \ true\n            elseif lst[i - 1] == '(' then\n                -- If there's\
    \ a right paren, there's a left paren.\n                if lst[i + 1] == ')' then\n\
    \                    return true\n                end\n            end\n     \
    \   end\n    end\n    return false\nend", "\tlocal i = 1\n\twhile i < #lst do\n\
    \t\tlocal open = lst[i]\n\t\tif open ~= '(' and open ~= ')' then\n\t\t\treturn\
    \ false\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn true\nend", "   -- Base case:\
    \ there's only one string or it's empty.\n   if #lst < 2 then return 'No' end\n\
    \   if #lst == 1 then return 'Yes' end", "  if #lst == 2 then\n    return match_parens(lst[1])\
    \ or match_parens(lst[2])\n  end", "  local stack = {}\n  local i = 0\n  for _,\
    \ v in ipairs(lst) do\n    if v == '(' or v == ')' then\n      stack[#stack+1]\
    \ = v\n    elseif v == ')' then\n      if not #stack == 1 then\n        return\
    \ 'No'\n      elseif stack[#stack] == v then\n        stack[#stack] = nil\n  \
    \    else\n        return 'No'\n      end\n    end\n  end\n  if #stack > 0 then\
    \ return 'No' end\n  return 'Yes'\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
