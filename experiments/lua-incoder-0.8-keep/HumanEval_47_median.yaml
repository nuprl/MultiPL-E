name: HumanEval_47_median
language: lua
prompt: "-- Return median of elements in the list l.\n-- >>> median([3, 1, 2, 4, 5])\n\
  -- 3\n-- >>> median([-10, 4, 6, 1000, 10, 20])\n-- 15.0\nlocal function median(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = median\n\
  \    lu.assertEquals(candidate({3, 1, 2, 4, 5}), 3)\n    lu.assertEquals(candidate({-10,\
  \ 4, 6, 1000, 10, 20}), 8.0)\n    lu.assertEquals(candidate({5}), 5)\n    lu.assertEquals(candidate({6,\
  \ 5}), 5.5)\n    lu.assertEquals(candidate({8, 1, 3, 9, 9, 2, 7}), 7)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local n = #l\n  if n >= 2 then\n    local m = math.floor(n / 2)\n\
    \    if n == (m % 2) then\n      return l[m]\n    else\n      return (l[m] + l[m\
    \ - 1]) / 2\n    end\n  else\n    return nil\n  end\nend", "  local n = #l\n \
    \ if n < 2 then\n    return nil\n  end\n  local middle = math.floor((n - 1) /\
    \ 2)\n  if middle > 1 then\n    return median(l[middle]) + median(l[middle - 1])\
    \ / 2\n  end\n  return l[middle]\nend", "  if #l == 0 then return nil end\n  if\
    \ #l == 1 then return l[1] end", "  return select(l, math.floor(#l*0.5))\nend",
  "  return nil, nil -- TODO: implement a median function\nend", "  local n = #l\n\
    \  if n < 1 then return nil end\n  local mid = math.floor(n/2)\n  if n % 2 ==\
    \ 0 then\n    return math.floor(l[mid]) + math.floor(l[mid+1]) / 2.0\n  else\n\
    \    return math.floor(l[mid])\n  end\nend", "    if l == nil then\n        return\
    \ nil\n    end\n    local l = l[1]\n    if #l == 0 then\n        return nil\n\
    \    end\n    local n = #l + 1\n    local median = nil\n    local small, large,\
    \ mid\n    for i = 1, n do\n        local value = tonumber(l[i])\n        if median\
    \ == nil then\n            median = value\n        elseif median > value then\n\
    \            large = value\n        elseif median < value then\n            small\
    \ = value\n        else\n            mid = i\n        end\n    end\n    median\
    \ = (small + large) / 2\n    return median\nend", "  local middle = #l / 2\n \
    \ local middle2 = middle\n  local half = #l\n  if half % 2 == 1 then\n    middle2\
    \ = middle2 + 1\n  end\n  if middle > half/2 then\n    return l[middle]\n  else\n\
    \    return l[middle2]\n  end\nend", "    if l==nil then\n        return nil\n\
    \    end\n    if #l < 0 then\n        return nil\n    end\n    local half = math.floor(#l/2)\n\
    \    return ((l[half]+l[half+1])/2.0):float()\nend", "  if l == nil then\n   \
    \ return nil\n  end\n  local n = #l\n  local median = l[math.floor(n / 2)]\n \
    \ if n % 2 == 0 then\n    return median + median\n  end\n  local mid = n / 2\n\
    \  local lower = median\n  local upper = median - median\n  local average = math.floor(n\
    \ / 2)\n  for i = 1, n do\n    if l[i] == lower then\n      lower = average +\
    \ i\n    elseif l[i] == upper then\n      upper = average + i\n    else\n    \
    \  average = average + i\n    end\n  end\n  return median + math.ceil((lower -\
    \ upper) / 2)\nend", "  if #l == 0 then\n    return nil\n  end\n  local mid =\
    \ #l / 2\n  if l[mid] < 0 then\n    return median(l[mid..0])\n  elseif l[mid]\
    \ >= 0 then\n    return median(l[mid..#l])\n  end\n  local i = 0\n  while i <\
    \ #l do\n    if l[i] > l[mid] then\n      i = i + 1\n    elseif l[i] < l[mid]\
    \ then\n      return median(l[i..mid])\n    end\n  end\n  return l[mid]\nend",
  "  if l==nil then return nil end\n  local n = #l\n  if n == 0 then\n    return nil\n\
    \  elseif n % 2 == 1 then\n    return l[math.floor(n/2)]\n  else\n    return ((l[math.floor(n\
    \ / 2)] + l[math.floor(n / 2) - 1]) / 2)\n  end\nend", "  local count = #l\n \
    \ if count == 0 then\n    return nil\n  elseif count == 1 then\n    return l[1]\n\
    \  end\n  local half = math.ceil(count / 2)\n  if half == count then\n    return\
    \ ((l[half] - l[count - 1]) .. l[half]) / 2\n  elseif half > count then\n    return\
    \ median(l, half)\n  else\n    return median(l, (half + 1))\n  end\nend", "  if\
    \ #l == 0 then return nil end\n  local l = sort(l)\n  if #l == 1 then return l[1]\
    \ end\n  local mid = math.floor(#l/2)\n  if l[mid] ~= l[mid-1] then\n    return\
    \ median(l[mid..(#l)])\n  else\n    return l[mid]\n  end\nend", "  if l==nil then\n\
    \    return nil\n  end\n  local mid = #l/2\n  if #l%2 == 1 then \n    return l[mid]\
    \ \n  elseif l[mid] == nil then\n    return nil\n  else\n    return median(l[mid-1],\
    \ median(l))\n  end\nend", "  if l==nil then\n    return nil\n  end\n  if #l==1\
    \ then\n    return l[1]\n  end\n  if #l==2 then\n    return l[1]+l[2]/2\n  end\n\
    \  local medians = { }\n  for i,v in ipairs(l) do\n    medians[#medians+1] = v\n\
    \  end\n  local median_idx = #medians\n  while median_idx > 1 do\n    median_idx\
    \ = median_idx/2\n    medians[median_idx] = medians[median_idx-1]+medians[median_idx]\n\
    \  end\n  return medians[median_idx]\nend", "  if l[1] < l[2] then\n    return\
    \ l[1]\n  elseif l[2] < l[1] then\n    return l[2]\n  else\n    if #l == 1 then\
    \ -- Return mean of list if only one value.\n      return l[1]\n    end\n    --\
    \ Sort the list and return middle value.\n    return l[((#l - 1) / 2) + 1]\n \
    \ end\nend\n</cell>\n<cell>", "  if l==nil then\n    return nil\n  elseif #l ==\
    \ 0 then\n    return nil\n  else\n    local _median = l[1]\n    for i = 2, #l\
    \ do\n      if _median < l[i] then\n        _median = l[i]\n      end\n    end\n\
    \    return _median\n  end\nend", "\tlocal count = #l\n\tif count == 0 then\n\t\
    \treturn nil\n\tend", "  return (tonumber(l[((#l) + 1)/2-1]) + tonumber(l[((#l)\
    \ + 1)/2]))/2\nend", "    local _median = nil\n    if #l > 0 then\n        local\
    \ _middle = math.floor((#l) / 2)\n        _median = l[_middle]\n        for i\
    \ = #l - 1, 1, -1 do\n            _median = nil\n            if #l % 2 == 0 then\n\
    \                if i == _middle then\n                    local _count = #l /\
    \ 2\n                    local _index = #l + 1\n                    while _index\
    \ <= _count do\n                        local _elt = list[_index]\n          \
    \              _index = _index + 1\n                        if _elt > _median\
    \ then\n                            _median = _elt\n                        end\n\
    \                    end\n                else\n                    local _middle\
    \ = math.floor((#l) / 2)\n                    _median = list[_middle - 1]\n  \
    \              end\n            end\n        end\n    end\n    return _median\n\
    end", "    if not l then return nil end\n    local n = #l\n    if n <= 1 then\n\
    \        return l[1]\n    end\n    local median\n    if n % 2 == 0 then\n    \
    \    median = median(l[1], l[n/2])\n    else\n        median = median(l[n/2],\
    \ l[1])\n    end\n    local i = 1\n    while i < n do\n        median = median\
    \ + l[i]/2\n        i = i + 1\n    end\n    return median\nend", "  if #l == 0\
    \ then\n    return nil\n  else\n    return math.floor((#l*0.5) + 1)\n  end\nend\n\
    </cell>\n<cell>", "  if #l == 0 then return nil end\n  local middle = #l / 2\n\
    \  local median = l[middle]\n  if #l % 2 then\n    median = (median + l[middle\
    \ - 1]) / 2\n  end\n  return median\nend", "  if l==nil then\n    return nil\n\
    \  end\n  local mid=math.floor(#l/2)\n  if #l%2 ~= 0 then\n    return l[mid]\n\
    \  end\n  return median(l[mid..2])\nend", "  local l = l or {}\n  local n = #l\n\
    \  if n == 0 then\n    return nil\n  elseif n == 1 then\n    return l[1]\n  else\n\
    \    if n % 2 == 0 then\n      return median(l, n / 2)\n    else\n      return\
    \ median(l + (n / 2), n / 2)\n    end\n  end\nend", "  if l == nil then return\
    \ nil end\n  local middle = #l / 2\n  if middle == 0 then return l[1] end\n  if\
    \ #l % 2 == 1 then return median(l[middle]) end\n  local i = middle - 1\n  local\
    \ median = nil\n  repeat\n    local x = l[i]\n    median = x > median and x or\
    \ median\n    i = i - 1\n  until i == 0\n  return median\nend", "  if l == nil\
    \ then\n    return nil\n  end\n  if #l < 1 then\n    return nil\n  end\n  -- Get\
    \ the middle index, which is roughly the median.\n  local middle_i = math.floor(#l\
    \ / 2)\n  if middle_i == 0 then\n    return l[1]\n  end\n  if #l == 1 then\n \
    \   return l[1]\n  end\n  -- The median is the element in the middle index.\n\
    \  return median(l[middle_i])\nend", '  local median = nil', "  if l == nil then\n\
    \    return nil\n  end\n  local half = math.floor((#l)/2)\n  if #l % 2 == 0 then\n\
    \    return l[half]\n  elseif #l % 2 ~= 0 then\n    return (l[half-1] + l[half])\
    \ / 2\n  end\nend", "  if l==nil then return nil end\n  if #l>0 then\n    local\
    \ m=l[1]\n    for i=2,#l do m=math.min(m,l[i]) end\n    return m\n  end\n  return\
    \ nil\nend", "    if l==nil then return nil end\n    local _min = l[1]\n    local\
    \ _max = l[#l]\n    local sum = 0\n    local count = 0\n    for i=1,#l do\n  \
    \      sum = sum + l[i]\n        if sum > _max then _max = sum end\n        if\
    \ sum < _min then _min = sum end\n        count = count + 1\n    end\n    if count%2==0\
    \ then return _min+1 elseif count==0 then return _min end\n    return (_max+_min)/2\n\
    end", "    local mid = math.ceil(#l) / 2\n    if #l % 2 == 0 then\n        return\
    \ mid\n    else\n        return median(l[mid]) + median(l[mid+1]) / 2\n    end\n\
    end", "  if #l == 0 then return 0 end\n  local middle_idx = math.floor(#l / 2)\n\
    \  if #l == 1 then return l[1] end\n  if l[middle_idx] == l[middle_idx - 1] then\
    \ return l[middle_idx] end\n  return median(l, middle_idx - 1, middle_idx)\nend",
  "  local mid = math.floor((#l)/2)\n  local lower = l\n  local upper = lower\n  if\
    \ #l % 2 == 1 then\n    lower = l[1]\n    upper = lower\n  end\n  if #l % 2 ==\
    \ 0 then\n    return upper\n  end\n  for i = 1, (mid-1) do\n    local t = lower[i]\n\
    \    lower[i] = lower[mid]\n    lower[mid] = t\n  end\n  if mid-1 > 1 then\n \
    \   local t = upper[mid]\n    upper[mid] = upper[mid-1]\n    upper[mid-1] = t\n\
    \  end\n  if upper - lower < math.abs(#l)/2 then\n    return lower[math.min(#l,\
    \ 1)]\n  end\n  local sum = 0\n  for i = 1, #l do\n    sum = sum + l[i]\n  end\n\
    \  return sum/((#l)/2)\nend", "    local count, median, largest = 0, 0, 0\n  \
    \  for _, val in ipairs(l) do\n        count = count + 1\n        if count > 1\
    \ then\n            if val > median then\n                largest = largest\n\
    \            else\n                largest = val\n            end\n        else\n\
    \            median = median + val / 2\n        end\n    end\n    return median\
    \ + largest / 2\nend", "    local c = table.count(l)\n    if c == 0 then\n   \
    \     return nil\n    end\n    if c % 2 == 0 then\n        return l[math.floor(c/2)]\n\
    \    end\n    local half = math.floor(c/2)\n    return l[half]+median(l[half+1])\
    \ end", "  if l == nil then return nil end\n  return (l[math.floor(#l / 2)] +\
    \ l[math.floor(#l / 2) - 1]) / 2\nend", "  local sorted = sort(l)\n  if #sorted\
    \ == 0 then return nil end\n  local mid = #sorted/2\n  if #sorted % 2 == 0 then\n\
    \    return (sorted[mid-1] + sorted[mid]) / 2\n  else\n    return sorted[mid]\n\
    \  end\nend", "  local sorted = math.sort(l)\n  return sorted[math.floor((#sorted\
    \ + 1) / 2)]\nend", "  local n = #l\n  if n == 0 then\n    return nil\n  else\n\
    \    local mid = n/2\n    if n < 2 then\n      return l[mid]\n    elseif n ==\
    \ 1 then\n      return l[1]\n    else\n      local lower = median(l, 1, mid-1)\n\
    \      local upper = median(l, mid+1, n)\n      return (lower+upper)/2\n    end\n\
    \  end\nend", "  local count = select(\"#\", l)\n  if count == 0 then return 0\
    \ end\n  local half = count / 2\n  return select((half), ((half) - 1), (half),\
    \ #l) + 1\nend", "  if l == nil then\n    return nil\n  end\n  if #l == 0 then\n\
    \    return nil\n  end\n  local median = 0\n  for i=1,#l do\n    median = median\
    \ + l[i]\n  end\n  median = median/#l\n  return median\nend", "  local len = #l\n\
    \  if len < 1 then return nil end\n  local half = math.floor(len / 2)\n  if half\
    \ == 1 then return l[half] end\n  local mid = len / 2 - 1\n  return (l[mid] +\
    \ l[len / 2]) / 2\nend", "  local count = select(\"#\", l)\n  if count == 1 then\
    \ return (l[select(\"#\", l) - 1] + l[select(\"#\", l)]) / 2 end\n  return select(math.floor(count\
    \ / 2.0) + 1, l[select(\"#\", l)], median(sub(1, l)))\nend", "  local count =\
    \ #l\n  if count == 0 then\n    return nil\n  end\n  local middle_idx = math.ceil(count\
    \ / 2)\n  local x = l[middle_idx]\n  local y = l[middle_idx - 1]\n  while y ~=\
    \ nil do\n    middle_idx = middle_idx - 1\n    if x < y then\n      x = y\n  \
    \  else\n      y = middle_idx\n    end\n  end\n  return x\nend", "  if l == nil\
    \ then\n    return 0\n  else\n    local half = #l/2\n    if half == 0 then\n \
    \     return l[half]\n    else\n      return ((l[half]+l[half-1])/2)\n    end\n\
    \  end\nend", "\tlocal len = #l\n\tlocal mid = len / 2\n\tlocal pivot = l[mid]\n\
    \twhile len > 1 do\n\t\tlocal cmp = l[mid]\n\t\tfor i = mid + 1, len-1 do\n\t\t\
    \tif cmp > l[i] then\n\t\t\t\treturn pivot\n\t\t\tend\n\t\t\tpivot = l[i]\n\t\t\
    end\n\t\tmid = len / 2\n\tend\n\treturn pivot\nend", "  if #l == 0 then\n    return\
    \ \"0\"\n  elseif #l == 1 then\n    return l[1]\n  else\n    local mid = math.floor((#l)\
    \ / 2)\n    if l[mid] <= l[mid+1] then\n      return median(l, mid+1, #l)\n  \
    \  else\n      return median(l, #l, mid)\n    end\n  end\nend", "    if #l ==\
    \ 0 then return 0 end\n    if #l == 1 then return l[1] end", "  if l == nil then\n\
    \    return nil\n  end\n  local _, n, _ = torch.median(l) -- Find median of list\n\
    \  if n == nil then -- Return nil if median was never computed\n    return nil\n\
    \  end\n  return n\nend", "  if l==nil then\n    return nil\n  elseif #l==0 then\n\
    \    return nil\n  else\n    local mid = math.floor(#l/2)\n    local median =\
    \ nil\n    for i=mid,-1,-1 do\n      if l[i]<l[mid] then\n        median = l[i]\n\
    \      else\n        median = l[mid]\n        break\n      end\n    end\n    return\
    \ median\n  end\nend", "  local n = #l\n  local median\n  if n == 0 then\n   \
    \ median = nil\n  else\n    median = l[((n - 1) - ((n - 1) / 2)) + 1]\n  end\n\
    \  return median\nend", "  local half = #l / 2\n  if half % 2 then\n    return\
    \ l[half]\n  else\n    return (l[half] + l[half - 1]) / 2\n  end\nend", "  local\
    \ i, n = 0, #l\n  if n == 0 then\n    return nil\n  end\n  if n % 2 == 0 then\n\
    \    return l[math.floor((n - 1) / 2)]\n  end\n  while i < n do\n    local j =\
    \ math.floor((i + 1) / 2)\n    if l[i] > l[j] then\n      local swap = l[i]\n\
    \      l[i] = l[j]\n      l[j] = swap\n    end\n    i = j\n  end\n  return l[i\
    \ - 1]\nend", "    if not l then return nil end\n    local n = #l\n    if n ==\
    \ 0 then return nil end\n    local mid = math.floor((n+1)/2)\n    if mid*2 > n\
    \ then return median(l[mid]) and median(l[mid-1]) or nil end\n    if mid*2 < n\
    \ then return median(l[mid]) or median(l[mid+1]) or nil end\n    return l[mid]\n\
    end", "  if #l == 0 then\n    error(\"median requires an even number of arguments\"\
    )\n  end\n  local half = math.floor(#l/2)\n  if half == 0 then\n    return nil\n\
    \  end\n  if half == 1 then\n    return l[half]\n  end\n  local m = median(l[half..half+1])\n\
    \  local i = 1\n  for i = half + 1,#l do\n    if l[i] <= m then\n      break\n\
    \    end\n  end\n  return i\nend", "  if l[1] == nil then\n    return nil\n  end\n\
    \  local mid = math.floor(#l / 2)\n  if #l % 2 ~= 0 then\n    return l[mid]\n\
    \  elseif l[mid] == nil then\n    return nil\n  end\n  if l[mid] > l[mid + 1]\
    \ then\n    local m1 = median(l[mid+1 : end])\n    local m2 = median(l[1 : mid])\n\
    \    return (m1 + m2) / 2\n  else\n    local m1 = median(l[mid+1 : end])\n   \
    \ local m2 = median(l[1 : mid])\n    return (m2 + m1) / 2\n  end\nend", "    if\
    \ #l < 1 then return nil end\n    local pivot = #l / 2\n    local first, second\
    \ = 1, pivot\n    local median = nil", "  if l==nil then\n    return nil\n  end\n\
    \  local l = l or {}\n  local count = 0\n  local largest = nil\n  local largestCount\
    \ = 0\n  for k,v in pairs(l) do\n    count = count + 1\n    if v==largest then\n\
    \      largestCount = largestCount + 1\n    end\n    if count > largestCount then\n\
    \      largest = k\n      largestCount = count\n    end\n  end\n  return largest\n\
    end", "  if l == nil then return nil end\n  if type(l) == 'number' then return\
    \ l end\n  local n = #l\n  local idx = 0\n  if n >= 2 and type(l[1]) == 'number'\
    \ then\n    idx = 1\n  elseif n < 2 then return nil end\n  -- The median is either\
    \ the average of middle elements\n  -- or the average of the first few elements.\n\
    \  local median = nil\n  local cnt = 0\n  for i = idx, idx + n do\n    if median\
    \ == nil then\n      median = l[i]\n    else\n      if cnt > 0 and cnt % 2 ==\
    \ 0 then\n        median = math.floor((median + l[i]) / 2)\n      else\n     \
    \   median = math.floor(median + l[i])\n      end\n    end\n    cnt = cnt + 1\n\
    \  end\n  return median\nend", "  if #l <= 1 then return nil end\n  local mid\
    \ = (#l + 1) >> 1\n  if l[mid] > l[mid+1] then return median(l, mid + 1, #l) end\n\
    \  return l[mid]\nend", "  if #l == 0 then\n    return nil\n  end", "  local n\
    \ = #l\n  if n < 1 then\n    -- Don't bother with empty lists.\n    return nil\n\
    \  elseif n == 1 then\n    -- Special case for trivial lists.\n    return l[1]\n\
    \  end", "  local n = #l\n  if n == 0 then\n    return nil\n  end\n  if n ~= 1\
    \ then\n    local i = n / 2\n    local mid = math.ceil(i / 2)\n    local left\
    \ = l\n    local right = l\n    if mid == 1 then\n      return l[mid - 1]\n  \
    \  else\n      while mid > 1 do\n        mid = math.floor(mid)\n        left =\
    \ left[mid - 1]\n        right = right[mid - 1]\n      end\n      return (left\
    \ + right) / 2\n    end\n  end\n  return l[1]\nend", "  local count = (#l) + 1\n\
    \  local median\n  if count % 2 == 0 then\n    median = l[(count - 1) div 2]\n\
    \  else\n    median = (l[((count - 1) div 2) + 1] + l[((count - 1) div 2)] ) /\
    \ 2\n  end\n  return median\nend", "  if #l == 0 then\n    return nil\n  end\n\
    \  local idx = floor(#l/2)\n  if idx == 1 then\n    return l[idx/2-1]\n  end\n\
    \  return (l[idx/2-1] + l[idx/2])/2\nend", "  if l == nil then return nil end\n\
    \  if #l == 0 then return nil end\n  local med = math.median(l) \n  local count\
    \ = 0\n  for _, v in ipairs(l) do\n    if v == med then\n      count = count +\
    \ 1\n    end\n  end\n  return med\nend", "    local n = #l\n    if n < 1 then\
    \ return 0 end\n    if n % 2 == 1 then return (l[floor(n / 2)] + l[floor(n / 2)\
    \ + 1]) / 2 end\n    local half = n / 2\n    return l[floor(half)] + (half - 1)*median(sublist(l,\
    \ half+1, n-1))\nend", "  if #l == 0 then\n    return 0\n  end", "    local n\
    \ = #l\n    if n == 0 then\n        error(\"median of empty list\")\n    end\n\
    \    if n < 2 then\n        return l[1]\n    end\n    local mid = (n - 1) >> 1\n\
    \    return l[mid] and median(sublist(l, 1, mid + 1)) or median(sublist(l, mid\
    \ + 1, n)) or l[mid]\nend", "  local n = #l\n  if n == 2 then\n    return l[1]\n\
    \  elseif n == 0 then\n    return nil\n  end", "    if #l == 0 then\n        return\
    \ 0\n    end\n    local median = nil\n    local count   = 0\n    for _, v in ipairs(l)\
    \ do\n        if count > 0 then\n            median = (median + v) / 2\n     \
    \   end\n        median = median + v\n        count = count + 1\n    end\n   \
    \ return median\nend", "  if #l == 0 then\n    return nil\n  end\n  local mid\
    \ = math.floor(#l / 2)\n  if #l % 2 == 0 then\n    return l[mid]\n  end\n  return\
    \ median(l[mid], l[mid])\nend", "    if l == nil then return nil end\n    if #l\
    \ == 0 then return nil end\n    if #l == 1 then return l[1] end\n    local pivot\
    \ = math.floor(#l/2)\n    if #l % 2 == 0 then\n        return median(l[pivot],\
    \ l[pivot-1]) -- even\n    end\n    -- odd, take the middle element\n    return\
    \ median(l[pivot], l[pivot+1]) -- odd\nend", "  local sortkeys = table.sort(l)\n\
    \  if #sortkeys == 1 then\n    return sortkeys[1]\n  end\n  local median = sortkeys[#sortkeys\
    \ / 2]\n  local count = 0\n  for _, v in ipairs(sortkeys) do\n    count = count\
    \ + 1\n    if v == median then\n      return median\n    end\n  end\n  return\
    \ median\nend", "  if #l == 0 then\n    error(\"median called with an empty list\"\
    )\n  end\n  local i = math.floor(#l / 2)\n  if #l % 2 == 0 then\n    return l[i\
    \ - 1]\n  else\n    return (l[i-1] + l[i - 1]) / 2\n  end\nend", "  if not l then\
    \ return nil end\n  local half = #l/2\n  if half < 2 then return nil end\n  if\
    \ #l % 2 == 0 then return l[half] end\n  return median(l[half], l[half-1])\nend",
  "  local cnt\n  if #l == 0 then return 0 end\n  if #l == 1 then\n    if l[1] < 0\
    \ then return -Infinity end\n    return l[1]\n  end\n  if #l % 2 ~= 0 then return\
    \ -Infinity end\n  cnt = #l / 2\n  local median = l[cnt]\n  for i = cnt + 1, #l\
    \ do\n    median = median + l[i] / 2\n  end\n  return median\nend", "  local n\
    \ = #l\n  if n < 1 then return nil end\n  if n == 1 then\n    return l[1]\n  end\n\
    \  local mid = math.floor(n/2)\n  if l[mid] < l[mid + 1] then\n    return median(l,\
    \ mid + 1, #l - 1)\n  else\n    return median(l, mid - 1, #l)\n  end\nend", " \
    \ local n = #l\n  if n <= 1 then\n    return l[1]\n  end\n  local m = n / 2\n\
    \  local median1 = median(l[1:m])\n  local median2 = median(l[m+1:n])\n  return\
    \ (median1 + median2) / 2\nend", "  if l == nil then return 0 end\n  local n =\
    \ #l\n  if n % 2 == 0 then\n    local mid = l/2\n    local x = median(l[mid+1])\n\
    \    local y = median(l[mid])\n    return y + (x-y) / 2\n  end\n  local mid =\
    \ l/2\n  return l[mid]\nend", "  local num = math.random(math.floor(#l) + 1)\n\
    \  if num % 2 == 0 then\n    local mid = math.random(num)\n    local i = 1\n \
    \   while i < num and l[i] <= l[mid] do\n      i = i + 1\n    end\n    if i ==\
    \ num then\n      return l[mid]\n    else\n      return (l[mid] + l[i])/2\n  \
    \  end\n  else\n    local mid = math.random(num)\n    local i = 1\n    while i\
    \ < num and l[i] >= l[mid] do\n      i = i + 1\n    end\n    if i == num then\n\
    \      return l[mid]\n    else\n      return (l[mid] + l[i])/2\n    end\n  end\n\
    end", "  if l == nil then return 0 end\n  local n = #l\n  if n <= 1 then return\
    \ l[1] end\n  return (l[n/2-1] + l[n/2]) / 2\nend", "  -- Find the middle of the\
    \ list.\n  local mid = math.floor((#l) / 2)\n  if #l == 0 then return nil end",
  "  if #l == 0 then\n    return nil\n  end\n  local i = math.floor((#l) / 2)\n  if\
    \ i > (#l) / 2 then -- If there are an odd number of elements, choose the median.\n\
    \    i = #l\n  end\n  return l[math.floor((#l) / 2)]\nend", "  if l==nil then\n\
    \    return nil\n  end\n  local n = 0\n  for i = 1, #l do\n    n = n + (l[i] or\
    \ 0)\n  end\n  return n / #l\nend", "  local i, n = select('#', l)\n  if n ==\
    \ 1 then\n    return l[1]\n  else\n    return (n - 1) / 2\n  end \nend", "  if\
    \ #l == 0 then return nil end\n  return (l[1] + l[2]) / 2.0\nend", "  if l ==\
    \ nil then\n    return nil\n  end", "    if not l or #l < 2 then\n        return\
    \ 0\n    end", "  return select(2, medians(l))\nend", "  local n = #l\n  if n\
    \ < 1 or n % 2 == 0 then\n    return nil\n  end\n  local half = math.floor(n /\
    \ 2)\n  return math.max(l[half], l[half - 1] + math.sqrt((l[half + 1] - l[half])\
    \ * (l[half + 1] - l[half]) / n))\nend", "    local n = #l\n    if n == 0 then\n\
    \        error('median: empty list')\n    end\n    if n % 2 == 0 then\n      \
    \  error('median: list is not even length')\n    end\n    local mid = math.floor((n\
    \ - 1) / 2)\n    if l[mid] <= l[mid+1] then\n        return l[mid]\n    else\n\
    \        return l[mid+1]\n    end\nend", "  return l:reduce(\n    function (a,\
    \ x) return a + x end,\n    0) / l:len()\nend", "  local n = #l\n  if n == 0 then\n\
    \    return nil\n  end\n  if n % 2 == 0 then\n    local mid = n / 2\n    local\
    \ first_half = l[mid]\n    local second_half = l[mid+1]\n    if first_half < second_half\
    \ then\n      return first_half\n    else\n      return second_half\n    end\n\
    \  else\n    local mid = n / 2\n    local first_half = l[mid]\n    local second_half\
    \ = l[mid+1]\n    return second_half + 0.5 * (first_half - second_half)\n  end\n\
    end", "\tlocal count, median, i, j, tmp\n\tcount = 1\n\tmedian = nil\n\tfor i,\
    \ v in ipairs(l) do\n\t\tif count == 1 then\n\t\t\tmedian = v\n\t\telse\n\t\t\t\
    if v < median then\n\t\t\t\tmedian = v\n\t\t\tend\n\t\tend\n\t\tcount = count\
    \ + 1\n\tend\n\tif count == 1 then\n\t\treturn median\n\tend\n\tif count == 2\
    \ then\n\t\treturn median\n\tend\n\tif count <= #l / 2 then\n\t\ttmp\n\t\treturn\
    \ median\n\tend\n\ti = count / 2\n\tj = count - i\n\treturn (median * j) + tmp\n\
    end", "  local cnt = 0\n  local s = nil\n  local x = nil", "  local half = #l\
    \ / 2\n  if half == 0 then\n    return nil\n  end", "  if not l then return nil\
    \ end\n  local n = #l\n  if n < 1 then return nil end\n  if n % 2 == 1 then\n\
    \    return l[((n - 1) / 2) + 1]\n  else\n    return ((l[((n - 1) / 2)] + l[(((n\
    \ - 1) / 2) + 1)])/2) * 0.5\n  end\nend", "  if #l == 0 then\n    return nil\n\
    \  end\n  local n = #l - 1\n  local m = math.floor(n / 2)\n  if n % 2 ~= 0 then\n\
    \    return l[m]\n  else\n    return ((l[m] + l[m+1]) / 2)\n  end\nend", "  if\
    \ l == nil then return nil end\n  if #l == 1 then return l[1] end\n  return ((l[1]\
    \ + l[2]) / 2) / 2\nend", "\t-- Find length of l and divide by 2 to make space\
    \ for middle element\n\tlocal len = #l\n\tlen = len / 2 + 1\n\t-- Initialise median\
    \ and count for number of elements found so far\n\tlocal median, count = 0, 0\n\
    \tfor i = 1, len do\n\t\tif l[i] > median then\n\t\t\tmedian = l[i]\n\t\tend\n\
    \t\tcount = count + 1\n\tend\n\t-- Return the calculated value\n\treturn median\
    \ / count\nend", "  local n = #l - 1\n  if n < 1 then return nil end\n  return\
    \ ((n - 1) / 2.0) * ((#l + 1) / 2.0) + select(l, #l + 1)\nend", "  local n = #l\n\
    \  if n <= 1 then\n    return l[1]\n  end\n  local mid = n/2\n  local l1 = l[:mid(mid)]\n\
    \  local l2 = l[#l]\n  local f1, f2, f3 = nil, nil, nil\n  if l1[mid] ~= l2[mid]\
    \ then\n    if l1[mid] > l2[mid] then f1, f2 = l1[mid], l2[mid]\n    else f2,\
    \ f3 = l1[mid], l2[mid] end\n  elseif l1[mid] == l2[mid] then f3 = l1[mid] end\n\
    \  return (f1 + f2 + f3) / 3\nend", "  if #l < 1 then return nil end\n  if #l\
    \ == 1 then return l[1] end\n  if #l == 2 then return (l[1] + l[2]) end\n  if\
    \ #l % 2 == 0 then return (l[#l/2] + l[(#l/2)-1]) end\n  local mid = math.floor(#l/2)\n\
    \  return median(l, mid-1) + median(l, mid)\nend", "  if l == nil then return\
    \ nil end\n  if #l == 0 then return nil end\n  local middle, count = div(#l, 2),\
    \ 0\n  for i = 1, middle, 1 do\n    count = count + 1\n    local m = l[i]\n  \
    \  for j = i + 1, #l, 1 do\n      if l[j] < m then\n        count = count + 1\n\
    \        local t = l[i]\n        l[i] = l[j]\n        l[j] = t\n      end\n  \
    \  end\n  end\n  return l[count]\nend", "  local n = #l - 1;\n  if n <= 1 then\n\
    \    return l[1];\n  elseif n % 2 == 0 then\n    return median(l, n / 2)\n  else\n\
    \    return (l[n] + l[n + 1]) / 2;\n  end\nend", "    local n = #l\n    if n <\
    \ 2 then\n        return l[1]\n    end\n    local mid = math.floor(n / 2)\n  \
    \  local l = l[mid]\n    for i = 1, n do\n        if l[i][1] > l[mid][1] or i\
    \ == n then\n            return l[mid][1]\n        else\n            mid = math.floor(n\
    \ / 2)\n            l = l[mid]\n        end\n    end\nend", "  return (select(l,\
    \ math.floor((#l-1)/2))+select(l, (math.floor((#l-1)/2)+1)))/2\nend", "  local\
    \ n = #l\n  if n == 0 then\n    return nil\n  end", "  return l and math.floor(\
    \ (#l) / 2 ) or 0\nend", "  if #l <= 1 then return nil end\n  return (l[1] + l[2])\
    \ / 2\nend", "  local count = #l\n  if count == 0 then\n    return nil\n  end\n\
    \  local i, j = math.ceil(count / 2), math.floor(count / 2)\n  if count == 1 then\n\
    \    return l[i]\n  end\n  local mid = count / 2\n  if l[mid] ~= nil then\n  \
    \  return l[mid]\n  end\n  -- If the list has an even number of elements, then\
    \ the median\n  -- is a midpoint of the two middle elements. Otherwise, the median\n\
    \  -- is the average of the middle elements.\n  local lower = j\n  local upper\
    \ = j\n  if j > 1 and l[j - 1] ~= nil then\n    lower = j - 1\n  end\n  if j >\
    \ 1 and l[j] ~= nil then\n    upper = j\n  end\n  if j > 1 and l[lower] ~= nil\
    \ and l[lower] > l[j] then\n    upper = lower\n  end\n  if j > 1 and l[upper]\
    \ ~= nil and l[upper] < l[j] then\n    lower = upper\n  end\n  -- If the list\
    \ is odd, then return the middle element.\n  if lower < j then\n    return median(l,\
    \ lower, upper)\n  end\n  -- If the list is odd, then return the middle element.\n\
    \  if upper < j then\n    return median(l, lower, upper)\n  end\n  -- If the list\
    \ has an even number of elements, then the median\n  -- is a midpoint of the two\
    \ middle elements. Otherwise, the median\n  -- is the average of the middle elements.\n\
    \  if lower < j and upper < j then\n    local average = (l[lower] + l[upper])\
    \ / 2\n    return average\n  end\n  return nil\nend", "  if l==nil then\n    return\
    \ nil\n  end\n  local m = math.floor(#l/2)\n  if #l == 0 then\n    return 0\n\
    \  end\n  if #l == 1 then\n    return l[m]\n  end\n  if m+1 == #l then\n    return\
    \ l[m]\n  end\n  return ((l[m] + l[m+1])/2)\nend", "    local n = #l\n    if not\
    \ n then\n        return nil\n    end\n    local mid = n / 2\n    if n % 2 ==\
    \ 1 then\n        return l[mid]\n    else\n        return median(l[mid], l[mid-1])\n\
    \    end\nend", '  if not l then return nil end', "  local mid = math.ceil(#l\
    \ / 2)\n  local i = 1\n  local median\n  repeat\n    median = math.fmod(mid, i)\n\
    \    if l[median] == nil then\n      break\n    end\n    i = i + 1\n  until l\
    \ == nil\n  return median\nend", "  local n = #l\n  if n == 0 then return nil\
    \ end\n  if n == 1 then return l[0] end\n  if n % 2 == 1 then return (l[math.floor(n/2)]\
    \ + l[math.floor(n/2)+1]) / 2 end\n  return (l[math.floor(n/2)] + median(l[math.floor(n/2):(n\
    \ - 1)]))/2\nend", "  if #l == 0 then\n    return nil\n  end\n  local middle =\
    \ math.floor(#l / 2)\n  if middle == 1 then\n    return l[middle]\n  end\n  local\
    \ lower = median(l[1:middle])\n  local upper = median(l[middle+1:end])\n  return\
    \ lower + math.abs(lower - upper) / 2\nend", "  if l[1] == nil then return nil\
    \ end\n  if #l == 1 then return l[1] end\n  local mid = math.floor(#l / 2)\n \
    \ local lower = median(l[1]):gsub(\"%D\", \"\"):tonumber()\n  local upper = median(l[#l]):gsub(\"\
    %D\", \"\"):tonumber()\n  -- Check if list is even or odd to get proper return\
    \ value\n  if #l % 2 == 1 then\n    if l[#l] == nil then return nil end\n    if\
    \ lower > upper then return upper else return lower end\n  else\n    -- If it's\
    \ even, return the middle value\n    if lower > upper then return upper else return\
    \ lower end\n  end\n  -- Sort array\n  table.sort(l)\n  -- Get middle value\n\
    \  local middle = median(l[mid])\n  if middle == nil then return nil end\n  --\
    \ Return middle value\n  return middle\nend", "  return math.floor(math.median(l))\n\
    end", "  if l == nil then return nil end\n  local n = #l\n  local half = (n /\
    \ 2) + 1\n  if n % 2 == 0 then return l[half] end\n  local tmp1 = l[half]\n  local\
    \ tmp2 = l[half - 1]\n  tmp1 = math.floor(tmp1)\n  tmp2 = math.floor(tmp2)\n \
    \ return tmp1 +\n    (tmp2 < tmp1 and tmp2 or\n      tmp2 < tmp1 and (tmp2 - tmp1)\
    \ or\n      tmp1 and\n      (tmp2 - tmp1 +\n        (tmp2 - tmp1) % 2) / 2)\n\
    end", "  if #l == 0 then\n    return nil\n  end\n  if #l == 1 then\n    return\
    \ l[1]\n  end\n  local q = math.floor(#l / 2)\n  local p = math.floor(#l / 2)\n\
    \  while p > 0 do\n    if l[p] > l[q] then\n      local t = l[q]\n      l[q] =\
    \ l[p]\n      l[p] = t\n    end\n    q = p\n    p = p - 1\n  end\n  return l[q\
    \ + 1]\nend", "  if #l == 0 then\n    return nil\n  elseif #l == 1 then\n    return\
    \ l[1]\n  elseif #l % 2 == 1 then\n    return (l[math.floor((#l + 1) / 2)] + l[math.ceil((#l\
    \ + 1) / 2)]) / 2\n  else\n    return (l[(#l - 1) / 2..#l]) / 2\n  end\nend",
  "  if l == nil then\n    return 0\n  end\n  local n = #l\n  if n <= 1 then\n   \
    \ return l[1]\n  end\n  local m = n / 2\n  if n % 2 == 1 then\n    return median(l[m\
    \ + 1], l[m])\n  end\n  -- Return the average of middle elements.\n  return ((l[m\
    \ + 1] + l[m]) / 2)\nend", "  if #l == 0 then return 0 end\n  local pivot = (l[#l])\
    \ / 2\n  local left, right = {}, {}\n  for i = 1, #l do\n    if l[i] <= pivot\
    \ then\n      table.insert(left, l[i])\n    else\n      table.insert(right, l[i])\n\
    \    end\n  end\n  return median(left) + median(right)\nend", "  if #l == 0 then\n\
    \    error(\"median requires at least one element\")\n  end\n  local half = math.floor((#l)\
    \ / 2)\n  local med = l[half]\n  local i, count\n  for i = half, #l do\n    local\
    \ val = l[i]\n    count = i - half + 1\n    if count ~= 1 then\n      med = (med\
    \ + val) / 2\n    end\n  end\n  return med\nend", "  return l:sort()[math.floor((#l\
    \ + 1) / 2) - 1]\nend", "    local t = {}\n    for _, v in ipairs(l) do\n    \
    \    table.insert(t, v)\n    end\n    local mid = math.floor(t[#t] / 2)\n    local\
    \ median = math.select(2, t[mid], t[#t] - mid)\n    return median\nend", "  if\
    \ #l == 0 then return 0 end\n  if #l == 1 then return l[1] end\n  local mid =\
    \ math.floor(#l / 2)\n  local lower = l[mid]\n  local upper = l[mid+1]\n  if lower\
    \ == upper then return lower end\n  if lower > upper then lower, upper = upper,\
    \ lower end\n  local med = (upper + lower) / 2\n  if #l % 2 == 1 then\n    return\
    \ med\n  else\n    return math.floor(med)\n  end\nend", "  if not l then return\
    \ nil end\n  if #l % 2 == 0 then return (list[#l] * (#l / 2)) end\n  local mid\
    \ = math.fmod(#l, 2)\n  return list[#l] ~= nil and list[mid] or list[mid+1]\n\
    end", "  if #l <= 1 then return 0 end\n  local mid = math.floor(#l/2)\n  local\
    \ median_l = mid\n  if #l % 2 == 1 then\n    median_l = mid+1\n  end\n  if #l\
    \ % 2 == 0 then\n    local even = #l % 2\n    if even == 1 then\n      return\
    \ math.ceil(#l/(2*median_l))\n    else\n      return math.floor(#l/(2*median_l))\n\
    \    end\n  end\n  local median = (l[mid]+l[mid+1])/2\n  return median\nend",
  "  local count, sum = count_and_sum(l)\n  if count > 0 then\n    if sum / count\
    \ <= 0.5 then\n      return (l - 1) / (count - 1)\n    end\n    return ((l + 1)\
    \ / 2)\n  end\n  return 0\nend", "  if l==nil then\n    return nil\n  elseif #l\
    \ == 1 then\n    return l[1]\n  else\n    -- Return ceiling (#l / 2), but also\
    \ check if\n    -- there is an even number of elements and return the middle element.\n\
    \    local i = (#l) + 1\n    local div = math.floor(i / 2)\n    local odd = i\
    \ % 2 ~= 0", "  if #l == 0 then\n    -- Empty lists return nil\n    return nil\n\
    \  end", "  if #l == 0 then\n    return nil\n  end\n  local n = #l - 1\n  local\
    \ i = ((n - 1) / 2) + 1\n  local mid = math.floor(i)\n  if i == 1 then\n    return\
    \ l[mid]\n  end\n  if i == n then\n    return l[mid]\n  end\n  if l[i] > l[i +\
    \ 1] then\n    return median(l)\n  end\n  return l[mid]\nend", "  local m = nil\n\
    \  for _, x in ipairs(l) do\n    if m == nil or x < m then\n      m = x\n    end\n\
    \  end\n  return m\nend", "    if l == nil then\n        return nil\n    end\n\
    \    if #l <= 1 then\n        return l[1]\n    end\n    local mid = #l / 2\n \
    \   if l[mid] < l[mid-1] then\n        return median(l[mid-1:mid+1])\n    else\n\
    \        return median(l[mid:mid+1])\n    end\nend", "  local count = select('#',\
    \ l)\n  if count < 1 then return nil end\n  local half = math.floor(count / 2)\n\
    \  local median = nil\n  if half > 1 then\n    median = select(half, l)\n  else\n\
    \    median = l[half]\n  end\n  for i = half, 1 do\n    median = median + l[i]\
    \ / (half + 1)\n  end\n  return median\nend", "  if #l <= 1 then return l[1] end\n\
    \  local mid = math.floor(#l / 2)\n  local i1, i2 = mid, mid\n  local median =\
    \ l[1]\n  while i1 <= #l do\n    local i3 = i1 + 1\n    local i5 = i3 + 1\n  \
    \  local i7 = i5 + 1\n    local median = (median * 10 + l[i1] + l[i3] + l[i5]\
    \ + l[i7]) /\n                  (10 * (i3 - i5 + 1))\n    i1, i2 = i2, i3\n  end\n\
    \  return median\nend", "  if l==nil then return nil end\n  if #l==0 then return\
    \ nil end\n  if #l==1 then return l[1] end\n  if #l==2 then\n    if l[1]==l[2]\
    \ then\n      return l[1]\n    end\n    return (l[1]+l[2])/2\n  end\n  local mid\n\
    \  local sum = 0\n  for _, v in ipairs(l) do\n    sum = sum + v\n  end\n  mid\
    \ = sum/#l\n  return mid\nend", "    local n = #l\n    if n == 0 then\n      \
    \  return nil\n    end\n    local idx = math.floor(n/2)\n    local l1 = l[idx]\n\
    \    local l2 = l[#l]\n    if l1 == nil or l2 == nil then\n        return nil\n\
    \    end\n    if l1 < l2 then\n        return median(l1)\n    else\n        return\
    \ median(l2)\n    end\nend", "  if l == nil then\n    return nil\n  elseif #l\
    \ == 0 then\n    return nil\n  elseif #l == 1 then\n    return l[1]\n  else\n\
    \    local half = (#l + 0) / 2;\n    if l[half] ~= nil then\n      return median(l[half],\
    \ l[#l])\n    else\n      return median(l[half], median(unpack(l, half+1, #l)))\n\
    \    end\n  end\nend", "  if #l == 0 then return nil end\n  return math.floor(#l\
    \ / 2)\nend", "  if l==nil then return nil end\n  -- Return median of elements\
    \ in the list.\n  -- >>> median([3, 1, 2, 4, 5])\n  -- 3\n  -- >>> median([-10,\
    \ 4, 6, 1000, 10, 20])\n  -- 15.0\n  if #l == 1 then return l[1] end\n  local\
    \ mid = math.floor( (#l+1)/2 )\n  if #l % 2 == 0 then\n    return (l[mid] + l[mid+1])\
    \ / 2\n  else\n    return l[mid]\n  end\nend", "  if l[1] == nil then\n    return\
    \ nil\n  elseif l[1] == 0 then\n    return 0\n  elseif l[2] == nil then\n    return\
    \ nil\n  elseif l[2] == 0 then\n    return l[1]\n  else\n    return (l[1] + l[2])\
    \ / 2\n  end\nend", "  if l==nil then\n    return \"nil\"\n  elseif #l == 1 then\n\
    \    return l[1]\n  else\n    return ((math.floor(#l * (0.5 + math.floor(math.log((#l)/(#l-1),\
    \ 2))))) + (math.floor(#l * (0.5 + math.floor(math.log((#l)/(#l-1), 2)))))/2)\n\
    \  end\nend", "   local size = math.fcount(l)\n   if size % 2 == 0 then\n    \
    \  local mid = math.floor(size / 2)\n      local median = l[mid]\n      if l[mid-1]\
    \ > median then\n         median = l[mid-1]\n      end\n      return median\n\
    \   else\n      return math.fdiv(\n         l[math.floor(size / 2)], math.fsub(l[math.floor(size\
    \ / 2)], l[mid]))\n   end\nend", "  local sorted, n = sort(), #l\n  if n <= 1\
    \ then return l[1] end\n  if sorted[n / 2].num < l[n/2].num then return sorted[n\
    \ / 2].num\n    else return l[n/2].num end\nend", "  local count  = 0\n  local\
    \ median = nil", "\tlocal middle = math.floor(#l / 2)\n\tlocal median = (l[middle]\
    \ + l[middle - 1]) / 2\n\treturn median\nend", "  if not (l and #l > 0) then\n\
    \    return nil\n  end", "  return math.floor(math.median(l:reduce(function(acc,\
    \ x) return acc + x end, 0)))\nend", "  if not l then return nil end\n  local\
    \ m = l[1]\n  for i = 2, #l do\n    m = m and l[i] or nil\n  end\n  return m\n\
    end", "    if l == nil then return 0 end\n    local n = #l\n    local x = l[1]\n\
    \    for i = 2, n do\n        x = math.floor(x / 2.0 + l[i / 2])\n    end\n  \
    \  return x\nend", "  if l[1] < l[2] then\n    return median(l[#l]) or median(l[#l\
    \ - 1]) or l[#l / 2]\n  elseif l[2] < l[1] then\n    return median(l[#l - 1])\
    \ or median(l[#l - 1]) or l[#l / 2]\n  else\n    return l[#l / 2]\n  end\nend",
  "  local n = #l\n  -- Return median of first n/2 elements.\n  if n <= 1 then\n \
    \   return l[1]\n  else\n    local half = math.floor((n + 1) / 2)\n    if n %\
    \ 2 == 0 then\n      return median(l, half, n - half)\n    end\n    return median(l,\
    \ half, half)\n  end\nend", "  if l == nil then\n    return nil\n  end\n  if #l\
    \ % 2 == 0 then\n    local a = l/2\n    local b = l\n    local c = math.fmod((b+1),\
    \ 2)\n    if c == 1 then\n      return l\n    elseif c == 0 then\n      return\
    \ l-1\n    else\n      return ((l-1)/2) + ((l+2)/2) * math.modf((b+1)/2)\n   \
    \ end\n  else\n    local a = #l\n    local b = 2*a\n    local c = math.fmod((b+1),\
    \ 2)\n    if c == 1 then\n      return l\n    elseif c == 0 then\n      return\
    \ l+1\n    else\n      return ((l+1)/2) + (l/2) * math.modf((b+1)/2)\n    end\n\
    \  end\nend", "  local n = 1\n  for i, v in ipairs(l) do n = n / 2 + n % 2 and\
    \ v or math.floor(v / 2) end\n  return n\nend", "    local num_items = len(l)\n\
    \    if num_items < 1 then\n        error(\"List is empty\")\n    end", "  if\
    \ #l == 0 then return 0 end\n  if #l == 1 then return l[1] end\n  return ((l[#l\
    \ / 2] + l[#l / 2 - 1]) / 2)\nend", "  if l == nil then\n    return nil\n  end\n\
    \  local n = 1\n  local m = nil\n  for i, v in ipairs(l) do\n    count = count\
    \ + 1\n    count = count + 1\n    if i == 0 then\n      m = v\n    else\n    \
    \  if v <= m then\n        m = v\n      end\n    end\n  end\n  -- If there is\
    \ only one number in l, return it.\n  if n == 1 then\n    return m\n  end\n  if\
    \ n % 2 == 0 then\n    middle = m + (m / 2)\n  else\n    middle = m\n  end\n \
    \ return middle\nend", "  if not l then\n    return nil\n  elseif #l == 0 then\n\
    \    return nil\n  else\n    local half = #l / 2\n    return l[half] + median(l[half+1]\
    \ or l) or half\n  end\nend", "    local sorted = table.sort(l)\n    local len\
    \ = #sorted\n    local mid = len / 2\n    if len % 2 == 0 then\n        return\
    \ sorted[mid]\n    end\n    return (sorted[mid-1] + sorted[mid]) / 2\nend", " \
    \ if #l == 0 then return 0 end\n  return math.floor(l/2)\nend", "  if #l == 0\
    \ then return nil end\n  if #l == 1 then\n    return l[1]\n  end\n  local half\
    \ = #l / 2\n  if l[half] > l[half+1] then\n    return median(l[half..half+1])\n\
    \  else\n    return median(l[half..half+2])\n  end\nend", "  if l==nil then\n\
    \    return nil\n  end\n  local n = #l\n  if n<=0 then\n    return nil\n  end\n\
    \  local t = l/2\n  if t*2+1 <= n then\n    return l[t]\n  else\n    return (l[t]\
    \ + l[t+1]) / 2.0\n  end\nend", '  if l == nil then return nil end', "  local\
    \ count = #l\n  if count == 0 then\n    return nil\n  else\n    local mid = math.floor((count\
    \ - 1) / 2)\n    if count == 1 then\n      return l[mid]\n    else\n      if l[mid]\
    \ > l[mid + 1] then\n        return median(l)\n      else\n        return median(l)\n\
    \      end\n    end\n  end\nend", "  return (tonumber(l) / 2 + 1) * (tonumber(l)\
    \ / 2 - 1)\nend", "  if l == nil then\n    return nil\n  end\n  if #l == 0 then\n\
    \    return nil\n  end\n  local idx = math.floor(#l / 2)\n  if idx == 0 or #l\
    \ % 2 == 1 then\n    return l[idx] or nil\n  end\n  local a = l[idx]:sub(1, idx\
    \ - 1)\n  local b = l[idx]:sub(idx)\n  if a == b then\n    return l[idx]\n  end\n\
    \  local c = l[idx]:sub(1, idx + 1)\n  local d = b - c\n  return d\nend", "  if\
    \ l[1] == nil then return nil end\n  if l[1] < l[2] then return l[2] end\n  if\
    \ l[1] > l[2] then return l[1] end\n  local mid = math.ceil((l[1]+l[2])/2);\n\
    \  if l[2]-mid*2 <= l[1] then return mid*2 end\n  return l[1] if mid*2 < l[1]\
    \ else mid*2\nend", "    if l == nil then return nil end\n    if #l == 1 then\n\
    \        return l[1]\n    end\n    if #l == 0 then\n        return nil\n    end\n\
    \    local pivot = l[#l]\n    local count = 0\n    for i,v in ipairs(l) do\n \
    \       if v == pivot then\n            count = count + 1\n            if count\
    \ == #l then\n                return pivot\n            end\n        end\n   \
    \ end\nend", "    local count = #l\n    if count == 0 then return 0 end", "  if\
    \ #l == 0 then\n    return nil\n  elseif #l == 1 then\n    return l[1]\n  else\n\
    \    return math.floor(l[math.ceil(#l / 2)])\n  end\nend", "  if #l == 0 then\n\
    \    return 0\n  elseif #l == 1 then\n    return l[1]\n  else\n    return (l[#l]\
    \ + median(l[#l - 1])) / 2\n  end\nend", "  local sorted = {}\n  table.sort(l)\n\
    \  if #l % 2 == 0 then\n    table.insert(sorted, l[#l])\n    table.insert(sorted,\
    \ l[#l])\n  else\n    table.insert(sorted, l[#l] / 2)\n    table.insert(sorted,\
    \ l[#l] / 2)\n  end\n  return sorted[#sorted]\nend", "    if not (type(l) == 'table')\
    \ then\n        error (\"median: input is not a table\", 2)\n    end\n    local\
    \ n = #l\n    if n == 2 then\n        if l[1] and l[1] <= l[2] then\n        \
    \    return l[1]\n        else\n            return l[2]\n        end\n    else\n\
    \        local m = math.floor(n/2)\n        if n % 2 == 1 then\n            return\
    \ (l[m-1] + l[m+1]) / 2\n        else\n            return l[m]\n        end\n\
    \    end\nend", "    if #l == 0 then\n        error'list l is empty'\n    end\n\
    \    if #l == 1 then\n        return l[1]\n    end\n    if #l % 2 == 0 then\n\
    \        return median(l[#l / 2 - 1] + l[#l / 2])\n    else\n        return median(l[#l\
    \ / 2] + l[#l / 2 - 1])\n    end\nend", "  local len = #l\n  if len > 1 then\n\
    \    local mid = math.floor(len / 2)\n    if len % 2 then\n      return (l[mid]\
    \ + l[mid+1]) / 2.0\n    else\n      return l[mid]\n    end\n  else\n    return\
    \ l[1]\n  end\nend", "    local n = #l\n    if n < 1 then return nil end", " \
    \ if not l then return 0 end\n  local half, count = 0, 1\n  local cur = l[half]\n\
    \  while cur do\n    cur = cur and l[half]\n    half = half + 1\n    count = count\
    \ + 1\n  end\n  return cur and count / 2 or 0\nend", "  local count = #l\n  if\
    \ count == 0 then\n    return nil\n  end\n  if count == 1 then\n    return l[1]\n\
    \  end\n  local middle = math.floor((count - 1) / 2)\n  if l[middle] == nil then\n\
    \    return nil\n  elseif l[middle] == l[middle - 1] then\n    return median(l,\
    \ middle - 1)\n  else\n    return l[middle]\n  end\nend", "  if not (#l == 0)\
    \ then\n    local mid = math.floor(#l) / 2\n    if #l % 2 == 1 then\n      return\
    \ l[mid]\n    else\n      local left = l[mid]\n      local right = l[mid + 1]\n\
    \      return (left + right) / 2\n    end\n  end\nend", "  local n = #l\n  if\
    \ n % 2 == 0 then\n    return l[(n / 2) - 1]\n  else\n    local middle = n / 2\n\
    \    return l[middle - 1] + median(sublist(l, middle))\n  end\nend", "  local\
    \ count = #l\n  if count == 0 then\n    return nil\n  elseif count == 1 then\n\
    \    return l[1]\n  end\n  \n  -- Assume even list size.\n  local half_count =\
    \ count / 2\n  \n  -- If count is not a multiple of the element size, get middle\
    \ elements.\n  -- If count is not a multiple of two, get one extra element from\
    \ the middle elements.\n  local middle = half_count\n  if count % 2 == 1 then\n\
    \    middle = half_count + 1\n  end\n  \n  -- Compute median in two parts: \n\
    \  --  a) middle elements, \n  --  b) middle elements + one extra.\n  local sorted_elements\
    \ = table.sort(l)\n  local median1, median2 = sorted_elements[middle], sorted_elements[middle\
    \ + 1]\n  \n  if median == nil then\n    return median1\n  else\n    return median\n\
    \  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this idea, but it's worth\
    \ noting that this solution will require a table sort which has complexity `O(n\
    \ log n)`, compared to solutions using `O(n)`.\n<|/ c |>\n<| c |>\n: Yes, I agree.\
    \ The complexity of the sorting is `O(n log n)` because it uses a merge-sort.\
    \ But if the list is not very long compared to the number of elements (`n` \u2264\
    \ `10`), then `O(n)` will suffice.\n<|/ c |>\n<| c |>\nYes, `O(n)` will suffice\
    \ for small lists. But if you use a `for` loop to run over the list to find the\
    \ median, the complexity will be `O(n)`, just as with any sort.\n<|/ c |>\n<|\
    \ c |>\nJust a note of caution here - if you use median as your sorting function\
    \ and have duplicate values, you'll lose the original sort order for those elements.\
    \ I used this technique to sort a list which had duplicates in it, but it didn't\
    \ give the results I was expecting (the order of the list was incorrect).\n<|/\
    \ c |>\n<| c |>\nIn fact, you need to sort the list before you find the median\
    \ for duplicates to work. Otherwise you might find the median of the list before\
    \ the duplicates are removed. If you have duplicates, just pick a distinct key\
    \ (e.g. an ID) and then apply your median function to the list.\n<|/ c |>\n<|\
    \ a |>\nHere is a solution which only requires O(log n) space, O(n) time, and\
    \ O(1) space.\nThe idea is that the median is computed from the largest ", " \
    \   if #l == 0 then return 0 end\n    if #l == 1 then return l[1] end\n    if\
    \ l[#l] ~= l[#l - 1] + 1 then -- Odd number of elements.\n        return l[#l\
    \ - 1] + math.floor((#l - 1) / 2.0) -- Middle.\n    end\n    local median = math.floor(#l\
    \ / 2)\n    local i = 1\n    while i <= median\n    do\n        median = median\
    \ + 1\n        if l[median] ~= l[median + 1] + 1 then\n            return l[median\
    \ + 1] + math.floor((median + 1) / 2.0)\n        end\n        i = i + 1\n    end\n\
    \    return l[median] + math.floor((median) / 2.0)\nend", "  local count = #l\n\
    \  if count == 0 then\n    return nil\n  end\n  if count == 1 then\n    return\
    \ l[1]\n  end\n  local mid = math.floor((count - 1) / 2)\n  if l[mid] < l[mid+1]\
    \ then\n    return median(l, mid + 1, count)\n  else\n    return median(l, mid,\
    \ count - 1)\n  end\nend", "    local half = math.floor(#l/2) - 1 -- Find median\
    \ by dividing list into two halves\n    if half > 1 then return median(l[half..half+1])\
    \ end\n    local median = l[half]\n    for i = half+2 to #l do\n        if l[i]\
    \ < median then\n            median = l[i]\n        elseif l[i] > median then\n\
    \            return median -- median is now in first half.\n        end\n    end\n\
    \    return median\nend", "  local total, n = 0, 0\n  for _, value in ipairs(l)\
    \ do\n    n = n + 1\n    total = total + value\n  end\n  if total == 0 then return\
    \ nil end\n  total = total / n\n  for i = #l + 1, 1 do\n    if total > 0 then\n\
    \      total = total - l[i]\n      n = n - 1\n    else\n      total = total +\
    \ l[i]\n    end\n    if n == 0 then return total end\n  end\nend", "  local count\
    \ = #l\n  if count == 0 then return nil end\n  -- if count is odd then return\
    \ the middle element\n  if count % 2 == 1 then\n    local mid = count / 2\n  \
    \  return mid\n  end\n  -- else return the average of the middle elements\n  local\
    \ mid1 = math.ceil(count / 2)\n  local mid2 = math.floor(count / 2)\n  return\
    \ mid2 + 0.5 * (mid1 - mid2)\nend", "   local n = #l\n   return n > 0 and n %\
    \ 2 == 1 and (n/2):(n - n/2):l\nend", "  if l == nil then\n    return nil\n  elseif\
    \ #l < 0 then\n    return nil\n  end\n  -- First sort by magnitude.\n  -- Then\
    \ sort by value, with equal values having equal sort keys.\n  -- (This preserves\
    \ the ordering of magnitude/value, but that ordering\n  -- is now lost.)\n  local\
    \ t = {}\n  for _, v in ipairs(l) do\n    t[math.abs(v)] = v\n  end\n  table.sort(t,\
    \ function(a, b) return a < b end)\n  for _, v in ipairs(l) do\n    if math.abs(v)\
    \ == t[math.abs(v)] then\n      return v\n    end\n  end\n  return nil\nend",
  "   local middle = math.floor((#l) / 2)\n   local median = (l[middle] + l[middle\
    \ - 1]) / 2\n   if middle % 2 == 1 then\n      median = median + l[middle + 1]\
    \ / 2\n   end\n   return median\nend", "  if not l then\n    return nil\n  end\n\
    \  local half = #l / 2\n  if half % 2 then\n    return median(l[half/2]) + median(l[half/2\
    \ - 1]) --median of [l/2] and [l/2-1]\n  else\n    return (l[half/2-1] + l[half/2])\
    \ / 2\n  end\nend", "  if l == nil then return nil end\n  local count = 1\n  local\
    \ median = l[1]\n  for i in l, nil:gmatch(\"(.-)\\1+\") do\n    count = count\
    \ + 1\n    median = median + (i - median) / count\n  end\n  return median\nend",
  "    local half = math.floor(#l / 2)\n    if #l % 2 == 0 then\n        return l[half]\n\
    \    else\n        return l[half - 1] + l[half]\n    end\nend", "  if l==nil then\
    \ return nil end\n  local n = #l\n  if n==0 then return nil end\n  -- If list\
    \ has even length, middle is ((n-1)/2)\n  local middle = math.floor((n-1)/2)\n\
    \  -- If list has odd length, middle is n/2\n  local middle_odd = middle+1\n \
    \ return middle, middle_odd, middle, n/2+1\nend", "  if #l < 1 then return nil\
    \ end\n  local half = #l / 2\n  if half < 1 then return l[half] end\n  local median\n\
    \  do\n    median = l[math.floor(#l / 2)]\n  end\n  for i = #l - 1, 1, -1 do\n\
    \    if l[i] < median then return median end\n    median = l[i]\n  end\n  return\
    \ median\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
