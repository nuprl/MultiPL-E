name: HumanEval_100_make_a_pile
language: lua
prompt: "-- Given a positive integer n, you have to make a pile of n levels of stones.\n\
  -- The first level has n stones.\n-- The number of stones in the next level is:\n\
  -- - the next odd number if n is odd.\n-- - the next even number if n is even.\n\
  -- Return the number of stones in each level in a list, where element at index\n\
  -- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile(3)\n\
  -- [3, 5, 7]\nlocal function make_a_pile(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_a_pile\n\
  \    lu.assertEquals(candidate(3), {3, 5, 7})\n    lu.assertEquals(candidate(4),\
  \ {4, 6, 8, 10})\n    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})\n    lu.assertEquals(candidate(6),\
  \ {6, 8, 10, 12, 14, 16})\n    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16,\
  \ 18, 20, 22})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local pile = { [1] = n }\n  for i = 2, n do\n    local level = {\
    \ [i + 1] = 0 }\n    for ii = 1, n do\n      level[ii] =\n        (pile[ii - 1]\
    \ + 1) %\n        (pile[ii] + 1)\n    end\n    pile = level\n  end\n  return pile\n\
    end", "    if n==0 then\n        return {}\n    elseif n==1 then\n        return\
    \ [1]\n    elseif n==2 then\n        return {1, 1}\n    else\n        local count\
    \ = {n}\n        local next=true\n        for i=1, n do\n            if next then\n\
    \                count[i+1]=count[i]+2\n            else\n                count[i+1]=count[i]+1\n\
    \            end\n            next=i%2\n        end\n        return count\n  \
    \  end\nend", "  local pile = {}\n  for i = 1, n do \n    table.insert(pile, (i+1)%2\
    \ == 0 and n or nil)\n  end\n  return pile\nend", "  if n <= 0 then return 0 end\n\
    \  if n <= 1 then return 1 end\n  return n / 2 * make_a_pile(math.floor(n/2))\
    \ + n - n % 2\nend", "    local pile = {}\n    pile[1] = n\n    if n <= 1 then\
    \ return pile end\n    for i = 2, n do\n        pile[i] = n * (math.floor((n -\
    \ 1) / 2) + math.floor((n - 1) / 2 + 1)) + n / 2\n    end\n    return pile\nend",
  "  if n <= 0 then\n    return nil\n  elseif n%2 == 0 then\n    return make_a_pile(n/2)*n\
    \ + (n%2 == 1 and 1 or 0)\n  else\n    return make_a_pile(n/2)*n + (n%2 == 0 and\
    \ 0 or 1)\n  end\nend", "  local pile = {}\n  for i = 1, n do\n    table.insert(pile,\
    \ n-i*2)\n    table.insert(pile, n-i*2+1)\n  end\n  return pile\nend", "  -- Base\
    \ case: return n\n  if n < 0 then\n    return {}\n  else\n    -- If n is even,\
    \ there are 2 stones in the next level\n    if n % 2 == 0 then\n      -- Return\
    \ the next even number which is n+1\n      return { n = n + 1 }\n    end", " \
    \   if n == 0 then\n        return {}\n    else\n        local n2 = math.floor(n/2)*2\n\
    \        return {\n            [math.floor(n/2) + 1] = (n2 - n%2) or (n2 + n%2)\n\
    \        }\n    end\nend\n</cell>\n<cell>", '  if n == 0 then return end', " \
    \ if n==0 then\n    return {1}\n  end\n  if n==1 then\n    return {1}\n  end\n\
    \  if n%2==1 then\n    return make_a_pile(n-1) + {n}\n  end\n  return make_a_pile(n-1)\
    \ + {n-1,n}\nend", "    if n == 0 then\n        return {}\n    end\n    local\
    \ pile = {}\n    local last_odd\n    local last_even\n    if n == 1 then\n   \
    \     pile[1] = n\n        last_odd = last_even = n\n    elseif n == 2 then\n\
    \        pile[1] = n\n        last_odd = last_even = n\n    elseif n % 2 == 1\
    \ then\n        local odd = math.floor(n/2)\n        local even = n - odd\n  \
    \      pile[1] = odd\n        last_odd = odd\n        last_even = even\n    else\n\
    \        local even = math.floor(n/2)\n        local odd = n - even\n        pile[1]\
    \ = odd\n        last_odd = odd\n        last_even = even\n    end\n    local\
    \ count = 1 -- number of levels in the pile\n    for i = 2, n do\n        count\
    \ = count + 1\n        local odd_count, even_count = pile[i], pile[count]\n  \
    \      pile[count] = odd_count + even_count\n    end\n    return pile\nend", " \
    \   local a = {}\n    local n = 1\n    while n <= n do\n        local a2 = if\
    \ n % 2 then n % 2 else n / 2 end\n        a[#a + 1] = a2\n        n = n + 1\n\
    \    end\n    return a\nend", "    local pile = {}\n    local num_stones = 0\n\
    \    if n == 1 then\n        pile[1] = 1\n        num_stones = 1\n    elseif n\
    \ ~= math.floor(n) then\n        pile[1] = math.floor(n)\n        num_stones =\
    \ n\n    else\n        local mod = math.floor(n) mod 2\n        num_stones = n\n\
    \        if mod ~= 0 then\n            pile[2] = math.floor(n/2)\n        else\n\
    \            pile[2] = 1\n        end\n    end\n    for i = 2, num_stones do\n\
    \        if i % 2 == 1 then\n            pile[i] = pile[i-1] + 1\n        else\n\
    \            pile[i] = pile[i-1]\n        end\n    end\n    return pile\nend",
  "  if n == 1 then\n    local result = {}\n    result[1] = 1\n    return result\n\
    \  else\n    local result = {}\n    result[1] = n % 2\n    local rest = n % 2\n\
    \    local next_even, next_odd = rest/2, rest/2\n    while next_even ~= 1 do\n\
    \      next_even = next_even/2\n    end\n    while next_odd ~= 0 do\n      result[2]\
    \ = next_odd\n      next_odd = next_odd/2\n    end\n    return make_a_pile(next_even)\n\
    \  end\nend", "  -- base case\n  if n == 0 then\n    return {}\n  end", "  local\
    \ lst = make_vector(n)\n  local odd = math.floor(n/2)\n  local even = math.mod(n,\
    \ 2)\n  if even then\n    lst[#lst+1] = even\n  elseif odd then\n    lst[#lst+1]\
    \ = odd\n    odd = odd+1\n    lst[#lst+1] = odd\n  end\n  return lst\nend", " \
    \ local pile = {}\n  repeat\n    pile[#pile + 1] = n\n  until (n % 2)\n  repeat\n\
    \    pile[#pile + 1] = #pile\n    pile[#pile + 1] = (n + 1) % 2\n  until (n %\
    \ 2)\n  return pile\nend\nmake_a_pile(3)\n</cell>\n<text>\nProblem 9", "  local\
    \ pile = {}\n  local last = 0\n  for i = 1, n do\n    if i%2==0 then\n      last\
    \ = last + math.floor(math.random()*(i+1))\n    else\n      last = last + math.ceil(math.random()*(i+1))\n\
    \    end\n    table.insert(pile, last)\n  end\n  return pile\nend", "  local pile\
    \ = {}\n  local p = 0\n  if n <= 1 then\n    return pile\n  elseif n % 2 == 1\
    \ then\n    p = (n / 2) + 1\n    pile[p] = 1\n    pile[p + 1] = 1\n  else\n  \
    \  p = math.floor((n + 1) / 2)\n    pile[p] = 1\n    pile[p + 1] = n / 2\n  end\n\
    \  return pile\nend", "  return function()\n    if n == 1 then\n      return [1]\n\
    \    end\n    local t = make_a_pile(n/2)\n    if math.floor(n/2) ~= n then\n \
    \     t[#t+1] = math.floor(n/2)\n    end\n    return t\n  end\nend", "   if n\
    \ < 1 then\n      return nil\n   elseif n == 1 then\n      return [1]\n   else\n\
    \      local pile = {}\n      local level = 0\n      local next_odd\n      local\
    \ next_even\n      for i = 1, n do\n         level = level + 1\n         if next_odd\
    \ ~= 1 then -- the next odd number\n            next_odd = next_odd+1\n      \
    \   else\n            next_even = next_even+1\n         end\n         pile[level]\
    \ = pile[level] + 1\n      end\n      return pile\n   end\nend", "  assert(n >\
    \ 0)\n  if n == 1 then return [1] end\n  if n == 2 then return [1, 3] end\n  if\
    \ n == 3 then return [2, 3] end\n  if n % 2 == 0 then return make_a_pile(n/2):append(n/2)\
    \ end\n  return make_a_pile(n/2):append(n/2):append(n/2):append(n/2)\nend", " \
    \ -- The first level has n stones.\n  local pile = {}\n  -- The next level has\
    \ (n / 2) stones.\n  pile[math.floor(n/2)] = math.floor(n/2)\n  -- The next level\
    \ has (n - n / 2) stones.\n  pile[math.floor((n-n/2)*2)+1] = math.floor((n-n/2)*2)\n\
    \  return pile\nend\nmake_a_pile(3)\n</cell>\n<code language=julia-1.6>\nmake_a_pile(4)\n\
    </cell>\n<text>\n4.7 Optimization\nAs a general optimization problem, we want\
    \ to find the maximum value of a function $f(x)$ on some interval $[a,b]$.", " \
    \   local pile = {}\n    local num_stones = (n * 2) + 1\n    for i = 1, num_stones,\
    \ 2 do pile[(i-1)/2] = i end\n    return pile\nend", "    local pile = {}\n  \
    \  for i = 1, n do\n        pile[i] = i\n    end\n    for i = 2, n do\n      \
    \  local n = math.floor((i+1)/2)\n        pile[i] = n\n    end\n    return pile\n\
    end", "    if n == 0 then\n        return nil\n    end\n    if n == 1 then\n \
    \       return {1}\n    end\n    local result = {n}\n    local even = math.floor(n/2)\n\
    \    local odd = math.floor(n/2)+1\n    for _ = 1, odd do\n        table.insert(result,\
    \ n)\n    end\n    table.insert(result, even)\n    return result\nend", "    if\
    \ n <= 1 then\n        return [1]\n    end\n    local n = n % 2\n    local count\
    \ = 0\n    local result\n    if n == 1 then\n        result = [1]\n    else\n\
    \        result = make_a_pile(n-1) + make_a_pile((n+1)/2)\n    end\n    count\
    \ = count + #result\n    result[#result+1] = count\n    return result\nend", " \
    \   local pile = {}\n    if n == 0 then\n        return pile\n    end\n    if\
    \ n % 2 == 1 then\n        local level = n % 2\n        local count = math.floor((n\
    \ - level) / 2)\n        for i = 1, count do\n            table.insert(pile, level)\n\
    \        end\n        table.insert(pile, count + 1)\n    else\n        local level\
    \ = math.floor((n - 1) / 2)\n        table.insert(pile, level)\n    end\n    return\
    \ pile\nend", "    local pile = {}\n    if n == 1 then\n        pile[1] = n\n\
    \    else\n        if n % 2 == 0 then\n            pile[1] = n\n        else\n\
    \            pile[1] = n % 2 + 1\n        end\n    end\n    for i = 2, n - 1 do\n\
    \        if i % 2 then\n            pile[i] = pile[i - 1] + 1\n        else\n\
    \            pile[i] = pile[i - 1]\n        end\n    end\n    return pile\nend",
  "   local pile = {}\n   for i = 1,n do\n      if i % 2 ==0 then\n         pile[i]\
    \ = i\n      else\n         pile[i] = i+1\n      end\n   end\n   return pile\n\
    end", "  if n == 0 then\n    return {}\n  elseif n%2 == 0 then\n    -- Even number\n\
    \    local n = math.floor(n)\n    local odds = [n, n+1, n+2]\n    local evens\
    \ = [n+1, n+2, n+3]\n    -- odds.next = make_a_pile(odds[1])\n    -- evens.next\
    \ = make_a_pile(evens[1])\n    return odds.next or make_a_pile(odds[1]) or evens.next\
    \ or make_a_pile(evens[1])\n  else\n    -- Odd number\n    local n = math.floor(n)\n\
    \    local odds = [n, n+1, n+2]\n    local evens = [n+1, n+2, n+3]\n    -- odds.next\
    \ = make_a_pile(odds[2])\n    -- evens.next = make_a_pile(evens[2])\n    return\
    \ odds.next or make_a_pile(odds[2]) or evens.next or make_a_pile(evens[2])\n \
    \ end\nend", "  local pile = {}\n  \n  local odd = n % 2\n  local next_even =\
    \ n / 2\n  \n  if odd then\n    pile[1] = next_even\n    if next_even % 2 ~= 0\
    \ then\n      pile[2] = next_even\n    end\n  else\n    pile[1] = next_even\n\
    \    pile[2] = next_odd\n  end\n  \n  for i = 2, n do\n    local level = pile[i]\n\
    \    pile[i] = level + level % 2\n  end\n  \n  return pile\nend", "  local pile\
    \ = {}\n  if n == 0 then\n    return pile\n  elseif n >= 0 then\n    -- If n is\
    \ even, we need to add an extra stone\n    if n % 2 == 0 then\n      table.insert(pile,\
    \ n)\n      return pile\n    end", "  local list = { }\n  for i = 1, n do\n  \
    \  list[i + 1] = i\n  end\n  return list\nend", "  if n < 2 then return {n} end\n\
    \  local a = make_a_pile(n-1)\n  local odd = math.floor(n/2)*2+1\n  local even\
    \ = math.floor(n/2)*2\n  if even > n then even = n end\n  if even > n then even\
    \ = n end\n  table.insert(a, odd)\n  table.insert(a, even)\n  return a\nend",
  "  local pile = {}\n  pile[1] = n\n  local i = 1\n  while i ~= n do\n    local odd_or_even\n\
    \    if i ~= n then\n      odd_or_even = i % 2 ~= 0 and \"odd\" or \"even\"\n\
    \    end\n    pile[i] = odd_or_even\n    if n ~= i then\n      i = i + (not odd_or_even)\n\
    \    else\n      i = i + 1\n    end\n  end\n  return pile\nend", "  local pile\
    \ = {}\n  repeat\n    table.insert(pile, math.floor(n/2))\n    n = math.mod(n,\
    \ 2)\n  until n\n  return pile\nend", "  if n < 0 then\n    return nil\n  end",
  "  assert(n >= 1, 'Expected positive integer')\n  local pile = {}\n  local is_odd\
    \ = n % 2\n  local num_stones = n\n  if is_odd then num_stones = n + 1 end\n \
    \ local i = 1\n  while num_stones > 0 do\n    table.insert(pile, (num_stones %\
    \ 2 == 0 and num_stones or num_stones + 1))\n    if is_odd then num_stones = num_stones\
    \ / 2 else num_stones = num_stones / 2 + 1\n    i = i + 1\n  end\n  return pile\n\
    end", "\t-- Base case\n\tif n == 1 then\n\t\treturn {n}\n\t-- Even case\n\telseif\
    \ n % 2 == 0 then\n\t\treturn {n % 2 + 1, make_a_pile(n-2)}\n\t-- Odd case\n\t\
    else\n\t\treturn {n % 2, make_a_pile(n-1)}\n\tend\nend", "\t-- Base case\n\tif\
    \ not n then\n\t\treturn nil\n\tend", "  local p = {}\n  for i = 1, n do\n   \
    \ p[i] = math.floor(n/2) + 1\n    n = math.floor((n % 2) * 2 - 1)\n  end\n  return\
    \ p\nend", "  if n == 0 then return {} end\n  local pile = {}\n  local count =\
    \ 1\n  repeat\n    table.insert(pile, n)\n    count = count + n % 2 == 0 and n\
    \ / 2 or n\n    n % 2 == 0 and n = n / 2\n  until n > 0\n  return pile\nend",
  "  local p = {}\n  for i = 1, n do\n    if n % 2 == 1 then\n      p[i + 1] = n +\
    \ 1 - (2 * i - 1)\n    else\n      p[i + 1] = i + 1\n    end\n  end\n  return\
    \ p\nend", "  -- Base case\n  if n == 0 then\n    local a = {}\n    a[1] = 1\n\
    \    return a\n  end\n  -- Middle case\n  if n % 2 == 0 then\n    local a = {}\n\
    \    a[1] = 1\n    for i = 2 to (n-1) do\n      a[i+1] = i\n    end\n    return\
    \ a\n  end\n  -- Recursive case\n  local a = {}\n  a[1] = 1\n  local r = n - 1\n\
    \  local t = make_a_pile(r)\n  for i = 2 to (r-1) do\n    t[i] = t[i] + t[i+1]\n\
    \  end\n  return t\nend", "  if n == 0 then\n    return {}\n  elseif n == 1 then\n\
    \    return {1}\n  else\n    local odds = 2\n    local evens = 2\n    local levels\
    \ = make_a_pile(n-1)\n    local next_level = levels[n]\n    if next_level % 2\
    \ == 0 then\n      evens = next_level\n    else\n      odds = next_level\n   \
    \ end\n    return setmetatable(levels, {__newindex = function()\n      if n ==\
    \ 1 then\n        levels[n] = next_level\n        return levels[n]\n      else\n\
    \        levels[n] = odds * n + evens\n        return levels[n]\n      end\n \
    \   end})\n  end\nend", "  if n == 1 then return [1]\n  elseif n % 2 == 1 then\
    \ return make_a_pile(n / 2) + [n / 2 + 1]\n  else return make_a_pile(n / 2) +\
    \ [n / 2]\nend", "    if n == 1 then\n        return {}\n    end", "    local\
    \ pile = {}\n    local next_even_level\n    local next_odd_level", "  if n < 1\
    \ then return nil end\n  if n == 1 then return [1] end", "    local pile = table.new()\n\
    \    local count = 0\n    for i = 1, n do\n        table.insert(pile, n)\n   \
    \     count = count + (i%2==0 and n or n-(i+1))\n    end\n    return pile\nend",
  "  local p = {}\n  for i = 1, n do\n    p[i + 1] = math.floor((i + 1)/2)*2\n  end\n\
    \  return p\nend", "  -- Base case\n  if n < 1 then\n    return [1]\n  end\n \
    \ -- Recursion\n  local levels = make_a_pile(n-1)\n  local stones = levels[math.floor(n/2)]\n\
    \  if n % 2 == 1 then\n    stones = stones + math.floor(n/2)\n  end\n  return\
    \ stones + levels[#levels]\nend", "  if n < 1 then\n    return {}\n  elseif n\
    \ == 1 then\n    return [1]\n  elseif n % 2 == 1 then\n    return make_a_pile(n\
    \ * 2) + [n + 1]\n  else\n    return make_a_pile((n / 2) * 2) + [n + 1]\n  end\n\
    end", "  if n == 1 then return {n} end\n  if n % 2 == 1 then\n    local m = n\
    \ / 2\n    return make_a_pile(m):append(n + m - 1):append(n / 2)\n  else\n   \
    \ local m = n / 2\n    return make_a_pile(m):append(n / 2):append(n + m - 1)\n\
    \  end\nend", "    if n == 1 then\n        return 1\n    elseif n == 2 then\n\
    \        return 3\n    end\n    local pile = {}\n    for i = 1, n do\n       \
    \ pile[(i+1)%2] = (i+1) * 2\n    end\n    local next_odd_n = next_odd(n)\n   \
    \ if next_odd_n > 0 then\n        table.insert(pile, n)\n    end\n    local next_even_n\
    \ = next_even(n)\n    if next_even_n ~= 0 then\n        table.insert(pile, next_even_n)\n\
    \    end\n    return pile\nend", "    local res = {}\n    for i = 1, n do\n  \
    \      if i % 2 == 1 then\n            res[i + 1] = i\n        else\n        \
    \    res[i + 1] = res[i] + (2 * (i % 2 == 0))\n        end\n    end\n    return\
    \ res\nend", "   assert(type(n) == 'number' and n >= 0)\n   local p = {[0] = 0}\n\
    \   for idx = 1, n do\n      local n = math.floor((math.floor(n / 2.0) + math.sqrt(2))\
    \ / 2)\n      local a = p.max\n      if n <= 0 then break end\n      if n % 2\
    \ == 0 then\n         a = a + 1\n      else\n         a = a + n\n      end\n \
    \     table.insert(p, a)\n   end\n   return p\nend", "  if n <= 0 then return\
    \ end\n  local pile = {}\n  if n % 2 == 1 then pile[#pile+1] = n end\n  for i=#pile,1,-1\
    \ do\n    pile[i] = pile[i-1] + 1\n    if pile[i] % 2 == 0 then\n      pile[#pile+1]\
    \ = i\n    end\n  end\n  return pile\nend", "   if n % 2 == 0 then\n      return\
    \ make_a_pile(n - 1) + math.floor(n/2)\n   else\n      return make_a_pile(n -\
    \ 1) + math.floor(n/2)\n   end\nend", "  assert(n >= 0, 'n must be positive')\n\
    \  assert(n % 2 == 0, 'n must be even')\n  local pile = {}\n  for i = 1, n do\n\
    \    if math.floor(i/2) == i then\n      pile[i] = n + 1\n    else\n      pile[i]\
    \ = i/2\n    end\n  end\n  return pile\nend", "    local p = [n+1]\n    for i\
    \ = 1, n do\n        local odd = i % 2\n        if odd then\n            p[i+1]\
    \ = odd + p[i]\n        else\n            p[i+1] = i + p[i]\n        end\n   \
    \ end\n    return p\nend", "  if n % 2 == 0 then\n    return make_a_pile(n-2)\n\
    \  else\n    local next_odd\n    if n%2 ~= 0 then\n      next_odd= nextpow2(nextpow2(n))\n\
    \    else\n      next_odd= n\n    end\n    local next_even\n    if n%2 == 1 then\n\
    \      next_even= nextpow2(n+1)\n    else\n      next_even= n\n    end\n    return\
    \ { next_odd, next_even }\n  end\nend", "  -- base case\n  if n == 1 then\n  \
    \  return [1]\n  -- recursive case\n  elseif n%2 ~= 0 then\n    -- odd case\n\
    \    local pile = make_a_pile((n/2)+1)\n    pile = insert(pile,1, (n%2)+1)\n \
    \   return pile\n  else\n    -- even case\n    local pile = make_a_pile((n/2)+1)\n\
    \    pile = insert(pile,1, (n%2)+1)\n    pile = insert(pile,1)\n    return pile\n\
    \  end\nend", "  if n <= 0 then\n    return nil\n  end\n  -- If n is odd, then\
    \ we add one stone to each level.\n  if n % 2 == 0 then\n    return make_a_pile(n\
    \ - 1) + 1\n  end\n  -- If n is even, then we add two stones to each level.\n\
    \  if n % 2 == 1 then\n    return make_a_pile(n - 1) + 2\n  end\n  -- If n is\
    \ odd, then we add three stones to each level.\n  if n % 3 == 0 then\n    return\
    \ make_a_pile(n - 1) + 3\n  end\n  -- If n is even, then we add four stones to\
    \ each level.\n  if n % 3 == 1 then\n    return make_a_pile(n - 1) + 4\n  end\n\
    \  -- Otherwise, we add five stones to each level.\n  return make_a_pile(n - 1)\
    \ + 5\nend", "\tassert(n > 0, \"n can't be zero\")\n\tlocal pile = setmetatable({},\
    \ { __index = {} })\n\tpile[1] = 0\n\tpile[2] = n - 1\n\tpile[3] = 0\n\tif n%2\
    \ == 1 then\n\t\tpile[2] = pile[2] + 1\n\tend\n\treturn pile\nend", "  assert(n\
    \ > 0, \"make_a_pile: n must be positive\")\n  assert(n % 2 == 0, \"make_a_pile:\
    \ n must be even\")\n  local result = {}\n  for i = 1, n do result[i] = n end\n\
    \  if n ~= 0 then\n    result[math.floor(n/2)+1] = n / 2\n  end\n  return result\n\
    end", "  if n == 2 then return [1] end\n  local stones = make_a_pile(n-1)\n  if\
    \ n % 2 == 1 then\n    table.insert(stones, stones[#stones] + 2)\n  else\n   \
    \ table.insert(stones, stones[#stones] + 3)\n  end\n  return stones\nend", " \
    \ local pile = {}\n  local n = 1\n  while n <= n do\n    local i = 1\n    if n\
    \ & 1 then\n      i = i + 1\n    end\n    if n & 2 then\n      i = i + 1\n   \
    \ end\n    pile[i] = pile[i] or n\n    n = n + 1\n  end\n  return pile\nend",
  "  if n == 2 then\n    local pile = {}\n    pile[1] = n\n    return pile\n  else\n\
    \    local pile = {}\n    local odd\n    local even\n    if n % 2 == 1 then\n\
    \      odd = n - 1\n      even = n\n    else\n      odd = n\n      even = n -\
    \ 1\n    end\n    local level = 1\n    pile[1] = odd\n    local next_level = even\n\
    \    while level ~= next_level do\n      pile[level+1] = next_level\n      next_level\
    \ = odd:next_level_of(even)\n      level = level + 1\n    end\n    return pile\n\
    \  end\nend", "    if n == 0 then return 0 end\n    if n % 2 ~= 0 then\n     \
    \   return make_a_pile(n - 1) + 1 -- next odd number\n    else\n        return\
    \ make_a_pile(n - 2) + 1 -- next even number\n    end\nend", "   assert(n > 0)\n\
    \   local p = [n]\n   if n % 2 == 0 then\n      for i = 1, (n - 1) do\n      \
    \   p[i+1] = math.floor(p[i] / 2)\n      end\n   else\n      for i = 1, (n - 1)\
    \ do\n         p[i+1] = p[i] / 2\n      end\n   end\n   return p\nend", "  --\
    \ TODO: use a dynamic array instead of repeatedly creating a new array for each\
    \ level.\n  -- TODO: This code would be more readable if you replaced the loop\
    \ with an if-else\n  -- statement that simply did two checks for odd and even\
    \ n, respectively.\n  local levels = { [1] = 1 }\n  for i = 2, n do\n    levels[i]\
    \ = levels[i-1]\n    levels[#levels+1] = levels[#levels] + 2 ^ (i-1)\n  end\n\
    \  return levels\nend", "  if n == 0 then\n    return [1]\n  end", "  local pile\
    \ = {}\n  local nlevels = math.floor(n/2) -- the first n levels have n-1 stones\n\
    \  pile[1] = n\n  if n%2 ~= 0 then -- the first level has even number of stones\n\
    \    nlevels = nlevels + 1\n  end\n  for i = 2, nlevels do\n    pile[i] = pile[i-1]\
    \ + i/2\n  end\n  return pile\nend", "  if n < 1 then\n    error('n must be >\
    \ 0.')\n  end\n  local pile = {}\n  if n <= 1 then\n    return table.tolist(pile)\n\
    \  end\n  local n = math.ceil(n)\n  local next_odd\n  if n % 2 == 0 then\n   \
    \ next_odd = n\n  else\n    next_odd = n + 1 -- we round up.\n  end\n  local next_even\
    \ = n + 1\n  local count = 0\n  for i = 1, next_odd do\n    count = count + 1\n\
    \    pile[i] = count\n  end\n  for i = 1, next_even do\n    count = count + 1\n\
    \    pile[i] = count\n  end\n  return table.tolist(pile)\nend", "  if n == 1 then\n\
    \    return [1]\n  else\n    if n % 2 == 0 then\n      return make_a_pile(math.floor(n/2))\
    \ + [math.floor(n/2)]\n    else\n      return make_a_pile(math.floor(n/2)) + [math.floor(n/2)+1]\n\
    \    end\n  end\nend\nprint(make_a_pile(5))", "  -- base case\n  if n==0 then\
    \ return {} end", "  local pile = {}\n  if n == 0 then\n    return pile\n  end\n\
    \  local i = 1\n  local next_odd = 0\n  local next_even = 1\n  while i <= n do\n\
    \    pile[i] = next_odd\n    next_even = next_even + 1\n    if next_even % 2 ~=\
    \ 0 then\n      next_odd = next_odd + 1\n    end\n    i = i + 1\n  end\n  return\
    \ pile\nend", "  -- Base case: return the last level of the pile.\n  if n <= 0\
    \ then\n    return 1\n  end\n  \n  -- Recursive case: add an even number of stones\
    \ to the pile, and divide by two\n  -- to get a number of stones in the next level.\
    \ Also add an odd number of stones\n  -- to the pile.\n  return 2*make_a_pile(n/2)\
    \ + n/2\nend", "  if n == 1 then\n    return { 1 }\n  elseif n % 2 == 0 then\n\
    \    return make_a_pile(n / 2) -- even number of levels\n  else\n    return make_a_pile((3\
    \ * n) + 1) -- odd number of levels\n  end\nend", "    local pile = {}\n    for\
    \ i = 1, n do\n        -- Odd numbers\n        if n ~= 0 and n % 2 == 1 then\n\
    \            pile[i] = n\n            n = math.floor((n - 1) / 2)\n          \
    \  pile[i + 1] = n\n        end\n        -- Even numbers\n        if n ~= 0 and\
    \ n % 2 == 0 then\n            pile[i] = n\n            n = math.floor((n - 1)\
    \ / 2)\n            pile[i + 1] = n\n        end\n    end\n    return pile\nend\n\
    </cell>\n<text>\nExercise 3\nThe code below will help you solve exercise 2.",
  "  return assert(tonumber(n))\n    and assert(n % 2 == 0)\n    and tonumber(math.floor(n/2))\n\
    \    and tonumber(math.ceil(n/2))\n    or assert(n % 2 == 1)\n    and tonumber(math.floor(n/2))\n\
    \    or assert(n % 2 == 0)\n    and tonumber(math.ceil(n/2))\nend", "    local\
    \ pile = {}\n    pile[1] = n\n    local i = 1\n    while n > 0 do\n        local\
    \ n = math.floor(n / 2)\n        if n % 2 then\n            pile[i] = n + 1\n\
    \        end\n        i = i + 1\n    end\n    return pile\nend", "    if n < 2\
    \ then\n        return n\n    end\n    local pile = {}\n    for i = 1, n do\n\
    \        pile[i] = n + 1\n    end\n    local next_odd\n    if n % 2 ~= 0 then\n\
    \        next_odd = math.ceil(n / 2)\n    else\n        next_odd = math.floor(n\
    \ / 2)\n    end\n    pile[next_odd] = n + 1\n    return pile\nend", "  if n ==\
    \ 0 then\n    return { }\n  end\n  local result = make_a_pile(n / 2) + { n = n\
    \ % 2 }\n  if n > 1 then\n    result[1] = n\n  end\n  return result\nend", " \
    \ local p = {}\n  for i = 1, n do\n    if math.mod(i,2) == 0 then\n      p[i+1]\
    \ = n+1\n    else\n      p[i+1] = n\n    end\n  end\n  return p\nend", "  if n\
    \ == 1 then\n    return [1]\n  else\n    local even, odd = n % 2, math.floor(n/2)\n\
    \    return make_a_pile(odd) + [even]\n  end\nend\n</code>\nIt works by recursing\
    \ down to 1 from the given number, which then is added the odd or even number\
    \ of stones.  This gives the correct answer with even or odd number of stones.\n\
    <code>\nprint(make_a_pile(3))\nprint(make_a_pile(4))\nprint(make_a_pile(7))\n\
    print(make_a_pile(11))\nprint(make_a_pile(13))\n</code>\nOutput:\n<code>\n[3,\
    \ 5, 7]\n[3, 7]\n[5, 7]\n[7, 7]\n</code>\n<|/ a dscore=1 tags=arrays,loops,lua\
    \ |>\n<| c |>\nGreat. Nice solution.\n<|/ c |>\n<| a dscore=0 tags=arrays,loops,lua\
    \ |>\nHere's a short answer, which can easily be extended for any number of levels:\n\
    <code>", "  local pile = {}\n  local i = 0\n  while n >= 1 do\n    if n % 2 ==\
    \ 1 then\n      pile[i] = n\n      n = n/2\n      i = i+1\n    else\n      pile[i]\
    \ = n\n      n = n/2\n      i = i+1\n      pile[i] = n\n      n = n/2\n      i\
    \ = i+1\n    end\n  end\n  return pile\nend", "    local levels = {}\n    local\
    \ n\n    if n==0 then\n        return 0\n    else\n        if n%2==0 then\n  \
    \          n=n/2\n        else\n            n=3*n+1\n        end\n    end\n  \
    \  for i=1,n,2 do\n        levels[i]=i\n    end\n    return levels\nend", "  if\
    \ n < 1 then\n    return nil\n  end\n  local pile = {}\n  for i = 1, n do\n  \
    \  table.insert(pile, n + 2 * i % 2)\n  end\n  return pile\nend", "    if n ==\
    \ 1 then\n        local x = {}\n        x[1] = n\n        return x\n    end\n\
    \    if n == 2 then\n        local x = {}\n        x[1] = n\n        x[2] = 2\
    \ * n\n        return x\n    end", "    local pile = {}\n    local max_level =\
    \ math.floor(n/2)\n    for i = 1, max_level do\n        local level = math.floor(i/2)\n\
    \        pile[level] = n - (2*i+1)\n        if n % (2*i+1) ~= 0 then\n       \
    \     pile[level+1] = pile[level]/2\n        end\n    end\n    return pile\nend",
  "    local pile = table.make({})\n    for i = 1, n do\n        table.insert(pile,\
    \ math.floor((n + 1) / 2))\n    end\n    return pile\nend", "  assert(n >= 0 and\
    \ n % 2 == 0, \"First argument must be a positive integer and second must be a\
    \ positive odd integer.\")\n  assert(n <= 100 and n % 2 == 0, \"First argument\
    \ must be a positive integer and second must be a positive odd integer.\")\n \
    \ assert(n == 1 or n == 2, \"First argument must be a positive integer and second\
    \ must be a positive even integer.\")", "    local p = [n]\n    if n == 0 then\n\
    \        return p\n    end\n    if n % 2 == 1 then\n        p[#p + 1] = n / 2\n\
    \        p[#p + 1] = n / 2 + 1\n    else\n        p[#p + 1] = n / 2\n    end\n\
    \    local t = make_a_pile(n / 2)\n    if n ~= 0 then\n        t[#t + 1] = n /\
    \ 2\n    end\n    return t\nend", "  if n < 2 then return [1] end\n  return make_a_pile(n-2)..n+make_a_pile(n-1)\n\
    end", "  local pile = {}\n  for i = 1, n do\n    local odd = math.floor(i/2)\n\
    \    local even = math.mod(i, 2)\n    pile[#pile+1] = odd+even\n  end\n  return\
    \ pile\nend\n</cell>\n<cell>\n%preview make_a_pile\n</cell>\n<cell>", "    local\
    \ pile = {}\n    for i=1,n do\n        if n%2 == 1 then\n            table.insert(pile,math.ceil(n/2))\n\
    \        else\n            table.insert(pile,math.floor(n/2))\n        end\n \
    \   end\n    return pile\nend", "\tn = math.floor(n)\n\tif n >= 0 then\n\t\tif\
    \ n % 2 == 1 then\n\t\t\tn = n + 2\n\t\telse\n\t\t\tn = n / 2\n\t\tend\n\tend\n\
    \tlocal p = {n}\n\tfor i = 1, n do\n\t\tif i % 2 == 1 then\n\t\t\tp[i + 1] = p[i\
    \ + 1] + 1\n\t\telse\n\t\t\tp[i + 1] = p[i + 1] + p[i/2]\n\t\tend\n\tend\n\treturn\
    \ p\nend", "    if n == 0 then\n        return {}\n    elseif n == 1 then\n  \
    \      return {n}\n    else\n        local pile = {}\n        pile[1] = n\n  \
    \      for i = 2, n do\n            local odd = i % 2 == 1\n            if odd\
    \ then\n                pile[i] = pile[i-1] + 2\n            else\n          \
    \      pile[i] = pile[i-1] + 1\n            end\n        end\n        return pile\n\
    \    end\nend\n</cell>\n<code language=julia-0.6>\n@time make_a_pile(3);\n</cell>\n\
    <text>\nWe have now created the function make_a_pile() that creates a pile\nwith\
    \ n levels of stones.\nNow we are going to solve the problem of counting the number\
    \ of ways a\nperson can eat in n levels.\nA person can eat in n levels if he can\
    \ get to the nth level and the\nn+1 level, and so on. In other words, a person\
    \ can eat in level n\nif he can get to the nth level, the n+1 level, and the n+2\
    \ level, and so on.", "    local ret = {}\n    local odd = 0\n    local even =\
    \ 0\n    for i = 1, n do\n        if i mod 2 == 0 then\n            even = even+1\n\
    \        else\n            odd = odd+1\n        end\n        ret[i] = odd\n  \
    \  end\n    return ret\nend\n</cell>\n<text>\nProblem 3b\nMake a function to check\
    \ whether a number is prime:", "    local pile = {}\n    if n <= 0 then\n    \
    \    return pile\n    end\n    local next_odd_n, next_even_n", "    local ans\
    \ = {}\n    for i = 1, n do\n        local n = math.floor(i * (i + 1) / (2 * n)\
    \ + 0.5)\n        if math.mod(i, 2) == 0 then\n            n = n + 1\n       \
    \ end\n        ans[i] = n\n    end\n    return ans\nend", "  if n<0 then return\
    \ nil end\n  if n==0 then return [1] end\n  local num_odd = n%2\n  local num_even\
    \ = n/2\n  return num_odd..make_a_pile(num_even)\nend\n</cell>\n<code language=xeus-cling-cpp14>\n\
    print(make_a_pile(-3))\n</cell>\n<code language=xeus-cling-cpp14>\nprint(make_a_pile(1))\n\
    print(make_a_pile(2))\nprint(make_a_pile(3))\nprint(make_a_pile(4))\nprint(make_a_pile(5))\n\
    </cell>\n<code language=xeus-cling-cpp14>\nprint(make_a_pile(6))\n</cell>\n<code\
    \ language=xeus-cling-cpp14>\nprint(make_a_pile(7))\n</cell>\n<text>\nQuestion\
    \ 3. Write a function that takes a positive integer N and returns the string \"\
    True\" or \"False\" depending on whether there is at least 1 pile of stones of\
    \ size N. \nThe function should return \"True\" if the piles are non-empty, and\
    \ \"False\" otherwise.", "  local list = []\n  for i = 0, n-1 do\n    local next\
    \ = tonumber(math.floor(tonumber(math.random(math.floor(tonumber(n/2)+1))*2+1)))\n\
    \    local num = tonumber(math.floor(tonumber(math.random(math.floor(tonumber(n/2)+1))*2+1)))\n\
    \    list.append(next-num)\n  end\n  return list\nend", "  -- Base cases: no stones,\
    \ even number of stones\n  if n < 1 then return nil end\n  if n == 1 then\n  \
    \  return n\n  end", "  local ret = {}\n  for i = 1, n do\n    ret[i + 1] = i\
    \ % 2 == 0 and i + 1 or i + 1\n  end\n  return ret\nend", "    local pile = {}\n\
    \    local i = 0\n    while i <= n do\n        if n % 2 == 0 then\n          \
    \  pile[i] = n\n            i = i + 1\n        else\n            pile[i] = n +\
    \ 1\n            i = i + 1\n        end\n        n = n + 1\n    end\n    return\
    \ pile\nend", "  local p = []\n  for i = 1, n do\n    table.insert(p, n)\n   \
    \ if n ~= 0 and ((i-1) % 2) == 0 then\n      n = n - ((n-1)/2) - 1\n    else\n\
    \      n = n - ((n-1)/2) + 1\n    end\n  end\n  return p\nend\nmake_a_pile = make_a_pile",
  "  local n = 0\n  while n ~= n do\n    local next = (n % 2 == 0 and n or n + 2)\n\
    \    table.insert(res, next)\n    n = next\n  end\n  return res\nend", "  local\
    \ list = {}\n  for i = 1, n do\n    list = list + [math.floor(i/2):i%2]\n  end\n\
    \  return list\nend", "    local pile = {}\n    if n == 2 then\n        pile[1]\
    \ = n\n        return pile\n    end\n    if n == 1 then\n        pile[1] = n\n\
    \        return pile\n    end\n    if n == 0 then\n        pile[1] = 1\n     \
    \   return pile\n    end\n    local result = make_a_pile(math.floor(n/2))\n  \
    \  local num = n % 2 == 0\n    local pile2 = result\n    if num then\n       \
    \ pile2[1] = result[1] + 1\n    else\n        pile2[1] = result[1]\n    end\n\
    \    return pile2\nend", "  -- Base cases\n  if n <= 0 then return nil end\n \
    \ if n == 1 then return [1] end\n  if n == 2 then return [2, 4] end", "    local\
    \ stones = n\n    local next_odd\n    if n % 2 == 1 then\n        next_odd = n\
    \ / 2 + 1\n    else\n        next_odd = 2 * n + 1\n    end\n    local next_even\n\
    \    if n % 2 == 0 then\n        next_even = n / 2\n    else\n        next_even\
    \ = 2 * n\n    end\n    local pile = {}\n    for i=1,n do\n        pile[i] = stones\n\
    \        stones = stones - next_odd * (i + 1)\n        stones = stones - next_even\
    \ * (i + 1)\n    end\n    return pile\nend\nmake_a_pile = make_a_pile", "  if\
    \ n == 1 then\n    return [1]\n  else\n    if n % 2 == 1 then\n      return make_a_pile(n-1)\
    \ + make_a_pile(n-1)\n    else\n      return make_a_pile(n-1) + make_a_pile(n-2)\
    \ + make_a_pile(n-2)\n    end\n  end\nend", "  if n == 0 then return end\n  if\
    \ n == 1 then return [1] end\n  if n % 2 == 0 then\n    return make_a_pile(n-1)\
    \ + [n]\n  else\n    return make_a_pile((n-1)/2) + [n/2]\n  end\nend", "  local\
    \ pile = nil\n  if n then\n    pile = { n+1 }\n    if n % 2 == 1 then \n     \
    \ pile[#pile+1] = math.floor(n/2)\n      n = math.floor(n/2) \n    end\n    for\
    \ i = 0, n-1 do\n      pile[#pile+1] = math.floor(n*math.pow(2, i)) + (n % 2 ==\
    \ 0 and 0 or 1)\n      n = math.floor(n/2) \n    end\n  end\n  return pile\nend",
  "    if n == 0 then\n        return {}\n    end", "  if n <= 0 then\n    return\
    \ nil\n  end\n  local pile = make_list(n)\n  for i = 1, n do\n    pile[(i+1) %\
    \ n] = (i + 1) % 2\n  end\n  return pile\nend", "  local out = {}\n  for i = 0,\
    \ n do\n    out[i] = n\n    if i ^ 2 == 0 and n ~= 0 then\n      out[i] = out[i]\
    \ + n / 2\n    end\n  end\n  return out\nend", "  local num_stones = 0\n  local\
    \ pile = {}\n  for i = 1, n do\n    num_stones = num_stones + i % 2 == 0 and i\
    \ or i + 1\n    table.insert(pile, num_stones)\n  end\n  return pile\nend", " \
    \ local list = {}\n  list[1] = n\n  list[2] = n\n  list[3] = n\n  list[4] = n\n\
    \  if math.mod(n, 2) == 0 then\n    list[5] = (n + 1) * (n + 1) -- Odd number\n\
    \  else\n    list[5] = (n + 2) * (n - 2) -- Even number\n  end\n  list[6] = list[5]\
    \ - (list[5] % 2)\n  return list\nend", "    local p = {}\n    for i = 1, n, 2\
    \ do\n        p[i + 1] = i\n    end\n    return p\nend", "   if n == 0 then\n\
    \      return {n}\n   elseif n == 1 then\n      return {n}\n   elseif n % 2 ==\
    \ 0 then\n      return make_a_pile(n-1) + {n % 2}\n   else\n      return make_a_pile(n-1)\
    \ + {(n % 2 + 1)}\n   end\nend", "  local pile = {}\n  for i = 1, n do\n    if\
    \ n % 2 == 0 then\n      pile[i + 1] = n / 2\n    else\n      pile[i + 1] = n\
    \ / 2 + 1\n    end\n  end\n  return pile\nend", "  if n < 1 then\n    return nil\n\
    \  end\n  local pile = make_a_pile(n-1)\n  if n % 2 ~= 0 then\n    pile[1] = n\
    \ + 1\n    return pile\n  end\n  local odd = n + 1\n  local even = n + 2\n  pile[1]\
    \ = odd\n  pile[2] = even\n  return pile\nend", "    local result = {}\n    if\
    \ n == 1 then return [1] end\n    local odd, even = math.floor(n/2), math.floor(n/2)\
    \ + 1\n    if even > n-1 then return nil end\n    local level = {n}\n    result[1]\
    \ = n\n    for i = 2 to n do\n        result[i] = level[odd]\n        odd, even\
    \ = even, odd + 2 * math.floor(((n-i-1) / 2))\n        level[even] = level[odd]\
    \ + 1\n    end\n    return result\nend", "    if n==0 then return 0 end\n    if\
    \ n==1 then return 1 end\n    if n%2 ~= 0 then return 2*make_a_pile(n-1) end\n\
    \    return make_a_pile(n-2)\nend", "  local pile = {}\n  for i = 1, n do\n  \
    \  if i % 2 == 1 then\n      pile[i + 1] = n\n    elseif i ~= 1 then\n      pile[i\
    \ + 1] = 2 * pile[i - 1] + 1\n    end\n  end\n  return pile\nend", "\tlocal pile\
    \ = {}\n\tlocal pile_upto = 2\n\twhile pile_upto <= n do\n\t\tlocal x = math.floor((n\
    \ - pile_upto) / 2)\n\t\tpile[pile_upto] = x\n\t\tpile_upto = pile_upto + x\n\t\
    end\n\treturn pile\nend", "  local nums = []\n  for i = 1, n do\n    if i % 2\
    \ == 0 then\n      nums[#nums+1] = i\n    else\n      nums[#nums+1] = i + 1 --\
    \ this is i+1\n    end\n  end\n  return nums\nend", "  if n == 0 then\n    local\
    \ result = {}\n    for i = 1, #result do result[i] = 0 end\n    return result\n\
    \  end", "    if n % 2 == 0 then\n        -- The next odd number is odd, so there\
    \ are n levels.\n        return make_a_pile(n - 1) + odd\n    else\n        --\
    \ The next even number is even, so there are n levels.\n        return make_a_pile(n\
    \ - 1) + even\n    end\nend", "  if n == 2 then return { [1] = n }\n  if n ==\
    \ 0 then return {}\n  if n % 2 == 0 then\n    return make_a_pile(math.floor(n/2))\n\
    \  else\n    local r = make_a_pile(math.floor(n/2))\n    r[#r+1] = math.floor(n/2)\n\
    \    return r\n  end\nend", "  if n%2 == 0 then return n end -- odd\n  local res\
    \ = 1\n  while n > 0 do -- even\n    res = res*(n/2) + 1\n    n /= 2\n  end\n\
    \  return res\nend", "  local pile = {}\n  local i = 1\n  if n % 2 ~= 0 then\n\
    \    i = 2\n  end\n  while i <= n do\n    pile[i + 1] = i -- number of stones\
    \ in level (i+1)\n    i = i + 2\n  end\n  return pile\nend", "  -- Base cases\n\
    \  if n == 1 then\n    local nlist = [1]\n    return nlist\n  end\n  if n % 2\
    \ == 0 then\n    local nlist = make_a_pile(n-1) + [n + 1]\n    return nlist\n\
    \  end\n  if n % 2 == 1 then\n    local nlist = make_a_pile(n/2-1) + [n/2]\n \
    \   return nlist\n  end", "  return make_list(math.floor(n/2), math.floor(n/2),\
    \ n-math.floor(n/2))\nend", "   local pile = {}\n   if n == 1 then return pile\
    \ end\n   for i=1,n do\n      if n % 2 == 0 then\n         table.insert(pile,\
    \ i+1)\n      else\n         table.insert(pile, n)\n         n = n/2\n      end\n\
    \   end\n   return pile\nend", "  assert(n ~= nil, \"n must be an integer.\")\n\
    \  local pile = {}\n  assert(n >= 0, \"n must be positive.\")\n  \n  for i = 1,\
    \ math.floor(n) do\n    pile[i] = n\n    if math.mod(i, 2) == 0 then\n      pile[i]\
    \ = math.floor(pile[i]/2)\n    end\n  end", "    local results = {}\n    for i\
    \ = 1, n do\n        if i%2 == 0 then\n            table.insert(results, 1)\n\
    \        elseif i%2 == 1 then\n            table.insert(results, i)\n        end\n\
    \    end\n    return results\nend", "    local pile = {}\n    for i = 1, n do\n\
    \        pile[i] = (i + 1) or n\n    end\n    return pile\nend", "  -- base case\n\
    \  if n == 0 then\n    return {}\n  end\n  -- recursive case\n  if n % 2 == 0\
    \ then\n    return make_a_pile(n/2) + {n}\n  else\n    return make_a_pile(n/2)\
    \ + {n/2}\n  end\nend", "  if n < 1 then\n    error('invalid argument: n is expected\
    \ to be positive')\n  end\n  local pile = {}\n  local level = 1\n  while n ~=\
    \ 0 do\n    pile[level] = n\n    n = n / 2 -- the next even or odd number\n  \
    \  level = level + 1 -- next level\n  end\n  return pile\nend", "  local pile\
    \ = {}\n  -- If n is even, the first level is just n.\n  local first_level = n\
    \ % 2 == 0 and n or n / 2\n  for i=1, first_level do\n    -- Calculate the number\
    \ of stones in the next level.\n    local num_stones = math.floor(n/2) + i\n \
    \   -- If the number is odd, the next level is one level larger.\n    if num_stones\
    \ % 2 == 1 then\n      num_stones = num_stones + 1\n    end\n    -- Add this level\
    \ to the pile.\n    pile[i] = num_stones\n  end\n  return pile\nend", "  assert(n\
    \ >= 0, 'n must be positive')\n  assert(n % 2 == 0, 'n must be even')", "    local\
    \ list = {}\n    local current_level = 1\n    while n ~= 0 do\n        list[current_level]\
    \ = n\n        if n % 2 == 0 then\n            current_level = current_level +\
    \ 1\n        elseif n % 2 == 1 then\n            current_level = current_level\
    \ + 1\n        end\n        n = n / 2\n    end\n    return list\nend", "  if n\
    \ < 1 then\n    return nil\n  else\n    local function get_next_level(i)\n   \
    \   if n % 2 == 1 then\n        return n / 2\n      else\n        return 3 * n\
    \ + 1\n      end\n    end\n    local pile = {}\n    for i = 1, n do\n      table.insert(pile,\
    \ make_a_pile(get_next_level(i)))\n    end\n    return pile\n  end\nend", "  \
    \  local pile = {}\n    local last_stone = 1\n    if n%2 == 0 then\n        for\
    \ i = 1, n do\n            table.insert(pile,last_stone)\n            last_stone\
    \ = last_stone + 1\n        end\n    else\n        for i = 1, n do\n         \
    \   table.insert(pile,last_stone)\n            last_stone = last_stone + 1\n \
    \           last_stone = last_stone + 1\n        end\n    end\n    return pile\n\
    end", "  if n==0 then return {} end\n  if n==1 then\n    local pile={}\n    pile[1]=n\n\
    \    return pile\n  end\n  local pile={}\n  local next=math.floor(n/2)+1\n  pile[1]=n\n\
    \  for i=1,next-1 do\n    pile[i]=2*n\n  end\n  for i=1,next do\n    pile[i]=n-1\n\
    \  end\n  return pile\nend", '    if n < 2 then return nil end', "  local pile\
    \ = {}\n  local i = 1\n  repeat\n    pile[i] = n\n    if i%2 ~= 0 then\n     \
    \ n = n - n % 2\n    end\n    i = i + 1\n  until n ~= 0\n  return pile\nend",
  "  -- base case\n  if n <= 0 then\n    return nil\n  end", "  local out = {}\n \
    \ for i = 1, n do\n    if math.mod(i, 2) == 1 then\n      out[i+1] = i\n    else\n\
    \      out[i+1] = math.floor(i/2)+1\n    end\n  end\n  return out\nend", "  local\
    \ results = {}\n  for i = 1, n do\n    if i % 2 == 0 then\n      results[i] =\
    \ n\n    else\n      results[i] = i * 2 + 1\n    end\n  end\n  return results\n\
    end", "  local a = {}\n  for i = 1, n do table.insert(a, n * (i + 1)) end\n  return\
    \ a\nend", "  local p = {}\n  if n < 2 then return end", "  local pile = {}\n\
    \  local counter = 1\n  for i = 1, n do\n    if n % 2 == 1 then\n      pile[i]\
    \ = counter\n      counter = counter + 2\n    else\n      pile[i] = counter\n\
    \      counter = counter + 4\n    end\n  end\n  return pile\nend", "  local pile\
    \ = {}\n  for i = 0, n-1 do\n    local num = math.floor(i/2)\n    if num % 2 ==\
    \ 0 then\n      pile[i] = num\n    else\n      pile[i] = num + 1\n    end\n  end\n\
    \  return pile\nend", "  if n <= 0 then\n    return {}\n  end", "  if n == 0 then\
    \ return { } end\n  -- Base case\n  if n == 1 then\n    return { n }\n  else\n\
    \    -- Find the next odd or even number\n    local next = math.floor(n/2)\n \
    \   -- Add it to the last even level\n    local count = n\n    -- If the next\
    \ even level has more stones than the last level\n    if next*2 <= n then\n  \
    \    count = next * 2\n    end\n    -- Return the count + 1 as the new last level\n\
    \    return { count, next }\n  end\nend", "  if n == 1 then\n    return {n}\n\
    \  elseif n == 0 then\n    return {}\n  else\n    local pile = {}\n    repeat\n\
    \      table.insert(pile, n % 2)\n      n = math.floor(n/2)\n    until n > 1\n\
    \    return pile\n  end\nend", "   if n % 2 == 0 then\n      return n:make_a_pile(n+1)\n\
    \   else\n      return n*n\n   end\nend", "  local pile = {}\n  local level =\
    \ 1\n  pile[level] = n", "  local pile = {}\n  for i = 1, n do\n    pile[(i +\
    \ 1) % n] = i % 2 and i + 1 or i\n  end\n  return pile\nend", "  if n <= 1 then\
    \ return end\n  local pile = table.new(n)\n  local count = 1\n  if n ~= 1 then\n\
    \    while count <= n do\n      pile[count] = count\n      count = count + 1\n\
    \    end\n  end\n  if n ~= 1 then\n    pile[#pile] = n - 1\n  end\n  return pile\n\
    end", "   if n==1 then return [1] else return [n*2, n*3+1] end\nend\n</cell>\n\
    <text>\nExercise: Given a positive integer n, you have to make a pile of n levels\
    \ of stones.\nThe first level has n stones.\nThe number of stones in the next\
    \ level is:\n- the next odd number if n is odd.\n- the next even number if n is\
    \ even.\nReturn the number of stones in each level in a list, where element at\
    \ index\ni represents the number of stones in the level (i+1).\nExamples:\n>>>\
    \ make_a_pile(3)\n[3, 5, 7]", "  local pile = {}\n  local last_odd, last_even\
    \ = nil, nil\n  for i = 1, n do\n    if i % 2 == 1 then\n      if last_odd ==\
    \ nil then\n        last_odd = i\n      else\n        last_even = i\n      end\n\
    \    elseif i % 2 == 0 then\n      if last_even then\n        last_even = nil\n\
    \      else\n        last_even = i\n      end\n    else\n      last_odd = nil\n\
    \    end\n    table.insert(pile, last_even + last_odd)\n  end\n  return pile\n\
    end", "  local result={}\n  for i=1,n do table.insert(result, 0) end\n  if n%2\
    \ then\n    for i=2,#result do\n      result[i]=(i-1)\n    end\n  else\n    for\
    \ i=2,#result do\n      result[i]=(i-1)/2\n    end\n  end\n  return result\nend",
  "  if n == 1 then\n    return [1]\n  elseif n % 2 == 1 then\n    return make_a_pile(math.floor(n/2))\n\
    \  else\n    return make_a_pile((n % 2) + 2) + make_a_pile(math.floor(n/2))\n\
    \  end\nend", "    if n == 0 then\n        return nil\n    end", "    local pile\
    \ = {}\n    for i = 1, n do\n        if i % 2 == 0 then\n            pile[i] =\
    \ n\n        elseif i % 2 ~= 0 then\n            pile[i] = n + 1\n        end\n\
    \    end\n    return pile\nend", "  local pile = {}\n  for i = 0, n-1 do\n   \
    \ pile[i] = i % 2 and i+1 or i+2\n  end\n  return pile\nend", "  return function()\n\
    \    if n == 1 then\n      return n\n    else if n & 1 then\n      return n*2\
    \ + 1\n    else\n      return n*2\n    end\n  end\nend", "   if n%2 == 0 then\n\
    \      n = n + 1\n   else\n      n = n + 2\n   end\n   local pile = {}\n   for\
    \ i = 1, n, 2 do\n      table.insert(pile, i)\n   end\n   return pile\nend\nprint(make_a_pile(1))",
  "\tassert(n >= 0, \"n must be positive\")\n\tassert(n % 2 == 0, \"n must be odd\"\
    )\n\tif n == 1 then\n\t\treturn [1]\n\tend\n\tlocal plist = {n}\n\tlocal rest\
    \ = n - 1\n\tlocal odd, even\n\tif n & 1 ~= 0 then\n\t\todd = make_a_pile(rest)\n\
    \t\teven = make_a_pile(n / 2)\n\t\tfor _,k in pairs(odd) do\n\t\t\tplist[#plist\
    \ + 1] = k + even[#even - k]\n\t\tend\n\telse\n\t\todd = make_a_pile(rest)\n\t\
    \tfor _,k in pairs(odd) do\n\t\t\tplist[#plist + 1] = k\n\t\tend\n\tend\n\treturn\
    \ plist\nend", "  local result = {n}\n  while n ~= 1 do\n    local odd, even =\
    \ math.modf(n/2)\n    local next = odd\n    if n ~= even then\n      next = next+1\n\
    \    end\n    table.insert(result, next)\n    n = math.floor(n/2)\n  end\n  return\
    \ result\nend", "  if n == 2 or n == 4 then return 2 end\n  if n == 3 then return\
    \ 3 end\n  if n == 5 then return 5 end\n  if n % 2 == 0 then\n    if n % 4 > 0\
    \ then return n / 2 end\n    return n / 2\n  else\n    return n * 3 + 1\n  end\n\
    end", "  return function()\n    if n == 0 then\n      return {}\n    elseif n\
    \ <= 0 then\n      error(\"n must be > 0\", 2)\n    elseif n == 1 then\n     \
    \ return n\n    elseif n % 2 == 0 then\n      local even = math.floor(n/2)\n \
    \     return make_a_pile(even) + make_a_pile(n-even)\n    else\n      local odd\
    \ = math.ceil(n/2)\n      return make_a_pile(odd) + make_a_pile(n-odd)\n    end\n\
    \  end\nend", "  if n == 0 then\n    return nil\n  elseif n == 1 then\n    return\
    \ {1}\n  elseif n % 2 == 0 then\n    return make_a_pile((n - 1) / 2) + make_a_pile((n\
    \ - 1) / 2) + 1\n  else\n    return make_a_pile((n - 1) / 2) + make_a_pile((n\
    \ - 1) / 2) + make_a_pile((n - 1) / 2) + 1\n  end\nend", "  if n == 0 then return\
    \ { [0] = 0 }\n  if n % 2 == 1 then return make_a_pile(n - 1)\n  else\n    local\
    \ ans = make_a_pile(n / 2)\n    ans[#ans + 1] = ans[#ans] + 1\n    return ans\n\
    \  end\nend", "  local pile = {}\n  for i = 1, n do\n    if i % 2 == 0 then\n\
    \      table.insert(pile, i)\n    elseif n >= i and math.floor(i/2) == i then\n\
    \      table.insert(pile, math.floor(i/2) + 1)\n    end\n  end\n  return pile\n\
    end", "  local pile = {}\n  local level = 0\n  if n % 2 == 1 then\n    level =\
    \ n\n  end\n  for i = 1, level do\n    local pile_next = make_a_pile(level * 2)\n\
    \    pile[i + 1] = pile[i] + pile_next - i\n  end\n  return pile\nend", "  if\
    \ n % 2 == 0 then\n    return make_a_pile(n-1) + n\n  else\n    return n\n  end\n\
    end", "  local pile = {}\n  if n == 0 then return pile end\n  local next_even\
    \ = next_even(n)\n  pile[1] = n\n  for i = 2, n do \n    if next_even % 2 == 0\
    \ then\n      pile[i] = pile[i-1] + n\n      next_even = next_even / 2\n    else\n\
    \      pile[i] = pile[i-1] + 1\n    end\n  end\n  return pile\nend", "  if n==0\
    \ then return 0 end\n  if n%2==1 then\n    return make_a_pile(n-1) + n + make_a_pile(n-2)\n\
    \  else\n    return make_a_pile(n-1) + make_a_pile(n-2)\n  end\nend", "  -- If\
    \ n is even, there will be 1 stone on top level.\n  if n % 2 == 0 then\n    return\
    \ n\n  end\n  -- If n is odd, there will be 1 stone on top level, followed by\
    \ 1 stone on each level.\n  -- (This line might not be totally correct but you\
    \ get the idea.)\n  return n - 1 .. n / 2\nend", "  local pile = {}\n  local odd\
    \ = 0\n  local even = 0", "   if n == 0 then\n      return {}\n   elseif n ==\
    \ 1 then\n      return {n}\n   else\n      local next_odd = math.floor(n/2)*2\
    \ + 1\n      local next_even = math.floor(n/2)*2\n      return {next_odd, next_even}\n\
    \   end\nend", "  if n == 0 then\n    return {}\n  elseif n == 2 then\n    return\
    \ {n}\n  else\n    local odd = math.floor(n/2) \n    local even = n%%2\n    local\
    \ left_pile = make_a_pile(odd)\n    local right_pile = make_a_pile(even)\n   \
    \ local total_pile = left_pile + right_pile\n    local counts = {}\n    for i=1,#total_pile\
    \ do\n      counts[total_pile[i]] = counts[total_pile[i]] + 1\n    end\n    return\
    \ counts\n  end\nend", "  local pile = {}\n  local i = 1\n  while i <= n do\n\
    \    if n % 2 == 0 then\n      pile[i] = n / 2\n      n = n / 2\n    else\n  \
    \    pile[i] = n / 2 + 1\n      n = n / 2 + 1\n    end\n    i = i + 1\n  end\n\
    \  return pile\nend", "  if n <= 1 then return {} end\n  if n % 2 == 0 then return\
    \ {n*2} end\n  local pile = {n*2}\n  while n%2 == 1 do\n    n = n/2\n    table.insert(pile,\
    \ n)\n  end\n  return pile\nend", "    local pile = {}\n    if n < 0 then return\
    \ end\n    if n == 0 then\n        pile[1] = 1\n        return pile\n    end\n\
    \    local even, odd = n % 2, n / 2\n    repeat\n        pile[#pile+1] = odd\n\
    \        odd = even\n    until even > 1\n    repeat\n        pile[#pile+1] = even\n\
    \        even = odd\n    until odd > 1\n    return pile\nend", "  assert(n >=\
    \ 0)\n  local list = []\n  repeat\n    list = list .. n\n    n = math.floor(n/2)\n\
    \  until n <= 0\n  return list\nend", "  local results = {}\n  for i = 1, n do\n\
    \    local n = math.floor((n + 1) /2 + 1)\n    table.insert(results, n)\n  end\n\
    \  return results\nend", "    if n % 2 ~= 0 then\n        return make_a_pile(2\
    \ * n) + 2 * n - 1\n    else\n        return make_a_pile(n + 1) + 1\n    end\n\
    end", "  if n == 0 then\n    return nil\n  elseif n == 1 or n % 2 == 0 then\n\
    \    return n\n  else\n    return make_a_pile(n - 1) + 2\n  end\nend", "    local\
    \ p = {}\n    if n == 0 then\n        return p\n    end\n    local odd_count =\
    \ 0\n    local even_count = 0\n    local current_pile = 0\n    for current_pile\
    \ <= n do\n        if n % 2 == 1 then\n            even_count = even_count + 1\n\
    \        else\n            odd_count = odd_count + 1\n        end\n        n =\
    \ n / 2\n    end\n    p[1] = odd_count + even_count\n    local i = 2\n    while\
    \ i < n do\n        if n % 2 == 1 then\n            p[i + 1] = odd_count + even_count\n\
    \        else\n            p[i + 1] = odd_count\n        end\n        n = n /\
    \ 2\n        i = i + 1\n    end\n    return p\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
