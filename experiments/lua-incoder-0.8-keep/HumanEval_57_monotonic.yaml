name: HumanEval_57_monotonic
language: lua
prompt: "-- Return True is list elements are monotonically increasing or decreasing.\n\
  -- >>> monotonic([1, 2, 4, 20])\n-- True\n-- >>> monotonic([1, 20, 4, 10])\n-- False\n\
  -- >>> monotonic([4, 1, 0, -10])\n-- True\nlocal function monotonic(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = monotonic\n\
  \    lu.assertEquals(candidate({1, 2, 4, 10}), true)\n    lu.assertEquals(candidate({1,\
  \ 2, 4, 20}), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}), false)\n   \
  \ lu.assertEquals(candidate({4, 1, 0, -10}), true)\n    lu.assertEquals(candidate({4,\
  \ 1, 1, 0}), true)\n    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)\n    lu.assertEquals(candidate({9,\
  \ 9, 9, 9}), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local l2 = {}\n  for i = #l - 1, 1, -1 do\n    table.insert(l2, l[i])\n\
    \  end\n  local ok = true\n  local i = #l\n  while i ~= 0 do\n    local m = i\
    \ + #l2\n    local s = l2[i]\n    local e\n    local f\n    if i < #l2 then\n\
    \      e = l2[i + 1]\n      f = l2[m + 1]\n    else\n      e = l2[i - 1]\n   \
    \   f = l2[m]\n    end\n    if not (e < f and s < e) then\n      ok = false\n\
    \    end\n    if i > m then\n      i = m\n    else\n      i = i + 1\n    end\n\
    \  end\n  return ok\nend", "  local result = true\n  for i = 1, #l do\n    local\
    \ v = l[i]\n    if v ~= nil and v ~= i then\n      if v > l[i - 1] or v < l[i\
    \ - 1] then\n        result = false\n      end\n    end\n  end\n  return result\n\
    end", "  local i = 1\n  local j = #l - 1\n  while i < j do\n    local x = l[i]\n\
    \    local y = l[j]\n    if x ~= y then\n      local tmp\n      if x > y then\
    \ tmp = x end\n      if x < y then tmp = y end\n      if tmp ~= x and tmp ~= y\
    \ then return false end\n    end\n    i = i + 2\n    j = j - 2\n  end\n  return\
    \ true\nend", "   if #l == 0 then return true end\n   local prev = l[1]\n   for\
    \ _, v in ipairs(l) do\n      if v ~= prev then\n\t return false\n      end\n\
    \      prev = v\n   end\n   return true\nend", "  if #l <= 1 then return false\
    \ end\n  local prev = -100\n  local curr = l[1]\n  for i = 2, #l do\n    local\
    \ _curr = l[i]\n    if _curr > prev and _curr < curr then return false end\n \
    \   prev = _curr\n    curr = curr\n  end\n  return true\nend", "   if l[1] < l[2]\
    \ then\n      l[1] = l[2]\n   end\n   if l[2] < l[3] then\n      l[2] = l[3]\n\
    \   end\n   if l[3] < l[4] then\n      l[3] = l[4]\n   end\n   return l[4] < l[1]\n\
    end", "    local prev, curr, n = l[1], l[2], 1\n    local ok = true\n    while\
    \ ok do\n        ok = false\n        if prev and prev < curr then\n          \
    \  ok = true\n            prev = curr\n        elseif prev and prev > curr then\n\
    \            ok = true\n            n = n + 1\n        end\n        curr = l[n]\n\
    \    end\n    return n == 1\nend", "    local l1 = {}\n    local l2 = {}\n   \
    \ for _, item in ipairs(l) do\n        if l1[item] then return false end\n   \
    \     l1[item] = true\n        l2[item] = true\n    end\n    for _, item in ipairs(l)\
    \ do\n        if not l2[item] then return false end\n        l2[item] = true\n\
    \    end\n    return true\nend", "  local lastx = 0\n  local lasty = 0\n  local\
    \ lastz = 0\n  for i=1,#l do\n    local x,y,z = l[i]\n    if x<lastx or y<lasty\
    \ or z<lastz then\n      return false\n    end\n    lastx = x\n    lasty = y\n\
    \    lastz = z\n  end\n  return true\nend", '  local sorted, start, stop = table.sort(l),
    0, #l', "  return next(l) == l[1]\nend", "  local i = 1\n  local j = #l + 1\n\
    \  for i = 1, #l do\n    for j = 1, #l do\n      if l[j] ~= l[i] then\n      \
    \  if l[j] < l[i] then\n          return true\n        else\n          return\
    \ false\n        end\n      end\n    end\n  end\n  return false\nend", "  if #l\
    \ == 1 then\n    return l[1] < l[2]\n  end\n  local tail = l[#l]\n  local head\n\
    \  local out = 1\n  while #l > 1 and out ~= 0 do\n    head, tail = tail, l[#l]\n\
    \    if tail > head then\n      return false\n    end\n    out = out + 1\n  end\n\
    \  return head == tail\nend", "  local i = 1\n  for _, x in ipairs(l) do\n   \
    \ i = i + 1\n    if i < 2 or (i > 2 and x < l[i - 1]) then\n      return false\n\
    \    end\n  end\n  return true\nend", "  if #l == 0 then return false end\n  local\
    \ prev = l[1]\n  for i = 2, #l do\n    if prev > l[i] then return false end\n\
    \    prev = l[i]\n  end\n  return true\nend", "  local first = l[1]\n  for i =\
    \ 2, #l do\n    local v = l[i]\n    if v < first then\n      return false\n  \
    \  end\n    if v > first then\n      first = v\n    end\n  end\n  return true\n\
    end", "    local last_index = 1\n    local last_element = l[last_index]", "  local\
    \ i = 1\n  for i = 2, #l do\n    if l[i-1] < l[i] or l[i-1] == l[i] and l[i] ~=\
    \ l[i-1] then\n      return false\n    end\n  end\n  return true\nend", "  local\
    \ i, j, m, n = 1, #l, 2\n  while i < n do\n    j = i - 1\n    m = j - 1\n    while\
    \ m > 0 and l[j] < l[m] do\n      m = m - 1\n    end\n    if m > 0 and l[j] ==\
    \ l[m] then\n      j = j - 1\n    end\n    if m > j then\n      l[i], l[j] = l[j],\
    \ l[i]\n      i = i + 1\n      j = j - 1\n    else\n      i = i + 1\n    end\n\
    \  end\n  return i < 2\nend", "    local i = 1\n    while i < #l do\n        if\
    \ l[i] < l[i-1] then\n            return false\n        end\n        i=i+1\n \
    \   end\n    return true\nend", "  local last_index, last_value = 0, l[1]\n  for\
    \ _, v in ipairs(l) do\n    last_index = last_index + 1\n    if last_value < v\
    \ then\n      return false\n    end\n    last_value = v\n  end\n  return true\n\
    end", "    if #l == 0 then return true end\n    if #l == 1 then return l[1] <\
    \ l[0] end\n    if l[1] <= l[2] then\n        return true\n    end\n    if l[1]\
    \ < l[3] then\n        return false\n    end\n    if l[2] <= l[3] then\n     \
    \   return true\n    end\n    return monotonic(l[#l-1])\nend", "    local is_decreasing\n\
    \    is_decreasing = true\n    local i = 1\n    while i <= #l do\n        local\
    \ x = l[i]\n        local x_next = l[i + 1]\n        if x >= x_next then\n   \
    \         if is_decreasing then\n                is_decreasing = false\n     \
    \       else\n                -- Found a monotonic increasing sequence\n     \
    \           return true\n            end\n        elseif x == x_next then\n  \
    \          -- Found a monotonic decreasing sequence\n            -- NOTE: This\
    \ assumes ascending sequences.\n            return false\n        end\n      \
    \  i = i + 2\n    end\n    -- No monotonic sequence found\n    return false\n\
    end", "   local function f(x, y)\n      if x > y then\n         return false\n\
    \      else\n         return true\n      end\n   end", "  local min_value = tonumber(l[1])\n\
    \  local max_value = tonumber(l[#l])\n  return min_value <= max_value and #l >\
    \ 0 and\n    (min_value < max_value or min_value < #l or\n     max_value > #l\
    \ or max_value < min_value)\nend", "  local sorted = {}\n  for i = 1, #l do\n\
    \    sorted[#sorted + 1] = l[i]\n  end\n  table.sort(sorted)\n  local last = sorted[1]\n\
    \  for i = 2, #sorted do\n    if sorted[i] ~= last then return false end\n   \
    \ last = sorted[i]\n  end\n  return true\nend", "  local tail = l[#l]\n  for i\
    \ = #l - 1, 1, -1 do\n    if l[i] < tail then\n      return false\n    end\n \
    \   tail = l[i]\n  end\n  return true\nend", "  if #l == 1 then return true end\n\
    \  local l, r = l[1], l[2]\n  if l > r then return false end\n  local li, ri =\
    \ l[2], l[3]\n  return li <= ri and monotonic(l) or monotonic(r)\nend", "\tlocal\
    \ sorted = table.remove(l)\n\tfor i = 1, #sorted - 1 do\n\t\tlocal low = sorted[i]\n\
    \t\tlocal high = sorted[i + 1]\n\t\tif low <= high and low > 0 then\n\t\t\tif\
    \ high > low then\n\t\t\t\treturn false\n\t\t\tend\n\t\telseif low < 0 and high\
    \ < 0 then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn true\nend", "   if #l\
    \ == 1 then\n      return true\n   end\n   if #l == 0 then\n      return false\n\
    \   end", "  if #l == 0 then return true end\n  for i = 1, #l do\n    if l[i-1]\
    \ < l[i] then return false end\n  end\n  return true\nend", "  for i = #l - 1,\
    \ 1, -1 do\n    local x = l[i]\n    if x > l[i-1] then\n      return false\n \
    \   end\n  end\n  return true\nend", "  if #l == 0 then return false end\n  if\
    \ l[1] < l[2] then return false end\n  if l[2] < l[3] then return true end\n \
    \ return monotonic(l[#l])\nend", "    local i = 0\n    local j = #l - 1\n    local\
    \ positive = true", "  local _, last = unpack(l)\n  return l[1] == last and #l\
    \ > 1 -- If length is 1 or less, return True\nend", "  if #l == 0 then\n    return\
    \ true\n  end\n  if l[1] < l[2] then\n    return false\n  end\n  if l[2] < l[1]\
    \ then\n    return true\n  end\n  for i = 2, #l do\n    if l[i] < l[i-1] then\n\
    \      return false\n    end\n  end\n  return true\nend", "  local ok, prev =\
    \ true, {}\n  local i = 1\n  for i = #l, 1, -1 do\n    if not ok then\n      ok\
    \ = prev[i] > l[i]\n    end\n    prev[i] = l[i]\n  end\n  return ok\nend", "\t\
    local i = 1\n\tlocal last = l[1]\n\tfor i = 2, #l do\n\t\tif l[i] ~= last then\n\
    \t\t\treturn true\n\t\tend\n\t\tlast = l[i]\n\tend\n\treturn false\nend", "  local\
    \ prev = l[1]\n  local curr = 1\n  local is_decreasing = true", "  if #l == 0\
    \ then return true end\n  local minimum = l[1]\n  for i=2,#l do\n    local value\
    \ = l[i]\n    if value < minimum then return false end\n    if minimum > value\
    \ then minimum = value end\n  end\n  return true\nend", "  local function less(x)\n\
    \    local l\n    if #l == 0 then return end\n    local n = #l\n    for i = 1,\
    \ n do\n      if l[i] == x then\n        return false\n      end\n    end\n  \
    \  return true\n  end\n  local function greater(x)\n    local l\n    if #l ==\
    \ 0 then return end\n    local n = #l\n    for i = 1, n do\n      if l[i] < x\
    \ then\n        return false\n      end\n    end\n    return true\n  end\n  return\
    \ less(l[1]) and greater(l[#l])\nend", "\tassert(#l > 0, \"Cannot check for monotonicity\
    \ of empty list\")\n\tif l[1] == nil then return false end\n\tlocal prev = 0\n\
    \tlocal current\n\tfor _, current in ipairs(l) do\n\t\tif prev == current then\
    \ return false end\n\t\tprev = current\n\tend\n\treturn true\nend", "   local\
    \ i = 1\n   while i <= #l do\n      if not l[i] or l[i-1] > l[i] then\n      \
    \   return false\n      end\n      i = i + 1\n   end\n   return true\nend", " \
    \ local function compare(x, y)\n    if x <= y then\n      return x\n    else\n\
    \      return y\n    end\n  end\n  local last_x, last_y = nil, nil\n  for _, x\
    \ in ipairs(l) do\n    if last_x ~= nil then\n      if last_y == nil then\n  \
    \      last_y = x\n      elseif last_y < x then\n        return true\n      else\n\
    \        return false\n      end\n    end\n    last_x = x\n    last_y = y\n  end\n\
    \  return false\nend", "  local ok, a, b = true, {}, {}\n  for i,v in ipairs(l)\
    \ do\n    a[v] = true\n  end\n  -- Return true if the list is completely monotonic,\
    \ meaning it has a value everywhere from 0 to N-1.\n  -- The last element in a\
    \ list has value 1, so the next element is always at least as large.\n  for i=1,\
    \ #l do\n    local v\n    if a[i] then\n      v = 1\n    else\n      local j =\
    \ i\n      while j > 0 do\n        if a[j] and b[j] then\n          local mn =\
    \ math.min(b[j], a[j])\n          local mx = math.max(b[j], a[j])\n          if\
    \ mx ~= v or mn ~= v then\n            v = mx or mn\n            ok = false\n\
    \            break\n          end\n        end\n        if a[j] then\n       \
    \   v = a[j]\n        else\n          j = j - 1\n        end\n      end\n    \
    \  if b[j] then\n        v = b[j]\n      end\n    end\n    b[i] = v\n  end\n \
    \ return ok\nend", "  local i, j = #l, 1, 0\n  -- The element itself is greater\
    \ than its successor.\n  if l[i] > l[j] then return false end\n  -- Compare to\
    \ the first element.\n  while j < i do\n    j = j + 1\n    -- The element itself\
    \ is lesser than its successor.\n    if l[i] < l[j] then return false end\n  \
    \  -- Compare to the last element.\n    while i < j do\n      i = i + 1\n    \
    \  -- The element itself is greater than its successor.\n      if l[i] > l[j]\
    \ then return false end\n    end\n  end\n  return true\nend", "  local sorted\
    \ = l:sort(function(a,b) return a < b end)\n  for i = 2, #sorted do\n    if sorted[i-1]\
    \ < sorted[i] then\n      return false\n    end\n  end\n  return true\nend", " \
    \ local last_value\n  local last_increment\n  local last_decrement\n  for i=1,#l\
    \ do\n    local value = l[i]\n    if value < last_value then\n      return false\n\
    \    end\n    local increment = last_increment or 1\n    local decrement = last_decrement\
    \ or 0\n    if last_value ~= 0 then\n      if ((value < last_value - increment)\
    \ or (value >= last_value + decrement)) then\n        return false\n      end\n\
    \    end\n    last_value = value\n    last_increment = increment\n    last_decrement\
    \ = decrement\n  end\n  return true\nend", "  if #l == 0 then return end\n  if\
    \ l[1] == l[2] then\n    local e1 = l[1]\n    local e2 = l[2]\n    if e1 ~= e2\
    \ then\n      if e1 < e2 then\n        return true\n      else\n        return\
    \ false\n      end\n    else\n      return false\n    end\n  end\n  if l[1] <\
    \ l[2] then\n    local e1 = l[1]\n    local e2 = l[2]\n    local i = 0\n    while\
    \ i < #l and l[i] == e1 do\n      i = i + 1\n    end\n    return i == #l\n  end\n\
    \  return false\nend", "    local min_index, max_index = 1, #l - 1\n    while\
    \ min_index <= max_index do\n        local candidate = l[min_index]\n        if\
    \ l[min_index] > candidate then min_index = min_index + 1 elseif l[min_index]\
    \ < candidate then max_index = max_index - 1 end\n    end\n    return min_index\
    \ <= max_index\nend\n</cell>\n<code language=julia-1.6>", "  if #l == 1 then return\
    \ true end\n  if l[1] < l[2] and l[2] < l[3] then return true end\n  if l[1] <\
    \ l[3] then return false end\n  if l[2] < l[3] then return false end\n  return\
    \ true\nend", "  local first = {}\n  for _, e in ipairs(l) do first[e] = true\
    \ end\n  for i, e in ipairs(l) do\n    local v = e\n    if i == 1 then\n     \
    \ v = v - 1\n      if first[v] and v ~= 0 then return false end\n      first[v]\
    \ = true\n    end\n    if i == #l then\n      v = v + 1\n      if first[v] and\
    \ v ~= #l then return false end\n      first[v] = true\n    end\n  end\n  return\
    \ true\nend", "  local i = 1\n  while i <= #l do\n    local i2 = i + 1\n    local\
    \ i3 = i2 + 1\n    local i4 = i3 + i\n    local i5 = i4 + i\n    local i6 = i5\
    \ + i\n    local i7 = i6 + i\n    local i8 = i7 + i\n    local i9 = i8 + i\n \
    \   local i10 = i9 + i\n    local i11 = i10 + i\n    if l[i-1] <= l[i2] and l[i-1]\
    \ <= l[i3] and l[i-1] <= l[i4] and\n       l[i-1] <= l[i5] and l[i-1] <= l[i6]\
    \ and l[i-1] <= l[i7] and l[i-1] <= l[i8] and l[i-1] <= l[i9] and l[i-1] <= l[i10]\
    \ and l[i-1] <= l[i11] and\n       l[i2] <= l[i3] and l[i2] <= l[i4] and l[i2]\
    \ <= l[i5] and l[i2] <= l[i6] and l[i2] <= l[i7] and l[i2] <= l[i8] and l[i2]\
    \ <= l[i9] and l[i2] <= l[i10] and l[i2] <= l[i11] and\n       l[i3] <= l[i4]\
    \ and l[i3] <= l[i5] and l[i3] <= l[i6] and l[i3] <= l[i7] and l[i3] <= l[i8]\
    \ and l[i3] <= l[i9] and l[i3] <= l[i10] and l[i3] <= l[i11] and\n       l[i4]\
    \ <= l[i5] and l[i4] <= l[i6] and l[i4] <= l[i7] and l[i4] <= l[i8] and l[i4]\
    \ <= l[i9] and l[i4] <= l[i10] and l[i4] <= l[i11] and\n       l[i5] <= l[i6]\
    \ and l[i5] <= l[i7] and l[i5] <= l[i8] and l[i5] <= l[i9] and l[i5] <= l[i10]\
    \ and l[i5] <= l[i11] and\n       l[i6] <= l[i7] and l[i6] <= l[i8] and l[i6]\
    \ <= l[i9] and l[i6] <= l[i10] and l[i6] <= l[i11] and\n       l[i7] <= l[i8]\
    \ and l[i7] <= l[i9] and l[i7] <= l[i10] and ", "\tlocal i, j = #l, 1\n\tlocal\
    \ found = -1\n\twhile (j > 0) do\n\t\tif l[i] < l[j] then\n\t\t\tfound = i\n\t\
    \t\tbreak\n\t\tend\n\t\tj = j - 1\n\tend\n\treturn found ~= nil\nend", "   if\
    \ #l == 1 then\n      return true\n   end\n   for i = 2, #l do\n      if l[i-1]\
    \ <= l[i] then\n         return false\n      elseif l[i-1] > l[i] then\n     \
    \    return true\n      end\n   end\n   return true\nend", "   local prev = -1\n\
    \   local curr = 1\n   for i = 1, #l do\n      local x = l[i]\n      -- if x is\
    \ not monotonic, then it must be increasing\n      if prev < curr or x > prev\
    \ then\n         return false\n      end\n      prev = curr\n      curr = x\n\
    \   end\n   return true\nend", "\tif l[1] == nil then return false end\n\tif l[1]\
    \ ~= l[2] or l[1] ~= l[3] or l[2] ~= l[4] then return false end\n\treturn true\n\
    end", "  if l[1] < l[2] then\n    return false\n  end\n  for i=3, #l do\n    if\
    \ l[i-1] > l[i] then\n      return false\n    end\n  end\n  return true\nend",
  "  local i = 1\n  local m = nil\n  while i < #l do\n    m = l[i]\n    if m < m then\n\
    \      l[i] = nil\n      i = i + 1\n    elseif m == m then\n      i = i + 1\n\
    \    end\n  end\n  l = l[1]\n  if l ~= nil then\n    return true\n  else\n   \
    \ return false\n  end\nend", "    local last = l[1]\n    local prev = last\n \
    \   for i = 2, #l do\n        if l[i] > prev then\n            prev = l[i]\n \
    \       else\n            return false\n        end\n    end\n    return true\n\
    end", "   local min, max = l[1], l[-1]\n   for i = 2, #l do\n      if l[i] ~=\
    \ min then return false end\n      min = max -- Keep track of old min.\n   end\n\
    \   return true\nend", "  local m = 1\n  for i = 1, #l do\n    if l[i] < l[i -\
    \ 1] or l[i] > l[i + 1] then\n      if l[i] < l[m - 1] or l[i] > l[m + 1] then\
    \ return false end\n      if l[i] > l[m - 1] and l[i] > l[m + 1] then return true\
    \ end\n    end\n    m = m + 1\n  end\n  return true\nend", "   local n = 1\n \
    \  local last = nil\n   for i, e in ipairs(l) do\n      if not last or n > last\
    \ then\n         last = n\n      end\n      if e > n then\n         n = e\n  \
    \    end\n   end\n   return last <= n\nend", "  local prev\n  for _, v in ipairs(l)\
    \ do\n    if prev then\n      if prev < v then return false end\n      if prev\
    \ > v then return true end\n    end\n    prev = v\n  end\n  return false\nend",
  "   local increasing\n   local decreasing\n   local m\n   local i\n   \n   if l[1]\
    \ < l[2] then\n      m = l[1]\n      i = 2\n   elseif l[2] < l[1] then\n     \
    \ m = l[2]\n      i = 1\n   else\n      return false\n   end", "  -- Avoid dealing\
    \ with nil.\n  if l == nil then return false end\n  -- Check whether the first\
    \ and last elements are nil.\n  if l[1] == nil then return l[2] == nil end\n \
    \ if l[#l] == nil then return false end\n  -- Return true if the first element\
    \ is increasing or decreasing.\n  return l[1] < l[#l] or l[1] > l[#l]\nend", " \
    \ local s, i, l = l[1], 1, l\n  if l == nil then return false end\n  while i <\
    \ #l do\n    if s[i] ~= l[i] then return false end\n    i = i + 1\n  end\n  while\
    \ i < #l do\n    if l[i] > s[i] then return false end\n    i = i + 1\n  end\n\
    \  return true\nend", "  local last = nil\n  for i,v in ipairs(l) do\n    if last\
    \ then\n      last = v\n      continue\n    end\n    if v < last then\n      return\
    \ false\n    end\n    last = v\n  end\n  return true\nend", "    local first,\
    \ last = unpack(l)\n    if first == last then return false end\n    if first<last\
    \ then return true end\n    local middle = math.floor((first+last)/2)\n    return\
    \ monotonic(l, first, middle) or monotonic(l, middle+1, last)\nend", "  local\
    \ increasing, decreasing = true, true\n  local min_value = l[1]", "  local max\
    \ = 0\n  local min = 1\n  for _, v in pairs(l) do\n    max = math.max(v, max)\n\
    \    min = math.min(v, min)\n  end\n  return min >= max\nend", "  if #l == 1 then\
    \ return true\n  elseif #l == 0 then return false\n  else\n    local first, last\
    \ = l[1], l[1]\n    local i = 1\n    for i = 2, #l do\n      if l[i] > last then\n\
    \        last = l[i]\n      elseif l[i] < first then\n        first = l[i]\n \
    \     end\n    end\n    return first < last\n  end\nend", "    local i = 1\n \
    \   local lastel = l[i]\n    for el in l:gmatch(\"[^%d]+\") do\n        if el\
    \ > lastel then return false end\n        if el < lastel then i = i + 1 end\n\
    \        lastel = el\n    end\n    return true\nend", "  local last_value = nil\n\
    \  for i, v in pairs(l) do\n    if last_value and last_value > v then\n      return\
    \ false\n    end\n    last_value = v\n  end\n  return true\nend", "  local i =\
    \ 1\n  while i <= #l and l[i] <= l[i-1] do\n    i = i + 1\n  end\n  return i ==\
    \ #l\nend", "  local increasing = true\n  local decreasing = false\n  for i =\
    \ 1, #l do\n    if l[i] ~= l[i - 1] + 1 then return false end\n    if increasing\
    \ then decreasing = false else increasing = true end\n  end\n  return increasing\n\
    end", "    local function aux(ls, i, n)\n        -- If we're at the end of our\
    \ list, there's no monotonic increasing/decreasing.\n        if i == n then\n\
    \            return false\n        end\n        -- Compare to the previous element\n\
    \        if ls[i] > ls[i + 1] then\n            return true\n        else\n  \
    \          return aux(ls, i + 1, n)\n        end\n    end\n    return aux(ls,\
    \ 1, #l)\nend", "   if #l < 1 then return false end\n   local i, cur = 1, l[1]\n\
    \   for i = 2, #l do\n      if l[i-1] > cur or cur == 0 then\n         return\
    \ false\n      end\n      cur = l[i]\n   end\n   return true\nend", "    if #l\
    \ < 1 then return false end\n    local i = 1\n    local last = l[1]\n    for i\
    \ = 2, #l do\n        local curr = l[i]\n        if curr > last then\n       \
    \     return false\n        end\n        last = curr\n    end\n    return true\n\
    end", "  local i = 1\n  local n = #l\n  while i < n do\n    if l[i] <= l[i-1]\
    \ then return false end\n    i = i + 1\n  end\n  return true\nend", "    if #l\
    \ == 0 then\n        return false\n    end\n    if l[1] < l[2] then\n        return\
    \ false\n    end\n    return true\nend", "  local i = 1\n  local j = 1\n  local\
    \ monotonic_increasing\n  local last_increasing_value = false\n  local last_decreasing_value\
    \ = false\n  local increasing_index = nil\n  local decreasing_index = nil", "\t\
    local monotone = { }, -- Keep track of the current monotone state.\n\t\t\t \t\
    \   \t   \t   \t   \t-- Start with a false value.\n\tlocal i, j, k\n\tfor i =\
    \ #l - 1, 1, -1 do\n\t\tlocal element = l[i]\n\t\tif i == 1 or element > l[i-1]\
    \ then\n\t\t\t-- Increasing or decreasing.\n\t\t\tif element > l[i-1] then\n\t\
    \t\t\t-- Increasing.\n\t\t\t\tif monotone[1] then return false end\n\t\t\t\tj\
    \ = i\n\t\t\t\tfor k = i - 1, i + 1, -1 do\n\t\t\t\t\tlocal prev_element = l[k]\n\
    \t\t\t\t\tif k == 1 or prev_element > l[k-1] then\n\t\t\t\t\t\t-- Increasing.\n\
    \t\t\t\t\t\tbreak\n\t\t\t\t\telse\n\t\t\t\t\t\t-- Decreasing.\n\t\t\t\t\t\tif\
    \ prev_element > element then\n\t\t\t\t\t\t\t-- Decreasing.\n\t\t\t\t\t\t\tif\
    \ monotone[2] then return false end\n\t\t\t\t\t\t\tmonotone[1] = true\n\t\t\t\t\
    \t\t\tj = k\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t-- Non-increasing.\n\t\t\t\t\t\t\t\
    if monotone[1] then return false end\n\t\t\t\t\t\t\tmonotone[1] = false\n\t\t\t\
    \t\t\t\tj = k\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\
    \t-- Decreasing.\n\t\t\t\tif monotone[2] then return false end\n\t\t\t\tj = i\n\
    \t\t\t\tfor k = i - 1, i + 1, -1 do\n\t\t\t\t\tlocal prev_element = l[k]\n\t\t\
    \t\t\tif k == 1 or prev_element > l[k-1] then\n\t\t\t\t\t\t-- Decreasing.\n\t\t\
    \t\t\t\tbreak\n\t\t\t\t\telse\n\t\t\t\t\t\t-- Increasing.\n\t\t\t\t\t\tif prev_element\
    \ > element then\n\t\t\t\t\t\t\t-- Increasing.\n\t\t\t\t\t\t\tif monotone[1] then\
    \ return false end\n\t\t\t\t\t\t\tmonotone[1] = true\n\t\t\t\t\t\t\tj = k\n\t\t\
    \t\t\t\telse\n\t\t\t\t\t\t\t-- Non-decreasing.\n\t\t\t\t\t\t\tif monotone[1] then\
    \ return false end\n\t\t\t\t\t\t\tmonotone[1] = false\n\t\t\t\t\t\t\tj = k\n\t\
    \t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\t-- Non-increasing\
    \ or non-decreasing.\n\t\t\tif element < l[i-1] then\n\t\t\t\t-- Non-increasing.\n\
    \t\t\t\tif monotone[2] then return false end\n\t\t\t\tmonotone[2] = true\n\t\t\
    \telse\n\t\t\t\t-- Non-decreasing.\n\t\t\t\tif monotone[1] then return false end\n\
    \t\t\t\tmonotone[1] = false\n\t\t\tend\n\t\tend\n\tend\n\t\n\t-- No monotonicity\
    \ found.\n\treturn true\nend", "  for i = 1, #l do\n    if l[i] ~= l[i-1] then\n\
    \      return false\n    end\n  end\n  return true\nend", "    local last_element,\
    \ last_element_index, is_decreasing = l[1], l[2], l[3]\n    for i, v in ipairs(l)\
    \ do\n        if last_element == v then\n            last_element_index = i\n\
    \            last_element = nil\n            is_decreasing = nil\n        elseif\
    \ v < last_element then\n            if last_element and is_decreasing then\n\
    \                return false\n            elseif last_element and last_element_index\
    \ < i then\n                return false\n            end\n        end\n    end\n\
    \    return true\nend", "  return l and #l > 0 and #l == l[1] and #l[2] == 1\n\
    end", '    local ret', "    -- Return False if empty list.\n    if not l then\n\
    \        return false\n    end", "  local i = 1\n  for _, e in ipairs(l) do\n\
    \    if e ~= l[i] then\n      break\n    end\n    i = i + 1\n  end\n  return i\
    \ <= #l\nend", "  local prev_idx = 1\n  local prev = 0\n  local cur_idx\n  for\
    \ idx = 1, #l do\n    cur_idx = math.abs(l[idx] - prev)\n    if cur_idx < prev_idx\
    \ then\n      return false\n    end\n    prev_idx = cur_idx\n    prev = l[idx]\n\
    \  end\n  return true\nend", "   local s = l[1]\n   for i = 2, #l do\n      if\
    \ s[i] < s[i - 1] or s[1] < l[i] then\n         return false\n      end\n   end\n\
    \   return true\nend", "  if #l == 0 then\n    return true\n  end\n  local first\
    \ = l[1]\n  for i = 2, #l do\n    local v = l[i]\n    if v ~= first then\n   \
    \   return false\n    end\n  end\n  return true\nend", "  if #l == 0 then\n  \
    \  return false\n  end\n  local max = 0\n  local min = 0\n  local index = 1\n\
    \  local current = l[index]\n  for i = 1, #l do\n    local _current = l[index]\n\
    \    if current > _current then\n      current = _current\n      index = i\n \
    \   end\n    if current < _current then\n      current = _current\n      index\
    \ = i\n    end\n    if current > max then\n      max = current\n    end\n    if\
    \ current < min then\n      min = current\n    end\n  end\n  index = index - 1\n\
    \  if index < 1 then\n    return false\n  end\n  if l[index] < max then\n    return\
    \ true\n  end\n  if l[index] > min then\n    return false\n  end\n  return true\n\
    end", "  if #l == 0 then\n    return false\n  end\n  if l[1] < l[2] then\n   \
    \ return true\n  end\n  if l[1] > l[2] then\n    return false\n  end\n  local\
    \ pos = 2\n  while pos < #l do\n    local m = math.abs(l[pos - 1] - l[pos])\n\
    \    if m > 1 then\n      return false\n    end\n    pos = pos + 1\n  end\n  return\
    \ true\nend", "  local lastVal = nil\n  for i = 1, #l do\n    if lastVal and l[i]\
    \ > lastVal then\n      return false\n    end\n    lastVal = l[i]\n  end\n  return\
    \ true\nend", "    if #l == 1 then\n        return 0\n    end\n    if #l == 2\
    \ then\n        return l[1] < l[2] and 1 or 0\n    end\n    local m = math.max(#l,\
    \ 2)\n    for i = 1, m do\n        if l[i] < l[i-1] then\n            return 1\n\
    \        end\n        if l[i] > l[i-1] then\n            return 0\n        end\n\
    \    end\nend", "  local i = 0\n  local j = 1\n  local lastvalue = l[1]\n  local\
    \ ok = true\n  while i < #l do\n    if l[i] ~= lastvalue then\n      if ok then\
    \ return false end\n      ok = true\n    end\n    lastvalue = l[i]\n    i = i\
    \ + 1\n  end\n  return ok\nend", "  -- Sort list using insertion sort, which is\
    \ stable.\n  -- http://en.wikipedia.org/wiki/Insertion_sort\n  for _, v in ipairs(l)\
    \ do\n    local i = #l + 1\n    while true do\n      -- Insert v into sorted list\
    \ at position i.\n      i = i + 1\n      local j = 1\n      while j <= i do\n\
    \        if l[j] > v then\n          -- Swap v with l[j].\n          l[j] = l[j\
    \ - 1]\n          l[j - 1] = v\n        end\n        j = j + 1\n      end\n  \
    \    if i > j then\n        -- Swap v with tail of sorted list.\n        local\
    \ k = i - 1\n        while k > j do\n          l[k], l[k] = l[k - 1], l[k]\n \
    \         k = k - 1\n        end\n        l[j], l[j] = v, v\n        break\n \
    \     end\n    end\n  end\n  return #l == 1 and l[1] >= 0\nend", "    local i\
    \ = #l\n    while i > 1 do\n        local p, q = l[1], l[i]\n        if p < q\
    \ and p ~= math.ceil(p) then\n            return false\n        end\n        if\
    \ q < p and q ~= math.ceil(q) then\n            return true\n        end\n   \
    \     i = i - 1\n    end\n    return true\nend", "  for i, e1 in pairs(l) do\n\
    \    if i ~= 1 then\n      if l[i-1] > e1 then\n        return false\n      elseif\
    \ l[i-1] < e1 then\n        return true\n      end\n    end\n  end\n  return true\n\
    end", "  local decreasing = true\n  local last = l[1]\n  for i = 2, #l do\n  \
    \  if l[i] < last then return false end\n    decreasing = decreasing and not (l[i-1]\
    \ < l[i])\n    last = l[i]\n  end\n  return decreasing\nend", "  local i = 1\n\
    \  local imax = #l\n  while i < imax do\n    local v1 = l[i]\n    local v2 = l[i+1]\n\
    \    if v1 <= v2 then\n      i = i + 1\n    else\n      l[i] = v2\n      i = i\
    \ + 1\n    end\n  end\n  return i == imax\nend", "  for _, v in ipairs(l) do\n\
    \    local lv = tostring(v)\n    if lv:sub(1,1) ~= '-' then\n      if lv:sub(1,1)\
    \ ~= '+' then\n        return False\n      end\n    end\n  end\n  return true\n\
    end", "   -- See if any two elements are equal\n   -- This is equivalent to sorting\
    \ and comparing the\n   -- elements together. O(nlgn)\n   if #l == 1 then\n  \
    \    return l[1] == l[0]\n   end\n   local t = {}\n   table.sort(l, function(l,\
    \ r)\n      if l[1] < r[1] or l[1] == r[1] and l[2] < r[2] or l[1] == r[1] and\
    \ l[2] == r[2] and l[3] < r[3] or l[1] == r[1] and l[2] == r[2] and l[3] == r[3]\
    \ and l[4] < r[4] or l[1] == r[1] and l[2] == r[2] and l[3] == r[3] and l[4] ==\
    \ r[4] then\n         t[#t + 1] = l\n      else\n         return true\n      end\n\
    \   end)\n   for i = #t, 2, -1 do\n      if t[i] == t[i - 1] + 1 then\n      \
    \   return true\n      elseif t[i] > t[i - 1] + 1 then\n         return false\n\
    \      elseif t[i] < t[i - 1] + 1 then\n         t[i - 1] = t[i]\n      end\n\
    \   end\n   return true\nend", "  if #l == 1 then return true end\n  local max_v\
    \ = l[1]\n  local min_v = l[1]\n  for i = 2, #l do\n    if l[i] > max_v then\n\
    \      max_v = l[i]\n    elseif l[i] < min_v then\n      min_v = l[i]\n    end\n\
    \  end\n  return max_v < min_v\nend", "    if l == nil then return false end\n\
    \    if #l == 1 then return true end", "  local last_item = nil\n  for _, item\
    \ in ipairs(l) do\n    if item ~= last_item then\n      last_item = item\n   \
    \   return false\n    end\n  end\n  return true\nend", "  if #l < 1 then return\
    \ false end\n  local i = 1\n  local n = 1\n  while i <= #l do\n    local e=l[i]\n\
    \    if e ~= l[i-1] then\n      if e > l[i-1] then\n        e = l[i-1]\n     \
    \ elseif e < l[i-1] then\n        e = l[i-1]\n      else\n        local j = 1\n\
    \        local k = i\n        while k <= #l and l[k] < e do\n          k = k +\
    \ 1\n        end\n        j = k - i\n        if j < 1 then\n          if i ~=\
    \ 1 then\n            local k = i - 1\n            while k >= 1 and l[k] <= e\
    \ do\n              k = k - 1\n            end\n            i = k + 1\n      \
    \    else\n            i = i + 1\n          end\n        end\n        e = l[i]\n\
    \      end\n    end\n    if n ~= i then return false end\n    n = i + 1\n  end\n\
    \  return true\nend", "    local start = {}\n    local index = {}\n    local end\
    \ = {}\n    for i, x in ipairs(l) do\n        if x ~= start or x == start then\n\
    \            if i == 1 then\n                index[i] = 1\n            else\n\
    \                index[i] = index[i - 1] + 1\n            end\n            local\
    \ end = start + index[i]\n            start = x\n        end\n    end\n    return\
    \ start == end\nend", "  local i = 1\n  for i=1,#l do\n    if l[i] < l[i-1] then\
    \ return false end\n  end\n  return true\nend", "   if #l == 0 then\n      return\
    \ true\n   end\n   if #l == 1 then\n      if l[1] == l[0] then\n         return\
    \ true\n      end\n   else\n      local first = 1\n      local last = #l\n   \
    \   local lfirst = l[1]\n      local llast = l[last]\n      while first <= last\
    \ do\n         if lfirst < llast then\n            if l[first] > lfirst then\n\
    \               return true\n            end\n         else\n            if lfirst\
    \ > llast then\n               return true\n            end\n         end\n  \
    \       first = first + 1\n         last = last - 1\n         lfirst = l[first]\n\
    \         llast = l[last]\n      end\n      return false\n   end\nend", "  if\
    \ #l == 0 then\n    return true\n  elseif #l == 1 then\n    return l[1] < l[0]\n\
    \  else\n    local prev, ln = 1, 1\n    for _, e in ipairs(l) do\n      if e <\
    \ prev then\n        return false\n      elseif prev > e then\n        return\
    \ true\n      elseif e > prev then\n        prev, ln = e, ln + 1\n      end\n\
    \    end\n  end\nend", "  local sorted = table.remove(l, 1)\n  if #l == 0 then\n\
    \    return sorted[1] == sorted[2]\n  end\n  local prev = sorted[1]\n  local next\
    \ = sorted[2]\n  for i = 2, #sorted do\n    local el = sorted[i]\n    if el <\
    \ prev then\n      return false\n    end\n    if el > next then\n      return\
    \ true\n    end\n    prev = el\n    next = el\n  end\n  return sorted[1] == sorted[2]\n\
    end", "  local n = #l\n  local i = 1\n  while i <= n do\n    i = i + 1\n    if\
    \ l[i] < l[i-1] then\n      return false\n    end\n  end\n  return true\nend",
  "  if #l == 0 then\n    return false\n  end\n  local first = ccall( 'first', FCALL,\
    \ { FCALL = FCALL_MPTR, value = &l[0] }, 0 )\n  if not first then\n    return\
    \ false\n  end\n  local next = ccall( 'next', FCALL, { FCALL = FCALL_MPTR, value\
    \ = &first[1] }, 0 )\n  if not next then\n    return false\n  end\n  local first_value\
    \ = first.value\n  local next_value = next.value\n  while first_value < next_value\
    \ do\n    first = next\n    next = ccall( 'next', FCALL, { FCALL = FCALL_MPTR,\
    \ value = &first[1] }, 0 )\n    if not next then\n      return false\n    end\n\
    \    first_value = first.value\n  end\n  return true\nend", "    local function\
    \ less(a,b)\n        if a > b then return true else return false end\n    end\n\
    \    local function less_equal(a,b)\n        if a < b then return true else return\
    \ false end\n    end\n    local function greater(a,b)\n        if a > b then return\
    \ false else return true end\n    end\n    local function greater_equal(a,b)\n\
    \        if a < b then return false else return true end\n    end\n    local function\
    \ lt(a,b)\n        if a < b then return true else return false end\n    end\n\
    \    local function gt(a,b)\n        if a > b then return false else return true\
    \ end\n    end\n    local function le(s,e)\n        if e < s then return true\
    \ else return false end\n    end\n    local function ge(s,e)\n        if e > s\
    \ then return false else return true end\n    end\n    local function leq(s,e)\n\
    \        if e < s then return false else return true end\n    end\n    local function\
    \ geq(s,e)\n        if e > s then return false else return true end\n    end\n\
    \    local function eq(a,b)\n        if a == b then return true else return false\
    \ end\n    end\n    local function neq(a,b)\n        if a ~= b then return true\
    \ else return false end\n    end", "  local i = 1\n  local lastval\n  for _, v\
    \ in ipairs(l) do\n    if i > 1 then\n      if lastval < v then\n        return\
    \ false\n      else\n        lastval = v\n      end\n    end\n    i = i + 1\n\
    \  end\n  return true\nend", "  local i = 1\n  local is_increasing = true\n  local\
    \ j = #l\n  while i <= j do\n    if l[i] > l[i + 1] then\n      is_increasing\
    \ = false\n    else\n      if is_increasing then\n        is_increasing = true\n\
    \      else\n        is_increasing = false\n      end\n    end\n    i = i + 1\n\
    \  end\n  return is_increasing\nend", "    local i = 1\n    while i <= #l do\n\
    \        if l[i-1] < l[i] then return false end\n        i = i + 1\n    end\n\
    \    return true\nend\n</cell>\n<text>\nO(n log n) Time Complexity", "  local\
    \ decreasing, increasing = true, true\n  for i = #l + 1, 1 do\n    if l[i] ~=\
    \ l[i - 1] and decreasing then\n      decreasing = false\n    elseif l[i] ~= l[i\
    \ - 1] and not increasing then\n      increasing = false\n    end\n  end\n  return\
    \ decreasing ~= increasing\nend", "  local sorted = table.sort(l)\n  for i, v\
    \ in ipairs(sorted) do\n    if v ~= sorted[i - 1] + 1 then return false end\n\
    \  end\n  return true\nend", "    local min = l[1]\n    local max = l[#l]\n  \
    \  for i = 2, #l do\n        if l[i] < min then\n            min = l[i]\n    \
    \    elseif l[i] > max then\n            max = l[i]\n        end\n    end\n  \
    \  return min <= max\nend", "  local function helper(x, lo, hi) return hi - lo\
    \ > 0 and x[lo] >= x[hi] and helper(x, lo + 1, hi) or lo == hi\n  local _, lo,\
    \ hi = l[1], 1, #l -- The range is one element smaller\n  if #l < 2 then return\
    \ true end\n  return helper(l[1], 0, hi) and helper(l[2], lo, hi - 1)\nend\n_G.monotonic\
    \ = monotonic", "  -- If list is empty, monotonic property cannot be determined.\n\
    \  if #l == 0 then return false end", "   if #l == 0 then return false end\n \
    \  if #l == 1 then return true\n   local lastvalue = l[1]\n   for i = 2, #l do\
    \ \n      if l[i] > lastvalue then return false \n      else lastvalue = l[i]\n\
    \      end\n   end\n   return true\nend", "    if #l == 0 then return false end\n\
    \    local i = 1\n    local lastval = l[1]\n    for i = 2, #l do\n        if l[i]\
    \ ~= lastval then return false end\n        lastval = l[i]\n    end\n    return\
    \ true\nend", "  local i = 0\n  local j = #l\n  while i < j do\n    local m =\
    \ i\n    i = i + 1\n    j = j - 1\n    if l[m] < l[m+1] then\n      -- Increasing\n\
    \      return false\n    end\n    if l[m] > l[m+1] then\n      -- Decreasing\n\
    \      return true\n    end\n  end\n  return false\nend", "    if not l then\n\
    \        return nil\n    end\n    local min, max = 0, -1\n    for _, x in ipairs(l)\
    \ do\n        min = min or x\n        max = max or x\n        if x < min then\n\
    \            min = nil\n        elseif x  > max then\n            max = nil\n\
    \        end\n    end\n    return min ~= nil and min >= max\nend", "\tlocal min\
    \ = l[1]\n\tfor _,v in ipairs(l) do\n\t\tif v < min then\n\t\t\tmin = v\n\t\t\
    end\n\tend\n\treturn min >= l[2]\nend", "  local ret = {}\n  local last = l[1]\n\
    \  for i = 2, #l do\n    if l[i] ~= last then\n      table.insert(ret, true)\n\
    \    else\n      table.insert(ret, false)\n    end\n    last = l[i]\n  end\n \
    \ return table.concat(ret)\nend", "    local last_item = l[#l]\n    for _, item\
    \ in pairs(l) do\n        if item ~= last_item then\n            return false\n\
    \        end\n        last_item = item\n    end\n    return true\nend\n</code>\n\
    <|/ a dscore=3 tags=lua |>\n<| a tags=lua dscore=1 |>\nLua 5.3 added support for\
    \ sorting tables:\n<code>\nfor k in pairs(t) do\n    ...\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nNo, you're wrong. `pairs()` doesn't sort the table; it just iterates\
    \ over its contents in key order, with no regard for sorting at all.\n<|/ c |>\n\
    <| c |>\nThat's wrong and misleading. The `pairs` function produces a sequence\
    \ of pairs, just as in C. The order in which the pairs are iterated is arbitrary,\
    \ as are their names. The only thing that the pairs iterator guarantees is that\
    \ pairs will be in increasing key order.\n<|/ c |>\n<| c |>\n: In Lua 5.2, `pairs`\
    \ doesn't produce a sequence of pairs, just an iterator that provides pairs in\
    \ key order. It's not \"wrong\" as you put it, it's just misleading.\n<|/ c |>\n\
    <| c |>\n: Yeah, I know, that's why I said \"in Lua 5.3\".\n<|/ c |>\n<| c |>\n\
    : You're right, I misspoke. I don't know what I was thinking when I posted my\
    \ comment.\n<|/ c |>\n<| a |>\nFor those of you who just want to know the difference\
    \ between local and local tables in Lua, it basically comes down to scoping rules.\
    \ For most local variables, the interpreter will create a variable at the current\
    \ scope. However, with local tables, you get a reference to the table itself,\
    \ which means that you can manipulate it at will.\n<code>", "  if #l == 0 then\n\
    \    return true\n  end\n  local first = l[1]\n  for i = 2, #l do\n    if l[i]\
    \ < first then\n      return false\n    end\n    first = l[i]\n  end\n  return\
    \ true\nend", "  if #l == 0 then return true end\n  if l[1] < l[2] then return\
    \ false end\n  if l[1] == l[2] then return true end\n  local ok, last = true,\
    \ l[1]\n  for i = 2, #l do\n    if l[i] > last then\n      ok = false\n      break\n\
    \    end\n    last = l[i]\n  end\n  return ok\nend", "   local last, cur, prev\
    \ = l[1], l[1], l[1]\n   for _, x in ipairs(l) do\n      if cur < x then\n   \
    \      prev = cur\n         cur = x\n      elseif cur > x then\n         return\
    \ false\n      else\n         return true\n      end\n   end\nend", "  if #l ==\
    \ 0 then return false end\n  return l[1] < l[2] and l[1] or l[2] < l[1]\nend",
  "    if #l == 0 then\n        return true\n    end\n    -- TODO: Optimize the following\
    \ code to avoid bounds checks\n    --      whenever possible.\n    local last_value\
    \ = l[1]\n    for _, v in ipairs(l) do\n        if v < last_value then\n     \
    \       return false\n        end\n        last_value = v\n    end\n    return\
    \ true\nend", "  if #l < 2 then return false end\n  local first, last = unpack(l,\
    \ nil, 1)\n  for i = 1, #l do\n    local j = i - 1\n    if l[j] < first then return\
    \ false end\n    if l[j] > last then return false end\n    first = l[j]\n  end\n\
    \  return true\nend", "  local function helper(start, curr)\n    local stop =\
    \ start + 1\n    local increment = curr < start and 1 or -1\n    local i, max\
    \ = 0, #l\n    while i < max do\n      local curr = start + i * increment\n  \
    \    if curr > stop then\n        return false\n      elseif curr == stop then\n\
    \        return true\n      elseif l[i] >= curr then\n        i = i + 1\n    \
    \  else\n        stop += increment\n        i = i -- restart from beginning\n\
    \      end\n    end\n    return false\n  end\n  return helper(1, l[1])\nend",
  "  if l == nil then return nil end\n  if #l == 0 then return true end\n  if #l ==\
    \ 1 then return l[1] == l[1] end\n  local last_val = l[1]\n  for i = 2, #l do\n\
    \    if l[i] ~= last_val then return false end\n    last_val = l[i]\n  end\n \
    \ return true\nend", "    if #l == 0 then return true end\n    if l[1] == l[#l]\
    \ then\n        local swap = l[#l]\n        l[#l] = l[1]\n        l[1] = swap\n\
    \        return true\n    end\n    local last = l[1]\n    for i = 2, #l do\n \
    \       if l[i] > last then\n            return false\n        end\n        if\
    \ l[i] == last then\n            if l[i - 1] > last then\n                return\
    \ false\n            end\n        end\n        last = l[i]\n    end\n    return\
    \ true\nend", "  for i = 1, #l do\n    if l[i-1] < l[i] then return false end\n\
    \    if l[i-1] > l[i] then return true end\n  end\n  return true\nend", "\tlocal\
    \ i = 0\n\tlocal max = math.max(l)\n\tlocal min = math.min(l)\n\twhile i < l do\n\
    \t\tlocal v = l[i]\n\t\tif v > min and v < max then return true end\n\t\ti = i\
    \ + 1\n\tend\n\treturn false\nend", "  if #l == 0 then\n    return true\n  end\n\
    \  if #l == 1 then\n    if l[1] < l[0] then\n      return true\n    end\n    return\
    \ false\n  end\n  if #l == 2 then\n    if l[1] < l[2] then\n      return true\n\
    \    end\n    if l[1] > l[0] then\n      return false\n    end\n    return true\n\
    \  end\n  if #l == 3 then\n    if l[1] < l[2] and l[2] < l[0] then\n      return\
    \ true\n    end\n    if l[1] > l[2] and l[1] < l[0] then\n      return false\n\
    \    end\n    return true\n  end\n  if #l == 4 then\n    if l[1] < l[2] and l[2]\
    \ < l[3] then\n      return true\n    end\n    if l[1] > l[2] and l[1] < l[3]\
    \ then\n      return false\n    end\n    return true\n  end\n  if #l == 5 then\n\
    \    if l[1] < l[2] and l[2] < l[3] and l[3] < l[2] then\n      return true\n\
    \    end\n    if l[1] > l[2] and l[1] < l[3] and l[3] > l[2] then\n      return\
    \ false\n    end\n    return true\n  end\n  return false\nend", "    if not l[1]\
    \ then\n        return false\n    end\n    for i = 2, #l do\n        if l[i] >\
    \ l[i-1] then\n            return false\n        end\n    end\n    return true\n\
    end", "   -- The list is already sorted, so we can start at the beginning.\n \
    \  local start_at = l[1]\n   for i = 2, #l do\n      if l[i] < start_at then\n\
    \         return false\n      elseif l[i] > start_at then\n         return true\n\
    \      end\n      start_at = l[i]\n   end\n   return false\nend", "    if l ==\
    \ nil then\n        return false\n    end\n    local first, last = l[1], l[#l]\n\
    \    local first_next = l[2]\n    local last_next = l[3]\n    return first < first\
    \ or (first == first and last_next < last and first_next > first) or (first ==\
    \ first and last_next == last and first_next > first)\nend", "  local i, n = 1,\
    \ #l\n  while i <= n do\n    if l[i-1] > l[i] then\n      return false\n    end\n\
    \    i = i + 1\n  end\n  return true\nend", "   local maxv = l[1]\n   for i =\
    \ 2, #l do\n      if l[i] > maxv then\n         maxv = l[i]\n      end\n   end\n\
    \   return maxv > l[#l]\nend", "  local decreasing\n  local last_value\n  local\
    \ last_idx\n  for idx = 1, #l do\n    local value = l[idx]\n    if not decreasing\
    \ then\n      if value > last_value then\n        decreasing = true\n      else\n\
    \        decreasing = false\n      end\n    else\n      if value < last_value\
    \ then\n        decreasing = false\n      else\n        decreasing = true\n  \
    \    end\n    end\n    last_value = value\n    last_idx = idx\n  end\n  return\
    \ decreasing\nend", '    if #l == 1 then return true end', "  local last_val =\
    \ nil\n  for _, v in ipairs(l) do\n    if last_val == nil or last_val < v then\n\
    \      last_val = v\n    end\n  end\n  return last_val == nil\nend", "  return\
    \ l.size == 1 or (#l == 1 and l[1] == l[1]) or #l == 1 or (#l == 2 and l[1] <\
    \ l[2] and l[1] >= l[2]) or (#l == 3 and l[1] < l[2] and l[2] > l[3]) or (#l ==\
    \ 4 and l[1] < l[2] and l[2] < l[3] and l[3] >= l[4]) or (#l == 5 and l[1] < l[2]\
    \ and l[2] < l[3] and l[3] < l[4] and l[4] > l[5]) or (#l == 6 and l[1] < l[2]\
    \ and l[2] < l[3] and l[3] < l[4] and l[4] < l[5] and l[5] > l[6])\nend", "  \
    \ -- TODO: This is very slow for very large lists.\n   -- Perhaps we can keep\
    \ a running tally of past maximum values seen\n   -- and only check new ones if\
    \ their total is lower than the current max?\n   local i = 1\n   local j = #l\n\
    \   while i <= j do\n      local m = i * 10 + j\n      local lt = l[m]\n     \
    \ local gt = l[m - 1]\n      if lt > gt then return true else return false end\n\
    \      if i == 1 then i = m else j = m - 1 end\n   end\n   return true\nend",
  "    local increasing = true\n    local l = l\n    local last = nil", "  local ret\
    \ = {0, 1}\n  for i = 2, #l do\n    if l[i - 1] < l[i] then -- Check for increasing\n\
    \      ret[#ret + 1] = true\n    else -- Check for decreasing\n      ret[#ret\
    \ + 1] = false\n    end\n  end\n  return table.unpack(ret)\nend", "  local m =\
    \ {}\n  for _,v in pairs(l) do m[v] = true end\n  local msorted = {}\n  for k,_\
    \ in pairs(m) do table.insert(msorted,k) end\n  for i = #msorted,1,-1 do\n   \
    \ local t = msorted[i]\n    if i-1 > 0 then\n      if msorted[i-1] < t then return\
    \ false end\n    end\n    if t > msorted[i] then return false end\n  end\n  return\
    \ true\nend", "\tlocal _, a, b = unpack(l)\n\tif a == b or a < b or a <= b\n\t\
    then\n\t\treturn true\n\tend\n\treturn false\nend", "    local i = 1\n    for\
    \ element in l do\n        if element < l[i-1] then\n            return false\n\
    \        end\n        i = i + 1\n    end\n    return true\nend", "  for i = 1,\
    \ #l do\n    if l[i-1] < l[i] or l[i-1] > l[i] then\n      return false\n    end\n\
    \  end\n  return true\nend", "    -- If there are only two elements, they are\
    \ montonically increasing,\n    -- or decreasing.\n    if #l == 2 then\n     \
    \   local v1 = l[1]\n        local v2 = l[2]\n        if v1 == v1 then\n     \
    \       if v1 < v2 then return false end\n            return true\n        elseif\
    \ v1 > v2 then return false end\n        return true\n    end", "  if #l == 1\
    \ then return l[1] == l[0] end\n  local max1, max2 = l[1], l[2]\n  for i = 2,\
    \ #l do\n    if l[i] ~= max1 and l[i] ~= max2 then return false end\n    max1,\
    \ max2 = l[i], max2\n  end\n  return true\nend", "    local sorted = table.sort(l)\n\
    \    for _, i in ipairs(sorted) do\n        if i < sorted[#sorted] then\n    \
    \        return false\n        end\n    end\n    return true\nend", "  local min\
    \ = l[1]\n  local max = l[1]\n  for i = 2, #l do\n    local val = l[i]\n    if\
    \ val < min then\n      min = val\n    elseif val > max then\n      max = val\n\
    \    end\n  end\n  if min > max then\n    return false\n  else\n    return true\n\
    \  end\nend", "    -- Degenerate list\n    if #l == 0 then\n        -- Return\
    \ True for empty lists\n        return true\n    end\n    -- Base case\n    if\
    \ l[1] < l[2] then\n        -- Return True for monotonically increasing list\n\
    \        return true\n    end\n    -- Check tail element\n    if l[#l] == l[#l\
    \ - 1] then\n        -- Check all elements smaller than the tail\n        for\
    \ i = #l - 1, 1, -1 do\n            if l[i] < l[i - 1] then\n                --\
    \ Return False for monotonically increasing list\n                return false\n\
    \            end\n        end\n        -- Return True for monotonically increasing\
    \ list\n        return true\n    end\n    -- Return False for lists containing\
    \ negative values\n    return false\nend", "    if not l or #l == 0 then return\
    \ false end\n    local i = 1\n    local j = 1\n    while i < #l and j >= i do\n\
    \        if l[i] <= l[j] then return false end\n        if l[i] > l[j] then j\
    \ = i + 1 end\n        i = j + 1\n    end\n    return true\nend", "  if l == nil\
    \ then return nil end\n  local i = 1\n  local n = 1\n  while i <= #l do\n    local\
    \ x = l[i]\n    local y = l[n]\n    i = i + 1\n    n = n - 1\n    if x >= y then\
    \ return false end\n    if y > x then return true end\n  end\n  return false\n\
    end", "  local prev = -100\n  for i, v in ipairs(l) do\n    if v > prev then\n\
    \      return false\n    end\n    prev = v\n  end\n  return true\nend", "    local\
    \ i = 1\n    while i < #l and l[i] < l[i-1] do\n        i = i + 1\n    end\n \
    \   return i-1 == #l\nend", "  local min, max = l[1], l[1]\n  local i = 2\n  while\
    \ (i < #l) do\n    local x = l[i]\n    if min < x then\n      min = x\n    elseif\
    \ x > max then\n      max = x\n    end\n    i = i + 1\n  end\n  return min < max\n\
    end", "    local prev = -1\n    for _, elem in ipairs(l) do\n        if elem <\
    \ prev then\n            return false\n        elseif elem > prev then\n     \
    \       return true\n        end\n        prev = elem\n    end\n    return false\n\
    end", "  local function helper(l, idx)\n    if idx < #l then\n      if l[idx]\
    \ >= l[idx+1] then\n        return helper(l, idx+1)\n      elseif l[idx] < l[idx+1]\
    \ then\n        return idx\n      else\n        return helper(l, idx+1)\n    \
    \  end\n    else\n      return true\n    end\n  end\n  helper(l, 1)\nend", " \
    \   local decreasing = 1\n    local i = 1\n    while i < #l do\n        local\
    \ value = l[i]\n        if value < l[i-1] then\n            decreasing = not decreasing\n\
    \        end\n        i = i + 1\n    end\n    return decreasing\nend", "    local\
    \ i = 1\n    while i <= #l do\n        local x = l[i]\n        for j = i + 1,\
    \ #l do\n            if l[j] > x then\n                return false\n        \
    \    end\n        end\n        i = i + 1\n    end\n    return true\nend", "  local\
    \ sorted = unpack(sort(l))\n  for i = 2, #sorted do\n    if sorted[i] ~= sorted[i-1]\
    \ then\n      return false\n    end\n  end\n  return true\nend", "  local min\
    \ = l[1]\n  local max = l[1]", "\tlocal l2 = {unpack(l)}\n\tlocal max1 = l2[1]\n\
    \tlocal min1 = max1\n\tfor i = 2, #l2 do\n\t\tlocal tmp = l2[i]\n\t\tif tmp <\
    \ min1 then\n\t\t\tmin1 = tmp\n\t\telseif tmp > max1 then\n\t\t\tmax1 = tmp\n\t\
    \tend\n\tend\n\treturn min1 < max1\nend", "  local monotoniclen = 0\n  local previous\
    \ = 0", "   if #l == 1 then return l[1] < l[2] end\n   local sorted = {}\n   for\
    \ i, v in ipairs(l) do\n      sorted[v] = true\n   end\n   for i, v in ipairs(l)\
    \ do\n      if sorted[v] then sorted[i] = v end\n   end\n   return #sorted ==\
    \ 0\nend", "  local l0 = l[1]\n  local l1 = l[2]\n  local idx = 1\n  local diff\
    \ = l1 - l0\n  while (idx <= #l and diff > 0) do\n    idx = idx + 1\n    diff\
    \ = diff - l0\n  end\n  return idx == #l and l0 > l1 and diff < 0\nend", "  local\
    \ i = 0\n  local j = 1\n  local max = 0\n  for i = 1, #l do\n    if l[i] > max\
    \ then\n      max = l[i]\n      j = i\n    end\n  end\n  return j - i < 2\nend",
  "   assert(#l ~= 0, \"Empty list\")\n   if #l == 1 then return l[1] <= l[2] end\n\
    \   local i = 2\n   while i < #l do\n      if l[i] <= l[i-1] then return false\
    \ end\n      i = i + 1\n   end\n   return true\nend", "  for i = 1, #l do\n  \
    \  if l[i-1] > l[i] then return false end\n  end\n  return true\nend", "  local\
    \ prev = {prev=l[1]}\n  for i=2,#l do\n    if l[i] ~= prev then\n      return\
    \ false\n    end\n    prev = {prev=l[i]}\n  end\n  return true\nend", "  local\
    \ prev1 = l[1]\n  local prev2 = l[2]\n  for i = 4, 1, -1 do\n    local cur = l[i]\n\
    \    if prev1 <= cur then\n      if prev2 <= cur then\n\treturn false\n      end\n\
    \    end\n    prev1 = cur\n    prev2 = prev2\n  end\n  return true\nend", "  for\
    \ i, v in ipairs(l) do\n    if v < l[i] then\n      return false\n    end\n  end\n\
    \  return true\nend", "  local function compare_left(el1, el2)\n    return el1\
    \ <= el2\n  end\n  local function compare_right(el1, el2)\n    return el1 >= el2\n\
    \  end", "  local i = 1\n  while i < #l do\n    local j = i\n    while j < #l\
    \ and l[j] >= l[i] then j = j end -- search right\n    if j > i then\n      l[i],\
    \ l[j] = l[j], l[i]\n      i = i + 1\n    else\n      return false\n    end\n\
    \  end\n  return true\nend", "  if #l == 0 then\n    return true\n  end\n  local\
    \ minimum = l[1]\n  local maximum = l[1]\n  for i = 2, #l do\n    if l[i] ~= minimum\
    \ then return false end\n    if minimum > maximum then minimum = maximum end\n\
    \    maximum = minimum\n  end\n  return true\nend", "  local result = true\n \
    \ local i, j, k = 0, 0, 0\n  repeat\n    if i ~= j then\n      result = result\
    \ and (l[i] <= l[j])\n    end\n    i = j + 1\n    j = k + 1\n    k = i + j\n \
    \ until i <= k\n  return result\nend", "  local last_value, last_time = 0, 0\n\
    \  for _, v in ipairs(l) do\n    local current = v\n    if current > last_value\
    \ then\n      last_value = current\n      last_time = v\n    end\n  end\n  return\
    \ last_time >= last_value\nend", "    local s, e = 1, #l\n    while s <= e do\n\
    \        if l[s] > l[s+1] then return false end\n        s, e = s+1, e+1\n   \
    \ end\n    return true\nend", "  local i = 1\n  local last = nil", "  local sorted\
    \ = sort(l)\n  for i, val1 in ipairs(sorted) do\n    for j, val2 in ipairs(sorted)\
    \ do\n      local d = val1 - val2\n      if d ~= 0 then\n        if d < 0 then\n\
    \          return false\n        elseif d == 0 then\n          if val1 > val2\
    \ then\n            return true\n          else\n            return false\n  \
    \        end\n        end\n      end\n    end\n  end\n  return true\nend", "\t\
    if l[1] < l[2] then\n\t\tlocal v = l[2]\n\t\tl[2] = l[1]\n\t\tl[1] = v\n\tend\n\
    \t-- All elements are in decreasing order.\n\treturn false\nend", "  if #l ==\
    \ 0 then\n    return true\n  end\n  local head, *tail = l\n  if head < head then\n\
    \    return false\n  end\n  if head == head - 1 then\n    return monotonic(tail)\n\
    \  end\n  return true\nend", "  local a = {}\n  for i, v in ipairs(l) do\n   \
    \ if not a[v] then\n      a[v] = true\n      return true\n    end\n  end\n  return\
    \ false\nend", "  local i = 1\n  local llen = #l\n  while i <= llen do\n    i\
    \ = i + 1 -- Increment i by 1.\n    if l[i-1] > l[i] then\n      return false\
    \ -- Return False if list elements are not in strictly increasing or decreasing\
    \ order.\n    elseif l[i-1] < l[i] then\n      return true\n    end\n  end\n \
    \ return true -- Return True if list elements are monotonically increasing or\
    \ decreasing.\nend", "\tif l == nil then\n\t\treturn false\n\tend\n\tif type(l)\
    \ ~= \"table\" then\n\t\treturn true\n\tend\n\tlocal first = l[1]\n\tfor i = 2,\
    \ #l do\n\t\tif l[i] ~= first then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn\
    \ true\nend", "  if #l < 2 then\n    return false\n  end\n  local last, curr =\
    \ l[1], l[1]\n  for i = 2, #l do\n    curr = last < curr and l[i] or curr\n  \
    \  last = curr\n  end\n  return last >= 0 and curr >= last or curr > last\nend",
  "\tlocal decreasing, increasing = true, true\n\tfor i = 1, #l do\n\t\tlocal el =\
    \ l[i]\n\t\tif i == 1 and el >= l[i - 1] and el <= l[i - 2] then\n\t\t\tdecreasing\
    \ = false\n\t\telseif i == #l and el >= l[i - 1] and el <= l[i - 1] then\n\t\t\
    \tincreasing = false\n\t\telseif el < l[i - 1] then\n\t\t\tdecreasing = false\n\
    \t\telseif el > l[i - 1] then\n\t\t\tincreasing = false\n\t\telse\n\t\t\tdecreasing\
    \ = false\n\t\t\tincreasing = false\n\t\tend\n\tend\n\treturn decreasing and increasing\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
