name: HumanEval_72_will_it_fly
language: lua
prompt: "-- Write a function that returns True if the object q will fly, and False\
  \ otherwise.\n-- The object q will fly if it's balanced (it is a palindromic list)\
  \ and the sum of its elements is less than or equal the maximum possible weight\
  \ w.\n-- Example:\n-- will_it_fly([1, 2], 5) \u279E False \n-- # 1+2 is less than\
  \ the maximum possible weight, but it's unbalanced.\n-- will_it_fly([3, 2, 3], 1)\
  \ \u279E False\n-- # it's balanced, but 3+2+3 is more than the maximum possible\
  \ weight.\n-- will_it_fly([3, 2, 3], 9) \u279E True\n-- # 3+2+3 is less than the\
  \ maximum possible weight, and it's balanced.\n-- will_it_fly([3], 5) \u279E True\n\
  -- # 3 is less than the maximum possible weight, and it's balanced.\nlocal function\
  \ will_it_fly(q, w)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = will_it_fly\n\
  \    lu.assertEquals(candidate({3, 2, 3}, 9), true)\n    lu.assertEquals(candidate({1,\
  \ 2}, 5), false)\n    lu.assertEquals(candidate({3}, 5), true)\n    lu.assertEquals(candidate({3,\
  \ 2, 3}, 1), false)\n    lu.assertEquals(candidate({1, 2, 3}, 6), false)\n    lu.assertEquals(candidate({5},\
  \ 5), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local max_possible = w\n  local sum_all = 0\n  for i = 1, #q do\n\
    \    local v = q[i]\n    sum_all = sum_all + v\n    if sum_all > max_possible\
    \ then\n      return false\n    end\n  end\n  return true\nend", "    if not is_palindrome(q)\
    \ then\n        return false\n    end", "  -- Check balance\n  if will_it_fly_helper(q,\
    \ w, w) then return true end\n  -- Check sum of weight\n  if will_it_fly_helper(q,\
    \ w, w) then return true end\n  -- Check max weight\n  if will_it_fly_helper(q,\
    \ w, w) then return true end\n  return false\nend", "   if w <= 0 then\n     \
    \ return {false, 0}\n   end\n   if #q == 0 then\n      return {true, 0}\n   end\n\
    \   local pal_sum = #q\n   if #q == 1 then\n      pal_sum = q[1]\n   end\n   local\
    \ pal_sum2 = pal_sum * pal_sum\n   local w_q = w * pal_sum\n   local w_w_q = w_q\
    \ * w\n   local w_w_q2 = w_w_q * w_q\n   local w_w_q3 = w_w_q2 * w_q\n   if w_w_q\
    \ >= w_w_q2 and w_w_q >= w_w_q3 then\n      return {true, pal_sum}\n   elseif\
    \ w_w_q >= w_w_q2 then\n      return {false, pal_sum}\n   elseif w_w_q >= w_w_q3\
    \ then\n      return {true, pal_sum2}\n   else\n      return {false, pal_sum2}\n\
    \   end\nend", "   -- base case\n   if #q == 1 then\n      return true\n   end\n\
    \   -- recurrence relation\n   if will_it_fly(q:sub(1,1), w) and\n   will_it_fly(q:sub(2),\
    \ w) and\n   will_it_fly(q:sub(1,2), w) and\n   will_it_fly(q:sub(1,3), w) and\n\
    \   will_it_fly(q:sub(3,1), w) and\n   will_it_fly(q:sub(3,2), w) and\n   will_it_fly(q:sub(3,3),\
    \ w) and\n   will_it_fly(q:sub(3,4), w) and\n   will_it_fly(q:sub(4,3), w) and\n\
    \   will_it_fly(q:sub(4,2), w) and\n   will_it_fly(q:sub(4,1), w) and\n   will_it_fly(q:sub(4,4),\
    \ w) and\n   will_it_fly(q:sub(4,5), w) and\n   will_it_fly(q:sub(5,4), w) and\n\
    \   will_it_fly(q:sub(5,3), w) and\n   will_it_fly(q:sub(5,2), w) and\n   will_it_fly(q:sub(5,1),\
    \ w) and\n   will_it_fly(q:sub(5,5), w) and\n   will_it_fly(q:sub(5,6), w) and\n\
    \   will_it_fly(q:sub(6,5), w) and\n   will_it_fly(q:sub(6,4), w) and\n   will_it_fly(q:sub(6,3),\
    \ w) and\n   will_it_fly(q:sub(6,2), w) and\n   will_it_fly(q:sub(6,1), w) and\n\
    \   will_it_fly(q:sub(6,6), w) and\n   will_it_fly(q:sub(6,7), w) and\n   will_it_fly(q:sub(7,6),\
    \ w) and\n   will_it_fly(q:sub(7,5), w) and\n   will_it_fly(q:sub(7,4), w) and\n\
    \   will_it_fly(q:sub(7,3), w) and\n   will_it_fly(q:sub(7,2), w) and\n   will_it_fly(q:sub(7,1),\
    \ w) and\n   will_it_fly(q:sub(7,7), w) and\n   will_it_fly(q:sub(7,8), w) and\n\
    \   will_it_fly(q:sub(8,7), ", "\tif w == 0 then return true end\n\tlocal rev\
    \ = w\n\tif w == 1 then return false end\n\trepeat\n\t\trev = rev * 10 + math.floor(math.log10(math.abs(rev)))\n\
    \tuntil rev > w\n\treturn ((#q == 0 and q) or #q == #q and q:reverse() == q:reverse())\
    \ and (#q == 0 or #q == #q and q:reverse() == q:reverse())\nend", "\t-- check\
    \ if q is balanced\n\tif sum_list(q, w) <= w then\n\t\treturn true\n\telse\n\t\
    \t-- check if it's a palindrome\n\t\tlocal q_palindrome = q:reverse()\n\t\treturn\
    \ sum_list(q_palindrome, w) <= w \n\tend\nend", "    if q ~= nil then\n      \
    \  if #q == 1 then\n            if will_it_fly(q[1], w) then\n               \
    \ return true\n            else\n                return false\n            end\n\
    \        else\n            local sum = 0\n            for i = 1, #q do\n     \
    \           sum = sum + q[i]\n                if sum <= w then\n             \
    \       if will_it_fly(q[#q - 1], w) then\n                        return true\n\
    \                    else\n                        return false\n            \
    \        end\n                end\n            end\n        end\n    end\n   \
    \ return true\nend", "    local max_weight = w\n    local max_fly_sum = 0", " \
    \ local s = sum (q) \n  return s and s < w \nend", "\t-- Check if q is a palindromic\
    \ list\n\tif palindromic(q) then\n\t\t-- Check if sum of its elements is less\
    \ than or equal to the max possible weight\n\t\tif math.abs(#q - (#q % 2)) >=\
    \ w then return true end\n\tend\n\treturn false\nend", "    local function is_balanced(l)\n\
    \        local n = 1\n        for i = 1,#l do\n            n = n*i\n        end\n\
    \        return #l == n\n    end\n    return is_balanced(q) and (q:reverse() ==\
    \ q) and ((w:reverse() >= 0) and w) or false\nend", "    local balanced = true\n\
    \    local max_weight_so_far = 0\n    local weight = 0\n    for i = 1, #q do\n\
    \        -- if balanced then add to weight\n        balanced = balance and weight\n\
    \        -- check whether weight can be updated\n        if balance and weight\
    \ + q[i] > w then\n            -- reset max weight so far\n            max_weight_so_far\
    \ = weight\n            -- increment weight and try again\n            weight\
    \ = weight + q[i]\n        else\n            -- reset weight and check whether\
    \ it's balanced\n            weight = weight\n        end\n        -- if max weight\
    \ so far is greater than w\n        if max_weight_so_far > w then\n          \
    \  -- return false\n            return false\n        end\n    end\n    -- if\
    \ balanced and max weight so far is equal to w\n    return balanced and max_weight_so_far\
    \ == w\nend", "  local max_weight = w\n  local balanced = true\n  local sum_weight\
    \ = 0\n  for i = 1,#q do\n    local x = q[i]\n    sum_weight = sum_weight + x\n\
    \    if x > max_weight then\n      max_weight = x\n    end\n    if x ~= 0 and\
    \ sum_weight < max_weight then\n      balanced = false\n    end\n  end\n  return\
    \ balanced and sum_weight <= max_weight\nend", "\tif type(q) ~= 'table' then return\
    \ true end\n\tlocal sum = 0\n\tfor i=1,#q do sum = sum + q[i] end\n\treturn sum<=w\
    \ and will_it_fly(balanced(q),w)\nend", "  assert(type(q) == 'table')\n  assert(type(nil_will_it_fly)\
    \ == 'function')\n  assert(type(w) == 'number')\n  local max_weight = nil_will_it_fly()\n\
    \  local pal_weight = 0\n  for i=1,#q do\n    pal_weight = pal_weight + q[i]\n\
    \    if pal_weight >= w then\n      return true\n    end\n    max_weight = max_weight\
    \ or q[i]\n  end\n  return false\nend", "    local s = sum_list(q)\n    return\
    \ s == w and all_palindromic(q)\nend", "  -- base case\n  if q == nil then return\
    \ w == nil end\n  -- check balance\n  local balance = will_it_fly(q[1], w)\n \
    \ if balance == false then\n    return false\n  end\n  -- check sum of elements\n\
    \  local sum = 0\n  for i = 2, #q do\n    sum = sum + q[i]\n  end\n  return sum\
    \ >= w\nend", "  local w = w or 0\n  local is_balanced = true\n  local sum_weight\
    \ = 0", "  local maxw = max_weight(w)\n  return #q == 0 or\n    maxw == 0 or\n\
    \    not is_balanced(q, w) or\n    math.abs(sum_list(q) - maxw) <= maxw -- unbalanced\
    \ or balanced or less than or equal to max\nend", "  local sum = 0\n  \n  for\
    \ i = 1, #q do \n    sum = sum + q[i]\n  end", "  w = w or 0\n  local bal = 0\n\
    \  for i = 1, #q do\n    local num = q[i]\n    if i == 1 then \n      bal = bal\
    \ * num\n    else\n      bal = bal * num \n    end\n  end\n  return bal <= w \n\
    end", "   if type(q) == \"table\" then\n      local max_weight = #q\n      for\
    \ i = 1, #q-1 do\n         max_weight = max_weight + q[i]\n      end\n      --\
    \ If the last item in the list is balanced, then\n      -- if the sum of the last\
    \ item + the penultimate item <= w,\n      -- then the last item is guaranteed\
    \ to fly.\n      if q[#q-1] == 1 then\n         return ((w<=max_weight) and\n\
    \            (q[#q-2] == q[#q-1] and #q>2))\n      else\n         return ((w<=max_weight)\
    \ and\n            (#q > 2))\n      end\n   else\n      -- If the last item is\
    \ a number, then\n      -- if the sum of the last item + the last item <= w,\n\
    \      -- then the last item is guaranteed to fly.\n      return (w<=#q)\n   end\n\
    end", "    local maxw = w -- start at the current maximum possible weight\n  \
    \  if #q < 2 then return false end\n    for i = 2, #q do\n        if maxw >= w--\
    \ or maxw < 0 then return false end\n        if math.abs(q[i]) ~= math.abs(q[i\
    \ - 1]) then return false end\n        maxw = maxw - (q[i] * q[i - 1])\n    end\n\
    \    return maxw <= w \nend", "    local result\n    local weight = 0\n    local\
    \ sum = 0\n    while w > 0 do\n        weight = weight + q[#q]\n        sum =\
    \ sum + weight\n        w = w - 1\n    end\n    if sum == w then\n        result\
    \ = true\n    else\n        result = false\n    end\n    return result\nend",
  "  for i=1,#q-1 do\n    if q[i] ~= q[#q] then\n      return false\n    end\n  end",
  "    -- Your code here\n    if w == 0 or #q == 0 then\n        return true\n   \
    \ end\n    if #q == 1 then\n        return q[1] == w\n    end\n    if w == 0 then\n\
    \        return true\n    end\n    if #q > 1 then\n        return true\n    end\n\
    \    if will_it_fly(q, w - q[1]) then\n        if will_it_fly(q + q[1], w) then\n\
    \            return true\n        end\n    end\n    return false\nend", "  if\
    \ #q > 0 then\n    local sum = 0 \n    for _, v in pairs(q) do sum = sum + v end\n\
    \    sum >= w and q:reverse() and will_it_fly(q:reverse(), w) \n  end\nend", " \
    \ local max = tonumber(w)\n  if w ~= nil then\n    local s = sum_list(q)\n   \
    \ if s >= max then\n      return false\n    elseif s == max then\n      return\
    \ true\n    else\n      return true\n    end\n  else\n    return true\n  end\n\
    end", '  if w == 0 then return true end', "    local p = 0\n    for x = 1, #q-1\
    \ do\n        p = p + q[x]\n    end\n    if p == w and sum( #q ) == w and #q >\
    \ 1 then\n        return true\n    else\n        return false\n    end\nend",
  "    local result = false\n    for i,v in ipairs(q) do\n        if v == 1 then\n\
    \            local reversed = v:reverse()\n            local sum = 0\n       \
    \     for j = 1,w do\n                sum = sum + reversed[j]\n            end\n\
    \            if sum == w then\n                result = true\n               \
    \ break\n            end\n        end\n    end\n    return result\nend", "\t--\
    \ Check balance.\n\tif q:is_balanced() then\n\t\t-- Check sum of weights in list.\n\
    \t\tlocal s, max_w = 0, #q\n\t\tfor _, v in pairs(q) do\n\t\t\ts = s + v\n\t\t\
    \tmax_w = max_w > v ? max_w : v\n\t\tend\n\t\treturn s <= w and max_w <= w\n\t\
    end\n\treturn false\nend", "\tif is_balanced(q) then\n\t\tif sum(q) <= w then\
    \ return true end\n\tend\n\treturn false\nend", "    if w == 0 then return true\
    \ end\n    local ok = true -- initialize to true as we may encounter some errors\n\
    \    local sum = 0 -- sum of elements in q\n    for _, v in pairs(q) do sum =\
    \ sum + v end\n    -- if the list is balanced and sum of elements is less than\
    \ or equal to maximum possible weight, then return true\n    if sum == w then\
    \ return true end\n    local max_possible = sum / w -- get the maximum possible\
    \ value\n    local sum = 0 -- initialize sum variable\n    for _, v in pairs(q)\
    \ do sum = sum + v end\n    -- if the list is unbalanced, and the sum of its elements\
    \ is more than maximum possible value, then return false\n    if sum > max_possible\
    \ then return false end\n    -- calculate the sum of its elements less or equal\
    \ to the maximum possible value\n    for i = #q, 1, -1 do\n        if q[i] <=\
    \ max_possible then\n            local sum = 0\n            for _, v in pairs(q)\
    \ do sum = sum + v end\n            if sum <= w then return true end\n       \
    \ end\n    end\n    return false\nend", "    -- Write your code here\n    local\
    \ pal = true\n    local sum = 0\n    for _, v in pairs(q) do\n        if w > 0\
    \ then\n            sum = sum + v\n            w = w - 1\n        else\n     \
    \       if v == q[#q] then\n                return false\n            else\n \
    \               pal = false\n            end\n        end\n    end\n    return\
    \ pal and sum <= w\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "    local\
    \ max_weight = w - 1\n    local sum = 0\n    for _, v in pairs(q) do\n       \
    \ sum = sum + v\n        if sum > max_weight then return false end\n    end\n\
    \    return true\nend", "  local is_balanced = true\n  local sum = 0\n  for i\
    \ = 1, #q do\n    sum = sum + q[i]\n    if sum > w then\n      is_balanced = false\n\
    \    end\n  end\n  return is_balanced and (sum <= w)\nend", "  if q == nil then\
    \ return false end\n  if #q < 2 then return false end\n  if w == nil then return\
    \ false end\n  local max_weight = #q * w\n  local sum = 0\n  for i = 1, #q do\n\
    \    sum = sum + q[i]\n  end\n  return max_weight > sum\nend", "  -- Write your\
    \ solution here\n  return true\nend", "\t-- Base case.\n\tif w == 0 then return\
    \ true end\n\t-- If the current weight is too small, return false.\n\tif w < 0\
    \ then return false end\n\t-- If the current weight is equal to the maximum possible\
    \ weight, return true.\n\tif w == max_weight then return true end\n\t-- If the\
    \ current weight is greater than the maximum possible weight, return false.\n\t\
    if w > max_weight then return false end\n\t-- Otherwise, iterate through all palindromic\
    \ lists q and return true if their sum is less than or equal to w.\n\tfor i =\
    \ 1, #q do\n\t\t-- If the current list is not palindromic, continue to the next\
    \ loop.\n\t\tif not palindromic(q[i]) then return false end\n\t\t-- Otherwise,\
    \ iterate through all palindromic lists q[i] and add its elements.\n\t\tfor j\
    \ = 1, #q[i] do\n\t\t\t-- If the current list is not palindromic, continue to\
    \ the next loop.\n\t\t\tif palindromic(q[i][j]) then return false end\n\t\t\t\
    -- Otherwise, add the current element of q[i].\n\t\t\tif not will_it_fly(q[i][j],\
    \ w - q[i][j]) then return false end\n\t\tend\n\tend\n\treturn true\nend", " \
    \   assert(w ~= 0 and w <= 1000, \"w should be between 0 and 1000 inclusive\"\
    )\n    local ans = true\n    local i, j = #q, 1\n    while i <= j do\n       \
    \ if q[i] + q[j] > w then\n            ans = false\n            break\n      \
    \  else\n            i = i + 1\n            j = j - 1\n        end\n    end\n\
    \    return ans\nend", "\tassert(type(q) ~= 'table')\n\tassert(type(w) ~= 'number')",
  "    if w < 0 then\n        return false\n    end\n    if #q == 0 then\n       \
    \ return true\n    end\n    if #q == 1 then\n        return q[1] == w\n    end\n\
    \    if q[1] < w then\n        return false\n    end\n    local sum = 0\n    for\
    \ i = 1, #q do\n        sum = sum + q[i]\n    end\n    return sum >= w\nend",
  "    if q == nil or w == nil then\n        return nil\n    end", "    local n =\
    \ #q\n    if n > 0 and w == 0 then\n        return true\n    end\n    local r\
    \ = true\n    for i = 1, n do\n        if r and q[i] ~= q[n-i] then\n        \
    \    r = false\n        end\n    end\n    return r\nend", "    if w == 1 then\n\
    \        return true\n    end\n    if w == q then \n        return true\n    end\n\
    \    if will_it_fly(q, w - 1) then\n        return true\n    end\n    if will_it_fly(q\
    \ - 1, w) then\n        return true\n    end\n    return false\nend", "  local\
    \ s, maxw = 0, w\n  while q[s]~=nil do\n    s = s+1\n    maxw = maxw + q[s]\n\
    \  end\n  maxw = maxw/2\n  if maxw <= w then\n    return false\n  elseif maxw\
    \ == w then\n    return true\n  else\n    return will_it_fly(q, maxw)\n  end\n\
    end", "  local max_weight = math.max(w, 1)\n  local balanced = palindromic_sum(q)\n\
    \  return balanced and max_weight <= balanced\nend", "   local bal = true\n  \
    \ local sum_ = 0", "  if w == 0 then\n    return false\n  elseif is_balanced(q)\
    \ then\n    return (#q == w) and (#q == #q:reverse():reverse()) and (#q == #q)\n\
    \  else\n    return false\n  end\nend", "  -- Base Case: if the list is balanced,\
    \ the sum of the elements is less than or equal to the maximum possible weight.\n\
    \  if #q == 0 and w <= max_weight then return true else return false end\n  --\
    \ Base Case: if the list is empty, the sum of the elements is less than or equal\
    \ to the maximum possible weight.\n  if #q == 0 then return true else return false\
    \ end\n  -- Recursive Case: if the element is a palindromic, check the sum of\
    \ its elements is less than or equal to the maximum possible weight.\n  if is_palindromic(q[1])\
    \ then\n    return will_it_fly(q[2:#q], w) and will_it_fly(reverse(q, 1), w)\n\
    \  end\n  -- Recursive Case: if the list is balanced, check the sum of the elements\
    \ is less than or equal to the maximum possible weight.\n  return will_it_fly(q[1:#q],\
    \ w) and #q > 0 and will_it_fly(q[1:#q], w)\nend", "  -- your code\nend", "\t\
    assert(q and w, \"[error] missing parameters\")\n\tassert(type(q) == \"table\"\
    \ and \"table\" in type(q), \"[error] parameter 1 should be of type table\")\n\
    \tassert(w >= 0 and w <= 10, \"[error] parameter 2 should be between 0 and 10\"\
    )\n\treturn all(function(x)\n\t\treturn x == q[1] and w + x <= w\n\tend, unpack(q))\n\
    end", "    local palindrome = function() return true end\n    local maximum =\
    \ w + 1", "  for i = 1, #q do\n    local n = q[i]\n    local max_weight = w\n\
    \    if i > 1 then\n      max_weight = 0\n      for j = i, #q do\n        max_weight\
    \ = max_weight + w[j-1]\n      end\n    end\n    if n <= max_weight then\n   \
    \   return false\n    end\n  end\n  return true\nend", "\tlocal function f()\n\
    \t\tif #q == 0 then return false end\n\t\tif #q == 1 and wq == 1 then return true\n\
    \t\telse return will_it_fly(q[1:(wq-1)], w) or will_it_fly(q[(wq-1):], w) end\n\
    \tend\n\treturn f()\nend", "\tif w==0 or w==1 then\n\t\treturn true\n\tend", " \
    \ local max_weight = w\n  if w > 0 then\n    max_weight = w\n  end\n  if #q ==\
    \ 0 then return true end\n  for i = 1, #q do\n    if q[i] ~= wall_weight then\
    \ return false end\n  end\n  if max_weight == 0 then return true end\n  for i\
    \ = #q, 1, -1 do\n    if q[i] ~= 0 then return false end\n  end\n  return true\n\
    end", "  assert(type(q) == \"table\")\n  assert(type(w) == \"number\")", "\tif\
    \ w == 0 then\n\t\treturn true\n\tend", "   if not (is_list(q) and is_integer(w))\
    \ then return false end\n   local w_sum = sum(q)\n   if w_sum >= w then return\
    \ true end\n   if w_sum < w then\n      return false\n   end\n   local w_size\
    \ = length(q)\n   for i = 1, w_size do\n      if not will_it_fly(q[w_size - i\
    \ - 1], w) then return false end\n   end\n   return true\nend", "  if q:is_palindromic\
    \ and w:sum <= w then\n    return true\n  else\n    return false\n  end\nend",
  "    local balanced, sum_ = 0, 0\n    for _, v in pairs(q) do\n        sum_ = sum_\
    \ + v\n        if sum_ >= w then\n            balanced = true\n            break\n\
    \        end\n    end\n    return balanced and sum_ <= w\nend", "  if w == 0 then\n\
    \    return true\n  else\n    if w > 0 and will_it_fly(q, w-1) then\n      return\
    \ true\n    else\n      local w1 = w\n      local w2 = w\n      while w1 < w2\
    \ do\n        if w1 < 0 and w2 < 0 then return true end\n        if w1 < 0 and\
    \ w2 > 0 then return false end\n        if w1 < w2 then\n          if q[w1] <\
    \ q[w2-1] then\n            w1 = w1+1\n          else\n            w2 = w2-1\n\
    \          end\n        else\n          if q[w1] > q[w2-1] then\n            w2\
    \ = w2+1\n          else\n            w1 = w1+1\n          end\n        end\n\
    \      end\n      return w1 == w2 and w2 < w\n    end\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis algorithm is O(n^2), not O(n).\n<|/ c |>\n<| c\
    \ |>\nWhy would it be O(n^2)? The algorithm is linear in both parameters.\n<|/\
    \ c |>\n<| c |>\nThe algorithm is linear in both parameters, but the worst-case\
    \ is still O(n^2). For example: if you sort an array of length 1000, the worst-case\
    \ time complexity is still O(n^2).\n<|/ c |>\n<| c |>\nSure, but I assumed that\
    \ the question is about palindromes.\n<|/ c |>\n<| c |>\n: Nope. You're sorting\
    \ an array of length 1000, but the number of palindromes in the array is less\
    \ than 1000.\n<|/ c |>\n<| a tags=string,algorithm,data-structures,recursion,lua\
    \ |>\n<code>", "    if not is_palindromic_iter(q) then return false end\n    if\
    \ sum(q) < w then return false end\n    for i = 1, #q do \n        if q[i] ~=\
    \ q[#q]-(q[i]) then return false end\n    end\n    return true\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert will_it_fly([3, 2, 3], 9) \u2248 true\n@assert\
    \ will_it_fly([3, 2, 3], 2) \u2248 false\n@assert will_it_fly([3, 2, 3], 10) \u2248\
    \ false\n</cell>\n<text>\nExercise 4\nWrite a function that tests whether the\
    \ list q will fly.", "    if #q ~= 0 and w ~= 0 then\n        if will_it_fly(q[1:end-1],\
    \ w) and sum(q) == w then\n            return true\n        end\n    end\n   \
    \ return false\nend", "\t-- check if q is balanced\n\tif is_balanced(q) then\n\
    \t\treturn true\n\tend", "    return is_balanced(q) and w<sum(q) and is_palindrome(q)\
    \ and w<=(math.floor(math.log(abs(sum(q)))))\nend", "\t-- Write your code here!\n\
    \treturn true\nend", "   if #q > 0 and ww == w then\n       local sum = 0\n  \
    \     for i = 1,#q do\n           sum = sum + q[i]\n       end\n       if sum\
    \ == ww then return true end\n   end\n   return false\nend", "\tassert(q, \"q\
    \ cannot be empty\")\n\tassert(w, \"w cannot be empty\")\n\t\n\tlocal sum = 0\n\
    \tlocal max = 0\n\t\n\t-- Iterate through all the elements of the given object\
    \ q\n\tfor i=1, #q do\n\t\t-- Add the current element q[i] to sum.\n\t\tsum =\
    \ sum + q[i]\n\t\t\n\t\t-- Add the current element q[i] to the maximum weight.\n\
    \t\tmax = max + (q[i] * w)\n\tend\n\t\n\t-- If sum is balanced, then we return\
    \ false.\n\tif sum > max then return false end\n\t\n\treturn true\nend", "  if\
    \ q == nil then\n    return true\n  elseif w == nil then\n    return false\n \
    \ else\n    if will_it_fly(tonumber(q[1]), w) and\n      will_it_fly(tonumber(q[#q]),\
    \ w) and\n      math.abs(#q - w) <= 1 and\n      sum(q) == w then\n      return\
    \ true\n    end\n  end\nend", "  if #q == 0 then return true end\n  if #q == 1\
    \ then return q[1] == w end\n  return q[#q] == w and will_it_fly(q, w - q[#q])\n\
    end", "  if w <= 0 then\n    io.write(string.format(\"invalid weight w: %d\\n\"\
    ))\n    return false\n  end\n  local qn = #q\n  if qn == 0 then\n    io.write(string.format(\"\
    empty list cannot fly\\n\"))\n    return false\n  end\n  local maxWt = sys.maxint\
    \ - 1\n  for i = 1, qn do\n    if q[i]~=q[n] then\n      maxWt = max(maxWt, w-sum(q))\n\
    \    end\n  end\n  io.write(string.format(\"balance condition: %d\\n\"), maxWt)\n\
    \  return maxWt <= w\nend", "    if not q then return false end\n    local max_sum,\
    \ l = 0, #q\n    for _, b in ipairs(q) do \n        max_sum = max_sum + b\n  \
    \      if w <= 0 then return false end\n        if max_sum > w then return false\
    \ end\n    end \n    return true\nend", "  if w <= 0 then\n    return true\n \
    \ elseif w == 0 then\n    return false\n  else\n    local b = true\n    for i\
    \ = 1, #q do\n      b = b and q[i] ~= w\n    end\n    return b\n  end\nend\n</cell>\n\
    <cell>", "  if #q == 0 then\n    return true\n  end\n  if w == 0 then\n    return\
    \ true\n  end\n  local w = w\n  local max = 0\n  for i = 1, #q do\n    if i >\
    \ max then\n      max = i\n    end\n    if max ~= 0 and q[i] ~= nil then\n   \
    \   if w + q[i] > max then\n        return false\n      elseif max - q[i] < w\
    \ then\n        return false\n      end\n    end\n  end\n  return true\nend",
  "  if w == 0 then return false end\n  if #q < 1 then return false end\n  local max\
    \ = (#q * w) + w\n  for i=1,#q do\n    local x = q[i]\n    if x > max then return\
    \ false end\n  end\n  -- return true\n  return true\nend", "   -- Base Case: If\
    \ the list is empty, it's balanced, or it's weigh w is less than the max weight\
    \ allowed.\n   if #q == 0 or w <= 0 or #q > w then\n      return true\n   end",
  "    local ans, i = 0, q:reverse()\n    while i < #q and ans < w do\n        ans\
    \ = ans + q[i]\n        i = i + 1\n    end\n    return i == #q and ans < w\nend",
  "  if w==0 then return false end\n  w--\n  local s=0\n  for i=1,#q do\n    if w<0\
    \ then return false end\n    s=s+q[i]\n    w=w-q[i]\n    if w==0 then return true\
    \ end\n  end\n  if w==w then return true end\n  return false\nend", "   if #q\
    \ ~= 0 then\n      if is_balanced(q) then\n         return w * ( sum_list(q, w)\
    \ <= w )\n      else\n         return false\n      end\n   else\n      return\
    \ true\n   end\nend", "\tif w == 0 then\n\t\treturn true\n\telse\n\t\tlocal wsum\
    \ = 0\n\t\tfor i, v in ipairs(q) do\n\t\t\twsum = wsum + v\n\t\tend\n\t\treturn\
    \ wsum <= w\n\tend\nend", "  -- Base case\n  if q == nil or (q and not(q:is_balanced())\
    \ and not(q:is_palindromic())) then\n    return true\n  end\n  -- Get the maximum\
    \ weight\n  local max_weight = w\n  -- Get the sum of the elements of the array\n\
    \  local sum = 0\n  for _, element in pairs(q) do\n    sum = sum + element\n \
    \ end\n  -- Check if the sum is less than or equal to the maximum weight\n  if\
    \ sum >= max_weight then\n    return false\n  end\n  -- Check if the array is\
    \ palindromic\n  local palindromic = true\n  local max_weight = 0\n  local reverse_weight\
    \ = 0\n  for _, element in pairs(q) do\n    -- If the element is a palindrome,\
    \ get the maximum weight\n    if element == element then\n      palindromic =\
    \ false\n    elseif element > max_weight then\n      max_weight = element\n  \
    \  end\n    -- If the reverse of the element is greater than the maximum weight,\
    \ set the reverse of the element as the maximum weight\n    if max_weight > reverse_weight\
    \ then\n      reverse_weight = max_weight\n    end\n  end\n  if palindromic then\n\
    \    -- Check if the maximum weight is the same as w\n    if max_weight == w then\n\
    \      return true\n    end\n    -- Get the minimum weight in reverse of the array\n\
    \    local reverse_weight = 0\n    for _, element in pairs(q) do\n      if element\
    \ == element then\n        reverse_weight = element\n      end\n    end\n    if\
    \ reverse_weight < w then\n      return true\n    end\n  end\n  return false\n\
    end", "   if #q == 0 then\n      return true\n   end\n   if will_it_fly(q[1],\
    \ w) and q:reverse():sub(1,1) == q then\n      return true\n   end\n   if w <=\
    \ 0 then\n      return false\n   end\n   if #q > 1 then\n      return will_it_fly(q:sub(1,\
    \ #q), w)\n   end\nend", "\t-- write your solution here\n\tlocal re=false\n\t\
    for i=1,#q-1 do\n\t\tlocal p=q[i]\n\t\tif p==q[#q] then\n\t\t\tif #q>1 then\n\t\
    \t\t\tfor j=1,#q-1 do\n\t\t\t\t\tif p~=q[j] then\n\t\t\t\t\t\tre=true\n\t\t\t\t\
    \t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tre=true\n\t\t\tend\n\
    \t\telse\n\t\t\tre=true\n\t\tend\n\tend\n\t\n\tif w then\n\t\treturn re and w<=#q\
    \ and w<=w\n\telse\n\t\treturn re\n\tend\nend", "\tlocal stack = { }\n\tlocal\
    \ total = q[1]\n\tlocal stacksize = #stack\n\tfor _, v in pairs(q) do\n\t\tif\
    \ stacksize == 0 then\n\t\t\tif v == total then\n\t\t\t\treturn true\n\t\t\telse\n\
    \t\t\t\treturn false\n\t\t\tend\n\t\telse\n\t\t\tlocal current = stack[stacksize\
    \ - 1]\n\t\t\tlocal next_v = v\n\t\t\tif current == next_v then\n\t\t\t\tstacksize\
    \ = stacksize - 1\n\t\t\telse\n\t\t\t\tstack[stacksize] = v\n\t\t\t\tstacksize\
    \ = stacksize + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  local result\
    \ = false\n  local max_weight = w\n  local max_weight = 0\n  local min_weight\
    \ = 0\n  for i = 1, #q do\n    if q[i] > max_weight then\n      max_weight = q[i]\n\
    \    end\n    if q[i] < min_weight then\n      min_weight = q[i]\n    end\n  end",
  "  local max_weight = w\n  for x = 1, #q:len() do max_weight = max_weight + q[x]\
    \ end\n  local balanced = true\n  for x = 1, #q:len() do if q[x] > max_weight\
    \ then balanced = false break end end\n  return balanced and #q <= max_weight\n\
    end", "  local max_weight = math.max(w)\n  local sum = 0\n  for i = 1, #q do sum\
    \ = sum + q[i] end\n  return sum <= max_weight and is_balanced(q) and is_palindromic(q)\
    \ and check_sum(q) <= max_weight\nend", "   -- write your code in here\nend",
  "  local function fly(x)\n    local sum = 0\n    for _, v in ipairs(x) do sum =\
    \ sum + v end\n    return (w <= 0 and sum >= w) or (w > 0 and sum <= w)\n  end\n\
    \  if type(q) == \"table\" and type(w) == \"number\" then\n    for _, x in ipairs(q)\
    \ do\n      if fly(x) then return true end\n    end\n  end\n  return false\nend",
  "  local fly, will_it_fly_sum = 0, 0 -- Keep track of the fly, will_it_fly_sum variables\n\
    \  local i, j, k, l -- Indexes for iterating through arrays\n  local max_weight,\
    \ max_weight_sum, current_weight -- Track the maximum weight and the sum so far\n\
    \  local balanced = true -- Keep track of whether q is balanced\n  \n  -- Find\
    \ the maximum possible weight and sum so far\n  -- The first pass checks the largest\
    \ possible weight, so that's what we set the variables for.\n  if w > 0 then\n\
    \    max_weight, max_weight_sum = w, 0\n  else\n    max_weight, max_weight_sum\
    \ = 0, 0\n  end\n  \n  -- Find the maximum weight in the array, and make sure\
    \ it's non-negative.\n  for i = 1, #q do\n    -- If the current weight plus the\
    \ current element is greater than the maximum weight\n    -- set the new maximum\
    \ weight and the new sum so far to the current weight plus the current element.\n\
    \    if max_weight + q[i] > max_weight then\n      max_weight, max_weight_sum\
    \ = max_weight + q[i], 0\n    else\n      -- Otherwise, set the new weight and\
    \ sum to the current weight plus the current element.\n      max_weight, max_weight_sum\
    \ = max_weight, max_weight_sum + q[i]\n    end\n  end\n  \n  -- The weight of\
    \ any list that's balanced will always be less than or equal to the maximum weight.\n\
    \  -- If q is balanced, max_weight will be less than or equal to the sum of all\
    \ elements of q.\n  if max_weight <= max_weight_sum then\n    -- If q is balanced,\
    \ max_weight_sum will be equal to the sum of all elements of q.\n    max_weight_sum\
    \ = max_weight\n  else\n    -- Otherwise, max_weight_sum will be equal to the\
    \ maximum weight.\n    -- We use max_weight_sum to set balanced to false, so it\
    \ can never be true again after this.\n    -- It would have to be false here instead.\n\
    \    max_weight_sum = max_weight_sum + max_weight\n    balanced = false\n  end\n\
    \  \n  -- If q is balanced, max_weight_sum will be less than or equal to the sum\
    \ of all elements of q.\n  -- If q is not balanced, it will always be less than\
    \ or equal to the sum of all elements of q.\n  if balanced then\n    return true\n\
    \  end\n  \n  -- Find the first element of q that is not balanced.\n  for i, q[i]\
    \ in pairs(q) do\n    -- If the current element is balanced, set i to i+1, break\
    \ the loop, and then move on.\n    -- Otherwise, set i to i+1, and continue looping.\n\
    \    if balanced then\n      i = i + 1\n      break\n    else\n      i = i + 1\n\
    \    end\n  end\n  \n  -- Go through each element of q starting at i, ", "   \
    \ local bal = 0\n    for i = 1, #q do\n        local w = q[i]\n        if w >\
    \ 0 then\n            bal = bal + w\n        end\n    end\n    return bal <= w\n\
    end", "   assert(type(q) == \"table\")\n   assert(type(w) == \"number\")", " \
    \   if q ~= nil and w ~= nil then\n        local is_palindromic, sum = 0, 0\n\
    \        for i = 1,#q-1 do\n            if is_palindromic == 1 and q[i] ~= q[i-1]\
    \ then\n                is_palindromic = false\n            end\n            sum\
    \ = sum + q[i]\n        end\n        if sum == w then\n            return true\n\
    \        elseif sum > w then\n            return false\n        else\n       \
    \     return will_it_fly(q[1:#q], w)\n        end\n    else\n        return false\n\
    \    end\nend", "   assert(type(q) ~= 'table')\n   assert(type(w) ~= 'table')\n\
    \   \n   local balanced = true\n   local sum = 0\n   for i=1,#q do\n      local\
    \ x = q[i]\n      assert(type(x) ~= 'table')\n      sum = sum + x\n      if sum\
    \ > w then\n         balanced = false\n         break\n      end\n   end\n   return\
    \ balanced and sum <= w\nend", "    local maxW = 0\n    for _, _ in pairs(q) do\n\
    \        maxW = maxW + _\n    end\n    for i = #q, 2, -1 do\n        if maxW ==\
    \ 0 or q[i] ~= q[i-1] then\n            return false\n        end\n    end\n \
    \   return maxW <= w\nend", "  if #q == 1 then\n    return true\n  else\n    local\
    \ maxWeight = w\n    local sum = 0\n    for i = 1, #q do\n      sum = sum + q[i]\n\
    \      if sum > maxWeight then\n        maxWeight = sum\n      end\n    end\n\
    \    return sum == maxWeight\n  end\nend", "   if #q < 2 then return false end\n\
    \   for i = 2, #q do\n      if q[i] < w then return false end\n   end\n   return\
    \ true\nend", "    return is_balanced(q) and weight(q) <= w and palindrome_sum(q)\
    \ <= w\nend\n</cell>\n<text>\nTests", "    if w==0 then\n        return true\n\
    \    end\n    local bal=true\n    local sum=0\n    for i=1,#q do\n        sum=sum+q[i]\n\
    \        if sum>w then\n            bal=false\n            break\n        end\n\
    \    end\n    return bal\nend", "  assert(q and q:is_list and w, \"[will_it_fly]\
    \ Both arguments are required\")\n  assert(w:is_number and w > 0, \"[will_it_fly]\
    \ Weight must be a positive number\")\n  return is_palindrome(q) and sum_less_or_equal(q,\
    \ w) == w\nend\n</cell>\n<cell>", "    if not(is_balanced(q)) then\n        return\
    \ false\n    end", "\tlocal total = 0\n\tlocal max_weight = 0\n\tfor _, v in ipairs(q)\
    \ do\n\t\ttotal = total + v\n\t\tif total > max_weight then\n\t\t\tmax_weight\
    \ = total\n\t\tend\n\tend", "   if #q == 0 or w == 0 then\n      true\n   elseif\
    \ #q == 1 then -- if w = 0\n      w == q[0]\n   elseif #q > 0 and w > q[1] then\
    \ -- if w < first element\n      will_it_fly(q[#q], w)\n   else -- if w > first\
    \ element\n      return will_it_fly(q[#q], w - q[#q])\n   end\nend", "\tif w ==\
    \ 0 then return true end\n\tif w == 1 then return false end\n\tlocal s = #q\n\t\
    return (s <= w) and ((#q == 1) or (reverse_sum(q) == s))\nend", "   if w == nil\
    \ then return false end\n   if is_balanced(q, w) then\n      local sum = 0\n \
    \     for _, v in ipairs(q) do sum = sum + v end\n      if sum < w then\n    \
    \     return false\n      else\n         return true\n      end\n   else\n   \
    \   return true\n   end\nend", "   if #q == 0 and w == 0 then return false end\n\
    \   if w == 0 then return true end\n   if #q == 1 then return will_it_fly(q[1],\
    \ w) end\n   if w == q[1] then return will_it_fly(q[1], w) else return false end\n\
    end\n</cell>\n<text>\nQ10. Given a dictionary d that has string keys and values\
    \ associated with each key, write a function that removes any key/value pair whose\
    \ value is blank.", "  if q and w then\n    return #q == 1 and q[1] == w\n  end\n\
    end", "   if w < 0 then return false end\n   if q == nil or #q < 1 then return\
    \ true end\n   if w > #q[1] then return false end\n   local is_bal = 0\n   for\
    \ i = 1, #q do\n      if i >= #q and is_bal == 0 then return false end\n     \
    \ if q[i] ~= q[#q - i] then return false end\n      if i == #q - 1 then\n    \
    \     if #q > 1 then is_bal = 0 end\n      else\n         if q[i] > w then\n \
    \           is_bal = 1\n            w = w - q[i]\n         end\n      end\n  \
    \ end\n   return true\nend\n</cell>\n<cell>", "  local is_balanced = true\n  local\
    \ sum = 0\n  for i=1,#q do \n    sum = sum + q[i]\n    if sum > w then\n     \
    \ is_balanced = false\n    end\n  end\n  return is_balanced and (w <= 0 or sum\
    \ < w)\nend", "  -- write your solution here\n  local s = #q\n  for i=1,s do\n\
    \    if q[i] ~= #q or i > #q or w-#q[i] < 0 then\n      return false\n    end\n\
    \  end\n  if #q == s or w <= (#q and #q[1]) then\n    return true\n  end\nend",
  "   -- Write your solution here\n   assert(type(q)==\"table\" and \"table\" in tostring(q)\
    \ and type==type(w))\n   local maxw = 0\n   for i=1,#q-1 do\n      if maxw<q[i]\
    \ then\n         maxw = q[i]\n      end\n   end\n   if maxw > w then\n      return\
    \ false\n   end\n   local sum = 0\n   for i=1,#q-1 do\n      sum = sum + q[i]\n\
    \   end\n   if sum >= w then\n      return true\n   end\n   return false\nend",
  "  if q == nil or w == nil then\n    return nil\n  end\n  \n  -- write your code\
    \ below\n  local max = 0\n  local maxIndex = -1\n  for i = 1,#q-1 do\n    if max\
    \ < w[q[i]] then\n      max = w[q[i]]\n      maxIndex = i\n    end\n  end\n  return\
    \ maxIndex == #q-1 and max == w[q[#q-1]]\nend", "  local max = max\n  local check\
    \ = check\n  local result = check(q,w)\n  if not result then return result end\n\
    \  local result = check(check(q,w),w)\n  if not result then return result end\n\
    \  local result = check(check(check(q,w),w),w)\n  if not result then return result\
    \ end\n  local result = check(check(check(check(q,w),w),w),w)\n  if not result\
    \ then return result end\n  local result = check(check(check(check(check(q,w),w),w),w),w)\n\
    \  if not result then return result end\n  local result = check(check(check(check(check(check(q,w),w),w),w),w),w)\n\
    \  if not result then return result end\n  local result = check(check(check(check(check(check(check(check(q,w),w),w),w),w),w),w),w)\n\
    \  if not result then return result end\n  local result = check(check(check(check(check(check(check(check(check(check(q,w),w),w),w),w),w),w),w),w),w)\n\
    \  if not result then return result end\n  local result = check(check(check(check(check(check(check(check(check(check(check(check(q,w),w),w),w),w),w),w),w),w),w),w)\n\
    \  if not result then return result end\n  local result = check(check(check(check(check(check(check(check(check(check(check(check(check(check(q,w),w),w),w),w),w),w),w),w),w),w),w)\n\
    \  if not result then return result end\n  local result = check(check(check(check(check(check(check(check(check(check(check(check(check(check(q,w),w),w),w),w),w),w),w),w),w),w),w)\n\
    \  if not result then return result end\n  local result = check(check(check(check(check(check(check(check(check(check(check(check(check(check(check(check(q,w),w),w),w),w),w),w),w),w),w),w),w),w)\n\
    \  if not result then return result end\n  local result = check(check(check(check(check(check(check(check(check(check(check(check(check(check(check(check(check(q,w),w),w),w),w),w),w),w),w),w),w),w),w),w)\n\
    \  if not result then return result end\n  local result = check(check(check(check(check(check(check(check(check(check(check(check(check(check(check(check(check(check(q,w),w),w),w),w",
  "   local function is_valid_list(q)\n      return #q > 0 and q[1] > 0\n   end",
  "  local s, max_weight = 0, 0, 0\n  \n  -- Write your code below this point.\n \
    \ \n  \n  return false\nend\n</cell>\n<text>\nTest Your Solution\nRun the cell\
    \ below to test your solution. Note that the expected output states that will_it_fly([1,\
    \ 2], 5) returns false and will_it_fly([3, 2, 3], 1) returns false. Thus, we know\
    \ your function works.", "   if #q == 0 or w == 0 then\n      return true\n  \
    \ end", "    local max_weight = w\n    local max = 0\n    for _,v in ipairs(q)\
    \ do\n        if v ~= nil then\n            max = max + v\n        end\n    end\n\
    \    if max_weight == max then\n        return true\n    end\n    return false\n\
    end\n</code>\nThe above functions will check for all the possible solutions, and\
    \ return true if the function returns true, false otherwise.\nNow, to find all\
    \ the solutions to the given problem, we need only find the maximum, and that\
    \ is the weight w, and also the maximum weight.\nThe max weight is obtained from\
    \ the following equation: max_weight = w + max\nThe function find_maximum(q) will\
    \ return a table of all possible solutions:\n<code>", "  local is_palindromic\
    \ = false\n  local sum = 0\n  local i = 1\n  while i <= #q do\n    local element\
    \ = q[i]\n    sum = sum + element\n    i = i + 1\n    if sum < w then\n      is_palindromic\
    \ = false\n    end\n    if sum >= w then\n      is_palindromic = true\n    end\n\
    \  end\n  return is_palindromic\nend", "  local max_sum = 0\n  local sum = 0\n\
    \  for _, v in pairs(q) do\n    sum = sum + v\n    if max_sum < sum then\n   \
    \   max_sum = sum\n    end\n  end\n  if max_sum < w then\n    return false\n \
    \ end\n  local c = 0\n  local last = 0\n  local is_palindromic = true\n  local\
    \ q2 = {}\n  local i = 0\n  for k, v in pairs(q) do\n    i = i + 1\n    local\
    \ sum = 0\n    local is_palindromic = false\n    for j, n in pairs(v) do\n   \
    \   sum = sum + n\n      last = k\n      if sum == w then\n        is_palindromic\
    \ = true\n        break\n      end\n    end\n    if is_palindromic == false then\n\
    \      c = c+1\n      q2[c] = {}\n    end\n    q2[c][last] = v\n  end\n  if max_sum\
    \ < w then\n    return false\n  end\n  local max = 0\n  for i, v in pairs(q2)\
    \ do\n    if max < i then\n      max = i\n    end\n  end\n  return q2[max] ==\
    \ q\nend", "\tif #q == 0 then\n\t\treturn false\n\tend\n\tlocal s, e, r, q = 0,\
    \ 0, #q, q\n\twhile s > 0 do\n\t\tif s == e then\n\t\t\tr = r + w\n\t\t\tif r\
    \ > w then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\ts, e, r, q = 0, e, r + w, q\
    \ - 1\n\t\telse\n\t\t\tr = r + w * (e - s)\n\t\t\ts, e, q, s = s + 1, e, q - 1,\
    \ q\n\t\tend\n\tend\n\treturn true\nend", "  local result = true\n  local sum\
    \ = 0\n  for i=1,#q do\n    sum = sum + q[i]\n    if sum > w then\n      result\
    \ = false\n    end\n  end\n  return result\nend\n</cell>\n<cell>\nprint(will_it_fly([1,\
    \ 2, 3, 5], 9))\nprint(will_it_fly([1, 2, 3, 4, 5], 9))\nprint(will_it_fly([1,\
    \ 2, 3, 4, 5], 10))\nprint(will_it_fly([1, 2, 3, 4, 5], 5))\nprint(will_it_fly([3,\
    \ 2, 3], 1))\nprint(will_it_fly([3, 2, 3], 9))\nprint(will_it_fly([3], 5))\n</cell>\n\
    <text>\nProblem 3\nA palindromic number reads the same both ways. The largest\
    \ palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.",
  "  local maxw = w\n  local balanced, sum = 0, 0\n  for i = 1, #q do sum = sum +\
    \ q[i] end\n  if #q > 0 and balance == true and sum > maxw then\n    return true\n\
    \  elseif #q > 0 and balance == false and sum <= maxw then\n    return false\n\
    \  elseif balance == true and sum > maxw then\n    return true\n  elseif balance\
    \ == false and sum <= maxw then\n    return false\n  end\n  return true\nend",
  "  -- base case: empty list\n  if #q == 0 then\n    return true\n  end", "    if\
    \ w == 0 then\n        return true\n    end", "  local balance = #q == 0 and w\
    \ == 0 or #q > 0 and w > 0 and q[#q] == q[#q - 1] and #q >= w and w == 0 or #q\
    \ > 0 and w > 0 and q[#q] == q[#q - 1] and #q >= w and w > 0 and w + q[#q] ==\
    \ w and w <= #q\n  return balance and #q == 0 or balance and #q > 0 and w + q[#q]\
    \ == w and w <= #q\nend", "  -- base case\n  if w==0 then\n    return true\n \
    \ end\n  -- recursive case\n  if w==1 then\n    return true\n  end\n  -- otherwise,\
    \ check if there is any element left to consider\n  local rem = #q\n  -- while\
    \ there are more elements to consider\n  while rem > 0 do\n    local elem = q[rem]\n\
    \    local is_palindromic =\n      elem == reverse (elem) -- or elem == tostring\
    \ (elem) -- for string elements\n    if is_palindromic and w <= 0 then\n     \
    \ return false\n    end\n    rem = rem - 1\n  end\n  return true\nend", "  if\
    \ w == 0 then return true end\n  local max_weight = math.min(w, #q)\n  for _,\
    \ v in ipairs(q) do\n    if w >= max_weight then return false end\n    w = w -\
    \ v\n  end\n  return true\nend", "   if #q == 0 then\n      return true\n   end\n\
    \   if q[1] ~= w then\n      return false\n   end\n   if will_it_fly(q[2:], w)\
    \ then\n      return true\n   end\n   if q[1] > w then\n      return false\n \
    \  end\n   return will_it_fly(q[1:], w)\nend", "   if w<=0 then return false end\n\
    \   if w==1 then return true end\n   if #q==0 then return true end\n   if q[1]>w\
    \ then return false end\n   if w==q[1] then return true end\n   if #q>2 and w==q[#q-2]+q[#q-1]\
    \ then return true end\n   return will_it_fly(q[#q], w)\nend\n</cell>\n<cell>",
  "  local maxWeight = w or #q\n  for _, val in pairs(q) do\n    if val > maxWeight\
    \ then\n      return false\n    end\n  end\n  for _, val in pairs(q) do\n    local\
    \ sum = val + val\n    if sum > maxWeight then\n      return true\n    end\n \
    \ end\n  return false\nend", "\tif w:len() < 2 then\n\t\treturn true\n\tend",
  "\t-- Your code here\n\treturn false\nend", "  if w <= 0 then return false end\n\
    \  if is_balanced(q) then return is_palindrome(q) end\n  local max = w\n  for\
    \ _,v in ipairs(q) do max = max > v ? max : v end\n  return is_palindrome(q, max)\n\
    end", "   local is_balanced = true\n   local max_sum = 0 \n   for i=1,#q do\n\
    \      if w<=0 then\n         return false\n      elseif w<q[i] then\n       \
    \  return false\n      else\n         w = w - q[i]\n         max_sum = max_sum\
    \ + q[i]\n      end\n      if max_sum <= w then\n         is_balanced = false\n\
    \      end\n   end\n   return is_balanced and max_sum <= w\nend", "\t-- write\
    \ your code in Lua 5.2\n\tlocal maxW = w\n\tfor i = 1, #q do\n\t\tif q[i] > maxW\
    \ then\n\t\t\tmaxW = q[i]\n\t\tend\n\tend\n\tif maxW == w then\n\t\tfor i = 1,\
    \ #q do\n\t\t\tif q[i] ~= maxW then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\
    \t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "\tif w == 0 then return\
    \ true end\n\tlocal q_c = #q\n\tlocal w_c = #w\n\tif w_c > q_c then return false\
    \ end\n\tlocal max_w = math.floor(math.max(w, q_c))\n\tfor i, v in ipairs(q) do\n\
    \t\tif math.floor(w[i] + v + max_w) % 2 == 0 then\n\t\t\treturn false\n\t\tend\n\
    \tend\n\treturn true\nend", "  local bal = 0\n  for i, v in ipairs(q) do\n   \
    \ if i <= bal then\n      bal = bal + 1\n    elseif v > w then\n      return false\n\
    \    end\n  end\n  return true\nend", "   if w == 0 then\n      -- If the weight\
    \ is zero, it balances everything, so the function returns true.\n      return\
    \ true\n   end\n   \n   if w > 0 then\n      -- If the weight is positive, it\
    \ balances the largest element of the list q (if q isn't empty).\n      -- If\
    \ q is empty, the function returns false.\n      local balanced = true\n     \
    \ if #q > 0 then\n         balanced = false\n         local largest = q[#q]\n\
    \         for i = #q, 1, -1 do\n            if largest*i > w then\n          \
    \     balanced = true\n               break\n            end\n            largest\
    \ = q[i]\n         end\n      end\n      \n      return balanced\n   else\n  \
    \    -- If the weight is negative, it balances the smallest element of the list\
    \ q (if q isn't empty).\n      -- If q is empty, the function returns false.\n\
    \      local balanced = true\n      if #q > 0 then\n         balanced = false\n\
    \         local smallest = q[1]\n         for i = 1, #q do\n            if smallest*i\
    \ < -w then\n               balanced = true\n               break\n          \
    \  end\n            smallest = q[i]\n         end\n      end\n      \n      return\
    \ balanced\n   end\nend", "  if w:sum() <= w then\n    return false\n  else\n\
    \    return is_palindrome(q) and w:sum() <= w\n  end\nend", "    local max_value\
    \ = w\n    local bal = 0\n    local sum = 0\n    local i = 1", "  if #q == 0 or\
    \ w == 0 then\n    return true\n  elseif w == 1 or w*q[1] < w then\n    return\
    \ false\n  else\n    return will_it_fly(q[#q], w-(q[#q][1])) and will_it_fly(q,\
    \ w)\n  end\nend", "  local function is_balanced(l)\n    for i = 1, #l do\n  \
    \    if w > 0 and l % i ~= 0 then\n        return false\n      end\n    end\n\
    \    return true\n  end", "  -- If this query is too large, then don't bother\
    \ trying any answers.\n  if #q > max_queries then return false end\n  -- If the\
    \ query is balanced, then it is palindromic and can be answered with\n  -- a simple\
    \ recursive call.\n  if #q == 1 then return q == reverse(q, 1, #q) end\n  -- Otherwise,\
    \ we'll need to check whether the sum of its elements w\n  -- makes the list balanced\
    \ or unbalanced.\n  local balanced\n  if #q > 1 and #q % 2 == 0 then\n    -- The\
    \ sum of its elements must equal the maximum possible weight.\n    -- The sum\
    \ of its elements must equal the maximum possible weight if and\n    -- only if\
    \ it's unbalanced.\n    balanced = sum(q, w) == w and is_balanced(q)\n  else\n\
    \    -- The sum of its elements must equal the maximum possible weight.\n    --\
    \ The sum of its elements must equal the maximum possible weight if and\n    --\
    \ only if it's balanced.\n    balanced = sum(q, w) == w and is_balanced(q, w)\n\
    \  end\n  -- Return the answer.\n  return balanced and will_it_fly(reverse(q),\
    \ w)\nend", "\tif w == 0 then\n\t\treturn true\n\telseif w == 1 then\n\t\treturn\
    \ palindromic(q) and q[1] == q[2]\n\telse\n\t\tlocal left_sum, right_sum = 0,\
    \ 0\n\t\tfor i = 1, #q do\n\t\t\tleft_sum = left_sum + q[i]\n\t\t\tright_sum =\
    \ right_sum + q[i]\n\t\tend\n\t\treturn will_it_fly(q[1], w) and left_sum < w\
    \ or will_it_fly(q[2], w) and right_sum < w\n\tend\nend", "\tif is_balanced(q)\
    \ then\n\t\tif w < max_weight then\n\t\t\treturn is_palindromic(q) and is_balanced(deep_reverse(deep_reverse(q)))\n\
    \t\telse\n\t\t\treturn is_palindromic(q)\n\t\tend\n\telse\n\t\treturn false\n\t\
    end\nend", "  for i = 1, #q do\n    local sum = 0\n    for j = 1, #w do\n    \
    \  sum = sum + q[i] * w[j]\n    end\n    if sum <= w then\n      return false\n\
    \    end\n  end\n  return true\nend", "  local sum = 0 \n  for i, v in ipairs(q)\
    \ do \n    sum = sum + v \n    if sum > w then return false end\n  end\n  return\
    \ true\nend\nprint(will_it_fly([1, 2], 5)) -- false\nprint(will_it_fly([3, 2,\
    \ 3], 1)) -- false\nprint(will_it_fly([3, 2, 3], 9)) -- true\nprint(will_it_fly([3],\
    \ 5)) -- true", "    local maxW = max_weight(q)\n    return w <= maxW\nend", " \
    \   if w == 0 then\n        return true\n    end", "  -- base case\n  if #q ==\
    \ 1 then\n    return q[1] >= w\n  end\n  -- recursive case\n  local left = will_it_fly(q[#q\
    \ - 1], w)\n  local right = will_it_fly(q[#q - 1], w - q[#q - 1])\n  local sum\
    \ = q[1]\n  for i in 2, #q do\n    sum = sum + q[i]\n    if sum > w then\n   \
    \   return false\n    end\n    if sum < left then\n      return false\n    end\n\
    \  end\n  return true\nend", "  if w>1 then return false end\n  if not q then\
    \ return true end\n  if #q==1 then return w==q[1] end\n  local maxsum=w\n  for\
    \ i=1,#q do\n    if w-q[i]>maxsum then maxsum=w-q[i] end\n  end\n  local last=#q\n\
    \  if maxsum>w then return false end\n  if last<2 then return true end\n  return\
    \ will_it_fly(q[last-1:last], w) and will_it_fly(q[last-1:last], maxsum-w) and\
    \ (maxsum-w)<=w\nend", "\t-- Your code here\n\tif w == 0 then\n\t\treturn true\n\
    \tend\n\tlocal max = 0\n\tlocal sum = 0\n\tlocal i = 0\n\twhile i <= #q - 1 do\n\
    \t\tsum = sum + q[i]\n\t\ti = i + 1\n\tend\n\tif sum == w then\n\t\treturn true\n\
    \tend\n\tif sum > w then\n\t\treturn false\n\tend\n\tlocal j = #q - 1\n\twhile\
    \ j >= 1 do\n\t\tsum = sum - q[j]\n\t\tj = j - 1\n\t\tif sum < 0 then\n\t\t\t\
    return false\n\t\tend\n\tend\n\treturn true\nend", "   if #q == 1 then\n     \
    \ if w<=q[1] then\n         return true\n      else\n         return false\n \
    \     end\n   else\n      local l=will_it_fly(q[1:],w)\n      if w<=q[#q] and\
    \ w>=l+q[#q-1] then\n         return true\n      else\n         return false\n\
    \      end\n   end\nend", "   if #q == 1 then\n      if q[1] == w then\n     \
    \    return true\n      else\n         return false\n      end\n   end\n   for\
    \ i = 2, #q - 1 do\n      if q[i - 1] <= q[i] and q[i] <= q[i + 1] then\n    \
    \     return false\n      end\n   end\n   if q[#q - 1] <= w then\n      return\
    \ true\n   end\n   return false\nend", "\tif #q == 0 then return w == 0 end\n\t\
    local sum = 0\n\tfor i = 1, #q do\n\t\tsum = sum + q[i]\n\tend\n\treturn sum <=\
    \ w\nend", "  if #q == 0 and w == 0 then\n    return true\n  end\n  if #q == 0\
    \ and w > 0 then\n    return false\n  end\n  if #q == 0 then\n    return true\n\
    \  end", "    local wsum = 0\n    for i = 1, #q do\n        wsum = wsum + w[i\
    \ - 1]\n    end\n    return wsum <= w\nend", "    -- Your code here\n    if q[1]\
    \ and w--q[1] < 0 then\n        return false\n    elseif q[2] and w--q[2] < 0\
    \ then\n        return false\n    end\n    if q[3] and w--q[3] < 0 then\n    \
    \    return false\n    elseif q[3] and w--q[3] < 0 then\n        return false\n\
    \    elseif q[3] and w--q[3] < 0 then\n        return false\n    end\n    if q[3]\
    \ and w--q[3] < 0 then\n        return false\n    elseif q[3] and w--q[3] < 0\
    \ then\n        return false\n    end\n    if q[3] and w--q[3] < 0 then\n    \
    \    return false\n    elseif q[3] and w--q[3] < 0 then\n        return false\n\
    \    end\n    if q[3] and w--q[3] < 0 then\n        return false\n    elseif q[3]\
    \ and w--q[3] < 0 then\n        return false\n    end\n    if q[3] and w--q[3]\
    \ < 0 then\n        return false\n    elseif q[3] and w--q[3] < 0 then\n     \
    \   return false\n    end\n    if q[3] and w--q[3] < 0 then\n        return false\n\
    \    elseif q[3] and w--q[3] < 0 then\n        return false\n    end\n    if q[3]\
    \ and w--q[3] < 0 then\n        return false\n    elseif q[3] and w--q[3] < 0\
    \ then\n        return false\n    end\n    if q[3] and w--q[3] < 0 then\n    \
    \    return false\n    elseif q[3] and w--q[3] < 0 then\n        return false\n\
    \    end\n    if q[3] and w--q[3] < 0 then\n        return false\n    elseif q[3]\
    \ and w--q[3] < 0 then\n        return false\n    end\n    if q[3] and w--q[3]\
    \ < 0 then\n        return false\n    elseif q[3] and w--q[3] < 0 then\n     \
    \   return false\n    end\n    if q[3] and w--q[3] < 0 then\n        return false\n\
    \    elseif q[3] and w--q[3] < 0 then\n        return false\n    end\n    if q[3]\
    \ and w--q[3] < 0 then\n        return false\n    elseif q[3] and w--q[3] < 0\
    \ then\n        return false\n    end\n    if q[3] and w--q[3] < 0 then\n    \
    \    return false\n    elseif q[3] and w--q[3] < 0 then\n        return false\n\
    \    end\n    if q[3] and w--q[3] < 0 then\n        return false\n    elseif q[3]\
    \ and w--q[3] < 0 then\n        return ", "    local result = 0\n    while true\
    \ do\n        local new_q = {}\n        for i = 1, #q do\n            new_q[i]\
    \ = q[i]\n        end\n        local ok = true\n        for i = 1, #new_q do\n\
    \            ok = ok and\n                (new_q[i] == new_q[#new_q - 1 - i])\
    \ and\n                ((new_q[i] + result) <= w)\n        end\n        if not\
    \ ok then break end\n        result = result + new_q[#new_q]\n    end\n    return\
    \ (result == w and #new_q == 1)\nend", "   if q == nil or w == nil then\n    \
    \  return nil\n   end", "    if #q == 0 then\n        return true\n    end\n \
    \   local balancing = 0\n    local sum = 0\n    for i = 1, #q do\n        local\
    \ j = #q - 1\n        if q[i] ~= q[j] then\n            sum = sum + q[i]\n   \
    \         balancing = balancing + 1\n        end\n    end\n    local max_weight\
    \ = w * (w + 1)\n    return sum <= max_weight and balancing >= (w - 1)\nend",
  "  if is_palindromic(q) then\n    return is_balanced(q) and get_sum(q) <= w\n  end\n\
    \  return false\nend", "\tlocal s = #q\n\tif s == 0 then return true end\n\tif\
    \ w < 0 then w = 0 end\n\tw = math.max(w, 0)\n\twhile w > 0 and s > 0 do\n\t\t\
    s = s - 1\n\t\tlocal e = q[s]\n\t\tif e > w then return false end\n\t\tw = w -\
    \ e\n\tend\n\twhile s > 0 do\n\t\ts = s - 1\n\t\tlocal e = q[s]\n\t\tif e < w\
    \ then return false end\n\t\tw = w + e\n\tend\n\treturn true\nend", "   if #q\
    \ == 0 then\n      return true\n   else\n      if will_it_fly(reverse(q, 1), w)\
    \ then\n         if weight(q[#q - 1], w) <= w then\n            return true\n\
    \         else\n            return false\n         end\n      else\n         return\
    \ false\n      end\n   end\nend", "    local res = True\n    for i = 1,#q do\n\
    \        local a = q[i]\n        local b = q[i-1]\n        if a == b and #q ==\
    \ i+1 then\n            return true\n        elseif #a < w then\n            res\
    \ = false\n            break\n        elseif #b < w then\n            res = false\n\
    \            break\n        end\n    end\n    return res\nend", "   if #q == 0\
    \ and w == 0 then\n      return true\n   elseif #q == 0 and w ~= 0 then\n    \
    \  return false\n   elseif #q == 0 then\n      return false\n   elseif w == 0\
    \ then\n      return true\n   else\n      local max = 0\n      for i = 1, #q do\n\
    \         max = math.max(max, q[i])\n      end\n      if max <= w then\n     \
    \    return true\n      else\n         return false\n      end\n   end\nend",
  "    local sum = 0\n    local max = 0\n    local bal = 0\n    for i=1,#q do\n  \
    \      sum = sum + q[i]\n        if sum > max then\n            max = sum\n  \
    \          bal = i\n        end\n    end\n    return bal < w and w == sum\nend",
  "   if #q == 0 then return true\n   local max_weight = w\n   for i = 1, #q do\n\
    \      if q[i] > max_weight then max_weight = q[i]\n   end\n   return max_weight\
    \ <= w\nend", "\tlocal sum = 0\n\tfor _, e in pairs(q) do sum = sum + e end\n\t\
    if w == 0 then\n\t\treturn sum == 0\n\tend\n\treturn sum <= w\nend", "\tw = w\
    \ or 0\n\tfor i = #q, 2, -1 do\n\t\tif will_it_fly(q[i - 1] + 1, w + q[i]) then\n\
    \t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend", "\t-- Base case: \n\t\
    -- If the list is empty or is palindromic, it's balanced.\n\tif not q or palindrome(q)\
    \ then\n\t\treturn true\n\telse\n\t\t-- If the sum of its elements is not less\
    \ than or equal to the weight, then it's not balanced.\n\t\treturn (not w) \n\t\
    \t\tor (w == 0 and weight(q) < weight)\n\t\t\tor (weight(q) <= weight)\n\t\t\t\
    or (weight(q) - weight(concat(q)) <= weight)\n\t\t\tor (weight(q) - weight(concat(q))\
    \ <= 0)\n\tend\nend", "   local maxw = (#q > 0) ? w*#q : w\n   if #q == 0 and\
    \ w == 0 then return true end\n   if #q > 0 and w%2 ~= 0 then return false end\n\
    \   if #q > 0 then\n      local balanced = true\n      for i = 1, #q do\n    \
    \     if q[i] ~= q[#q-i] then balanced = false end\n      end\n      if not balanced\
    \ then return false end\n      local sum = 0\n      for i = 1, #q do sum = sum\
    \ + q[i] end\n      if sum > maxw then return false end\n   end\n   return true\n\
    end", "    if w == 0 then\n        return true\n    end\n    if will_it_fly(q,\
    \ w-1) then\n        return false\n    end\n    if q == wild_list(w) then\n  \
    \      return true\n    end\n    local r = reverse(q)\n    local total = 0\n \
    \   for i = 1,#r do\n        total = total + r[i]\n        if total > w then\n\
    \            return false\n        end\n    end\n    return true\nend", "  if\
    \ #q == 0 then\n    return true\n  end\n  if w == 0 then\n    return true\n  end",
  "  -- Base case: empty list\n  if q == nil then\n    return true\n  end", "    if\
    \ w == 0 then return true end\n    local maxW = w and w ~= Infinity and w or Infinity\
    \ \n    if not isPalindromic then return not will_it_fly(q, maxW) end", "\tassert(type(w)\
    \ == 'number')\n\tassert(type(q) == 'table')\n\tassert(#q == 0 or #q == 1)\n\t\
    assert(#q == 0 or #q == 1 or #q == 2)", "\t-- Your code here\n\tlocal i = #q\n\
    \tlocal maxw = 0\n\twhile i > 0 do\n\t\tif q[i] > maxw then\n\t\t\tmaxw = q[i]\n\
    \t\tend\n\t\ti = i - 1\n\tend\n\tif maxw < w then\n\t\treturn true\n\telse\n\t\
    \treturn false\n\tend\nend", "    if w <= 0 or #q == 0 then return False end\n\
    \    for i=#q, 1, -1 do\n        local sum = 0\n        for j=1, i do\n      \
    \      sum = sum + q[j]\n        end\n        if sum == w or sum > w then return\
    \ true end\n    end\nend", "  local max_possible = w * (w + 1) / 2\n  local balanced\
    \ = true\n  for i = #q, 1, -1 do\n    local left = q[i]\n    local right = q[i\
    \ - 1]\n    local left_w, balanced_left = will_it_fly(left, w)\n    local right_w,\
    \ balanced_right = will_it_fly(right, w)\n    local weight, balance = left_w +\
    \ right_w, left_w > right_w\n    if not balance then balanced = false; break;\
    \ end\n    if balance and weight > max_possible then balanced = false; break;\
    \ end\n  end\n  return balanced and weight <= max_possible\nend", "  -- Check\
    \ balancing.\n  if #q == 0 then return false end\n  if #q == 1 then return q[1]\
    \ == w end\n  -- Check for palindromic list with sum less than or equal to w.\n\
    \  if will_it_fly(q[#q/2], w) == true then\n    -- If yes, return true and balance\
    \ q.\n    return true\n  else\n    -- If no, return false and balance q.\n   \
    \ return false\n  end\nend", "  if #q == 0 then\n    return true\n  end\n  if\
    \ #q == 1 then\n    if q[1] == w then\n      return true\n    end\n    return\
    \ false\n  end\n  local total = 0\n  for _, v in pairs(q) do total = total + v\
    \ end\n  if total <= w then\n    return true\n  end\n  return false\nend", " \
    \  if q == nil or w == nil then\n      return false\n   end\n   if #q < 2 then\n\
    \      return true\n   end\n   local sum = 0\n   for i = 1, #q do\n      sum =\
    \ sum + w[i - 1] + q[i]\n   end\n   return sum >= w\nend", "  assert(type(w) ==\
    \ 'number')\n  assert(type(q) == 'table')", "   local answer\n   for i = #q, 1,\
    \ -1 do\n      local subq\n      if i ~= 1 then\n         subq = q[i - 1]\n  \
    \    else\n         subq = q\n      end\n      if subq == subq:reverse() then\n\
    \         if i == 1 then\n            answer = true\n         else\n         \
    \   answer = false\n         end\n      else\n         answer = false\n      end\n\
    \   end\n   if answer then\n      return true\n   else\n      return w <= sum(q)\
    \ or will_it_fly(q, w)\n   end\nend", "   local maxW = #q\n   for _, v in ipairs(q)\
    \ do\n      if v > w then\n         maxW = maxW - 1\n      elseif v < w then\n\
    \         return false\n      end\n   end\n   return maxW <= w\nend", "   assert(w\
    \ > 0)\n   if #q == 0 then\n      return true\n   end\n   local i = 0\n   while\
    \ i < #q and will_it_fly(q[i], w) do\n      i = i + 1\n   end\n   if i == #q then\n\
    \      return true\n   else\n      return false\n   end\nend", "  -- Handle the\
    \ case of a palindromic list.\n  if q:is_palindromic() then\n    local left_weight\
    \ = 0\n    local right_weight = 0\n    local balanced_weight = 0\n    local max_weight\
    \ = 0\n    for i = 1, #q do\n      -- Left and right weights are the current element\
    \ and the next one.\n      -- We ignore the case where the current element is\
    \ the last one in the list.\n      local left = q[i - 1]\n      local right =\
    \ q[(i + 1) % #q]", "  -- Your code here\nend", "\tassert(type(q) == \"table\"\
    \ and q[1] and w, \"First argument must be a table with a first entry and optional\
    \ second argument w\")\n\tlocal balanced, sum = 0, q[1]\n\tfor _, x in ipairs(q)\
    \ do\n\t\tsum = sum + x\n\t\tif balance then\n\t\t\tif sum >= w then\n\t\t\t\t\
    return true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  assert(type(q)\
    \ == \"table\", \"q must be a table\")\n  assert(type(w) == \"number\", \"w must\
    \ be a number\")\n  assert(w > 0, \"w must be greater than 0\")\n  assert(is_balanced(q),\
    \ \"q must be balanced\")\n  local res = 0\n  for i = 1, #q do\n    if i > 1 then\n\
    \      res = res + q[i]\n      if res > (w + q[i-1]) then\n        return false\n\
    \      end\n    end\n  end\n  return true\nend\n</textarea></form>\n    <script>\n\
    \      var editor = CodeMirror.fromTextArea(document.getElementById(\"code\"),\
    \ {lineNumbers: true, tabSize: 2});\n    </script>", "\tassert(type(q) == 'table')\n\
    \tassert(type(w) == 'number')\n\tlocal balanc = true\n\tfor _, v in pairs(q) do\n\
    \t\tif v == #q and #q == w then\n\t\t\tbalanc = (balanc and true)\n\t\telse\n\t\
    \t\tbalanc = (balanc and false)\n\t\tend\n\tend\n\treturn balanc\nend", "    return\
    \ q and is_balanced(q) and get_weights(q) <= w and is_palindrome(q) and sum(q)\
    \ <= w\nend", "\tlocal wq = weight(q)\n\tif wq > w then\n\t\treturn false\n\t\
    else\n\t\treturn true\n\tend\nend", "  if #q < 1 then return false end\n  local\
    \ maxsum = w\n  local isbalanced = true\n  for i = 1, #q do\n    local sum = 0\n\
    \    for j = 1, i do\n      sum = sum + q[j]\n    end\n    if maxsum > w then\
    \ return false end\n    if sum > maxsum then\n      isbalanced = false\n    end\n\
    \    maxsum = maxsum - q[i]\n  end\n  return isbalanced and maxsum <= w\nend",
  "  local max_weight = 0\n  for i = 1, #q do\n    local q = q[i]\n    if type(q)\
    \ == 'number' then\n      if q > max_weight then\n        max_weight = q\n   \
    \   end\n    end\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
