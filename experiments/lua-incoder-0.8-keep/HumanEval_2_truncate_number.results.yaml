name: HumanEval_2_truncate_number
language: lua
results:
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local _, decimals, integer_part = math.modf(number)\n    return integer_part\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp87als048.lua:15:\
    \ expected: 0.5, actual: nil\nstack traceback:\n\t/tmp/tmp87als048.lua:15: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local result = math.floor(number)\n  if number < 1 then\n    return 0\n  end\n\
    \  local remainder = math.fmod(number, 1)\n  if remainder == 0 then\n    return\
    \ 1\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1qf3kb07.lua:22:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmp1qf3kb07.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local integer_part, decimal_part = math.modf(number)\n    return decimal_part\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local digits = math.floor(math.log(number, 10))\n    number = math.floor(number\
    \ - math.pow(10, -digits))\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpkb79wsxs.lua:19: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal_part = math.floor(number)\n  local integer_part = math.floor(number\
    \ * 10) % 10\n  return decimal_part + (integer_part / 10)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jecaxo4.lua:16:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp_jecaxo4.lua:16: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- We use floating point numbers to avoid having to do any integer math.\n\
    \    -- This isn't necessarily precise, but it's good enough.\n    local decomposed\
    \ = math.floor(-number) + math.ceil(number) + 1\n    return decomposed / (10^math.floor(math.log(decomposed,\
    \ 10)))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm6dxkhbo.lua:17:\
    \ expected: 0.5, actual: 1\nstack traceback:\n\t/tmp/tmpm6dxkhbo.lua:17: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then\n    return nil\n  end\n  return math.floor(number):reverse()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpuro8lqdd.lua:11:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpuro8lqdd.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmpuro8lqdd.lua:17: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal_part = math.floor(number * 100) / 100\n  if decimal_part < 1\
    \ then\n    return 0\n  else\n    return decimal_part\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprdk95e5f.lua:19:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmprdk95e5f.lua:19: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local sign = number and number < 0 and -1 or 1\n    local whole, fract =\
    \ math.modf(number)\n    local integer = math.floor(whole)\n    return sign *\
    \ integer * 10^(-fract)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzf07f0l3.lua:17:\
    \ expected: 0.5, actual: 0.94868329805051\nstack traceback:\n\t/tmp/tmpzf07f0l3.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local _, integer, decimals = math.modf(number)\n  return number * 10^decimals\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_t96n612.lua:9:\
    \ attempt to perform arithmetic on a nil value (local 'decimals')\nstack traceback:\n\
    \t/tmp/tmp_t96n612.lua:9: in local 'candidate'\n\t/tmp/tmp_t96n612.lua:15: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local result = math.floor((number * 100) * 1000) / 1000\n  return math.floor(result)\
    \ / 100\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmperq2h44t.lua:15:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmperq2h44t.lua:15: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local factor = 10^(math.floor(math.log10(number))-1)\n    return math.floor(number/factor)\
    \ * factor\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7f7l0bbj.lua:15:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp7f7l0bbj.lua:15: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number <= 1 then\n    return number\n  end\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7sb3sbh2.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    -- The number can be positive, negative, or zero.\n\tlocal sign = number:sign()\n\
    \tnumber = number:abs()\n\t\n\t-- If the number is zero, return 0.\n\tif number\
    \ == 0 then\n\t\treturn 0\n\tend\n\t\n\t-- If the number is negative, round it\
    \ up, and return it.\n\tif sign then\n\t\tnumber = number:ceil()\n\tend\n\t\n\t\
    -- Return the decimal part (without the sign).\n\treturn number:float()\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpypb4q9oi.lua:9:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmpypb4q9oi.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpypb4q9oi.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.trunc(number):reverse()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpoed1zsow.lua:8:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmpoed1zsow.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpoed1zsow.lua:14: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number == 0 then\n    return 0\n  elseif number < 0 then\n    number = -number\n\
    \  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpppsg5u60.lua:22: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- Use logarithm to find fractional part of the given number.\n    -- The\
    \ logarithm of a number a is log(n!)/log(a!)\n    -- The floor of the logarithm\
    \ is the first integer smaller than\n    -- the logarithm of the given number.\
    \ We can calculate the floor\n    -- by dividing the logarithm by log(a!)\n  \
    \  -- >>> math.floor(math.log(125)) -- 7\n    -- >>> math.floor(math.log(100))\
    \ -- 3\n    -- >>> math.floor(math.log(10)) -- 2\n    -- >>> math.floor(math.log(5))\
    \ -- 1\n    -- >>> math.floor(math.log(2)) -- 0\n    --\n    -- >>> math.floor(math.log(3.5)/math.log(0.5))\
    \ -- 2\n    -- >>> math.floor(math.log(3.5)/math.log(1.5)) -- 1\n    -- >>> math.floor(math.log(3.5)/math.log(3.0))\
    \ -- 0\n    -- >>> math.floor(math.log(3.5)/math.log(4.0)) -- 1\n    -- >>> math.floor(math.log(3.5)/math.log(5.0))\
    \ -- 1\n    -- >>> math.floor(math.log(3.5)/math.log(10.0)) -- 1\n    -- >>> math.floor(math.log(3.5)/math.log(20.0))\
    \ -- 1\n    -- >>> math.floor(math.log(3.5)/math.log(100.0)) -- 1\n    -- >>>\
    \ math.floor(math.log(3.5)/math.log(500.0)) -- 1\n    -- >>> math.floor(math.log(3.5)/math.log(1e5))\
    \ -- 1\n    -- >>> math.floor(math.log(3.5)/math.log(1e8)) -- 1\n    -- >>> math.floor(math.log(3.5)/math.log(1e9))\
    \ -- 1\n    --\n    -- >>> math.floor(math.log(1e12)/math.log(1e10)) -- 4\n  \
    \  -- >>> math.floor(math.log(1e12)/math.log(1e11)) -- 4\n    -- >>> math.floor(math.log(1e12)/math.log(1e12))\
    \ -- 1\n    -- >>> math.floor(math.log(1e12)/math.log(1e13)) -- 1\n    -- >>>\
    \ math.floor(math.log(1e12)/math.log(1e14)) -- 1\n    -- >>> math.floor(math.log(1e12)/math.log(1e15))\
    \ -- 1\n    -- >>> math.floor(math.log(1e12)/math.log(1e16)) -- 1\n    -- >>>\
    \ math.floor(math.log(1e12)/math.log(1e17)) -- 1\n    -- >>> math.floor(math.log(1e12)/math.log(1e18))\
    \ -- 1\n    -- >>> math.floor(math.log(1e12)/math.log(1e19)) -- 1\n    -- >>>\
    \ math.floor(math.log(1e12)/math.log(1e20)) -- 1\n    -- >>> math.floor(math.log(1e12)/math.log(1e21))\
    \ -- 1\n    -- >>> math.floor(math.log(1e12)/math.log(1e22)) -- 1\n    -- >>>\
    \ math.floor(math.log(1e12)/math.log(1e23)) -- 1\n    -- >>> math.floor(math.log(1e12)/math.log(\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpl14byqbv.lua:56: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer_part, decimal_part = math.modf(number)\n  return integer_part\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptuc061rd.lua:15:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmptuc061rd.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   assert(type(number) == \"number\")\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmptuyfau2z.lua:18: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number):reverse():sub(1)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpezhu5w9c.lua:8:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpezhu5w9c.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpezhu5w9c.lua:14: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local int_part, dec_part = math.modf(number)\n    return dec_part < 1 and\
    \ number or math.trunc(number * 10^-dec_part)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_ntg_w_r.lua:15:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp_ntg_w_r.lua:15: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then\n    return 1\n  end\n  local remainder = math.floor(number)\n\
    \  if number < remainder then\n    return number\n  end\n  number = number - remainder\n\
    \  local integer_part = math.floor(number)\n  remainder = math.floor(number -\
    \ integer_part)\n  local decimal_part = remainder / 10\n  if decimal_part > 1\
    \ then\n    return integer_part + math.pow(10, decimal_part - 1)\n  else\n   \
    \ return integer_part\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpk1230eia.lua:29:\
    \ expected: 0.5, actual: 0\nstack traceback:\n\t/tmp/tmpk1230eia.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal, integer, remainder = math.modf(number)\n  return math.floor(decimal),\
    \ remainder\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb78vecm0.lua:15:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpb78vecm0.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local result = math.sqrt(number)\n   if result > math.sqrt(2) then\n     \
    \ return math.floor(result) - math.floor(result / 2)\n   else\n      return math.floor(result)\n\
    \   end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgriltf9x.lua:19:\
    \ expected: 0.5, actual: 1\nstack traceback:\n\t/tmp/tmpgriltf9x.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- If the number given is negative (which it always is), then\n    -- we\
    \ return the given number\n    if number < 0 then\n        return number\n   \
    \ end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpay7x46p7.lua:22: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer, decimals = math.modf(number)\n  return integer - math.floor(integer),\
    \ decimals\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi4rzkt0t.lua:15:\
    \ expected: 0.5, actual: 0\nstack traceback:\n\t/tmp/tmpi4rzkt0t.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number < 1 then\n        return number\n    end\n    local dec = math.floor(math.log10(number))\n\
    \    local decimals = number - dec * math.pow(10, dec)\n    local integer = number\
    \ - decimals\n    integer = math.floor(integer)\n    return integer * 10 + decimals\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsftjwhcx.lua:21:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpsftjwhcx.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal_part, integer_part, decimals = math.modf(number)\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpke87loc6.lua:18: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local result = math.trunc(number)\n  if result == number then\n    return math.floor(number)\n\
    \  end\n  local remainder = math.abs(number - result)\n  return remainder < 1\
    \ and result + 1 or result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpb6y9093y.lua:8:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmpb6y9093y.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpb6y9093y.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local intpart, decimalpart = math.modf(number)\n    return intpart + decimalpart\
    \ * math.pow(10, -math.floor(math.log(decimalpart)))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp57uy2iln.lua:15:\
    \ expected: 0.5, actual: 8\nstack traceback:\n\t/tmp/tmp57uy2iln.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local decimals, integer = math.modf(number)\n    return math.floor(integer\
    \ + (decimals ~= 0 and decimals or -math.abs(decimals)))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvgpqqvfh.lua:15:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpvgpqqvfh.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local factor = 1\n    local decimals = 0\n    while factor <= number do\n\
    \        decimals = math.round(math.floor(math.abs(number) / factor))\n      \
    \  factor = factor * 10\n    end\n    return math.floor(number) - decimals\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplwx815na.lua:11:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmplwx815na.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmplwx815na.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1.0 then\n    return math.floor(number)\n  else\n    local remainder\
    \ = math.floor(number)\n    local remainder_decimal = math.modf(remainder)\n \
    \   return remainder + math.modf(number - remainder)[1]\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfwcg8rrg.lua:13:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpfwcg8rrg.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpfwcg8rrg.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number * 100) / 100\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpk8ggxe36.lua:14:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpk8ggxe36.lua:14: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimals = math.huge\n  local factor = math.huge\n  local truncated =\
    \ number\n  local decimal_count = 0\n  local old_factor\n  while truncated > 0\
    \ and decimal_count < decimals do\n    old_factor = factor\n    factor = math.huge\
    \ / 10\n    local floor_part = truncated % factor\n    local integer_part = truncated\
    \ - floor_part\n    truncated = floor_part\n    if truncated == 0 then\n     \
    \ factor = old_factor\n      truncated = integer_part\n      decimal_count = decimals\n\
    \    end\n  end\n  return truncated, decimal_count\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  -- Decompose the given number into decimal and integer parts.\n  -- The decimal\
    \ part is always smaller than 1 (never zero).\n  local decimal = math.floor(math.abs(number))\n\
    \  local integer = math.abs(number) - decimal\n  -- Return the truncated number\
    \ to the given precision.\n  return decimal <= 0.0 and integer or integer * 10.0\
    \ / decimal\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps_ipqyrl.lua:19:\
    \ expected: 0.5, actual: 1.6666666666667\nstack traceback:\n\t/tmp/tmps_ipqyrl.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local integer, decimals = math.modf(number)\n    return integer or 0, decimals\
    \ * -1\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfe_0agio.lua:15:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpfe_0agio.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local precision = math.floor(math.log(number, 10) + 1)\n  local fraction =\
    \ number % 1\n  return math.floor(number * 10^(precision - fraction)) / 10^precision\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpglbd29sd.lua:16:\
    \ expected: 0.5, actual: 1.1\nstack traceback:\n\t/tmp/tmpglbd29sd.lua:16: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number == 0 then\n    number\n  else\n    local decimals, integer = math.modf(number)\n\
    \    integer = truncate_number(integer)\n    return integer + (decimals == 0 and\
    \ 0 or math.floor(decimals))\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpbyq41wpv.lua:10: syntax error near 'else'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer_part = math.floor(number)\n  local fractional_part = math.modf(number\
    \ - integer_part)[1]\n  if fractional_part == 0 then return integer_part end\n\
    \  return integer_part + (fractional_part - 1)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpn2i6f1wr.lua:9:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpn2i6f1wr.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpn2i6f1wr.lua:17: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    local decimals = math.floor(math.log(number,10)+1)\n\treturn math.trunc(number/10^decimals)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7vsre_tu.lua:9:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmp7vsre_tu.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmp7vsre_tu.lua:15: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number <= 0 then\n    return nil\n  else\n    local factor = 10^math.floor(math.log10(number))\n\
    \    return math.floor(number/factor) * factor\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps6h42t0u.lua:19:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmps6h42t0u.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1.0 then\n    return number, 0.0\n  end\n  local factors = math.huge\n\
    \  -- Use Freedman\u2013Diaconis algorithm for large numbers.\n  repeat\n    factors\
    \ = factors - 1\n    local floor_of_number = math.floor(number)\n    local remainder\
    \ = number - floor_of_number\n    local floor_of_factors = math.floor(factors)\n\
    \    local decimals = floor_of_factors - floor_of_number - 1\n    if decimals\
    \ ~= 0 then\n      return floor_of_number, decimals\n    end\n    number = remainder\n\
    \  until number < factors\n  return number, 0\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp827dm1qd.lua:30:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmp827dm1qd.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number * 10) / 10\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_u1lua9m.lua:14:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp_u1lua9m.lua:14: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    local dec = tonumber(string.format(\"%.\" .. DECIMAL_DIG .. \"f\", number))\n\t\
    if dec == nil then\n\t\treturn number\n\tend\n\t-- In case the original number\
    \ was too small, truncate up to the biggest\n\t-- positive number smaller than\
    \ the given number.\n\tif number < -POS_INFINITY then\n\t\treturn -POS_INFINITY\n\
    \tend\n\t-- Since truncating to an integer part will always return an integer\n\
    \t-- greater than or equal to original number, we can just compare it to the\n\
    \t-- original number.\n\tif number < trunc(number) then\n\t\treturn dec\n\tend\n\
    \treturn dec\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgpsw5ha3.lua:8:\
    \ attempt to concatenate a nil value (global 'DECIMAL_DIG')\nstack traceback:\n\
    \t/tmp/tmpgpsw5ha3.lua:8: in local 'candidate'\n\t/tmp/tmpgpsw5ha3.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local precision, decimal_part = math.modf(number)\n  return decimal_part\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number >= 1.0 and number <= 1.0 then\n    return number\n  elseif number\
    \ >= 1.0 and number <= 0 then\n    return 1.0\n  elseif number <= -1.0 then\n\
    \    return -1.0\n  else\n    local whole = math.floor(number)\n    local fraction\
    \ = number - whole\n    if whole <= 0 and fraction >= 1 then\n      return 0.0\n\
    \    elseif whole > 0 and fraction >= .5 then\n      return whole\n    else\n\
    \      return whole + fraction\n    end\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplzze4m5i.lua:30:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmplzze4m5i.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local fraction = math.modf(number)\n  local decimals = math.abs(fraction[1])\
    \ + 1\n  return fraction[1] == 0 and number or number - fraction[1] / decimals\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5q9sha4c.lua:9:\
    \ attempt to index a number value (local 'fraction')\nstack traceback:\n\t/tmp/tmp5q9sha4c.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmp5q9sha4c.lua:16: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  -- Get integer and decimal parts of number.\n  local integer_part, decimal_part\
    \ = math.modf(number)\n  -- Truncate decimal part if exceeding half of its integral\
    \ part.\n  -- This also handles the case when number is close to (integer) 1.\n\
    \  return decimal_part > 0 and decimal_part - math.floor(integer_part / 2) * 0.5\
    \ or number\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuwlso1or.lua:18:\
    \ expected: 0.5, actual: 0\nstack traceback:\n\t/tmp/tmpuwlso1or.lua:18: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  assert(type(number) == 'number')\n  assert(number > 0)\n  local integer, decimals\
    \ = math.modf(number)\n  return integer + math.trunc(decimals)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpj0dccqhn.lua:11:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmpj0dccqhn.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmpj0dccqhn.lua:17: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal_places = math.floor(math.log(number) / math.log(10) + 0.5)\n\
    \  return math.trunc(number * 10^decimal_places)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpakjl8uuu.lua:9:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmpakjl8uuu.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpakjl8uuu.lua:15: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number < 1 then return number end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmprxeb7wgv.lua:18: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local sign = math.abs(number)\n    local exponent = math.floor((math.log10(sign)\
    \ - math.log10(abs(number))) + 1)\n    local fraction = number / math.pow(10,\
    \ exponent)\n    local integer_part = math.floor((number - fraction) * math.pow(10,\
    \ exponent - 1))\n    return integer_part + fraction\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpsfhzphuc.lua:9:\
    \ attempt to call a nil value (global 'abs')\nstack traceback:\n\t/tmp/tmpsfhzphuc.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpsfhzphuc.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local n = math.floor(number)\n  if number > n then\n    return n\n  end\n \
    \ local d = math.modf(number * 2)\n  n = math.floor(d)\n  if d > n then\n    return\
    \ n\n  end\n  d = math.modf(n)\n  return math.floor(number - d * 2)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsp5hhcaw.lua:24:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpsp5hhcaw.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number)::float\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_yw81ewn.lua:8: 'end' expected (to close 'function' at line\
    \ 7) near '::'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local n = math.floor(number)\n  if n > number then\n    local decimals = math.mod(number\
    \ - n, 1)\n    return n * 10^decimals + math.max(0, decimals)\n  end\n  return\
    \ n\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpls1f9953.lua:19:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpls1f9953.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  assert(type(number) == 'number')\n  if number < 0 then\n    error(\"truncate_number:\
    \ given number must be positive\")\n  end\n  if number == 0 then\n    return number\n\
    \  end\n  local integer_part, decimal_part = math.modf(number)\n  -- Python 3\
    \ returns number as a float and Python 2 returns it as int.\n  -- This does not\
    \ affect the result since we are comparing it to a number.\n  if math.modf(number\
    \ + 1)[1] ~= 0 then\n    error(\"truncate_number: given number is not a multiple\
    \ of a \"..\n      \"power of ten\")\n  end\n  return decimal_part\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpvoed9b2r.lua:18:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpvoed9b2r.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpvoed9b2r.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    if number < 1 then return number end\n\tlocal sign = math.sign( number )\n\tnumber\
    \ = sign*math.abs(number)\n\tlocal decimals = math.modf(number)\n\tnumber = decimals[1]\n\
    \treturn sign*number\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpx1necv4i.lua:9:\
    \ attempt to call a nil value (field 'sign')\nstack traceback:\n\t/tmp/tmpx1necv4i.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpx1necv4i.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 0 then\n    return 0\n  elseif number < 1 then\n    return number\n\
    \  else\n    local _, decimals = math.modf(number)\n    return math.floor(number),\
    \ decimals\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc6mn400o.lua:21:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpc6mn400o.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number >= 1 then\n    return math.floor(number)\n  end\n  return math.ceil(number)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd67kg84n.lua:17:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpd67kg84n.lua:17: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then return number end\n  if number < 10 then return number end\n\
    \  if number < 100 then return number end\n  if number < 1000 then return number\
    \ end\n  if number < 10000 then return number end\n  if number < 100000 then return\
    \ number end\n  if number < 1000000 then return number end\n  if number < 10000000\
    \ then return number end\n  if number < 100000000 then return number end\n  if\
    \ number < 1000000000 then return number end\n  return number % 1000000000\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpek1odsi_.lua:24:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpek1odsi_.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local n = tonumber(number)\n   if n == number then\n      return number\n\
    \   end\n   if n < 0 then\n      return number\n   end\n   if n == 0 then\n  \
    \    return 0\n   end\n   local a = math.floor(n)\n   local f = math.mod(n, 1)\n\
    \   return f < 0.5 and a or a+1\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg7c47atp.lua:26:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpg7c47atp.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local decimal_part = math.modf(number - 1)\n    local integer_part = math.floor(number)\n\
    \    local decimal_part_remainder = number - integer_part\n    local decimal_part_multiplier\
    \ = 10^math.floor(math.log10(decimal_part_remainder))\n    return decimal_part_remainder\
    \ * decimal_part_multiplier\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7spx8_53.lua:18:\
    \ expected: 0.5, actual: 0.05\nstack traceback:\n\t/tmp/tmp7spx8_53.lua:18: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then return 1 end\n  local power = math.floor(math.log(number,\
    \ 1))\n  local divisor = math.pow(10, power)\n  return math.ceil(number/divisor)\
    \ * divisor\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyv9he6af.lua:17:\
    \ expected: 0.5, actual: #NaN\nstack traceback:\n\t/tmp/tmpyv9he6af.lua:17: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 0 then\n    return number\n  end\n  local decimals = math.floor(math.log(number)/math.log(10)\
    \ + 2)\n  if decimals <= 0 then\n    return math.floor(number):reverse()\n  else\n\
    \    return math.floor(number):reverse():reverse():reverse():reverse()\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpjujbvujg.lua:15:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpjujbvujg.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpjujbvujg.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1.0 then\n    return number -- already truncated\n  elseif number\
    \ < 1.0 + (10 - 1) then\n    return math.floor(number)\n  else\n    return math.floor(number\
    \ * 10 / 10.0) -- 10^(-decimal_part)\n  end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd38l3xxh.lua:20:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpd38l3xxh.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer, decimal = math.modf(number)\n  return math.round(integer - math.ldexp(decimal,\
    \ -10))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6l60aqf7.lua:9:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmp6l60aqf7.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmp6l60aqf7.lua:15: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 0 then\n    return nil\n  end\n  if number == 0 then\n    return\
    \ 0\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpg94jd743.lua:23: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number <= 0 then\n        return 0\n    end\n    local exponent = math.floor(math.log(number)/math.log(10))\n\
    \    local integer_part = math.trunc(number/math.pow(10, exponent))\n    local\
    \ decimal_part = number-integer_part*math.pow(10, exponent)\n    if decimal_part\
    \ < 1 then\n        integer_part = math.ceil(integer_part)\n        decimal_part\
    \ = math.floor(decimal_part)\n    end\n    return integer_part, decimal_part\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpa1lggu8o.lua:12:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmpa1lggu8o.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmpa1lggu8o.lua:24: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer_part = math.floor(number)\n  if integer_part == number then\n\
    \    return integer_part\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppz7frp3n.lua:21: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number >= 1 then\n    return number\n  end\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgl0zvoc_.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number >= 0 then\n        return math.floor(number)\n    end\n    return\
    \ math.ceil(number)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphwl0lae6.lua:17:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmphwl0lae6.lua:17: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local sign = math.sign(number)\n  local integer_part = math.floor(number):abs()\n\
    \  local decimal_part = number - integer_part\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpc32rf4qk.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 0 then\n    return 0\n  end\n  local factor = 1\n  local decimals\
    \ = 0\n  while number ~= 0 do\n    local digit = number % 10\n    number = math.trunc(number\
    \ / 10)\n    if factor == 10 then\n      decimals = decimals + 1\n    else\n \
    \     decimals = decimals\n    end\n    factor = factor * 10\n    number = math.trunc(number\
    \ * factor)\n  end\n  return number * factor / decimals\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpau5uf8sk.lua:15:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmpau5uf8sk.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpau5uf8sk.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    local int_part, decimal_part = math.modf(number)\n\treturn decimal_part * 100\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxl50_9ti.lua:15:\
    \ expected: 0.5, actual: 50\nstack traceback:\n\t/tmp/tmpxl50_9ti.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   if number <= 1 then return number end\n   local decimal_part = math.floor(math.log(number\
    \ - 1, 10)) + 1\n   if decimal_part == 1 then return number end\n   local integer_part\
    \ = math.floor(number) - decimal_part\n   return integer_part\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5gilfar5.lua:18:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp5gilfar5.lua:18: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  assert(type(number) == 'number', string.format('%s is not a number', number))\n\
    \  assert(number >= 0, string.format('%s is not positive', number))\n  assert(number\
    \ <= 1000000000000, string.format('%s is too large', number))\n  assert(number\
    \ % 1 == 0, string.format('%s is not an integer', number))\n  return math.floor(number):div(10^math.floor(math.log10(number)+1):ceil())\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8hzbxm_2.lua:11:\
    \ 3.5 is not an integer\nstack traceback:\n\t/tmp/tmp8hzbxm_2.lua:11: in local\
    \ 'candidate'\n\t/tmp/tmp8hzbxm_2.lua:18: in function 'test_humaneval'\n\nRan\
    \ 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number):reverse():gsub(\"[%%.]\", \"\")\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmph2oc8z1y.lua:8:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmph2oc8z1y.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmph2oc8z1y.lua:14: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal = math.modf(number)[1]\n  if decimal < 0 then\n    decimal =\
    \ decimal + 1\n  end\n  return number, decimal\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpnlacmw08.lua:8:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpnlacmw08.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpnlacmw08.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    local decimal_part = math.modf(number)\n\tnumber = decimal_part[1]\n\treturn decimal_part\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp30vj75wy.lua:9:\
    \ attempt to index a number value (local 'decimal_part')\nstack traceback:\n\t\
    /tmp/tmp30vj75wy.lua:9: in local 'candidate'\n\t/tmp/tmp30vj75wy.lua:16: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- Return 0 if number is not even number\n    -- This is not very elegant,\
    \ but this function is only for benchmarking\n    if math.mod(number, 2) ~= 0\
    \ then\n        return 0\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6qztbjd8.lua:22: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    local decimal = 0\n\twhile number >= 1 do\n\t\tdecimal = decimal + 1\n\t\tnumber\
    \ = math.floor(number * 10)\n\tend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpk_n9zl5i.lua:22: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   -- Special case: truncate to zero\n   if number == 0 then\n      return 0\n\
    \   end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7n_pu2gi.lua:21: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   -- This works, but it can have issues due to rounding issues.\n   -- For example\
    \ 2.45 would be rounded to 2.4.\n   -- Lua doesn't have built-in support for decimal\
    \ numbers\n   -- (at least not up to version 5.2), so this function doesn't work\n\
    \   -- in all cases.\n   -- Also, Lua 5.3 doesn't support floating point numbers.\n\
    \   -- So this function has issues with floats.\n   --\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.0\n   -- >>> truncate_number(2.5)\n   -- 2.0\n   --\n   -- >>> truncate_number(2.4)\n\
    \   -- 2.0\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   --\n   -- >>> truncate_number(2.6)\n   -- 2.5\n   -- >>> truncate_number(2.6)\n\
    \   -- 2.6\n   --\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   --\n   -- >>>\
    \ truncate_number(2.5)\n   -- 2.5\n   --\n   -- >>> truncate_number(2.5)\n   --\
    \ 2.5\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   --\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   --\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   --\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   --\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   --\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   --\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   -- >>> truncate_number(2.5)\n   -- 2.5\n   -- >>> truncate_number(2.5)\n\
    \   -- 2.5\n   --\n   \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpbd96c7_0.lua:98: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 0 then\n    number = -number\n  end\n  if math.floor(number) ==\
    \ number then\n    number = math.modf(number)\n  end\n  return math.floor(number[1])\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0lmw58f2.lua:14:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmp0lmw58f2.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmp0lmw58f2.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then\n    return number\n  else\n    local factor = 10\n    local\
    \ decimal_count = 0\n    while true do\n      local remainder = math.floor(number\
    \ / factor)\n      if remainder <= number then\n        factor *= 10\n       \
    \ decimal_count = decimal_count + 1\n      else\n        return math.floor(number\
    \ / factor) * math.pow(10, -decimal_count)\n      end\n    end\n  end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1nywt5v9.lua:16: syntax error near '*'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then\n    return nil\n  end\n  local remainder = math.floor((number:digits()\
    \ + number:div()) / 2)\n  return number:sub(1, number:digits() + remainder)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7k5z6wza.lua:11:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmp7k5z6wza.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmp7k5z6wza.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local int_part = math.floor(number)\n    local fraction = math.modf(number\
    \ - int_part)[1]\n    local decimal_part = math.pow(10.0, math.floor(math.log10(fraction)))\n\
    \    local decimal_part = decimal_part + fraction % decimal_part\n    return int_part\
    \ + decimal_part\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpaivojweu.lua:9:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpaivojweu.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpaivojweu.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then\n    return 0\n  end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp68lmobzm.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local result = {}\n  if number < 1 then\n    return result\n  end\n  local\
    \ factor = 1\n  for i = 1, math.floor(math.log10(number)) + 1 do\n    factor =\
    \ factor * 10\n    if number <= factor then\n      break\n    end\n  end\n  table.insert(result,\
    \ math.floor(number / factor) * factor)\n  table.insert(result, number % factor)\n\
    \  table.insert(result, math.floor(math.log10(number)))\n  return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpo_psyoat.lua:28:\
    \ expected: 0.5, actual: {0, 3.5, 0}\nstack traceback:\n\t/tmp/tmpo_psyoat.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then return 0 end\n  local decimals = math.floor(math.log(number)\
    \ / math.log(10))\n  if number <= 10 then\n    local integer_part = math.floor(number)\n\
    \    local fraction = number - integer_part\n    return integer_part, fraction,\
    \ decimals\n  else\n    local integer_part, fraction, decimals = 0, 0, 0\n   \
    \ repeat\n      integer_part = integer_part + 10\n      fraction = fraction *\
    \ (10 - integer_part) / 10\n    until integer + fraction >= number\n    return\
    \ integer_part, fraction, decimals\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7_8039rq.lua:27:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmp7_8039rq.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local digits = math.floor(math.log(number) / math.log(10) + 0.9999999999)\n\
    \  if digits == 0 then\n    return 1\n  else\n    return math.floor(number / 10^digits)\
    \ / 10^digits\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppt09yy4l.lua:19:\
    \ expected: 0.5, actual: 0\nstack traceback:\n\t/tmp/tmppt09yy4l.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number):trunc() / 100\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpawkfyef7.lua:8:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpawkfyef7.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpawkfyef7.lua:14: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local sign = math.sign( number )\n   local factor = 1\n   local integer_part\
    \ = math.floor( number )\n   local decimal_part = number - integer_part\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfru67otm.lua:21: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local fraction = math.modf(number)\n  if fraction[1] == 1 then\n    return\
    \ fraction[1]\n  end\n  return number\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpexk1mr5s.lua:9:\
    \ attempt to index a number value (local 'fraction')\nstack traceback:\n\t/tmp/tmpexk1mr5s.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpexk1mr5s.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local sign = math.abs(number)\n  local negative = sign == number\n  if negative\
    \ then\n    sign = -sign\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_scgivvf.lua:22: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    return math.floor(number + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpecjt5_00.lua:14:\
    \ expected: 0.5, actual: 4\nstack traceback:\n\t/tmp/tmpecjt5_00.lua:14: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local factor = 1\n  while number >= factor do\n    factor = factor * 10 + 1\n\
    \  end\n  local decimals = factor % 10\n  return math.floor(number/factor), decimals\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiwb1mqdf.lua:19:\
    \ expected: 0.5, actual: 0\nstack traceback:\n\t/tmp/tmpiwb1mqdf.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number <= 0 then return 0 end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8f2snb7y.lua:18: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    local intpart, decimalpart = string.match(tostring(number), \"^-?%d*(.-?)%d*$\"\
    )\n\tdecimalpart = decimalpart and tonumber(decimalpart)\n\tnumber = tonumber(intpart)\
    \ or 0\n\t-- We now have both parts, truncate the integer and convert to a float\n\
    \t-- with some rounding up (if necessary)\n\treturn math.ceil(math.round(number\
    \ * 10^decimalpart) / 10^decimalpart)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpv2rgzcry.lua:13:\
    \ attempt to perform arithmetic on a nil value (local 'decimalpart')\nstack traceback:\n\
    \t/tmp/tmpv2rgzcry.lua:13: in local 'candidate'\n\t/tmp/tmpv2rgzcry.lua:19: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local digits = tostring(number)\n  if digits == '0' then\n    return 0\n  end\n\
    \  local result = tonumber(digits)\n  if result == nil then\n    return nil\n\
    \  end\n  local n = #digits - 1\n  if n ~= 0 then\n    result = result - tonumber(sub(1,\
    \ digits))\n  end\n  if result < 0 then\n    return nil\n  end\n  local decimals\
    \ = result + tonumber(sub(n, digits))\n  return decimals\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2nk6rues.lua:18:\
    \ attempt to call a nil value (global 'sub')\nstack traceback:\n\t/tmp/tmp2nk6rues.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmp2nk6rues.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number * 10 / math.pow(10, math.floor(math.log(number, 10))+2))\
    \ / 10\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2rmwxgwq.lua:14:\
    \ expected: 0.5, actual: 0\nstack traceback:\n\t/tmp/tmp2rmwxgwq.lua:14: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- Decompose into integer part and decimal part.\n    local integer, decimals\
    \ = math.modf(number)\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfavq909q.lua:19: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 0 then\n    return nil\n  end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdqz6xty4.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number < 1 then\n        return number\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1bm6s8yg.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local fraction, integer = math.modf(number)\n    return integer + (fraction\
    \ < 1 and 1 or 0)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local decimal, integer = math.modf(number)\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1guhdrcm.lua:18: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number <= 1 then\n        return number\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfnywrvlo.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local decimal_part = math.floor((number - math.floor(number)) * 1000)\n  \
    \ return math.floor(number * 1000) / 1000 + decimal_part\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc8k_a_cn.lua:15:\
    \ expected: 0.5, actual: 503.5\nstack traceback:\n\t/tmp/tmpc8k_a_cn.lua:15: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    return math.floor(number * 10 / 10) or 1\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp32cl7bah.lua:14:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmp32cl7bah.lua:14: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then return number end\n  local remainder = math.floor((number\
    \ - 1) / 10)\n  local trunc = (number - (remainder * 10))\n  if trunc > 9 then\n\
    \    trunc = trunc - 1\n  else\n    trunc = 1\n  end\n  return remainder * 10\
    \ + trunc\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe0gco0pk.lua:22:\
    \ expected: 0.5, actual: 1\nstack traceback:\n\t/tmp/tmpe0gco0pk.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local decimals = math.floor(number)\n    local trunc_number = number - decimals\n\
    \    local remaining = 1.0\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpp18hs97r.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimals = math.floor(math.log(number)/math.log(10) + 1)\n  local integer\
    \ = math.trunc(number)\n  return integer * 10^decimals\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpd86yjsi5.lua:9:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmpd86yjsi5.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpd86yjsi5.lua:16: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number <= math.floor(native.round(number)) then\n        return number\n\
    \    end\n    return number - math.floor(number)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfe55y7bv.lua:8:\
    \ attempt to index a nil value (global 'native')\nstack traceback:\n\t/tmp/tmpfe55y7bv.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpfe55y7bv.lua:17: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer_part, decimals = math.modf(number)\n  local result = integer_part\
    \ + decimals\n  return math.floor(result)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv_01b2ht.lua:16:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpv_01b2ht.lua:16: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local decomp = math.floor(math.log(number))\n    if decomp > 3 then\n   \
    \     return math.ceil(number/10^(3-decomp))\n    else\n        return number\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnsns0vx7.lua:19:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpnsns0vx7.lua:19: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  assert(type(number) == 'number')\n  assert(number >= 0)\n  local x = math.floor(number)\n\
    \  local _, x_decimal = x:div(10^(-_G._math.modf(number)[1]))\n  if x_decimal\
    \ > 0 then\n    return number\n  else\n    return math.ceil(number - x_decimal)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpe4tam4vj.lua:11:\
    \ attempt to index a number value (local 'x')\nstack traceback:\n\t/tmp/tmpe4tam4vj.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmpe4tam4vj.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local integer = math.floor(number)\n   local decimals = math.modf(number)\n\
    \   return integer, decimals[1]\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpou_pzfnw.lua:10:\
    \ attempt to index a number value (local 'decimals')\nstack traceback:\n\t/tmp/tmpou_pzfnw.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpou_pzfnw.lua:16: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local int_part, decimal_part = math.modf(number)\n    local decimal_part\
    \ = math.floor(decimal_part)\n    if decimal_part > 1 then\n        local integer_part\
    \ = math.ceil(number)\n        decimal_part = math.round(number - integer_part\
    \ * math.pow(10, -decimal_part))\n    end\n    return int_part, decimal_part\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr0muusts.lua:20:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpr0muusts.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number <= 1 then\n        return number\n    end\n    if number ~= truncate_number(number\
    \ / 10) or number < 1 then\n        error(\"Invalid number\")\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9rc6aqbl.lua:23: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number <= 0 then\n    return 0\n  else\n    -- Truncate to integer (floor)\
    \ or fraction (ceil).\n    local factor = 10\n    local rounded = math.floor(number)\n\
    \    local fraction = math.abs(number - rounded)\n    if rounded ~= number then\n\
    \      factor = math.floor(factor / 10)\n    end\n    if factor < 1 then\n   \
    \   rounded = rounded\n    else\n      rounded = rounded + factor * 10\n    end\n\
    \    return rounded / factor\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuxjw340o.lua:30:\
    \ expected: 0.5, actual: 13\nstack traceback:\n\t/tmp/tmpuxjw340o.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal = number - math.floor(number)\n  if decimal == 0.0 and number\
    \ ~= 0.0 then\n    return number\n  elseif decimal < 0.0 and number ~= 0.0 then\n\
    \    return 0.0\n  else\n    return math.floor(number)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgu913_i9.lua:21:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpgu913_i9.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- if number is integer\n    if math.floor(number) == number then\n     \
    \   return number\n    end\n    -- if number is a decimal\n    local result =\
    \ math.modf(number)\n    -- truncate decimal\n    return math.floor(result[1]):rep(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpoxa9fc9v.lua:15:\
    \ attempt to index a number value (local 'result')\nstack traceback:\n\t/tmp/tmpoxa9fc9v.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpoxa9fc9v.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local int_part = math.floor(number)\n  if number < int_part then\n    return\
    \ number\n  else\n    return int_part + number - int_part\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmri0oqvb.lua:19:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpmri0oqvb.lua:19: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local sign = number < 0 and -1 or 1\n    local integer = math.trunc(number)\n\
    \    local decimal = number - integer\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpx90p1he0.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number == 0 then\n        return 0\n    end\n    local int_part\n    local\
    \ decimal_part = math.floor(number)\n    if decimal_part > 0 then\n        int_part\
    \ = number\n    else\n        int_part = math.ceil(number)\n    end\n    return\
    \ int_part\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkrwqu27a.lua:24:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpkrwqu27a.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- If the number is already an integer or float, just return it.\n    if\
    \ number <= math.floor(number) then\n        return number\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp0252rucq.lua:21: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number > 1 then\n    local floor_part = math.floor(number)\n    local decimal_part\
    \ = math.abs(number - floor_part)\n    return decimal_part, floor_part\n  else\n\
    \    return 0, number\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local _, fraction = math.modf(number)\n  return fraction\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- Only numbers with no decimals require further work.\n    if number ~=\
    \ math.round(number) then return number end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4rpwgdhb.lua:19: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- Only positive numbers require decimal part to be truncated as this is\n\
    \    -- used to determine the smallest possible power of ten (i.e. truncate to\n\
    \    -- nearest 0.01).\n    if number <= 0.0 then\n        error(\"Truncating\
    \ number to 0.0 is not supported\")\n    end\n    -- Exponent of given number\
    \ is the number of fractional digits to retain.\n    local exp = math.floor(math.log(number)\
    \ / math.log(10.0)) -- math.log10 returns negative number\n    -- Get smallest\
    \ power of ten that fits given number.\n    local power = math.pow(10, exp)\n\
    \    -- Return truncated number by multiplying number by 10^exp.\n    return number\
    \ * power\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8ynjw3ck.lua:25:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp8ynjw3ck.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    local digits, decimals = math.modf(number)\n\treturn math.floor(number), math.ceil(decimals)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw8oanlp9.lua:15:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpw8oanlp9.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local integer_part, decimal_part = math.modf(number)\n    return decimal_part\
    \ * 100\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoh4qvdnz.lua:15:\
    \ expected: 0.5, actual: 50\nstack traceback:\n\t/tmp/tmpoh4qvdnz.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  assert(type(number) == 'number')\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfuduafbu.lua:18: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number == 0 then\n    return 0\n  end\n  if number % 1 == 0 then\n    return\
    \ number\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpn6axier9.lua:23: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local factor = 10^math.floor(math.log(number, 10)) + 4\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdwod2wxe.lua:18: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number * 100) / 100\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwggo2leb.lua:14:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpwggo2leb.lua:14: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  -- Special cases.\n  if number <= 0 then\n    return 0\n  elseif number < 1\
    \ then\n    return number\n  elseif number % 1 == 0 then\n    return number\n\
    \  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmptaclfnzx.lua:25: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local factor = 1\n  while number >= factor do\n    factor = factor * 10\n \
    \ end\n  return number / factor\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppcw86f_4.lua:18:\
    \ expected: 0.5, actual: 0.35\nstack traceback:\n\t/tmp/tmppcw86f_4.lua:18: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    assert(type(number) == 'number', 'A number must be given')\n\tif number < 0 then\n\
    \t\treturn nil, ''\n\tend\n\tlocal integer_part, decimal_part = math.modf(number)\n\
    \treturn decimal_part, integer_part .. '.0'\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal_part = math.floor(number / 10)\n  local integer_part = number\
    \ - decimal_part * 10\n  return decimal_part, integer_part\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp619sui9q.lua:16:\
    \ expected: 0.5, actual: 0\nstack traceback:\n\t/tmp/tmp619sui9q.lua:16: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    -- The algorithm used here is very simple and is not guaranteed to be accurate.\n\
    \t-- A better algorithm can be found in a comment\n\t-- to http://mattduck.com/2010/06/24/rounding-floats-in-matlab-round-and-rnd/.\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpa2g7pk7f.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer = 0\n  local decimal = 0\n  local factor = 10\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpyoobsxrh.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  -- >>> truncate_number(3.5)\n  -- 0.5\n  local decimal_part = math.trunc(number)\n\
    \  if number >= 1 then\n    decimal_part = math.floor(decimal_part)\n  end\n \
    \ return decimal_part\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8bybczmc.lua:10:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmp8bybczmc.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmp8bybczmc.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local factor = 1\n  if number < 1 then\n    factor = 0\n  end\n  local result\
    \ = math.floor(number / factor)\n  result = math.modf(number - result * factor)\
    \ [1]\n  result = result + factor\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9wu1cmfy.lua:13:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmp9wu1cmfy.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmp9wu1cmfy.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local divisor = math.floor(math.log(number + 1, 10))\n    if divisor > 0\
    \ then\n        -- It's not possible to write a decimal without fractional part\
    \ for\n        -- a positive number. For example: 0.1 cannot be written with decimal\n\
    \        -- part for 0.\n        return number / math.pow(10, divisor)\n    end\n\
    \    return number\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmh5s1xhy.lua:21:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpmh5s1xhy.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal = math.floor(number - math.floor(number))\n  return number -\
    \ decimal\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprqwvczau.lua:15:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmprqwvczau.lua:15: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local decimal = math.floor(number / 10) * 10\n   local integer = number -\
    \ decimal\n   if integer < 10 then\n      return string.format(\"%0.f\", number)\n\
    \   else\n      return string.format(\"%0.f\", decimal)\n   end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4szd951i.lua:20:\
    \ expected: 0.5, actual: \"4\"\nstack traceback:\n\t/tmp/tmp4szd951i.lua:20: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    -- We don't want to do any truncation if the number is zero\n    if number\
    \ == 0 then\n        return 0\n    end\n    -- If number is negative, we want\
    \ to return the integer part\n    if number < 0 then\n        local result = math.floor(number)\n\
    \        if result == 0 then\n            return number\n        else\n      \
    \      return result\n        end\n    end\n    -- If number is not negative,\
    \ we want to return the number without the\n    -- decimal part (return it without\
    \ any modification).\n    -- First step: get the integer part\n    local result\
    \ = math.floor(number)\n    -- Second step: get the decimal part of the number\n\
    \    local decimal_part = number - result\n    -- And return the truncated number\
    \ with the decimal part\n    return result+decimal_part\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgf72cbwu.lua:34:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpgf72cbwu.lua:34: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local integer_part, decimal_part = math.modf(number)\n    return decimal_part\
    \ * 100\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg8e3ron3.lua:15:\
    \ expected: 0.5, actual: 50\nstack traceback:\n\t/tmp/tmpg8e3ron3.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local integer = 0\n    local decimals = 0\n    local remainder = 0\n    while\
    \ number > 0 do\n        integer = integer * 10 + number % 1\n        number =\
    \ math.floor(number / 10)\n        decimals = decimals + 1\n        remainder\
    \ = remainder + number\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpitvxncr_.lua:26: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then\n    return 1\n  end\n  return math.floor(number)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd7ky0nlh.lua:17:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpd7ky0nlh.lua:17: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local fraction = number % 1\n  local integer = math.floor(number)\n  return\
    \ integer - fraction + math.floor((integer - math.floor(integer)) * 0.1)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa9jt82er.lua:16:\
    \ expected: 0.5, actual: 2.5\nstack traceback:\n\t/tmp/tmpa9jt82er.lua:16: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local parts = tonumber(number):match(\"^(-?%d+)(.%d+)$\")\n  local integer_part\
    \ = tonumber(parts[1])\n  local decimal_part = tonumber(parts[2]) -- parts[2]\
    \ is a string and needs parsing.\n  return integer_part + (decimal_part - integer_part\
    \ * 10000) / 10000\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7_adpwu1.lua:8:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmp7_adpwu1.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmp7_adpwu1.lua:17: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  -- The result is guaranteed to be less or equal to the given number,\n  --\
    \ as we assume the number is always greater or equal to 1.\n  -- If number is\
    \ negative, return 0.\n  if number <= 0 then\n    return 0\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpty73b0qb.lua:23: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number == nil then\n    return nil\n  end\n  local digits = math.floor(math.log(number,\
    \ 10) + 1)\n  number = math.floor(number / math.pow(10, digits))\n  return math.floor(number\
    \ - math.pow(10, digits - 1)) * math.pow(10, digits)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4124_1ws.lua:19:\
    \ expected: 0.5, actual: -10\nstack traceback:\n\t/tmp/tmp4124_1ws.lua:19: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    if number < 1 then return 0 end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4mmj3m2g.lua:18: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local factor = 1\n  while number % factor ~= 0 do\n    factor = factor * 10\n\
    \  end\n  return math.floor(number/factor)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local digits = math.floor(math.log(number, 10))\n   return math.pow(10, digits)\
    \ * (number / math.pow(10, digits))\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpugt5wsvi.lua:15:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpugt5wsvi.lua:15: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number * 100) / 100\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb_fesu4n.lua:14:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpb_fesu4n.lua:14: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number < 0 then\n        return 0 -- Don't know how to deal with negative\
    \ numbers\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpc_qwt2h4.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer = math.floor(number)\n  local decimal = number - integer\n  if\
    \ decimal < 1 then\n    -- The number is smaller than 1, so return the integer\
    \ part.\n    return integer\n  elseif integer == 0 then\n    -- If the integer\
    \ part is 0, then the decimal part is 0.\n    -- Return 1 because 0 is the decimal\
    \ part of 0.\n    return 1\n  end\n  return decimal\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxn8xxcbg.lua:24:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpxn8xxcbg.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local remainder, result = math.modf(number)\n    if remainder > 0 then\n\
    \        if number > 0 then\n            return result\n        else\n       \
    \     return 1\n        end\n    else\n        return result\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local integer, decimal = math.floor(number), math.modf(number)\n    if decimal\
    \ > 1.0 then\n        integer, decimal = math.ceil(integer), math.ceil(decimal)\n\
    \    end\n    return integer + decimal\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx5yb99f6.lua:18:\
    \ expected: 0.5, actual: 6\nstack traceback:\n\t/tmp/tmpx5yb99f6.lua:18: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  return math.floor(number * 100) / 100\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4oqse3y4.lua:14:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp4oqse3y4.lua:14: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then return 0 end\n  local decimals = math:floor((math:floor(math:log10(number))\
    \ - 2) / 3)\n  local integer_part = math:floor(math:log10(number))\n  if integer_part\
    \ == 0 then return 0 end\n  return number - integer_part * math:pow(10.0, decimals)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0an511fv.lua:9:\
    \ calling 'log10' on bad self (number expected, got table)\nstack traceback:\n\
    \t/tmp/tmp0an511fv.lua:9: in local 'candidate'\n\t/tmp/tmp0an511fv.lua:18: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number <= 1 then return number end\n  local factor, integer = math.modf(number)\n\
    \  return factor + 0.5\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8lqi3cva.lua:16:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp8lqi3cva.lua:16: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimals = 0\n  if number <= 0 then return 0 end\n  decimals = math.floor(math.log(number,\
    \ 10) + 1)\n  return math.pow(10, -decimals) * number\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv6fnlb8z.lua:17:\
    \ expected: 0.5, actual: 0.35\nstack traceback:\n\t/tmp/tmpv6fnlb8z.lua:17: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local decimal_part = tonumber(number)\n    if decimal_part < 1 then\n   \
    \     return math.ceil(number), 1\n    else\n        local integer_part, decimal_part\
    \ = math.modf(number)\n        return integer_part, decimal_part\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfz_af7p4.lua:20:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpfz_af7p4.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local factor = 1\n   local factorfactor = 1\n   if number % 1 ~= 0 then\n\
    \      local digits = math.floor(math.log(number, 10) + 1)\n      if digits >\
    \ 15 then\n         return nil -- number too big to fit\n      elseif digits <\
    \ -15 then\n         return nil -- number too small to fit\n      else\n     \
    \    factor = math.pow(10, digits)\n      end\n   end\n   local remainder = number:rem(1)\n\
    \   if remainder >= 1 then\n      local floor_of_remainder = math.floor(remainder)\n\
    \      if floor_of_remainder < factorfactor then\n         factorfactor = -factorfactor\n\
    \      else\n         factorfactor = -factor\n      end\n   end\n   return remainder\
    \ * factor + factorfactor\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp3v7lagzd.lua:20:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmp3v7lagzd.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmp3v7lagzd.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local decimal_part = tonumber(number)\n  if decimal_part == nil then\n    return\
    \ nil, nil\n  end\n  local integer_part, decimals_part = math.modf(number)\n \
    \ if integer_part == nil then\n    return nil, nil\n  end\n  return decimal_part,\
    \ integers_part\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpngyp5r0t.lua:22:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpngyp5r0t.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then\n    return 0\n  elseif number < 10 then\n    -- Decompose\
    \ number into integer part and decimal part.\n    local integer_part, decimal_part\
    \ = math.modf(number)\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpxttewu2f.lua:22: 'end' expected (to close 'if' at line 8)\
    \ near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local decimal, integer = math.modf(number)\n    if integer < 1 then\n   \
    \     return decimal\n    else\n        return number\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpooyp7ui9.lua:19:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpooyp7ui9.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local digit, decimals = math.modf(number)\n   return tonumber(digit), decimals\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw8rex786.lua:15:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmpw8rex786.lua:15: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number < 1 then\n    return number\n  end\n  local integer_part\n  if math.fmod(number,\
    \ 1) == 0 then\n    integer_part = math.floor(number)\n  else\n    integer_part\
    \ = math.ceil(number)\n  end\n  local decimal_part = number - integer_part\n \
    \ return decimal_part\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuepvd710.lua:24:\
    \ expected: 0.5, actual: -0.5\nstack traceback:\n\t/tmp/tmpuepvd710.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    local decimal = math.floor(math.abs(number))\n\tif decimal ~= number then\n\t\t\
    decimal = math.floor(decimal)\n\tend\n\tif number < 1 then\n\t\treturn 0\n\telseif\
    \ decimal == 0 then\n\t\treturn 1\n\telse\n\t\treturn decimal\n\tend\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppwb7p5j0.lua:24:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmppwb7p5j0.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   local decimals = math.modf(number * 10^decimals)[1]\n   return tonumber(string.format(\"\
    %0.*f\", decimals, number))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmppf0ffpcd.lua:8:\
    \ attempt to perform arithmetic on a nil value (global 'decimals')\nstack traceback:\n\
    \t/tmp/tmppf0ffpcd.lua:8: in local 'candidate'\n\t/tmp/tmppf0ffpcd.lua:15: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integerPart = math.floor(number)\n  local decimalPart = math.floor(number\
    \ - integerPart)\n  return integerPart, decimalPart\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3djivjxd.lua:16:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmp3djivjxd.lua:16: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number < 0 then\n        error(\"number must be positive\")\n    end\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpiynbhohv.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number < 0 then\n        return nil, nil\n    end\n    local num = math.floor(n)\n\
    \    local d = n - num\n    return num, d\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpvt1jtinh.lua:11:\
    \ bad argument #1 to 'floor' (number expected, got nil)\nstack traceback:\n\t\
    /tmp/tmpvt1jtinh.lua:11: in local 'candidate'\n\t/tmp/tmpvt1jtinh.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local integer = math.floor(number)\n    local decimal = number - integer\n\
    \    return integer + decimal\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpool1eqdt.lua:16:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpool1eqdt.lua:16: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  assert(type(number) == \"number\", \"TruncateNumber: input is not a number\"\
    )\n  if number <= math.floor_number(number) then\n    return number\n  else\n\
    \    local m = math.modf(math.abs(number))\n    return math.floor(m.r * 100 +\
    \ m.i) * 1.0 / 100.0\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpwjd5rd3v.lua:9:\
    \ attempt to call a nil value (field 'floor_number')\nstack traceback:\n\t/tmp/tmpwjd5rd3v.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpwjd5rd3v.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer -- integer part\n  local decimal -- decimal part\n  local decimal_places\
    \ -- number of decimal places left (always smaller than 1)\n  local decomposite\
    \ -- decomposed number if an integer part and decimal part are found\n  -- The\
    \ number is decomposed into integer part and decimal part separately\n  local\
    \ decimal_part\n  local integer_part\n  local sign = 1\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4mj_qxsu.lua:25: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local integer_part\n  local decimal_part\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9o82j3hp.lua:19: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local factor = 1\n  -- if number is negative, get it's absolute value\n  if\
    \ number < 0 then\n    number = math.abs(number)\n    factor = 1\n  end\n  local\
    \ number = math.floor(number * factor) / factor\n  -- if number is smaller than\
    \ 1, return the whole number\n  if number < 1 then\n    return number\n  end\n\
    \  -- otherwise return number as a decimal\n  return number\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmponeya655.lua:26:\
    \ expected: 0.5, actual: 3\nstack traceback:\n\t/tmp/tmponeya655.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local div = math.floor(number)\n    local mod = math.modf(number)\n    local\
    \ decimals = mod[1]\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpg05fwqih.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if math.type(number) == 'number' then\n    return math.floor(number)\n  elseif\
    \ type(number) == 'table' then\n    local number_table = {}\n    for key, val\
    \ in pairs(number) do\n      number_table[key] = truncate_number(val)\n    end\n\
    \    return number_table\n  end\n  return number\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjaipkt32.lua:23:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmpjaipkt32.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if math.floor(number) ~= number then\n    return math.floor(number)\n  end\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpqh34bo7z.lua:20: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   assert(number >= 0 and number <= 1, \"Truncating number is not possible, number\
    \ must be in [0, 1] range\")\n   local integerPart, decimalPart = math.modf(number)\n\
    \   if decimalPart > 1 then -- In case there are decimals\n      return truncate_number(integerPart)\n\
    \   else\n      return integerPart\n   end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5hjl7g76.lua:8:\
    \ Truncating number is not possible, number must be in [0, 1] range\nstack traceback:\n\
    \t/tmp/tmp5hjl7g76.lua:8: in local 'candidate'\n\t/tmp/tmp5hjl7g76.lua:20: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  if number == 0 then return 0 end\n  if number < 1 then return nil end\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpd1o7jq5r.lua:19: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   if number < 1 then\n      return 1\n   elseif number < 0 then\n      return\
    \ nil\n   else\n      local trunc = math.trunc(number)\n      return math.floor(number)\
    \ - trunc + trunc/10\n   end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n\
    \    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpv2udx42t.lua:13:\
    \ attempt to call a nil value (field 'trunc')\nstack traceback:\n\t/tmp/tmpv2udx42t.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpv2udx42t.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   assert(type(number) == 'number')\n   local decimals = math.floor(math.log(number)\
    \ / math.log(10))\n   local pow10 = 10 ** decimals\n   local decimal, integer\
    \ = math.modf(number)\n   integer = integer * pow10\n   if integer < 1 then\n\
    \      return math.floor(number)\n   else\n      return integer\n   end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpbzl6n5p0.lua:10: unexpected symbol near '*'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\t\
    local result = math.floor(number)\n\tlocal fraction = math.modf(number - result)\n\
    \treturn result + math.abs(fraction[1]) * math.pow(10, math.floor(math.log10(math.abs(fraction[1]))))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptppfcl4j.lua:10:\
    \ attempt to index a number value (local 'fraction')\nstack traceback:\n\t/tmp/tmptppfcl4j.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmptppfcl4j.lua:16: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number <= 0 then\n        return 0\n    end\n    local part1, part2 =\
    \ math.modf(number)\n    local decimals = math.abs(part2)\n    return part1 *\
    \ 10^decimals\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwg15ex_f.lua:19:\
    \ expected: 0.5, actual: 9.4868329805051\nstack traceback:\n\t/tmp/tmpwg15ex_f.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  -- We use the algorithm described here: http://www.exploringbinary.com/floating-point-converter/\n\
    \  -- We first decompose the number into an integer part, the decimal part,\n\
    \  -- then we return the decimal part.\n  return math.floor((number - (math.floor(number\
    \ - math.ldexp(1.0, number))) .. 1)) * math.ldexp(1.0, number)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_2s6m9lq.lua:11:\
    \ bad argument #2 to 'ldexp' (number has no integer representation)\nstack traceback:\n\
    \t/tmp/tmp_2s6m9lq.lua:11: in local 'candidate'\n\t/tmp/tmp_2s6m9lq.lua:17: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   -- Round down.\n   if number < 1 then\n      return 1\n   end\n   if number\
    \ < 10 then\n      return number\n   end\n   if math.fmod(number, 1) ~= 0 then\n\
    \      local decimal_part = math.modf(number)\n      local integer_part = math.floor(number)\n\
    \      return integer_part * 10 + decimal_part[1]\n   else\n      return math.floor(number)\n\
    \   end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2_g4fzn9.lua:27:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp2_g4fzn9.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    if number < 1 then return 1 end\n    if number < 10 then return number end\n\
    \    local decimals = math.floor(math.log(number, 10))\n    local integer_part\
    \ = math.trunc(number)\n    return integer_part * 10^decimals\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5),\
    \ 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0),\
    \ 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp89bw1nj6.lua:18:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmp89bw1nj6.lua:18: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \   assert(type(number) ~= 'table')\n   local is_negative = number < 0\n   number\
    \ = tonumber(number)\n   assert(type(number) == 'number' and number > 0)\n   local\
    \ factor = 1\n   local digits = 0\n   local trunc_number = number\n   while trunc_number\
    \ >= 1 do\n      digits = digits + 1\n      trunc_number = trunc_number * factor\n\
    \      factor = factor * 10\n   end\n   assert(digits > 0 and digits <= 20)\n\
    \   if trunc_number == 0 then\n      if is_negative then\n\t return -number\n\
    \      else\n\t return number\n      end\n   else\n      local factor = 1\n  \
    \    local trunc_number = number\n      while trunc_number >= 1 do\n\t digits\
    \ = digits - 1\n\t trunc_number = trunc_number / factor\n\t factor = factor *\
    \ 10\n      end\n      assert(digits > 0 and digits <= 20)\n      if is_negative\
    \ then\n\t return -number\n      else\n\t return number\n      end\n   end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps1ysjgz8.lua:47:\
    \ expected: 0.5, actual: 3.5\nstack traceback:\n\t/tmp/tmps1ysjgz8.lua:47: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \    local decimal_part = math.modf(number - math_floor(0.1, number))\n    --\
    \ Make sure decimal part is always smaller than 1.\n    -- This is needed, because\
    \ the decimal point may be replaced by\n    -- rounding.\n    if decimal_part.magnitude\
    \ > 1 then\n        decimal_part = 1\n    else\n        decimal_part = math_floor(decimal_part.magnitude)\n\
    \    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpi9ptjed0.lua:26: 'end' expected (to close 'function' at line\
    \ 7) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive floating point number, it can be decomposed into\n\
    -- and integer part (largest integer smaller than given number) and decimals\n\
    -- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
    -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n\
    \  local parts = tonumber(string.format(\"%.*f\", math.floor(math.log10(number)),\
    \ number))\n  return parts > 0 and number / math.pow(10, parts - 1) or 0\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
    \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
    \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpoi27s6an.lua:8:\
    \ invalid option '%*' to 'format'\nstack traceback:\n\t/tmp/tmpoi27s6an.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpoi27s6an.lua:15: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
